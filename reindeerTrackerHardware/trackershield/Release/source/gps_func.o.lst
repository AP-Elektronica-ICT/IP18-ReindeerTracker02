   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"gps_func.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.printUbxResponseHex,"ax",%progbits
  18              		.align	1
  19              		.global	printUbxResponseHex
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	printUbxResponseHex:
  26              	.LFB1:
  27              		.file 1 "../source/gps_func.c"
   1:../source/gps_func.c **** /*
   2:../source/gps_func.c ****  * gps_func.c
   3:../source/gps_func.c ****  *
   4:../source/gps_func.c ****  *  Created on: Mar 15, 2018
   5:../source/gps_func.c ****  *      Author: nks
   6:../source/gps_func.c ****  */
   7:../source/gps_func.c **** 
   8:../source/gps_func.c **** #include <string.h>
   9:../source/gps_func.c **** #include <stdio.h>
  10:../source/gps_func.c **** #include <stdlib.h>
  11:../source/gps_func.c **** 
  12:../source/gps_func.c **** #include "gps_func.h"
  13:../source/gps_func.c **** #include "at_func.h"
  14:../source/gps_func.c **** 
  15:../source/gps_func.c **** 
  16:../source/gps_func.c **** 
  17:../source/gps_func.c **** /*
  18:../source/gps_func.c ****  *
  19:../source/gps_func.c ****  * Print UBX response message as hex numbers
  20:../source/gps_func.c ****  * cannot print it normally by printf because it contains 0x00 as data
  21:../source/gps_func.c ****  */
  22:../source/gps_func.c **** 
  23:../source/gps_func.c **** void printUbxResponseHex(char* data, uint8_t dataLength)
  24:../source/gps_func.c **** {
  28              		.loc 1 24 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 70B5     		push	{r4, r5, r6, lr}
  34              		.cfi_def_cfa_offset 16
  35              		.cfi_offset 4, -16
  36              		.cfi_offset 5, -12
  37              		.cfi_offset 6, -8
  38              		.cfi_offset 14, -4
  39 0002 0139     		subs	r1, r1, #1
  40              	.LVL1:
  41              	.LBB2:
  25:../source/gps_func.c **** 	for (uint8_t n = 0; n < dataLength; n++)
  26:../source/gps_func.c **** 	{
  27:../source/gps_func.c **** 		printf("%02x ", (uint8_t) (*(data + n)));
  42              		.loc 1 27 0
  43 0004 054E     		ldr	r6, .L4
  44 0006 451E     		subs	r5, r0, #1
  45 0008 4418     		adds	r4, r0, r1
  46              	.LVL2:
  47              	.L2:
  25:../source/gps_func.c **** 	for (uint8_t n = 0; n < dataLength; n++)
  48              		.loc 1 25 0 discriminator 1
  49 000a A542     		cmp	r5, r4
  50 000c 00D1     		bne	.L3
  51              	.LBE2:
  28:../source/gps_func.c **** 	}
  29:../source/gps_func.c **** }
  52              		.loc 1 29 0
  53 000e 70BD     		pop	{r4, r5, r6, pc}
  54              	.LVL3:
  55              	.L3:
  56              	.LBB3:
  27:../source/gps_func.c **** 	}
  57              		.loc 1 27 0 discriminator 3
  58 0010 15F8011F 		ldrb	r1, [r5, #1]!	@ zero_extendqisi2
  59              	.LVL4:
  60 0014 3046     		mov	r0, r6
  61 0016 FFF7FEFF 		bl	printf
  62              	.LVL5:
  63 001a F6E7     		b	.L2
  64              	.L5:
  65              		.align	2
  66              	.L4:
  67 001c 00000000 		.word	.LC0
  68              	.LBE3:
  69              		.cfi_endproc
  70              	.LFE1:
  72              		.section	.text.calcUbxCrc,"ax",%progbits
  73              		.align	1
  74              		.global	calcUbxCrc
  75              		.syntax unified
  76              		.thumb
  77              		.thumb_func
  78              		.fpu fpv4-sp-d16
  80              	calcUbxCrc:
  81              	.LFB2:
  30:../source/gps_func.c **** 
  31:../source/gps_func.c **** uint8_t calcUbxCrc(char *data)
  32:../source/gps_func.c **** {
  82              		.loc 1 32 0
  83              		.cfi_startproc
  84              		@ args = 0, pretend = 0, frame = 0
  85              		@ frame_needed = 0, uses_anonymous_args = 0
  86              	.LVL6:
  87 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  88              		.cfi_def_cfa_offset 24
  89              		.cfi_offset 4, -24
  90              		.cfi_offset 5, -20
  91              		.cfi_offset 6, -16
  92              		.cfi_offset 7, -12
  93              		.cfi_offset 8, -8
  94              		.cfi_offset 14, -4
  33:../source/gps_func.c **** 
  34:../source/gps_func.c **** 	uint8_t ck_a = 0, ck_b = 0, n = 0;
  35:../source/gps_func.c **** 
  36:../source/gps_func.c **** 	while (data[n] != 0x0d) //figure out length of input message by finding CR line end char
  95              		.loc 1 36 0
  96 0004 0023     		movs	r3, #0
  32:../source/gps_func.c **** 
  97              		.loc 1 32 0
  98 0006 0546     		mov	r5, r0
  99              	.LVL7:
 100              	.L7:
 101 0008 DCB2     		uxtb	r4, r3
 102              	.LVL8:
 103              		.loc 1 36 0
 104 000a 2919     		adds	r1, r5, r4
 105 000c 2A57     		ldrsb	r2, [r5, r4]
 106 000e 0D2A     		cmp	r2, #13
 107 0010 03F10103 		add	r3, r3, #1
 108 0014 F8D1     		bne	.L7
 109 0016 0023     		movs	r3, #0
 110 0018 2E46     		mov	r6, r5
 111 001a 1A46     		mov	r2, r3
 112              	.LVL9:
 113              	.L8:
  37:../source/gps_func.c **** 	{
  38:../source/gps_func.c **** 		n++;
  39:../source/gps_func.c **** 	}
  40:../source/gps_func.c **** 
  41:../source/gps_func.c **** 	uint8_t dataLength = n;
  42:../source/gps_func.c **** 
  43:../source/gps_func.c **** 	for (n = 0; n < dataLength; n++)//calculate checksum for dataLength bytes
 114              		.loc 1 43 0 discriminator 1
 115 001c 701B     		subs	r0, r6, r5
 116 001e C0B2     		uxtb	r0, r0
 117 0020 8442     		cmp	r4, r0
 118 0022 0ED8     		bhi	.L9
  44:../source/gps_func.c **** 	{
  45:../source/gps_func.c **** 		ck_a = ck_a + data[n];
  46:../source/gps_func.c **** 		ck_b = ck_b + ck_a;
  47:../source/gps_func.c **** 	}
  48:../source/gps_func.c **** 
  49:../source/gps_func.c **** 	data[n] = ck_a; //add checksum to end of data string
  50:../source/gps_func.c **** 	data[n + 1] = ck_b;
 119              		.loc 1 50 0
 120 0024 4B70     		strb	r3, [r1, #1]
  51:../source/gps_func.c **** 	data[n + 2] = 0;	//add a zero to terminate string
  52:../source/gps_func.c **** 
  53:../source/gps_func.c **** 	for (n = 0; n < (dataLength + 2); n++) //debug print our complete message
  54:../source/gps_func.c **** 	{
  55:../source/gps_func.c **** 		printf("%02x ", (uint8_t) data[n]);
 121              		.loc 1 55 0
 122 0026 DFF83480 		ldr	r8, .L13
  49:../source/gps_func.c **** 	data[n + 1] = ck_b;
 123              		.loc 1 49 0
 124 002a 0A70     		strb	r2, [r1]
  51:../source/gps_func.c **** 	data[n + 2] = 0;	//add a zero to terminate string
 125              		.loc 1 51 0
 126 002c 0023     		movs	r3, #0
 127              	.LVL10:
 128 002e 8B70     		strb	r3, [r1, #2]
 129              	.LVL11:
  53:../source/gps_func.c **** 	{
 130              		.loc 1 53 0
 131 0030 661C     		adds	r6, r4, #1
 132              	.LVL12:
 133              	.L10:
 134 0032 5F1C     		adds	r7, r3, #1
  53:../source/gps_func.c **** 	{
 135              		.loc 1 53 0 is_stmt 0 discriminator 1
 136 0034 DBB2     		uxtb	r3, r3
 137 0036 9E42     		cmp	r6, r3
 138 0038 0ADA     		bge	.L11
  56:../source/gps_func.c **** 	}
  57:../source/gps_func.c **** 
  58:../source/gps_func.c **** 	return dataLength + 4;
 139              		.loc 1 58 0 is_stmt 1
 140 003a 201D     		adds	r0, r4, #4
  59:../source/gps_func.c **** }
 141              		.loc 1 59 0
 142 003c C0B2     		uxtb	r0, r0
 143 003e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 144              	.LVL13:
 145              	.L9:
  45:../source/gps_func.c **** 		ck_b = ck_b + ck_a;
 146              		.loc 1 45 0 discriminator 3
 147 0042 16F9010B 		ldrsb	r0, [r6], #1
 148              	.LVL14:
 149 0046 0244     		add	r2, r2, r0
 150              	.LVL15:
 151 0048 D2B2     		uxtb	r2, r2
 152              	.LVL16:
  46:../source/gps_func.c **** 	}
 153              		.loc 1 46 0 discriminator 3
 154 004a 1344     		add	r3, r3, r2
 155              	.LVL17:
 156 004c DBB2     		uxtb	r3, r3
 157              	.LVL18:
 158 004e E5E7     		b	.L8
 159              	.LVL19:
 160              	.L11:
  55:../source/gps_func.c **** 	}
 161              		.loc 1 55 0 discriminator 3
 162 0050 E95C     		ldrb	r1, [r5, r3]	@ zero_extendqisi2
 163 0052 4046     		mov	r0, r8
 164 0054 FFF7FEFF 		bl	printf
 165              	.LVL20:
 166 0058 3B46     		mov	r3, r7
 167 005a EAE7     		b	.L10
 168              	.L14:
 169              		.align	2
 170              	.L13:
 171 005c 00000000 		.word	.LC0
 172              		.cfi_endproc
 173              	.LFE2:
 175              		.section	.text.parseData,"ax",%progbits
 176              		.align	1
 177              		.global	parseData
 178              		.syntax unified
 179              		.thumb
 180              		.thumb_func
 181              		.fpu fpv4-sp-d16
 183              	parseData:
 184              	.LFB4:
  60:../source/gps_func.c **** 
  61:../source/gps_func.c **** uint8_t getGPS()
  62:../source/gps_func.c **** {
  63:../source/gps_func.c **** 
  64:../source/gps_func.c **** 	uint8_t counter = 0;
  65:../source/gps_func.c **** 
  66:../source/gps_func.c **** 	char GLL_ID[10];	// GLL Message ID $GPGLL
  67:../source/gps_func.c **** 	char latitude[15];
  68:../source/gps_func.c **** 	char northSouth[2];	// Indicates North / South, N = north, S = south
  69:../source/gps_func.c **** 	char longitude[15];
  70:../source/gps_func.c **** 	char eastWest[2];	// Indicates East / West, E = east, W = west
  71:../source/gps_func.c **** 	char time[10];		// UTC Time
  72:../source/gps_func.c **** 	char status[2];	// Status indicates data validity V = Data invalid or receiver warning, A = data v
  73:../source/gps_func.c **** 	char posMode[2];	// Positioning mode according to NMEA protocol
  74:../source/gps_func.c **** 	char checkSum[10];
  75:../source/gps_func.c **** 
  76:../source/gps_func.c **** 	char* GPS_dataPtrs[9] =
  77:../source/gps_func.c **** 	{ GLL_ID, latitude, northSouth, longitude, eastWest, time, status, posMode,
  78:../source/gps_func.c **** 			checkSum };
  79:../source/gps_func.c **** 
  80:../source/gps_func.c **** 	char* gllStart = strstr(GPS_recBuf, "NGLL"); //get starting pointer of GLL string
  81:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
  82:../source/gps_func.c **** 
  83:../source/gps_func.c **** 	if (gllStart != NULL) //check if GLL string is found
  84:../source/gps_func.c **** 	{
  85:../source/gps_func.c **** 
  86:../source/gps_func.c **** 		char* gllEnd = strstr(gllStart, "\r\n"); //get end of GLL string
  87:../source/gps_func.c **** 
  88:../source/gps_func.c **** 		if (gllEnd != NULL)
  89:../source/gps_func.c **** 
  90:../source/gps_func.c **** 		{
  91:../source/gps_func.c **** 			*(gllEnd + 2) = 0; //write 0 to end of GLL string so string functions will stop correctly
  92:../source/gps_func.c **** 			printf("GLL string %s\r\n", gllStart);
  93:../source/gps_func.c **** 		}
  94:../source/gps_func.c **** 
  95:../source/gps_func.c **** 		uint8_t gllLength = strlen(gllStart);
  96:../source/gps_func.c **** 		char* gllStringPtr = gllStart;
  97:../source/gps_func.c **** 
  98:../source/gps_func.c **** 		/*
  99:../source/gps_func.c **** 		 * Here own function is used instead of strtok to splice the string
 100:../source/gps_func.c **** 		 *
 101:../source/gps_func.c **** 		 */
 102:../source/gps_func.c **** 		while (*gllStringPtr)
 103:../source/gps_func.c **** 		{
 104:../source/gps_func.c **** 
 105:../source/gps_func.c **** 			if (*gllStringPtr == ',') //if comma is found
 106:../source/gps_func.c **** 			{
 107:../source/gps_func.c **** 				*gllStringPtr = 0; //put 0 to comma's place
 108:../source/gps_func.c **** 				GPS_dataPtrs[counter] = gllStart; //save this string token to variable
 109:../source/gps_func.c **** 				counter++;
 110:../source/gps_func.c **** 				gllStart = gllStringPtr + 1; //move gllStart so it points to the next char after the comma
 111:../source/gps_func.c **** 
 112:../source/gps_func.c **** 			}
 113:../source/gps_func.c **** 
 114:../source/gps_func.c **** 			gllStringPtr++;
 115:../source/gps_func.c **** 
 116:../source/gps_func.c **** 		}
 117:../source/gps_func.c **** 
 118:../source/gps_func.c **** 		if (strstr(GPS_dataPtrs[6], "A") != NULL)
 119:../source/gps_func.c **** 		{
 120:../source/gps_func.c **** 			printf("Got GPS\r\n");
 121:../source/gps_func.c **** 			parseData(GPS_dataPtrs[1], GPS_dataPtrs[3]);
 122:../source/gps_func.c **** 			return 1;
 123:../source/gps_func.c **** 		}
 124:../source/gps_func.c **** 
 125:../source/gps_func.c **** 		else if (strstr(GPS_dataPtrs[6], "V") != NULL)
 126:../source/gps_func.c **** 		{
 127:../source/gps_func.c **** 			printf("Data invalid, waiting for valid data\r\n");
 128:../source/gps_func.c **** 		}
 129:../source/gps_func.c **** 
 130:../source/gps_func.c **** 		for (uint8_t cnr = 0; cnr < 7; cnr++)
 131:../source/gps_func.c **** 		{
 132:../source/gps_func.c **** 			printf("%s\r\n", GPS_dataPtrs[cnr]);
 133:../source/gps_func.c **** 		}
 134:../source/gps_func.c **** 
 135:../source/gps_func.c **** 	}
 136:../source/gps_func.c **** 
 137:../source/gps_func.c **** 	if (gsvStart != NULL) //if GSV string is found, print it
 138:../source/gps_func.c **** 	{
 139:../source/gps_func.c **** 		char* gsvEnd = strstr(gsvStart, "\r\n");
 140:../source/gps_func.c **** 
 141:../source/gps_func.c **** 		if (gsvEnd != NULL)
 142:../source/gps_func.c **** 		{
 143:../source/gps_func.c **** 
 144:../source/gps_func.c **** 			*(gsvEnd + 2) = 0;
 145:../source/gps_func.c **** 			printf("GSV string %s\r\n", gsvStart);
 146:../source/gps_func.c **** 
 147:../source/gps_func.c **** 		}
 148:../source/gps_func.c **** 	}
 149:../source/gps_func.c **** 
 150:../source/gps_func.c **** 	return 0;
 151:../source/gps_func.c **** 	//}
 152:../source/gps_func.c **** }
 153:../source/gps_func.c **** 
 154:../source/gps_func.c **** void parseData(char* latStr, char* lonStr)
 155:../source/gps_func.c **** {
 185              		.loc 1 155 0
 186              		.cfi_startproc
 187              		@ args = 0, pretend = 0, frame = 0
 188              		@ frame_needed = 0, uses_anonymous_args = 0
 189              	.LVL21:
 190 0000 70B5     		push	{r4, r5, r6, lr}
 191              		.cfi_def_cfa_offset 16
 192              		.cfi_offset 4, -16
 193              		.cfi_offset 5, -12
 194              		.cfi_offset 6, -8
 195              		.cfi_offset 14, -4
 156:../source/gps_func.c **** 
 157:../source/gps_func.c **** 	uint8_t d_ptr = 0;
 158:../source/gps_func.c **** 
 159:../source/gps_func.c **** 	const char s = '.';
 160:../source/gps_func.c **** 
 161:../source/gps_func.c **** 	char* delPtr;
 162:../source/gps_func.c **** 
 163:../source/gps_func.c **** 	/*
 164:../source/gps_func.c **** 	 * swap comma from ddmm.mmm to dd.mmmmm
 165:../source/gps_func.c **** 	 */
 166:../source/gps_func.c **** 
 167:../source/gps_func.c **** 	latStr[4] = latStr[3];
 196              		.loc 1 167 0
 197 0002 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 198 0004 0371     		strb	r3, [r0, #4]
 168:../source/gps_func.c **** 	latStr[3] = latStr[2];
 199              		.loc 1 168 0
 200 0006 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 201 0008 C370     		strb	r3, [r0, #3]
 169:../source/gps_func.c **** 	latStr[2] = '.';
 202              		.loc 1 169 0
 203 000a 2E23     		movs	r3, #46
 204 000c 8370     		strb	r3, [r0, #2]
 170:../source/gps_func.c **** 
 171:../source/gps_func.c **** 	lonStr[5] = lonStr[4];
 205              		.loc 1 171 0
 206 000e 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
 207 0010 4A71     		strb	r2, [r1, #5]
 172:../source/gps_func.c **** 	lonStr[4] = lonStr[3];
 208              		.loc 1 172 0
 209 0012 CA78     		ldrb	r2, [r1, #3]	@ zero_extendqisi2
 210 0014 0A71     		strb	r2, [r1, #4]
 173:../source/gps_func.c **** 	lonStr[3] = '.';
 211              		.loc 1 173 0
 212 0016 CB70     		strb	r3, [r1, #3]
 174:../source/gps_func.c **** 
 175:../source/gps_func.c **** 	printf("latstr %s lonstr %s\r\n",latStr,lonStr);
 213              		.loc 1 175 0
 214 0018 0A46     		mov	r2, r1
 155:../source/gps_func.c **** 
 215              		.loc 1 155 0
 216 001a 0546     		mov	r5, r0
 217 001c 0C46     		mov	r4, r1
 218              		.loc 1 175 0
 219 001e 0146     		mov	r1, r0
 220              	.LVL22:
 221 0020 2448     		ldr	r0, .L28
 222              	.LVL23:
 223 0022 FFF7FEFF 		bl	printf
 224              	.LVL24:
 176:../source/gps_func.c **** 
 177:../source/gps_func.c **** 	while (latStr[d_ptr] == '0')
 225              		.loc 1 177 0
 226 0026 0023     		movs	r3, #0
 227              	.LVL25:
 228              	.L16:
 229 0028 DAB2     		uxtb	r2, r3
 230 002a A918     		adds	r1, r5, r2
 231 002c AA56     		ldrsb	r2, [r5, r2]
 232 002e 302A     		cmp	r2, #48
 233 0030 03F10103 		add	r3, r3, #1
 234              	.LVL26:
 235 0034 F8D0     		beq	.L16
 178:../source/gps_func.c **** 	{		// Skip all zeroes from beginning of string
 179:../source/gps_func.c **** 		d_ptr++;
 180:../source/gps_func.c **** 	}
 181:../source/gps_func.c **** 
 182:../source/gps_func.c **** 	strcpy(parsedLat, latStr + d_ptr);// Copy string without zeroes to new string
 236              		.loc 1 182 0
 237 0036 2048     		ldr	r0, .L28+4
 238 0038 FFF7FEFF 		bl	strcpy
 239              	.LVL27:
 183:../source/gps_func.c **** 
 184:../source/gps_func.c **** 	d_ptr = 0;
 185:../source/gps_func.c **** 
 186:../source/gps_func.c **** 	delPtr = strchr(parsedLat, s);
 240              		.loc 1 186 0
 241 003c 2E21     		movs	r1, #46
 242 003e 1E48     		ldr	r0, .L28+4
 243 0040 FFF7FEFF 		bl	strchr
 244              	.LVL28:
 187:../source/gps_func.c **** 	delPtr++;
 245              		.loc 1 187 0
 246 0044 0130     		adds	r0, r0, #1
 247              	.LVL29:
 248              	.L17:
 249 0046 0646     		mov	r6, r0
 250              	.LVL30:
 251 0048 0130     		adds	r0, r0, #1
 252              	.LVL31:
 188:../source/gps_func.c **** 	while(*delPtr == '0'){	delPtr++;} //LOOP2: If there is zeroes in minutes part, skip them
 253              		.loc 1 188 0 discriminator 1
 254 004a 96F90030 		ldrsb	r3, [r6]
 255 004e 302B     		cmp	r3, #48
 256 0050 F9D0     		beq	.L17
 189:../source/gps_func.c **** 
 190:../source/gps_func.c **** 	uint32_t latMinutes = atol(delPtr);
 257              		.loc 1 190 0
 258 0052 3046     		mov	r0, r6
 259 0054 FFF7FEFF 		bl	atol
 260              	.LVL32:
 191:../source/gps_func.c **** 	latMinutes = latMinutes / 6; //Convert minutes to decimal degrees
 261              		.loc 1 191 0
 262 0058 0625     		movs	r5, #6
 263              	.LVL33:
 192:../source/gps_func.c **** 
 193:../source/gps_func.c **** 	sprintf(delPtr, "%ld\r\n", latMinutes); //here because of LOOP2 delPtr points after the original z
 264              		.loc 1 193 0
 265 005a 1849     		ldr	r1, .L28+8
 191:../source/gps_func.c **** 	latMinutes = latMinutes / 6; //Convert minutes to decimal degrees
 266              		.loc 1 191 0
 267 005c B0FBF5F5 		udiv	r5, r0, r5
 268              	.LVL34:
 269              		.loc 1 193 0
 270 0060 3046     		mov	r0, r6
 271 0062 2A46     		mov	r2, r5
 272 0064 FFF7FEFF 		bl	sprintf
 273              	.LVL35:
 194:../source/gps_func.c **** 											//and decimal problem is fixed
 195:../source/gps_func.c **** 
 196:../source/gps_func.c **** 	printf("latmin: %ld\r\n",latMinutes);
 274              		.loc 1 196 0
 275 0068 2946     		mov	r1, r5
 276 006a 1548     		ldr	r0, .L28+12
 277 006c FFF7FEFF 		bl	printf
 278              	.LVL36:
 197:../source/gps_func.c **** 
 198:../source/gps_func.c **** 	while (lonStr[d_ptr] == '0')
 279              		.loc 1 198 0
 280 0070 0023     		movs	r3, #0
 281              	.LVL37:
 282              	.L18:
 283 0072 DAB2     		uxtb	r2, r3
 284 0074 A118     		adds	r1, r4, r2
 285 0076 A256     		ldrsb	r2, [r4, r2]
 286 0078 302A     		cmp	r2, #48
 287 007a 03F10103 		add	r3, r3, #1
 288              	.LVL38:
 289 007e F8D0     		beq	.L18
 199:../source/gps_func.c **** 	{
 200:../source/gps_func.c **** 		d_ptr++;
 201:../source/gps_func.c **** 	}
 202:../source/gps_func.c **** 
 203:../source/gps_func.c **** 	strcpy(parsedLon, lonStr + d_ptr);
 290              		.loc 1 203 0
 291 0080 1048     		ldr	r0, .L28+16
 292 0082 FFF7FEFF 		bl	strcpy
 293              	.LVL39:
 204:../source/gps_func.c **** 
 205:../source/gps_func.c **** 	delPtr = strchr(parsedLon, s);
 294              		.loc 1 205 0
 295 0086 2E21     		movs	r1, #46
 296 0088 0E48     		ldr	r0, .L28+16
 297 008a FFF7FEFF 		bl	strchr
 298              	.LVL40:
 206:../source/gps_func.c **** 	delPtr++;
 299              		.loc 1 206 0
 300 008e 0130     		adds	r0, r0, #1
 301              	.LVL41:
 302              	.L19:
 303 0090 0446     		mov	r4, r0
 304              	.LVL42:
 305 0092 0130     		adds	r0, r0, #1
 306              	.LVL43:
 207:../source/gps_func.c **** 	while(*delPtr == '0'){	delPtr++;} //LOOP3: If there is zeroes in minutes part, skip them
 307              		.loc 1 207 0 discriminator 1
 308 0094 94F90030 		ldrsb	r3, [r4]
 309 0098 302B     		cmp	r3, #48
 310 009a F9D0     		beq	.L19
 208:../source/gps_func.c **** 
 209:../source/gps_func.c **** 	uint32_t lonMinutes = atol(delPtr);
 311              		.loc 1 209 0
 312 009c 2046     		mov	r0, r4
 313 009e FFF7FEFF 		bl	atol
 314              	.LVL44:
 210:../source/gps_func.c **** 	lonMinutes = lonMinutes / 6;
 211:../source/gps_func.c **** 
 212:../source/gps_func.c **** 	sprintf(delPtr, "%ld\r\n", lonMinutes);//here because of LOOP3 delPtr points after the original ze
 315              		.loc 1 212 0
 316 00a2 0622     		movs	r2, #6
 317 00a4 0549     		ldr	r1, .L28+8
 318 00a6 B0FBF2F2 		udiv	r2, r0, r2
 319              	.LVL45:
 320 00aa 2046     		mov	r0, r4
 213:../source/gps_func.c **** 											//and decimal problem is fixed
 214:../source/gps_func.c **** 
 215:../source/gps_func.c **** 	//printf("Parsed latitude: %s", parsedLon);
 216:../source/gps_func.c **** 	//printf("Parsed longitude: %s", parsedLat);
 217:../source/gps_func.c **** }
 321              		.loc 1 217 0
 322 00ac BDE87040 		pop	{r4, r5, r6, lr}
 323              		.cfi_restore 14
 324              		.cfi_restore 6
 325              		.cfi_restore 5
 326              		.cfi_restore 4
 327              		.cfi_def_cfa_offset 0
 328              	.LVL46:
 212:../source/gps_func.c **** 											//and decimal problem is fixed
 329              		.loc 1 212 0
 330 00b0 FFF7FEBF 		b	sprintf
 331              	.LVL47:
 332              	.L29:
 333              		.align	2
 334              	.L28:
 335 00b4 00000000 		.word	.LC1
 336 00b8 00000000 		.word	parsedLat
 337 00bc 16000000 		.word	.LC2
 338 00c0 1C000000 		.word	.LC3
 339 00c4 00000000 		.word	parsedLon
 340              		.cfi_endproc
 341              	.LFE4:
 343              		.section	.text.getGPS,"ax",%progbits
 344              		.align	1
 345              		.global	getGPS
 346              		.syntax unified
 347              		.thumb
 348              		.thumb_func
 349              		.fpu fpv4-sp-d16
 351              	getGPS:
 352              	.LFB3:
  62:../source/gps_func.c **** 
 353              		.loc 1 62 0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 120
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              	.LVL48:
 358 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 359              		.cfi_def_cfa_offset 20
 360              		.cfi_offset 4, -20
 361              		.cfi_offset 5, -16
 362              		.cfi_offset 6, -12
 363              		.cfi_offset 7, -8
 364              		.cfi_offset 14, -4
 365 0002 9FB0     		sub	sp, sp, #124
 366              		.cfi_def_cfa_offset 144
  76:../source/gps_func.c **** 	{ GLL_ID, latitude, northSouth, longitude, eastWest, time, status, posMode,
 367              		.loc 1 76 0
 368 0004 04AB     		add	r3, sp, #16
 369 0006 1593     		str	r3, [sp, #84]
 370 0008 0DAB     		add	r3, sp, #52
 371 000a 1693     		str	r3, [sp, #88]
 372 000c 11AB     		add	r3, sp, #68
 373 000e 1893     		str	r3, [sp, #96]
 374 0010 01AB     		add	r3, sp, #4
 375 0012 1993     		str	r3, [sp, #100]
 376 0014 07AB     		add	r3, sp, #28
 377 0016 1A93     		str	r3, [sp, #104]
 378 0018 02AB     		add	r3, sp, #8
 379 001a 1B93     		str	r3, [sp, #108]
 380 001c 03AB     		add	r3, sp, #12
 381 001e 1C93     		str	r3, [sp, #112]
  80:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
 382              		.loc 1 80 0
 383 0020 3249     		ldr	r1, .L50
 384 0022 3348     		ldr	r0, .L50+4
  76:../source/gps_func.c **** 	{ GLL_ID, latitude, northSouth, longitude, eastWest, time, status, posMode,
 385              		.loc 1 76 0
 386 0024 CDF85CD0 		str	sp, [sp, #92]
 387 0028 0AAB     		add	r3, sp, #40
 388 002a 1D93     		str	r3, [sp, #116]
  80:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
 389              		.loc 1 80 0
 390 002c FFF7FEFF 		bl	strstr
 391              	.LVL49:
  81:../source/gps_func.c **** 
 392              		.loc 1 81 0
 393 0030 3049     		ldr	r1, .L50+8
  80:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
 394              		.loc 1 80 0
 395 0032 0446     		mov	r4, r0
 396              	.LVL50:
  81:../source/gps_func.c **** 
 397              		.loc 1 81 0
 398 0034 2E48     		ldr	r0, .L50+4
 399              	.LVL51:
 400 0036 FFF7FEFF 		bl	strstr
 401              	.LVL52:
 402 003a 0546     		mov	r5, r0
 403              	.LVL53:
  83:../source/gps_func.c **** 	{
 404              		.loc 1 83 0
 405 003c 24B9     		cbnz	r4, .L31
 406              	.LVL54:
 407              	.L41:
 137:../source/gps_func.c **** 	{
 408              		.loc 1 137 0
 409 003e 002D     		cmp	r5, #0
 410 0040 45D1     		bne	.L32
 150:../source/gps_func.c **** 	//}
 411              		.loc 1 150 0
 412 0042 2846     		mov	r0, r5
 413              	.L33:
 152:../source/gps_func.c **** 
 414              		.loc 1 152 0
 415 0044 1FB0     		add	sp, sp, #124
 416              		.cfi_remember_state
 417              		.cfi_def_cfa_offset 20
 418              		@ sp needed
 419 0046 F0BD     		pop	{r4, r5, r6, r7, pc}
 420              	.LVL55:
 421              	.L31:
 422              		.cfi_restore_state
 423              	.LBB4:
  86:../source/gps_func.c **** 
 424              		.loc 1 86 0
 425 0048 2B49     		ldr	r1, .L50+12
 426 004a 2046     		mov	r0, r4
 427              	.LVL56:
 428 004c FFF7FEFF 		bl	strstr
 429              	.LVL57:
  88:../source/gps_func.c **** 
 430              		.loc 1 88 0
 431 0050 28B1     		cbz	r0, .L34
  91:../source/gps_func.c **** 			printf("GLL string %s\r\n", gllStart);
 432              		.loc 1 91 0
 433 0052 0023     		movs	r3, #0
 434 0054 8370     		strb	r3, [r0, #2]
  92:../source/gps_func.c **** 		}
 435              		.loc 1 92 0
 436 0056 2146     		mov	r1, r4
 437 0058 2848     		ldr	r0, .L50+16
 438              	.LVL58:
 439 005a FFF7FEFF 		bl	printf
 440              	.LVL59:
 441              	.L34:
 442              	.LBE4:
  62:../source/gps_func.c **** 
 443              		.loc 1 62 0
 444 005e 0023     		movs	r3, #0
 445 0060 2246     		mov	r2, r4
 446              	.LBB7:
 107:../source/gps_func.c **** 				GPS_dataPtrs[counter] = gllStart; //save this string token to variable
 447              		.loc 1 107 0
 448 0062 1846     		mov	r0, r3
 449              	.LVL60:
 450              	.L35:
 102:../source/gps_func.c **** 		{
 451              		.loc 1 102 0
 452 0064 92F90010 		ldrsb	r1, [r2]
 453 0068 71B9     		cbnz	r1, .L37
 118:../source/gps_func.c **** 		{
 454              		.loc 1 118 0
 455 006a 1B9C     		ldr	r4, [sp, #108]
 456              	.LVL61:
 457 006c 4121     		movs	r1, #65
 458 006e 2046     		mov	r0, r4
 459 0070 FFF7FEFF 		bl	strchr
 460              	.LVL62:
 461 0074 B8B1     		cbz	r0, .L38
 120:../source/gps_func.c **** 			parseData(GPS_dataPtrs[1], GPS_dataPtrs[3]);
 462              		.loc 1 120 0
 463 0076 2248     		ldr	r0, .L50+20
 464 0078 FFF7FEFF 		bl	puts
 465              	.LVL63:
 121:../source/gps_func.c **** 			return 1;
 466              		.loc 1 121 0
 467 007c 1698     		ldr	r0, [sp, #88]
 468 007e 1899     		ldr	r1, [sp, #96]
 469 0080 FFF7FEFF 		bl	parseData
 470              	.LVL64:
 122:../source/gps_func.c **** 		}
 471              		.loc 1 122 0
 472 0084 0120     		movs	r0, #1
 473 0086 DDE7     		b	.L33
 474              	.LVL65:
 475              	.L37:
 105:../source/gps_func.c **** 			{
 476              		.loc 1 105 0
 477 0088 2C29     		cmp	r1, #44
 478 008a 02F10101 		add	r1, r2, #1
 479 008e 08D1     		bne	.L36
 107:../source/gps_func.c **** 				GPS_dataPtrs[counter] = gllStart; //save this string token to variable
 480              		.loc 1 107 0
 481 0090 1070     		strb	r0, [r2]
 108:../source/gps_func.c **** 				counter++;
 482              		.loc 1 108 0
 483 0092 1EAA     		add	r2, sp, #120
 484              	.LVL66:
 485 0094 02EB8302 		add	r2, r2, r3, lsl #2
 109:../source/gps_func.c **** 				gllStart = gllStringPtr + 1; //move gllStart so it points to the next char after the comma
 486              		.loc 1 109 0
 487 0098 0133     		adds	r3, r3, #1
 488              	.LVL67:
 108:../source/gps_func.c **** 				counter++;
 489              		.loc 1 108 0
 490 009a 42F8244C 		str	r4, [r2, #-36]
 109:../source/gps_func.c **** 				gllStart = gllStringPtr + 1; //move gllStart so it points to the next char after the comma
 491              		.loc 1 109 0
 492 009e DBB2     		uxtb	r3, r3
 493              	.LVL68:
 110:../source/gps_func.c **** 
 494              		.loc 1 110 0
 495 00a0 0C46     		mov	r4, r1
 496              	.LVL69:
 497              	.L36:
 114:../source/gps_func.c **** 
 498              		.loc 1 114 0
 499 00a2 0A46     		mov	r2, r1
 500              	.LVL70:
 501 00a4 DEE7     		b	.L35
 502              	.LVL71:
 503              	.L38:
 125:../source/gps_func.c **** 		{
 504              		.loc 1 125 0
 505 00a6 5621     		movs	r1, #86
 506 00a8 2046     		mov	r0, r4
 507 00aa FFF7FEFF 		bl	strchr
 508              	.LVL72:
 509 00ae 10B1     		cbz	r0, .L39
 127:../source/gps_func.c **** 		}
 510              		.loc 1 127 0
 511 00b0 1448     		ldr	r0, .L50+24
 512 00b2 FFF7FEFF 		bl	puts
 513              	.LVL73:
 514              	.L39:
 515              	.LBB5:
 132:../source/gps_func.c **** 		}
 516              		.loc 1 132 0 discriminator 3
 517 00b6 144E     		ldr	r6, .L50+28
 518              	.LBE5:
 519              	.LBE7:
  62:../source/gps_func.c **** 
 520              		.loc 1 62 0 discriminator 3
 521 00b8 0024     		movs	r4, #0
 522              	.LBB8:
 523              	.LBB6:
 132:../source/gps_func.c **** 		}
 524              		.loc 1 132 0 discriminator 3
 525 00ba 15AF     		add	r7, sp, #84
 526              	.L40:
 527              	.LVL74:
 528 00bc 57F82410 		ldr	r1, [r7, r4, lsl #2]
 529 00c0 3046     		mov	r0, r6
 530 00c2 0134     		adds	r4, r4, #1
 531              	.LVL75:
 532 00c4 FFF7FEFF 		bl	printf
 533              	.LVL76:
 130:../source/gps_func.c **** 		{
 534              		.loc 1 130 0 discriminator 3
 535 00c8 072C     		cmp	r4, #7
 536 00ca F7D1     		bne	.L40
 537 00cc B7E7     		b	.L41
 538              	.L32:
 539              	.LBE6:
 540              	.LBE8:
 541              	.LBB9:
 139:../source/gps_func.c **** 
 542              		.loc 1 139 0
 543 00ce 0A49     		ldr	r1, .L50+12
 544 00d0 2846     		mov	r0, r5
 545 00d2 FFF7FEFF 		bl	strstr
 546              	.LVL77:
 547 00d6 0024     		movs	r4, #0
 141:../source/gps_func.c **** 		{
 548              		.loc 1 141 0
 549 00d8 0028     		cmp	r0, #0
 550 00da B3D0     		beq	.L33
 144:../source/gps_func.c **** 			printf("GSV string %s\r\n", gsvStart);
 551              		.loc 1 144 0
 552 00dc 8470     		strb	r4, [r0, #2]
 145:../source/gps_func.c **** 
 553              		.loc 1 145 0
 554 00de 2946     		mov	r1, r5
 555 00e0 0A48     		ldr	r0, .L50+32
 556              	.LVL78:
 557 00e2 FFF7FEFF 		bl	printf
 558              	.LVL79:
 559              	.LBE9:
 150:../source/gps_func.c **** 	//}
 560              		.loc 1 150 0
 561 00e6 2046     		mov	r0, r4
 562 00e8 ACE7     		b	.L33
 563              	.L51:
 564 00ea 00BF     		.align	2
 565              	.L50:
 566 00ec 00000000 		.word	.LC4
 567 00f0 00000000 		.word	GPS_recBuf
 568 00f4 05000000 		.word	.LC5
 569 00f8 0A000000 		.word	.LC6
 570 00fc 0D000000 		.word	.LC7
 571 0100 1D000000 		.word	.LC8
 572 0104 26000000 		.word	.LC9
 573 0108 4C000000 		.word	.LC10
 574 010c 51000000 		.word	.LC11
 575              		.cfi_endproc
 576              	.LFE3:
 578              		.section	.rodata.getGPS.str1.1,"aMS",%progbits,1
 579              	.LC4:
 580 0000 4E474C4C 		.ascii	"NGLL\000"
 580      00
 581              	.LC5:
 582 0005 50475356 		.ascii	"PGSV\000"
 582      00
 583              	.LC6:
 584 000a 0D0A00   		.ascii	"\015\012\000"
 585              	.LC7:
 586 000d 474C4C20 		.ascii	"GLL string %s\015\012\000"
 586      73747269 
 586      6E672025 
 586      730D0A00 
 587              	.LC8:
 588 001d 476F7420 		.ascii	"Got GPS\015\000"
 588      4750530D 
 588      00
 589              	.LC9:
 590 0026 44617461 		.ascii	"Data invalid, waiting for valid data\015\000"
 590      20696E76 
 590      616C6964 
 590      2C207761 
 590      6974696E 
 591              	.LC10:
 592 004c 25730D0A 		.ascii	"%s\015\012\000"
 592      00
 593              	.LC11:
 594 0051 47535620 		.ascii	"GSV string %s\015\012\000"
 594      73747269 
 594      6E672025 
 594      730D0A00 
 595              		.section	.rodata.parseData.str1.1,"aMS",%progbits,1
 596              	.LC1:
 597 0000 6C617473 		.ascii	"latstr %s lonstr %s\015\012\000"
 597      74722025 
 597      73206C6F 
 597      6E737472 
 597      2025730D 
 598              	.LC2:
 599 0016 256C640D 		.ascii	"%ld\015\012\000"
 599      0A00
 600              	.LC3:
 601 001c 6C61746D 		.ascii	"latmin: %ld\015\012\000"
 601      696E3A20 
 601      256C640D 
 601      0A00
 602              		.section	.rodata.printUbxResponseHex.str1.1,"aMS",%progbits,1
 603              	.LC0:
 604 0000 25303278 		.ascii	"%02x \000"
 604      2000
 605              		.text
 606              	.Letext0:
 607              		.file 2 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 608              		.file 3 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 609              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 610              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 611              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 612              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 613              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/stdlib.h"
 614              		.file 9 "../source/gps_func.h"
 615              		.file 10 "../source/at_func.h"
 616              		.file 11 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/stdio.h"
 617              		.file 12 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/string.h"
 618              		.file 13 "<built-in>"
