   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_adc16.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ADC16_Init,"ax",%progbits
  18              		.align	1
  19              		.global	ADC16_Init
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	ADC16_Init:
  26              	.LFB152:
  27              		.file 1 "../drivers/fsl_adc16.c"
   1:../drivers/fsl_adc16.c **** /*
   2:../drivers/fsl_adc16.c ****  * The Clear BSD License
   3:../drivers/fsl_adc16.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_adc16.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_adc16.c ****  * All rights reserved.
   6:../drivers/fsl_adc16.c ****  *
   7:../drivers/fsl_adc16.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_adc16.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_adc16.c ****  * that the following conditions are met:
  10:../drivers/fsl_adc16.c ****  *
  11:../drivers/fsl_adc16.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_adc16.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_adc16.c ****  *
  14:../drivers/fsl_adc16.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_adc16.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_adc16.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_adc16.c ****  *
  18:../drivers/fsl_adc16.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_adc16.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_adc16.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_adc16.c ****  *
  22:../drivers/fsl_adc16.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_adc16.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_adc16.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_adc16.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_adc16.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_adc16.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_adc16.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_adc16.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_adc16.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_adc16.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_adc16.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_adc16.c ****  */
  34:../drivers/fsl_adc16.c **** 
  35:../drivers/fsl_adc16.c **** #include "fsl_adc16.h"
  36:../drivers/fsl_adc16.c **** 
  37:../drivers/fsl_adc16.c **** /*******************************************************************************
  38:../drivers/fsl_adc16.c ****  * Prototypes
  39:../drivers/fsl_adc16.c ****  ******************************************************************************/
  40:../drivers/fsl_adc16.c **** /*!
  41:../drivers/fsl_adc16.c ****  * @brief Get instance number for ADC16 module.
  42:../drivers/fsl_adc16.c ****  *
  43:../drivers/fsl_adc16.c ****  * @param base ADC16 peripheral base address
  44:../drivers/fsl_adc16.c ****  */
  45:../drivers/fsl_adc16.c **** static uint32_t ADC16_GetInstance(ADC_Type *base);
  46:../drivers/fsl_adc16.c **** 
  47:../drivers/fsl_adc16.c **** /*******************************************************************************
  48:../drivers/fsl_adc16.c ****  * Variables
  49:../drivers/fsl_adc16.c ****  ******************************************************************************/
  50:../drivers/fsl_adc16.c **** /*! @brief Pointers to ADC16 bases for each instance. */
  51:../drivers/fsl_adc16.c **** static ADC_Type *const s_adc16Bases[] = ADC_BASE_PTRS;
  52:../drivers/fsl_adc16.c **** 
  53:../drivers/fsl_adc16.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  54:../drivers/fsl_adc16.c **** /*! @brief Pointers to ADC16 clocks for each instance. */
  55:../drivers/fsl_adc16.c **** static const clock_ip_name_t s_adc16Clocks[] = ADC16_CLOCKS;
  56:../drivers/fsl_adc16.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  57:../drivers/fsl_adc16.c **** 
  58:../drivers/fsl_adc16.c **** /*******************************************************************************
  59:../drivers/fsl_adc16.c ****  * Code
  60:../drivers/fsl_adc16.c ****  ******************************************************************************/
  61:../drivers/fsl_adc16.c **** static uint32_t ADC16_GetInstance(ADC_Type *base)
  62:../drivers/fsl_adc16.c **** {
  63:../drivers/fsl_adc16.c ****     uint32_t instance;
  64:../drivers/fsl_adc16.c **** 
  65:../drivers/fsl_adc16.c ****     /* Find the instance index from base address mappings. */
  66:../drivers/fsl_adc16.c ****     for (instance = 0; instance < ARRAY_SIZE(s_adc16Bases); instance++)
  67:../drivers/fsl_adc16.c ****     {
  68:../drivers/fsl_adc16.c ****         if (s_adc16Bases[instance] == base)
  69:../drivers/fsl_adc16.c ****         {
  70:../drivers/fsl_adc16.c ****             break;
  71:../drivers/fsl_adc16.c ****         }
  72:../drivers/fsl_adc16.c ****     }
  73:../drivers/fsl_adc16.c **** 
  74:../drivers/fsl_adc16.c ****     assert(instance < ARRAY_SIZE(s_adc16Bases));
  75:../drivers/fsl_adc16.c **** 
  76:../drivers/fsl_adc16.c ****     return instance;
  77:../drivers/fsl_adc16.c **** }
  78:../drivers/fsl_adc16.c **** 
  79:../drivers/fsl_adc16.c **** void ADC16_Init(ADC_Type *base, const adc16_config_t *config)
  80:../drivers/fsl_adc16.c **** {
  28              		.loc 1 80 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33              	.LBB8:
  34              	.LBB9:
  68:../drivers/fsl_adc16.c ****         {
  35              		.loc 1 68 0
  36 0000 2A4B     		ldr	r3, .L28
  37 0002 9842     		cmp	r0, r3
  38              	.LBE9:
  39              	.LBE8:
  40              		.loc 1 80 0
  41 0004 30B5     		push	{r4, r5, lr}
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 5, -8
  45              		.cfi_offset 14, -4
  46              	.LBB12:
  47              	.LBB10:
  68:../drivers/fsl_adc16.c ****         {
  48              		.loc 1 68 0
  49 0006 4BD0     		beq	.L10
  50              	.LVL1:
  66:../drivers/fsl_adc16.c ****     {
  51              		.loc 1 66 0
  52 0008 03F50023 		add	r3, r3, #524288
  53 000c 9842     		cmp	r0, r3
  54 000e 0CBF     		ite	eq
  55 0010 0123     		moveq	r3, #1
  56 0012 0223     		movne	r3, #2
  57              	.LVL2:
  58              	.L2:
  59              	.LBE10:
  60              	.LBE12:
  81:../drivers/fsl_adc16.c ****     assert(NULL != config);
  82:../drivers/fsl_adc16.c **** 
  83:../drivers/fsl_adc16.c ****     uint32_t tmp32;
  84:../drivers/fsl_adc16.c **** 
  85:../drivers/fsl_adc16.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  86:../drivers/fsl_adc16.c ****     /* Enable the clock. */
  87:../drivers/fsl_adc16.c ****     CLOCK_EnableClock(s_adc16Clocks[ADC16_GetInstance(base)]);
  61              		.loc 1 87 0
  62 0014 264A     		ldr	r2, .L28+4
  63 0016 52F82340 		ldr	r4, [r2, r3, lsl #2]
  64              	.LVL3:
  65              	.LBB13:
  66              	.LBB14:
  67              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  68              		.loc 2 694 0
  69 001a 230C     		lsrs	r3, r4, #16
  70 001c 03F18043 		add	r3, r3, #1073741824
  71 0020 03F58E23 		add	r3, r3, #290816
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
  72              		.loc 2 695 0
  73 0024 A4B2     		uxth	r4, r4
  74              	.LVL4:
  75 0026 1D68     		ldr	r5, [r3]
  76 0028 0122     		movs	r2, #1
  77 002a A240     		lsls	r2, r2, r4
  78 002c 2A43     		orrs	r2, r2, r5
  79 002e 1A60     		str	r2, [r3]
  80              	.LBE14:
  81              	.LBE13:
  88:../drivers/fsl_adc16.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  89:../drivers/fsl_adc16.c **** 
  90:../drivers/fsl_adc16.c ****     /* ADCx_CFG1. */
  91:../drivers/fsl_adc16.c ****     tmp32 = ADC_CFG1_ADICLK(config->clockSource) | ADC_CFG1_MODE(config->resolution);
  82              		.loc 1 91 0
  83 0030 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
  84 0032 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
  92:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
  85              		.loc 1 92 0
  86 0034 4C79     		ldrb	r4, [r1, #5]	@ zero_extendqisi2
  91:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
  87              		.loc 1 91 0
  88 0036 9B00     		lsls	r3, r3, #2
  89 0038 03F00C03 		and	r3, r3, #12
  90 003c 02F00302 		and	r2, r2, #3
  91 0040 1A43     		orrs	r2, r2, r3
  92              	.LVL5:
  93:../drivers/fsl_adc16.c ****     {
  94:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG1_ADLSMP_MASK;
  95:../drivers/fsl_adc16.c ****     }
  96:../drivers/fsl_adc16.c ****     tmp32 |= ADC_CFG1_ADIV(config->clockDivider);
  93              		.loc 1 96 0
  94 0042 CB78     		ldrb	r3, [r1, #3]	@ zero_extendqisi2
  92:../drivers/fsl_adc16.c ****     {
  95              		.loc 1 92 0
  96 0044 042C     		cmp	r4, #4
  97              		.loc 1 96 0
  98 0046 4FEA4313 		lsl	r3, r3, #5
  94:../drivers/fsl_adc16.c ****     }
  99              		.loc 1 94 0
 100 004a 18BF     		it	ne
 101 004c 42F01002 		orrne	r2, r2, #16
 102              	.LVL6:
 103              		.loc 1 96 0
 104 0050 03F06003 		and	r3, r3, #96
 105 0054 1343     		orrs	r3, r3, r2
 106              	.LVL7:
  97:../drivers/fsl_adc16.c ****     if (config->enableLowPower)
 107              		.loc 1 97 0
 108 0056 CA79     		ldrb	r2, [r1, #7]	@ zero_extendqisi2
 109 0058 0AB1     		cbz	r2, .L4
  98:../drivers/fsl_adc16.c ****     {
  99:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG1_ADLPC_MASK;
 110              		.loc 1 99 0
 111 005a 43F08003 		orr	r3, r3, #128
 112              	.LVL8:
 113              	.L4:
 100:../drivers/fsl_adc16.c ****     }
 101:../drivers/fsl_adc16.c ****     base->CFG1 = tmp32;
 114              		.loc 1 101 0
 115 005e 8360     		str	r3, [r0, #8]
 102:../drivers/fsl_adc16.c **** 
 103:../drivers/fsl_adc16.c ****     /* ADCx_CFG2. */
 104:../drivers/fsl_adc16.c ****     tmp32 = base->CFG2 & ~(ADC_CFG2_ADACKEN_MASK | ADC_CFG2_ADHSC_MASK | ADC_CFG2_ADLSTS_MASK);
 116              		.loc 1 104 0
 117 0060 C368     		ldr	r3, [r0, #12]
 118              	.LVL9:
 105:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
 106:../drivers/fsl_adc16.c ****     {
 107:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG2_ADLSTS(config->longSampleMode);
 108:../drivers/fsl_adc16.c ****     }
 109:../drivers/fsl_adc16.c ****     if (config->enableHighSpeed)
 119              		.loc 1 109 0
 120 0062 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 105:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
 121              		.loc 1 105 0
 122 0064 042C     		cmp	r4, #4
 104:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
 123              		.loc 1 104 0
 124 0066 23F00F03 		bic	r3, r3, #15
 125              	.LVL10:
 107:../drivers/fsl_adc16.c ****     }
 126              		.loc 1 107 0
 127 006a 1CBF     		itt	ne
 128 006c 04F00304 		andne	r4, r4, #3
 129 0070 2343     		orrne	r3, r3, r4
 130              	.LVL11:
 131              		.loc 1 109 0
 132 0072 0AB1     		cbz	r2, .L6
 110:../drivers/fsl_adc16.c ****     {
 111:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG2_ADHSC_MASK;
 133              		.loc 1 111 0
 134 0074 43F00403 		orr	r3, r3, #4
 135              	.LVL12:
 136              	.L6:
 112:../drivers/fsl_adc16.c ****     }
 113:../drivers/fsl_adc16.c ****     if (config->enableAsynchronousClock)
 137              		.loc 1 113 0
 138 0078 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 139 007a 0AB1     		cbz	r2, .L7
 114:../drivers/fsl_adc16.c ****     {
 115:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG2_ADACKEN_MASK;
 140              		.loc 1 115 0
 141 007c 43F00803 		orr	r3, r3, #8
 142              	.LVL13:
 143              	.L7:
 116:../drivers/fsl_adc16.c ****     }
 117:../drivers/fsl_adc16.c ****     base->CFG2 = tmp32;
 144              		.loc 1 117 0
 145 0080 C360     		str	r3, [r0, #12]
 118:../drivers/fsl_adc16.c **** 
 119:../drivers/fsl_adc16.c ****     /* ADCx_SC2. */
 120:../drivers/fsl_adc16.c ****     tmp32 = base->SC2 & ~(ADC_SC2_REFSEL_MASK);
 146              		.loc 1 120 0
 147 0082 026A     		ldr	r2, [r0, #32]
 121:../drivers/fsl_adc16.c ****     tmp32 |= ADC_SC2_REFSEL(config->referenceVoltageSource);
 148              		.loc 1 121 0
 149 0084 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 150              	.LVL14:
 120:../drivers/fsl_adc16.c ****     tmp32 |= ADC_SC2_REFSEL(config->referenceVoltageSource);
 151              		.loc 1 120 0
 152 0086 22F00302 		bic	r2, r2, #3
 153              	.LVL15:
 154              		.loc 1 121 0
 155 008a 03F00303 		and	r3, r3, #3
 156 008e 1343     		orrs	r3, r3, r2
 157              	.LVL16:
 122:../drivers/fsl_adc16.c ****     base->SC2 = tmp32;
 158              		.loc 1 122 0
 159 0090 0362     		str	r3, [r0, #32]
 123:../drivers/fsl_adc16.c **** 
 124:../drivers/fsl_adc16.c ****     /* ADCx_SC3. */
 125:../drivers/fsl_adc16.c ****     if (config->enableContinuousConversion)
 160              		.loc 1 125 0
 161 0092 0B7A     		ldrb	r3, [r1, #8]	@ zero_extendqisi2
 162              	.LVL17:
 163 0094 33B1     		cbz	r3, .L8
 126:../drivers/fsl_adc16.c ****     {
 127:../drivers/fsl_adc16.c ****         base->SC3 |= ADC_SC3_ADCO_MASK;
 164              		.loc 1 127 0
 165 0096 436A     		ldr	r3, [r0, #36]
 166 0098 43F00803 		orr	r3, r3, #8
 167              	.L27:
 128:../drivers/fsl_adc16.c ****     }
 129:../drivers/fsl_adc16.c ****     else
 130:../drivers/fsl_adc16.c ****     {
 131:../drivers/fsl_adc16.c ****         base->SC3 &= ~ADC_SC3_ADCO_MASK;
 168              		.loc 1 131 0
 169 009c 4362     		str	r3, [r0, #36]
 170              	.LVL18:
 171 009e 30BD     		pop	{r4, r5, pc}
 172              	.LVL19:
 173              	.L10:
 174              	.LBB15:
 175              	.LBB11:
  66:../drivers/fsl_adc16.c ****     {
 176              		.loc 1 66 0
 177 00a0 0023     		movs	r3, #0
 178 00a2 B7E7     		b	.L2
 179              	.LVL20:
 180              	.L8:
 181              	.LBE11:
 182              	.LBE15:
 183              		.loc 1 131 0
 184 00a4 436A     		ldr	r3, [r0, #36]
 185 00a6 23F00803 		bic	r3, r3, #8
 186 00aa F7E7     		b	.L27
 187              	.L29:
 188              		.align	2
 189              	.L28:
 190 00ac 00B00340 		.word	1073983488
 191 00b0 00000000 		.word	.LANCHOR0
 192              		.cfi_endproc
 193              	.LFE152:
 195              		.section	.text.ADC16_Deinit,"ax",%progbits
 196              		.align	1
 197              		.global	ADC16_Deinit
 198              		.syntax unified
 199              		.thumb
 200              		.thumb_func
 201              		.fpu fpv4-sp-d16
 203              	ADC16_Deinit:
 204              	.LFB153:
 132:../drivers/fsl_adc16.c ****     }
 133:../drivers/fsl_adc16.c **** }
 134:../drivers/fsl_adc16.c **** 
 135:../drivers/fsl_adc16.c **** void ADC16_Deinit(ADC_Type *base)
 136:../drivers/fsl_adc16.c **** {
 205              		.loc 1 136 0
 206              		.cfi_startproc
 207              		@ args = 0, pretend = 0, frame = 0
 208              		@ frame_needed = 0, uses_anonymous_args = 0
 209              		@ link register save eliminated.
 210              	.LVL21:
 211              	.LBB20:
 212              	.LBB21:
  68:../drivers/fsl_adc16.c ****         {
 213              		.loc 1 68 0
 214 0000 0D4B     		ldr	r3, .L34
 215 0002 9842     		cmp	r0, r3
 216 0004 16D0     		beq	.L32
 217              	.LVL22:
  66:../drivers/fsl_adc16.c ****     {
 218              		.loc 1 66 0
 219 0006 03F50023 		add	r3, r3, #524288
 220 000a 9842     		cmp	r0, r3
 221 000c 0CBF     		ite	eq
 222 000e 0120     		moveq	r0, #1
 223 0010 0220     		movne	r0, #2
 224              	.LVL23:
 225              	.L31:
 226              	.LBE21:
 227              	.LBE20:
 137:../drivers/fsl_adc16.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 138:../drivers/fsl_adc16.c ****     /* Disable the clock. */
 139:../drivers/fsl_adc16.c ****     CLOCK_DisableClock(s_adc16Clocks[ADC16_GetInstance(base)]);
 228              		.loc 1 139 0
 229 0012 0A4B     		ldr	r3, .L34+4
 230 0014 53F82020 		ldr	r2, [r3, r0, lsl #2]
 231              	.LVL24:
 232              	.LBB23:
 233              	.LBB24:
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 234              		.loc 2 705 0
 235 0018 130C     		lsrs	r3, r2, #16
 236 001a 03F18043 		add	r3, r3, #1073741824
 237 001e 03F58E23 		add	r3, r3, #290816
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 238              		.loc 2 706 0
 239 0022 92B2     		uxth	r2, r2
 240              	.LVL25:
 241 0024 1968     		ldr	r1, [r3]
 242 0026 0120     		movs	r0, #1
 243              	.LVL26:
 244 0028 00FA02F2 		lsl	r2, r0, r2
 245 002c 21EA0202 		bic	r2, r1, r2
 246 0030 1A60     		str	r2, [r3]
 247 0032 7047     		bx	lr
 248              	.LVL27:
 249              	.L32:
 250              	.LBE24:
 251              	.LBE23:
 252              	.LBB25:
 253              	.LBB22:
  66:../drivers/fsl_adc16.c ****     {
 254              		.loc 1 66 0
 255 0034 0020     		movs	r0, #0
 256              	.LVL28:
 257 0036 ECE7     		b	.L31
 258              	.L35:
 259              		.align	2
 260              	.L34:
 261 0038 00B00340 		.word	1073983488
 262 003c 00000000 		.word	.LANCHOR0
 263              	.LBE22:
 264              	.LBE25:
 265              		.cfi_endproc
 266              	.LFE153:
 268              		.section	.text.ADC16_GetDefaultConfig,"ax",%progbits
 269              		.align	1
 270              		.global	ADC16_GetDefaultConfig
 271              		.syntax unified
 272              		.thumb
 273              		.thumb_func
 274              		.fpu fpv4-sp-d16
 276              	ADC16_GetDefaultConfig:
 277              	.LFB154:
 140:../drivers/fsl_adc16.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 141:../drivers/fsl_adc16.c **** }
 142:../drivers/fsl_adc16.c **** 
 143:../drivers/fsl_adc16.c **** void ADC16_GetDefaultConfig(adc16_config_t *config)
 144:../drivers/fsl_adc16.c **** {
 278              		.loc 1 144 0
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 0
 281              		@ frame_needed = 0, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 283              	.LVL29:
 145:../drivers/fsl_adc16.c ****     assert(NULL != config);
 146:../drivers/fsl_adc16.c **** 
 147:../drivers/fsl_adc16.c ****     config->referenceVoltageSource = kADC16_ReferenceVoltageSourceVref;
 148:../drivers/fsl_adc16.c ****     config->clockSource = kADC16_ClockSourceAsynchronousClock;
 149:../drivers/fsl_adc16.c ****     config->enableAsynchronousClock = true;
 284              		.loc 1 149 0
 285 0000 0122     		movs	r2, #1
 147:../drivers/fsl_adc16.c ****     config->clockSource = kADC16_ClockSourceAsynchronousClock;
 286              		.loc 1 147 0
 287 0002 0023     		movs	r3, #0
 148:../drivers/fsl_adc16.c ****     config->enableAsynchronousClock = true;
 288              		.loc 1 148 0
 289 0004 0321     		movs	r1, #3
 290              		.loc 1 149 0
 291 0006 8270     		strb	r2, [r0, #2]
 150:../drivers/fsl_adc16.c ****     config->clockDivider = kADC16_ClockDivider8;
 151:../drivers/fsl_adc16.c ****     config->resolution = kADC16_ResolutionSE12Bit;
 292              		.loc 1 151 0
 293 0008 0271     		strb	r2, [r0, #4]
 152:../drivers/fsl_adc16.c ****     config->longSampleMode = kADC16_LongSampleDisabled;
 294              		.loc 1 152 0
 295 000a 0422     		movs	r2, #4
 147:../drivers/fsl_adc16.c ****     config->clockSource = kADC16_ClockSourceAsynchronousClock;
 296              		.loc 1 147 0
 297 000c 0370     		strb	r3, [r0]
 148:../drivers/fsl_adc16.c ****     config->enableAsynchronousClock = true;
 298              		.loc 1 148 0
 299 000e 4170     		strb	r1, [r0, #1]
 150:../drivers/fsl_adc16.c ****     config->resolution = kADC16_ResolutionSE12Bit;
 300              		.loc 1 150 0
 301 0010 C170     		strb	r1, [r0, #3]
 302              		.loc 1 152 0
 303 0012 4271     		strb	r2, [r0, #5]
 153:../drivers/fsl_adc16.c ****     config->enableHighSpeed = false;
 304              		.loc 1 153 0
 305 0014 8371     		strb	r3, [r0, #6]
 154:../drivers/fsl_adc16.c ****     config->enableLowPower = false;
 306              		.loc 1 154 0
 307 0016 C371     		strb	r3, [r0, #7]
 155:../drivers/fsl_adc16.c ****     config->enableContinuousConversion = false;
 308              		.loc 1 155 0
 309 0018 0372     		strb	r3, [r0, #8]
 310 001a 7047     		bx	lr
 311              		.cfi_endproc
 312              	.LFE154:
 314              		.section	.text.ADC16_SetChannelMuxMode,"ax",%progbits
 315              		.align	1
 316              		.global	ADC16_SetChannelMuxMode
 317              		.syntax unified
 318              		.thumb
 319              		.thumb_func
 320              		.fpu fpv4-sp-d16
 322              	ADC16_SetChannelMuxMode:
 323              	.LFB156:
 156:../drivers/fsl_adc16.c **** }
 157:../drivers/fsl_adc16.c **** 
 158:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 159:../drivers/fsl_adc16.c **** status_t ADC16_DoAutoCalibration(ADC_Type *base)
 160:../drivers/fsl_adc16.c **** {
 161:../drivers/fsl_adc16.c ****     bool bHWTrigger = false;
 162:../drivers/fsl_adc16.c ****     volatile uint32_t tmp32; /* 'volatile' here is for the dummy read of ADCx_R[0] register. */
 163:../drivers/fsl_adc16.c ****     status_t status = kStatus_Success;
 164:../drivers/fsl_adc16.c **** 
 165:../drivers/fsl_adc16.c ****     /* The calibration would be failed when in hardwar mode.
 166:../drivers/fsl_adc16.c ****      * Remember the hardware trigger state here and restore it later if the hardware trigger is ena
 167:../drivers/fsl_adc16.c ****     if (0U != (ADC_SC2_ADTRG_MASK & base->SC2))
 168:../drivers/fsl_adc16.c ****     {
 169:../drivers/fsl_adc16.c ****         bHWTrigger = true;
 170:../drivers/fsl_adc16.c ****         base->SC2 &= ~ADC_SC2_ADTRG_MASK;
 171:../drivers/fsl_adc16.c ****     }
 172:../drivers/fsl_adc16.c **** 
 173:../drivers/fsl_adc16.c ****     /* Clear the CALF and launch the calibration. */
 174:../drivers/fsl_adc16.c ****     base->SC3 |= ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK;
 175:../drivers/fsl_adc16.c ****     while (0U == (kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
 176:../drivers/fsl_adc16.c ****     {
 177:../drivers/fsl_adc16.c ****         /* Check the CALF when the calibration is active. */
 178:../drivers/fsl_adc16.c ****         if (0U != (kADC16_CalibrationFailedFlag & ADC16_GetStatusFlags(base)))
 179:../drivers/fsl_adc16.c ****         {
 180:../drivers/fsl_adc16.c ****             status = kStatus_Fail;
 181:../drivers/fsl_adc16.c ****             break;
 182:../drivers/fsl_adc16.c ****         }
 183:../drivers/fsl_adc16.c ****     }
 184:../drivers/fsl_adc16.c ****     tmp32 = base->R[0]; /* Dummy read to clear COCO caused by calibration. */
 185:../drivers/fsl_adc16.c **** 
 186:../drivers/fsl_adc16.c ****     /* Restore the hardware trigger setting if it was enabled before. */
 187:../drivers/fsl_adc16.c ****     if (bHWTrigger)
 188:../drivers/fsl_adc16.c ****     {
 189:../drivers/fsl_adc16.c ****         base->SC2 |= ADC_SC2_ADTRG_MASK;
 190:../drivers/fsl_adc16.c ****     }
 191:../drivers/fsl_adc16.c ****     /* Check the CALF at the end of calibration. */
 192:../drivers/fsl_adc16.c ****     if (0U != (kADC16_CalibrationFailedFlag & ADC16_GetStatusFlags(base)))
 193:../drivers/fsl_adc16.c ****     {
 194:../drivers/fsl_adc16.c ****         status = kStatus_Fail;
 195:../drivers/fsl_adc16.c ****     }
 196:../drivers/fsl_adc16.c ****     if (kStatus_Success != status) /* Check if the calibration process is succeed. */
 197:../drivers/fsl_adc16.c ****     {
 198:../drivers/fsl_adc16.c ****         return status;
 199:../drivers/fsl_adc16.c ****     }
 200:../drivers/fsl_adc16.c **** 
 201:../drivers/fsl_adc16.c ****     /* Calculate the calibration values. */
 202:../drivers/fsl_adc16.c ****     tmp32 = base->CLP0 + base->CLP1 + base->CLP2 + base->CLP3 + base->CLP4 + base->CLPS;
 203:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 204:../drivers/fsl_adc16.c ****     base->PG = tmp32;
 205:../drivers/fsl_adc16.c **** 
 206:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
 207:../drivers/fsl_adc16.c ****     tmp32 = base->CLM0 + base->CLM1 + base->CLM2 + base->CLM3 + base->CLM4 + base->CLMS;
 208:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 209:../drivers/fsl_adc16.c ****     base->MG = tmp32;
 210:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
 211:../drivers/fsl_adc16.c **** 
 212:../drivers/fsl_adc16.c ****     return kStatus_Success;
 213:../drivers/fsl_adc16.c **** }
 214:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 215:../drivers/fsl_adc16.c **** 
 216:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_MUX_SELECT) && FSL_FEATURE_ADC16_HAS_MUX_SELECT
 217:../drivers/fsl_adc16.c **** void ADC16_SetChannelMuxMode(ADC_Type *base, adc16_channel_mux_mode_t mode)
 218:../drivers/fsl_adc16.c **** {
 324              		.loc 1 218 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              		@ link register save eliminated.
 329              	.LVL30:
 219:../drivers/fsl_adc16.c ****     if (kADC16_ChannelMuxA == mode)
 220:../drivers/fsl_adc16.c ****     {
 221:../drivers/fsl_adc16.c ****         base->CFG2 &= ~ADC_CFG2_MUXSEL_MASK;
 330              		.loc 1 221 0
 331 0000 C368     		ldr	r3, [r0, #12]
 219:../drivers/fsl_adc16.c ****     if (kADC16_ChannelMuxA == mode)
 332              		.loc 1 219 0
 333 0002 19B9     		cbnz	r1, .L38
 334              		.loc 1 221 0
 335 0004 23F01003 		bic	r3, r3, #16
 336              	.L40:
 222:../drivers/fsl_adc16.c ****     }
 223:../drivers/fsl_adc16.c ****     else /* kADC16_ChannelMuxB. */
 224:../drivers/fsl_adc16.c ****     {
 225:../drivers/fsl_adc16.c ****         base->CFG2 |= ADC_CFG2_MUXSEL_MASK;
 337              		.loc 1 225 0
 338 0008 C360     		str	r3, [r0, #12]
 339 000a 7047     		bx	lr
 340              	.L38:
 341 000c 43F01003 		orr	r3, r3, #16
 342 0010 FAE7     		b	.L40
 343              		.cfi_endproc
 344              	.LFE156:
 346              		.section	.text.ADC16_SetHardwareCompareConfig,"ax",%progbits
 347              		.align	1
 348              		.global	ADC16_SetHardwareCompareConfig
 349              		.syntax unified
 350              		.thumb
 351              		.thumb_func
 352              		.fpu fpv4-sp-d16
 354              	ADC16_SetHardwareCompareConfig:
 355              	.LFB157:
 226:../drivers/fsl_adc16.c ****     }
 227:../drivers/fsl_adc16.c **** }
 228:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_MUX_SELECT */
 229:../drivers/fsl_adc16.c **** 
 230:../drivers/fsl_adc16.c **** void ADC16_SetHardwareCompareConfig(ADC_Type *base, const adc16_hardware_compare_config_t *config)
 231:../drivers/fsl_adc16.c **** {
 356              		.loc 1 231 0
 357              		.cfi_startproc
 358              		@ args = 0, pretend = 0, frame = 0
 359              		@ frame_needed = 0, uses_anonymous_args = 0
 360              		@ link register save eliminated.
 361              	.LVL31:
 232:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC2 & ~(ADC_SC2_ACFE_MASK | ADC_SC2_ACFGT_MASK | ADC_SC2_ACREN_MASK);
 362              		.loc 1 232 0
 363 0000 036A     		ldr	r3, [r0, #32]
 364 0002 23F03803 		bic	r3, r3, #56
 365              	.LVL32:
 233:../drivers/fsl_adc16.c **** 
 234:../drivers/fsl_adc16.c ****     if (!config) /* Pass "NULL" to disable the feature. */
 366              		.loc 1 234 0
 367 0006 09B9     		cbnz	r1, .L42
 235:../drivers/fsl_adc16.c ****     {
 236:../drivers/fsl_adc16.c ****         base->SC2 = tmp32;
 368              		.loc 1 236 0
 369 0008 0362     		str	r3, [r0, #32]
 237:../drivers/fsl_adc16.c ****         return;
 370              		.loc 1 237 0
 371 000a 7047     		bx	lr
 372              	.L42:
 373              	.LVL33:
 238:../drivers/fsl_adc16.c ****     }
 239:../drivers/fsl_adc16.c ****     /* Enable the feature. */
 240:../drivers/fsl_adc16.c ****     tmp32 |= ADC_SC2_ACFE_MASK;
 241:../drivers/fsl_adc16.c **** 
 242:../drivers/fsl_adc16.c ****     /* Select the hardware compare working mode. */
 243:../drivers/fsl_adc16.c ****     switch (config->hardwareCompareMode)
 374              		.loc 1 243 0
 375 000c 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 376 000e 022A     		cmp	r2, #2
 377 0010 0DD0     		beq	.L45
 378 0012 032A     		cmp	r2, #3
 379 0014 0ED0     		beq	.L46
 380 0016 012A     		cmp	r2, #1
 240:../drivers/fsl_adc16.c **** 
 381              		.loc 1 240 0
 382 0018 14BF     		ite	ne
 383 001a 43F02003 		orrne	r3, r3, #32
 384              	.LVL34:
 244:../drivers/fsl_adc16.c ****     {
 245:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode0:
 246:../drivers/fsl_adc16.c ****             break;
 247:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode1:
 248:../drivers/fsl_adc16.c ****             tmp32 |= ADC_SC2_ACFGT_MASK;
 385              		.loc 1 248 0
 386 001e 43F03003 		orreq	r3, r3, #48
 387              	.LVL35:
 388              	.L48:
 249:../drivers/fsl_adc16.c ****             break;
 250:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode2:
 251:../drivers/fsl_adc16.c ****             tmp32 |= ADC_SC2_ACREN_MASK;
 252:../drivers/fsl_adc16.c ****             break;
 253:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode3:
 254:../drivers/fsl_adc16.c ****             tmp32 |= ADC_SC2_ACFGT_MASK | ADC_SC2_ACREN_MASK;
 255:../drivers/fsl_adc16.c ****             break;
 256:../drivers/fsl_adc16.c ****         default:
 257:../drivers/fsl_adc16.c ****             break;
 258:../drivers/fsl_adc16.c ****     }
 259:../drivers/fsl_adc16.c ****     base->SC2 = tmp32;
 389              		.loc 1 259 0
 390 0022 0362     		str	r3, [r0, #32]
 260:../drivers/fsl_adc16.c **** 
 261:../drivers/fsl_adc16.c ****     /* Load the compare values. */
 262:../drivers/fsl_adc16.c ****     base->CV1 = ADC_CV1_CV(config->value1);
 391              		.loc 1 262 0
 392 0024 4B88     		ldrh	r3, [r1, #2]
 393              	.LVL36:
 394 0026 8361     		str	r3, [r0, #24]
 395              	.LVL37:
 263:../drivers/fsl_adc16.c ****     base->CV2 = ADC_CV2_CV(config->value2);
 396              		.loc 1 263 0
 397 0028 8B88     		ldrh	r3, [r1, #4]
 398 002a C361     		str	r3, [r0, #28]
 399 002c 7047     		bx	lr
 400              	.LVL38:
 401              	.L45:
 251:../drivers/fsl_adc16.c ****             break;
 402              		.loc 1 251 0
 403 002e 43F02803 		orr	r3, r3, #40
 404              	.LVL39:
 252:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode3:
 405              		.loc 1 252 0
 406 0032 F6E7     		b	.L48
 407              	.LVL40:
 408              	.L46:
 254:../drivers/fsl_adc16.c ****             break;
 409              		.loc 1 254 0
 410 0034 43F03803 		orr	r3, r3, #56
 411              	.LVL41:
 255:../drivers/fsl_adc16.c ****         default:
 412              		.loc 1 255 0
 413 0038 F3E7     		b	.L48
 414              		.cfi_endproc
 415              	.LFE157:
 417              		.section	.text.ADC16_SetHardwareAverage,"ax",%progbits
 418              		.align	1
 419              		.global	ADC16_SetHardwareAverage
 420              		.syntax unified
 421              		.thumb
 422              		.thumb_func
 423              		.fpu fpv4-sp-d16
 425              	ADC16_SetHardwareAverage:
 426              	.LFB158:
 264:../drivers/fsl_adc16.c **** }
 265:../drivers/fsl_adc16.c **** 
 266:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_HW_AVERAGE) && FSL_FEATURE_ADC16_HAS_HW_AVERAGE
 267:../drivers/fsl_adc16.c **** void ADC16_SetHardwareAverage(ADC_Type *base, adc16_hardware_average_mode_t mode)
 268:../drivers/fsl_adc16.c **** {
 427              		.loc 1 268 0
 428              		.cfi_startproc
 429              		@ args = 0, pretend = 0, frame = 0
 430              		@ frame_needed = 0, uses_anonymous_args = 0
 431              		@ link register save eliminated.
 432              	.LVL42:
 269:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
 270:../drivers/fsl_adc16.c **** 
 271:../drivers/fsl_adc16.c ****     if (kADC16_HardwareAverageDisabled != mode)
 433              		.loc 1 271 0
 434 0000 0429     		cmp	r1, #4
 269:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
 435              		.loc 1 269 0
 436 0002 436A     		ldr	r3, [r0, #36]
 272:../drivers/fsl_adc16.c ****     {
 273:../drivers/fsl_adc16.c ****         tmp32 |= ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(mode);
 437              		.loc 1 273 0
 438 0004 18BF     		it	ne
 439 0006 01F00301 		andne	r1, r1, #3
 440              	.LVL43:
 269:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
 441              		.loc 1 269 0
 442 000a 23F00703 		bic	r3, r3, #7
 443              	.LVL44:
 444              		.loc 1 273 0
 445 000e 1CBF     		itt	ne
 446 0010 41F00401 		orrne	r1, r1, #4
 447 0014 0B43     		orrne	r3, r3, r1
 448              	.LVL45:
 274:../drivers/fsl_adc16.c ****     }
 275:../drivers/fsl_adc16.c ****     base->SC3 = tmp32;
 449              		.loc 1 275 0
 450 0016 4362     		str	r3, [r0, #36]
 451 0018 7047     		bx	lr
 452              		.cfi_endproc
 453              	.LFE158:
 455              		.section	.text.ADC16_GetStatusFlags,"ax",%progbits
 456              		.align	1
 457              		.global	ADC16_GetStatusFlags
 458              		.syntax unified
 459              		.thumb
 460              		.thumb_func
 461              		.fpu fpv4-sp-d16
 463              	ADC16_GetStatusFlags:
 464              	.LFB159:
 276:../drivers/fsl_adc16.c **** }
 277:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_HW_AVERAGE */
 278:../drivers/fsl_adc16.c **** 
 279:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_PGA) && FSL_FEATURE_ADC16_HAS_PGA
 280:../drivers/fsl_adc16.c **** void ADC16_SetPGAConfig(ADC_Type *base, const adc16_pga_config_t *config)
 281:../drivers/fsl_adc16.c **** {
 282:../drivers/fsl_adc16.c ****     uint32_t tmp32;
 283:../drivers/fsl_adc16.c **** 
 284:../drivers/fsl_adc16.c ****     if (!config) /* Passing "NULL" is to disable the feature. */
 285:../drivers/fsl_adc16.c ****     {
 286:../drivers/fsl_adc16.c ****         base->PGA = 0U;
 287:../drivers/fsl_adc16.c ****         return;
 288:../drivers/fsl_adc16.c ****     }
 289:../drivers/fsl_adc16.c **** 
 290:../drivers/fsl_adc16.c ****     /* Enable the PGA and set the gain value. */
 291:../drivers/fsl_adc16.c ****     tmp32 = ADC_PGA_PGAEN_MASK | ADC_PGA_PGAG(config->pgaGain);
 292:../drivers/fsl_adc16.c **** 
 293:../drivers/fsl_adc16.c ****     /* Configure the misc features for PGA. */
 294:../drivers/fsl_adc16.c ****     if (config->enableRunInNormalMode)
 295:../drivers/fsl_adc16.c ****     {
 296:../drivers/fsl_adc16.c ****         tmp32 |= ADC_PGA_PGALPb_MASK;
 297:../drivers/fsl_adc16.c ****     }
 298:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_PGA_CHOPPING) && FSL_FEATURE_ADC16_HAS_PGA_CHOPPING
 299:../drivers/fsl_adc16.c ****     if (config->disablePgaChopping)
 300:../drivers/fsl_adc16.c ****     {
 301:../drivers/fsl_adc16.c ****         tmp32 |= ADC_PGA_PGACHPb_MASK;
 302:../drivers/fsl_adc16.c ****     }
 303:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_PGA_CHOPPING */
 304:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASUREMENT) && FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASU
 305:../drivers/fsl_adc16.c ****     if (config->enableRunInOffsetMeasurement)
 306:../drivers/fsl_adc16.c ****     {
 307:../drivers/fsl_adc16.c ****         tmp32 |= ADC_PGA_PGAOFSM_MASK;
 308:../drivers/fsl_adc16.c ****     }
 309:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASUREMENT */
 310:../drivers/fsl_adc16.c ****     base->PGA = tmp32;
 311:../drivers/fsl_adc16.c **** }
 312:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_PGA */
 313:../drivers/fsl_adc16.c **** 
 314:../drivers/fsl_adc16.c **** uint32_t ADC16_GetStatusFlags(ADC_Type *base)
 315:../drivers/fsl_adc16.c **** {
 465              		.loc 1 315 0
 466              		.cfi_startproc
 467              		@ args = 0, pretend = 0, frame = 0
 468              		@ frame_needed = 0, uses_anonymous_args = 0
 469              		@ link register save eliminated.
 470              	.LVL46:
 316:../drivers/fsl_adc16.c ****     uint32_t ret = 0;
 317:../drivers/fsl_adc16.c **** 
 318:../drivers/fsl_adc16.c ****     if (0U != (base->SC2 & ADC_SC2_ADACT_MASK))
 471              		.loc 1 318 0
 472 0000 036A     		ldr	r3, [r0, #32]
 319:../drivers/fsl_adc16.c ****     {
 320:../drivers/fsl_adc16.c ****         ret |= kADC16_ActiveFlag;
 321:../drivers/fsl_adc16.c ****     }
 322:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 323:../drivers/fsl_adc16.c ****     if (0U != (base->SC3 & ADC_SC3_CALF_MASK))
 473              		.loc 1 323 0
 474 0002 426A     		ldr	r2, [r0, #36]
 320:../drivers/fsl_adc16.c ****     }
 475              		.loc 1 320 0
 476 0004 03F08003 		and	r3, r3, #128
 477              	.LVL47:
 478              		.loc 1 323 0
 479 0008 5206     		lsls	r2, r2, #25
 324:../drivers/fsl_adc16.c ****     {
 325:../drivers/fsl_adc16.c ****         ret |= kADC16_CalibrationFailedFlag;
 480              		.loc 1 325 0
 481 000a 48BF     		it	mi
 482 000c 43F04003 		orrmi	r3, r3, #64
 483              	.LVL48:
 326:../drivers/fsl_adc16.c ****     }
 327:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 328:../drivers/fsl_adc16.c ****     return ret;
 329:../drivers/fsl_adc16.c **** }
 484              		.loc 1 329 0
 485 0010 1846     		mov	r0, r3
 486              	.LVL49:
 487 0012 7047     		bx	lr
 488              		.cfi_endproc
 489              	.LFE159:
 491              		.section	.text.ADC16_DoAutoCalibration,"ax",%progbits
 492              		.align	1
 493              		.global	ADC16_DoAutoCalibration
 494              		.syntax unified
 495              		.thumb
 496              		.thumb_func
 497              		.fpu fpv4-sp-d16
 499              	ADC16_DoAutoCalibration:
 500              	.LFB155:
 160:../drivers/fsl_adc16.c ****     bool bHWTrigger = false;
 501              		.loc 1 160 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 8
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505              	.LVL50:
 506 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 507              		.cfi_def_cfa_offset 32
 508              		.cfi_offset 4, -20
 509              		.cfi_offset 5, -16
 510              		.cfi_offset 6, -12
 511              		.cfi_offset 7, -8
 512              		.cfi_offset 14, -4
 167:../drivers/fsl_adc16.c ****     {
 513              		.loc 1 167 0
 514 0002 056A     		ldr	r5, [r0, #32]
 515 0004 15F04005 		ands	r5, r5, #64
 516              	.LVL51:
 170:../drivers/fsl_adc16.c ****     }
 517              		.loc 1 170 0
 518 0008 1EBF     		ittt	ne
 519 000a 036A     		ldrne	r3, [r0, #32]
 520 000c 23F04003 		bicne	r3, r3, #64
 521 0010 0362     		strne	r3, [r0, #32]
 174:../drivers/fsl_adc16.c ****     while (0U == (kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
 522              		.loc 1 174 0
 523 0012 436A     		ldr	r3, [r0, #36]
 524 0014 43F0C003 		orr	r3, r3, #192
 160:../drivers/fsl_adc16.c ****     bool bHWTrigger = false;
 525              		.loc 1 160 0
 526 0018 0146     		mov	r1, r0
 169:../drivers/fsl_adc16.c ****         base->SC2 &= ~ADC_SC2_ADTRG_MASK;
 527              		.loc 1 169 0
 528 001a 18BF     		it	ne
 529 001c 0125     		movne	r5, #1
 530              	.LVL52:
 174:../drivers/fsl_adc16.c ****     while (0U == (kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
 531              		.loc 1 174 0
 532 001e 4362     		str	r3, [r0, #36]
 533              	.LVL53:
 534              	.L63:
 535              	.LBB26:
 536              	.LBB27:
 330:../drivers/fsl_adc16.c **** 
 331:../drivers/fsl_adc16.c **** void ADC16_ClearStatusFlags(ADC_Type *base, uint32_t mask)
 332:../drivers/fsl_adc16.c **** {
 333:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 334:../drivers/fsl_adc16.c ****     if (0U != (mask & kADC16_CalibrationFailedFlag))
 335:../drivers/fsl_adc16.c ****     {
 336:../drivers/fsl_adc16.c ****         base->SC3 |= ADC_SC3_CALF_MASK;
 337:../drivers/fsl_adc16.c ****     }
 338:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 339:../drivers/fsl_adc16.c **** }
 340:../drivers/fsl_adc16.c **** 
 341:../drivers/fsl_adc16.c **** void ADC16_SetChannelConfig(ADC_Type *base, uint32_t channelGroup, const adc16_channel_config_t *co
 342:../drivers/fsl_adc16.c **** {
 343:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 344:../drivers/fsl_adc16.c ****     assert(NULL != config);
 345:../drivers/fsl_adc16.c **** 
 346:../drivers/fsl_adc16.c ****     uint32_t sc1 = ADC_SC1_ADCH(config->channelNumber); /* Set the channel number. */
 347:../drivers/fsl_adc16.c **** 
 348:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
 349:../drivers/fsl_adc16.c ****     /* Enable the differential conversion. */
 350:../drivers/fsl_adc16.c ****     if (config->enableDifferentialConversion)
 351:../drivers/fsl_adc16.c ****     {
 352:../drivers/fsl_adc16.c ****         sc1 |= ADC_SC1_DIFF_MASK;
 353:../drivers/fsl_adc16.c ****     }
 354:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
 355:../drivers/fsl_adc16.c ****     /* Enable the interrupt when the conversion is done. */
 356:../drivers/fsl_adc16.c ****     if (config->enableInterruptOnConversionCompleted)
 357:../drivers/fsl_adc16.c ****     {
 358:../drivers/fsl_adc16.c ****         sc1 |= ADC_SC1_AIEN_MASK;
 359:../drivers/fsl_adc16.c ****     }
 360:../drivers/fsl_adc16.c ****     base->SC1[channelGroup] = sc1;
 361:../drivers/fsl_adc16.c **** }
 362:../drivers/fsl_adc16.c **** 
 363:../drivers/fsl_adc16.c **** uint32_t ADC16_GetChannelStatusFlags(ADC_Type *base, uint32_t channelGroup)
 364:../drivers/fsl_adc16.c **** {
 365:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 366:../drivers/fsl_adc16.c **** 
 367:../drivers/fsl_adc16.c ****     uint32_t ret = 0U;
 368:../drivers/fsl_adc16.c **** 
 369:../drivers/fsl_adc16.c ****     if (0U != (base->SC1[channelGroup] & ADC_SC1_COCO_MASK))
 537              		.loc 1 369 0
 538 0020 0B68     		ldr	r3, [r1]
 539              	.LBE27:
 540              	.LBE26:
 175:../drivers/fsl_adc16.c ****     {
 541              		.loc 1 175 0
 542 0022 1A06     		lsls	r2, r3, #24
 543 0024 36D5     		bpl	.L66
 163:../drivers/fsl_adc16.c **** 
 544              		.loc 1 163 0
 545 0026 0024     		movs	r4, #0
 546              	.L64:
 547              	.LVL54:
 184:../drivers/fsl_adc16.c **** 
 548              		.loc 1 184 0
 549 0028 0B69     		ldr	r3, [r1, #16]
 550 002a 0193     		str	r3, [sp, #4]
 187:../drivers/fsl_adc16.c ****     {
 551              		.loc 1 187 0
 552 002c 1DB1     		cbz	r5, .L67
 189:../drivers/fsl_adc16.c ****     }
 553              		.loc 1 189 0
 554 002e 0B6A     		ldr	r3, [r1, #32]
 555 0030 43F04003 		orr	r3, r3, #64
 556 0034 0B62     		str	r3, [r1, #32]
 557              	.L67:
 192:../drivers/fsl_adc16.c ****     {
 558              		.loc 1 192 0
 559 0036 0846     		mov	r0, r1
 560 0038 FFF7FEFF 		bl	ADC16_GetStatusFlags
 561              	.LVL55:
 562 003c 4306     		lsls	r3, r0, #25
 563 003e 30D4     		bmi	.L72
 196:../drivers/fsl_adc16.c ****     {
 564              		.loc 1 196 0
 565 0040 2CBB     		cbnz	r4, .L61
 202:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 566              		.loc 1 202 0
 567 0042 CB6C     		ldr	r3, [r1, #76]
 568 0044 8F6C     		ldr	r7, [r1, #72]
 569 0046 4E6C     		ldr	r6, [r1, #68]
 570 0048 0D6C     		ldr	r5, [r1, #64]
 571              	.LVL56:
 572 004a C86B     		ldr	r0, [r1, #60]
 573 004c 8A6B     		ldr	r2, [r1, #56]
 574 004e 3B44     		add	r3, r3, r7
 575 0050 3344     		add	r3, r3, r6
 576 0052 2B44     		add	r3, r3, r5
 577 0054 0344     		add	r3, r3, r0
 578 0056 1344     		add	r3, r3, r2
 579 0058 0193     		str	r3, [sp, #4]
 203:../drivers/fsl_adc16.c ****     base->PG = tmp32;
 580              		.loc 1 203 0
 581 005a 019B     		ldr	r3, [sp, #4]
 582 005c 5B08     		lsrs	r3, r3, #1
 583 005e 43F40043 		orr	r3, r3, #32768
 584 0062 0193     		str	r3, [sp, #4]
 204:../drivers/fsl_adc16.c **** 
 585              		.loc 1 204 0
 586 0064 019B     		ldr	r3, [sp, #4]
 587 0066 CB62     		str	r3, [r1, #44]
 207:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 588              		.loc 1 207 0
 589 0068 CB6E     		ldr	r3, [r1, #108]
 590 006a 8F6E     		ldr	r7, [r1, #104]
 591 006c 4E6E     		ldr	r6, [r1, #100]
 592 006e 0D6E     		ldr	r5, [r1, #96]
 593 0070 C86D     		ldr	r0, [r1, #92]
 594 0072 8A6D     		ldr	r2, [r1, #88]
 595 0074 3B44     		add	r3, r3, r7
 596 0076 3344     		add	r3, r3, r6
 597 0078 2B44     		add	r3, r3, r5
 598 007a 0344     		add	r3, r3, r0
 599 007c 1344     		add	r3, r3, r2
 600 007e 0193     		str	r3, [sp, #4]
 208:../drivers/fsl_adc16.c ****     base->MG = tmp32;
 601              		.loc 1 208 0
 602 0080 019B     		ldr	r3, [sp, #4]
 603 0082 5B08     		lsrs	r3, r3, #1
 604 0084 43F40043 		orr	r3, r3, #32768
 605 0088 0193     		str	r3, [sp, #4]
 209:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
 606              		.loc 1 209 0
 607 008a 019B     		ldr	r3, [sp, #4]
 608 008c 0B63     		str	r3, [r1, #48]
 609              	.LVL57:
 610              	.L61:
 213:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 611              		.loc 1 213 0
 612 008e 2046     		mov	r0, r4
 613 0090 03B0     		add	sp, sp, #12
 614              		.cfi_remember_state
 615              		.cfi_def_cfa_offset 20
 616              		@ sp needed
 617 0092 F0BD     		pop	{r4, r5, r6, r7, pc}
 618              	.LVL58:
 619              	.L66:
 620              		.cfi_restore_state
 178:../drivers/fsl_adc16.c ****         {
 621              		.loc 1 178 0
 622 0094 0846     		mov	r0, r1
 623 0096 FFF7FEFF 		bl	ADC16_GetStatusFlags
 624              	.LVL59:
 625 009a 4006     		lsls	r0, r0, #25
 626 009c C0D5     		bpl	.L63
 180:../drivers/fsl_adc16.c ****             break;
 627              		.loc 1 180 0
 628 009e 0124     		movs	r4, #1
 629 00a0 C2E7     		b	.L64
 630              	.LVL60:
 631              	.L72:
 632 00a2 0124     		movs	r4, #1
 633              	.LVL61:
 634 00a4 F3E7     		b	.L61
 635              		.cfi_endproc
 636              	.LFE155:
 638              		.section	.text.ADC16_ClearStatusFlags,"ax",%progbits
 639              		.align	1
 640              		.global	ADC16_ClearStatusFlags
 641              		.syntax unified
 642              		.thumb
 643              		.thumb_func
 644              		.fpu fpv4-sp-d16
 646              	ADC16_ClearStatusFlags:
 647              	.LFB160:
 332:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 648              		.loc 1 332 0
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 0
 651              		@ frame_needed = 0, uses_anonymous_args = 0
 652              		@ link register save eliminated.
 653              	.LVL62:
 334:../drivers/fsl_adc16.c ****     {
 654              		.loc 1 334 0
 655 0000 4B06     		lsls	r3, r1, #25
 336:../drivers/fsl_adc16.c ****     }
 656              		.loc 1 336 0
 657 0002 42BF     		ittt	mi
 658 0004 436A     		ldrmi	r3, [r0, #36]
 659 0006 43F04003 		orrmi	r3, r3, #64
 660 000a 4362     		strmi	r3, [r0, #36]
 661 000c 7047     		bx	lr
 662              		.cfi_endproc
 663              	.LFE160:
 665              		.section	.text.ADC16_SetChannelConfig,"ax",%progbits
 666              		.align	1
 667              		.global	ADC16_SetChannelConfig
 668              		.syntax unified
 669              		.thumb
 670              		.thumb_func
 671              		.fpu fpv4-sp-d16
 673              	ADC16_SetChannelConfig:
 674              	.LFB161:
 342:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 675              		.loc 1 342 0
 676              		.cfi_startproc
 677              		@ args = 0, pretend = 0, frame = 0
 678              		@ frame_needed = 0, uses_anonymous_args = 0
 679              	.LVL63:
 680 0000 10B5     		push	{r4, lr}
 681              		.cfi_def_cfa_offset 8
 682              		.cfi_offset 4, -8
 683              		.cfi_offset 14, -4
 346:../drivers/fsl_adc16.c **** 
 684              		.loc 1 346 0
 685 0002 1368     		ldr	r3, [r2]
 350:../drivers/fsl_adc16.c ****     {
 686              		.loc 1 350 0
 687 0004 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 346:../drivers/fsl_adc16.c **** 
 688              		.loc 1 346 0
 689 0006 03F01F03 		and	r3, r3, #31
 690              	.LVL64:
 350:../drivers/fsl_adc16.c ****     {
 691              		.loc 1 350 0
 692 000a 0CB1     		cbz	r4, .L82
 352:../drivers/fsl_adc16.c ****     }
 693              		.loc 1 352 0
 694 000c 43F02003 		orr	r3, r3, #32
 695              	.LVL65:
 696              	.L82:
 356:../drivers/fsl_adc16.c ****     {
 697              		.loc 1 356 0
 698 0010 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 699              	.LVL66:
 700 0012 0AB1     		cbz	r2, .L83
 358:../drivers/fsl_adc16.c ****     }
 701              		.loc 1 358 0
 702 0014 43F04003 		orr	r3, r3, #64
 703              	.LVL67:
 704              	.L83:
 360:../drivers/fsl_adc16.c **** }
 705              		.loc 1 360 0
 706 0018 40F82130 		str	r3, [r0, r1, lsl #2]
 707 001c 10BD     		pop	{r4, pc}
 708              		.cfi_endproc
 709              	.LFE161:
 711              		.section	.text.ADC16_GetChannelStatusFlags,"ax",%progbits
 712              		.align	1
 713              		.global	ADC16_GetChannelStatusFlags
 714              		.syntax unified
 715              		.thumb
 716              		.thumb_func
 717              		.fpu fpv4-sp-d16
 719              	ADC16_GetChannelStatusFlags:
 720              	.LFB162:
 364:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 721              		.loc 1 364 0
 722              		.cfi_startproc
 723              		@ args = 0, pretend = 0, frame = 0
 724              		@ frame_needed = 0, uses_anonymous_args = 0
 725              		@ link register save eliminated.
 726              	.LVL68:
 727              		.loc 1 369 0
 728 0000 50F82100 		ldr	r0, [r0, r1, lsl #2]
 729              	.LVL69:
 370:../drivers/fsl_adc16.c ****     {
 371:../drivers/fsl_adc16.c ****         ret |= kADC16_ChannelConversionDoneFlag;
 372:../drivers/fsl_adc16.c ****     }
 373:../drivers/fsl_adc16.c ****     return ret;
 374:../drivers/fsl_adc16.c **** }
 730              		.loc 1 374 0
 731 0004 00F08000 		and	r0, r0, #128
 732 0008 7047     		bx	lr
 733              		.cfi_endproc
 734              	.LFE162:
 736              		.section	.rodata.s_adc16Clocks,"a",%progbits
 737              		.align	2
 738              		.set	.LANCHOR0,. + 0
 741              	s_adc16Clocks:
 742 0000 1B003C10 		.word	272367643
 743 0004 1B003010 		.word	271581211
 744              		.text
 745              	.Letext0:
 746              		.file 3 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 747              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 748              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 749              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 750              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 751              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 752              		.file 9 "../CMSIS/core_cm4.h"
 753              		.file 10 "../CMSIS/system_MK64F12.h"
 754              		.file 11 "../CMSIS/MK64F12.h"
 755              		.file 12 "../drivers/fsl_common.h"
 756              		.file 13 "../drivers/fsl_adc16.h"
