   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_adc16.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ADC16_Init,"ax",%progbits
  18              		.align	1
  19              		.global	ADC16_Init
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	ADC16_Init:
  26              	.LFB152:
  27              		.file 1 "../drivers/fsl_adc16.c"
   1:../drivers/fsl_adc16.c **** /*
   2:../drivers/fsl_adc16.c ****  * The Clear BSD License
   3:../drivers/fsl_adc16.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_adc16.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_adc16.c ****  * All rights reserved.
   6:../drivers/fsl_adc16.c ****  *
   7:../drivers/fsl_adc16.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_adc16.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_adc16.c ****  * that the following conditions are met:
  10:../drivers/fsl_adc16.c ****  *
  11:../drivers/fsl_adc16.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_adc16.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_adc16.c ****  *
  14:../drivers/fsl_adc16.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_adc16.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_adc16.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_adc16.c ****  *
  18:../drivers/fsl_adc16.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_adc16.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_adc16.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_adc16.c ****  *
  22:../drivers/fsl_adc16.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_adc16.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_adc16.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_adc16.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_adc16.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_adc16.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_adc16.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_adc16.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_adc16.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_adc16.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_adc16.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_adc16.c ****  */
  34:../drivers/fsl_adc16.c **** 
  35:../drivers/fsl_adc16.c **** #include "fsl_adc16.h"
  36:../drivers/fsl_adc16.c **** 
  37:../drivers/fsl_adc16.c **** /*******************************************************************************
  38:../drivers/fsl_adc16.c ****  * Prototypes
  39:../drivers/fsl_adc16.c ****  ******************************************************************************/
  40:../drivers/fsl_adc16.c **** /*!
  41:../drivers/fsl_adc16.c ****  * @brief Get instance number for ADC16 module.
  42:../drivers/fsl_adc16.c ****  *
  43:../drivers/fsl_adc16.c ****  * @param base ADC16 peripheral base address
  44:../drivers/fsl_adc16.c ****  */
  45:../drivers/fsl_adc16.c **** static uint32_t ADC16_GetInstance(ADC_Type *base);
  46:../drivers/fsl_adc16.c **** 
  47:../drivers/fsl_adc16.c **** /*******************************************************************************
  48:../drivers/fsl_adc16.c ****  * Variables
  49:../drivers/fsl_adc16.c ****  ******************************************************************************/
  50:../drivers/fsl_adc16.c **** /*! @brief Pointers to ADC16 bases for each instance. */
  51:../drivers/fsl_adc16.c **** static ADC_Type *const s_adc16Bases[] = ADC_BASE_PTRS;
  52:../drivers/fsl_adc16.c **** 
  53:../drivers/fsl_adc16.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  54:../drivers/fsl_adc16.c **** /*! @brief Pointers to ADC16 clocks for each instance. */
  55:../drivers/fsl_adc16.c **** static const clock_ip_name_t s_adc16Clocks[] = ADC16_CLOCKS;
  56:../drivers/fsl_adc16.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  57:../drivers/fsl_adc16.c **** 
  58:../drivers/fsl_adc16.c **** /*******************************************************************************
  59:../drivers/fsl_adc16.c ****  * Code
  60:../drivers/fsl_adc16.c ****  ******************************************************************************/
  61:../drivers/fsl_adc16.c **** static uint32_t ADC16_GetInstance(ADC_Type *base)
  62:../drivers/fsl_adc16.c **** {
  63:../drivers/fsl_adc16.c ****     uint32_t instance;
  64:../drivers/fsl_adc16.c **** 
  65:../drivers/fsl_adc16.c ****     /* Find the instance index from base address mappings. */
  66:../drivers/fsl_adc16.c ****     for (instance = 0; instance < ARRAY_SIZE(s_adc16Bases); instance++)
  67:../drivers/fsl_adc16.c ****     {
  68:../drivers/fsl_adc16.c ****         if (s_adc16Bases[instance] == base)
  69:../drivers/fsl_adc16.c ****         {
  70:../drivers/fsl_adc16.c ****             break;
  71:../drivers/fsl_adc16.c ****         }
  72:../drivers/fsl_adc16.c ****     }
  73:../drivers/fsl_adc16.c **** 
  74:../drivers/fsl_adc16.c ****     assert(instance < ARRAY_SIZE(s_adc16Bases));
  75:../drivers/fsl_adc16.c **** 
  76:../drivers/fsl_adc16.c ****     return instance;
  77:../drivers/fsl_adc16.c **** }
  78:../drivers/fsl_adc16.c **** 
  79:../drivers/fsl_adc16.c **** void ADC16_Init(ADC_Type *base, const adc16_config_t *config)
  80:../drivers/fsl_adc16.c **** {
  28              		.loc 1 80 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33              	.LBB8:
  34              	.LBB9:
  68:../drivers/fsl_adc16.c ****         {
  35              		.loc 1 68 0
  36 0000 2A4B     		ldr	r3, .L28
  37 0002 9842     		cmp	r0, r3
  38              	.LBE9:
  39              	.LBE8:
  40              		.loc 1 80 0
  41 0004 30B5     		push	{r4, r5, lr}
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 5, -8
  45              		.cfi_offset 14, -4
  46              	.LBB12:
  47              	.LBB10:
  68:../drivers/fsl_adc16.c ****         {
  48              		.loc 1 68 0
  49 0006 4BD0     		beq	.L10
  50              	.LVL1:
  66:../drivers/fsl_adc16.c ****     {
  51              		.loc 1 66 0
  52 0008 03F50023 		add	r3, r3, #524288
  53 000c 9842     		cmp	r0, r3
  54 000e 0CBF     		ite	eq
  55 0010 0123     		moveq	r3, #1
  56 0012 0223     		movne	r3, #2
  57              	.LVL2:
  58              	.L2:
  59              	.LBE10:
  60              	.LBE12:
  81:../drivers/fsl_adc16.c ****     assert(NULL != config);
  82:../drivers/fsl_adc16.c **** 
  83:../drivers/fsl_adc16.c ****     uint32_t tmp32;
  84:../drivers/fsl_adc16.c **** 
  85:../drivers/fsl_adc16.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  86:../drivers/fsl_adc16.c ****     /* Enable the clock. */
  87:../drivers/fsl_adc16.c ****     CLOCK_EnableClock(s_adc16Clocks[ADC16_GetInstance(base)]);
  61              		.loc 1 87 0
  62 0014 264A     		ldr	r2, .L28+4
  63 0016 52F82340 		ldr	r4, [r2, r3, lsl #2]
  64              	.LVL3:
  65              	.LBB13:
  66              	.LBB14:
  67              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  68              		.loc 2 694 0
  69 001a 230C     		lsrs	r3, r4, #16
  70 001c 03F18043 		add	r3, r3, #1073741824
  71 0020 03F58E23 		add	r3, r3, #290816
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
  72              		.loc 2 695 0
  73 0024 A4B2     		uxth	r4, r4
  74              	.LVL4:
  75 0026 1D68     		ldr	r5, [r3]
  76 0028 0122     		movs	r2, #1
  77 002a A240     		lsls	r2, r2, r4
  78 002c 2A43     		orrs	r2, r2, r5
  79 002e 1A60     		str	r2, [r3]
  80              	.LBE14:
  81              	.LBE13:
  88:../drivers/fsl_adc16.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  89:../drivers/fsl_adc16.c **** 
  90:../drivers/fsl_adc16.c ****     /* ADCx_CFG1. */
  91:../drivers/fsl_adc16.c ****     tmp32 = ADC_CFG1_ADICLK(config->clockSource) | ADC_CFG1_MODE(config->resolution);
  82              		.loc 1 91 0
  83 0030 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
  84 0032 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
  92:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
  85              		.loc 1 92 0
  86 0034 4C79     		ldrb	r4, [r1, #5]	@ zero_extendqisi2
  91:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
  87              		.loc 1 91 0
  88 0036 9B00     		lsls	r3, r3, #2
  89 0038 03F00C03 		and	r3, r3, #12
  90 003c 02F00302 		and	r2, r2, #3
  91 0040 1A43     		orrs	r2, r2, r3
  92              	.LVL5:
  93:../drivers/fsl_adc16.c ****     {
  94:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG1_ADLSMP_MASK;
  95:../drivers/fsl_adc16.c ****     }
  96:../drivers/fsl_adc16.c ****     tmp32 |= ADC_CFG1_ADIV(config->clockDivider);
  93              		.loc 1 96 0
  94 0042 CB78     		ldrb	r3, [r1, #3]	@ zero_extendqisi2
  92:../drivers/fsl_adc16.c ****     {
  95              		.loc 1 92 0
  96 0044 042C     		cmp	r4, #4
  97              		.loc 1 96 0
  98 0046 4FEA4313 		lsl	r3, r3, #5
  94:../drivers/fsl_adc16.c ****     }
  99              		.loc 1 94 0
 100 004a 18BF     		it	ne
 101 004c 42F01002 		orrne	r2, r2, #16
 102              	.LVL6:
 103              		.loc 1 96 0
 104 0050 03F06003 		and	r3, r3, #96
 105 0054 1343     		orrs	r3, r3, r2
 106              	.LVL7:
  97:../drivers/fsl_adc16.c ****     if (config->enableLowPower)
 107              		.loc 1 97 0
 108 0056 CA79     		ldrb	r2, [r1, #7]	@ zero_extendqisi2
 109 0058 0AB1     		cbz	r2, .L4
  98:../drivers/fsl_adc16.c ****     {
  99:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG1_ADLPC_MASK;
 110              		.loc 1 99 0
 111 005a 43F08003 		orr	r3, r3, #128
 112              	.LVL8:
 113              	.L4:
 100:../drivers/fsl_adc16.c ****     }
 101:../drivers/fsl_adc16.c ****     base->CFG1 = tmp32;
 114              		.loc 1 101 0
 115 005e 8360     		str	r3, [r0, #8]
 102:../drivers/fsl_adc16.c **** 
 103:../drivers/fsl_adc16.c ****     /* ADCx_CFG2. */
 104:../drivers/fsl_adc16.c ****     tmp32 = base->CFG2 & ~(ADC_CFG2_ADACKEN_MASK | ADC_CFG2_ADHSC_MASK | ADC_CFG2_ADLSTS_MASK);
 116              		.loc 1 104 0
 117 0060 C368     		ldr	r3, [r0, #12]
 118              	.LVL9:
 105:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
 106:../drivers/fsl_adc16.c ****     {
 107:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG2_ADLSTS(config->longSampleMode);
 108:../drivers/fsl_adc16.c ****     }
 109:../drivers/fsl_adc16.c ****     if (config->enableHighSpeed)
 119              		.loc 1 109 0
 120 0062 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 105:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
 121              		.loc 1 105 0
 122 0064 042C     		cmp	r4, #4
 104:../drivers/fsl_adc16.c ****     if (kADC16_LongSampleDisabled != config->longSampleMode)
 123              		.loc 1 104 0
 124 0066 23F00F03 		bic	r3, r3, #15
 125              	.LVL10:
 107:../drivers/fsl_adc16.c ****     }
 126              		.loc 1 107 0
 127 006a 1CBF     		itt	ne
 128 006c 04F00304 		andne	r4, r4, #3
 129 0070 2343     		orrne	r3, r3, r4
 130              	.LVL11:
 131              		.loc 1 109 0
 132 0072 0AB1     		cbz	r2, .L6
 110:../drivers/fsl_adc16.c ****     {
 111:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG2_ADHSC_MASK;
 133              		.loc 1 111 0
 134 0074 43F00403 		orr	r3, r3, #4
 135              	.LVL12:
 136              	.L6:
 112:../drivers/fsl_adc16.c ****     }
 113:../drivers/fsl_adc16.c ****     if (config->enableAsynchronousClock)
 137              		.loc 1 113 0
 138 0078 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 139 007a 0AB1     		cbz	r2, .L7
 114:../drivers/fsl_adc16.c ****     {
 115:../drivers/fsl_adc16.c ****         tmp32 |= ADC_CFG2_ADACKEN_MASK;
 140              		.loc 1 115 0
 141 007c 43F00803 		orr	r3, r3, #8
 142              	.LVL13:
 143              	.L7:
 116:../drivers/fsl_adc16.c ****     }
 117:../drivers/fsl_adc16.c ****     base->CFG2 = tmp32;
 144              		.loc 1 117 0
 145 0080 C360     		str	r3, [r0, #12]
 118:../drivers/fsl_adc16.c **** 
 119:../drivers/fsl_adc16.c ****     /* ADCx_SC2. */
 120:../drivers/fsl_adc16.c ****     tmp32 = base->SC2 & ~(ADC_SC2_REFSEL_MASK);
 146              		.loc 1 120 0
 147 0082 026A     		ldr	r2, [r0, #32]
 121:../drivers/fsl_adc16.c ****     tmp32 |= ADC_SC2_REFSEL(config->referenceVoltageSource);
 148              		.loc 1 121 0
 149 0084 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 150              	.LVL14:
 120:../drivers/fsl_adc16.c ****     tmp32 |= ADC_SC2_REFSEL(config->referenceVoltageSource);
 151              		.loc 1 120 0
 152 0086 22F00302 		bic	r2, r2, #3
 153              	.LVL15:
 154              		.loc 1 121 0
 155 008a 03F00303 		and	r3, r3, #3
 156 008e 1343     		orrs	r3, r3, r2
 157              	.LVL16:
 122:../drivers/fsl_adc16.c ****     base->SC2 = tmp32;
 158              		.loc 1 122 0
 159 0090 0362     		str	r3, [r0, #32]
 123:../drivers/fsl_adc16.c **** 
 124:../drivers/fsl_adc16.c ****     /* ADCx_SC3. */
 125:../drivers/fsl_adc16.c ****     if (config->enableContinuousConversion)
 160              		.loc 1 125 0
 161 0092 0B7A     		ldrb	r3, [r1, #8]	@ zero_extendqisi2
 162              	.LVL17:
 163 0094 33B1     		cbz	r3, .L8
 126:../drivers/fsl_adc16.c ****     {
 127:../drivers/fsl_adc16.c ****         base->SC3 |= ADC_SC3_ADCO_MASK;
 164              		.loc 1 127 0
 165 0096 436A     		ldr	r3, [r0, #36]
 166 0098 43F00803 		orr	r3, r3, #8
 167              	.L27:
 128:../drivers/fsl_adc16.c ****     }
 129:../drivers/fsl_adc16.c ****     else
 130:../drivers/fsl_adc16.c ****     {
 131:../drivers/fsl_adc16.c ****         base->SC3 &= ~ADC_SC3_ADCO_MASK;
 168              		.loc 1 131 0
 169 009c 4362     		str	r3, [r0, #36]
 170              	.LVL18:
 132:../drivers/fsl_adc16.c ****     }
 133:../drivers/fsl_adc16.c **** }
 171              		.loc 1 133 0
 172 009e 30BD     		pop	{r4, r5, pc}
 173              	.LVL19:
 174              	.L10:
 175              	.LBB15:
 176              	.LBB11:
  66:../drivers/fsl_adc16.c ****     {
 177              		.loc 1 66 0
 178 00a0 0023     		movs	r3, #0
 179 00a2 B7E7     		b	.L2
 180              	.LVL20:
 181              	.L8:
 182              	.LBE11:
 183              	.LBE15:
 131:../drivers/fsl_adc16.c ****     }
 184              		.loc 1 131 0
 185 00a4 436A     		ldr	r3, [r0, #36]
 186 00a6 23F00803 		bic	r3, r3, #8
 187 00aa F7E7     		b	.L27
 188              	.L29:
 189              		.align	2
 190              	.L28:
 191 00ac 00B00340 		.word	1073983488
 192 00b0 00000000 		.word	.LANCHOR0
 193              		.cfi_endproc
 194              	.LFE152:
 196              		.section	.text.ADC16_Deinit,"ax",%progbits
 197              		.align	1
 198              		.global	ADC16_Deinit
 199              		.syntax unified
 200              		.thumb
 201              		.thumb_func
 202              		.fpu fpv4-sp-d16
 204              	ADC16_Deinit:
 205              	.LFB153:
 134:../drivers/fsl_adc16.c **** 
 135:../drivers/fsl_adc16.c **** void ADC16_Deinit(ADC_Type *base)
 136:../drivers/fsl_adc16.c **** {
 206              		.loc 1 136 0
 207              		.cfi_startproc
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              		@ link register save eliminated.
 211              	.LVL21:
 212              	.LBB20:
 213              	.LBB21:
  68:../drivers/fsl_adc16.c ****         {
 214              		.loc 1 68 0
 215 0000 0D4B     		ldr	r3, .L34
 216 0002 9842     		cmp	r0, r3
 217 0004 16D0     		beq	.L32
 218              	.LVL22:
  66:../drivers/fsl_adc16.c ****     {
 219              		.loc 1 66 0
 220 0006 03F50023 		add	r3, r3, #524288
 221 000a 9842     		cmp	r0, r3
 222 000c 0CBF     		ite	eq
 223 000e 0120     		moveq	r0, #1
 224 0010 0220     		movne	r0, #2
 225              	.LVL23:
 226              	.L31:
 227              	.LBE21:
 228              	.LBE20:
 137:../drivers/fsl_adc16.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 138:../drivers/fsl_adc16.c ****     /* Disable the clock. */
 139:../drivers/fsl_adc16.c ****     CLOCK_DisableClock(s_adc16Clocks[ADC16_GetInstance(base)]);
 229              		.loc 1 139 0
 230 0012 0A4B     		ldr	r3, .L34+4
 231 0014 53F82020 		ldr	r2, [r3, r0, lsl #2]
 232              	.LVL24:
 233              	.LBB23:
 234              	.LBB24:
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 235              		.loc 2 705 0
 236 0018 130C     		lsrs	r3, r2, #16
 237 001a 03F18043 		add	r3, r3, #1073741824
 238 001e 03F58E23 		add	r3, r3, #290816
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 239              		.loc 2 706 0
 240 0022 92B2     		uxth	r2, r2
 241              	.LVL25:
 242 0024 1968     		ldr	r1, [r3]
 243 0026 0120     		movs	r0, #1
 244              	.LVL26:
 245 0028 00FA02F2 		lsl	r2, r0, r2
 246 002c 21EA0202 		bic	r2, r1, r2
 247 0030 1A60     		str	r2, [r3]
 248              	.LBE24:
 249              	.LBE23:
 140:../drivers/fsl_adc16.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 141:../drivers/fsl_adc16.c **** }
 250              		.loc 1 141 0
 251 0032 7047     		bx	lr
 252              	.LVL27:
 253              	.L32:
 254              	.LBB25:
 255              	.LBB22:
  66:../drivers/fsl_adc16.c ****     {
 256              		.loc 1 66 0
 257 0034 0020     		movs	r0, #0
 258              	.LVL28:
 259 0036 ECE7     		b	.L31
 260              	.L35:
 261              		.align	2
 262              	.L34:
 263 0038 00B00340 		.word	1073983488
 264 003c 00000000 		.word	.LANCHOR0
 265              	.LBE22:
 266              	.LBE25:
 267              		.cfi_endproc
 268              	.LFE153:
 270              		.section	.text.ADC16_GetDefaultConfig,"ax",%progbits
 271              		.align	1
 272              		.global	ADC16_GetDefaultConfig
 273              		.syntax unified
 274              		.thumb
 275              		.thumb_func
 276              		.fpu fpv4-sp-d16
 278              	ADC16_GetDefaultConfig:
 279              	.LFB154:
 142:../drivers/fsl_adc16.c **** 
 143:../drivers/fsl_adc16.c **** void ADC16_GetDefaultConfig(adc16_config_t *config)
 144:../drivers/fsl_adc16.c **** {
 280              		.loc 1 144 0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
 284              		@ link register save eliminated.
 285              	.LVL29:
 145:../drivers/fsl_adc16.c ****     assert(NULL != config);
 146:../drivers/fsl_adc16.c **** 
 147:../drivers/fsl_adc16.c ****     config->referenceVoltageSource = kADC16_ReferenceVoltageSourceVref;
 148:../drivers/fsl_adc16.c ****     config->clockSource = kADC16_ClockSourceAsynchronousClock;
 149:../drivers/fsl_adc16.c ****     config->enableAsynchronousClock = true;
 286              		.loc 1 149 0
 287 0000 0122     		movs	r2, #1
 147:../drivers/fsl_adc16.c ****     config->clockSource = kADC16_ClockSourceAsynchronousClock;
 288              		.loc 1 147 0
 289 0002 0023     		movs	r3, #0
 148:../drivers/fsl_adc16.c ****     config->enableAsynchronousClock = true;
 290              		.loc 1 148 0
 291 0004 0321     		movs	r1, #3
 292              		.loc 1 149 0
 293 0006 8270     		strb	r2, [r0, #2]
 150:../drivers/fsl_adc16.c ****     config->clockDivider = kADC16_ClockDivider8;
 151:../drivers/fsl_adc16.c ****     config->resolution = kADC16_ResolutionSE12Bit;
 294              		.loc 1 151 0
 295 0008 0271     		strb	r2, [r0, #4]
 152:../drivers/fsl_adc16.c ****     config->longSampleMode = kADC16_LongSampleDisabled;
 296              		.loc 1 152 0
 297 000a 0422     		movs	r2, #4
 147:../drivers/fsl_adc16.c ****     config->clockSource = kADC16_ClockSourceAsynchronousClock;
 298              		.loc 1 147 0
 299 000c 0370     		strb	r3, [r0]
 148:../drivers/fsl_adc16.c ****     config->enableAsynchronousClock = true;
 300              		.loc 1 148 0
 301 000e 4170     		strb	r1, [r0, #1]
 150:../drivers/fsl_adc16.c ****     config->resolution = kADC16_ResolutionSE12Bit;
 302              		.loc 1 150 0
 303 0010 C170     		strb	r1, [r0, #3]
 304              		.loc 1 152 0
 305 0012 4271     		strb	r2, [r0, #5]
 153:../drivers/fsl_adc16.c ****     config->enableHighSpeed = false;
 306              		.loc 1 153 0
 307 0014 8371     		strb	r3, [r0, #6]
 154:../drivers/fsl_adc16.c ****     config->enableLowPower = false;
 308              		.loc 1 154 0
 309 0016 C371     		strb	r3, [r0, #7]
 155:../drivers/fsl_adc16.c ****     config->enableContinuousConversion = false;
 310              		.loc 1 155 0
 311 0018 0372     		strb	r3, [r0, #8]
 156:../drivers/fsl_adc16.c **** }
 312              		.loc 1 156 0
 313 001a 7047     		bx	lr
 314              		.cfi_endproc
 315              	.LFE154:
 317              		.section	.text.ADC16_SetChannelMuxMode,"ax",%progbits
 318              		.align	1
 319              		.global	ADC16_SetChannelMuxMode
 320              		.syntax unified
 321              		.thumb
 322              		.thumb_func
 323              		.fpu fpv4-sp-d16
 325              	ADC16_SetChannelMuxMode:
 326              	.LFB156:
 157:../drivers/fsl_adc16.c **** 
 158:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 159:../drivers/fsl_adc16.c **** status_t ADC16_DoAutoCalibration(ADC_Type *base)
 160:../drivers/fsl_adc16.c **** {
 161:../drivers/fsl_adc16.c ****     bool bHWTrigger = false;
 162:../drivers/fsl_adc16.c ****     volatile uint32_t tmp32; /* 'volatile' here is for the dummy read of ADCx_R[0] register. */
 163:../drivers/fsl_adc16.c ****     status_t status = kStatus_Success;
 164:../drivers/fsl_adc16.c **** 
 165:../drivers/fsl_adc16.c ****     /* The calibration would be failed when in hardwar mode.
 166:../drivers/fsl_adc16.c ****      * Remember the hardware trigger state here and restore it later if the hardware trigger is ena
 167:../drivers/fsl_adc16.c ****     if (0U != (ADC_SC2_ADTRG_MASK & base->SC2))
 168:../drivers/fsl_adc16.c ****     {
 169:../drivers/fsl_adc16.c ****         bHWTrigger = true;
 170:../drivers/fsl_adc16.c ****         base->SC2 &= ~ADC_SC2_ADTRG_MASK;
 171:../drivers/fsl_adc16.c ****     }
 172:../drivers/fsl_adc16.c **** 
 173:../drivers/fsl_adc16.c ****     /* Clear the CALF and launch the calibration. */
 174:../drivers/fsl_adc16.c ****     base->SC3 |= ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK;
 175:../drivers/fsl_adc16.c ****     while (0U == (kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
 176:../drivers/fsl_adc16.c ****     {
 177:../drivers/fsl_adc16.c ****         /* Check the CALF when the calibration is active. */
 178:../drivers/fsl_adc16.c ****         if (0U != (kADC16_CalibrationFailedFlag & ADC16_GetStatusFlags(base)))
 179:../drivers/fsl_adc16.c ****         {
 180:../drivers/fsl_adc16.c ****             status = kStatus_Fail;
 181:../drivers/fsl_adc16.c ****             break;
 182:../drivers/fsl_adc16.c ****         }
 183:../drivers/fsl_adc16.c ****     }
 184:../drivers/fsl_adc16.c ****     tmp32 = base->R[0]; /* Dummy read to clear COCO caused by calibration. */
 185:../drivers/fsl_adc16.c **** 
 186:../drivers/fsl_adc16.c ****     /* Restore the hardware trigger setting if it was enabled before. */
 187:../drivers/fsl_adc16.c ****     if (bHWTrigger)
 188:../drivers/fsl_adc16.c ****     {
 189:../drivers/fsl_adc16.c ****         base->SC2 |= ADC_SC2_ADTRG_MASK;
 190:../drivers/fsl_adc16.c ****     }
 191:../drivers/fsl_adc16.c ****     /* Check the CALF at the end of calibration. */
 192:../drivers/fsl_adc16.c ****     if (0U != (kADC16_CalibrationFailedFlag & ADC16_GetStatusFlags(base)))
 193:../drivers/fsl_adc16.c ****     {
 194:../drivers/fsl_adc16.c ****         status = kStatus_Fail;
 195:../drivers/fsl_adc16.c ****     }
 196:../drivers/fsl_adc16.c ****     if (kStatus_Success != status) /* Check if the calibration process is succeed. */
 197:../drivers/fsl_adc16.c ****     {
 198:../drivers/fsl_adc16.c ****         return status;
 199:../drivers/fsl_adc16.c ****     }
 200:../drivers/fsl_adc16.c **** 
 201:../drivers/fsl_adc16.c ****     /* Calculate the calibration values. */
 202:../drivers/fsl_adc16.c ****     tmp32 = base->CLP0 + base->CLP1 + base->CLP2 + base->CLP3 + base->CLP4 + base->CLPS;
 203:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 204:../drivers/fsl_adc16.c ****     base->PG = tmp32;
 205:../drivers/fsl_adc16.c **** 
 206:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
 207:../drivers/fsl_adc16.c ****     tmp32 = base->CLM0 + base->CLM1 + base->CLM2 + base->CLM3 + base->CLM4 + base->CLMS;
 208:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 209:../drivers/fsl_adc16.c ****     base->MG = tmp32;
 210:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
 211:../drivers/fsl_adc16.c **** 
 212:../drivers/fsl_adc16.c ****     return kStatus_Success;
 213:../drivers/fsl_adc16.c **** }
 214:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 215:../drivers/fsl_adc16.c **** 
 216:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_MUX_SELECT) && FSL_FEATURE_ADC16_HAS_MUX_SELECT
 217:../drivers/fsl_adc16.c **** void ADC16_SetChannelMuxMode(ADC_Type *base, adc16_channel_mux_mode_t mode)
 218:../drivers/fsl_adc16.c **** {
 327              		.loc 1 218 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 0
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              		@ link register save eliminated.
 332              	.LVL30:
 219:../drivers/fsl_adc16.c ****     if (kADC16_ChannelMuxA == mode)
 220:../drivers/fsl_adc16.c ****     {
 221:../drivers/fsl_adc16.c ****         base->CFG2 &= ~ADC_CFG2_MUXSEL_MASK;
 333              		.loc 1 221 0
 334 0000 C368     		ldr	r3, [r0, #12]
 219:../drivers/fsl_adc16.c ****     if (kADC16_ChannelMuxA == mode)
 335              		.loc 1 219 0
 336 0002 19B9     		cbnz	r1, .L38
 337              		.loc 1 221 0
 338 0004 23F01003 		bic	r3, r3, #16
 339              	.L40:
 222:../drivers/fsl_adc16.c ****     }
 223:../drivers/fsl_adc16.c ****     else /* kADC16_ChannelMuxB. */
 224:../drivers/fsl_adc16.c ****     {
 225:../drivers/fsl_adc16.c ****         base->CFG2 |= ADC_CFG2_MUXSEL_MASK;
 340              		.loc 1 225 0
 341 0008 C360     		str	r3, [r0, #12]
 226:../drivers/fsl_adc16.c ****     }
 227:../drivers/fsl_adc16.c **** }
 342              		.loc 1 227 0
 343 000a 7047     		bx	lr
 344              	.L38:
 225:../drivers/fsl_adc16.c ****     }
 345              		.loc 1 225 0
 346 000c 43F01003 		orr	r3, r3, #16
 347 0010 FAE7     		b	.L40
 348              		.cfi_endproc
 349              	.LFE156:
 351              		.section	.text.ADC16_SetHardwareCompareConfig,"ax",%progbits
 352              		.align	1
 353              		.global	ADC16_SetHardwareCompareConfig
 354              		.syntax unified
 355              		.thumb
 356              		.thumb_func
 357              		.fpu fpv4-sp-d16
 359              	ADC16_SetHardwareCompareConfig:
 360              	.LFB157:
 228:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_MUX_SELECT */
 229:../drivers/fsl_adc16.c **** 
 230:../drivers/fsl_adc16.c **** void ADC16_SetHardwareCompareConfig(ADC_Type *base, const adc16_hardware_compare_config_t *config)
 231:../drivers/fsl_adc16.c **** {
 361              		.loc 1 231 0
 362              		.cfi_startproc
 363              		@ args = 0, pretend = 0, frame = 0
 364              		@ frame_needed = 0, uses_anonymous_args = 0
 365              		@ link register save eliminated.
 366              	.LVL31:
 232:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC2 & ~(ADC_SC2_ACFE_MASK | ADC_SC2_ACFGT_MASK | ADC_SC2_ACREN_MASK);
 367              		.loc 1 232 0
 368 0000 036A     		ldr	r3, [r0, #32]
 369 0002 23F03803 		bic	r3, r3, #56
 370              	.LVL32:
 233:../drivers/fsl_adc16.c **** 
 234:../drivers/fsl_adc16.c ****     if (!config) /* Pass "NULL" to disable the feature. */
 371              		.loc 1 234 0
 372 0006 09B9     		cbnz	r1, .L42
 235:../drivers/fsl_adc16.c ****     {
 236:../drivers/fsl_adc16.c ****         base->SC2 = tmp32;
 373              		.loc 1 236 0
 374 0008 0362     		str	r3, [r0, #32]
 237:../drivers/fsl_adc16.c ****         return;
 375              		.loc 1 237 0
 376 000a 7047     		bx	lr
 377              	.L42:
 378              	.LVL33:
 238:../drivers/fsl_adc16.c ****     }
 239:../drivers/fsl_adc16.c ****     /* Enable the feature. */
 240:../drivers/fsl_adc16.c ****     tmp32 |= ADC_SC2_ACFE_MASK;
 241:../drivers/fsl_adc16.c **** 
 242:../drivers/fsl_adc16.c ****     /* Select the hardware compare working mode. */
 243:../drivers/fsl_adc16.c ****     switch (config->hardwareCompareMode)
 379              		.loc 1 243 0
 380 000c 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 381 000e 022A     		cmp	r2, #2
 382 0010 0DD0     		beq	.L45
 383 0012 032A     		cmp	r2, #3
 384 0014 0ED0     		beq	.L46
 385 0016 012A     		cmp	r2, #1
 240:../drivers/fsl_adc16.c **** 
 386              		.loc 1 240 0
 387 0018 14BF     		ite	ne
 388 001a 43F02003 		orrne	r3, r3, #32
 389              	.LVL34:
 244:../drivers/fsl_adc16.c ****     {
 245:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode0:
 246:../drivers/fsl_adc16.c ****             break;
 247:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode1:
 248:../drivers/fsl_adc16.c ****             tmp32 |= ADC_SC2_ACFGT_MASK;
 390              		.loc 1 248 0
 391 001e 43F03003 		orreq	r3, r3, #48
 392              	.LVL35:
 393              	.L48:
 249:../drivers/fsl_adc16.c ****             break;
 250:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode2:
 251:../drivers/fsl_adc16.c ****             tmp32 |= ADC_SC2_ACREN_MASK;
 252:../drivers/fsl_adc16.c ****             break;
 253:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode3:
 254:../drivers/fsl_adc16.c ****             tmp32 |= ADC_SC2_ACFGT_MASK | ADC_SC2_ACREN_MASK;
 255:../drivers/fsl_adc16.c ****             break;
 256:../drivers/fsl_adc16.c ****         default:
 257:../drivers/fsl_adc16.c ****             break;
 258:../drivers/fsl_adc16.c ****     }
 259:../drivers/fsl_adc16.c ****     base->SC2 = tmp32;
 394              		.loc 1 259 0
 395 0022 0362     		str	r3, [r0, #32]
 260:../drivers/fsl_adc16.c **** 
 261:../drivers/fsl_adc16.c ****     /* Load the compare values. */
 262:../drivers/fsl_adc16.c ****     base->CV1 = ADC_CV1_CV(config->value1);
 396              		.loc 1 262 0
 397 0024 4B88     		ldrh	r3, [r1, #2]
 398              	.LVL36:
 399 0026 8361     		str	r3, [r0, #24]
 400              	.LVL37:
 263:../drivers/fsl_adc16.c ****     base->CV2 = ADC_CV2_CV(config->value2);
 401              		.loc 1 263 0
 402 0028 8B88     		ldrh	r3, [r1, #4]
 403 002a C361     		str	r3, [r0, #28]
 264:../drivers/fsl_adc16.c **** }
 404              		.loc 1 264 0
 405 002c 7047     		bx	lr
 406              	.LVL38:
 407              	.L45:
 251:../drivers/fsl_adc16.c ****             break;
 408              		.loc 1 251 0
 409 002e 43F02803 		orr	r3, r3, #40
 410              	.LVL39:
 252:../drivers/fsl_adc16.c ****         case kADC16_HardwareCompareMode3:
 411              		.loc 1 252 0
 412 0032 F6E7     		b	.L48
 413              	.LVL40:
 414              	.L46:
 254:../drivers/fsl_adc16.c ****             break;
 415              		.loc 1 254 0
 416 0034 43F03803 		orr	r3, r3, #56
 417              	.LVL41:
 255:../drivers/fsl_adc16.c ****         default:
 418              		.loc 1 255 0
 419 0038 F3E7     		b	.L48
 420              		.cfi_endproc
 421              	.LFE157:
 423              		.section	.text.ADC16_SetHardwareAverage,"ax",%progbits
 424              		.align	1
 425              		.global	ADC16_SetHardwareAverage
 426              		.syntax unified
 427              		.thumb
 428              		.thumb_func
 429              		.fpu fpv4-sp-d16
 431              	ADC16_SetHardwareAverage:
 432              	.LFB158:
 265:../drivers/fsl_adc16.c **** 
 266:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_HW_AVERAGE) && FSL_FEATURE_ADC16_HAS_HW_AVERAGE
 267:../drivers/fsl_adc16.c **** void ADC16_SetHardwareAverage(ADC_Type *base, adc16_hardware_average_mode_t mode)
 268:../drivers/fsl_adc16.c **** {
 433              		.loc 1 268 0
 434              		.cfi_startproc
 435              		@ args = 0, pretend = 0, frame = 0
 436              		@ frame_needed = 0, uses_anonymous_args = 0
 437              		@ link register save eliminated.
 438              	.LVL42:
 269:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
 270:../drivers/fsl_adc16.c **** 
 271:../drivers/fsl_adc16.c ****     if (kADC16_HardwareAverageDisabled != mode)
 439              		.loc 1 271 0
 440 0000 0429     		cmp	r1, #4
 269:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
 441              		.loc 1 269 0
 442 0002 436A     		ldr	r3, [r0, #36]
 272:../drivers/fsl_adc16.c ****     {
 273:../drivers/fsl_adc16.c ****         tmp32 |= ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(mode);
 443              		.loc 1 273 0
 444 0004 18BF     		it	ne
 445 0006 01F00301 		andne	r1, r1, #3
 446              	.LVL43:
 269:../drivers/fsl_adc16.c ****     uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
 447              		.loc 1 269 0
 448 000a 23F00703 		bic	r3, r3, #7
 449              	.LVL44:
 450              		.loc 1 273 0
 451 000e 1CBF     		itt	ne
 452 0010 41F00401 		orrne	r1, r1, #4
 453 0014 0B43     		orrne	r3, r3, r1
 454              	.LVL45:
 274:../drivers/fsl_adc16.c ****     }
 275:../drivers/fsl_adc16.c ****     base->SC3 = tmp32;
 455              		.loc 1 275 0
 456 0016 4362     		str	r3, [r0, #36]
 276:../drivers/fsl_adc16.c **** }
 457              		.loc 1 276 0
 458 0018 7047     		bx	lr
 459              		.cfi_endproc
 460              	.LFE158:
 462              		.section	.text.ADC16_GetStatusFlags,"ax",%progbits
 463              		.align	1
 464              		.global	ADC16_GetStatusFlags
 465              		.syntax unified
 466              		.thumb
 467              		.thumb_func
 468              		.fpu fpv4-sp-d16
 470              	ADC16_GetStatusFlags:
 471              	.LFB159:
 277:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_HW_AVERAGE */
 278:../drivers/fsl_adc16.c **** 
 279:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_PGA) && FSL_FEATURE_ADC16_HAS_PGA
 280:../drivers/fsl_adc16.c **** void ADC16_SetPGAConfig(ADC_Type *base, const adc16_pga_config_t *config)
 281:../drivers/fsl_adc16.c **** {
 282:../drivers/fsl_adc16.c ****     uint32_t tmp32;
 283:../drivers/fsl_adc16.c **** 
 284:../drivers/fsl_adc16.c ****     if (!config) /* Passing "NULL" is to disable the feature. */
 285:../drivers/fsl_adc16.c ****     {
 286:../drivers/fsl_adc16.c ****         base->PGA = 0U;
 287:../drivers/fsl_adc16.c ****         return;
 288:../drivers/fsl_adc16.c ****     }
 289:../drivers/fsl_adc16.c **** 
 290:../drivers/fsl_adc16.c ****     /* Enable the PGA and set the gain value. */
 291:../drivers/fsl_adc16.c ****     tmp32 = ADC_PGA_PGAEN_MASK | ADC_PGA_PGAG(config->pgaGain);
 292:../drivers/fsl_adc16.c **** 
 293:../drivers/fsl_adc16.c ****     /* Configure the misc features for PGA. */
 294:../drivers/fsl_adc16.c ****     if (config->enableRunInNormalMode)
 295:../drivers/fsl_adc16.c ****     {
 296:../drivers/fsl_adc16.c ****         tmp32 |= ADC_PGA_PGALPb_MASK;
 297:../drivers/fsl_adc16.c ****     }
 298:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_PGA_CHOPPING) && FSL_FEATURE_ADC16_HAS_PGA_CHOPPING
 299:../drivers/fsl_adc16.c ****     if (config->disablePgaChopping)
 300:../drivers/fsl_adc16.c ****     {
 301:../drivers/fsl_adc16.c ****         tmp32 |= ADC_PGA_PGACHPb_MASK;
 302:../drivers/fsl_adc16.c ****     }
 303:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_PGA_CHOPPING */
 304:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASUREMENT) && FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASU
 305:../drivers/fsl_adc16.c ****     if (config->enableRunInOffsetMeasurement)
 306:../drivers/fsl_adc16.c ****     {
 307:../drivers/fsl_adc16.c ****         tmp32 |= ADC_PGA_PGAOFSM_MASK;
 308:../drivers/fsl_adc16.c ****     }
 309:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASUREMENT */
 310:../drivers/fsl_adc16.c ****     base->PGA = tmp32;
 311:../drivers/fsl_adc16.c **** }
 312:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_PGA */
 313:../drivers/fsl_adc16.c **** 
 314:../drivers/fsl_adc16.c **** uint32_t ADC16_GetStatusFlags(ADC_Type *base)
 315:../drivers/fsl_adc16.c **** {
 472              		.loc 1 315 0
 473              		.cfi_startproc
 474              		@ args = 0, pretend = 0, frame = 0
 475              		@ frame_needed = 0, uses_anonymous_args = 0
 476              		@ link register save eliminated.
 477              	.LVL46:
 316:../drivers/fsl_adc16.c ****     uint32_t ret = 0;
 317:../drivers/fsl_adc16.c **** 
 318:../drivers/fsl_adc16.c ****     if (0U != (base->SC2 & ADC_SC2_ADACT_MASK))
 478              		.loc 1 318 0
 479 0000 036A     		ldr	r3, [r0, #32]
 319:../drivers/fsl_adc16.c ****     {
 320:../drivers/fsl_adc16.c ****         ret |= kADC16_ActiveFlag;
 321:../drivers/fsl_adc16.c ****     }
 322:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 323:../drivers/fsl_adc16.c ****     if (0U != (base->SC3 & ADC_SC3_CALF_MASK))
 480              		.loc 1 323 0
 481 0002 426A     		ldr	r2, [r0, #36]
 320:../drivers/fsl_adc16.c ****     }
 482              		.loc 1 320 0
 483 0004 03F08003 		and	r3, r3, #128
 484              	.LVL47:
 485              		.loc 1 323 0
 486 0008 5206     		lsls	r2, r2, #25
 324:../drivers/fsl_adc16.c ****     {
 325:../drivers/fsl_adc16.c ****         ret |= kADC16_CalibrationFailedFlag;
 487              		.loc 1 325 0
 488 000a 48BF     		it	mi
 489 000c 43F04003 		orrmi	r3, r3, #64
 490              	.LVL48:
 326:../drivers/fsl_adc16.c ****     }
 327:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 328:../drivers/fsl_adc16.c ****     return ret;
 329:../drivers/fsl_adc16.c **** }
 491              		.loc 1 329 0
 492 0010 1846     		mov	r0, r3
 493              	.LVL49:
 494 0012 7047     		bx	lr
 495              		.cfi_endproc
 496              	.LFE159:
 498              		.section	.text.ADC16_DoAutoCalibration,"ax",%progbits
 499              		.align	1
 500              		.global	ADC16_DoAutoCalibration
 501              		.syntax unified
 502              		.thumb
 503              		.thumb_func
 504              		.fpu fpv4-sp-d16
 506              	ADC16_DoAutoCalibration:
 507              	.LFB155:
 160:../drivers/fsl_adc16.c ****     bool bHWTrigger = false;
 508              		.loc 1 160 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 8
 511              		@ frame_needed = 0, uses_anonymous_args = 0
 512              	.LVL50:
 513 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 514              		.cfi_def_cfa_offset 32
 515              		.cfi_offset 4, -20
 516              		.cfi_offset 5, -16
 517              		.cfi_offset 6, -12
 518              		.cfi_offset 7, -8
 519              		.cfi_offset 14, -4
 167:../drivers/fsl_adc16.c ****     {
 520              		.loc 1 167 0
 521 0002 056A     		ldr	r5, [r0, #32]
 522 0004 15F04005 		ands	r5, r5, #64
 523              	.LVL51:
 170:../drivers/fsl_adc16.c ****     }
 524              		.loc 1 170 0
 525 0008 1EBF     		ittt	ne
 526 000a 036A     		ldrne	r3, [r0, #32]
 527 000c 23F04003 		bicne	r3, r3, #64
 528 0010 0362     		strne	r3, [r0, #32]
 174:../drivers/fsl_adc16.c ****     while (0U == (kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
 529              		.loc 1 174 0
 530 0012 436A     		ldr	r3, [r0, #36]
 531 0014 43F0C003 		orr	r3, r3, #192
 160:../drivers/fsl_adc16.c ****     bool bHWTrigger = false;
 532              		.loc 1 160 0
 533 0018 0146     		mov	r1, r0
 169:../drivers/fsl_adc16.c ****         base->SC2 &= ~ADC_SC2_ADTRG_MASK;
 534              		.loc 1 169 0
 535 001a 18BF     		it	ne
 536 001c 0125     		movne	r5, #1
 537              	.LVL52:
 174:../drivers/fsl_adc16.c ****     while (0U == (kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
 538              		.loc 1 174 0
 539 001e 4362     		str	r3, [r0, #36]
 540              	.LVL53:
 541              	.L64:
 542              	.LBB26:
 543              	.LBB27:
 330:../drivers/fsl_adc16.c **** 
 331:../drivers/fsl_adc16.c **** void ADC16_ClearStatusFlags(ADC_Type *base, uint32_t mask)
 332:../drivers/fsl_adc16.c **** {
 333:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 334:../drivers/fsl_adc16.c ****     if (0U != (mask & kADC16_CalibrationFailedFlag))
 335:../drivers/fsl_adc16.c ****     {
 336:../drivers/fsl_adc16.c ****         base->SC3 |= ADC_SC3_CALF_MASK;
 337:../drivers/fsl_adc16.c ****     }
 338:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 339:../drivers/fsl_adc16.c **** }
 340:../drivers/fsl_adc16.c **** 
 341:../drivers/fsl_adc16.c **** void ADC16_SetChannelConfig(ADC_Type *base, uint32_t channelGroup, const adc16_channel_config_t *co
 342:../drivers/fsl_adc16.c **** {
 343:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 344:../drivers/fsl_adc16.c ****     assert(NULL != config);
 345:../drivers/fsl_adc16.c **** 
 346:../drivers/fsl_adc16.c ****     uint32_t sc1 = ADC_SC1_ADCH(config->channelNumber); /* Set the channel number. */
 347:../drivers/fsl_adc16.c **** 
 348:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
 349:../drivers/fsl_adc16.c ****     /* Enable the differential conversion. */
 350:../drivers/fsl_adc16.c ****     if (config->enableDifferentialConversion)
 351:../drivers/fsl_adc16.c ****     {
 352:../drivers/fsl_adc16.c ****         sc1 |= ADC_SC1_DIFF_MASK;
 353:../drivers/fsl_adc16.c ****     }
 354:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
 355:../drivers/fsl_adc16.c ****     /* Enable the interrupt when the conversion is done. */
 356:../drivers/fsl_adc16.c ****     if (config->enableInterruptOnConversionCompleted)
 357:../drivers/fsl_adc16.c ****     {
 358:../drivers/fsl_adc16.c ****         sc1 |= ADC_SC1_AIEN_MASK;
 359:../drivers/fsl_adc16.c ****     }
 360:../drivers/fsl_adc16.c ****     base->SC1[channelGroup] = sc1;
 361:../drivers/fsl_adc16.c **** }
 362:../drivers/fsl_adc16.c **** 
 363:../drivers/fsl_adc16.c **** uint32_t ADC16_GetChannelStatusFlags(ADC_Type *base, uint32_t channelGroup)
 364:../drivers/fsl_adc16.c **** {
 365:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 366:../drivers/fsl_adc16.c **** 
 367:../drivers/fsl_adc16.c ****     uint32_t ret = 0U;
 368:../drivers/fsl_adc16.c **** 
 369:../drivers/fsl_adc16.c ****     if (0U != (base->SC1[channelGroup] & ADC_SC1_COCO_MASK))
 544              		.loc 1 369 0
 545 0020 0B68     		ldr	r3, [r1]
 546 0022 1806     		lsls	r0, r3, #24
 547 0024 3BD4     		bmi	.L68
 548              	.LVL54:
 549              	.LBE27:
 550              	.LBE26:
 178:../drivers/fsl_adc16.c ****         {
 551              		.loc 1 178 0
 552 0026 0846     		mov	r0, r1
 553 0028 FFF7FEFF 		bl	ADC16_GetStatusFlags
 554              	.LVL55:
 555 002c 4206     		lsls	r2, r0, #25
 556 002e F7D5     		bpl	.L64
 180:../drivers/fsl_adc16.c ****             break;
 557              		.loc 1 180 0
 558 0030 0124     		movs	r4, #1
 559              	.L63:
 560              	.LVL56:
 184:../drivers/fsl_adc16.c **** 
 561              		.loc 1 184 0
 562 0032 0B69     		ldr	r3, [r1, #16]
 563 0034 0193     		str	r3, [sp, #4]
 187:../drivers/fsl_adc16.c ****     {
 564              		.loc 1 187 0
 565 0036 1DB1     		cbz	r5, .L65
 189:../drivers/fsl_adc16.c ****     }
 566              		.loc 1 189 0
 567 0038 0B6A     		ldr	r3, [r1, #32]
 568 003a 43F04003 		orr	r3, r3, #64
 569 003e 0B62     		str	r3, [r1, #32]
 570              	.L65:
 192:../drivers/fsl_adc16.c ****     {
 571              		.loc 1 192 0
 572 0040 0846     		mov	r0, r1
 573 0042 FFF7FEFF 		bl	ADC16_GetStatusFlags
 574              	.LVL57:
 575 0046 4306     		lsls	r3, r0, #25
 576 0048 2BD4     		bmi	.L69
 196:../drivers/fsl_adc16.c ****     {
 577              		.loc 1 196 0
 578 004a 2CBB     		cbnz	r4, .L61
 202:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 579              		.loc 1 202 0
 580 004c CB6C     		ldr	r3, [r1, #76]
 581 004e 8F6C     		ldr	r7, [r1, #72]
 582 0050 4E6C     		ldr	r6, [r1, #68]
 583 0052 0D6C     		ldr	r5, [r1, #64]
 584              	.LVL58:
 585 0054 C86B     		ldr	r0, [r1, #60]
 586 0056 8A6B     		ldr	r2, [r1, #56]
 587 0058 3B44     		add	r3, r3, r7
 588 005a 3344     		add	r3, r3, r6
 589 005c 2B44     		add	r3, r3, r5
 590 005e 0344     		add	r3, r3, r0
 591 0060 1344     		add	r3, r3, r2
 592 0062 0193     		str	r3, [sp, #4]
 203:../drivers/fsl_adc16.c ****     base->PG = tmp32;
 593              		.loc 1 203 0
 594 0064 019B     		ldr	r3, [sp, #4]
 595 0066 5B08     		lsrs	r3, r3, #1
 596 0068 43F40043 		orr	r3, r3, #32768
 597 006c 0193     		str	r3, [sp, #4]
 204:../drivers/fsl_adc16.c **** 
 598              		.loc 1 204 0
 599 006e 019B     		ldr	r3, [sp, #4]
 600 0070 CB62     		str	r3, [r1, #44]
 207:../drivers/fsl_adc16.c ****     tmp32 = 0x8000U | (tmp32 >> 1U);
 601              		.loc 1 207 0
 602 0072 CB6E     		ldr	r3, [r1, #108]
 603 0074 8F6E     		ldr	r7, [r1, #104]
 604 0076 4E6E     		ldr	r6, [r1, #100]
 605 0078 0D6E     		ldr	r5, [r1, #96]
 606 007a C86D     		ldr	r0, [r1, #92]
 607 007c 8A6D     		ldr	r2, [r1, #88]
 608 007e 3B44     		add	r3, r3, r7
 609 0080 3344     		add	r3, r3, r6
 610 0082 2B44     		add	r3, r3, r5
 611 0084 0344     		add	r3, r3, r0
 612 0086 1344     		add	r3, r3, r2
 613 0088 0193     		str	r3, [sp, #4]
 208:../drivers/fsl_adc16.c ****     base->MG = tmp32;
 614              		.loc 1 208 0
 615 008a 019B     		ldr	r3, [sp, #4]
 616 008c 5B08     		lsrs	r3, r3, #1
 617 008e 43F40043 		orr	r3, r3, #32768
 618 0092 0193     		str	r3, [sp, #4]
 209:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
 619              		.loc 1 209 0
 620 0094 019B     		ldr	r3, [sp, #4]
 621 0096 0B63     		str	r3, [r1, #48]
 622              	.LVL59:
 623              	.L61:
 213:../drivers/fsl_adc16.c **** #endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
 624              		.loc 1 213 0
 625 0098 2046     		mov	r0, r4
 626 009a 03B0     		add	sp, sp, #12
 627              		.cfi_remember_state
 628              		.cfi_def_cfa_offset 20
 629              		@ sp needed
 630 009c F0BD     		pop	{r4, r5, r6, r7, pc}
 631              	.LVL60:
 632              	.L68:
 633              		.cfi_restore_state
 163:../drivers/fsl_adc16.c **** 
 634              		.loc 1 163 0
 635 009e 0024     		movs	r4, #0
 636 00a0 C7E7     		b	.L63
 637              	.LVL61:
 638              	.L69:
 194:../drivers/fsl_adc16.c ****     }
 639              		.loc 1 194 0
 640 00a2 0124     		movs	r4, #1
 641              	.LVL62:
 642 00a4 F8E7     		b	.L61
 643              		.cfi_endproc
 644              	.LFE155:
 646              		.section	.text.ADC16_ClearStatusFlags,"ax",%progbits
 647              		.align	1
 648              		.global	ADC16_ClearStatusFlags
 649              		.syntax unified
 650              		.thumb
 651              		.thumb_func
 652              		.fpu fpv4-sp-d16
 654              	ADC16_ClearStatusFlags:
 655              	.LFB160:
 332:../drivers/fsl_adc16.c **** #if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
 656              		.loc 1 332 0
 657              		.cfi_startproc
 658              		@ args = 0, pretend = 0, frame = 0
 659              		@ frame_needed = 0, uses_anonymous_args = 0
 660              		@ link register save eliminated.
 661              	.LVL63:
 334:../drivers/fsl_adc16.c ****     {
 662              		.loc 1 334 0
 663 0000 4B06     		lsls	r3, r1, #25
 336:../drivers/fsl_adc16.c ****     }
 664              		.loc 1 336 0
 665 0002 42BF     		ittt	mi
 666 0004 436A     		ldrmi	r3, [r0, #36]
 667 0006 43F04003 		orrmi	r3, r3, #64
 668 000a 4362     		strmi	r3, [r0, #36]
 339:../drivers/fsl_adc16.c **** 
 669              		.loc 1 339 0
 670 000c 7047     		bx	lr
 671              		.cfi_endproc
 672              	.LFE160:
 674              		.section	.text.ADC16_SetChannelConfig,"ax",%progbits
 675              		.align	1
 676              		.global	ADC16_SetChannelConfig
 677              		.syntax unified
 678              		.thumb
 679              		.thumb_func
 680              		.fpu fpv4-sp-d16
 682              	ADC16_SetChannelConfig:
 683              	.LFB161:
 342:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 684              		.loc 1 342 0
 685              		.cfi_startproc
 686              		@ args = 0, pretend = 0, frame = 0
 687              		@ frame_needed = 0, uses_anonymous_args = 0
 688              	.LVL64:
 689 0000 10B5     		push	{r4, lr}
 690              		.cfi_def_cfa_offset 8
 691              		.cfi_offset 4, -8
 692              		.cfi_offset 14, -4
 346:../drivers/fsl_adc16.c **** 
 693              		.loc 1 346 0
 694 0002 1368     		ldr	r3, [r2]
 350:../drivers/fsl_adc16.c ****     {
 695              		.loc 1 350 0
 696 0004 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 346:../drivers/fsl_adc16.c **** 
 697              		.loc 1 346 0
 698 0006 03F01F03 		and	r3, r3, #31
 699              	.LVL65:
 350:../drivers/fsl_adc16.c ****     {
 700              		.loc 1 350 0
 701 000a 0CB1     		cbz	r4, .L81
 352:../drivers/fsl_adc16.c ****     }
 702              		.loc 1 352 0
 703 000c 43F02003 		orr	r3, r3, #32
 704              	.LVL66:
 705              	.L81:
 356:../drivers/fsl_adc16.c ****     {
 706              		.loc 1 356 0
 707 0010 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 708              	.LVL67:
 709 0012 0AB1     		cbz	r2, .L82
 358:../drivers/fsl_adc16.c ****     }
 710              		.loc 1 358 0
 711 0014 43F04003 		orr	r3, r3, #64
 712              	.LVL68:
 713              	.L82:
 360:../drivers/fsl_adc16.c **** }
 714              		.loc 1 360 0
 715 0018 40F82130 		str	r3, [r0, r1, lsl #2]
 361:../drivers/fsl_adc16.c **** 
 716              		.loc 1 361 0
 717 001c 10BD     		pop	{r4, pc}
 718              		.cfi_endproc
 719              	.LFE161:
 721              		.section	.text.ADC16_GetChannelStatusFlags,"ax",%progbits
 722              		.align	1
 723              		.global	ADC16_GetChannelStatusFlags
 724              		.syntax unified
 725              		.thumb
 726              		.thumb_func
 727              		.fpu fpv4-sp-d16
 729              	ADC16_GetChannelStatusFlags:
 730              	.LFB162:
 364:../drivers/fsl_adc16.c ****     assert(channelGroup < ADC_SC1_COUNT);
 731              		.loc 1 364 0
 732              		.cfi_startproc
 733              		@ args = 0, pretend = 0, frame = 0
 734              		@ frame_needed = 0, uses_anonymous_args = 0
 735              		@ link register save eliminated.
 736              	.LVL69:
 737              		.loc 1 369 0
 738 0000 50F82100 		ldr	r0, [r0, r1, lsl #2]
 739              	.LVL70:
 370:../drivers/fsl_adc16.c ****     {
 371:../drivers/fsl_adc16.c ****         ret |= kADC16_ChannelConversionDoneFlag;
 372:../drivers/fsl_adc16.c ****     }
 373:../drivers/fsl_adc16.c ****     return ret;
 374:../drivers/fsl_adc16.c **** }
 740              		.loc 1 374 0
 741 0004 00F08000 		and	r0, r0, #128
 742 0008 7047     		bx	lr
 743              		.cfi_endproc
 744              	.LFE162:
 746              		.section	.rodata.s_adc16Clocks,"a",%progbits
 747              		.align	2
 748              		.set	.LANCHOR0,. + 0
 751              	s_adc16Clocks:
 752 0000 1B003C10 		.word	272367643
 753 0004 1B003010 		.word	271581211
 754              		.text
 755              	.Letext0:
 756              		.file 3 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 757              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 758              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 759              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 760              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 761              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 762              		.file 9 "../CMSIS/core_cm4.h"
 763              		.file 10 "../CMSIS/system_MK64F12.h"
 764              		.file 11 "../CMSIS/MK64F12.h"
 765              		.file 12 "../drivers/fsl_common.h"
 766              		.file 13 "../drivers/fsl_adc16.h"
