   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_rtc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.RTC_CheckDatetimeFormat,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	RTC_CheckDatetimeFormat:
  25              	.LFB153:
  26              		.file 1 "../drivers/fsl_rtc.c"
   1:../drivers/fsl_rtc.c **** /*
   2:../drivers/fsl_rtc.c ****  * The Clear BSD License
   3:../drivers/fsl_rtc.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_rtc.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_rtc.c ****  * All rights reserved.
   6:../drivers/fsl_rtc.c ****  *
   7:../drivers/fsl_rtc.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_rtc.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_rtc.c ****  * that the following conditions are met:
  10:../drivers/fsl_rtc.c ****  *
  11:../drivers/fsl_rtc.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_rtc.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_rtc.c ****  *
  14:../drivers/fsl_rtc.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_rtc.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_rtc.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_rtc.c ****  *
  18:../drivers/fsl_rtc.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_rtc.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_rtc.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_rtc.c ****  *
  22:../drivers/fsl_rtc.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_rtc.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_rtc.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_rtc.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_rtc.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_rtc.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_rtc.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_rtc.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_rtc.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_rtc.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_rtc.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_rtc.c ****  */
  34:../drivers/fsl_rtc.c **** 
  35:../drivers/fsl_rtc.c **** #include "fsl_rtc.h"
  36:../drivers/fsl_rtc.c **** 
  37:../drivers/fsl_rtc.c **** /*******************************************************************************
  38:../drivers/fsl_rtc.c ****  * Definitions
  39:../drivers/fsl_rtc.c ****  ******************************************************************************/
  40:../drivers/fsl_rtc.c **** #define SECONDS_IN_A_DAY (86400U)
  41:../drivers/fsl_rtc.c **** #define SECONDS_IN_A_HOUR (3600U)
  42:../drivers/fsl_rtc.c **** #define SECONDS_IN_A_MINUTE (60U)
  43:../drivers/fsl_rtc.c **** #define DAYS_IN_A_YEAR (365U)
  44:../drivers/fsl_rtc.c **** #define YEAR_RANGE_START (1970U)
  45:../drivers/fsl_rtc.c **** #define YEAR_RANGE_END (2099U)
  46:../drivers/fsl_rtc.c **** 
  47:../drivers/fsl_rtc.c **** /*******************************************************************************
  48:../drivers/fsl_rtc.c ****  * Prototypes
  49:../drivers/fsl_rtc.c ****  ******************************************************************************/
  50:../drivers/fsl_rtc.c **** /*!
  51:../drivers/fsl_rtc.c ****  * @brief Checks whether the date and time passed in is valid
  52:../drivers/fsl_rtc.c ****  *
  53:../drivers/fsl_rtc.c ****  * @param datetime Pointer to structure where the date and time details are stored
  54:../drivers/fsl_rtc.c ****  *
  55:../drivers/fsl_rtc.c ****  * @return Returns false if the date & time details are out of range; true if in range
  56:../drivers/fsl_rtc.c ****  */
  57:../drivers/fsl_rtc.c **** static bool RTC_CheckDatetimeFormat(const rtc_datetime_t *datetime);
  58:../drivers/fsl_rtc.c **** 
  59:../drivers/fsl_rtc.c **** /*!
  60:../drivers/fsl_rtc.c ****  * @brief Converts time data from datetime to seconds
  61:../drivers/fsl_rtc.c ****  *
  62:../drivers/fsl_rtc.c ****  * @param datetime Pointer to datetime structure where the date and time details are stored
  63:../drivers/fsl_rtc.c ****  *
  64:../drivers/fsl_rtc.c ****  * @return The result of the conversion in seconds
  65:../drivers/fsl_rtc.c ****  */
  66:../drivers/fsl_rtc.c **** static uint32_t RTC_ConvertDatetimeToSeconds(const rtc_datetime_t *datetime);
  67:../drivers/fsl_rtc.c **** 
  68:../drivers/fsl_rtc.c **** /*!
  69:../drivers/fsl_rtc.c ****  * @brief Converts time data from seconds to a datetime structure
  70:../drivers/fsl_rtc.c ****  *
  71:../drivers/fsl_rtc.c ****  * @param seconds  Seconds value that needs to be converted to datetime format
  72:../drivers/fsl_rtc.c ****  * @param datetime Pointer to the datetime structure where the result of the conversion is stored
  73:../drivers/fsl_rtc.c ****  */
  74:../drivers/fsl_rtc.c **** static void RTC_ConvertSecondsToDatetime(uint32_t seconds, rtc_datetime_t *datetime);
  75:../drivers/fsl_rtc.c **** 
  76:../drivers/fsl_rtc.c **** /*******************************************************************************
  77:../drivers/fsl_rtc.c ****  * Code
  78:../drivers/fsl_rtc.c ****  ******************************************************************************/
  79:../drivers/fsl_rtc.c **** static bool RTC_CheckDatetimeFormat(const rtc_datetime_t *datetime)
  80:../drivers/fsl_rtc.c **** {
  27              		.loc 1 80 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
  33              		.cfi_def_cfa_offset 32
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
  81:../drivers/fsl_rtc.c ****     assert(datetime);
  82:../drivers/fsl_rtc.c **** 
  83:../drivers/fsl_rtc.c ****     /* Table of days in a month for a non leap year. First entry in the table is not used,
  84:../drivers/fsl_rtc.c ****      * valid months start from 1
  85:../drivers/fsl_rtc.c ****      */
  86:../drivers/fsl_rtc.c ****     uint8_t daysPerMonth[] = {0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U};
  38              		.loc 1 86 0
  39 0002 224B     		ldr	r3, .L10
  80:../drivers/fsl_rtc.c ****     assert(datetime);
  40              		.loc 1 80 0
  41 0004 0246     		mov	r2, r0
  42              		.loc 1 86 0
  43 0006 6C46     		mov	r4, sp
  44 0008 03F10806 		add	r6, r3, #8
  45              	.LVL1:
  46              	.L2:
  47 000c 1868     		ldr	r0, [r3]	@ unaligned
  48 000e 5968     		ldr	r1, [r3, #4]	@ unaligned
  49 0010 2546     		mov	r5, r4
  50 0012 03C5     		stmia	r5!, {r0, r1}
  51 0014 0833     		adds	r3, r3, #8
  52 0016 B342     		cmp	r3, r6
  53 0018 2C46     		mov	r4, r5
  54 001a F7D1     		bne	.L2
  55 001c 1868     		ldr	r0, [r3]	@ unaligned
  56 001e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
  57 0020 2860     		str	r0, [r5]
  58 0022 2B71     		strb	r3, [r5, #4]
  87:../drivers/fsl_rtc.c **** 
  88:../drivers/fsl_rtc.c ****     /* Check year, month, hour, minute, seconds */
  89:../drivers/fsl_rtc.c ****     if ((datetime->year < YEAR_RANGE_START) || (datetime->year > YEAR_RANGE_END) || (datetime->mont
  59              		.loc 1 89 0
  60 0024 1388     		ldrh	r3, [r2]
  61 0026 A3F2B271 		subw	r1, r3, #1970
  62 002a 8129     		cmp	r1, #129
  63 002c 02D9     		bls	.L3
  64              	.L5:
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  91:../drivers/fsl_rtc.c ****     {
  92:../drivers/fsl_rtc.c ****         /* If not correct then error*/
  93:../drivers/fsl_rtc.c ****         return false;
  65              		.loc 1 93 0
  66 002e 0020     		movs	r0, #0
  67              	.L4:
  94:../drivers/fsl_rtc.c ****     }
  95:../drivers/fsl_rtc.c **** 
  96:../drivers/fsl_rtc.c ****     /* Adjust the days in February for a leap year */
  97:../drivers/fsl_rtc.c ****     if ((((datetime->year & 3U) == 0) && (datetime->year % 100 != 0)) || (datetime->year % 400 == 0
  98:../drivers/fsl_rtc.c ****     {
  99:../drivers/fsl_rtc.c ****         daysPerMonth[2] = 29U;
 100:../drivers/fsl_rtc.c ****     }
 101:../drivers/fsl_rtc.c **** 
 102:../drivers/fsl_rtc.c ****     /* Check the validity of the day */
 103:../drivers/fsl_rtc.c ****     if ((datetime->day > daysPerMonth[datetime->month]) || (datetime->day < 1U))
 104:../drivers/fsl_rtc.c ****     {
 105:../drivers/fsl_rtc.c ****         return false;
 106:../drivers/fsl_rtc.c ****     }
 107:../drivers/fsl_rtc.c **** 
 108:../drivers/fsl_rtc.c ****     return true;
 109:../drivers/fsl_rtc.c **** }
  68              		.loc 1 109 0
  69 0030 04B0     		add	sp, sp, #16
  70              		.cfi_remember_state
  71              		.cfi_def_cfa_offset 16
  72              		@ sp needed
  73 0032 70BD     		pop	{r4, r5, r6, pc}
  74              	.L3:
  75              		.cfi_restore_state
  89:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  76              		.loc 1 89 0 discriminator 1
  77 0034 9478     		ldrb	r4, [r2, #2]	@ zero_extendqisi2
  78 0036 611E     		subs	r1, r4, #1
  79 0038 0B29     		cmp	r1, #11
  80 003a F8D8     		bhi	.L5
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  81              		.loc 1 90 0
  82 003c 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
  83 003e 1729     		cmp	r1, #23
  84 0040 F5D8     		bhi	.L5
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  85              		.loc 1 90 0 is_stmt 0 discriminator 1
  86 0042 5179     		ldrb	r1, [r2, #5]	@ zero_extendqisi2
  87 0044 3B29     		cmp	r1, #59
  88 0046 F2D8     		bhi	.L5
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  89              		.loc 1 90 0 discriminator 2
  90 0048 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
  91 004a 3B29     		cmp	r1, #59
  92 004c EFD8     		bhi	.L5
  97:../drivers/fsl_rtc.c ****     {
  93              		.loc 1 97 0 is_stmt 1
  94 004e 9907     		lsls	r1, r3, #30
  95 0050 06D1     		bne	.L6
  97:../drivers/fsl_rtc.c ****     {
  96              		.loc 1 97 0 is_stmt 0 discriminator 1
  97 0052 6420     		movs	r0, #100
  98 0054 B3FBF0F1 		udiv	r1, r3, r0
  99 0058 00FB1131 		mls	r1, r0, r1, r3
 100 005c 89B2     		uxth	r1, r1
 101 005e 39B9     		cbnz	r1, .L7
 102              	.L6:
  97:../drivers/fsl_rtc.c ****     {
 103              		.loc 1 97 0 discriminator 3
 104 0060 4FF4C870 		mov	r0, #400
 105 0064 B3FBF0F1 		udiv	r1, r3, r0
 106 0068 00FB1133 		mls	r3, r0, r1, r3
 107 006c 9BB2     		uxth	r3, r3
 108 006e 13B9     		cbnz	r3, .L8
 109              	.L7:
  99:../drivers/fsl_rtc.c ****     }
 110              		.loc 1 99 0 is_stmt 1
 111 0070 1D23     		movs	r3, #29
 112 0072 8DF80230 		strb	r3, [sp, #2]
 113              	.L8:
 103:../drivers/fsl_rtc.c ****     {
 114              		.loc 1 103 0
 115 0076 04AB     		add	r3, sp, #16
 116 0078 1C44     		add	r4, r4, r3
 117 007a D078     		ldrb	r0, [r2, #3]	@ zero_extendqisi2
 118 007c 14F8103C 		ldrb	r3, [r4, #-16]	@ zero_extendqisi2
 119 0080 8342     		cmp	r3, r0
 120 0082 D4D3     		bcc	.L5
 103:../drivers/fsl_rtc.c ****     {
 121              		.loc 1 103 0 is_stmt 0 discriminator 1
 122 0084 0030     		adds	r0, r0, #0
 123 0086 18BF     		it	ne
 124 0088 0120     		movne	r0, #1
 125 008a D1E7     		b	.L4
 126              	.L11:
 127              		.align	2
 128              	.L10:
 129 008c 00000000 		.word	.LANCHOR0
 130              		.cfi_endproc
 131              	.LFE153:
 133              		.section	.text.RTC_ConvertDatetimeToSeconds,"ax",%progbits
 134              		.align	1
 135              		.syntax unified
 136              		.thumb
 137              		.thumb_func
 138              		.fpu fpv4-sp-d16
 140              	RTC_ConvertDatetimeToSeconds:
 141              	.LFB154:
 110:../drivers/fsl_rtc.c **** 
 111:../drivers/fsl_rtc.c **** static uint32_t RTC_ConvertDatetimeToSeconds(const rtc_datetime_t *datetime)
 112:../drivers/fsl_rtc.c **** {
 142              		.loc 1 112 0 is_stmt 1
 143              		.cfi_startproc
 144              		@ args = 0, pretend = 0, frame = 32
 145              		@ frame_needed = 0, uses_anonymous_args = 0
 146              	.LVL2:
 147 0000 70B5     		push	{r4, r5, r6, lr}
 148              		.cfi_def_cfa_offset 16
 149              		.cfi_offset 4, -16
 150              		.cfi_offset 5, -12
 151              		.cfi_offset 6, -8
 152              		.cfi_offset 14, -4
 113:../drivers/fsl_rtc.c ****     assert(datetime);
 114:../drivers/fsl_rtc.c **** 
 115:../drivers/fsl_rtc.c ****     /* Number of days from begin of the non Leap-year*/
 116:../drivers/fsl_rtc.c ****     /* Number of days from begin of the non Leap-year*/
 117:../drivers/fsl_rtc.c ****     uint16_t monthDays[] = {0U, 0U, 31U, 59U, 90U, 120U, 151U, 181U, 212U, 243U, 273U, 304U, 334U};
 153              		.loc 1 117 0
 154 0002 1D4B     		ldr	r3, .L16
 112:../drivers/fsl_rtc.c ****     assert(datetime);
 155              		.loc 1 112 0
 156 0004 88B0     		sub	sp, sp, #32
 157              		.cfi_def_cfa_offset 48
 112:../drivers/fsl_rtc.c ****     assert(datetime);
 158              		.loc 1 112 0
 159 0006 0246     		mov	r2, r0
 160              		.loc 1 117 0
 161 0008 01AC     		add	r4, sp, #4
 162 000a 03F11806 		add	r6, r3, #24
 163              	.LVL3:
 164              	.L13:
 165 000e 1868     		ldr	r0, [r3]	@ unaligned
 166 0010 5968     		ldr	r1, [r3, #4]	@ unaligned
 167 0012 2546     		mov	r5, r4
 168 0014 03C5     		stmia	r5!, {r0, r1}
 169 0016 0833     		adds	r3, r3, #8
 170 0018 B342     		cmp	r3, r6
 171 001a 2C46     		mov	r4, r5
 172 001c F7D1     		bne	.L13
 173 001e 1B88     		ldrh	r3, [r3]	@ unaligned
 174 0020 2B80     		strh	r3, [r5]	@ unaligned
 118:../drivers/fsl_rtc.c ****     uint32_t seconds;
 119:../drivers/fsl_rtc.c **** 
 120:../drivers/fsl_rtc.c ****     /* Compute number of days from 1970 till given year*/
 121:../drivers/fsl_rtc.c ****     seconds = (datetime->year - 1970U) * DAYS_IN_A_YEAR;
 122:../drivers/fsl_rtc.c ****     /* Add leap year days */
 123:../drivers/fsl_rtc.c ****     seconds += ((datetime->year / 4) - (1970U / 4));
 124:../drivers/fsl_rtc.c ****     /* Add number of days till given month*/
 125:../drivers/fsl_rtc.c ****     seconds += monthDays[datetime->month];
 126:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 127:../drivers/fsl_rtc.c ****      * represented in the hours, minutes and seconds field*/
 128:../drivers/fsl_rtc.c ****     seconds += (datetime->day - 1);
 175              		.loc 1 128 0
 176 0022 D378     		ldrb	r3, [r2, #3]	@ zero_extendqisi2
 121:../drivers/fsl_rtc.c ****     /* Add leap year days */
 177              		.loc 1 121 0
 178 0024 1488     		ldrh	r4, [r2]
 179              	.LVL4:
 125:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 180              		.loc 1 125 0
 181 0026 9078     		ldrb	r0, [r2, #2]	@ zero_extendqisi2
 182              	.LVL5:
 183              		.loc 1 128 0
 184 0028 A3F52F21 		sub	r1, r3, #716800
 185 002c A1F6B621 		subw	r1, r1, #2742
 186 0030 40F26D13 		movw	r3, #365
 187 0034 03FB0413 		mla	r3, r3, r4, r1
 125:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 188              		.loc 1 125 0
 189 0038 08A9     		add	r1, sp, #32
 190 003a 01EB4001 		add	r1, r1, r0, lsl #1
 191              		.loc 1 128 0
 192 003e 03EB9403 		add	r3, r3, r4, lsr #2
 125:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 193              		.loc 1 125 0
 194 0042 31F81C1C 		ldrh	r1, [r1, #-28]
 195              		.loc 1 128 0
 196 0046 0B44     		add	r3, r3, r1
 129:../drivers/fsl_rtc.c ****     /* For leap year if month less than or equal to Febraury, decrement day counter*/
 130:../drivers/fsl_rtc.c ****     if ((!(datetime->year & 3U)) && (datetime->month <= 2U))
 197              		.loc 1 130 0
 198 0048 A107     		lsls	r1, r4, #30
 128:../drivers/fsl_rtc.c ****     /* For leap year if month less than or equal to Febraury, decrement day counter*/
 199              		.loc 1 128 0
 200 004a 03F1FF35 		add	r5, r3, #-1
 201              	.LVL6:
 202              		.loc 1 130 0
 203 004e 02D1     		bne	.L14
 204              		.loc 1 130 0 is_stmt 0 discriminator 1
 205 0050 0228     		cmp	r0, #2
 131:../drivers/fsl_rtc.c ****     {
 132:../drivers/fsl_rtc.c ****         seconds--;
 206              		.loc 1 132 0 is_stmt 1 discriminator 1
 207 0052 98BF     		it	ls
 208 0054 9D1E     		subls	r5, r3, #2
 209              	.LVL7:
 210              	.L14:
 133:../drivers/fsl_rtc.c ****     }
 134:../drivers/fsl_rtc.c **** 
 135:../drivers/fsl_rtc.c ****     seconds = (seconds * SECONDS_IN_A_DAY) + (datetime->hour * SECONDS_IN_A_HOUR) +
 136:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 211              		.loc 1 136 0
 212 0056 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 213              		.loc 1 135 0
 214 0058 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 215              		.loc 1 136 0
 216 005a C3EB0313 		rsb	r3, r3, r3, lsl #4
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 217              		.loc 1 135 0
 218 005e 4FF46160 		mov	r0, #3600
 219              		.loc 1 136 0
 220 0062 9B00     		lsls	r3, r3, #2
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 221              		.loc 1 135 0
 222 0064 00FB0133 		mla	r3, r0, r1, r3
 223              		.loc 1 136 0
 224 0068 9079     		ldrb	r0, [r2, #6]	@ zero_extendqisi2
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 225              		.loc 1 135 0
 226 006a 0344     		add	r3, r3, r0
 227              	.LVL8:
 137:../drivers/fsl_rtc.c **** 
 138:../drivers/fsl_rtc.c ****     return seconds;
 139:../drivers/fsl_rtc.c **** }
 228              		.loc 1 139 0
 229 006c 0348     		ldr	r0, .L16+4
 230 006e 00FB0530 		mla	r0, r0, r5, r3
 231              	.LVL9:
 232 0072 08B0     		add	sp, sp, #32
 233              		.cfi_def_cfa_offset 16
 234              		@ sp needed
 235 0074 70BD     		pop	{r4, r5, r6, pc}
 236              	.L17:
 237 0076 00BF     		.align	2
 238              	.L16:
 239 0078 0E000000 		.word	.LANCHOR0+14
 240 007c 80510100 		.word	86400
 241              		.cfi_endproc
 242              	.LFE154:
 244              		.section	.text.RTC_ConvertSecondsToDatetime,"ax",%progbits
 245              		.align	1
 246              		.syntax unified
 247              		.thumb
 248              		.thumb_func
 249              		.fpu fpv4-sp-d16
 251              	RTC_ConvertSecondsToDatetime:
 252              	.LFB155:
 140:../drivers/fsl_rtc.c **** 
 141:../drivers/fsl_rtc.c **** static void RTC_ConvertSecondsToDatetime(uint32_t seconds, rtc_datetime_t *datetime)
 142:../drivers/fsl_rtc.c **** {
 253              		.loc 1 142 0
 254              		.cfi_startproc
 255              		@ args = 0, pretend = 0, frame = 16
 256              		@ frame_needed = 0, uses_anonymous_args = 0
 257              	.LVL10:
 258 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 259              		.cfi_def_cfa_offset 20
 260              		.cfi_offset 4, -20
 261              		.cfi_offset 5, -16
 262              		.cfi_offset 6, -12
 263              		.cfi_offset 7, -8
 264              		.cfi_offset 14, -4
 143:../drivers/fsl_rtc.c ****     assert(datetime);
 144:../drivers/fsl_rtc.c **** 
 145:../drivers/fsl_rtc.c ****     uint32_t x;
 146:../drivers/fsl_rtc.c ****     uint32_t secondsRemaining, days;
 147:../drivers/fsl_rtc.c ****     uint16_t daysInYear;
 148:../drivers/fsl_rtc.c ****     /* Table of days in a month for a non leap year. First entry in the table is not used,
 149:../drivers/fsl_rtc.c ****      * valid months start from 1
 150:../drivers/fsl_rtc.c ****      */
 151:../drivers/fsl_rtc.c ****     uint8_t daysPerMonth[] = {0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U};
 265              		.loc 1 151 0
 266 0002 284A     		ldr	r2, .L30
 142:../drivers/fsl_rtc.c ****     assert(datetime);
 267              		.loc 1 142 0
 268 0004 85B0     		sub	sp, sp, #20
 269              		.cfi_def_cfa_offset 40
 270              		.loc 1 151 0
 271 0006 6C46     		mov	r4, sp
 142:../drivers/fsl_rtc.c ****     assert(datetime);
 272              		.loc 1 142 0
 273 0008 0746     		mov	r7, r0
 274 000a 0B46     		mov	r3, r1
 275              		.loc 1 151 0
 276 000c 02F1080C 		add	ip, r2, #8
 277 0010 2546     		mov	r5, r4
 278              	.LVL11:
 279              	.L19:
 280 0012 1068     		ldr	r0, [r2]	@ unaligned
 281 0014 5168     		ldr	r1, [r2, #4]	@ unaligned
 282 0016 2646     		mov	r6, r4
 283 0018 03C6     		stmia	r6!, {r0, r1}
 284 001a 0832     		adds	r2, r2, #8
 285 001c 6245     		cmp	r2, ip
 286 001e 3446     		mov	r4, r6
 287 0020 F7D1     		bne	.L19
 152:../drivers/fsl_rtc.c **** 
 153:../drivers/fsl_rtc.c ****     /* Start with the seconds value that is passed in to be converted to date time format */
 154:../drivers/fsl_rtc.c ****     secondsRemaining = seconds;
 155:../drivers/fsl_rtc.c **** 
 156:../drivers/fsl_rtc.c ****     /* Calcuate the number of days, we add 1 for the current day which is represented in the
 157:../drivers/fsl_rtc.c ****      * hours and seconds field
 158:../drivers/fsl_rtc.c ****      */
 159:../drivers/fsl_rtc.c ****     days = secondsRemaining / SECONDS_IN_A_DAY + 1;
 288              		.loc 1 159 0
 289 0022 2149     		ldr	r1, .L30+4
 151:../drivers/fsl_rtc.c **** 
 290              		.loc 1 151 0
 291 0024 1068     		ldr	r0, [r2]	@ unaligned
 292 0026 3060     		str	r0, [r6]
 160:../drivers/fsl_rtc.c **** 
 161:../drivers/fsl_rtc.c ****     /* Update seconds left*/
 162:../drivers/fsl_rtc.c ****     secondsRemaining = secondsRemaining % SECONDS_IN_A_DAY;
 163:../drivers/fsl_rtc.c **** 
 164:../drivers/fsl_rtc.c ****     /* Calculate the datetime hour, minute and second fields */
 165:../drivers/fsl_rtc.c ****     datetime->hour = secondsRemaining / SECONDS_IN_A_HOUR;
 293              		.loc 1 165 0
 294 0028 4FF46164 		mov	r4, #3600
 159:../drivers/fsl_rtc.c **** 
 295              		.loc 1 159 0
 296 002c B7FBF1F0 		udiv	r0, r7, r1
 151:../drivers/fsl_rtc.c **** 
 297              		.loc 1 151 0
 298 0030 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 299 0032 3271     		strb	r2, [r6, #4]
 300              	.LVL12:
 162:../drivers/fsl_rtc.c **** 
 301              		.loc 1 162 0
 302 0034 01FB1071 		mls	r1, r1, r0, r7
 159:../drivers/fsl_rtc.c **** 
 303              		.loc 1 159 0
 304 0038 421C     		adds	r2, r0, #1
 305              	.LVL13:
 306              		.loc 1 165 0
 307 003a B1FBF4F0 		udiv	r0, r1, r4
 308 003e 1871     		strb	r0, [r3, #4]
 166:../drivers/fsl_rtc.c ****     secondsRemaining = secondsRemaining % SECONDS_IN_A_HOUR;
 309              		.loc 1 166 0
 310 0040 04FB1010 		mls	r0, r4, r0, r1
 311              	.LVL14:
 167:../drivers/fsl_rtc.c ****     datetime->minute = secondsRemaining / 60U;
 312              		.loc 1 167 0
 313 0044 3C24     		movs	r4, #60
 314 0046 B0FBF4F1 		udiv	r1, r0, r4
 168:../drivers/fsl_rtc.c ****     datetime->second = secondsRemaining % SECONDS_IN_A_MINUTE;
 315              		.loc 1 168 0
 316 004a 04FB1100 		mls	r0, r4, r1, r0
 317              	.LVL15:
 167:../drivers/fsl_rtc.c ****     datetime->minute = secondsRemaining / 60U;
 318              		.loc 1 167 0
 319 004e 5971     		strb	r1, [r3, #5]
 320              		.loc 1 168 0
 321 0050 9871     		strb	r0, [r3, #6]
 322              	.LVL16:
 169:../drivers/fsl_rtc.c **** 
 170:../drivers/fsl_rtc.c ****     /* Calculate year */
 171:../drivers/fsl_rtc.c ****     daysInYear = DAYS_IN_A_YEAR;
 172:../drivers/fsl_rtc.c ****     datetime->year = YEAR_RANGE_START;
 323              		.loc 1 172 0
 324 0052 40F2B271 		movw	r1, #1970
 171:../drivers/fsl_rtc.c ****     datetime->year = YEAR_RANGE_START;
 325              		.loc 1 171 0
 326 0056 40F26D10 		movw	r0, #365
 327              		.loc 1 172 0
 328 005a 1980     		strh	r1, [r3]	@ movhi
 173:../drivers/fsl_rtc.c ****     while (days > daysInYear)
 174:../drivers/fsl_rtc.c ****     {
 175:../drivers/fsl_rtc.c ****         /* Decrease day count by a year and increment year by 1 */
 176:../drivers/fsl_rtc.c ****         days -= daysInYear;
 177:../drivers/fsl_rtc.c ****         datetime->year++;
 178:../drivers/fsl_rtc.c **** 
 179:../drivers/fsl_rtc.c ****         /* Adjust the number of days for a leap year */
 180:../drivers/fsl_rtc.c ****         if (datetime->year & 3U)
 181:../drivers/fsl_rtc.c ****         {
 182:../drivers/fsl_rtc.c ****             daysInYear = DAYS_IN_A_YEAR;
 329              		.loc 1 182 0
 330 005c 0446     		mov	r4, r0
 331              	.LVL17:
 332              	.L20:
 173:../drivers/fsl_rtc.c ****     while (days > daysInYear)
 333              		.loc 1 173 0
 334 005e 9042     		cmp	r0, r2
 335 0060 1988     		ldrh	r1, [r3]
 336 0062 0CD3     		bcc	.L22
 183:../drivers/fsl_rtc.c ****         }
 184:../drivers/fsl_rtc.c ****         else
 185:../drivers/fsl_rtc.c ****         {
 186:../drivers/fsl_rtc.c ****             daysInYear = DAYS_IN_A_YEAR + 1;
 187:../drivers/fsl_rtc.c ****         }
 188:../drivers/fsl_rtc.c ****     }
 189:../drivers/fsl_rtc.c **** 
 190:../drivers/fsl_rtc.c ****     /* Adjust the days in February for a leap year */
 191:../drivers/fsl_rtc.c ****     if (!(datetime->year & 3U))
 337              		.loc 1 191 0
 338 0064 8907     		lsls	r1, r1, #30
 192:../drivers/fsl_rtc.c ****     {
 193:../drivers/fsl_rtc.c ****         daysPerMonth[2] = 29U;
 339              		.loc 1 193 0
 340 0066 04BF     		itt	eq
 341 0068 1D21     		moveq	r1, #29
 342 006a 8DF80210 		strbeq	r1, [sp, #2]
 343              	.LVL18:
 194:../drivers/fsl_rtc.c ****     }
 195:../drivers/fsl_rtc.c **** 
 196:../drivers/fsl_rtc.c ****     for (x = 1U; x <= 12U; x++)
 344              		.loc 1 196 0
 345 006e 0121     		movs	r1, #1
 346              	.LVL19:
 347              	.L26:
 197:../drivers/fsl_rtc.c ****     {
 198:../drivers/fsl_rtc.c ****         if (days <= daysPerMonth[x])
 348              		.loc 1 198 0
 349 0070 685C     		ldrb	r0, [r5, r1]	@ zero_extendqisi2
 350 0072 9042     		cmp	r0, r2
 351 0074 0FD3     		bcc	.L24
 199:../drivers/fsl_rtc.c ****         {
 200:../drivers/fsl_rtc.c ****             datetime->month = x;
 352              		.loc 1 200 0
 353 0076 9970     		strb	r1, [r3, #2]
 354              	.L25:
 201:../drivers/fsl_rtc.c ****             break;
 202:../drivers/fsl_rtc.c ****         }
 203:../drivers/fsl_rtc.c ****         else
 204:../drivers/fsl_rtc.c ****         {
 205:../drivers/fsl_rtc.c ****             days -= daysPerMonth[x];
 206:../drivers/fsl_rtc.c ****         }
 207:../drivers/fsl_rtc.c ****     }
 208:../drivers/fsl_rtc.c **** 
 209:../drivers/fsl_rtc.c ****     datetime->day = days;
 355              		.loc 1 209 0
 356 0078 DA70     		strb	r2, [r3, #3]
 210:../drivers/fsl_rtc.c **** }
 357              		.loc 1 210 0
 358 007a 05B0     		add	sp, sp, #20
 359              		.cfi_remember_state
 360              		.cfi_def_cfa_offset 20
 361              		@ sp needed
 362 007c F0BD     		pop	{r4, r5, r6, r7, pc}
 363              	.LVL20:
 364              	.L22:
 365              		.cfi_restore_state
 177:../drivers/fsl_rtc.c **** 
 366              		.loc 1 177 0
 367 007e 0131     		adds	r1, r1, #1
 368 0080 89B2     		uxth	r1, r1
 182:../drivers/fsl_rtc.c ****         }
 369              		.loc 1 182 0
 370 0082 11F0030F 		tst	r1, #3
 176:../drivers/fsl_rtc.c ****         datetime->year++;
 371              		.loc 1 176 0
 372 0086 A2EB0002 		sub	r2, r2, r0
 373              	.LVL21:
 177:../drivers/fsl_rtc.c **** 
 374              		.loc 1 177 0
 375 008a 1980     		strh	r1, [r3]	@ movhi
 182:../drivers/fsl_rtc.c ****         }
 376              		.loc 1 182 0
 377 008c 0CBF     		ite	eq
 378 008e 4FF4B770 		moveq	r0, #366
 379              	.LVL22:
 380 0092 2046     		movne	r0, r4
 381 0094 E3E7     		b	.L20
 382              	.LVL23:
 383              	.L24:
 196:../drivers/fsl_rtc.c ****     {
 384              		.loc 1 196 0 discriminator 2
 385 0096 0131     		adds	r1, r1, #1
 386              	.LVL24:
 387 0098 0D29     		cmp	r1, #13
 205:../drivers/fsl_rtc.c ****         }
 388              		.loc 1 205 0 discriminator 2
 389 009a A2EB0002 		sub	r2, r2, r0
 390              	.LVL25:
 196:../drivers/fsl_rtc.c ****     {
 391              		.loc 1 196 0 discriminator 2
 392 009e E7D1     		bne	.L26
 393 00a0 EAE7     		b	.L25
 394              	.L31:
 395 00a2 00BF     		.align	2
 396              	.L30:
 397 00a4 00000000 		.word	.LANCHOR0
 398 00a8 80510100 		.word	86400
 399              		.cfi_endproc
 400              	.LFE155:
 402              		.section	.text.RTC_GetDefaultConfig,"ax",%progbits
 403              		.align	1
 404              		.global	RTC_GetDefaultConfig
 405              		.syntax unified
 406              		.thumb
 407              		.thumb_func
 408              		.fpu fpv4-sp-d16
 410              	RTC_GetDefaultConfig:
 411              	.LFB157:
 211:../drivers/fsl_rtc.c **** 
 212:../drivers/fsl_rtc.c **** void RTC_Init(RTC_Type *base, const rtc_config_t *config)
 213:../drivers/fsl_rtc.c **** {
 214:../drivers/fsl_rtc.c ****     assert(config);
 215:../drivers/fsl_rtc.c **** 
 216:../drivers/fsl_rtc.c ****     uint32_t reg;
 217:../drivers/fsl_rtc.c **** 
 218:../drivers/fsl_rtc.c **** #if defined(RTC_CLOCKS)
 219:../drivers/fsl_rtc.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 220:../drivers/fsl_rtc.c ****     CLOCK_EnableClock(kCLOCK_Rtc0);
 221:../drivers/fsl_rtc.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 222:../drivers/fsl_rtc.c **** #endif /* RTC_CLOCKS */
 223:../drivers/fsl_rtc.c **** 
 224:../drivers/fsl_rtc.c ****     /* Issue a software reset if timer is invalid */
 225:../drivers/fsl_rtc.c ****     if (RTC_GetStatusFlags(RTC) & kRTC_TimeInvalidFlag)
 226:../drivers/fsl_rtc.c ****     {
 227:../drivers/fsl_rtc.c ****         RTC_Reset(RTC);
 228:../drivers/fsl_rtc.c ****     }
 229:../drivers/fsl_rtc.c **** 
 230:../drivers/fsl_rtc.c ****     reg = base->CR;
 231:../drivers/fsl_rtc.c ****     /* Setup the update mode and supervisor access mode */
 232:../drivers/fsl_rtc.c ****     reg &= ~(RTC_CR_UM_MASK | RTC_CR_SUP_MASK);
 233:../drivers/fsl_rtc.c ****     reg |= RTC_CR_UM(config->updateMode) | RTC_CR_SUP(config->supervisorAccess);
 234:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION) && FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION
 235:../drivers/fsl_rtc.c ****     /* Setup the wakeup pin select */
 236:../drivers/fsl_rtc.c ****     reg &= ~(RTC_CR_WPS_MASK);
 237:../drivers/fsl_rtc.c ****     reg |= RTC_CR_WPS(config->wakeupSelect);
 238:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_WAKEUP_PIN */
 239:../drivers/fsl_rtc.c ****     base->CR = reg;
 240:../drivers/fsl_rtc.c **** 
 241:../drivers/fsl_rtc.c ****     /* Configure the RTC time compensation register */
 242:../drivers/fsl_rtc.c ****     base->TCR = (RTC_TCR_CIR(config->compensationInterval) | RTC_TCR_TCR(config->compensationTime))
 243:../drivers/fsl_rtc.c **** 	
 244:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_TSIC) && FSL_FEATURE_RTC_HAS_TSIC
 245:../drivers/fsl_rtc.c **** 	/* Configure RTC timer seconds interrupt to be generated once per second */
 246:../drivers/fsl_rtc.c **** 	base->IER &= ~(RTC_IER_TSIC_MASK | RTC_IER_TSIE_MASK);
 247:../drivers/fsl_rtc.c **** #endif
 248:../drivers/fsl_rtc.c **** }
 249:../drivers/fsl_rtc.c **** 
 250:../drivers/fsl_rtc.c **** void RTC_GetDefaultConfig(rtc_config_t *config)
 251:../drivers/fsl_rtc.c **** {
 412              		.loc 1 251 0
 413              		.cfi_startproc
 414              		@ args = 0, pretend = 0, frame = 0
 415              		@ frame_needed = 0, uses_anonymous_args = 0
 416              		@ link register save eliminated.
 417              	.LVL26:
 252:../drivers/fsl_rtc.c ****     assert(config);
 253:../drivers/fsl_rtc.c **** 
 254:../drivers/fsl_rtc.c ****     /* Wakeup pin will assert if the RTC interrupt asserts or if the wakeup pin is turned on */
 255:../drivers/fsl_rtc.c ****     config->wakeupSelect = false;
 418              		.loc 1 255 0
 419 0000 0023     		movs	r3, #0
 420 0002 0370     		strb	r3, [r0]
 256:../drivers/fsl_rtc.c ****     /* Registers cannot be written when locked */
 257:../drivers/fsl_rtc.c ****     config->updateMode = false;
 421              		.loc 1 257 0
 422 0004 4370     		strb	r3, [r0, #1]
 258:../drivers/fsl_rtc.c ****     /* Non-supervisor mode write accesses are not supported and will generate a bus error */
 259:../drivers/fsl_rtc.c ****     config->supervisorAccess = false;
 423              		.loc 1 259 0
 424 0006 8370     		strb	r3, [r0, #2]
 260:../drivers/fsl_rtc.c ****     /* Compensation interval used by the crystal compensation logic */
 261:../drivers/fsl_rtc.c ****     config->compensationInterval = 0;
 262:../drivers/fsl_rtc.c ****     /* Compensation time used by the crystal compensation logic */
 263:../drivers/fsl_rtc.c ****     config->compensationTime = 0;
 425              		.loc 1 263 0
 426 0008 C0E90133 		strd	r3, r3, [r0, #4]
 264:../drivers/fsl_rtc.c **** }
 427              		.loc 1 264 0
 428 000c 7047     		bx	lr
 429              		.cfi_endproc
 430              	.LFE157:
 432              		.section	.text.RTC_SetDatetime,"ax",%progbits
 433              		.align	1
 434              		.global	RTC_SetDatetime
 435              		.syntax unified
 436              		.thumb
 437              		.thumb_func
 438              		.fpu fpv4-sp-d16
 440              	RTC_SetDatetime:
 441              	.LFB158:
 265:../drivers/fsl_rtc.c **** 
 266:../drivers/fsl_rtc.c **** status_t RTC_SetDatetime(RTC_Type *base, const rtc_datetime_t *datetime)
 267:../drivers/fsl_rtc.c **** {
 442              		.loc 1 267 0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 0
 445              		@ frame_needed = 0, uses_anonymous_args = 0
 446              	.LVL27:
 447 0000 38B5     		push	{r3, r4, r5, lr}
 448              		.cfi_def_cfa_offset 16
 449              		.cfi_offset 3, -16
 450              		.cfi_offset 4, -12
 451              		.cfi_offset 5, -8
 452              		.cfi_offset 14, -4
 453              		.loc 1 267 0
 454 0002 0546     		mov	r5, r0
 268:../drivers/fsl_rtc.c ****     assert(datetime);
 269:../drivers/fsl_rtc.c **** 
 270:../drivers/fsl_rtc.c ****     /* Return error if the time provided is not valid */
 271:../drivers/fsl_rtc.c ****     if (!(RTC_CheckDatetimeFormat(datetime)))
 455              		.loc 1 271 0
 456 0004 0846     		mov	r0, r1
 457              	.LVL28:
 267:../drivers/fsl_rtc.c ****     assert(datetime);
 458              		.loc 1 267 0
 459 0006 0C46     		mov	r4, r1
 460              		.loc 1 271 0
 461 0008 FFF7FEFF 		bl	RTC_CheckDatetimeFormat
 462              	.LVL29:
 463 000c 28B1     		cbz	r0, .L35
 272:../drivers/fsl_rtc.c ****     {
 273:../drivers/fsl_rtc.c ****         return kStatus_InvalidArgument;
 274:../drivers/fsl_rtc.c ****     }
 275:../drivers/fsl_rtc.c **** 
 276:../drivers/fsl_rtc.c ****     /* Set time in seconds */
 277:../drivers/fsl_rtc.c ****     base->TSR = RTC_ConvertDatetimeToSeconds(datetime);
 464              		.loc 1 277 0
 465 000e 2046     		mov	r0, r4
 466 0010 FFF7FEFF 		bl	RTC_ConvertDatetimeToSeconds
 467              	.LVL30:
 468 0014 2860     		str	r0, [r5]
 278:../drivers/fsl_rtc.c **** 
 279:../drivers/fsl_rtc.c ****     return kStatus_Success;
 469              		.loc 1 279 0
 470 0016 0020     		movs	r0, #0
 471              	.L33:
 280:../drivers/fsl_rtc.c **** }
 472              		.loc 1 280 0
 473 0018 38BD     		pop	{r3, r4, r5, pc}
 474              	.LVL31:
 475              	.L35:
 273:../drivers/fsl_rtc.c ****     }
 476              		.loc 1 273 0
 477 001a 0420     		movs	r0, #4
 478 001c FCE7     		b	.L33
 479              		.cfi_endproc
 480              	.LFE158:
 482              		.section	.text.RTC_GetDatetime,"ax",%progbits
 483              		.align	1
 484              		.global	RTC_GetDatetime
 485              		.syntax unified
 486              		.thumb
 487              		.thumb_func
 488              		.fpu fpv4-sp-d16
 490              	RTC_GetDatetime:
 491              	.LFB159:
 281:../drivers/fsl_rtc.c **** 
 282:../drivers/fsl_rtc.c **** void RTC_GetDatetime(RTC_Type *base, rtc_datetime_t *datetime)
 283:../drivers/fsl_rtc.c **** {
 492              		.loc 1 283 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 0
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              		@ link register save eliminated.
 497              	.LVL32:
 284:../drivers/fsl_rtc.c ****     assert(datetime);
 285:../drivers/fsl_rtc.c **** 
 286:../drivers/fsl_rtc.c ****     uint32_t seconds = 0;
 287:../drivers/fsl_rtc.c **** 
 288:../drivers/fsl_rtc.c ****     seconds = base->TSR;
 498              		.loc 1 288 0
 499 0000 0068     		ldr	r0, [r0]
 500              	.LVL33:
 289:../drivers/fsl_rtc.c ****     RTC_ConvertSecondsToDatetime(seconds, datetime);
 501              		.loc 1 289 0
 502 0002 FFF7FEBF 		b	RTC_ConvertSecondsToDatetime
 503              	.LVL34:
 504              		.cfi_endproc
 505              	.LFE159:
 507              		.section	.text.RTC_SetAlarm,"ax",%progbits
 508              		.align	1
 509              		.global	RTC_SetAlarm
 510              		.syntax unified
 511              		.thumb
 512              		.thumb_func
 513              		.fpu fpv4-sp-d16
 515              	RTC_SetAlarm:
 516              	.LFB160:
 290:../drivers/fsl_rtc.c **** }
 291:../drivers/fsl_rtc.c **** 
 292:../drivers/fsl_rtc.c **** status_t RTC_SetAlarm(RTC_Type *base, const rtc_datetime_t *alarmTime)
 293:../drivers/fsl_rtc.c **** {
 517              		.loc 1 293 0
 518              		.cfi_startproc
 519              		@ args = 0, pretend = 0, frame = 0
 520              		@ frame_needed = 0, uses_anonymous_args = 0
 521              	.LVL35:
 522 0000 38B5     		push	{r3, r4, r5, lr}
 523              		.cfi_def_cfa_offset 16
 524              		.cfi_offset 3, -16
 525              		.cfi_offset 4, -12
 526              		.cfi_offset 5, -8
 527              		.cfi_offset 14, -4
 528              		.loc 1 293 0
 529 0002 0446     		mov	r4, r0
 294:../drivers/fsl_rtc.c ****     assert(alarmTime);
 295:../drivers/fsl_rtc.c **** 
 296:../drivers/fsl_rtc.c ****     uint32_t alarmSeconds = 0;
 297:../drivers/fsl_rtc.c ****     uint32_t currSeconds = 0;
 298:../drivers/fsl_rtc.c **** 
 299:../drivers/fsl_rtc.c ****     /* Return error if the alarm time provided is not valid */
 300:../drivers/fsl_rtc.c ****     if (!(RTC_CheckDatetimeFormat(alarmTime)))
 530              		.loc 1 300 0
 531 0004 0846     		mov	r0, r1
 532              	.LVL36:
 293:../drivers/fsl_rtc.c ****     assert(alarmTime);
 533              		.loc 1 293 0
 534 0006 0D46     		mov	r5, r1
 535              		.loc 1 300 0
 536 0008 FFF7FEFF 		bl	RTC_CheckDatetimeFormat
 537              	.LVL37:
 538 000c 40B1     		cbz	r0, .L39
 301:../drivers/fsl_rtc.c ****     {
 302:../drivers/fsl_rtc.c ****         return kStatus_InvalidArgument;
 303:../drivers/fsl_rtc.c ****     }
 304:../drivers/fsl_rtc.c **** 
 305:../drivers/fsl_rtc.c ****     alarmSeconds = RTC_ConvertDatetimeToSeconds(alarmTime);
 539              		.loc 1 305 0
 540 000e 2846     		mov	r0, r5
 541 0010 FFF7FEFF 		bl	RTC_ConvertDatetimeToSeconds
 542              	.LVL38:
 306:../drivers/fsl_rtc.c **** 
 307:../drivers/fsl_rtc.c ****     /* Get the current time */
 308:../drivers/fsl_rtc.c ****     currSeconds = base->TSR;
 543              		.loc 1 308 0
 544 0014 2368     		ldr	r3, [r4]
 545              	.LVL39:
 309:../drivers/fsl_rtc.c **** 
 310:../drivers/fsl_rtc.c ****     /* Return error if the alarm time has passed */
 311:../drivers/fsl_rtc.c ****     if (alarmSeconds < currSeconds)
 546              		.loc 1 311 0
 547 0016 9842     		cmp	r0, r3
 548 0018 04D3     		bcc	.L40
 312:../drivers/fsl_rtc.c ****     {
 313:../drivers/fsl_rtc.c ****         return kStatus_Fail;
 314:../drivers/fsl_rtc.c ****     }
 315:../drivers/fsl_rtc.c **** 
 316:../drivers/fsl_rtc.c ****     /* Set alarm in seconds*/
 317:../drivers/fsl_rtc.c ****     base->TAR = alarmSeconds;
 549              		.loc 1 317 0
 550 001a A060     		str	r0, [r4, #8]
 318:../drivers/fsl_rtc.c **** 
 319:../drivers/fsl_rtc.c ****     return kStatus_Success;
 551              		.loc 1 319 0
 552 001c 0020     		movs	r0, #0
 553              	.LVL40:
 554              	.L37:
 320:../drivers/fsl_rtc.c **** }
 555              		.loc 1 320 0
 556 001e 38BD     		pop	{r3, r4, r5, pc}
 557              	.LVL41:
 558              	.L39:
 302:../drivers/fsl_rtc.c ****     }
 559              		.loc 1 302 0
 560 0020 0420     		movs	r0, #4
 561 0022 FCE7     		b	.L37
 562              	.LVL42:
 563              	.L40:
 313:../drivers/fsl_rtc.c ****     }
 564              		.loc 1 313 0
 565 0024 0120     		movs	r0, #1
 566              	.LVL43:
 567 0026 FAE7     		b	.L37
 568              		.cfi_endproc
 569              	.LFE160:
 571              		.section	.text.RTC_GetAlarm,"ax",%progbits
 572              		.align	1
 573              		.global	RTC_GetAlarm
 574              		.syntax unified
 575              		.thumb
 576              		.thumb_func
 577              		.fpu fpv4-sp-d16
 579              	RTC_GetAlarm:
 580              	.LFB161:
 321:../drivers/fsl_rtc.c **** 
 322:../drivers/fsl_rtc.c **** void RTC_GetAlarm(RTC_Type *base, rtc_datetime_t *datetime)
 323:../drivers/fsl_rtc.c **** {
 581              		.loc 1 323 0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 0
 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              		@ link register save eliminated.
 586              	.LVL44:
 324:../drivers/fsl_rtc.c ****     assert(datetime);
 325:../drivers/fsl_rtc.c **** 
 326:../drivers/fsl_rtc.c ****     uint32_t alarmSeconds = 0;
 327:../drivers/fsl_rtc.c **** 
 328:../drivers/fsl_rtc.c ****     /* Get alarm in seconds  */
 329:../drivers/fsl_rtc.c ****     alarmSeconds = base->TAR;
 587              		.loc 1 329 0
 588 0000 8068     		ldr	r0, [r0, #8]
 589              	.LVL45:
 330:../drivers/fsl_rtc.c **** 
 331:../drivers/fsl_rtc.c ****     RTC_ConvertSecondsToDatetime(alarmSeconds, datetime);
 590              		.loc 1 331 0
 591 0002 FFF7FEBF 		b	RTC_ConvertSecondsToDatetime
 592              	.LVL46:
 593              		.cfi_endproc
 594              	.LFE161:
 596              		.section	.text.RTC_EnableInterrupts,"ax",%progbits
 597              		.align	1
 598              		.global	RTC_EnableInterrupts
 599              		.syntax unified
 600              		.thumb
 601              		.thumb_func
 602              		.fpu fpv4-sp-d16
 604              	RTC_EnableInterrupts:
 605              	.LFB162:
 332:../drivers/fsl_rtc.c **** }
 333:../drivers/fsl_rtc.c **** 
 334:../drivers/fsl_rtc.c **** void RTC_EnableInterrupts(RTC_Type *base, uint32_t mask)
 335:../drivers/fsl_rtc.c **** {
 606              		.loc 1 335 0
 607              		.cfi_startproc
 608              		@ args = 0, pretend = 0, frame = 0
 609              		@ frame_needed = 0, uses_anonymous_args = 0
 610              		@ link register save eliminated.
 611              	.LVL47:
 336:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 337:../drivers/fsl_rtc.c **** 
 338:../drivers/fsl_rtc.c ****     /* RTC_IER */
 339:../drivers/fsl_rtc.c ****     if (kRTC_TimeInvalidInterruptEnable == (kRTC_TimeInvalidInterruptEnable & mask))
 612              		.loc 1 339 0
 613 0000 01F00103 		and	r3, r1, #1
 614              	.LVL48:
 340:../drivers/fsl_rtc.c ****     {
 341:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TIIE_MASK;
 342:../drivers/fsl_rtc.c ****     }
 343:../drivers/fsl_rtc.c ****     if (kRTC_TimeOverflowInterruptEnable == (kRTC_TimeOverflowInterruptEnable & mask))
 615              		.loc 1 343 0
 616 0004 8A07     		lsls	r2, r1, #30
 344:../drivers/fsl_rtc.c ****     {
 345:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TOIE_MASK;
 617              		.loc 1 345 0
 618 0006 48BF     		it	mi
 619 0008 43F00203 		orrmi	r3, r3, #2
 620              	.LVL49:
 346:../drivers/fsl_rtc.c ****     }
 347:../drivers/fsl_rtc.c ****     if (kRTC_AlarmInterruptEnable == (kRTC_AlarmInterruptEnable & mask))
 621              		.loc 1 347 0
 622 000c 4A07     		lsls	r2, r1, #29
 348:../drivers/fsl_rtc.c ****     {
 349:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TAIE_MASK;
 623              		.loc 1 349 0
 624 000e 48BF     		it	mi
 625 0010 43F00403 		orrmi	r3, r3, #4
 626              	.LVL50:
 350:../drivers/fsl_rtc.c ****     }
 351:../drivers/fsl_rtc.c ****     if (kRTC_SecondsInterruptEnable == (kRTC_SecondsInterruptEnable & mask))
 627              		.loc 1 351 0
 628 0014 0A07     		lsls	r2, r1, #28
 352:../drivers/fsl_rtc.c ****     {
 353:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TSIE_MASK;
 354:../drivers/fsl_rtc.c ****     }
 355:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 356:../drivers/fsl_rtc.c ****     if (kRTC_MonotonicOverflowInterruptEnable == (kRTC_MonotonicOverflowInterruptEnable & mask))
 357:../drivers/fsl_rtc.c ****     {
 358:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_MOIE_MASK;
 359:../drivers/fsl_rtc.c ****     }
 360:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 361:../drivers/fsl_rtc.c ****     base->IER |= tmp32;
 629              		.loc 1 361 0
 630 0016 C269     		ldr	r2, [r0, #28]
 353:../drivers/fsl_rtc.c ****     }
 631              		.loc 1 353 0
 632 0018 48BF     		it	mi
 633 001a 43F01003 		orrmi	r3, r3, #16
 634              	.LVL51:
 635              		.loc 1 361 0
 636 001e 1343     		orrs	r3, r3, r2
 637              	.LVL52:
 638 0020 C361     		str	r3, [r0, #28]
 362:../drivers/fsl_rtc.c **** 
 363:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
 364:../drivers/fsl_rtc.c ****     tmp32 = 0U;
 365:../drivers/fsl_rtc.c **** 
 366:../drivers/fsl_rtc.c ****     /* RTC_TIR */
 367:../drivers/fsl_rtc.c ****     if (kRTC_TestModeInterruptEnable == (kRTC_TestModeInterruptEnable & mask))
 368:../drivers/fsl_rtc.c ****     {
 369:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TMIE_MASK;
 370:../drivers/fsl_rtc.c ****     }
 371:../drivers/fsl_rtc.c ****     if (kRTC_FlashSecurityInterruptEnable == (kRTC_FlashSecurityInterruptEnable & mask))
 372:../drivers/fsl_rtc.c ****     {
 373:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_FSIE_MASK;
 374:../drivers/fsl_rtc.c ****     }
 375:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
 376:../drivers/fsl_rtc.c ****     if (kRTC_TamperPinInterruptEnable == (kRTC_TamperPinInterruptEnable & mask))
 377:../drivers/fsl_rtc.c ****     {
 378:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TPIE_MASK;
 379:../drivers/fsl_rtc.c ****     }
 380:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
 381:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
 382:../drivers/fsl_rtc.c ****     if (kRTC_SecurityModuleInterruptEnable == (kRTC_SecurityModuleInterruptEnable & mask))
 383:../drivers/fsl_rtc.c ****     {
 384:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_SIE_MASK;
 385:../drivers/fsl_rtc.c ****     }
 386:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_SIE */
 387:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
 388:../drivers/fsl_rtc.c ****     if (kRTC_LossOfClockInterruptEnable == (kRTC_LossOfClockInterruptEnable & mask))
 389:../drivers/fsl_rtc.c ****     {
 390:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_LCIE_MASK;
 391:../drivers/fsl_rtc.c ****     }
 392:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
 393:../drivers/fsl_rtc.c ****     base->TIR |= tmp32;
 394:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
 395:../drivers/fsl_rtc.c **** }
 639              		.loc 1 395 0
 640 0022 7047     		bx	lr
 641              		.cfi_endproc
 642              	.LFE162:
 644              		.section	.text.RTC_DisableInterrupts,"ax",%progbits
 645              		.align	1
 646              		.global	RTC_DisableInterrupts
 647              		.syntax unified
 648              		.thumb
 649              		.thumb_func
 650              		.fpu fpv4-sp-d16
 652              	RTC_DisableInterrupts:
 653              	.LFB163:
 396:../drivers/fsl_rtc.c **** 
 397:../drivers/fsl_rtc.c **** void RTC_DisableInterrupts(RTC_Type *base, uint32_t mask)
 398:../drivers/fsl_rtc.c **** {
 654              		.loc 1 398 0
 655              		.cfi_startproc
 656              		@ args = 0, pretend = 0, frame = 0
 657              		@ frame_needed = 0, uses_anonymous_args = 0
 658              		@ link register save eliminated.
 659              	.LVL53:
 399:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 400:../drivers/fsl_rtc.c **** 
 401:../drivers/fsl_rtc.c ****     /* RTC_IER */
 402:../drivers/fsl_rtc.c ****     if (kRTC_TimeInvalidInterruptEnable == (kRTC_TimeInvalidInterruptEnable & mask))
 660              		.loc 1 402 0
 661 0000 01F00103 		and	r3, r1, #1
 662              	.LVL54:
 403:../drivers/fsl_rtc.c ****     {
 404:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TIIE_MASK;
 405:../drivers/fsl_rtc.c ****     }
 406:../drivers/fsl_rtc.c ****     if (kRTC_TimeOverflowInterruptEnable == (kRTC_TimeOverflowInterruptEnable & mask))
 663              		.loc 1 406 0
 664 0004 8A07     		lsls	r2, r1, #30
 407:../drivers/fsl_rtc.c ****     {
 408:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TOIE_MASK;
 665              		.loc 1 408 0
 666 0006 48BF     		it	mi
 667 0008 43F00203 		orrmi	r3, r3, #2
 668              	.LVL55:
 409:../drivers/fsl_rtc.c ****     }
 410:../drivers/fsl_rtc.c ****     if (kRTC_AlarmInterruptEnable == (kRTC_AlarmInterruptEnable & mask))
 669              		.loc 1 410 0
 670 000c 4A07     		lsls	r2, r1, #29
 411:../drivers/fsl_rtc.c ****     {
 412:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TAIE_MASK;
 671              		.loc 1 412 0
 672 000e 48BF     		it	mi
 673 0010 43F00403 		orrmi	r3, r3, #4
 674              	.LVL56:
 413:../drivers/fsl_rtc.c ****     }
 414:../drivers/fsl_rtc.c ****     if (kRTC_SecondsInterruptEnable == (kRTC_SecondsInterruptEnable & mask))
 675              		.loc 1 414 0
 676 0014 0A07     		lsls	r2, r1, #28
 415:../drivers/fsl_rtc.c ****     {
 416:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TSIE_MASK;
 417:../drivers/fsl_rtc.c ****     }
 418:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 419:../drivers/fsl_rtc.c ****     if (kRTC_MonotonicOverflowInterruptEnable == (kRTC_MonotonicOverflowInterruptEnable & mask))
 420:../drivers/fsl_rtc.c ****     {
 421:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_MOIE_MASK;
 422:../drivers/fsl_rtc.c ****     }
 423:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 424:../drivers/fsl_rtc.c ****     base->IER &= (uint32_t)(~tmp32);
 677              		.loc 1 424 0
 678 0016 C269     		ldr	r2, [r0, #28]
 416:../drivers/fsl_rtc.c ****     }
 679              		.loc 1 416 0
 680 0018 48BF     		it	mi
 681 001a 43F01003 		orrmi	r3, r3, #16
 682              	.LVL57:
 683              		.loc 1 424 0
 684 001e 22EA0303 		bic	r3, r2, r3
 685              	.LVL58:
 686 0022 C361     		str	r3, [r0, #28]
 425:../drivers/fsl_rtc.c **** 
 426:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
 427:../drivers/fsl_rtc.c ****     tmp32 = 0U;
 428:../drivers/fsl_rtc.c **** 
 429:../drivers/fsl_rtc.c ****     /* RTC_TIR */
 430:../drivers/fsl_rtc.c ****     if (kRTC_TestModeInterruptEnable == (kRTC_TestModeInterruptEnable & mask))
 431:../drivers/fsl_rtc.c ****     {
 432:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TMIE_MASK;
 433:../drivers/fsl_rtc.c ****     }
 434:../drivers/fsl_rtc.c ****     if (kRTC_FlashSecurityInterruptEnable == (kRTC_FlashSecurityInterruptEnable & mask))
 435:../drivers/fsl_rtc.c ****     {
 436:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_FSIE_MASK;
 437:../drivers/fsl_rtc.c ****     }
 438:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
 439:../drivers/fsl_rtc.c ****     if (kRTC_TamperPinInterruptEnable == (kRTC_TamperPinInterruptEnable & mask))
 440:../drivers/fsl_rtc.c ****     {
 441:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TPIE_MASK;
 442:../drivers/fsl_rtc.c ****     }
 443:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
 444:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
 445:../drivers/fsl_rtc.c ****     if (kRTC_SecurityModuleInterruptEnable == (kRTC_SecurityModuleInterruptEnable & mask))
 446:../drivers/fsl_rtc.c ****     {
 447:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_SIE_MASK;
 448:../drivers/fsl_rtc.c ****     }
 449:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_SIE */
 450:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
 451:../drivers/fsl_rtc.c ****     if (kRTC_LossOfClockInterruptEnable == (kRTC_LossOfClockInterruptEnable & mask))
 452:../drivers/fsl_rtc.c ****     {
 453:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_LCIE_MASK;
 454:../drivers/fsl_rtc.c ****     }
 455:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
 456:../drivers/fsl_rtc.c ****     base->TIR &= (uint32_t)(~tmp32);
 457:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
 458:../drivers/fsl_rtc.c **** }
 687              		.loc 1 458 0
 688 0024 7047     		bx	lr
 689              		.cfi_endproc
 690              	.LFE163:
 692              		.section	.text.RTC_GetEnabledInterrupts,"ax",%progbits
 693              		.align	1
 694              		.global	RTC_GetEnabledInterrupts
 695              		.syntax unified
 696              		.thumb
 697              		.thumb_func
 698              		.fpu fpv4-sp-d16
 700              	RTC_GetEnabledInterrupts:
 701              	.LFB164:
 459:../drivers/fsl_rtc.c **** 
 460:../drivers/fsl_rtc.c **** uint32_t RTC_GetEnabledInterrupts(RTC_Type *base)
 461:../drivers/fsl_rtc.c **** {
 702              		.loc 1 461 0
 703              		.cfi_startproc
 704              		@ args = 0, pretend = 0, frame = 0
 705              		@ frame_needed = 0, uses_anonymous_args = 0
 706              		@ link register save eliminated.
 707              	.LVL59:
 462:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 463:../drivers/fsl_rtc.c **** 
 464:../drivers/fsl_rtc.c ****     /* RTC_IER */
 465:../drivers/fsl_rtc.c ****     if (RTC_IER_TIIE_MASK == (RTC_IER_TIIE_MASK & base->IER))
 708              		.loc 1 465 0
 709 0000 C369     		ldr	r3, [r0, #28]
 466:../drivers/fsl_rtc.c ****     {
 467:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeInvalidInterruptEnable;
 468:../drivers/fsl_rtc.c ****     }
 469:../drivers/fsl_rtc.c ****     if (RTC_IER_TOIE_MASK == (RTC_IER_TOIE_MASK & base->IER))
 710              		.loc 1 469 0
 711 0002 C269     		ldr	r2, [r0, #28]
 712 0004 9207     		lsls	r2, r2, #30
 470:../drivers/fsl_rtc.c ****     {
 471:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeOverflowInterruptEnable;
 472:../drivers/fsl_rtc.c ****     }
 473:../drivers/fsl_rtc.c ****     if (RTC_IER_TAIE_MASK == (RTC_IER_TAIE_MASK & base->IER))
 713              		.loc 1 473 0
 714 0006 C269     		ldr	r2, [r0, #28]
 715 0008 03F00103 		and	r3, r3, #1
 716              	.LVL60:
 471:../drivers/fsl_rtc.c ****     }
 717              		.loc 1 471 0
 718 000c 48BF     		it	mi
 719 000e 43F00203 		orrmi	r3, r3, #2
 720              	.LVL61:
 721              		.loc 1 473 0
 722 0012 5107     		lsls	r1, r2, #29
 474:../drivers/fsl_rtc.c ****     {
 475:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_AlarmInterruptEnable;
 476:../drivers/fsl_rtc.c ****     }
 477:../drivers/fsl_rtc.c ****     if (RTC_IER_TSIE_MASK == (RTC_IER_TSIE_MASK & base->IER))
 723              		.loc 1 477 0
 724 0014 C269     		ldr	r2, [r0, #28]
 475:../drivers/fsl_rtc.c ****     }
 725              		.loc 1 475 0
 726 0016 48BF     		it	mi
 727 0018 43F00403 		orrmi	r3, r3, #4
 728              	.LVL62:
 729              		.loc 1 477 0
 730 001c D206     		lsls	r2, r2, #27
 478:../drivers/fsl_rtc.c ****     {
 479:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_SecondsInterruptEnable;
 731              		.loc 1 479 0
 732 001e 48BF     		it	mi
 733 0020 43F00803 		orrmi	r3, r3, #8
 734              	.LVL63:
 480:../drivers/fsl_rtc.c ****     }
 481:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 482:../drivers/fsl_rtc.c ****     if (RTC_IER_MOIE_MASK == (RTC_IER_MOIE_MASK & base->IER))
 483:../drivers/fsl_rtc.c ****     {
 484:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_MonotonicOverflowInterruptEnable;
 485:../drivers/fsl_rtc.c ****     }
 486:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 487:../drivers/fsl_rtc.c **** 
 488:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
 489:../drivers/fsl_rtc.c ****     /* RTC_TIR */
 490:../drivers/fsl_rtc.c ****     if (RTC_TIR_TMIE_MASK == (RTC_TIR_TMIE_MASK & base->TIR))
 491:../drivers/fsl_rtc.c ****     {
 492:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TestModeInterruptEnable;
 493:../drivers/fsl_rtc.c ****     }
 494:../drivers/fsl_rtc.c ****     if (RTC_TIR_FSIE_MASK == (RTC_TIR_FSIE_MASK & base->TIR))
 495:../drivers/fsl_rtc.c ****     {
 496:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_FlashSecurityInterruptEnable;
 497:../drivers/fsl_rtc.c ****     }
 498:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
 499:../drivers/fsl_rtc.c ****     if (RTC_TIR_TPIE_MASK == (RTC_TIR_TPIE_MASK & base->TIR))
 500:../drivers/fsl_rtc.c ****     {
 501:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TamperPinInterruptEnable;
 502:../drivers/fsl_rtc.c ****     }
 503:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
 504:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
 505:../drivers/fsl_rtc.c ****     if (RTC_TIR_SIE_MASK == (RTC_TIR_SIE_MASK & base->TIR))
 506:../drivers/fsl_rtc.c ****     {
 507:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_SecurityModuleInterruptEnable;
 508:../drivers/fsl_rtc.c ****     }
 509:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_SIE */
 510:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
 511:../drivers/fsl_rtc.c ****     if (RTC_TIR_LCIE_MASK == (RTC_TIR_LCIE_MASK & base->TIR))
 512:../drivers/fsl_rtc.c ****     {
 513:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_LossOfClockInterruptEnable;
 514:../drivers/fsl_rtc.c ****     }
 515:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
 516:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
 517:../drivers/fsl_rtc.c **** 
 518:../drivers/fsl_rtc.c ****     return tmp32;
 519:../drivers/fsl_rtc.c **** }
 735              		.loc 1 519 0
 736 0024 1846     		mov	r0, r3
 737              	.LVL64:
 738 0026 7047     		bx	lr
 739              		.cfi_endproc
 740              	.LFE164:
 742              		.section	.text.RTC_GetStatusFlags,"ax",%progbits
 743              		.align	1
 744              		.global	RTC_GetStatusFlags
 745              		.syntax unified
 746              		.thumb
 747              		.thumb_func
 748              		.fpu fpv4-sp-d16
 750              	RTC_GetStatusFlags:
 751              	.LFB165:
 520:../drivers/fsl_rtc.c **** 
 521:../drivers/fsl_rtc.c **** uint32_t RTC_GetStatusFlags(RTC_Type *base)
 522:../drivers/fsl_rtc.c **** {
 752              		.loc 1 522 0
 753              		.cfi_startproc
 754              		@ args = 0, pretend = 0, frame = 0
 755              		@ frame_needed = 0, uses_anonymous_args = 0
 756              		@ link register save eliminated.
 757              	.LVL65:
 523:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 524:../drivers/fsl_rtc.c **** 
 525:../drivers/fsl_rtc.c ****     /* RTC_SR */
 526:../drivers/fsl_rtc.c ****     if (RTC_SR_TIF_MASK == (RTC_SR_TIF_MASK & base->SR))
 758              		.loc 1 526 0
 759 0000 4369     		ldr	r3, [r0, #20]
 527:../drivers/fsl_rtc.c ****     {
 528:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeInvalidFlag;
 529:../drivers/fsl_rtc.c ****     }
 530:../drivers/fsl_rtc.c ****     if (RTC_SR_TOF_MASK == (RTC_SR_TOF_MASK & base->SR))
 760              		.loc 1 530 0
 761 0002 4269     		ldr	r2, [r0, #20]
 762 0004 9107     		lsls	r1, r2, #30
 531:../drivers/fsl_rtc.c ****     {
 532:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeOverflowFlag;
 533:../drivers/fsl_rtc.c ****     }
 534:../drivers/fsl_rtc.c ****     if (RTC_SR_TAF_MASK == (RTC_SR_TAF_MASK & base->SR))
 763              		.loc 1 534 0
 764 0006 4269     		ldr	r2, [r0, #20]
 765 0008 03F00103 		and	r3, r3, #1
 766              	.LVL66:
 532:../drivers/fsl_rtc.c ****     }
 767              		.loc 1 532 0
 768 000c 48BF     		it	mi
 769 000e 43F00203 		orrmi	r3, r3, #2
 770              	.LVL67:
 771              		.loc 1 534 0
 772 0012 5207     		lsls	r2, r2, #29
 535:../drivers/fsl_rtc.c ****     {
 536:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_AlarmFlag;
 773              		.loc 1 536 0
 774 0014 48BF     		it	mi
 775 0016 43F00403 		orrmi	r3, r3, #4
 776              	.LVL68:
 537:../drivers/fsl_rtc.c ****     }
 538:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 539:../drivers/fsl_rtc.c ****     if (RTC_SR_MOF_MASK == (RTC_SR_MOF_MASK & base->SR))
 540:../drivers/fsl_rtc.c ****     {
 541:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_MonotonicOverflowFlag;
 542:../drivers/fsl_rtc.c ****     }
 543:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 544:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_SR_TIDF) && FSL_FEATURE_RTC_HAS_SR_TIDF)
 545:../drivers/fsl_rtc.c ****     if (RTC_SR_TIDF_MASK == (RTC_SR_TIDF_MASK & base->SR))
 546:../drivers/fsl_rtc.c ****     {
 547:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TamperInterruptDetectFlag;
 548:../drivers/fsl_rtc.c ****     }
 549:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_SR_TIDF */
 550:../drivers/fsl_rtc.c **** 
 551:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR) && FSL_FEATURE_RTC_HAS_TDR)
 552:../drivers/fsl_rtc.c ****     /* RTC_TDR */
 553:../drivers/fsl_rtc.c ****     if (RTC_TDR_TMF_MASK == (RTC_TDR_TMF_MASK & base->TDR))
 554:../drivers/fsl_rtc.c ****     {
 555:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TestModeFlag;
 556:../drivers/fsl_rtc.c ****     }
 557:../drivers/fsl_rtc.c ****     if (RTC_TDR_FSF_MASK == (RTC_TDR_FSF_MASK & base->TDR))
 558:../drivers/fsl_rtc.c ****     {
 559:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_FlashSecurityFlag;
 560:../drivers/fsl_rtc.c ****     }
 561:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_TPF) && FSL_FEATURE_RTC_HAS_TDR_TPF)
 562:../drivers/fsl_rtc.c ****     if (RTC_TDR_TPF_MASK == (RTC_TDR_TPF_MASK & base->TDR))
 563:../drivers/fsl_rtc.c ****     {
 564:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TamperPinFlag;
 565:../drivers/fsl_rtc.c ****     }
 566:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_TPF */
 567:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_STF) && FSL_FEATURE_RTC_HAS_TDR_STF)
 568:../drivers/fsl_rtc.c ****     if (RTC_TDR_STF_MASK == (RTC_TDR_STF_MASK & base->TDR))
 569:../drivers/fsl_rtc.c ****     {
 570:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_SecurityTamperFlag;
 571:../drivers/fsl_rtc.c ****     }
 572:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_STF */
 573:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_LCTF) && FSL_FEATURE_RTC_HAS_TDR_LCTF)
 574:../drivers/fsl_rtc.c ****     if (RTC_TDR_LCTF_MASK == (RTC_TDR_LCTF_MASK & base->TDR))
 575:../drivers/fsl_rtc.c ****     {
 576:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_LossOfClockTamperFlag;
 577:../drivers/fsl_rtc.c ****     }
 578:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_LCTF */
 579:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR */
 580:../drivers/fsl_rtc.c **** 
 581:../drivers/fsl_rtc.c ****     return tmp32;
 582:../drivers/fsl_rtc.c **** }
 777              		.loc 1 582 0
 778 001a 1846     		mov	r0, r3
 779              	.LVL69:
 780 001c 7047     		bx	lr
 781              		.cfi_endproc
 782              	.LFE165:
 784              		.section	.text.RTC_Init,"ax",%progbits
 785              		.align	1
 786              		.global	RTC_Init
 787              		.syntax unified
 788              		.thumb
 789              		.thumb_func
 790              		.fpu fpv4-sp-d16
 792              	RTC_Init:
 793              	.LFB156:
 213:../drivers/fsl_rtc.c ****     assert(config);
 794              		.loc 1 213 0
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 0
 797              		@ frame_needed = 0, uses_anonymous_args = 0
 798              	.LVL70:
 799              	.LBB6:
 800              	.LBB7:
 801              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 802              		.loc 2 695 0
 803 0000 164A     		ldr	r2, .L95
 804 0002 1368     		ldr	r3, [r2]
 805              	.LBE7:
 806              	.LBE6:
 213:../drivers/fsl_rtc.c ****     assert(config);
 807              		.loc 1 213 0
 808 0004 70B5     		push	{r4, r5, r6, lr}
 809              		.cfi_def_cfa_offset 16
 810              		.cfi_offset 4, -16
 811              		.cfi_offset 5, -12
 812              		.cfi_offset 6, -8
 813              		.cfi_offset 14, -4
 225:../drivers/fsl_rtc.c ****     {
 814              		.loc 1 225 0
 815 0006 164E     		ldr	r6, .L95+4
 816              	.LBB9:
 817              	.LBB8:
 818              		.loc 2 695 0
 819 0008 43F00053 		orr	r3, r3, #536870912
 820 000c 1360     		str	r3, [r2]
 821              	.LVL71:
 822              	.LBE8:
 823              	.LBE9:
 213:../drivers/fsl_rtc.c ****     assert(config);
 824              		.loc 1 213 0
 825 000e 0446     		mov	r4, r0
 225:../drivers/fsl_rtc.c ****     {
 826              		.loc 1 225 0
 827 0010 3046     		mov	r0, r6
 828              	.LVL72:
 213:../drivers/fsl_rtc.c ****     assert(config);
 829              		.loc 1 213 0
 830 0012 0D46     		mov	r5, r1
 225:../drivers/fsl_rtc.c ****     {
 831              		.loc 1 225 0
 832 0014 FFF7FEFF 		bl	RTC_GetStatusFlags
 833              	.LVL73:
 834 0018 C307     		lsls	r3, r0, #31
 835 001a 09D5     		bpl	.L91
 836              	.LVL74:
 837              	.LBB10:
 838              	.LBB11:
 839              		.file 3 "../drivers/fsl_rtc.h"
   1:../drivers/fsl_rtc.h **** /*
   2:../drivers/fsl_rtc.h ****  * The Clear BSD License
   3:../drivers/fsl_rtc.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_rtc.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_rtc.h ****  * All rights reserved.
   6:../drivers/fsl_rtc.h ****  *
   7:../drivers/fsl_rtc.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_rtc.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_rtc.h ****  * that the following conditions are met:
  10:../drivers/fsl_rtc.h ****  *
  11:../drivers/fsl_rtc.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_rtc.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_rtc.h ****  *
  14:../drivers/fsl_rtc.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_rtc.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_rtc.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_rtc.h ****  *
  18:../drivers/fsl_rtc.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_rtc.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_rtc.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_rtc.h ****  *
  22:../drivers/fsl_rtc.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_rtc.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_rtc.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_rtc.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_rtc.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_rtc.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_rtc.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_rtc.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_rtc.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_rtc.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_rtc.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_rtc.h ****  */
  34:../drivers/fsl_rtc.h **** #ifndef _FSL_RTC_H_
  35:../drivers/fsl_rtc.h **** #define _FSL_RTC_H_
  36:../drivers/fsl_rtc.h **** 
  37:../drivers/fsl_rtc.h **** #include "fsl_common.h"
  38:../drivers/fsl_rtc.h **** 
  39:../drivers/fsl_rtc.h **** /*!
  40:../drivers/fsl_rtc.h ****  * @addtogroup rtc
  41:../drivers/fsl_rtc.h ****  * @{
  42:../drivers/fsl_rtc.h ****  */
  43:../drivers/fsl_rtc.h **** 
  44:../drivers/fsl_rtc.h **** /*******************************************************************************
  45:../drivers/fsl_rtc.h ****  * Definitions
  46:../drivers/fsl_rtc.h ****  ******************************************************************************/
  47:../drivers/fsl_rtc.h **** 
  48:../drivers/fsl_rtc.h **** /*! @name Driver version */
  49:../drivers/fsl_rtc.h **** /*@{*/
  50:../drivers/fsl_rtc.h **** #define FSL_RTC_DRIVER_VERSION (MAKE_VERSION(2, 0, 0)) /*!< Version 2.0.0 */
  51:../drivers/fsl_rtc.h **** /*@}*/
  52:../drivers/fsl_rtc.h **** 
  53:../drivers/fsl_rtc.h **** /*! @brief List of RTC interrupts */
  54:../drivers/fsl_rtc.h **** typedef enum _rtc_interrupt_enable
  55:../drivers/fsl_rtc.h **** {
  56:../drivers/fsl_rtc.h ****     kRTC_TimeInvalidInterruptEnable = (1U << 0U),  /*!< Time invalid interrupt.*/
  57:../drivers/fsl_rtc.h ****     kRTC_TimeOverflowInterruptEnable = (1U << 1U), /*!< Time overflow interrupt.*/
  58:../drivers/fsl_rtc.h ****     kRTC_AlarmInterruptEnable = (1U << 2U),        /*!< Alarm interrupt.*/
  59:../drivers/fsl_rtc.h ****     kRTC_SecondsInterruptEnable = (1U << 3U),      /*!< Seconds interrupt.*/
  60:../drivers/fsl_rtc.h **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
  61:../drivers/fsl_rtc.h ****     kRTC_MonotonicOverflowInterruptEnable = (1U << 4U), /*!< Monotonic Overflow Interrupt Enable */
  62:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
  63:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
  64:../drivers/fsl_rtc.h ****     kRTC_TestModeInterruptEnable = (1U << 5U),      /* test mode interrupt */
  65:../drivers/fsl_rtc.h ****     kRTC_FlashSecurityInterruptEnable = (1U << 6U), /* flash security interrupt */
  66:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
  67:../drivers/fsl_rtc.h ****     kRTC_TamperPinInterruptEnable = (1U << 7U),     /* Tamper pin interrupt */
  68:../drivers/fsl_rtc.h **** #endif                                                     /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
  69:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
  70:../drivers/fsl_rtc.h ****     kRTC_SecurityModuleInterruptEnable = (1U << 8U), /* security module interrupt */
  71:../drivers/fsl_rtc.h **** #endif                                                     /* FSL_FEATURE_RTC_HAS_TIR_SIE */
  72:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
  73:../drivers/fsl_rtc.h ****     kRTC_LossOfClockInterruptEnable = (1U << 9U), /* loss of clock interrupt */
  74:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
  75:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
  76:../drivers/fsl_rtc.h **** } rtc_interrupt_enable_t;
  77:../drivers/fsl_rtc.h **** 
  78:../drivers/fsl_rtc.h **** /*! @brief List of RTC flags */
  79:../drivers/fsl_rtc.h **** typedef enum _rtc_status_flags
  80:../drivers/fsl_rtc.h **** {
  81:../drivers/fsl_rtc.h ****     kRTC_TimeInvalidFlag = (1U << 0U),            /*!< Time invalid flag */
  82:../drivers/fsl_rtc.h ****     kRTC_TimeOverflowFlag = (1U << 1U),           /*!< Time overflow flag */
  83:../drivers/fsl_rtc.h ****     kRTC_AlarmFlag = (1U << 2U),                   /*!< Alarm flag*/
  84:../drivers/fsl_rtc.h **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
  85:../drivers/fsl_rtc.h ****     kRTC_MonotonicOverflowFlag = (1U << 3U),       /*!< Monotonic Overflow Flag */
  86:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
  87:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_SR_TIDF) && FSL_FEATURE_RTC_HAS_SR_TIDF)
  88:../drivers/fsl_rtc.h ****     kRTC_TamperInterruptDetectFlag = (1U << 4U), /*!< Tamper interrupt detect flag */
  89:../drivers/fsl_rtc.h **** #endif                                                 /* FSL_FEATURE_RTC_HAS_SR_TIDF */
  90:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR) && FSL_FEATURE_RTC_HAS_TDR)
  91:../drivers/fsl_rtc.h ****     kRTC_TestModeFlag = (1U << 5U),      /* Test mode flag */
  92:../drivers/fsl_rtc.h ****     kRTC_FlashSecurityFlag = (1U << 6U), /* Flash security flag */
  93:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_TPF) && FSL_FEATURE_RTC_HAS_TDR_TPF)
  94:../drivers/fsl_rtc.h ****     kRTC_TamperPinFlag = (1U << 7U),     /* Tamper pin flag */
  95:../drivers/fsl_rtc.h **** #endif                                         /* FSL_FEATURE_RTC_HAS_TDR_TPF */
  96:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_STF) && FSL_FEATURE_RTC_HAS_TDR_STF)
  97:../drivers/fsl_rtc.h ****     kRTC_SecurityTamperFlag = (1U << 8U), /* Security tamper flag */
  98:../drivers/fsl_rtc.h **** #endif                                          /* FSL_FEATURE_RTC_HAS_TDR_STF */
  99:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_LCTF) && FSL_FEATURE_RTC_HAS_TDR_LCTF)
 100:../drivers/fsl_rtc.h ****     kRTC_LossOfClockTamperFlag = (1U << 9U), /* Loss of clock flag */
 101:../drivers/fsl_rtc.h **** #endif                                             /* FSL_FEATURE_RTC_HAS_TDR_LCTF */
 102:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TDR */
 103:../drivers/fsl_rtc.h **** } rtc_status_flags_t;
 104:../drivers/fsl_rtc.h **** 
 105:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_OSC_SCXP) && FSL_FEATURE_RTC_HAS_OSC_SCXP)
 106:../drivers/fsl_rtc.h **** 
 107:../drivers/fsl_rtc.h **** /*! @brief List of RTC Oscillator capacitor load settings */
 108:../drivers/fsl_rtc.h **** typedef enum _rtc_osc_cap_load
 109:../drivers/fsl_rtc.h **** {
 110:../drivers/fsl_rtc.h ****     kRTC_Capacitor_2p = RTC_CR_SC2P_MASK,  /*!< 2 pF capacitor load */
 111:../drivers/fsl_rtc.h ****     kRTC_Capacitor_4p = RTC_CR_SC4P_MASK,  /*!< 4 pF capacitor load */
 112:../drivers/fsl_rtc.h ****     kRTC_Capacitor_8p = RTC_CR_SC8P_MASK,  /*!< 8 pF capacitor load */
 113:../drivers/fsl_rtc.h ****     kRTC_Capacitor_16p = RTC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 114:../drivers/fsl_rtc.h **** } rtc_osc_cap_load_t;
 115:../drivers/fsl_rtc.h **** 
 116:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_SCG_HAS_OSC_SCXP */
 117:../drivers/fsl_rtc.h **** 
 118:../drivers/fsl_rtc.h **** /*! @brief Structure is used to hold the date and time */
 119:../drivers/fsl_rtc.h **** typedef struct _rtc_datetime
 120:../drivers/fsl_rtc.h **** {
 121:../drivers/fsl_rtc.h ****     uint16_t year;  /*!< Range from 1970 to 2099.*/
 122:../drivers/fsl_rtc.h ****     uint8_t month;  /*!< Range from 1 to 12.*/
 123:../drivers/fsl_rtc.h ****     uint8_t day;    /*!< Range from 1 to 31 (depending on month).*/
 124:../drivers/fsl_rtc.h ****     uint8_t hour;   /*!< Range from 0 to 23.*/
 125:../drivers/fsl_rtc.h ****     uint8_t minute; /*!< Range from 0 to 59.*/
 126:../drivers/fsl_rtc.h ****     uint8_t second; /*!< Range from 0 to 59.*/
 127:../drivers/fsl_rtc.h **** } rtc_datetime_t;
 128:../drivers/fsl_rtc.h **** 
 129:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_PCR) && FSL_FEATURE_RTC_HAS_PCR)
 130:../drivers/fsl_rtc.h **** 
 131:../drivers/fsl_rtc.h **** /*!
 132:../drivers/fsl_rtc.h ****  * @brief RTC pin config structure
 133:../drivers/fsl_rtc.h ****  */
 134:../drivers/fsl_rtc.h **** typedef struct _rtc_pin_config
 135:../drivers/fsl_rtc.h **** {
 136:../drivers/fsl_rtc.h ****     bool inputLogic;       /*!< true: Tamper pin input data is logic one.
 137:../drivers/fsl_rtc.h ****                                 false: Tamper pin input data is logic zero. */
 138:../drivers/fsl_rtc.h ****     bool pinActiveLow;     /*!< true: Tamper pin is active low.
 139:../drivers/fsl_rtc.h ****                                 false: Tamper pin is active high. */
 140:../drivers/fsl_rtc.h ****     bool filterEnable;     /*!< true: Input filter is enabled on the tamper pin.
 141:../drivers/fsl_rtc.h ****                                 false: Input filter is disabled on the tamper pin. */
 142:../drivers/fsl_rtc.h ****     bool pullSelectNegate; /*!< true: Tamper pin pull resistor direction will negate the tamper pin
 143:../drivers/fsl_rtc.h ****                                 false: Tamper pin pull resistor direction will assert the tamper pi
 144:../drivers/fsl_rtc.h ****     bool pullEnable;       /*!< true: Pull resistor is enabled on tamper pin.
 145:../drivers/fsl_rtc.h ****                                 false: Pull resistor is disabled on tamper pin. */
 146:../drivers/fsl_rtc.h **** } rtc_pin_config_t;
 147:../drivers/fsl_rtc.h **** 
 148:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_PCR */
 149:../drivers/fsl_rtc.h **** 
 150:../drivers/fsl_rtc.h **** /*!
 151:../drivers/fsl_rtc.h ****  * @brief RTC config structure
 152:../drivers/fsl_rtc.h ****  *
 153:../drivers/fsl_rtc.h ****  * This structure holds the configuration settings for the RTC peripheral. To initialize this
 154:../drivers/fsl_rtc.h ****  * structure to reasonable defaults, call the RTC_GetDefaultConfig() function and pass a
 155:../drivers/fsl_rtc.h ****  * pointer to your config structure instance.
 156:../drivers/fsl_rtc.h ****  *
 157:../drivers/fsl_rtc.h ****  * The config struct can be made const so it resides in flash
 158:../drivers/fsl_rtc.h ****  */
 159:../drivers/fsl_rtc.h **** typedef struct _rtc_config
 160:../drivers/fsl_rtc.h **** {
 161:../drivers/fsl_rtc.h ****     bool wakeupSelect;             /*!< true: Wakeup pin outputs the 32 KHz clock;
 162:../drivers/fsl_rtc.h ****                                         false:Wakeup pin used to wakeup the chip  */
 163:../drivers/fsl_rtc.h ****     bool updateMode;               /*!< true: Registers can be written even when locked under certa
 164:../drivers/fsl_rtc.h ****                                         conditions, false: No writes allowed when registers are loc
 165:../drivers/fsl_rtc.h ****     bool supervisorAccess;         /*!< true: Non-supervisor accesses are allowed;
 166:../drivers/fsl_rtc.h ****                                         false: Non-supervisor accesses are not supported */
 167:../drivers/fsl_rtc.h ****     uint32_t compensationInterval; /*!< Compensation interval that is written to the CIR field in R
 168:../drivers/fsl_rtc.h ****     uint32_t compensationTime;     /*!< Compensation time that is written to the TCR field in RTC T
 169:../drivers/fsl_rtc.h **** } rtc_config_t;
 170:../drivers/fsl_rtc.h **** 
 171:../drivers/fsl_rtc.h **** /*******************************************************************************
 172:../drivers/fsl_rtc.h ****  * API
 173:../drivers/fsl_rtc.h ****  ******************************************************************************/
 174:../drivers/fsl_rtc.h **** 
 175:../drivers/fsl_rtc.h **** #if defined(__cplusplus)
 176:../drivers/fsl_rtc.h **** extern "C" {
 177:../drivers/fsl_rtc.h **** #endif
 178:../drivers/fsl_rtc.h **** 
 179:../drivers/fsl_rtc.h **** /*!
 180:../drivers/fsl_rtc.h ****  * @name Initialization and deinitialization
 181:../drivers/fsl_rtc.h ****  * @{
 182:../drivers/fsl_rtc.h ****  */
 183:../drivers/fsl_rtc.h **** 
 184:../drivers/fsl_rtc.h **** /*!
 185:../drivers/fsl_rtc.h ****  * @brief Ungates the RTC clock and configures the peripheral for basic operation.
 186:../drivers/fsl_rtc.h ****  *
 187:../drivers/fsl_rtc.h ****  * This function issues a software reset if the timer invalid flag is set.
 188:../drivers/fsl_rtc.h ****  *
 189:../drivers/fsl_rtc.h ****  * @note This API should be called at the beginning of the application using the RTC driver.
 190:../drivers/fsl_rtc.h ****  *
 191:../drivers/fsl_rtc.h ****  * @param base   RTC peripheral base address
 192:../drivers/fsl_rtc.h ****  * @param config Pointer to the user's RTC configuration structure.
 193:../drivers/fsl_rtc.h ****  */
 194:../drivers/fsl_rtc.h **** void RTC_Init(RTC_Type *base, const rtc_config_t *config);
 195:../drivers/fsl_rtc.h **** 
 196:../drivers/fsl_rtc.h **** /*!
 197:../drivers/fsl_rtc.h ****  * @brief Stops the timer and gate the RTC clock.
 198:../drivers/fsl_rtc.h ****  *
 199:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 200:../drivers/fsl_rtc.h ****  */
 201:../drivers/fsl_rtc.h **** static inline void RTC_Deinit(RTC_Type *base)
 202:../drivers/fsl_rtc.h **** {
 203:../drivers/fsl_rtc.h ****     /* Stop the RTC timer */
 204:../drivers/fsl_rtc.h ****     base->SR &= ~RTC_SR_TCE_MASK;
 205:../drivers/fsl_rtc.h **** 
 206:../drivers/fsl_rtc.h **** #if defined(RTC_CLOCKS)
 207:../drivers/fsl_rtc.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 208:../drivers/fsl_rtc.h ****     /* Gate the module clock */
 209:../drivers/fsl_rtc.h ****     CLOCK_DisableClock(kCLOCK_Rtc0);
 210:../drivers/fsl_rtc.h **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 211:../drivers/fsl_rtc.h **** #endif /* RTC_CLOCKS */
 212:../drivers/fsl_rtc.h **** }
 213:../drivers/fsl_rtc.h **** 
 214:../drivers/fsl_rtc.h **** /*!
 215:../drivers/fsl_rtc.h ****  * @brief Fills in the RTC config struct with the default settings.
 216:../drivers/fsl_rtc.h ****  *
 217:../drivers/fsl_rtc.h ****  * The default values are as follows.
 218:../drivers/fsl_rtc.h ****  * @code
 219:../drivers/fsl_rtc.h ****  *    config->wakeupSelect = false;
 220:../drivers/fsl_rtc.h ****  *    config->updateMode = false;
 221:../drivers/fsl_rtc.h ****  *    config->supervisorAccess = false;
 222:../drivers/fsl_rtc.h ****  *    config->compensationInterval = 0;
 223:../drivers/fsl_rtc.h ****  *    config->compensationTime = 0;
 224:../drivers/fsl_rtc.h ****  * @endcode
 225:../drivers/fsl_rtc.h ****  * @param config Pointer to the user's RTC configuration structure.
 226:../drivers/fsl_rtc.h ****  */
 227:../drivers/fsl_rtc.h **** void RTC_GetDefaultConfig(rtc_config_t *config);
 228:../drivers/fsl_rtc.h **** 
 229:../drivers/fsl_rtc.h **** /*! @}*/
 230:../drivers/fsl_rtc.h **** 
 231:../drivers/fsl_rtc.h **** /*!
 232:../drivers/fsl_rtc.h ****  * @name Current Time & Alarm
 233:../drivers/fsl_rtc.h ****  * @{
 234:../drivers/fsl_rtc.h ****  */
 235:../drivers/fsl_rtc.h **** 
 236:../drivers/fsl_rtc.h **** /*!
 237:../drivers/fsl_rtc.h ****  * @brief Sets the RTC date and time according to the given time structure.
 238:../drivers/fsl_rtc.h ****  *
 239:../drivers/fsl_rtc.h ****  * The RTC counter must be stopped prior to calling this function because writes to the RTC
 240:../drivers/fsl_rtc.h ****  * seconds register fail if the RTC counter is running.
 241:../drivers/fsl_rtc.h ****  *
 242:../drivers/fsl_rtc.h ****  * @param base     RTC peripheral base address
 243:../drivers/fsl_rtc.h ****  * @param datetime Pointer to the structure where the date and time details are stored.
 244:../drivers/fsl_rtc.h ****  *
 245:../drivers/fsl_rtc.h ****  * @return kStatus_Success: Success in setting the time and starting the RTC
 246:../drivers/fsl_rtc.h ****  *         kStatus_InvalidArgument: Error because the datetime format is incorrect
 247:../drivers/fsl_rtc.h ****  */
 248:../drivers/fsl_rtc.h **** status_t RTC_SetDatetime(RTC_Type *base, const rtc_datetime_t *datetime);
 249:../drivers/fsl_rtc.h **** 
 250:../drivers/fsl_rtc.h **** /*!
 251:../drivers/fsl_rtc.h ****  * @brief Gets the RTC time and stores it in the given time structure.
 252:../drivers/fsl_rtc.h ****  *
 253:../drivers/fsl_rtc.h ****  * @param base     RTC peripheral base address
 254:../drivers/fsl_rtc.h ****  * @param datetime Pointer to the structure where the date and time details are stored.
 255:../drivers/fsl_rtc.h ****  */
 256:../drivers/fsl_rtc.h **** void RTC_GetDatetime(RTC_Type *base, rtc_datetime_t *datetime);
 257:../drivers/fsl_rtc.h **** 
 258:../drivers/fsl_rtc.h **** /*!
 259:../drivers/fsl_rtc.h ****  * @brief Sets the RTC alarm time.
 260:../drivers/fsl_rtc.h ****  *
 261:../drivers/fsl_rtc.h ****  * The function checks whether the specified alarm time is greater than the present
 262:../drivers/fsl_rtc.h ****  * time. If not, the function does not set the alarm and returns an error.
 263:../drivers/fsl_rtc.h ****  *
 264:../drivers/fsl_rtc.h ****  * @param base      RTC peripheral base address
 265:../drivers/fsl_rtc.h ****  * @param alarmTime Pointer to the structure where the alarm time is stored.
 266:../drivers/fsl_rtc.h ****  *
 267:../drivers/fsl_rtc.h ****  * @return kStatus_Success: success in setting the RTC alarm
 268:../drivers/fsl_rtc.h ****  *         kStatus_InvalidArgument: Error because the alarm datetime format is incorrect
 269:../drivers/fsl_rtc.h ****  *         kStatus_Fail: Error because the alarm time has already passed
 270:../drivers/fsl_rtc.h ****  */
 271:../drivers/fsl_rtc.h **** status_t RTC_SetAlarm(RTC_Type *base, const rtc_datetime_t *alarmTime);
 272:../drivers/fsl_rtc.h **** 
 273:../drivers/fsl_rtc.h **** /*!
 274:../drivers/fsl_rtc.h ****  * @brief Returns the RTC alarm time.
 275:../drivers/fsl_rtc.h ****  *
 276:../drivers/fsl_rtc.h ****  * @param base     RTC peripheral base address
 277:../drivers/fsl_rtc.h ****  * @param datetime Pointer to the structure where the alarm date and time details are stored.
 278:../drivers/fsl_rtc.h ****  */
 279:../drivers/fsl_rtc.h **** void RTC_GetAlarm(RTC_Type *base, rtc_datetime_t *datetime);
 280:../drivers/fsl_rtc.h **** 
 281:../drivers/fsl_rtc.h **** /*! @}*/
 282:../drivers/fsl_rtc.h **** 
 283:../drivers/fsl_rtc.h **** /*!
 284:../drivers/fsl_rtc.h ****  * @name Interrupt Interface
 285:../drivers/fsl_rtc.h ****  * @{
 286:../drivers/fsl_rtc.h ****  */
 287:../drivers/fsl_rtc.h **** 
 288:../drivers/fsl_rtc.h **** /*!
 289:../drivers/fsl_rtc.h ****  * @brief Enables the selected RTC interrupts.
 290:../drivers/fsl_rtc.h ****  *
 291:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 292:../drivers/fsl_rtc.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 293:../drivers/fsl_rtc.h ****  *             enumeration ::rtc_interrupt_enable_t
 294:../drivers/fsl_rtc.h ****  */
 295:../drivers/fsl_rtc.h **** void RTC_EnableInterrupts(RTC_Type *base, uint32_t mask);
 296:../drivers/fsl_rtc.h **** 
 297:../drivers/fsl_rtc.h **** /*!
 298:../drivers/fsl_rtc.h ****  * @brief Disables the selected RTC interrupts.
 299:../drivers/fsl_rtc.h ****  *
 300:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 301:../drivers/fsl_rtc.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 302:../drivers/fsl_rtc.h ****  *             enumeration ::rtc_interrupt_enable_t
 303:../drivers/fsl_rtc.h ****  */
 304:../drivers/fsl_rtc.h **** void RTC_DisableInterrupts(RTC_Type *base, uint32_t mask);
 305:../drivers/fsl_rtc.h **** 
 306:../drivers/fsl_rtc.h **** /*!
 307:../drivers/fsl_rtc.h ****  * @brief Gets the enabled RTC interrupts.
 308:../drivers/fsl_rtc.h ****  *
 309:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 310:../drivers/fsl_rtc.h ****  *
 311:../drivers/fsl_rtc.h ****  * @return The enabled interrupts. This is the logical OR of members of the
 312:../drivers/fsl_rtc.h ****  *         enumeration ::rtc_interrupt_enable_t
 313:../drivers/fsl_rtc.h ****  */
 314:../drivers/fsl_rtc.h **** uint32_t RTC_GetEnabledInterrupts(RTC_Type *base);
 315:../drivers/fsl_rtc.h **** 
 316:../drivers/fsl_rtc.h **** /*! @}*/
 317:../drivers/fsl_rtc.h **** 
 318:../drivers/fsl_rtc.h **** /*!
 319:../drivers/fsl_rtc.h ****  * @name Status Interface
 320:../drivers/fsl_rtc.h ****  * @{
 321:../drivers/fsl_rtc.h ****  */
 322:../drivers/fsl_rtc.h **** 
 323:../drivers/fsl_rtc.h **** /*!
 324:../drivers/fsl_rtc.h ****  * @brief Gets the RTC status flags.
 325:../drivers/fsl_rtc.h ****  *
 326:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 327:../drivers/fsl_rtc.h ****  *
 328:../drivers/fsl_rtc.h ****  * @return The status flags. This is the logical OR of members of the
 329:../drivers/fsl_rtc.h ****  *         enumeration ::rtc_status_flags_t
 330:../drivers/fsl_rtc.h ****  */
 331:../drivers/fsl_rtc.h **** uint32_t RTC_GetStatusFlags(RTC_Type *base);
 332:../drivers/fsl_rtc.h **** 
 333:../drivers/fsl_rtc.h **** /*!
 334:../drivers/fsl_rtc.h ****  * @brief  Clears the RTC status flags.
 335:../drivers/fsl_rtc.h ****  *
 336:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 337:../drivers/fsl_rtc.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
 338:../drivers/fsl_rtc.h ****  *             enumeration ::rtc_status_flags_t
 339:../drivers/fsl_rtc.h ****  */
 340:../drivers/fsl_rtc.h **** void RTC_ClearStatusFlags(RTC_Type *base, uint32_t mask);
 341:../drivers/fsl_rtc.h **** 
 342:../drivers/fsl_rtc.h **** /*! @}*/
 343:../drivers/fsl_rtc.h **** 
 344:../drivers/fsl_rtc.h **** /*!
 345:../drivers/fsl_rtc.h ****  * @brief Set RTC clock source.
 346:../drivers/fsl_rtc.h ****  * 
 347:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 348:../drivers/fsl_rtc.h ****  *
 349:../drivers/fsl_rtc.h ****  * @note After setting this bit, wait the oscillator startup time before enabling
 350:../drivers/fsl_rtc.h ****  *       the time counter to allow the 32.768 kHz clock time to stabilize.
 351:../drivers/fsl_rtc.h ****  */
 352:../drivers/fsl_rtc.h **** static inline void RTC_SetClockSource(RTC_Type *base)
 353:../drivers/fsl_rtc.h **** {
 354:../drivers/fsl_rtc.h ****     /* Enable the RTC 32KHz oscillator */
 355:../drivers/fsl_rtc.h ****     base->CR |= RTC_CR_OSCE_MASK;
 356:../drivers/fsl_rtc.h **** }
 357:../drivers/fsl_rtc.h **** 
 358:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TTSR) && FSL_FEATURE_RTC_HAS_TTSR)
 359:../drivers/fsl_rtc.h **** 
 360:../drivers/fsl_rtc.h **** /*!
 361:../drivers/fsl_rtc.h ****  * @brief Get the RTC tamper time seconds.
 362:../drivers/fsl_rtc.h ****  *
 363:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 364:../drivers/fsl_rtc.h ****  */
 365:../drivers/fsl_rtc.h **** static inline uint32_t RTC_GetTamperTimeSeconds(RTC_Type *base)
 366:../drivers/fsl_rtc.h **** {
 367:../drivers/fsl_rtc.h ****     return base->TTSR;
 368:../drivers/fsl_rtc.h **** }
 369:../drivers/fsl_rtc.h **** 
 370:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TTSR */
 371:../drivers/fsl_rtc.h **** 
 372:../drivers/fsl_rtc.h **** /*!
 373:../drivers/fsl_rtc.h ****  * @name Timer Start and Stop
 374:../drivers/fsl_rtc.h ****  * @{
 375:../drivers/fsl_rtc.h ****  */
 376:../drivers/fsl_rtc.h **** 
 377:../drivers/fsl_rtc.h **** /*!
 378:../drivers/fsl_rtc.h ****  * @brief Starts the RTC time counter.
 379:../drivers/fsl_rtc.h ****  *
 380:../drivers/fsl_rtc.h ****  * After calling this function, the timer counter increments once a second provided SR[TOF] or
 381:../drivers/fsl_rtc.h ****  * SR[TIF] are not set.
 382:../drivers/fsl_rtc.h ****  *
 383:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 384:../drivers/fsl_rtc.h ****  */
 385:../drivers/fsl_rtc.h **** static inline void RTC_StartTimer(RTC_Type *base)
 386:../drivers/fsl_rtc.h **** {
 387:../drivers/fsl_rtc.h ****     base->SR |= RTC_SR_TCE_MASK;
 388:../drivers/fsl_rtc.h **** }
 389:../drivers/fsl_rtc.h **** 
 390:../drivers/fsl_rtc.h **** /*!
 391:../drivers/fsl_rtc.h ****  * @brief Stops the RTC time counter.
 392:../drivers/fsl_rtc.h ****  *
 393:../drivers/fsl_rtc.h ****  * RTC's seconds register can be written to only when the timer is stopped.
 394:../drivers/fsl_rtc.h ****  *
 395:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 396:../drivers/fsl_rtc.h ****  */
 397:../drivers/fsl_rtc.h **** static inline void RTC_StopTimer(RTC_Type *base)
 398:../drivers/fsl_rtc.h **** {
 399:../drivers/fsl_rtc.h ****     base->SR &= ~RTC_SR_TCE_MASK;
 400:../drivers/fsl_rtc.h **** }
 401:../drivers/fsl_rtc.h **** 
 402:../drivers/fsl_rtc.h **** /*! @}*/
 403:../drivers/fsl_rtc.h **** 
 404:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_OSC_SCXP) && FSL_FEATURE_RTC_HAS_OSC_SCXP)
 405:../drivers/fsl_rtc.h **** 
 406:../drivers/fsl_rtc.h **** /*!
 407:../drivers/fsl_rtc.h ****  * @brief This function sets the specified capacitor configuration for the RTC oscillator.
 408:../drivers/fsl_rtc.h ****  *
 409:../drivers/fsl_rtc.h ****  * @param base    RTC peripheral base address
 410:../drivers/fsl_rtc.h ****  * @param capLoad Oscillator loads to enable. This is a logical OR of members of the
 411:../drivers/fsl_rtc.h ****  *                enumeration ::rtc_osc_cap_load_t
 412:../drivers/fsl_rtc.h ****  */
 413:../drivers/fsl_rtc.h **** static inline void RTC_SetOscCapLoad(RTC_Type *base, uint32_t capLoad)
 414:../drivers/fsl_rtc.h **** {
 415:../drivers/fsl_rtc.h ****     uint32_t reg = base->CR;
 416:../drivers/fsl_rtc.h **** 
 417:../drivers/fsl_rtc.h ****     reg &= ~(RTC_CR_SC2P_MASK | RTC_CR_SC4P_MASK | RTC_CR_SC8P_MASK | RTC_CR_SC16P_MASK);
 418:../drivers/fsl_rtc.h ****     reg |= capLoad;
 419:../drivers/fsl_rtc.h **** 
 420:../drivers/fsl_rtc.h ****     base->CR = reg;
 421:../drivers/fsl_rtc.h **** }
 422:../drivers/fsl_rtc.h **** 
 423:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_SCG_HAS_OSC_SCXP */
 424:../drivers/fsl_rtc.h **** 
 425:../drivers/fsl_rtc.h **** /*!
 426:../drivers/fsl_rtc.h ****  * @brief Performs a software reset on the RTC module.
 427:../drivers/fsl_rtc.h ****  *
 428:../drivers/fsl_rtc.h ****  * This resets all RTC registers except for the SWR bit and the RTC_WAR and RTC_RAR
 429:../drivers/fsl_rtc.h ****  * registers. The SWR bit is cleared by software explicitly clearing it.
 430:../drivers/fsl_rtc.h ****  *
 431:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 432:../drivers/fsl_rtc.h ****  */
 433:../drivers/fsl_rtc.h **** static inline void RTC_Reset(RTC_Type *base)
 434:../drivers/fsl_rtc.h **** {
 435:../drivers/fsl_rtc.h ****     base->CR |= RTC_CR_SWR_MASK;
 840              		.loc 3 435 0
 841 001c 3369     		ldr	r3, [r6, #16]
 842 001e 43F00103 		orr	r3, r3, #1
 843 0022 3361     		str	r3, [r6, #16]
 436:../drivers/fsl_rtc.h ****     base->CR &= ~RTC_CR_SWR_MASK;
 844              		.loc 3 436 0
 845 0024 3369     		ldr	r3, [r6, #16]
 846 0026 23F00103 		bic	r3, r3, #1
 847 002a 3361     		str	r3, [r6, #16]
 437:../drivers/fsl_rtc.h **** 
 438:../drivers/fsl_rtc.h ****     /* Set TSR register to 0x1 to avoid the timer invalid (TIF) bit being set in the SR register */
 439:../drivers/fsl_rtc.h ****     base->TSR = 1U;
 848              		.loc 3 439 0
 849 002c 0123     		movs	r3, #1
 850 002e 3360     		str	r3, [r6]
 851              	.LVL75:
 852              	.L91:
 853              	.LBE11:
 854              	.LBE10:
 230:../drivers/fsl_rtc.c ****     /* Setup the update mode and supervisor access mode */
 855              		.loc 1 230 0
 856 0030 2369     		ldr	r3, [r4, #16]
 857              	.LVL76:
 233:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION) && FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION
 858              		.loc 1 233 0
 859 0032 6A78     		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 232:../drivers/fsl_rtc.c ****     reg |= RTC_CR_UM(config->updateMode) | RTC_CR_SUP(config->supervisorAccess);
 860              		.loc 1 232 0
 861 0034 23F00C03 		bic	r3, r3, #12
 862              	.LVL77:
 863 0038 43EAC203 		orr	r3, r3, r2, lsl #3
 864              	.LVL78:
 233:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION) && FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION
 865              		.loc 1 233 0
 866 003c AA78     		ldrb	r2, [r5, #2]	@ zero_extendqisi2
 867 003e 43EA8203 		orr	r3, r3, r2, lsl #2
 868              	.LVL79:
 237:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_WAKEUP_PIN */
 869              		.loc 1 237 0
 870 0042 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 236:../drivers/fsl_rtc.c ****     reg |= RTC_CR_WPS(config->wakeupSelect);
 871              		.loc 1 236 0
 872 0044 23F01003 		bic	r3, r3, #16
 873              	.LVL80:
 237:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_WAKEUP_PIN */
 874              		.loc 1 237 0
 875 0048 43EA0213 		orr	r3, r3, r2, lsl #4
 876              	.LVL81:
 239:../drivers/fsl_rtc.c **** 
 877              		.loc 1 239 0
 878 004c 2361     		str	r3, [r4, #16]
 242:../drivers/fsl_rtc.c **** 	
 879              		.loc 1 242 0
 880 004e 6B68     		ldr	r3, [r5, #4]
 881              	.LVL82:
 882 0050 2A7A     		ldrb	r2, [r5, #8]	@ zero_extendqisi2
 883 0052 1B02     		lsls	r3, r3, #8
 884 0054 9BB2     		uxth	r3, r3
 885 0056 1343     		orrs	r3, r3, r2
 886 0058 E360     		str	r3, [r4, #12]
 887              	.LVL83:
 248:../drivers/fsl_rtc.c **** 
 888              		.loc 1 248 0
 889 005a 70BD     		pop	{r4, r5, r6, pc}
 890              	.LVL84:
 891              	.L96:
 892              		.align	2
 893              	.L95:
 894 005c 3C800440 		.word	1074036796
 895 0060 00D00340 		.word	1073991680
 896              		.cfi_endproc
 897              	.LFE156:
 899              		.section	.text.RTC_ClearStatusFlags,"ax",%progbits
 900              		.align	1
 901              		.global	RTC_ClearStatusFlags
 902              		.syntax unified
 903              		.thumb
 904              		.thumb_func
 905              		.fpu fpv4-sp-d16
 907              	RTC_ClearStatusFlags:
 908              	.LFB166:
 583:../drivers/fsl_rtc.c **** 
 584:../drivers/fsl_rtc.c **** void RTC_ClearStatusFlags(RTC_Type *base, uint32_t mask)
 585:../drivers/fsl_rtc.c **** {
 909              		.loc 1 585 0
 910              		.cfi_startproc
 911              		@ args = 0, pretend = 0, frame = 0
 912              		@ frame_needed = 0, uses_anonymous_args = 0
 913              		@ link register save eliminated.
 914              	.LVL85:
 586:../drivers/fsl_rtc.c ****     /* The alarm flag is cleared by writing to the TAR register */
 587:../drivers/fsl_rtc.c ****     if (mask & kRTC_AlarmFlag)
 915              		.loc 1 587 0
 916 0000 4B07     		lsls	r3, r1, #29
 588:../drivers/fsl_rtc.c ****     {
 589:../drivers/fsl_rtc.c ****         base->TAR = 0U;
 917              		.loc 1 589 0
 918 0002 44BF     		itt	mi
 919 0004 0023     		movmi	r3, #0
 920 0006 8360     		strmi	r3, [r0, #8]
 590:../drivers/fsl_rtc.c ****     }
 591:../drivers/fsl_rtc.c **** 
 592:../drivers/fsl_rtc.c ****     /* The timer overflow flag is cleared by initializing the TSR register.
 593:../drivers/fsl_rtc.c ****      * The time counter should be disabled for this write to be successful
 594:../drivers/fsl_rtc.c ****      */
 595:../drivers/fsl_rtc.c ****     if (mask & kRTC_TimeOverflowFlag)
 921              		.loc 1 595 0
 922 0008 8A07     		lsls	r2, r1, #30
 596:../drivers/fsl_rtc.c ****     {
 597:../drivers/fsl_rtc.c ****         base->TSR = 1U;
 923              		.loc 1 597 0
 924 000a 44BF     		itt	mi
 925 000c 0123     		movmi	r3, #1
 926 000e 0360     		strmi	r3, [r0]
 598:../drivers/fsl_rtc.c ****     }
 599:../drivers/fsl_rtc.c **** 
 600:../drivers/fsl_rtc.c ****     /* The timer overflow flag is cleared by initializing the TSR register.
 601:../drivers/fsl_rtc.c ****      * The time counter should be disabled for this write to be successful
 602:../drivers/fsl_rtc.c ****      */
 603:../drivers/fsl_rtc.c ****     if (mask & kRTC_TimeInvalidFlag)
 927              		.loc 1 603 0
 928 0010 CB07     		lsls	r3, r1, #31
 604:../drivers/fsl_rtc.c ****     {
 605:../drivers/fsl_rtc.c ****         base->TSR = 1U;
 929              		.loc 1 605 0
 930 0012 44BF     		itt	mi
 931 0014 0123     		movmi	r3, #1
 932 0016 0360     		strmi	r3, [r0]
 606:../drivers/fsl_rtc.c ****     }
 607:../drivers/fsl_rtc.c **** 
 608:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR) && FSL_FEATURE_RTC_HAS_TDR)
 609:../drivers/fsl_rtc.c ****     /* To clear, write logic one to this flag after exiting from all test modes */
 610:../drivers/fsl_rtc.c ****     if (kRTC_TestModeFlag == (kRTC_TestModeFlag & mask))
 611:../drivers/fsl_rtc.c ****     {
 612:../drivers/fsl_rtc.c ****         base->TDR = RTC_TDR_TMF_MASK;
 613:../drivers/fsl_rtc.c ****     }
 614:../drivers/fsl_rtc.c ****     /* To clear, write logic one to this flag after flash security is enabled */
 615:../drivers/fsl_rtc.c ****     if (kRTC_FlashSecurityFlag == (kRTC_FlashSecurityFlag & mask))
 616:../drivers/fsl_rtc.c ****     {
 617:../drivers/fsl_rtc.c ****         base->TDR = RTC_TDR_FSF_MASK;
 618:../drivers/fsl_rtc.c ****     }
 619:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_TPF) && FSL_FEATURE_RTC_HAS_TDR_TPF)
 620:../drivers/fsl_rtc.c ****     /* To clear, write logic one to the corresponding flag after that tamper pin negates */
 621:../drivers/fsl_rtc.c ****     if (kRTC_TamperPinFlag == (kRTC_TamperPinFlag & mask))
 622:../drivers/fsl_rtc.c ****     {
 623:../drivers/fsl_rtc.c ****         base->TDR = RTC_TDR_TPF_MASK;
 624:../drivers/fsl_rtc.c ****     }
 625:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_TPF */
 626:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_STF) && FSL_FEATURE_RTC_HAS_TDR_STF)
 627:../drivers/fsl_rtc.c ****     /* To clear, write logic one to this flag after security module has negated its tamper detect *
 628:../drivers/fsl_rtc.c ****     if (kRTC_SecurityTamperFlag == (kRTC_SecurityTamperFlag & mask))
 629:../drivers/fsl_rtc.c ****     {
 630:../drivers/fsl_rtc.c ****         base->TDR = RTC_TDR_STF_MASK;
 631:../drivers/fsl_rtc.c ****     }
 632:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_STF */
 633:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_LCTF) && FSL_FEATURE_RTC_HAS_TDR_LCTF)
 634:../drivers/fsl_rtc.c ****     /* To clear, write logic one to this flag after loss of clock negates */
 635:../drivers/fsl_rtc.c ****     if (kRTC_LossOfClockTamperFlag == (kRTC_LossOfClockTamperFlag & mask))
 636:../drivers/fsl_rtc.c ****     {
 637:../drivers/fsl_rtc.c ****         base->TDR = RTC_TDR_LCTF_MASK;
 638:../drivers/fsl_rtc.c ****     }
 639:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_LCTF */
 640:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR */
 641:../drivers/fsl_rtc.c **** }
 933              		.loc 1 641 0
 934 0018 7047     		bx	lr
 935              		.cfi_endproc
 936              	.LFE166:
 938              		.section	.rodata
 939              		.align	1
 940              		.set	.LANCHOR0,. + 0
 941              	.LC0:
 942 0000 00       		.byte	0
 943 0001 1F       		.byte	31
 944 0002 1C       		.byte	28
 945 0003 1F       		.byte	31
 946 0004 1E       		.byte	30
 947 0005 1F       		.byte	31
 948 0006 1E       		.byte	30
 949 0007 1F       		.byte	31
 950 0008 1F       		.byte	31
 951 0009 1E       		.byte	30
 952 000a 1F       		.byte	31
 953 000b 1E       		.byte	30
 954 000c 1F       		.byte	31
 955 000d 00       		.space	1
 956              	.LC1:
 957 000e 0000     		.short	0
 958 0010 0000     		.short	0
 959 0012 1F00     		.short	31
 960 0014 3B00     		.short	59
 961 0016 5A00     		.short	90
 962 0018 7800     		.short	120
 963 001a 9700     		.short	151
 964 001c B500     		.short	181
 965 001e D400     		.short	212
 966 0020 F300     		.short	243
 967 0022 1101     		.short	273
 968 0024 3001     		.short	304
 969 0026 4E01     		.short	334
 970              		.text
 971              	.Letext0:
 972              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 973              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 974              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 975              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 976              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 977              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 978              		.file 10 "../CMSIS/core_cm4.h"
 979              		.file 11 "../CMSIS/system_MK64F12.h"
 980              		.file 12 "../CMSIS/MK64F12.h"
 981              		.file 13 "../drivers/fsl_common.h"
