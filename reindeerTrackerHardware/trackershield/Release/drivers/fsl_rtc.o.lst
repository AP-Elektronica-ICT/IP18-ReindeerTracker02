   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_rtc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.RTC_CheckDatetimeFormat,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	RTC_CheckDatetimeFormat:
  25              	.LFB153:
  26              		.file 1 "../drivers/fsl_rtc.c"
   1:../drivers/fsl_rtc.c **** /*
   2:../drivers/fsl_rtc.c ****  * The Clear BSD License
   3:../drivers/fsl_rtc.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_rtc.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_rtc.c ****  * All rights reserved.
   6:../drivers/fsl_rtc.c ****  *
   7:../drivers/fsl_rtc.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_rtc.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_rtc.c ****  * that the following conditions are met:
  10:../drivers/fsl_rtc.c ****  *
  11:../drivers/fsl_rtc.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_rtc.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_rtc.c ****  *
  14:../drivers/fsl_rtc.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_rtc.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_rtc.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_rtc.c ****  *
  18:../drivers/fsl_rtc.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_rtc.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_rtc.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_rtc.c ****  *
  22:../drivers/fsl_rtc.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_rtc.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_rtc.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_rtc.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_rtc.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_rtc.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_rtc.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_rtc.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_rtc.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_rtc.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_rtc.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_rtc.c ****  */
  34:../drivers/fsl_rtc.c **** 
  35:../drivers/fsl_rtc.c **** #include "fsl_rtc.h"
  36:../drivers/fsl_rtc.c **** 
  37:../drivers/fsl_rtc.c **** /*******************************************************************************
  38:../drivers/fsl_rtc.c ****  * Definitions
  39:../drivers/fsl_rtc.c ****  ******************************************************************************/
  40:../drivers/fsl_rtc.c **** #define SECONDS_IN_A_DAY (86400U)
  41:../drivers/fsl_rtc.c **** #define SECONDS_IN_A_HOUR (3600U)
  42:../drivers/fsl_rtc.c **** #define SECONDS_IN_A_MINUTE (60U)
  43:../drivers/fsl_rtc.c **** #define DAYS_IN_A_YEAR (365U)
  44:../drivers/fsl_rtc.c **** #define YEAR_RANGE_START (1970U)
  45:../drivers/fsl_rtc.c **** #define YEAR_RANGE_END (2099U)
  46:../drivers/fsl_rtc.c **** 
  47:../drivers/fsl_rtc.c **** /*******************************************************************************
  48:../drivers/fsl_rtc.c ****  * Prototypes
  49:../drivers/fsl_rtc.c ****  ******************************************************************************/
  50:../drivers/fsl_rtc.c **** /*!
  51:../drivers/fsl_rtc.c ****  * @brief Checks whether the date and time passed in is valid
  52:../drivers/fsl_rtc.c ****  *
  53:../drivers/fsl_rtc.c ****  * @param datetime Pointer to structure where the date and time details are stored
  54:../drivers/fsl_rtc.c ****  *
  55:../drivers/fsl_rtc.c ****  * @return Returns false if the date & time details are out of range; true if in range
  56:../drivers/fsl_rtc.c ****  */
  57:../drivers/fsl_rtc.c **** static bool RTC_CheckDatetimeFormat(const rtc_datetime_t *datetime);
  58:../drivers/fsl_rtc.c **** 
  59:../drivers/fsl_rtc.c **** /*!
  60:../drivers/fsl_rtc.c ****  * @brief Converts time data from datetime to seconds
  61:../drivers/fsl_rtc.c ****  *
  62:../drivers/fsl_rtc.c ****  * @param datetime Pointer to datetime structure where the date and time details are stored
  63:../drivers/fsl_rtc.c ****  *
  64:../drivers/fsl_rtc.c ****  * @return The result of the conversion in seconds
  65:../drivers/fsl_rtc.c ****  */
  66:../drivers/fsl_rtc.c **** static uint32_t RTC_ConvertDatetimeToSeconds(const rtc_datetime_t *datetime);
  67:../drivers/fsl_rtc.c **** 
  68:../drivers/fsl_rtc.c **** /*!
  69:../drivers/fsl_rtc.c ****  * @brief Converts time data from seconds to a datetime structure
  70:../drivers/fsl_rtc.c ****  *
  71:../drivers/fsl_rtc.c ****  * @param seconds  Seconds value that needs to be converted to datetime format
  72:../drivers/fsl_rtc.c ****  * @param datetime Pointer to the datetime structure where the result of the conversion is stored
  73:../drivers/fsl_rtc.c ****  */
  74:../drivers/fsl_rtc.c **** static void RTC_ConvertSecondsToDatetime(uint32_t seconds, rtc_datetime_t *datetime);
  75:../drivers/fsl_rtc.c **** 
  76:../drivers/fsl_rtc.c **** /*******************************************************************************
  77:../drivers/fsl_rtc.c ****  * Code
  78:../drivers/fsl_rtc.c ****  ******************************************************************************/
  79:../drivers/fsl_rtc.c **** static bool RTC_CheckDatetimeFormat(const rtc_datetime_t *datetime)
  80:../drivers/fsl_rtc.c **** {
  27              		.loc 1 80 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
  33              		.cfi_def_cfa_offset 32
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
  81:../drivers/fsl_rtc.c ****     assert(datetime);
  82:../drivers/fsl_rtc.c **** 
  83:../drivers/fsl_rtc.c ****     /* Table of days in a month for a non leap year. First entry in the table is not used,
  84:../drivers/fsl_rtc.c ****      * valid months start from 1
  85:../drivers/fsl_rtc.c ****      */
  86:../drivers/fsl_rtc.c ****     uint8_t daysPerMonth[] = {0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U};
  38              		.loc 1 86 0
  39 0002 224B     		ldr	r3, .L10
  80:../drivers/fsl_rtc.c ****     assert(datetime);
  40              		.loc 1 80 0
  41 0004 0246     		mov	r2, r0
  42              		.loc 1 86 0
  43 0006 6C46     		mov	r4, sp
  44 0008 03F10806 		add	r6, r3, #8
  45              	.LVL1:
  46              	.L2:
  47 000c 1868     		ldr	r0, [r3]	@ unaligned
  48 000e 5968     		ldr	r1, [r3, #4]	@ unaligned
  49 0010 2546     		mov	r5, r4
  50 0012 03C5     		stmia	r5!, {r0, r1}
  51 0014 0833     		adds	r3, r3, #8
  52 0016 B342     		cmp	r3, r6
  53 0018 2C46     		mov	r4, r5
  54 001a F7D1     		bne	.L2
  55 001c 1868     		ldr	r0, [r3]	@ unaligned
  56 001e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
  57 0020 2860     		str	r0, [r5]
  58 0022 2B71     		strb	r3, [r5, #4]
  87:../drivers/fsl_rtc.c **** 
  88:../drivers/fsl_rtc.c ****     /* Check year, month, hour, minute, seconds */
  89:../drivers/fsl_rtc.c ****     if ((datetime->year < YEAR_RANGE_START) || (datetime->year > YEAR_RANGE_END) || (datetime->mont
  59              		.loc 1 89 0
  60 0024 1388     		ldrh	r3, [r2]
  61 0026 A3F2B271 		subw	r1, r3, #1970
  62 002a 8129     		cmp	r1, #129
  63 002c 02D9     		bls	.L3
  64              	.L5:
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  91:../drivers/fsl_rtc.c ****     {
  92:../drivers/fsl_rtc.c ****         /* If not correct then error*/
  93:../drivers/fsl_rtc.c ****         return false;
  65              		.loc 1 93 0
  66 002e 0020     		movs	r0, #0
  67              	.L4:
  94:../drivers/fsl_rtc.c ****     }
  95:../drivers/fsl_rtc.c **** 
  96:../drivers/fsl_rtc.c ****     /* Adjust the days in February for a leap year */
  97:../drivers/fsl_rtc.c ****     if ((((datetime->year & 3U) == 0) && (datetime->year % 100 != 0)) || (datetime->year % 400 == 0
  98:../drivers/fsl_rtc.c ****     {
  99:../drivers/fsl_rtc.c ****         daysPerMonth[2] = 29U;
 100:../drivers/fsl_rtc.c ****     }
 101:../drivers/fsl_rtc.c **** 
 102:../drivers/fsl_rtc.c ****     /* Check the validity of the day */
 103:../drivers/fsl_rtc.c ****     if ((datetime->day > daysPerMonth[datetime->month]) || (datetime->day < 1U))
 104:../drivers/fsl_rtc.c ****     {
 105:../drivers/fsl_rtc.c ****         return false;
 106:../drivers/fsl_rtc.c ****     }
 107:../drivers/fsl_rtc.c **** 
 108:../drivers/fsl_rtc.c ****     return true;
 109:../drivers/fsl_rtc.c **** }
  68              		.loc 1 109 0
  69 0030 04B0     		add	sp, sp, #16
  70              		.cfi_remember_state
  71              		.cfi_def_cfa_offset 16
  72              		@ sp needed
  73 0032 70BD     		pop	{r4, r5, r6, pc}
  74              	.L3:
  75              		.cfi_restore_state
  89:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  76              		.loc 1 89 0 discriminator 1
  77 0034 9478     		ldrb	r4, [r2, #2]	@ zero_extendqisi2
  78 0036 611E     		subs	r1, r4, #1
  79 0038 0B29     		cmp	r1, #11
  80 003a F8D8     		bhi	.L5
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  81              		.loc 1 90 0
  82 003c 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
  83 003e 1729     		cmp	r1, #23
  84 0040 F5D8     		bhi	.L5
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  85              		.loc 1 90 0 is_stmt 0 discriminator 1
  86 0042 5179     		ldrb	r1, [r2, #5]	@ zero_extendqisi2
  87 0044 3B29     		cmp	r1, #59
  88 0046 F2D8     		bhi	.L5
  90:../drivers/fsl_rtc.c ****         (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime
  89              		.loc 1 90 0 discriminator 2
  90 0048 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
  91 004a 3B29     		cmp	r1, #59
  92 004c EFD8     		bhi	.L5
  97:../drivers/fsl_rtc.c ****     {
  93              		.loc 1 97 0 is_stmt 1
  94 004e 9907     		lsls	r1, r3, #30
  95 0050 06D1     		bne	.L6
  97:../drivers/fsl_rtc.c ****     {
  96              		.loc 1 97 0 is_stmt 0 discriminator 1
  97 0052 6420     		movs	r0, #100
  98 0054 B3FBF0F1 		udiv	r1, r3, r0
  99 0058 00FB1131 		mls	r1, r0, r1, r3
 100 005c 89B2     		uxth	r1, r1
 101 005e 39B9     		cbnz	r1, .L7
 102              	.L6:
  97:../drivers/fsl_rtc.c ****     {
 103              		.loc 1 97 0 discriminator 3
 104 0060 4FF4C870 		mov	r0, #400
 105 0064 B3FBF0F1 		udiv	r1, r3, r0
 106 0068 00FB1133 		mls	r3, r0, r1, r3
 107 006c 9BB2     		uxth	r3, r3
 108 006e 13B9     		cbnz	r3, .L8
 109              	.L7:
  99:../drivers/fsl_rtc.c ****     }
 110              		.loc 1 99 0 is_stmt 1
 111 0070 1D23     		movs	r3, #29
 112 0072 8DF80230 		strb	r3, [sp, #2]
 113              	.L8:
 103:../drivers/fsl_rtc.c ****     {
 114              		.loc 1 103 0
 115 0076 04AB     		add	r3, sp, #16
 116 0078 1C44     		add	r4, r4, r3
 117 007a D078     		ldrb	r0, [r2, #3]	@ zero_extendqisi2
 118 007c 14F8103C 		ldrb	r3, [r4, #-16]	@ zero_extendqisi2
 119 0080 8342     		cmp	r3, r0
 120 0082 D4D3     		bcc	.L5
 103:../drivers/fsl_rtc.c ****     {
 121              		.loc 1 103 0 is_stmt 0 discriminator 1
 122 0084 0030     		adds	r0, r0, #0
 123 0086 18BF     		it	ne
 124 0088 0120     		movne	r0, #1
 125 008a D1E7     		b	.L4
 126              	.L11:
 127              		.align	2
 128              	.L10:
 129 008c 00000000 		.word	.LANCHOR0
 130              		.cfi_endproc
 131              	.LFE153:
 133              		.section	.text.RTC_ConvertDatetimeToSeconds,"ax",%progbits
 134              		.align	1
 135              		.syntax unified
 136              		.thumb
 137              		.thumb_func
 138              		.fpu fpv4-sp-d16
 140              	RTC_ConvertDatetimeToSeconds:
 141              	.LFB154:
 110:../drivers/fsl_rtc.c **** 
 111:../drivers/fsl_rtc.c **** static uint32_t RTC_ConvertDatetimeToSeconds(const rtc_datetime_t *datetime)
 112:../drivers/fsl_rtc.c **** {
 142              		.loc 1 112 0 is_stmt 1
 143              		.cfi_startproc
 144              		@ args = 0, pretend = 0, frame = 32
 145              		@ frame_needed = 0, uses_anonymous_args = 0
 146              	.LVL2:
 147 0000 70B5     		push	{r4, r5, r6, lr}
 148              		.cfi_def_cfa_offset 16
 149              		.cfi_offset 4, -16
 150              		.cfi_offset 5, -12
 151              		.cfi_offset 6, -8
 152              		.cfi_offset 14, -4
 113:../drivers/fsl_rtc.c ****     assert(datetime);
 114:../drivers/fsl_rtc.c **** 
 115:../drivers/fsl_rtc.c ****     /* Number of days from begin of the non Leap-year*/
 116:../drivers/fsl_rtc.c ****     /* Number of days from begin of the non Leap-year*/
 117:../drivers/fsl_rtc.c ****     uint16_t monthDays[] = {0U, 0U, 31U, 59U, 90U, 120U, 151U, 181U, 212U, 243U, 273U, 304U, 334U};
 153              		.loc 1 117 0
 154 0002 1D4B     		ldr	r3, .L16
 112:../drivers/fsl_rtc.c ****     assert(datetime);
 155              		.loc 1 112 0
 156 0004 88B0     		sub	sp, sp, #32
 157              		.cfi_def_cfa_offset 48
 112:../drivers/fsl_rtc.c ****     assert(datetime);
 158              		.loc 1 112 0
 159 0006 0246     		mov	r2, r0
 160              		.loc 1 117 0
 161 0008 01AC     		add	r4, sp, #4
 162 000a 03F11806 		add	r6, r3, #24
 163              	.LVL3:
 164              	.L13:
 165 000e 1868     		ldr	r0, [r3]	@ unaligned
 166 0010 5968     		ldr	r1, [r3, #4]	@ unaligned
 167 0012 2546     		mov	r5, r4
 168 0014 03C5     		stmia	r5!, {r0, r1}
 169 0016 0833     		adds	r3, r3, #8
 170 0018 B342     		cmp	r3, r6
 171 001a 2C46     		mov	r4, r5
 172 001c F7D1     		bne	.L13
 173 001e 1B88     		ldrh	r3, [r3]	@ unaligned
 174 0020 2B80     		strh	r3, [r5]	@ unaligned
 118:../drivers/fsl_rtc.c ****     uint32_t seconds;
 119:../drivers/fsl_rtc.c **** 
 120:../drivers/fsl_rtc.c ****     /* Compute number of days from 1970 till given year*/
 121:../drivers/fsl_rtc.c ****     seconds = (datetime->year - 1970U) * DAYS_IN_A_YEAR;
 122:../drivers/fsl_rtc.c ****     /* Add leap year days */
 123:../drivers/fsl_rtc.c ****     seconds += ((datetime->year / 4) - (1970U / 4));
 124:../drivers/fsl_rtc.c ****     /* Add number of days till given month*/
 125:../drivers/fsl_rtc.c ****     seconds += monthDays[datetime->month];
 126:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 127:../drivers/fsl_rtc.c ****      * represented in the hours, minutes and seconds field*/
 128:../drivers/fsl_rtc.c ****     seconds += (datetime->day - 1);
 175              		.loc 1 128 0
 176 0022 D378     		ldrb	r3, [r2, #3]	@ zero_extendqisi2
 121:../drivers/fsl_rtc.c ****     /* Add leap year days */
 177              		.loc 1 121 0
 178 0024 1488     		ldrh	r4, [r2]
 179              	.LVL4:
 125:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 180              		.loc 1 125 0
 181 0026 9078     		ldrb	r0, [r2, #2]	@ zero_extendqisi2
 182              	.LVL5:
 183              		.loc 1 128 0
 184 0028 A3F52F21 		sub	r1, r3, #716800
 185 002c A1F6B621 		subw	r1, r1, #2742
 186 0030 40F26D13 		movw	r3, #365
 187 0034 03FB0413 		mla	r3, r3, r4, r1
 125:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 188              		.loc 1 125 0
 189 0038 08A9     		add	r1, sp, #32
 190 003a 01EB4001 		add	r1, r1, r0, lsl #1
 191              		.loc 1 128 0
 192 003e 03EB9403 		add	r3, r3, r4, lsr #2
 125:../drivers/fsl_rtc.c ****     /* Add days in given month. We subtract the current day as it is
 193              		.loc 1 125 0
 194 0042 31F81C1C 		ldrh	r1, [r1, #-28]
 195              		.loc 1 128 0
 196 0046 0B44     		add	r3, r3, r1
 129:../drivers/fsl_rtc.c ****     /* For leap year if month less than or equal to Febraury, decrement day counter*/
 130:../drivers/fsl_rtc.c ****     if ((!(datetime->year & 3U)) && (datetime->month <= 2U))
 197              		.loc 1 130 0
 198 0048 A107     		lsls	r1, r4, #30
 128:../drivers/fsl_rtc.c ****     /* For leap year if month less than or equal to Febraury, decrement day counter*/
 199              		.loc 1 128 0
 200 004a 03F1FF35 		add	r5, r3, #-1
 201              	.LVL6:
 202              		.loc 1 130 0
 203 004e 02D1     		bne	.L14
 204              		.loc 1 130 0 is_stmt 0 discriminator 1
 205 0050 0228     		cmp	r0, #2
 131:../drivers/fsl_rtc.c ****     {
 132:../drivers/fsl_rtc.c ****         seconds--;
 206              		.loc 1 132 0 is_stmt 1 discriminator 1
 207 0052 98BF     		it	ls
 208 0054 9D1E     		subls	r5, r3, #2
 209              	.LVL7:
 210              	.L14:
 133:../drivers/fsl_rtc.c ****     }
 134:../drivers/fsl_rtc.c **** 
 135:../drivers/fsl_rtc.c ****     seconds = (seconds * SECONDS_IN_A_DAY) + (datetime->hour * SECONDS_IN_A_HOUR) +
 136:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 211              		.loc 1 136 0
 212 0056 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 213              		.loc 1 135 0
 214 0058 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 215              		.loc 1 136 0
 216 005a C3EB0313 		rsb	r3, r3, r3, lsl #4
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 217              		.loc 1 135 0
 218 005e 4FF46160 		mov	r0, #3600
 219              		.loc 1 136 0
 220 0062 9B00     		lsls	r3, r3, #2
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 221              		.loc 1 135 0
 222 0064 00FB0133 		mla	r3, r0, r1, r3
 223              		.loc 1 136 0
 224 0068 9079     		ldrb	r0, [r2, #6]	@ zero_extendqisi2
 135:../drivers/fsl_rtc.c ****               (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
 225              		.loc 1 135 0
 226 006a 0344     		add	r3, r3, r0
 227              	.LVL8:
 137:../drivers/fsl_rtc.c **** 
 138:../drivers/fsl_rtc.c ****     return seconds;
 139:../drivers/fsl_rtc.c **** }
 228              		.loc 1 139 0
 229 006c 0348     		ldr	r0, .L16+4
 230 006e 00FB0530 		mla	r0, r0, r5, r3
 231              	.LVL9:
 232 0072 08B0     		add	sp, sp, #32
 233              		.cfi_def_cfa_offset 16
 234              		@ sp needed
 235 0074 70BD     		pop	{r4, r5, r6, pc}
 236              	.L17:
 237 0076 00BF     		.align	2
 238              	.L16:
 239 0078 0E000000 		.word	.LANCHOR0+14
 240 007c 80510100 		.word	86400
 241              		.cfi_endproc
 242              	.LFE154:
 244              		.section	.text.RTC_ConvertSecondsToDatetime,"ax",%progbits
 245              		.align	1
 246              		.syntax unified
 247              		.thumb
 248              		.thumb_func
 249              		.fpu fpv4-sp-d16
 251              	RTC_ConvertSecondsToDatetime:
 252              	.LFB155:
 140:../drivers/fsl_rtc.c **** 
 141:../drivers/fsl_rtc.c **** static void RTC_ConvertSecondsToDatetime(uint32_t seconds, rtc_datetime_t *datetime)
 142:../drivers/fsl_rtc.c **** {
 253              		.loc 1 142 0
 254              		.cfi_startproc
 255              		@ args = 0, pretend = 0, frame = 16
 256              		@ frame_needed = 0, uses_anonymous_args = 0
 257              	.LVL10:
 258 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 259              		.cfi_def_cfa_offset 20
 260              		.cfi_offset 4, -20
 261              		.cfi_offset 5, -16
 262              		.cfi_offset 6, -12
 263              		.cfi_offset 7, -8
 264              		.cfi_offset 14, -4
 143:../drivers/fsl_rtc.c ****     assert(datetime);
 144:../drivers/fsl_rtc.c **** 
 145:../drivers/fsl_rtc.c ****     uint32_t x;
 146:../drivers/fsl_rtc.c ****     uint32_t secondsRemaining, days;
 147:../drivers/fsl_rtc.c ****     uint16_t daysInYear;
 148:../drivers/fsl_rtc.c ****     /* Table of days in a month for a non leap year. First entry in the table is not used,
 149:../drivers/fsl_rtc.c ****      * valid months start from 1
 150:../drivers/fsl_rtc.c ****      */
 151:../drivers/fsl_rtc.c ****     uint8_t daysPerMonth[] = {0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U};
 265              		.loc 1 151 0
 266 0002 284A     		ldr	r2, .L30
 142:../drivers/fsl_rtc.c ****     assert(datetime);
 267              		.loc 1 142 0
 268 0004 85B0     		sub	sp, sp, #20
 269              		.cfi_def_cfa_offset 40
 142:../drivers/fsl_rtc.c ****     assert(datetime);
 270              		.loc 1 142 0
 271 0006 0746     		mov	r7, r0
 272 0008 0B46     		mov	r3, r1
 273              		.loc 1 151 0
 274 000a 6C46     		mov	r4, sp
 275 000c 02F1080E 		add	lr, r2, #8
 276 0010 6D46     		mov	r5, sp
 277              	.LVL11:
 278              	.L19:
 279 0012 1068     		ldr	r0, [r2]	@ unaligned
 280 0014 5168     		ldr	r1, [r2, #4]	@ unaligned
 281 0016 2646     		mov	r6, r4
 282 0018 03C6     		stmia	r6!, {r0, r1}
 283 001a 0832     		adds	r2, r2, #8
 284 001c 7245     		cmp	r2, lr
 285 001e 3446     		mov	r4, r6
 286 0020 F7D1     		bne	.L19
 152:../drivers/fsl_rtc.c **** 
 153:../drivers/fsl_rtc.c ****     /* Start with the seconds value that is passed in to be converted to date time format */
 154:../drivers/fsl_rtc.c ****     secondsRemaining = seconds;
 155:../drivers/fsl_rtc.c **** 
 156:../drivers/fsl_rtc.c ****     /* Calcuate the number of days, we add 1 for the current day which is represented in the
 157:../drivers/fsl_rtc.c ****      * hours and seconds field
 158:../drivers/fsl_rtc.c ****      */
 159:../drivers/fsl_rtc.c ****     days = secondsRemaining / SECONDS_IN_A_DAY + 1;
 287              		.loc 1 159 0
 288 0022 2149     		ldr	r1, .L30+4
 151:../drivers/fsl_rtc.c **** 
 289              		.loc 1 151 0
 290 0024 1068     		ldr	r0, [r2]	@ unaligned
 291 0026 3060     		str	r0, [r6]
 160:../drivers/fsl_rtc.c **** 
 161:../drivers/fsl_rtc.c ****     /* Update seconds left*/
 162:../drivers/fsl_rtc.c ****     secondsRemaining = secondsRemaining % SECONDS_IN_A_DAY;
 163:../drivers/fsl_rtc.c **** 
 164:../drivers/fsl_rtc.c ****     /* Calculate the datetime hour, minute and second fields */
 165:../drivers/fsl_rtc.c ****     datetime->hour = secondsRemaining / SECONDS_IN_A_HOUR;
 292              		.loc 1 165 0
 293 0028 4FF46164 		mov	r4, #3600
 159:../drivers/fsl_rtc.c **** 
 294              		.loc 1 159 0
 295 002c B7FBF1F0 		udiv	r0, r7, r1
 151:../drivers/fsl_rtc.c **** 
 296              		.loc 1 151 0
 297 0030 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 298 0032 3271     		strb	r2, [r6, #4]
 299              	.LVL12:
 162:../drivers/fsl_rtc.c **** 
 300              		.loc 1 162 0
 301 0034 01FB1071 		mls	r1, r1, r0, r7
 159:../drivers/fsl_rtc.c **** 
 302              		.loc 1 159 0
 303 0038 421C     		adds	r2, r0, #1
 304              	.LVL13:
 305              		.loc 1 165 0
 306 003a B1FBF4F0 		udiv	r0, r1, r4
 307 003e 1871     		strb	r0, [r3, #4]
 166:../drivers/fsl_rtc.c ****     secondsRemaining = secondsRemaining % SECONDS_IN_A_HOUR;
 308              		.loc 1 166 0
 309 0040 04FB1010 		mls	r0, r4, r0, r1
 310              	.LVL14:
 167:../drivers/fsl_rtc.c ****     datetime->minute = secondsRemaining / 60U;
 311              		.loc 1 167 0
 312 0044 3C24     		movs	r4, #60
 313 0046 B0FBF4F1 		udiv	r1, r0, r4
 168:../drivers/fsl_rtc.c ****     datetime->second = secondsRemaining % SECONDS_IN_A_MINUTE;
 314              		.loc 1 168 0
 315 004a 04FB1100 		mls	r0, r4, r1, r0
 316              	.LVL15:
 167:../drivers/fsl_rtc.c ****     datetime->minute = secondsRemaining / 60U;
 317              		.loc 1 167 0
 318 004e 5971     		strb	r1, [r3, #5]
 319              		.loc 1 168 0
 320 0050 9871     		strb	r0, [r3, #6]
 321              	.LVL16:
 169:../drivers/fsl_rtc.c **** 
 170:../drivers/fsl_rtc.c ****     /* Calculate year */
 171:../drivers/fsl_rtc.c ****     daysInYear = DAYS_IN_A_YEAR;
 172:../drivers/fsl_rtc.c ****     datetime->year = YEAR_RANGE_START;
 322              		.loc 1 172 0
 323 0052 40F2B271 		movw	r1, #1970
 171:../drivers/fsl_rtc.c ****     datetime->year = YEAR_RANGE_START;
 324              		.loc 1 171 0
 325 0056 40F26D10 		movw	r0, #365
 326              		.loc 1 172 0
 327 005a 1980     		strh	r1, [r3]	@ movhi
 173:../drivers/fsl_rtc.c ****     while (days > daysInYear)
 174:../drivers/fsl_rtc.c ****     {
 175:../drivers/fsl_rtc.c ****         /* Decrease day count by a year and increment year by 1 */
 176:../drivers/fsl_rtc.c ****         days -= daysInYear;
 177:../drivers/fsl_rtc.c ****         datetime->year++;
 178:../drivers/fsl_rtc.c **** 
 179:../drivers/fsl_rtc.c ****         /* Adjust the number of days for a leap year */
 180:../drivers/fsl_rtc.c ****         if (datetime->year & 3U)
 181:../drivers/fsl_rtc.c ****         {
 182:../drivers/fsl_rtc.c ****             daysInYear = DAYS_IN_A_YEAR;
 183:../drivers/fsl_rtc.c ****         }
 184:../drivers/fsl_rtc.c ****         else
 185:../drivers/fsl_rtc.c ****         {
 186:../drivers/fsl_rtc.c ****             daysInYear = DAYS_IN_A_YEAR + 1;
 328              		.loc 1 186 0
 329 005c 0446     		mov	r4, r0
 330              	.LVL17:
 331              	.L20:
 173:../drivers/fsl_rtc.c ****     while (days > daysInYear)
 332              		.loc 1 173 0
 333 005e 8242     		cmp	r2, r0
 334 0060 1988     		ldrh	r1, [r3]
 335 0062 0CD8     		bhi	.L22
 187:../drivers/fsl_rtc.c ****         }
 188:../drivers/fsl_rtc.c ****     }
 189:../drivers/fsl_rtc.c **** 
 190:../drivers/fsl_rtc.c ****     /* Adjust the days in February for a leap year */
 191:../drivers/fsl_rtc.c ****     if (!(datetime->year & 3U))
 336              		.loc 1 191 0
 337 0064 8907     		lsls	r1, r1, #30
 192:../drivers/fsl_rtc.c ****     {
 193:../drivers/fsl_rtc.c ****         daysPerMonth[2] = 29U;
 338              		.loc 1 193 0
 339 0066 04BF     		itt	eq
 340 0068 1D21     		moveq	r1, #29
 341 006a 8DF80210 		strbeq	r1, [sp, #2]
 342              	.LVL18:
 194:../drivers/fsl_rtc.c ****     }
 195:../drivers/fsl_rtc.c **** 
 196:../drivers/fsl_rtc.c ****     for (x = 1U; x <= 12U; x++)
 343              		.loc 1 196 0
 344 006e 0121     		movs	r1, #1
 345              	.LVL19:
 346              	.L26:
 197:../drivers/fsl_rtc.c ****     {
 198:../drivers/fsl_rtc.c ****         if (days <= daysPerMonth[x])
 347              		.loc 1 198 0
 348 0070 685C     		ldrb	r0, [r5, r1]	@ zero_extendqisi2
 349 0072 9042     		cmp	r0, r2
 350 0074 0FD3     		bcc	.L24
 199:../drivers/fsl_rtc.c ****         {
 200:../drivers/fsl_rtc.c ****             datetime->month = x;
 351              		.loc 1 200 0
 352 0076 9970     		strb	r1, [r3, #2]
 353              	.L25:
 201:../drivers/fsl_rtc.c ****             break;
 202:../drivers/fsl_rtc.c ****         }
 203:../drivers/fsl_rtc.c ****         else
 204:../drivers/fsl_rtc.c ****         {
 205:../drivers/fsl_rtc.c ****             days -= daysPerMonth[x];
 206:../drivers/fsl_rtc.c ****         }
 207:../drivers/fsl_rtc.c ****     }
 208:../drivers/fsl_rtc.c **** 
 209:../drivers/fsl_rtc.c ****     datetime->day = days;
 354              		.loc 1 209 0
 355 0078 DA70     		strb	r2, [r3, #3]
 210:../drivers/fsl_rtc.c **** }
 356              		.loc 1 210 0
 357 007a 05B0     		add	sp, sp, #20
 358              		.cfi_remember_state
 359              		.cfi_def_cfa_offset 20
 360              		@ sp needed
 361 007c F0BD     		pop	{r4, r5, r6, r7, pc}
 362              	.LVL20:
 363              	.L22:
 364              		.cfi_restore_state
 177:../drivers/fsl_rtc.c **** 
 365              		.loc 1 177 0
 366 007e 0131     		adds	r1, r1, #1
 367 0080 89B2     		uxth	r1, r1
 186:../drivers/fsl_rtc.c ****         }
 368              		.loc 1 186 0
 369 0082 11F0030F 		tst	r1, #3
 176:../drivers/fsl_rtc.c ****         datetime->year++;
 370              		.loc 1 176 0
 371 0086 A2EB0002 		sub	r2, r2, r0
 372              	.LVL21:
 177:../drivers/fsl_rtc.c **** 
 373              		.loc 1 177 0
 374 008a 1980     		strh	r1, [r3]	@ movhi
 186:../drivers/fsl_rtc.c ****         }
 375              		.loc 1 186 0
 376 008c 14BF     		ite	ne
 377 008e 2046     		movne	r0, r4
 378              	.LVL22:
 379 0090 4FF4B770 		moveq	r0, #366
 380 0094 E3E7     		b	.L20
 381              	.LVL23:
 382              	.L24:
 196:../drivers/fsl_rtc.c ****     {
 383              		.loc 1 196 0 discriminator 2
 384 0096 0131     		adds	r1, r1, #1
 385              	.LVL24:
 386 0098 0D29     		cmp	r1, #13
 205:../drivers/fsl_rtc.c ****         }
 387              		.loc 1 205 0 discriminator 2
 388 009a A2EB0002 		sub	r2, r2, r0
 389              	.LVL25:
 196:../drivers/fsl_rtc.c ****     {
 390              		.loc 1 196 0 discriminator 2
 391 009e E7D1     		bne	.L26
 392 00a0 EAE7     		b	.L25
 393              	.L31:
 394 00a2 00BF     		.align	2
 395              	.L30:
 396 00a4 00000000 		.word	.LANCHOR0
 397 00a8 80510100 		.word	86400
 398              		.cfi_endproc
 399              	.LFE155:
 401              		.section	.text.RTC_GetDefaultConfig,"ax",%progbits
 402              		.align	1
 403              		.global	RTC_GetDefaultConfig
 404              		.syntax unified
 405              		.thumb
 406              		.thumb_func
 407              		.fpu fpv4-sp-d16
 409              	RTC_GetDefaultConfig:
 410              	.LFB157:
 211:../drivers/fsl_rtc.c **** 
 212:../drivers/fsl_rtc.c **** void RTC_Init(RTC_Type *base, const rtc_config_t *config)
 213:../drivers/fsl_rtc.c **** {
 214:../drivers/fsl_rtc.c ****     assert(config);
 215:../drivers/fsl_rtc.c **** 
 216:../drivers/fsl_rtc.c ****     uint32_t reg;
 217:../drivers/fsl_rtc.c **** 
 218:../drivers/fsl_rtc.c **** #if defined(RTC_CLOCKS)
 219:../drivers/fsl_rtc.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 220:../drivers/fsl_rtc.c ****     CLOCK_EnableClock(kCLOCK_Rtc0);
 221:../drivers/fsl_rtc.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 222:../drivers/fsl_rtc.c **** #endif /* RTC_CLOCKS */
 223:../drivers/fsl_rtc.c **** 
 224:../drivers/fsl_rtc.c ****     /* Issue a software reset if timer is invalid */
 225:../drivers/fsl_rtc.c ****     if (RTC_GetStatusFlags(RTC) & kRTC_TimeInvalidFlag)
 226:../drivers/fsl_rtc.c ****     {
 227:../drivers/fsl_rtc.c ****         RTC_Reset(RTC);
 228:../drivers/fsl_rtc.c ****     }
 229:../drivers/fsl_rtc.c **** 
 230:../drivers/fsl_rtc.c ****     reg = base->CR;
 231:../drivers/fsl_rtc.c ****     /* Setup the update mode and supervisor access mode */
 232:../drivers/fsl_rtc.c ****     reg &= ~(RTC_CR_UM_MASK | RTC_CR_SUP_MASK);
 233:../drivers/fsl_rtc.c ****     reg |= RTC_CR_UM(config->updateMode) | RTC_CR_SUP(config->supervisorAccess);
 234:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION) && FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION
 235:../drivers/fsl_rtc.c ****     /* Setup the wakeup pin select */
 236:../drivers/fsl_rtc.c ****     reg &= ~(RTC_CR_WPS_MASK);
 237:../drivers/fsl_rtc.c ****     reg |= RTC_CR_WPS(config->wakeupSelect);
 238:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_WAKEUP_PIN */
 239:../drivers/fsl_rtc.c ****     base->CR = reg;
 240:../drivers/fsl_rtc.c **** 
 241:../drivers/fsl_rtc.c ****     /* Configure the RTC time compensation register */
 242:../drivers/fsl_rtc.c ****     base->TCR = (RTC_TCR_CIR(config->compensationInterval) | RTC_TCR_TCR(config->compensationTime))
 243:../drivers/fsl_rtc.c **** 	
 244:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_TSIC) && FSL_FEATURE_RTC_HAS_TSIC
 245:../drivers/fsl_rtc.c **** 	/* Configure RTC timer seconds interrupt to be generated once per second */
 246:../drivers/fsl_rtc.c **** 	base->IER &= ~(RTC_IER_TSIC_MASK | RTC_IER_TSIE_MASK);
 247:../drivers/fsl_rtc.c **** #endif
 248:../drivers/fsl_rtc.c **** }
 249:../drivers/fsl_rtc.c **** 
 250:../drivers/fsl_rtc.c **** void RTC_GetDefaultConfig(rtc_config_t *config)
 251:../drivers/fsl_rtc.c **** {
 411              		.loc 1 251 0
 412              		.cfi_startproc
 413              		@ args = 0, pretend = 0, frame = 0
 414              		@ frame_needed = 0, uses_anonymous_args = 0
 415              		@ link register save eliminated.
 416              	.LVL26:
 252:../drivers/fsl_rtc.c ****     assert(config);
 253:../drivers/fsl_rtc.c **** 
 254:../drivers/fsl_rtc.c ****     /* Wakeup pin will assert if the RTC interrupt asserts or if the wakeup pin is turned on */
 255:../drivers/fsl_rtc.c ****     config->wakeupSelect = false;
 417              		.loc 1 255 0
 418 0000 0023     		movs	r3, #0
 419 0002 0370     		strb	r3, [r0]
 256:../drivers/fsl_rtc.c ****     /* Registers cannot be written when locked */
 257:../drivers/fsl_rtc.c ****     config->updateMode = false;
 420              		.loc 1 257 0
 421 0004 4370     		strb	r3, [r0, #1]
 258:../drivers/fsl_rtc.c ****     /* Non-supervisor mode write accesses are not supported and will generate a bus error */
 259:../drivers/fsl_rtc.c ****     config->supervisorAccess = false;
 422              		.loc 1 259 0
 423 0006 8370     		strb	r3, [r0, #2]
 260:../drivers/fsl_rtc.c ****     /* Compensation interval used by the crystal compensation logic */
 261:../drivers/fsl_rtc.c ****     config->compensationInterval = 0;
 424              		.loc 1 261 0
 425 0008 4360     		str	r3, [r0, #4]
 262:../drivers/fsl_rtc.c ****     /* Compensation time used by the crystal compensation logic */
 263:../drivers/fsl_rtc.c ****     config->compensationTime = 0;
 426              		.loc 1 263 0
 427 000a 8360     		str	r3, [r0, #8]
 428 000c 7047     		bx	lr
 429              		.cfi_endproc
 430              	.LFE157:
 432              		.section	.text.RTC_SetDatetime,"ax",%progbits
 433              		.align	1
 434              		.global	RTC_SetDatetime
 435              		.syntax unified
 436              		.thumb
 437              		.thumb_func
 438              		.fpu fpv4-sp-d16
 440              	RTC_SetDatetime:
 441              	.LFB158:
 264:../drivers/fsl_rtc.c **** }
 265:../drivers/fsl_rtc.c **** 
 266:../drivers/fsl_rtc.c **** status_t RTC_SetDatetime(RTC_Type *base, const rtc_datetime_t *datetime)
 267:../drivers/fsl_rtc.c **** {
 442              		.loc 1 267 0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 0
 445              		@ frame_needed = 0, uses_anonymous_args = 0
 446              	.LVL27:
 447 0000 38B5     		push	{r3, r4, r5, lr}
 448              		.cfi_def_cfa_offset 16
 449              		.cfi_offset 3, -16
 450              		.cfi_offset 4, -12
 451              		.cfi_offset 5, -8
 452              		.cfi_offset 14, -4
 453              		.loc 1 267 0
 454 0002 0546     		mov	r5, r0
 268:../drivers/fsl_rtc.c ****     assert(datetime);
 269:../drivers/fsl_rtc.c **** 
 270:../drivers/fsl_rtc.c ****     /* Return error if the time provided is not valid */
 271:../drivers/fsl_rtc.c ****     if (!(RTC_CheckDatetimeFormat(datetime)))
 455              		.loc 1 271 0
 456 0004 0846     		mov	r0, r1
 457              	.LVL28:
 267:../drivers/fsl_rtc.c ****     assert(datetime);
 458              		.loc 1 267 0
 459 0006 0C46     		mov	r4, r1
 460              		.loc 1 271 0
 461 0008 FFF7FEFF 		bl	RTC_CheckDatetimeFormat
 462              	.LVL29:
 463 000c 28B1     		cbz	r0, .L35
 272:../drivers/fsl_rtc.c ****     {
 273:../drivers/fsl_rtc.c ****         return kStatus_InvalidArgument;
 274:../drivers/fsl_rtc.c ****     }
 275:../drivers/fsl_rtc.c **** 
 276:../drivers/fsl_rtc.c ****     /* Set time in seconds */
 277:../drivers/fsl_rtc.c ****     base->TSR = RTC_ConvertDatetimeToSeconds(datetime);
 464              		.loc 1 277 0
 465 000e 2046     		mov	r0, r4
 466 0010 FFF7FEFF 		bl	RTC_ConvertDatetimeToSeconds
 467              	.LVL30:
 468 0014 2860     		str	r0, [r5]
 278:../drivers/fsl_rtc.c **** 
 279:../drivers/fsl_rtc.c ****     return kStatus_Success;
 469              		.loc 1 279 0
 470 0016 0020     		movs	r0, #0
 471 0018 38BD     		pop	{r3, r4, r5, pc}
 472              	.LVL31:
 473              	.L35:
 273:../drivers/fsl_rtc.c ****     }
 474              		.loc 1 273 0
 475 001a 0420     		movs	r0, #4
 280:../drivers/fsl_rtc.c **** }
 476              		.loc 1 280 0
 477 001c 38BD     		pop	{r3, r4, r5, pc}
 478              		.cfi_endproc
 479              	.LFE158:
 481              		.section	.text.RTC_GetDatetime,"ax",%progbits
 482              		.align	1
 483              		.global	RTC_GetDatetime
 484              		.syntax unified
 485              		.thumb
 486              		.thumb_func
 487              		.fpu fpv4-sp-d16
 489              	RTC_GetDatetime:
 490              	.LFB159:
 281:../drivers/fsl_rtc.c **** 
 282:../drivers/fsl_rtc.c **** void RTC_GetDatetime(RTC_Type *base, rtc_datetime_t *datetime)
 283:../drivers/fsl_rtc.c **** {
 491              		.loc 1 283 0
 492              		.cfi_startproc
 493              		@ args = 0, pretend = 0, frame = 0
 494              		@ frame_needed = 0, uses_anonymous_args = 0
 495              		@ link register save eliminated.
 496              	.LVL32:
 284:../drivers/fsl_rtc.c ****     assert(datetime);
 285:../drivers/fsl_rtc.c **** 
 286:../drivers/fsl_rtc.c ****     uint32_t seconds = 0;
 287:../drivers/fsl_rtc.c **** 
 288:../drivers/fsl_rtc.c ****     seconds = base->TSR;
 497              		.loc 1 288 0
 498 0000 0068     		ldr	r0, [r0]
 499              	.LVL33:
 289:../drivers/fsl_rtc.c ****     RTC_ConvertSecondsToDatetime(seconds, datetime);
 500              		.loc 1 289 0
 501 0002 FFF7FEBF 		b	RTC_ConvertSecondsToDatetime
 502              	.LVL34:
 503              		.cfi_endproc
 504              	.LFE159:
 506              		.section	.text.RTC_SetAlarm,"ax",%progbits
 507              		.align	1
 508              		.global	RTC_SetAlarm
 509              		.syntax unified
 510              		.thumb
 511              		.thumb_func
 512              		.fpu fpv4-sp-d16
 514              	RTC_SetAlarm:
 515              	.LFB160:
 290:../drivers/fsl_rtc.c **** }
 291:../drivers/fsl_rtc.c **** 
 292:../drivers/fsl_rtc.c **** status_t RTC_SetAlarm(RTC_Type *base, const rtc_datetime_t *alarmTime)
 293:../drivers/fsl_rtc.c **** {
 516              		.loc 1 293 0
 517              		.cfi_startproc
 518              		@ args = 0, pretend = 0, frame = 0
 519              		@ frame_needed = 0, uses_anonymous_args = 0
 520              	.LVL35:
 521 0000 38B5     		push	{r3, r4, r5, lr}
 522              		.cfi_def_cfa_offset 16
 523              		.cfi_offset 3, -16
 524              		.cfi_offset 4, -12
 525              		.cfi_offset 5, -8
 526              		.cfi_offset 14, -4
 527              		.loc 1 293 0
 528 0002 0446     		mov	r4, r0
 294:../drivers/fsl_rtc.c ****     assert(alarmTime);
 295:../drivers/fsl_rtc.c **** 
 296:../drivers/fsl_rtc.c ****     uint32_t alarmSeconds = 0;
 297:../drivers/fsl_rtc.c ****     uint32_t currSeconds = 0;
 298:../drivers/fsl_rtc.c **** 
 299:../drivers/fsl_rtc.c ****     /* Return error if the alarm time provided is not valid */
 300:../drivers/fsl_rtc.c ****     if (!(RTC_CheckDatetimeFormat(alarmTime)))
 529              		.loc 1 300 0
 530 0004 0846     		mov	r0, r1
 531              	.LVL36:
 293:../drivers/fsl_rtc.c ****     assert(alarmTime);
 532              		.loc 1 293 0
 533 0006 0D46     		mov	r5, r1
 534              		.loc 1 300 0
 535 0008 FFF7FEFF 		bl	RTC_CheckDatetimeFormat
 536              	.LVL37:
 537 000c 40B1     		cbz	r0, .L39
 301:../drivers/fsl_rtc.c ****     {
 302:../drivers/fsl_rtc.c ****         return kStatus_InvalidArgument;
 303:../drivers/fsl_rtc.c ****     }
 304:../drivers/fsl_rtc.c **** 
 305:../drivers/fsl_rtc.c ****     alarmSeconds = RTC_ConvertDatetimeToSeconds(alarmTime);
 538              		.loc 1 305 0
 539 000e 2846     		mov	r0, r5
 540 0010 FFF7FEFF 		bl	RTC_ConvertDatetimeToSeconds
 541              	.LVL38:
 306:../drivers/fsl_rtc.c **** 
 307:../drivers/fsl_rtc.c ****     /* Get the current time */
 308:../drivers/fsl_rtc.c ****     currSeconds = base->TSR;
 542              		.loc 1 308 0
 543 0014 2368     		ldr	r3, [r4]
 544              	.LVL39:
 309:../drivers/fsl_rtc.c **** 
 310:../drivers/fsl_rtc.c ****     /* Return error if the alarm time has passed */
 311:../drivers/fsl_rtc.c ****     if (alarmSeconds < currSeconds)
 545              		.loc 1 311 0
 546 0016 9842     		cmp	r0, r3
 547 0018 04D3     		bcc	.L40
 312:../drivers/fsl_rtc.c ****     {
 313:../drivers/fsl_rtc.c ****         return kStatus_Fail;
 314:../drivers/fsl_rtc.c ****     }
 315:../drivers/fsl_rtc.c **** 
 316:../drivers/fsl_rtc.c ****     /* Set alarm in seconds*/
 317:../drivers/fsl_rtc.c ****     base->TAR = alarmSeconds;
 548              		.loc 1 317 0
 549 001a A060     		str	r0, [r4, #8]
 318:../drivers/fsl_rtc.c **** 
 319:../drivers/fsl_rtc.c ****     return kStatus_Success;
 550              		.loc 1 319 0
 551 001c 0020     		movs	r0, #0
 552              	.LVL40:
 553 001e 38BD     		pop	{r3, r4, r5, pc}
 554              	.LVL41:
 555              	.L39:
 302:../drivers/fsl_rtc.c ****     }
 556              		.loc 1 302 0
 557 0020 0420     		movs	r0, #4
 558 0022 38BD     		pop	{r3, r4, r5, pc}
 559              	.LVL42:
 560              	.L40:
 313:../drivers/fsl_rtc.c ****     }
 561              		.loc 1 313 0
 562 0024 0120     		movs	r0, #1
 563              	.LVL43:
 320:../drivers/fsl_rtc.c **** }
 564              		.loc 1 320 0
 565 0026 38BD     		pop	{r3, r4, r5, pc}
 566              		.cfi_endproc
 567              	.LFE160:
 569              		.section	.text.RTC_GetAlarm,"ax",%progbits
 570              		.align	1
 571              		.global	RTC_GetAlarm
 572              		.syntax unified
 573              		.thumb
 574              		.thumb_func
 575              		.fpu fpv4-sp-d16
 577              	RTC_GetAlarm:
 578              	.LFB161:
 321:../drivers/fsl_rtc.c **** 
 322:../drivers/fsl_rtc.c **** void RTC_GetAlarm(RTC_Type *base, rtc_datetime_t *datetime)
 323:../drivers/fsl_rtc.c **** {
 579              		.loc 1 323 0
 580              		.cfi_startproc
 581              		@ args = 0, pretend = 0, frame = 0
 582              		@ frame_needed = 0, uses_anonymous_args = 0
 583              		@ link register save eliminated.
 584              	.LVL44:
 324:../drivers/fsl_rtc.c ****     assert(datetime);
 325:../drivers/fsl_rtc.c **** 
 326:../drivers/fsl_rtc.c ****     uint32_t alarmSeconds = 0;
 327:../drivers/fsl_rtc.c **** 
 328:../drivers/fsl_rtc.c ****     /* Get alarm in seconds  */
 329:../drivers/fsl_rtc.c ****     alarmSeconds = base->TAR;
 585              		.loc 1 329 0
 586 0000 8068     		ldr	r0, [r0, #8]
 587              	.LVL45:
 330:../drivers/fsl_rtc.c **** 
 331:../drivers/fsl_rtc.c ****     RTC_ConvertSecondsToDatetime(alarmSeconds, datetime);
 588              		.loc 1 331 0
 589 0002 FFF7FEBF 		b	RTC_ConvertSecondsToDatetime
 590              	.LVL46:
 591              		.cfi_endproc
 592              	.LFE161:
 594              		.section	.text.RTC_EnableInterrupts,"ax",%progbits
 595              		.align	1
 596              		.global	RTC_EnableInterrupts
 597              		.syntax unified
 598              		.thumb
 599              		.thumb_func
 600              		.fpu fpv4-sp-d16
 602              	RTC_EnableInterrupts:
 603              	.LFB162:
 332:../drivers/fsl_rtc.c **** }
 333:../drivers/fsl_rtc.c **** 
 334:../drivers/fsl_rtc.c **** void RTC_EnableInterrupts(RTC_Type *base, uint32_t mask)
 335:../drivers/fsl_rtc.c **** {
 604              		.loc 1 335 0
 605              		.cfi_startproc
 606              		@ args = 0, pretend = 0, frame = 0
 607              		@ frame_needed = 0, uses_anonymous_args = 0
 608              		@ link register save eliminated.
 609              	.LVL47:
 336:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 337:../drivers/fsl_rtc.c **** 
 338:../drivers/fsl_rtc.c ****     /* RTC_IER */
 339:../drivers/fsl_rtc.c ****     if (kRTC_TimeInvalidInterruptEnable == (kRTC_TimeInvalidInterruptEnable & mask))
 610              		.loc 1 339 0
 611 0000 01F00103 		and	r3, r1, #1
 612              	.LVL48:
 340:../drivers/fsl_rtc.c ****     {
 341:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TIIE_MASK;
 342:../drivers/fsl_rtc.c ****     }
 343:../drivers/fsl_rtc.c ****     if (kRTC_TimeOverflowInterruptEnable == (kRTC_TimeOverflowInterruptEnable & mask))
 613              		.loc 1 343 0
 614 0004 8A07     		lsls	r2, r1, #30
 344:../drivers/fsl_rtc.c ****     {
 345:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TOIE_MASK;
 615              		.loc 1 345 0
 616 0006 48BF     		it	mi
 617 0008 43F00203 		orrmi	r3, r3, #2
 618              	.LVL49:
 346:../drivers/fsl_rtc.c ****     }
 347:../drivers/fsl_rtc.c ****     if (kRTC_AlarmInterruptEnable == (kRTC_AlarmInterruptEnable & mask))
 619              		.loc 1 347 0
 620 000c 4A07     		lsls	r2, r1, #29
 348:../drivers/fsl_rtc.c ****     {
 349:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TAIE_MASK;
 621              		.loc 1 349 0
 622 000e 48BF     		it	mi
 623 0010 43F00403 		orrmi	r3, r3, #4
 624              	.LVL50:
 350:../drivers/fsl_rtc.c ****     }
 351:../drivers/fsl_rtc.c ****     if (kRTC_SecondsInterruptEnable == (kRTC_SecondsInterruptEnable & mask))
 625              		.loc 1 351 0
 626 0014 0A07     		lsls	r2, r1, #28
 352:../drivers/fsl_rtc.c ****     {
 353:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TSIE_MASK;
 354:../drivers/fsl_rtc.c ****     }
 355:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 356:../drivers/fsl_rtc.c ****     if (kRTC_MonotonicOverflowInterruptEnable == (kRTC_MonotonicOverflowInterruptEnable & mask))
 357:../drivers/fsl_rtc.c ****     {
 358:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_MOIE_MASK;
 359:../drivers/fsl_rtc.c ****     }
 360:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 361:../drivers/fsl_rtc.c ****     base->IER |= tmp32;
 627              		.loc 1 361 0
 628 0016 C269     		ldr	r2, [r0, #28]
 353:../drivers/fsl_rtc.c ****     }
 629              		.loc 1 353 0
 630 0018 48BF     		it	mi
 631 001a 43F01003 		orrmi	r3, r3, #16
 632              	.LVL51:
 633              		.loc 1 361 0
 634 001e 1343     		orrs	r3, r3, r2
 635              	.LVL52:
 636 0020 C361     		str	r3, [r0, #28]
 637 0022 7047     		bx	lr
 638              		.cfi_endproc
 639              	.LFE162:
 641              		.section	.text.RTC_DisableInterrupts,"ax",%progbits
 642              		.align	1
 643              		.global	RTC_DisableInterrupts
 644              		.syntax unified
 645              		.thumb
 646              		.thumb_func
 647              		.fpu fpv4-sp-d16
 649              	RTC_DisableInterrupts:
 650              	.LFB163:
 362:../drivers/fsl_rtc.c **** 
 363:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
 364:../drivers/fsl_rtc.c ****     tmp32 = 0U;
 365:../drivers/fsl_rtc.c **** 
 366:../drivers/fsl_rtc.c ****     /* RTC_TIR */
 367:../drivers/fsl_rtc.c ****     if (kRTC_TestModeInterruptEnable == (kRTC_TestModeInterruptEnable & mask))
 368:../drivers/fsl_rtc.c ****     {
 369:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TMIE_MASK;
 370:../drivers/fsl_rtc.c ****     }
 371:../drivers/fsl_rtc.c ****     if (kRTC_FlashSecurityInterruptEnable == (kRTC_FlashSecurityInterruptEnable & mask))
 372:../drivers/fsl_rtc.c ****     {
 373:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_FSIE_MASK;
 374:../drivers/fsl_rtc.c ****     }
 375:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
 376:../drivers/fsl_rtc.c ****     if (kRTC_TamperPinInterruptEnable == (kRTC_TamperPinInterruptEnable & mask))
 377:../drivers/fsl_rtc.c ****     {
 378:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TPIE_MASK;
 379:../drivers/fsl_rtc.c ****     }
 380:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
 381:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
 382:../drivers/fsl_rtc.c ****     if (kRTC_SecurityModuleInterruptEnable == (kRTC_SecurityModuleInterruptEnable & mask))
 383:../drivers/fsl_rtc.c ****     {
 384:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_SIE_MASK;
 385:../drivers/fsl_rtc.c ****     }
 386:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_SIE */
 387:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
 388:../drivers/fsl_rtc.c ****     if (kRTC_LossOfClockInterruptEnable == (kRTC_LossOfClockInterruptEnable & mask))
 389:../drivers/fsl_rtc.c ****     {
 390:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_LCIE_MASK;
 391:../drivers/fsl_rtc.c ****     }
 392:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
 393:../drivers/fsl_rtc.c ****     base->TIR |= tmp32;
 394:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
 395:../drivers/fsl_rtc.c **** }
 396:../drivers/fsl_rtc.c **** 
 397:../drivers/fsl_rtc.c **** void RTC_DisableInterrupts(RTC_Type *base, uint32_t mask)
 398:../drivers/fsl_rtc.c **** {
 651              		.loc 1 398 0
 652              		.cfi_startproc
 653              		@ args = 0, pretend = 0, frame = 0
 654              		@ frame_needed = 0, uses_anonymous_args = 0
 655              		@ link register save eliminated.
 656              	.LVL53:
 399:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 400:../drivers/fsl_rtc.c **** 
 401:../drivers/fsl_rtc.c ****     /* RTC_IER */
 402:../drivers/fsl_rtc.c ****     if (kRTC_TimeInvalidInterruptEnable == (kRTC_TimeInvalidInterruptEnable & mask))
 657              		.loc 1 402 0
 658 0000 01F00103 		and	r3, r1, #1
 659              	.LVL54:
 403:../drivers/fsl_rtc.c ****     {
 404:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TIIE_MASK;
 405:../drivers/fsl_rtc.c ****     }
 406:../drivers/fsl_rtc.c ****     if (kRTC_TimeOverflowInterruptEnable == (kRTC_TimeOverflowInterruptEnable & mask))
 660              		.loc 1 406 0
 661 0004 8A07     		lsls	r2, r1, #30
 407:../drivers/fsl_rtc.c ****     {
 408:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TOIE_MASK;
 662              		.loc 1 408 0
 663 0006 48BF     		it	mi
 664 0008 43F00203 		orrmi	r3, r3, #2
 665              	.LVL55:
 409:../drivers/fsl_rtc.c ****     }
 410:../drivers/fsl_rtc.c ****     if (kRTC_AlarmInterruptEnable == (kRTC_AlarmInterruptEnable & mask))
 666              		.loc 1 410 0
 667 000c 4A07     		lsls	r2, r1, #29
 411:../drivers/fsl_rtc.c ****     {
 412:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TAIE_MASK;
 668              		.loc 1 412 0
 669 000e 48BF     		it	mi
 670 0010 43F00403 		orrmi	r3, r3, #4
 671              	.LVL56:
 413:../drivers/fsl_rtc.c ****     }
 414:../drivers/fsl_rtc.c ****     if (kRTC_SecondsInterruptEnable == (kRTC_SecondsInterruptEnable & mask))
 672              		.loc 1 414 0
 673 0014 0A07     		lsls	r2, r1, #28
 415:../drivers/fsl_rtc.c ****     {
 416:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_TSIE_MASK;
 417:../drivers/fsl_rtc.c ****     }
 418:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 419:../drivers/fsl_rtc.c ****     if (kRTC_MonotonicOverflowInterruptEnable == (kRTC_MonotonicOverflowInterruptEnable & mask))
 420:../drivers/fsl_rtc.c ****     {
 421:../drivers/fsl_rtc.c ****         tmp32 |= RTC_IER_MOIE_MASK;
 422:../drivers/fsl_rtc.c ****     }
 423:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 424:../drivers/fsl_rtc.c ****     base->IER &= (uint32_t)(~tmp32);
 674              		.loc 1 424 0
 675 0016 C269     		ldr	r2, [r0, #28]
 416:../drivers/fsl_rtc.c ****     }
 676              		.loc 1 416 0
 677 0018 48BF     		it	mi
 678 001a 43F01003 		orrmi	r3, r3, #16
 679              	.LVL57:
 680              		.loc 1 424 0
 681 001e 22EA0303 		bic	r3, r2, r3
 682              	.LVL58:
 683 0022 C361     		str	r3, [r0, #28]
 684 0024 7047     		bx	lr
 685              		.cfi_endproc
 686              	.LFE163:
 688              		.section	.text.RTC_GetEnabledInterrupts,"ax",%progbits
 689              		.align	1
 690              		.global	RTC_GetEnabledInterrupts
 691              		.syntax unified
 692              		.thumb
 693              		.thumb_func
 694              		.fpu fpv4-sp-d16
 696              	RTC_GetEnabledInterrupts:
 697              	.LFB164:
 425:../drivers/fsl_rtc.c **** 
 426:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
 427:../drivers/fsl_rtc.c ****     tmp32 = 0U;
 428:../drivers/fsl_rtc.c **** 
 429:../drivers/fsl_rtc.c ****     /* RTC_TIR */
 430:../drivers/fsl_rtc.c ****     if (kRTC_TestModeInterruptEnable == (kRTC_TestModeInterruptEnable & mask))
 431:../drivers/fsl_rtc.c ****     {
 432:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TMIE_MASK;
 433:../drivers/fsl_rtc.c ****     }
 434:../drivers/fsl_rtc.c ****     if (kRTC_FlashSecurityInterruptEnable == (kRTC_FlashSecurityInterruptEnable & mask))
 435:../drivers/fsl_rtc.c ****     {
 436:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_FSIE_MASK;
 437:../drivers/fsl_rtc.c ****     }
 438:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
 439:../drivers/fsl_rtc.c ****     if (kRTC_TamperPinInterruptEnable == (kRTC_TamperPinInterruptEnable & mask))
 440:../drivers/fsl_rtc.c ****     {
 441:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_TPIE_MASK;
 442:../drivers/fsl_rtc.c ****     }
 443:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
 444:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
 445:../drivers/fsl_rtc.c ****     if (kRTC_SecurityModuleInterruptEnable == (kRTC_SecurityModuleInterruptEnable & mask))
 446:../drivers/fsl_rtc.c ****     {
 447:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_SIE_MASK;
 448:../drivers/fsl_rtc.c ****     }
 449:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_SIE */
 450:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
 451:../drivers/fsl_rtc.c ****     if (kRTC_LossOfClockInterruptEnable == (kRTC_LossOfClockInterruptEnable & mask))
 452:../drivers/fsl_rtc.c ****     {
 453:../drivers/fsl_rtc.c ****         tmp32 |= RTC_TIR_LCIE_MASK;
 454:../drivers/fsl_rtc.c ****     }
 455:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
 456:../drivers/fsl_rtc.c ****     base->TIR &= (uint32_t)(~tmp32);
 457:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
 458:../drivers/fsl_rtc.c **** }
 459:../drivers/fsl_rtc.c **** 
 460:../drivers/fsl_rtc.c **** uint32_t RTC_GetEnabledInterrupts(RTC_Type *base)
 461:../drivers/fsl_rtc.c **** {
 698              		.loc 1 461 0
 699              		.cfi_startproc
 700              		@ args = 0, pretend = 0, frame = 0
 701              		@ frame_needed = 0, uses_anonymous_args = 0
 702              		@ link register save eliminated.
 703              	.LVL59:
 462:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 463:../drivers/fsl_rtc.c **** 
 464:../drivers/fsl_rtc.c ****     /* RTC_IER */
 465:../drivers/fsl_rtc.c ****     if (RTC_IER_TIIE_MASK == (RTC_IER_TIIE_MASK & base->IER))
 704              		.loc 1 465 0
 705 0000 C369     		ldr	r3, [r0, #28]
 466:../drivers/fsl_rtc.c ****     {
 467:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeInvalidInterruptEnable;
 468:../drivers/fsl_rtc.c ****     }
 469:../drivers/fsl_rtc.c ****     if (RTC_IER_TOIE_MASK == (RTC_IER_TOIE_MASK & base->IER))
 706              		.loc 1 469 0
 707 0002 C269     		ldr	r2, [r0, #28]
 708 0004 9207     		lsls	r2, r2, #30
 470:../drivers/fsl_rtc.c ****     {
 471:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeOverflowInterruptEnable;
 472:../drivers/fsl_rtc.c ****     }
 473:../drivers/fsl_rtc.c ****     if (RTC_IER_TAIE_MASK == (RTC_IER_TAIE_MASK & base->IER))
 709              		.loc 1 473 0
 710 0006 C269     		ldr	r2, [r0, #28]
 711 0008 03F00103 		and	r3, r3, #1
 712              	.LVL60:
 471:../drivers/fsl_rtc.c ****     }
 713              		.loc 1 471 0
 714 000c 48BF     		it	mi
 715 000e 43F00203 		orrmi	r3, r3, #2
 716              	.LVL61:
 717              		.loc 1 473 0
 718 0012 5107     		lsls	r1, r2, #29
 474:../drivers/fsl_rtc.c ****     {
 475:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_AlarmInterruptEnable;
 476:../drivers/fsl_rtc.c ****     }
 477:../drivers/fsl_rtc.c ****     if (RTC_IER_TSIE_MASK == (RTC_IER_TSIE_MASK & base->IER))
 719              		.loc 1 477 0
 720 0014 C269     		ldr	r2, [r0, #28]
 475:../drivers/fsl_rtc.c ****     }
 721              		.loc 1 475 0
 722 0016 48BF     		it	mi
 723 0018 43F00403 		orrmi	r3, r3, #4
 724              	.LVL62:
 725              		.loc 1 477 0
 726 001c D206     		lsls	r2, r2, #27
 478:../drivers/fsl_rtc.c ****     {
 479:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_SecondsInterruptEnable;
 727              		.loc 1 479 0
 728 001e 48BF     		it	mi
 729 0020 43F00803 		orrmi	r3, r3, #8
 730              	.LVL63:
 480:../drivers/fsl_rtc.c ****     }
 481:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 482:../drivers/fsl_rtc.c ****     if (RTC_IER_MOIE_MASK == (RTC_IER_MOIE_MASK & base->IER))
 483:../drivers/fsl_rtc.c ****     {
 484:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_MonotonicOverflowInterruptEnable;
 485:../drivers/fsl_rtc.c ****     }
 486:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 487:../drivers/fsl_rtc.c **** 
 488:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
 489:../drivers/fsl_rtc.c ****     /* RTC_TIR */
 490:../drivers/fsl_rtc.c ****     if (RTC_TIR_TMIE_MASK == (RTC_TIR_TMIE_MASK & base->TIR))
 491:../drivers/fsl_rtc.c ****     {
 492:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TestModeInterruptEnable;
 493:../drivers/fsl_rtc.c ****     }
 494:../drivers/fsl_rtc.c ****     if (RTC_TIR_FSIE_MASK == (RTC_TIR_FSIE_MASK & base->TIR))
 495:../drivers/fsl_rtc.c ****     {
 496:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_FlashSecurityInterruptEnable;
 497:../drivers/fsl_rtc.c ****     }
 498:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
 499:../drivers/fsl_rtc.c ****     if (RTC_TIR_TPIE_MASK == (RTC_TIR_TPIE_MASK & base->TIR))
 500:../drivers/fsl_rtc.c ****     {
 501:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TamperPinInterruptEnable;
 502:../drivers/fsl_rtc.c ****     }
 503:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
 504:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
 505:../drivers/fsl_rtc.c ****     if (RTC_TIR_SIE_MASK == (RTC_TIR_SIE_MASK & base->TIR))
 506:../drivers/fsl_rtc.c ****     {
 507:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_SecurityModuleInterruptEnable;
 508:../drivers/fsl_rtc.c ****     }
 509:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_SIE */
 510:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
 511:../drivers/fsl_rtc.c ****     if (RTC_TIR_LCIE_MASK == (RTC_TIR_LCIE_MASK & base->TIR))
 512:../drivers/fsl_rtc.c ****     {
 513:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_LossOfClockInterruptEnable;
 514:../drivers/fsl_rtc.c ****     }
 515:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
 516:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
 517:../drivers/fsl_rtc.c **** 
 518:../drivers/fsl_rtc.c ****     return tmp32;
 519:../drivers/fsl_rtc.c **** }
 731              		.loc 1 519 0
 732 0024 1846     		mov	r0, r3
 733              	.LVL64:
 734 0026 7047     		bx	lr
 735              		.cfi_endproc
 736              	.LFE164:
 738              		.section	.text.RTC_GetStatusFlags,"ax",%progbits
 739              		.align	1
 740              		.global	RTC_GetStatusFlags
 741              		.syntax unified
 742              		.thumb
 743              		.thumb_func
 744              		.fpu fpv4-sp-d16
 746              	RTC_GetStatusFlags:
 747              	.LFB165:
 520:../drivers/fsl_rtc.c **** 
 521:../drivers/fsl_rtc.c **** uint32_t RTC_GetStatusFlags(RTC_Type *base)
 522:../drivers/fsl_rtc.c **** {
 748              		.loc 1 522 0
 749              		.cfi_startproc
 750              		@ args = 0, pretend = 0, frame = 0
 751              		@ frame_needed = 0, uses_anonymous_args = 0
 752              		@ link register save eliminated.
 753              	.LVL65:
 523:../drivers/fsl_rtc.c ****     uint32_t tmp32 = 0U;
 524:../drivers/fsl_rtc.c **** 
 525:../drivers/fsl_rtc.c ****     /* RTC_SR */
 526:../drivers/fsl_rtc.c ****     if (RTC_SR_TIF_MASK == (RTC_SR_TIF_MASK & base->SR))
 754              		.loc 1 526 0
 755 0000 4369     		ldr	r3, [r0, #20]
 527:../drivers/fsl_rtc.c ****     {
 528:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeInvalidFlag;
 529:../drivers/fsl_rtc.c ****     }
 530:../drivers/fsl_rtc.c ****     if (RTC_SR_TOF_MASK == (RTC_SR_TOF_MASK & base->SR))
 756              		.loc 1 530 0
 757 0002 4269     		ldr	r2, [r0, #20]
 758 0004 9107     		lsls	r1, r2, #30
 531:../drivers/fsl_rtc.c ****     {
 532:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TimeOverflowFlag;
 533:../drivers/fsl_rtc.c ****     }
 534:../drivers/fsl_rtc.c ****     if (RTC_SR_TAF_MASK == (RTC_SR_TAF_MASK & base->SR))
 759              		.loc 1 534 0
 760 0006 4269     		ldr	r2, [r0, #20]
 761 0008 03F00103 		and	r3, r3, #1
 762              	.LVL66:
 532:../drivers/fsl_rtc.c ****     }
 763              		.loc 1 532 0
 764 000c 48BF     		it	mi
 765 000e 43F00203 		orrmi	r3, r3, #2
 766              	.LVL67:
 767              		.loc 1 534 0
 768 0012 5207     		lsls	r2, r2, #29
 535:../drivers/fsl_rtc.c ****     {
 536:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_AlarmFlag;
 769              		.loc 1 536 0
 770 0014 48BF     		it	mi
 771 0016 43F00403 		orrmi	r3, r3, #4
 772              	.LVL68:
 537:../drivers/fsl_rtc.c ****     }
 538:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
 539:../drivers/fsl_rtc.c ****     if (RTC_SR_MOF_MASK == (RTC_SR_MOF_MASK & base->SR))
 540:../drivers/fsl_rtc.c ****     {
 541:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_MonotonicOverflowFlag;
 542:../drivers/fsl_rtc.c ****     }
 543:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
 544:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_SR_TIDF) && FSL_FEATURE_RTC_HAS_SR_TIDF)
 545:../drivers/fsl_rtc.c ****     if (RTC_SR_TIDF_MASK == (RTC_SR_TIDF_MASK & base->SR))
 546:../drivers/fsl_rtc.c ****     {
 547:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TamperInterruptDetectFlag;
 548:../drivers/fsl_rtc.c ****     }
 549:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_SR_TIDF */
 550:../drivers/fsl_rtc.c **** 
 551:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR) && FSL_FEATURE_RTC_HAS_TDR)
 552:../drivers/fsl_rtc.c ****     /* RTC_TDR */
 553:../drivers/fsl_rtc.c ****     if (RTC_TDR_TMF_MASK == (RTC_TDR_TMF_MASK & base->TDR))
 554:../drivers/fsl_rtc.c ****     {
 555:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TestModeFlag;
 556:../drivers/fsl_rtc.c ****     }
 557:../drivers/fsl_rtc.c ****     if (RTC_TDR_FSF_MASK == (RTC_TDR_FSF_MASK & base->TDR))
 558:../drivers/fsl_rtc.c ****     {
 559:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_FlashSecurityFlag;
 560:../drivers/fsl_rtc.c ****     }
 561:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_TPF) && FSL_FEATURE_RTC_HAS_TDR_TPF)
 562:../drivers/fsl_rtc.c ****     if (RTC_TDR_TPF_MASK == (RTC_TDR_TPF_MASK & base->TDR))
 563:../drivers/fsl_rtc.c ****     {
 564:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_TamperPinFlag;
 565:../drivers/fsl_rtc.c ****     }
 566:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_TPF */
 567:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_STF) && FSL_FEATURE_RTC_HAS_TDR_STF)
 568:../drivers/fsl_rtc.c ****     if (RTC_TDR_STF_MASK == (RTC_TDR_STF_MASK & base->TDR))
 569:../drivers/fsl_rtc.c ****     {
 570:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_SecurityTamperFlag;
 571:../drivers/fsl_rtc.c ****     }
 572:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_STF */
 573:../drivers/fsl_rtc.c **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_LCTF) && FSL_FEATURE_RTC_HAS_TDR_LCTF)
 574:../drivers/fsl_rtc.c ****     if (RTC_TDR_LCTF_MASK == (RTC_TDR_LCTF_MASK & base->TDR))
 575:../drivers/fsl_rtc.c ****     {
 576:../drivers/fsl_rtc.c ****         tmp32 |= kRTC_LossOfClockTamperFlag;
 577:../drivers/fsl_rtc.c ****     }
 578:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR_LCTF */
 579:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_TDR */
 580:../drivers/fsl_rtc.c **** 
 581:../drivers/fsl_rtc.c ****     return tmp32;
 582:../drivers/fsl_rtc.c **** }
 773              		.loc 1 582 0
 774 001a 1846     		mov	r0, r3
 775              	.LVL69:
 776 001c 7047     		bx	lr
 777              		.cfi_endproc
 778              	.LFE165:
 780              		.section	.text.RTC_Init,"ax",%progbits
 781              		.align	1
 782              		.global	RTC_Init
 783              		.syntax unified
 784              		.thumb
 785              		.thumb_func
 786              		.fpu fpv4-sp-d16
 788              	RTC_Init:
 789              	.LFB156:
 213:../drivers/fsl_rtc.c ****     assert(config);
 790              		.loc 1 213 0
 791              		.cfi_startproc
 792              		@ args = 0, pretend = 0, frame = 0
 793              		@ frame_needed = 0, uses_anonymous_args = 0
 794              	.LVL70:
 795              	.LBB6:
 796              	.LBB7:
 797              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 798              		.loc 2 695 0
 799 0000 184A     		ldr	r2, .L95
 800 0002 1368     		ldr	r3, [r2]
 801              	.LBE7:
 802              	.LBE6:
 213:../drivers/fsl_rtc.c ****     assert(config);
 803              		.loc 1 213 0
 804 0004 70B5     		push	{r4, r5, r6, lr}
 805              		.cfi_def_cfa_offset 16
 806              		.cfi_offset 4, -16
 807              		.cfi_offset 5, -12
 808              		.cfi_offset 6, -8
 809              		.cfi_offset 14, -4
 225:../drivers/fsl_rtc.c ****     {
 810              		.loc 1 225 0
 811 0006 184E     		ldr	r6, .L95+4
 812              	.LBB9:
 813              	.LBB8:
 814              		.loc 2 695 0
 815 0008 43F00053 		orr	r3, r3, #536870912
 816 000c 1360     		str	r3, [r2]
 817              	.LVL71:
 818              	.LBE8:
 819              	.LBE9:
 213:../drivers/fsl_rtc.c ****     assert(config);
 820              		.loc 1 213 0
 821 000e 0446     		mov	r4, r0
 225:../drivers/fsl_rtc.c ****     {
 822              		.loc 1 225 0
 823 0010 3046     		mov	r0, r6
 824              	.LVL72:
 213:../drivers/fsl_rtc.c ****     assert(config);
 825              		.loc 1 213 0
 826 0012 0D46     		mov	r5, r1
 225:../drivers/fsl_rtc.c ****     {
 827              		.loc 1 225 0
 828 0014 FFF7FEFF 		bl	RTC_GetStatusFlags
 829              	.LVL73:
 830 0018 C307     		lsls	r3, r0, #31
 831 001a 09D5     		bpl	.L91
 832              	.LVL74:
 833              	.LBB10:
 834              	.LBB11:
 835              		.file 3 "../drivers/fsl_rtc.h"
   1:../drivers/fsl_rtc.h **** /*
   2:../drivers/fsl_rtc.h ****  * The Clear BSD License
   3:../drivers/fsl_rtc.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_rtc.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_rtc.h ****  * All rights reserved.
   6:../drivers/fsl_rtc.h ****  *
   7:../drivers/fsl_rtc.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_rtc.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_rtc.h ****  * that the following conditions are met:
  10:../drivers/fsl_rtc.h ****  *
  11:../drivers/fsl_rtc.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_rtc.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_rtc.h ****  *
  14:../drivers/fsl_rtc.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_rtc.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_rtc.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_rtc.h ****  *
  18:../drivers/fsl_rtc.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_rtc.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_rtc.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_rtc.h ****  *
  22:../drivers/fsl_rtc.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_rtc.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_rtc.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_rtc.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_rtc.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_rtc.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_rtc.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_rtc.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_rtc.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_rtc.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_rtc.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_rtc.h ****  */
  34:../drivers/fsl_rtc.h **** #ifndef _FSL_RTC_H_
  35:../drivers/fsl_rtc.h **** #define _FSL_RTC_H_
  36:../drivers/fsl_rtc.h **** 
  37:../drivers/fsl_rtc.h **** #include "fsl_common.h"
  38:../drivers/fsl_rtc.h **** 
  39:../drivers/fsl_rtc.h **** /*!
  40:../drivers/fsl_rtc.h ****  * @addtogroup rtc
  41:../drivers/fsl_rtc.h ****  * @{
  42:../drivers/fsl_rtc.h ****  */
  43:../drivers/fsl_rtc.h **** 
  44:../drivers/fsl_rtc.h **** /*******************************************************************************
  45:../drivers/fsl_rtc.h ****  * Definitions
  46:../drivers/fsl_rtc.h ****  ******************************************************************************/
  47:../drivers/fsl_rtc.h **** 
  48:../drivers/fsl_rtc.h **** /*! @name Driver version */
  49:../drivers/fsl_rtc.h **** /*@{*/
  50:../drivers/fsl_rtc.h **** #define FSL_RTC_DRIVER_VERSION (MAKE_VERSION(2, 0, 0)) /*!< Version 2.0.0 */
  51:../drivers/fsl_rtc.h **** /*@}*/
  52:../drivers/fsl_rtc.h **** 
  53:../drivers/fsl_rtc.h **** /*! @brief List of RTC interrupts */
  54:../drivers/fsl_rtc.h **** typedef enum _rtc_interrupt_enable
  55:../drivers/fsl_rtc.h **** {
  56:../drivers/fsl_rtc.h ****     kRTC_TimeInvalidInterruptEnable = (1U << 0U),  /*!< Time invalid interrupt.*/
  57:../drivers/fsl_rtc.h ****     kRTC_TimeOverflowInterruptEnable = (1U << 1U), /*!< Time overflow interrupt.*/
  58:../drivers/fsl_rtc.h ****     kRTC_AlarmInterruptEnable = (1U << 2U),        /*!< Alarm interrupt.*/
  59:../drivers/fsl_rtc.h ****     kRTC_SecondsInterruptEnable = (1U << 3U),      /*!< Seconds interrupt.*/
  60:../drivers/fsl_rtc.h **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
  61:../drivers/fsl_rtc.h ****     kRTC_MonotonicOverflowInterruptEnable = (1U << 4U), /*!< Monotonic Overflow Interrupt Enable */
  62:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
  63:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR) && FSL_FEATURE_RTC_HAS_TIR)
  64:../drivers/fsl_rtc.h ****     kRTC_TestModeInterruptEnable = (1U << 5U),      /* test mode interrupt */
  65:../drivers/fsl_rtc.h ****     kRTC_FlashSecurityInterruptEnable = (1U << 6U), /* flash security interrupt */
  66:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_TPIE) && FSL_FEATURE_RTC_HAS_TIR_TPIE)
  67:../drivers/fsl_rtc.h ****     kRTC_TamperPinInterruptEnable = (1U << 7U),     /* Tamper pin interrupt */
  68:../drivers/fsl_rtc.h **** #endif                                                     /* FSL_FEATURE_RTC_HAS_TIR_TPIE */
  69:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_SIE) && FSL_FEATURE_RTC_HAS_TIR_SIE)
  70:../drivers/fsl_rtc.h ****     kRTC_SecurityModuleInterruptEnable = (1U << 8U), /* security module interrupt */
  71:../drivers/fsl_rtc.h **** #endif                                                     /* FSL_FEATURE_RTC_HAS_TIR_SIE */
  72:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TIR_LCIE) && FSL_FEATURE_RTC_HAS_TIR_LCIE)
  73:../drivers/fsl_rtc.h ****     kRTC_LossOfClockInterruptEnable = (1U << 9U), /* loss of clock interrupt */
  74:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TIR_LCIE */
  75:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TIR */
  76:../drivers/fsl_rtc.h **** } rtc_interrupt_enable_t;
  77:../drivers/fsl_rtc.h **** 
  78:../drivers/fsl_rtc.h **** /*! @brief List of RTC flags */
  79:../drivers/fsl_rtc.h **** typedef enum _rtc_status_flags
  80:../drivers/fsl_rtc.h **** {
  81:../drivers/fsl_rtc.h ****     kRTC_TimeInvalidFlag = (1U << 0U),            /*!< Time invalid flag */
  82:../drivers/fsl_rtc.h ****     kRTC_TimeOverflowFlag = (1U << 1U),           /*!< Time overflow flag */
  83:../drivers/fsl_rtc.h ****     kRTC_AlarmFlag = (1U << 2U),                   /*!< Alarm flag*/
  84:../drivers/fsl_rtc.h **** #if defined(FSL_FEATURE_RTC_HAS_MONOTONIC) && (FSL_FEATURE_RTC_HAS_MONOTONIC)
  85:../drivers/fsl_rtc.h ****     kRTC_MonotonicOverflowFlag = (1U << 3U),       /*!< Monotonic Overflow Flag */
  86:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_MONOTONIC */
  87:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_SR_TIDF) && FSL_FEATURE_RTC_HAS_SR_TIDF)
  88:../drivers/fsl_rtc.h ****     kRTC_TamperInterruptDetectFlag = (1U << 4U), /*!< Tamper interrupt detect flag */
  89:../drivers/fsl_rtc.h **** #endif                                                 /* FSL_FEATURE_RTC_HAS_SR_TIDF */
  90:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR) && FSL_FEATURE_RTC_HAS_TDR)
  91:../drivers/fsl_rtc.h ****     kRTC_TestModeFlag = (1U << 5U),      /* Test mode flag */
  92:../drivers/fsl_rtc.h ****     kRTC_FlashSecurityFlag = (1U << 6U), /* Flash security flag */
  93:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_TPF) && FSL_FEATURE_RTC_HAS_TDR_TPF)
  94:../drivers/fsl_rtc.h ****     kRTC_TamperPinFlag = (1U << 7U),     /* Tamper pin flag */
  95:../drivers/fsl_rtc.h **** #endif                                         /* FSL_FEATURE_RTC_HAS_TDR_TPF */
  96:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_STF) && FSL_FEATURE_RTC_HAS_TDR_STF)
  97:../drivers/fsl_rtc.h ****     kRTC_SecurityTamperFlag = (1U << 8U), /* Security tamper flag */
  98:../drivers/fsl_rtc.h **** #endif                                          /* FSL_FEATURE_RTC_HAS_TDR_STF */
  99:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TDR_LCTF) && FSL_FEATURE_RTC_HAS_TDR_LCTF)
 100:../drivers/fsl_rtc.h ****     kRTC_LossOfClockTamperFlag = (1U << 9U), /* Loss of clock flag */
 101:../drivers/fsl_rtc.h **** #endif                                             /* FSL_FEATURE_RTC_HAS_TDR_LCTF */
 102:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TDR */
 103:../drivers/fsl_rtc.h **** } rtc_status_flags_t;
 104:../drivers/fsl_rtc.h **** 
 105:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_OSC_SCXP) && FSL_FEATURE_RTC_HAS_OSC_SCXP)
 106:../drivers/fsl_rtc.h **** 
 107:../drivers/fsl_rtc.h **** /*! @brief List of RTC Oscillator capacitor load settings */
 108:../drivers/fsl_rtc.h **** typedef enum _rtc_osc_cap_load
 109:../drivers/fsl_rtc.h **** {
 110:../drivers/fsl_rtc.h ****     kRTC_Capacitor_2p = RTC_CR_SC2P_MASK,  /*!< 2 pF capacitor load */
 111:../drivers/fsl_rtc.h ****     kRTC_Capacitor_4p = RTC_CR_SC4P_MASK,  /*!< 4 pF capacitor load */
 112:../drivers/fsl_rtc.h ****     kRTC_Capacitor_8p = RTC_CR_SC8P_MASK,  /*!< 8 pF capacitor load */
 113:../drivers/fsl_rtc.h ****     kRTC_Capacitor_16p = RTC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 114:../drivers/fsl_rtc.h **** } rtc_osc_cap_load_t;
 115:../drivers/fsl_rtc.h **** 
 116:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_SCG_HAS_OSC_SCXP */
 117:../drivers/fsl_rtc.h **** 
 118:../drivers/fsl_rtc.h **** /*! @brief Structure is used to hold the date and time */
 119:../drivers/fsl_rtc.h **** typedef struct _rtc_datetime
 120:../drivers/fsl_rtc.h **** {
 121:../drivers/fsl_rtc.h ****     uint16_t year;  /*!< Range from 1970 to 2099.*/
 122:../drivers/fsl_rtc.h ****     uint8_t month;  /*!< Range from 1 to 12.*/
 123:../drivers/fsl_rtc.h ****     uint8_t day;    /*!< Range from 1 to 31 (depending on month).*/
 124:../drivers/fsl_rtc.h ****     uint8_t hour;   /*!< Range from 0 to 23.*/
 125:../drivers/fsl_rtc.h ****     uint8_t minute; /*!< Range from 0 to 59.*/
 126:../drivers/fsl_rtc.h ****     uint8_t second; /*!< Range from 0 to 59.*/
 127:../drivers/fsl_rtc.h **** } rtc_datetime_t;
 128:../drivers/fsl_rtc.h **** 
 129:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_PCR) && FSL_FEATURE_RTC_HAS_PCR)
 130:../drivers/fsl_rtc.h **** 
 131:../drivers/fsl_rtc.h **** /*!
 132:../drivers/fsl_rtc.h ****  * @brief RTC pin config structure
 133:../drivers/fsl_rtc.h ****  */
 134:../drivers/fsl_rtc.h **** typedef struct _rtc_pin_config
 135:../drivers/fsl_rtc.h **** {
 136:../drivers/fsl_rtc.h ****     bool inputLogic;       /*!< true: Tamper pin input data is logic one.
 137:../drivers/fsl_rtc.h ****                                 false: Tamper pin input data is logic zero. */
 138:../drivers/fsl_rtc.h ****     bool pinActiveLow;     /*!< true: Tamper pin is active low.
 139:../drivers/fsl_rtc.h ****                                 false: Tamper pin is active high. */
 140:../drivers/fsl_rtc.h ****     bool filterEnable;     /*!< true: Input filter is enabled on the tamper pin.
 141:../drivers/fsl_rtc.h ****                                 false: Input filter is disabled on the tamper pin. */
 142:../drivers/fsl_rtc.h ****     bool pullSelectNegate; /*!< true: Tamper pin pull resistor direction will negate the tamper pin
 143:../drivers/fsl_rtc.h ****                                 false: Tamper pin pull resistor direction will assert the tamper pi
 144:../drivers/fsl_rtc.h ****     bool pullEnable;       /*!< true: Pull resistor is enabled on tamper pin.
 145:../drivers/fsl_rtc.h ****                                 false: Pull resistor is disabled on tamper pin. */
 146:../drivers/fsl_rtc.h **** } rtc_pin_config_t;
 147:../drivers/fsl_rtc.h **** 
 148:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_PCR */
 149:../drivers/fsl_rtc.h **** 
 150:../drivers/fsl_rtc.h **** /*!
 151:../drivers/fsl_rtc.h ****  * @brief RTC config structure
 152:../drivers/fsl_rtc.h ****  *
 153:../drivers/fsl_rtc.h ****  * This structure holds the configuration settings for the RTC peripheral. To initialize this
 154:../drivers/fsl_rtc.h ****  * structure to reasonable defaults, call the RTC_GetDefaultConfig() function and pass a
 155:../drivers/fsl_rtc.h ****  * pointer to your config structure instance.
 156:../drivers/fsl_rtc.h ****  *
 157:../drivers/fsl_rtc.h ****  * The config struct can be made const so it resides in flash
 158:../drivers/fsl_rtc.h ****  */
 159:../drivers/fsl_rtc.h **** typedef struct _rtc_config
 160:../drivers/fsl_rtc.h **** {
 161:../drivers/fsl_rtc.h ****     bool wakeupSelect;             /*!< true: Wakeup pin outputs the 32 KHz clock;
 162:../drivers/fsl_rtc.h ****                                         false:Wakeup pin used to wakeup the chip  */
 163:../drivers/fsl_rtc.h ****     bool updateMode;               /*!< true: Registers can be written even when locked under certa
 164:../drivers/fsl_rtc.h ****                                         conditions, false: No writes allowed when registers are loc
 165:../drivers/fsl_rtc.h ****     bool supervisorAccess;         /*!< true: Non-supervisor accesses are allowed;
 166:../drivers/fsl_rtc.h ****                                         false: Non-supervisor accesses are not supported */
 167:../drivers/fsl_rtc.h ****     uint32_t compensationInterval; /*!< Compensation interval that is written to the CIR field in R
 168:../drivers/fsl_rtc.h ****     uint32_t compensationTime;     /*!< Compensation time that is written to the TCR field in RTC T
 169:../drivers/fsl_rtc.h **** } rtc_config_t;
 170:../drivers/fsl_rtc.h **** 
 171:../drivers/fsl_rtc.h **** /*******************************************************************************
 172:../drivers/fsl_rtc.h ****  * API
 173:../drivers/fsl_rtc.h ****  ******************************************************************************/
 174:../drivers/fsl_rtc.h **** 
 175:../drivers/fsl_rtc.h **** #if defined(__cplusplus)
 176:../drivers/fsl_rtc.h **** extern "C" {
 177:../drivers/fsl_rtc.h **** #endif
 178:../drivers/fsl_rtc.h **** 
 179:../drivers/fsl_rtc.h **** /*!
 180:../drivers/fsl_rtc.h ****  * @name Initialization and deinitialization
 181:../drivers/fsl_rtc.h ****  * @{
 182:../drivers/fsl_rtc.h ****  */
 183:../drivers/fsl_rtc.h **** 
 184:../drivers/fsl_rtc.h **** /*!
 185:../drivers/fsl_rtc.h ****  * @brief Ungates the RTC clock and configures the peripheral for basic operation.
 186:../drivers/fsl_rtc.h ****  *
 187:../drivers/fsl_rtc.h ****  * This function issues a software reset if the timer invalid flag is set.
 188:../drivers/fsl_rtc.h ****  *
 189:../drivers/fsl_rtc.h ****  * @note This API should be called at the beginning of the application using the RTC driver.
 190:../drivers/fsl_rtc.h ****  *
 191:../drivers/fsl_rtc.h ****  * @param base   RTC peripheral base address
 192:../drivers/fsl_rtc.h ****  * @param config Pointer to the user's RTC configuration structure.
 193:../drivers/fsl_rtc.h ****  */
 194:../drivers/fsl_rtc.h **** void RTC_Init(RTC_Type *base, const rtc_config_t *config);
 195:../drivers/fsl_rtc.h **** 
 196:../drivers/fsl_rtc.h **** /*!
 197:../drivers/fsl_rtc.h ****  * @brief Stops the timer and gate the RTC clock.
 198:../drivers/fsl_rtc.h ****  *
 199:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 200:../drivers/fsl_rtc.h ****  */
 201:../drivers/fsl_rtc.h **** static inline void RTC_Deinit(RTC_Type *base)
 202:../drivers/fsl_rtc.h **** {
 203:../drivers/fsl_rtc.h ****     /* Stop the RTC timer */
 204:../drivers/fsl_rtc.h ****     base->SR &= ~RTC_SR_TCE_MASK;
 205:../drivers/fsl_rtc.h **** 
 206:../drivers/fsl_rtc.h **** #if defined(RTC_CLOCKS)
 207:../drivers/fsl_rtc.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 208:../drivers/fsl_rtc.h ****     /* Gate the module clock */
 209:../drivers/fsl_rtc.h ****     CLOCK_DisableClock(kCLOCK_Rtc0);
 210:../drivers/fsl_rtc.h **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 211:../drivers/fsl_rtc.h **** #endif /* RTC_CLOCKS */
 212:../drivers/fsl_rtc.h **** }
 213:../drivers/fsl_rtc.h **** 
 214:../drivers/fsl_rtc.h **** /*!
 215:../drivers/fsl_rtc.h ****  * @brief Fills in the RTC config struct with the default settings.
 216:../drivers/fsl_rtc.h ****  *
 217:../drivers/fsl_rtc.h ****  * The default values are as follows.
 218:../drivers/fsl_rtc.h ****  * @code
 219:../drivers/fsl_rtc.h ****  *    config->wakeupSelect = false;
 220:../drivers/fsl_rtc.h ****  *    config->updateMode = false;
 221:../drivers/fsl_rtc.h ****  *    config->supervisorAccess = false;
 222:../drivers/fsl_rtc.h ****  *    config->compensationInterval = 0;
 223:../drivers/fsl_rtc.h ****  *    config->compensationTime = 0;
 224:../drivers/fsl_rtc.h ****  * @endcode
 225:../drivers/fsl_rtc.h ****  * @param config Pointer to the user's RTC configuration structure.
 226:../drivers/fsl_rtc.h ****  */
 227:../drivers/fsl_rtc.h **** void RTC_GetDefaultConfig(rtc_config_t *config);
 228:../drivers/fsl_rtc.h **** 
 229:../drivers/fsl_rtc.h **** /*! @}*/
 230:../drivers/fsl_rtc.h **** 
 231:../drivers/fsl_rtc.h **** /*!
 232:../drivers/fsl_rtc.h ****  * @name Current Time & Alarm
 233:../drivers/fsl_rtc.h ****  * @{
 234:../drivers/fsl_rtc.h ****  */
 235:../drivers/fsl_rtc.h **** 
 236:../drivers/fsl_rtc.h **** /*!
 237:../drivers/fsl_rtc.h ****  * @brief Sets the RTC date and time according to the given time structure.
 238:../drivers/fsl_rtc.h ****  *
 239:../drivers/fsl_rtc.h ****  * The RTC counter must be stopped prior to calling this function because writes to the RTC
 240:../drivers/fsl_rtc.h ****  * seconds register fail if the RTC counter is running.
 241:../drivers/fsl_rtc.h ****  *
 242:../drivers/fsl_rtc.h ****  * @param base     RTC peripheral base address
 243:../drivers/fsl_rtc.h ****  * @param datetime Pointer to the structure where the date and time details are stored.
 244:../drivers/fsl_rtc.h ****  *
 245:../drivers/fsl_rtc.h ****  * @return kStatus_Success: Success in setting the time and starting the RTC
 246:../drivers/fsl_rtc.h ****  *         kStatus_InvalidArgument: Error because the datetime format is incorrect
 247:../drivers/fsl_rtc.h ****  */
 248:../drivers/fsl_rtc.h **** status_t RTC_SetDatetime(RTC_Type *base, const rtc_datetime_t *datetime);
 249:../drivers/fsl_rtc.h **** 
 250:../drivers/fsl_rtc.h **** /*!
 251:../drivers/fsl_rtc.h ****  * @brief Gets the RTC time and stores it in the given time structure.
 252:../drivers/fsl_rtc.h ****  *
 253:../drivers/fsl_rtc.h ****  * @param base     RTC peripheral base address
 254:../drivers/fsl_rtc.h ****  * @param datetime Pointer to the structure where the date and time details are stored.
 255:../drivers/fsl_rtc.h ****  */
 256:../drivers/fsl_rtc.h **** void RTC_GetDatetime(RTC_Type *base, rtc_datetime_t *datetime);
 257:../drivers/fsl_rtc.h **** 
 258:../drivers/fsl_rtc.h **** /*!
 259:../drivers/fsl_rtc.h ****  * @brief Sets the RTC alarm time.
 260:../drivers/fsl_rtc.h ****  *
 261:../drivers/fsl_rtc.h ****  * The function checks whether the specified alarm time is greater than the present
 262:../drivers/fsl_rtc.h ****  * time. If not, the function does not set the alarm and returns an error.
 263:../drivers/fsl_rtc.h ****  *
 264:../drivers/fsl_rtc.h ****  * @param base      RTC peripheral base address
 265:../drivers/fsl_rtc.h ****  * @param alarmTime Pointer to the structure where the alarm time is stored.
 266:../drivers/fsl_rtc.h ****  *
 267:../drivers/fsl_rtc.h ****  * @return kStatus_Success: success in setting the RTC alarm
 268:../drivers/fsl_rtc.h ****  *         kStatus_InvalidArgument: Error because the alarm datetime format is incorrect
 269:../drivers/fsl_rtc.h ****  *         kStatus_Fail: Error because the alarm time has already passed
 270:../drivers/fsl_rtc.h ****  */
 271:../drivers/fsl_rtc.h **** status_t RTC_SetAlarm(RTC_Type *base, const rtc_datetime_t *alarmTime);
 272:../drivers/fsl_rtc.h **** 
 273:../drivers/fsl_rtc.h **** /*!
 274:../drivers/fsl_rtc.h ****  * @brief Returns the RTC alarm time.
 275:../drivers/fsl_rtc.h ****  *
 276:../drivers/fsl_rtc.h ****  * @param base     RTC peripheral base address
 277:../drivers/fsl_rtc.h ****  * @param datetime Pointer to the structure where the alarm date and time details are stored.
 278:../drivers/fsl_rtc.h ****  */
 279:../drivers/fsl_rtc.h **** void RTC_GetAlarm(RTC_Type *base, rtc_datetime_t *datetime);
 280:../drivers/fsl_rtc.h **** 
 281:../drivers/fsl_rtc.h **** /*! @}*/
 282:../drivers/fsl_rtc.h **** 
 283:../drivers/fsl_rtc.h **** /*!
 284:../drivers/fsl_rtc.h ****  * @name Interrupt Interface
 285:../drivers/fsl_rtc.h ****  * @{
 286:../drivers/fsl_rtc.h ****  */
 287:../drivers/fsl_rtc.h **** 
 288:../drivers/fsl_rtc.h **** /*!
 289:../drivers/fsl_rtc.h ****  * @brief Enables the selected RTC interrupts.
 290:../drivers/fsl_rtc.h ****  *
 291:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 292:../drivers/fsl_rtc.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 293:../drivers/fsl_rtc.h ****  *             enumeration ::rtc_interrupt_enable_t
 294:../drivers/fsl_rtc.h ****  */
 295:../drivers/fsl_rtc.h **** void RTC_EnableInterrupts(RTC_Type *base, uint32_t mask);
 296:../drivers/fsl_rtc.h **** 
 297:../drivers/fsl_rtc.h **** /*!
 298:../drivers/fsl_rtc.h ****  * @brief Disables the selected RTC interrupts.
 299:../drivers/fsl_rtc.h ****  *
 300:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 301:../drivers/fsl_rtc.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 302:../drivers/fsl_rtc.h ****  *             enumeration ::rtc_interrupt_enable_t
 303:../drivers/fsl_rtc.h ****  */
 304:../drivers/fsl_rtc.h **** void RTC_DisableInterrupts(RTC_Type *base, uint32_t mask);
 305:../drivers/fsl_rtc.h **** 
 306:../drivers/fsl_rtc.h **** /*!
 307:../drivers/fsl_rtc.h ****  * @brief Gets the enabled RTC interrupts.
 308:../drivers/fsl_rtc.h ****  *
 309:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 310:../drivers/fsl_rtc.h ****  *
 311:../drivers/fsl_rtc.h ****  * @return The enabled interrupts. This is the logical OR of members of the
 312:../drivers/fsl_rtc.h ****  *         enumeration ::rtc_interrupt_enable_t
 313:../drivers/fsl_rtc.h ****  */
 314:../drivers/fsl_rtc.h **** uint32_t RTC_GetEnabledInterrupts(RTC_Type *base);
 315:../drivers/fsl_rtc.h **** 
 316:../drivers/fsl_rtc.h **** /*! @}*/
 317:../drivers/fsl_rtc.h **** 
 318:../drivers/fsl_rtc.h **** /*!
 319:../drivers/fsl_rtc.h ****  * @name Status Interface
 320:../drivers/fsl_rtc.h ****  * @{
 321:../drivers/fsl_rtc.h ****  */
 322:../drivers/fsl_rtc.h **** 
 323:../drivers/fsl_rtc.h **** /*!
 324:../drivers/fsl_rtc.h ****  * @brief Gets the RTC status flags.
 325:../drivers/fsl_rtc.h ****  *
 326:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 327:../drivers/fsl_rtc.h ****  *
 328:../drivers/fsl_rtc.h ****  * @return The status flags. This is the logical OR of members of the
 329:../drivers/fsl_rtc.h ****  *         enumeration ::rtc_status_flags_t
 330:../drivers/fsl_rtc.h ****  */
 331:../drivers/fsl_rtc.h **** uint32_t RTC_GetStatusFlags(RTC_Type *base);
 332:../drivers/fsl_rtc.h **** 
 333:../drivers/fsl_rtc.h **** /*!
 334:../drivers/fsl_rtc.h ****  * @brief  Clears the RTC status flags.
 335:../drivers/fsl_rtc.h ****  *
 336:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 337:../drivers/fsl_rtc.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
 338:../drivers/fsl_rtc.h ****  *             enumeration ::rtc_status_flags_t
 339:../drivers/fsl_rtc.h ****  */
 340:../drivers/fsl_rtc.h **** void RTC_ClearStatusFlags(RTC_Type *base, uint32_t mask);
 341:../drivers/fsl_rtc.h **** 
 342:../drivers/fsl_rtc.h **** /*! @}*/
 343:../drivers/fsl_rtc.h **** 
 344:../drivers/fsl_rtc.h **** /*!
 345:../drivers/fsl_rtc.h ****  * @brief Set RTC clock source.
 346:../drivers/fsl_rtc.h ****  * 
 347:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 348:../drivers/fsl_rtc.h ****  *
 349:../drivers/fsl_rtc.h ****  * @note After setting this bit, wait the oscillator startup time before enabling
 350:../drivers/fsl_rtc.h ****  *       the time counter to allow the 32.768 kHz clock time to stabilize.
 351:../drivers/fsl_rtc.h ****  */
 352:../drivers/fsl_rtc.h **** static inline void RTC_SetClockSource(RTC_Type *base)
 353:../drivers/fsl_rtc.h **** {
 354:../drivers/fsl_rtc.h ****     /* Enable the RTC 32KHz oscillator */
 355:../drivers/fsl_rtc.h ****     base->CR |= RTC_CR_OSCE_MASK;
 356:../drivers/fsl_rtc.h **** }
 357:../drivers/fsl_rtc.h **** 
 358:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_TTSR) && FSL_FEATURE_RTC_HAS_TTSR)
 359:../drivers/fsl_rtc.h **** 
 360:../drivers/fsl_rtc.h **** /*!
 361:../drivers/fsl_rtc.h ****  * @brief Get the RTC tamper time seconds.
 362:../drivers/fsl_rtc.h ****  *
 363:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 364:../drivers/fsl_rtc.h ****  */
 365:../drivers/fsl_rtc.h **** static inline uint32_t RTC_GetTamperTimeSeconds(RTC_Type *base)
 366:../drivers/fsl_rtc.h **** {
 367:../drivers/fsl_rtc.h ****     return base->TTSR;
 368:../drivers/fsl_rtc.h **** }
 369:../drivers/fsl_rtc.h **** 
 370:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_RTC_HAS_TTSR */
 371:../drivers/fsl_rtc.h **** 
 372:../drivers/fsl_rtc.h **** /*!
 373:../drivers/fsl_rtc.h ****  * @name Timer Start and Stop
 374:../drivers/fsl_rtc.h ****  * @{
 375:../drivers/fsl_rtc.h ****  */
 376:../drivers/fsl_rtc.h **** 
 377:../drivers/fsl_rtc.h **** /*!
 378:../drivers/fsl_rtc.h ****  * @brief Starts the RTC time counter.
 379:../drivers/fsl_rtc.h ****  *
 380:../drivers/fsl_rtc.h ****  * After calling this function, the timer counter increments once a second provided SR[TOF] or
 381:../drivers/fsl_rtc.h ****  * SR[TIF] are not set.
 382:../drivers/fsl_rtc.h ****  *
 383:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 384:../drivers/fsl_rtc.h ****  */
 385:../drivers/fsl_rtc.h **** static inline void RTC_StartTimer(RTC_Type *base)
 386:../drivers/fsl_rtc.h **** {
 387:../drivers/fsl_rtc.h ****     base->SR |= RTC_SR_TCE_MASK;
 388:../drivers/fsl_rtc.h **** }
 389:../drivers/fsl_rtc.h **** 
 390:../drivers/fsl_rtc.h **** /*!
 391:../drivers/fsl_rtc.h ****  * @brief Stops the RTC time counter.
 392:../drivers/fsl_rtc.h ****  *
 393:../drivers/fsl_rtc.h ****  * RTC's seconds register can be written to only when the timer is stopped.
 394:../drivers/fsl_rtc.h ****  *
 395:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 396:../drivers/fsl_rtc.h ****  */
 397:../drivers/fsl_rtc.h **** static inline void RTC_StopTimer(RTC_Type *base)
 398:../drivers/fsl_rtc.h **** {
 399:../drivers/fsl_rtc.h ****     base->SR &= ~RTC_SR_TCE_MASK;
 400:../drivers/fsl_rtc.h **** }
 401:../drivers/fsl_rtc.h **** 
 402:../drivers/fsl_rtc.h **** /*! @}*/
 403:../drivers/fsl_rtc.h **** 
 404:../drivers/fsl_rtc.h **** #if (defined(FSL_FEATURE_RTC_HAS_OSC_SCXP) && FSL_FEATURE_RTC_HAS_OSC_SCXP)
 405:../drivers/fsl_rtc.h **** 
 406:../drivers/fsl_rtc.h **** /*!
 407:../drivers/fsl_rtc.h ****  * @brief This function sets the specified capacitor configuration for the RTC oscillator.
 408:../drivers/fsl_rtc.h ****  *
 409:../drivers/fsl_rtc.h ****  * @param base    RTC peripheral base address
 410:../drivers/fsl_rtc.h ****  * @param capLoad Oscillator loads to enable. This is a logical OR of members of the
 411:../drivers/fsl_rtc.h ****  *                enumeration ::rtc_osc_cap_load_t
 412:../drivers/fsl_rtc.h ****  */
 413:../drivers/fsl_rtc.h **** static inline void RTC_SetOscCapLoad(RTC_Type *base, uint32_t capLoad)
 414:../drivers/fsl_rtc.h **** {
 415:../drivers/fsl_rtc.h ****     uint32_t reg = base->CR;
 416:../drivers/fsl_rtc.h **** 
 417:../drivers/fsl_rtc.h ****     reg &= ~(RTC_CR_SC2P_MASK | RTC_CR_SC4P_MASK | RTC_CR_SC8P_MASK | RTC_CR_SC16P_MASK);
 418:../drivers/fsl_rtc.h ****     reg |= capLoad;
 419:../drivers/fsl_rtc.h **** 
 420:../drivers/fsl_rtc.h ****     base->CR = reg;
 421:../drivers/fsl_rtc.h **** }
 422:../drivers/fsl_rtc.h **** 
 423:../drivers/fsl_rtc.h **** #endif /* FSL_FEATURE_SCG_HAS_OSC_SCXP */
 424:../drivers/fsl_rtc.h **** 
 425:../drivers/fsl_rtc.h **** /*!
 426:../drivers/fsl_rtc.h ****  * @brief Performs a software reset on the RTC module.
 427:../drivers/fsl_rtc.h ****  *
 428:../drivers/fsl_rtc.h ****  * This resets all RTC registers except for the SWR bit and the RTC_WAR and RTC_RAR
 429:../drivers/fsl_rtc.h ****  * registers. The SWR bit is cleared by software explicitly clearing it.
 430:../drivers/fsl_rtc.h ****  *
 431:../drivers/fsl_rtc.h ****  * @param base RTC peripheral base address
 432:../drivers/fsl_rtc.h ****  */
 433:../drivers/fsl_rtc.h **** static inline void RTC_Reset(RTC_Type *base)
 434:../drivers/fsl_rtc.h **** {
 435:../drivers/fsl_rtc.h ****     base->CR |= RTC_CR_SWR_MASK;
 836              		.loc 3 435 0
 837 001c 3369     		ldr	r3, [r6, #16]
 838 001e 43F00103 		orr	r3, r3, #1
 839 0022 3361     		str	r3, [r6, #16]
 436:../drivers/fsl_rtc.h ****     base->CR &= ~RTC_CR_SWR_MASK;
 840              		.loc 3 436 0
 841 0024 3369     		ldr	r3, [r6, #16]
 842 0026 23F00103 		bic	r3, r3, #1
 843 002a 3361     		str	r3, [r6, #16]
 437:../drivers/fsl_rtc.h **** 
 438:../drivers/fsl_rtc.h ****     /* Set TSR register to 0x1 to avoid the timer invalid (TIF) bit being set in the SR register */
 439:../drivers/fsl_rtc.h ****     base->TSR = 1U;
 844              		.loc 3 439 0
 845 002c 0123     		movs	r3, #1
 846 002e 3360     		str	r3, [r6]
 847              	.LVL75:
 848              	.L91:
 849              	.LBE11:
 850              	.LBE10:
 233:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION) && FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION
 851              		.loc 1 233 0
 852 0030 6A78     		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 853 0032 A978     		ldrb	r1, [r5, #2]	@ zero_extendqisi2
 230:../drivers/fsl_rtc.c ****     /* Setup the update mode and supervisor access mode */
 854              		.loc 1 230 0
 855 0034 2369     		ldr	r3, [r4, #16]
 856              	.LVL76:
 233:../drivers/fsl_rtc.c **** #if defined(FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION) && FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION
 857              		.loc 1 233 0
 858 0036 D200     		lsls	r2, r2, #3
 859 0038 8900     		lsls	r1, r1, #2
 860 003a 02F00802 		and	r2, r2, #8
 861 003e 01F00401 		and	r1, r1, #4
 862 0042 23F01C03 		bic	r3, r3, #28
 863              	.LVL77:
 864 0046 0A43     		orrs	r2, r2, r1
 236:../drivers/fsl_rtc.c ****     reg |= RTC_CR_WPS(config->wakeupSelect);
 865              		.loc 1 236 0
 866 0048 1A43     		orrs	r2, r2, r3
 867              	.LVL78:
 237:../drivers/fsl_rtc.c **** #endif /* FSL_FEATURE_RTC_HAS_WAKEUP_PIN */
 868              		.loc 1 237 0
 869 004a 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 870 004c 1B01     		lsls	r3, r3, #4
 871 004e 03F01003 		and	r3, r3, #16
 872 0052 1343     		orrs	r3, r3, r2
 873              	.LVL79:
 239:../drivers/fsl_rtc.c **** 
 874              		.loc 1 239 0
 875 0054 2361     		str	r3, [r4, #16]
 242:../drivers/fsl_rtc.c **** 	
 876              		.loc 1 242 0
 877 0056 6B68     		ldr	r3, [r5, #4]
 878              	.LVL80:
 879 0058 2A7A     		ldrb	r2, [r5, #8]	@ zero_extendqisi2
 880 005a 1B02     		lsls	r3, r3, #8
 881 005c 9BB2     		uxth	r3, r3
 882 005e 1343     		orrs	r3, r3, r2
 883 0060 E360     		str	r3, [r4, #12]
 884              	.LVL81:
 885 0062 70BD     		pop	{r4, r5, r6, pc}
 886              	.LVL82:
 887              	.L96:
 888              		.align	2
 889              	.L95:
 890 0064 3C800440 		.word	1074036796
 891 0068 00D00340 		.word	1073991680
 892              		.cfi_endproc
 893              	.LFE156:
 895              		.section	.text.RTC_ClearStatusFlags,"ax",%progbits
 896              		.align	1
 897              		.global	RTC_ClearStatusFlags
 898              		.syntax unified
 899              		.thumb
 900              		.thumb_func
 901              		.fpu fpv4-sp-d16
 903              	RTC_ClearStatusFlags:
 904              	.LFB166:
 583:../drivers/fsl_rtc.c **** 
 584:../drivers/fsl_rtc.c **** void RTC_ClearStatusFlags(RTC_Type *base, uint32_t mask)
 585:../drivers/fsl_rtc.c **** {
 905              		.loc 1 585 0
 906              		.cfi_startproc
 907              		@ args = 0, pretend = 0, frame = 0
 908              		@ frame_needed = 0, uses_anonymous_args = 0
 909              		@ link register save eliminated.
 910              	.LVL83:
 586:../drivers/fsl_rtc.c ****     /* The alarm flag is cleared by writing to the TAR register */
 587:../drivers/fsl_rtc.c ****     if (mask & kRTC_AlarmFlag)
 911              		.loc 1 587 0
 912 0000 4B07     		lsls	r3, r1, #29
 588:../drivers/fsl_rtc.c ****     {
 589:../drivers/fsl_rtc.c ****         base->TAR = 0U;
 913              		.loc 1 589 0
 914 0002 44BF     		itt	mi
 915 0004 0023     		movmi	r3, #0
 916 0006 8360     		strmi	r3, [r0, #8]
 590:../drivers/fsl_rtc.c ****     }
 591:../drivers/fsl_rtc.c **** 
 592:../drivers/fsl_rtc.c ****     /* The timer overflow flag is cleared by initializing the TSR register.
 593:../drivers/fsl_rtc.c ****      * The time counter should be disabled for this write to be successful
 594:../drivers/fsl_rtc.c ****      */
 595:../drivers/fsl_rtc.c ****     if (mask & kRTC_TimeOverflowFlag)
 917              		.loc 1 595 0
 918 0008 8A07     		lsls	r2, r1, #30
 596:../drivers/fsl_rtc.c ****     {
 597:../drivers/fsl_rtc.c ****         base->TSR = 1U;
 919              		.loc 1 597 0
 920 000a 44BF     		itt	mi
 921 000c 0123     		movmi	r3, #1
 922 000e 0360     		strmi	r3, [r0]
 598:../drivers/fsl_rtc.c ****     }
 599:../drivers/fsl_rtc.c **** 
 600:../drivers/fsl_rtc.c ****     /* The timer overflow flag is cleared by initializing the TSR register.
 601:../drivers/fsl_rtc.c ****      * The time counter should be disabled for this write to be successful
 602:../drivers/fsl_rtc.c ****      */
 603:../drivers/fsl_rtc.c ****     if (mask & kRTC_TimeInvalidFlag)
 923              		.loc 1 603 0
 924 0010 CB07     		lsls	r3, r1, #31
 604:../drivers/fsl_rtc.c ****     {
 605:../drivers/fsl_rtc.c ****         base->TSR = 1U;
 925              		.loc 1 605 0
 926 0012 44BF     		itt	mi
 927 0014 0123     		movmi	r3, #1
 928 0016 0360     		strmi	r3, [r0]
 929 0018 7047     		bx	lr
 930              		.cfi_endproc
 931              	.LFE166:
 933              		.section	.rodata
 934              		.align	1
 935              		.set	.LANCHOR0,. + 0
 936              	.LC0:
 937 0000 00       		.byte	0
 938 0001 1F       		.byte	31
 939 0002 1C       		.byte	28
 940 0003 1F       		.byte	31
 941 0004 1E       		.byte	30
 942 0005 1F       		.byte	31
 943 0006 1E       		.byte	30
 944 0007 1F       		.byte	31
 945 0008 1F       		.byte	31
 946 0009 1E       		.byte	30
 947 000a 1F       		.byte	31
 948 000b 1E       		.byte	30
 949 000c 1F       		.byte	31
 950 000d 00       		.space	1
 951              	.LC1:
 952 000e 0000     		.short	0
 953 0010 0000     		.short	0
 954 0012 1F00     		.short	31
 955 0014 3B00     		.short	59
 956 0016 5A00     		.short	90
 957 0018 7800     		.short	120
 958 001a 9700     		.short	151
 959 001c B500     		.short	181
 960 001e D400     		.short	212
 961 0020 F300     		.short	243
 962 0022 1101     		.short	273
 963 0024 3001     		.short	304
 964 0026 4E01     		.short	334
 965              		.text
 966              	.Letext0:
 967              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 968              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 969              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 970              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 971              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 972              		.file 9 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 973              		.file 10 "../CMSIS/core_cm4.h"
 974              		.file 11 "../CMSIS/system_MK64F12.h"
 975              		.file 12 "../CMSIS/MK64F12.h"
 976              		.file 13 "../drivers/fsl_common.h"
