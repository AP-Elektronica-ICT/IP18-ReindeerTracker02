   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_dspi_edma.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.EDMA_SetChannelPreemptionConfig,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	EDMA_SetChannelPreemptionConfig:
  25              	.LFB167:
  26              		.file 1 "../drivers/fsl_edma.h"
   1:../drivers/fsl_edma.h **** /*
   2:../drivers/fsl_edma.h ****  * The Clear BSD License
   3:../drivers/fsl_edma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_edma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_edma.h ****  * All rights reserved.
   6:../drivers/fsl_edma.h ****  *
   7:../drivers/fsl_edma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_edma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_edma.h ****  * that the following conditions are met:
  10:../drivers/fsl_edma.h ****  *
  11:../drivers/fsl_edma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_edma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_edma.h ****  *
  14:../drivers/fsl_edma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_edma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_edma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_edma.h ****  *
  18:../drivers/fsl_edma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_edma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_edma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_edma.h ****  *
  22:../drivers/fsl_edma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_edma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_edma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_edma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_edma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_edma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_edma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_edma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_edma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_edma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_edma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_edma.h ****  */
  34:../drivers/fsl_edma.h **** 
  35:../drivers/fsl_edma.h **** #ifndef _FSL_EDMA_H_
  36:../drivers/fsl_edma.h **** #define _FSL_EDMA_H_
  37:../drivers/fsl_edma.h **** 
  38:../drivers/fsl_edma.h **** #include "fsl_common.h"
  39:../drivers/fsl_edma.h **** 
  40:../drivers/fsl_edma.h **** /*!
  41:../drivers/fsl_edma.h ****  * @addtogroup edma
  42:../drivers/fsl_edma.h ****  * @{
  43:../drivers/fsl_edma.h ****  */
  44:../drivers/fsl_edma.h **** 
  45:../drivers/fsl_edma.h **** /*******************************************************************************
  46:../drivers/fsl_edma.h ****  * Definitions
  47:../drivers/fsl_edma.h ****  ******************************************************************************/
  48:../drivers/fsl_edma.h **** 
  49:../drivers/fsl_edma.h **** /*! @name Driver version */
  50:../drivers/fsl_edma.h **** /*@{*/
  51:../drivers/fsl_edma.h **** /*! @brief eDMA driver version */
  52:../drivers/fsl_edma.h **** #define FSL_EDMA_DRIVER_VERSION (MAKE_VERSION(2, 1, 2)) /*!< Version 2.1.2. */
  53:../drivers/fsl_edma.h **** /*@}*/
  54:../drivers/fsl_edma.h **** 
  55:../drivers/fsl_edma.h **** /*! @brief Compute the offset unit from DCHPRI3 */
  56:../drivers/fsl_edma.h **** #define DMA_DCHPRI_INDEX(channel) (((channel) & ~0x03U) | (3 - ((channel)&0x03U)))
  57:../drivers/fsl_edma.h **** 
  58:../drivers/fsl_edma.h **** /*! @brief Get the pointer of DCHPRIn */
  59:../drivers/fsl_edma.h **** #define DMA_DCHPRIn(base, channel) ((volatile uint8_t *)&(base->DCHPRI3))[DMA_DCHPRI_INDEX(channel)
  60:../drivers/fsl_edma.h **** 
  61:../drivers/fsl_edma.h **** /*! @brief eDMA transfer configuration */
  62:../drivers/fsl_edma.h **** typedef enum _edma_transfer_size
  63:../drivers/fsl_edma.h **** {
  64:../drivers/fsl_edma.h ****     kEDMA_TransferSize1Bytes = 0x0U,  /*!< Source/Destination data transfer size is 1 byte every ti
  65:../drivers/fsl_edma.h ****     kEDMA_TransferSize2Bytes = 0x1U,  /*!< Source/Destination data transfer size is 2 bytes every t
  66:../drivers/fsl_edma.h ****     kEDMA_TransferSize4Bytes = 0x2U,  /*!< Source/Destination data transfer size is 4 bytes every t
  67:../drivers/fsl_edma.h ****     kEDMA_TransferSize16Bytes = 0x4U, /*!< Source/Destination data transfer size is 16 bytes every 
  68:../drivers/fsl_edma.h ****     kEDMA_TransferSize32Bytes = 0x5U, /*!< Source/Destination data transfer size is 32 bytes every 
  69:../drivers/fsl_edma.h **** } edma_transfer_size_t;
  70:../drivers/fsl_edma.h **** 
  71:../drivers/fsl_edma.h **** /*! @brief eDMA modulo configuration */
  72:../drivers/fsl_edma.h **** typedef enum _edma_modulo
  73:../drivers/fsl_edma.h **** {
  74:../drivers/fsl_edma.h ****     kEDMA_ModuloDisable = 0x0U, /*!< Disable modulo */
  75:../drivers/fsl_edma.h ****     kEDMA_Modulo2bytes,         /*!< Circular buffer size is 2 bytes. */
  76:../drivers/fsl_edma.h ****     kEDMA_Modulo4bytes,         /*!< Circular buffer size is 4 bytes. */
  77:../drivers/fsl_edma.h ****     kEDMA_Modulo8bytes,         /*!< Circular buffer size is 8 bytes. */
  78:../drivers/fsl_edma.h ****     kEDMA_Modulo16bytes,        /*!< Circular buffer size is 16 bytes. */
  79:../drivers/fsl_edma.h ****     kEDMA_Modulo32bytes,        /*!< Circular buffer size is 32 bytes. */
  80:../drivers/fsl_edma.h ****     kEDMA_Modulo64bytes,        /*!< Circular buffer size is 64 bytes. */
  81:../drivers/fsl_edma.h ****     kEDMA_Modulo128bytes,       /*!< Circular buffer size is 128 bytes. */
  82:../drivers/fsl_edma.h ****     kEDMA_Modulo256bytes,       /*!< Circular buffer size is 256 bytes. */
  83:../drivers/fsl_edma.h ****     kEDMA_Modulo512bytes,       /*!< Circular buffer size is 512 bytes. */
  84:../drivers/fsl_edma.h ****     kEDMA_Modulo1Kbytes,        /*!< Circular buffer size is 1 K bytes. */
  85:../drivers/fsl_edma.h ****     kEDMA_Modulo2Kbytes,        /*!< Circular buffer size is 2 K bytes. */
  86:../drivers/fsl_edma.h ****     kEDMA_Modulo4Kbytes,        /*!< Circular buffer size is 4 K bytes. */
  87:../drivers/fsl_edma.h ****     kEDMA_Modulo8Kbytes,        /*!< Circular buffer size is 8 K bytes. */
  88:../drivers/fsl_edma.h ****     kEDMA_Modulo16Kbytes,       /*!< Circular buffer size is 16 K bytes. */
  89:../drivers/fsl_edma.h ****     kEDMA_Modulo32Kbytes,       /*!< Circular buffer size is 32 K bytes. */
  90:../drivers/fsl_edma.h ****     kEDMA_Modulo64Kbytes,       /*!< Circular buffer size is 64 K bytes. */
  91:../drivers/fsl_edma.h ****     kEDMA_Modulo128Kbytes,      /*!< Circular buffer size is 128 K bytes. */
  92:../drivers/fsl_edma.h ****     kEDMA_Modulo256Kbytes,      /*!< Circular buffer size is 256 K bytes. */
  93:../drivers/fsl_edma.h ****     kEDMA_Modulo512Kbytes,      /*!< Circular buffer size is 512 K bytes. */
  94:../drivers/fsl_edma.h ****     kEDMA_Modulo1Mbytes,        /*!< Circular buffer size is 1 M bytes. */
  95:../drivers/fsl_edma.h ****     kEDMA_Modulo2Mbytes,        /*!< Circular buffer size is 2 M bytes. */
  96:../drivers/fsl_edma.h ****     kEDMA_Modulo4Mbytes,        /*!< Circular buffer size is 4 M bytes. */
  97:../drivers/fsl_edma.h ****     kEDMA_Modulo8Mbytes,        /*!< Circular buffer size is 8 M bytes. */
  98:../drivers/fsl_edma.h ****     kEDMA_Modulo16Mbytes,       /*!< Circular buffer size is 16 M bytes. */
  99:../drivers/fsl_edma.h ****     kEDMA_Modulo32Mbytes,       /*!< Circular buffer size is 32 M bytes. */
 100:../drivers/fsl_edma.h ****     kEDMA_Modulo64Mbytes,       /*!< Circular buffer size is 64 M bytes. */
 101:../drivers/fsl_edma.h ****     kEDMA_Modulo128Mbytes,      /*!< Circular buffer size is 128 M bytes. */
 102:../drivers/fsl_edma.h ****     kEDMA_Modulo256Mbytes,      /*!< Circular buffer size is 256 M bytes. */
 103:../drivers/fsl_edma.h ****     kEDMA_Modulo512Mbytes,      /*!< Circular buffer size is 512 M bytes. */
 104:../drivers/fsl_edma.h ****     kEDMA_Modulo1Gbytes,        /*!< Circular buffer size is 1 G bytes. */
 105:../drivers/fsl_edma.h ****     kEDMA_Modulo2Gbytes,        /*!< Circular buffer size is 2 G bytes. */
 106:../drivers/fsl_edma.h **** } edma_modulo_t;
 107:../drivers/fsl_edma.h **** 
 108:../drivers/fsl_edma.h **** /*! @brief Bandwidth control */
 109:../drivers/fsl_edma.h **** typedef enum _edma_bandwidth
 110:../drivers/fsl_edma.h **** {
 111:../drivers/fsl_edma.h ****     kEDMA_BandwidthStallNone = 0x0U,   /*!< No eDMA engine stalls. */
 112:../drivers/fsl_edma.h ****     kEDMA_BandwidthStall4Cycle = 0x2U, /*!< eDMA engine stalls for 4 cycles after each read/write. 
 113:../drivers/fsl_edma.h ****     kEDMA_BandwidthStall8Cycle = 0x3U, /*!< eDMA engine stalls for 8 cycles after each read/write. 
 114:../drivers/fsl_edma.h **** } edma_bandwidth_t;
 115:../drivers/fsl_edma.h **** 
 116:../drivers/fsl_edma.h **** /*! @brief Channel link type */
 117:../drivers/fsl_edma.h **** typedef enum _edma_channel_link_type
 118:../drivers/fsl_edma.h **** {
 119:../drivers/fsl_edma.h ****     kEDMA_LinkNone = 0x0U, /*!< No channel link  */
 120:../drivers/fsl_edma.h ****     kEDMA_MinorLink,       /*!< Channel link after each minor loop */
 121:../drivers/fsl_edma.h ****     kEDMA_MajorLink,       /*!< Channel link while major loop count exhausted */
 122:../drivers/fsl_edma.h **** } edma_channel_link_type_t;
 123:../drivers/fsl_edma.h **** 
 124:../drivers/fsl_edma.h **** /*!@brief eDMA channel status flags. */
 125:../drivers/fsl_edma.h **** enum _edma_channel_status_flags
 126:../drivers/fsl_edma.h **** {
 127:../drivers/fsl_edma.h ****     kEDMA_DoneFlag = 0x1U,      /*!< DONE flag, set while transfer finished, CITER value exhausted*
 128:../drivers/fsl_edma.h ****     kEDMA_ErrorFlag = 0x2U,     /*!< eDMA error flag, an error occurred in a transfer */
 129:../drivers/fsl_edma.h ****     kEDMA_InterruptFlag = 0x4U, /*!< eDMA interrupt flag, set while an interrupt occurred of this c
 130:../drivers/fsl_edma.h **** };
 131:../drivers/fsl_edma.h **** 
 132:../drivers/fsl_edma.h **** /*! @brief eDMA channel error status flags. */
 133:../drivers/fsl_edma.h **** enum _edma_error_status_flags
 134:../drivers/fsl_edma.h **** {
 135:../drivers/fsl_edma.h ****     kEDMA_DestinationBusErrorFlag = DMA_ES_DBE_MASK,    /*!< Bus error on destination address */
 136:../drivers/fsl_edma.h ****     kEDMA_SourceBusErrorFlag = DMA_ES_SBE_MASK,         /*!< Bus error on the source address */
 137:../drivers/fsl_edma.h ****     kEDMA_ScatterGatherErrorFlag = DMA_ES_SGE_MASK,     /*!< Error on the Scatter/Gather address, n
 138:../drivers/fsl_edma.h ****     kEDMA_NbytesErrorFlag = DMA_ES_NCE_MASK,            /*!< NBYTES/CITER configuration error */
 139:../drivers/fsl_edma.h ****     kEDMA_DestinationOffsetErrorFlag = DMA_ES_DOE_MASK, /*!< Destination offset not aligned with de
 140:../drivers/fsl_edma.h ****     kEDMA_DestinationAddressErrorFlag = DMA_ES_DAE_MASK, /*!< Destination address not aligned with 
 141:../drivers/fsl_edma.h ****     kEDMA_SourceOffsetErrorFlag = DMA_ES_SOE_MASK,       /*!< Source offset not aligned with source
 142:../drivers/fsl_edma.h ****     kEDMA_SourceAddressErrorFlag = DMA_ES_SAE_MASK,      /*!< Source address not aligned with sourc
 143:../drivers/fsl_edma.h ****     kEDMA_ErrorChannelFlag = DMA_ES_ERRCHN_MASK,         /*!< Error channel number of the cancelled
 144:../drivers/fsl_edma.h ****     kEDMA_ChannelPriorityErrorFlag = DMA_ES_CPE_MASK,    /*!< Channel priority is not unique. */
 145:../drivers/fsl_edma.h ****     kEDMA_TransferCanceledFlag = DMA_ES_ECX_MASK,        /*!< Transfer cancelled */
 146:../drivers/fsl_edma.h **** #if defined(FSL_FEATURE_EDMA_CHANNEL_GROUP_COUNT) && FSL_FEATURE_EDMA_CHANNEL_GROUP_COUNT > 1
 147:../drivers/fsl_edma.h ****     kEDMA_GroupPriorityErrorFlag = DMA_ES_GPE_MASK, /*!< Group priority is not unique. */
 148:../drivers/fsl_edma.h **** #endif
 149:../drivers/fsl_edma.h ****     kEDMA_ValidFlag = DMA_ES_VLD_MASK, /*!< No error occurred, this bit is 0. Otherwise, it is 1. *
 150:../drivers/fsl_edma.h **** };
 151:../drivers/fsl_edma.h **** 
 152:../drivers/fsl_edma.h **** /*! @brief eDMA interrupt source */
 153:../drivers/fsl_edma.h **** typedef enum _edma_interrupt_enable
 154:../drivers/fsl_edma.h **** {
 155:../drivers/fsl_edma.h ****     kEDMA_ErrorInterruptEnable = 0x1U,                  /*!< Enable interrupt while channel error o
 156:../drivers/fsl_edma.h ****     kEDMA_MajorInterruptEnable = DMA_CSR_INTMAJOR_MASK, /*!< Enable interrupt while major count exh
 157:../drivers/fsl_edma.h ****     kEDMA_HalfInterruptEnable = DMA_CSR_INTHALF_MASK,   /*!< Enable interrupt while major count to 
 158:../drivers/fsl_edma.h **** } edma_interrupt_enable_t;
 159:../drivers/fsl_edma.h **** 
 160:../drivers/fsl_edma.h **** /*! @brief eDMA transfer type */
 161:../drivers/fsl_edma.h **** typedef enum _edma_transfer_type
 162:../drivers/fsl_edma.h **** {
 163:../drivers/fsl_edma.h ****     kEDMA_MemoryToMemory = 0x0U, /*!< Transfer from memory to memory */
 164:../drivers/fsl_edma.h ****     kEDMA_PeripheralToMemory,    /*!< Transfer from peripheral to memory */
 165:../drivers/fsl_edma.h ****     kEDMA_MemoryToPeripheral,    /*!< Transfer from memory to peripheral */
 166:../drivers/fsl_edma.h **** } edma_transfer_type_t;
 167:../drivers/fsl_edma.h **** 
 168:../drivers/fsl_edma.h **** /*! @brief eDMA transfer status */
 169:../drivers/fsl_edma.h **** enum _edma_transfer_status
 170:../drivers/fsl_edma.h **** {
 171:../drivers/fsl_edma.h ****     kStatus_EDMA_QueueFull = MAKE_STATUS(kStatusGroup_EDMA, 0), /*!< TCD queue is full. */
 172:../drivers/fsl_edma.h ****     kStatus_EDMA_Busy = MAKE_STATUS(kStatusGroup_EDMA, 1),      /*!< Channel is busy and can't hand
 173:../drivers/fsl_edma.h ****                                                                      transfer request. */
 174:../drivers/fsl_edma.h **** };
 175:../drivers/fsl_edma.h **** 
 176:../drivers/fsl_edma.h **** /*! @brief eDMA global configuration structure.*/
 177:../drivers/fsl_edma.h **** typedef struct _edma_config
 178:../drivers/fsl_edma.h **** {
 179:../drivers/fsl_edma.h ****     bool enableContinuousLinkMode;    /*!< Enable (true) continuous link mode. Upon minor loop comp
 180:../drivers/fsl_edma.h ****                                            activates again if that channel has a minor loop channel
 181:../drivers/fsl_edma.h ****                                            the link channel is itself. */
 182:../drivers/fsl_edma.h ****     bool enableHaltOnError;           /*!< Enable (true) transfer halt on error. Any error causes t
 183:../drivers/fsl_edma.h ****                                            Subsequently, all service requests are ignored until the
 184:../drivers/fsl_edma.h ****     bool enableRoundRobinArbitration; /*!< Enable (true) round robin channel arbitration method or 
 185:../drivers/fsl_edma.h ****                                            arbitration is used for channel selection */
 186:../drivers/fsl_edma.h ****     bool enableDebugMode; /*!< Enable(true) eDMA debug mode. When in debug mode, the eDMA stalls th
 187:../drivers/fsl_edma.h ****                                a new channel. Executing channels are allowed to complete. */
 188:../drivers/fsl_edma.h **** } edma_config_t;
 189:../drivers/fsl_edma.h **** 
 190:../drivers/fsl_edma.h **** /*!
 191:../drivers/fsl_edma.h ****  * @brief eDMA transfer configuration
 192:../drivers/fsl_edma.h ****  *
 193:../drivers/fsl_edma.h ****  * This structure configures the source/destination transfer attribute.
 194:../drivers/fsl_edma.h ****  */
 195:../drivers/fsl_edma.h **** typedef struct _edma_transfer_config
 196:../drivers/fsl_edma.h **** {
 197:../drivers/fsl_edma.h ****     uint32_t srcAddr;                      /*!< Source data address. */
 198:../drivers/fsl_edma.h ****     uint32_t destAddr;                     /*!< Destination data address. */
 199:../drivers/fsl_edma.h ****     edma_transfer_size_t srcTransferSize;  /*!< Source data transfer size. */
 200:../drivers/fsl_edma.h ****     edma_transfer_size_t destTransferSize; /*!< Destination data transfer size. */
 201:../drivers/fsl_edma.h ****     int16_t srcOffset;                     /*!< Sign-extended offset applied to the current source 
 202:../drivers/fsl_edma.h ****                                                 form the next-state value as each source read is co
 203:../drivers/fsl_edma.h ****     int16_t destOffset;                    /*!< Sign-extended offset applied to the current destina
 204:../drivers/fsl_edma.h ****                                                 form the next-state value as each destination write
 205:../drivers/fsl_edma.h ****     uint32_t minorLoopBytes;               /*!< Bytes to transfer in a minor loop*/
 206:../drivers/fsl_edma.h ****     uint32_t majorLoopCounts;              /*!< Major loop iteration count. */
 207:../drivers/fsl_edma.h **** } edma_transfer_config_t;
 208:../drivers/fsl_edma.h **** 
 209:../drivers/fsl_edma.h **** /*! @brief eDMA channel priority configuration */
 210:../drivers/fsl_edma.h **** typedef struct _edma_channel_Preemption_config
 211:../drivers/fsl_edma.h **** {
 212:../drivers/fsl_edma.h ****     bool enableChannelPreemption; /*!< If true: a channel can be suspended by other channel with hi
 213:../drivers/fsl_edma.h ****     bool enablePreemptAbility;    /*!< If true: a channel can suspend other channel with low priori
 214:../drivers/fsl_edma.h ****     uint8_t channelPriority;      /*!< Channel priority */
 215:../drivers/fsl_edma.h **** } edma_channel_Preemption_config_t;
 216:../drivers/fsl_edma.h **** 
 217:../drivers/fsl_edma.h **** /*! @brief eDMA minor offset configuration */
 218:../drivers/fsl_edma.h **** typedef struct _edma_minor_offset_config
 219:../drivers/fsl_edma.h **** {
 220:../drivers/fsl_edma.h ****     bool enableSrcMinorOffset;  /*!< Enable(true) or Disable(false) source minor loop offset. */
 221:../drivers/fsl_edma.h ****     bool enableDestMinorOffset; /*!< Enable(true) or Disable(false) destination minor loop offset. 
 222:../drivers/fsl_edma.h ****     uint32_t minorOffset;       /*!< Offset for a minor loop mapping. */
 223:../drivers/fsl_edma.h **** } edma_minor_offset_config_t;
 224:../drivers/fsl_edma.h **** 
 225:../drivers/fsl_edma.h **** /*!
 226:../drivers/fsl_edma.h ****  * @brief eDMA TCD.
 227:../drivers/fsl_edma.h ****  *
 228:../drivers/fsl_edma.h ****  * This structure is same as TCD register which is described in reference manual,
 229:../drivers/fsl_edma.h ****  * and is used to configure the scatter/gather feature as a next hardware TCD.
 230:../drivers/fsl_edma.h ****  */
 231:../drivers/fsl_edma.h **** typedef struct _edma_tcd
 232:../drivers/fsl_edma.h **** {
 233:../drivers/fsl_edma.h ****     __IO uint32_t SADDR;     /*!< SADDR register, used to save source address */
 234:../drivers/fsl_edma.h ****     __IO uint16_t SOFF;      /*!< SOFF register, save offset bytes every transfer */
 235:../drivers/fsl_edma.h ****     __IO uint16_t ATTR;      /*!< ATTR register, source/destination transfer size and modulo */
 236:../drivers/fsl_edma.h ****     __IO uint32_t NBYTES;    /*!< Nbytes register, minor loop length in bytes */
 237:../drivers/fsl_edma.h ****     __IO uint32_t SLAST;     /*!< SLAST register */
 238:../drivers/fsl_edma.h ****     __IO uint32_t DADDR;     /*!< DADDR register, used for destination address */
 239:../drivers/fsl_edma.h ****     __IO uint16_t DOFF;      /*!< DOFF register, used for destination offset */
 240:../drivers/fsl_edma.h ****     __IO uint16_t CITER;     /*!< CITER register, current minor loop numbers, for unfinished minor 
 241:../drivers/fsl_edma.h ****     __IO uint32_t DLAST_SGA; /*!< DLASTSGA register, next stcd address used in scatter-gather mode 
 242:../drivers/fsl_edma.h ****     __IO uint16_t CSR;       /*!< CSR register, for TCD control status */
 243:../drivers/fsl_edma.h ****     __IO uint16_t BITER;     /*!< BITER register, begin minor loop count. */
 244:../drivers/fsl_edma.h **** } edma_tcd_t;
 245:../drivers/fsl_edma.h **** 
 246:../drivers/fsl_edma.h **** /*! @brief Callback for eDMA */
 247:../drivers/fsl_edma.h **** struct _edma_handle;
 248:../drivers/fsl_edma.h **** 
 249:../drivers/fsl_edma.h **** /*! @brief Define callback function for eDMA. */
 250:../drivers/fsl_edma.h **** typedef void (*edma_callback)(struct _edma_handle *handle, void *userData, bool transferDone, uint3
 251:../drivers/fsl_edma.h **** 
 252:../drivers/fsl_edma.h **** /*! @brief eDMA transfer handle structure */
 253:../drivers/fsl_edma.h **** typedef struct _edma_handle
 254:../drivers/fsl_edma.h **** {
 255:../drivers/fsl_edma.h ****     edma_callback callback; /*!< Callback function for major count exhausted. */
 256:../drivers/fsl_edma.h ****     void *userData;         /*!< Callback function parameter. */
 257:../drivers/fsl_edma.h ****     DMA_Type *base;         /*!< eDMA peripheral base address. */
 258:../drivers/fsl_edma.h ****     edma_tcd_t *tcdPool;    /*!< Pointer to memory stored TCDs. */
 259:../drivers/fsl_edma.h ****     uint8_t channel;        /*!< eDMA channel number. */
 260:../drivers/fsl_edma.h ****     volatile int8_t header; /*!< The first TCD index. Should point to the next TCD to be loaded int
 261:../drivers/fsl_edma.h ****     volatile int8_t tail;   /*!< The last TCD index. Should point to the next TCD to be stored into
 262:../drivers/fsl_edma.h ****     volatile int8_t tcdUsed; /*!< The number of used TCD slots. Should reflect the number of TCDs c
 263:../drivers/fsl_edma.h ****                                 the memory. */
 264:../drivers/fsl_edma.h ****     volatile int8_t tcdSize; /*!< The total number of TCD slots in the queue. */
 265:../drivers/fsl_edma.h ****     uint8_t flags;           /*!< The status of the current channel. */
 266:../drivers/fsl_edma.h **** } edma_handle_t;
 267:../drivers/fsl_edma.h **** 
 268:../drivers/fsl_edma.h **** /*******************************************************************************
 269:../drivers/fsl_edma.h ****  * APIs
 270:../drivers/fsl_edma.h ****  ******************************************************************************/
 271:../drivers/fsl_edma.h **** #if defined(__cplusplus)
 272:../drivers/fsl_edma.h **** extern "C" {
 273:../drivers/fsl_edma.h **** #endif /* __cplusplus */
 274:../drivers/fsl_edma.h **** 
 275:../drivers/fsl_edma.h **** /*!
 276:../drivers/fsl_edma.h ****  * @name eDMA initialization and de-initialization
 277:../drivers/fsl_edma.h ****  * @{
 278:../drivers/fsl_edma.h ****  */
 279:../drivers/fsl_edma.h **** 
 280:../drivers/fsl_edma.h **** /*!
 281:../drivers/fsl_edma.h ****  * @brief Initializes the eDMA peripheral.
 282:../drivers/fsl_edma.h ****  *
 283:../drivers/fsl_edma.h ****  * This function ungates the eDMA clock and configures the eDMA peripheral according
 284:../drivers/fsl_edma.h ****  * to the configuration structure.
 285:../drivers/fsl_edma.h ****  *
 286:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 287:../drivers/fsl_edma.h ****  * @param config A pointer to the configuration structure, see "edma_config_t".
 288:../drivers/fsl_edma.h ****  * @note This function enables the minor loop map feature.
 289:../drivers/fsl_edma.h ****  */
 290:../drivers/fsl_edma.h **** void EDMA_Init(DMA_Type *base, const edma_config_t *config);
 291:../drivers/fsl_edma.h **** 
 292:../drivers/fsl_edma.h **** /*!
 293:../drivers/fsl_edma.h ****  * @brief Deinitializes the eDMA peripheral.
 294:../drivers/fsl_edma.h ****  *
 295:../drivers/fsl_edma.h ****  * This function gates the eDMA clock.
 296:../drivers/fsl_edma.h ****  *
 297:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 298:../drivers/fsl_edma.h ****  */
 299:../drivers/fsl_edma.h **** void EDMA_Deinit(DMA_Type *base);
 300:../drivers/fsl_edma.h **** 
 301:../drivers/fsl_edma.h **** /*!
 302:../drivers/fsl_edma.h ****  * @brief Push content of TCD structure into hardware TCD register.
 303:../drivers/fsl_edma.h ****  *
 304:../drivers/fsl_edma.h ****  * @param base EDMA peripheral base address.
 305:../drivers/fsl_edma.h ****  * @param channel EDMA channel number.
 306:../drivers/fsl_edma.h ****  * @param tcd Point to TCD structure.
 307:../drivers/fsl_edma.h ****  */
 308:../drivers/fsl_edma.h **** void EDMA_InstallTCD(DMA_Type *base, uint32_t channel, edma_tcd_t *tcd);
 309:../drivers/fsl_edma.h **** 
 310:../drivers/fsl_edma.h **** /*!
 311:../drivers/fsl_edma.h ****  * @brief Gets the eDMA default configuration structure.
 312:../drivers/fsl_edma.h ****  *
 313:../drivers/fsl_edma.h ****  * This function sets the configuration structure to default values.
 314:../drivers/fsl_edma.h ****  * The default configuration is set to the following values.
 315:../drivers/fsl_edma.h ****  * @code
 316:../drivers/fsl_edma.h ****  *   config.enableContinuousLinkMode = false;
 317:../drivers/fsl_edma.h ****  *   config.enableHaltOnError = true;
 318:../drivers/fsl_edma.h ****  *   config.enableRoundRobinArbitration = false;
 319:../drivers/fsl_edma.h ****  *   config.enableDebugMode = false;
 320:../drivers/fsl_edma.h ****  * @endcode
 321:../drivers/fsl_edma.h ****  *
 322:../drivers/fsl_edma.h ****  * @param config A pointer to the eDMA configuration structure.
 323:../drivers/fsl_edma.h ****  */
 324:../drivers/fsl_edma.h **** void EDMA_GetDefaultConfig(edma_config_t *config);
 325:../drivers/fsl_edma.h **** 
 326:../drivers/fsl_edma.h **** /* @} */
 327:../drivers/fsl_edma.h **** /*!
 328:../drivers/fsl_edma.h ****  * @name eDMA Channel Operation
 329:../drivers/fsl_edma.h ****  * @{
 330:../drivers/fsl_edma.h ****  */
 331:../drivers/fsl_edma.h **** 
 332:../drivers/fsl_edma.h **** /*!
 333:../drivers/fsl_edma.h ****  * @brief Sets all TCD registers to default values.
 334:../drivers/fsl_edma.h ****  *
 335:../drivers/fsl_edma.h ****  * This function sets TCD registers for this channel to default values.
 336:../drivers/fsl_edma.h ****  *
 337:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 338:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 339:../drivers/fsl_edma.h ****  * @note This function must not be called while the channel transfer is ongoing
 340:../drivers/fsl_edma.h ****  *       or it causes unpredictable results.
 341:../drivers/fsl_edma.h ****  * @note This function enables the auto stop request feature.
 342:../drivers/fsl_edma.h ****  */
 343:../drivers/fsl_edma.h **** void EDMA_ResetChannel(DMA_Type *base, uint32_t channel);
 344:../drivers/fsl_edma.h **** 
 345:../drivers/fsl_edma.h **** /*!
 346:../drivers/fsl_edma.h ****  * @brief Configures the eDMA transfer attribute.
 347:../drivers/fsl_edma.h ****  *
 348:../drivers/fsl_edma.h ****  * This function configures the transfer attribute, including source address, destination address,
 349:../drivers/fsl_edma.h ****  * transfer size, address offset, and so on. It also configures the scatter gather feature if the
 350:../drivers/fsl_edma.h ****  * user supplies the TCD address.
 351:../drivers/fsl_edma.h ****  * Example:
 352:../drivers/fsl_edma.h ****  * @code
 353:../drivers/fsl_edma.h ****  *  edma_transfer_t config;
 354:../drivers/fsl_edma.h ****  *  edma_tcd_t tcd;
 355:../drivers/fsl_edma.h ****  *  config.srcAddr = ..;
 356:../drivers/fsl_edma.h ****  *  config.destAddr = ..;
 357:../drivers/fsl_edma.h ****  *  ...
 358:../drivers/fsl_edma.h ****  *  EDMA_SetTransferConfig(DMA0, channel, &config, &stcd);
 359:../drivers/fsl_edma.h ****  * @endcode
 360:../drivers/fsl_edma.h ****  *
 361:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 362:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 363:../drivers/fsl_edma.h ****  * @param config Pointer to eDMA transfer configuration structure.
 364:../drivers/fsl_edma.h ****  * @param nextTcd Point to TCD structure. It can be NULL if users
 365:../drivers/fsl_edma.h ****  *                do not want to enable scatter/gather feature.
 366:../drivers/fsl_edma.h ****  * @note If nextTcd is not NULL, it means scatter gather feature is enabled
 367:../drivers/fsl_edma.h ****  *       and DREQ bit is cleared in the previous transfer configuration, which
 368:../drivers/fsl_edma.h ****  *       is set in the eDMA_ResetChannel.
 369:../drivers/fsl_edma.h ****  */
 370:../drivers/fsl_edma.h **** void EDMA_SetTransferConfig(DMA_Type *base,
 371:../drivers/fsl_edma.h ****                             uint32_t channel,
 372:../drivers/fsl_edma.h ****                             const edma_transfer_config_t *config,
 373:../drivers/fsl_edma.h ****                             edma_tcd_t *nextTcd);
 374:../drivers/fsl_edma.h **** 
 375:../drivers/fsl_edma.h **** /*!
 376:../drivers/fsl_edma.h ****  * @brief Configures the eDMA minor offset feature.
 377:../drivers/fsl_edma.h ****  *
 378:../drivers/fsl_edma.h ****  * The minor offset means that the signed-extended value is added to the source address or destinat
 379:../drivers/fsl_edma.h ****  * address after each minor loop.
 380:../drivers/fsl_edma.h ****  *
 381:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 382:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 383:../drivers/fsl_edma.h ****  * @param config A pointer to the minor offset configuration structure.
 384:../drivers/fsl_edma.h ****  */
 385:../drivers/fsl_edma.h **** void EDMA_SetMinorOffsetConfig(DMA_Type *base, uint32_t channel, const edma_minor_offset_config_t *
 386:../drivers/fsl_edma.h **** 
 387:../drivers/fsl_edma.h **** /*!
 388:../drivers/fsl_edma.h ****  * @brief Configures the eDMA channel preemption feature.
 389:../drivers/fsl_edma.h ****  *
 390:../drivers/fsl_edma.h ****  * This function configures the channel preemption attribute and the priority of the channel.
 391:../drivers/fsl_edma.h ****  *
 392:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 393:../drivers/fsl_edma.h ****  * @param channel eDMA channel number
 394:../drivers/fsl_edma.h ****  * @param config A pointer to the channel preemption configuration structure.
 395:../drivers/fsl_edma.h ****  */
 396:../drivers/fsl_edma.h **** static inline void EDMA_SetChannelPreemptionConfig(DMA_Type *base,
 397:../drivers/fsl_edma.h ****                                                    uint32_t channel,
 398:../drivers/fsl_edma.h ****                                                    const edma_channel_Preemption_config_t *config)
 399:../drivers/fsl_edma.h **** {
  27              		.loc 1 399 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 10B5     		push	{r4, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 4, -8
  35              		.cfi_offset 14, -4
 400:../drivers/fsl_edma.h ****     assert(channel < FSL_FEATURE_EDMA_MODULE_CHANNEL);
 401:../drivers/fsl_edma.h ****     assert(config != NULL);
 402:../drivers/fsl_edma.h **** 
 403:../drivers/fsl_edma.h ****     DMA_DCHPRIn(base, channel) =
 404:../drivers/fsl_edma.h ****         (DMA_DCHPRI0_DPA(!config->enablePreemptAbility) | DMA_DCHPRI0_ECP(config->enableChannelPree
  36              		.loc 1 404 0
  37 0002 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
  38 0004 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
 405:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  39              		.loc 1 405 0
  40 0006 9278     		ldrb	r2, [r2, #2]	@ zero_extendqisi2
  41              	.LVL1:
 404:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  42              		.loc 1 404 0
  43 0008 002B     		cmp	r3, #0
  44              		.loc 1 405 0
  45 000a 02F00F02 		and	r2, r2, #15
 404:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  46              		.loc 1 404 0
  47 000e 0CBF     		ite	eq
  48 0010 4023     		moveq	r3, #64
  49 0012 0023     		movne	r3, #0
  50 0014 42EAC412 		orr	r2, r2, r4, lsl #7
 403:../drivers/fsl_edma.h ****         (DMA_DCHPRI0_DPA(!config->enablePreemptAbility) | DMA_DCHPRI0_ECP(config->enableChannelPree
  51              		.loc 1 403 0
  52 0018 00F58070 		add	r0, r0, #256
  53              	.LVL2:
  54 001c 81F00301 		eor	r1, r1, #3
  55              	.LVL3:
 404:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  56              		.loc 1 404 0
  57 0020 1343     		orrs	r3, r3, r2
  58 0022 DBB2     		uxtb	r3, r3
 403:../drivers/fsl_edma.h ****         (DMA_DCHPRI0_DPA(!config->enablePreemptAbility) | DMA_DCHPRI0_ECP(config->enableChannelPree
  59              		.loc 1 403 0
  60 0024 4354     		strb	r3, [r0, r1]
 406:../drivers/fsl_edma.h **** }
  61              		.loc 1 406 0
  62 0026 10BD     		pop	{r4, pc}
  63              		.cfi_endproc
  64              	.LFE167:
  66              		.section	.text.EDMA_DspiMasterCallback,"ax",%progbits
  67              		.align	1
  68              		.syntax unified
  69              		.thumb
  70              		.thumb_func
  71              		.fpu fpv4-sp-d16
  73              	EDMA_DspiMasterCallback:
  74              	.LFB180:
  75              		.file 2 "../drivers/fsl_dspi_edma.c"
   1:../drivers/fsl_dspi_edma.c **** /*
   2:../drivers/fsl_dspi_edma.c ****  * The Clear BSD License
   3:../drivers/fsl_dspi_edma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dspi_edma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dspi_edma.c ****  * All rights reserved.
   6:../drivers/fsl_dspi_edma.c ****  *
   7:../drivers/fsl_dspi_edma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dspi_edma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dspi_edma.c ****  * that the following conditions are met:
  10:../drivers/fsl_dspi_edma.c ****  *
  11:../drivers/fsl_dspi_edma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dspi_edma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dspi_edma.c ****  *
  14:../drivers/fsl_dspi_edma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dspi_edma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dspi_edma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dspi_edma.c ****  *
  18:../drivers/fsl_dspi_edma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dspi_edma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dspi_edma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_dspi_edma.c ****  *
  22:../drivers/fsl_dspi_edma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dspi_edma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dspi_edma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dspi_edma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dspi_edma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dspi_edma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dspi_edma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dspi_edma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dspi_edma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dspi_edma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dspi_edma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dspi_edma.c ****  */
  34:../drivers/fsl_dspi_edma.c **** 
  35:../drivers/fsl_dspi_edma.c **** #include "fsl_dspi_edma.h"
  36:../drivers/fsl_dspi_edma.c **** 
  37:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  38:../drivers/fsl_dspi_edma.c **** * Definitons
  39:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
  40:../drivers/fsl_dspi_edma.c **** 
  41:../drivers/fsl_dspi_edma.c **** /*!
  42:../drivers/fsl_dspi_edma.c **** * @brief Structure definition for dspi_master_edma_private_handle_t. The structure is private.
  43:../drivers/fsl_dspi_edma.c **** */
  44:../drivers/fsl_dspi_edma.c **** typedef struct _dspi_master_edma_private_handle
  45:../drivers/fsl_dspi_edma.c **** {
  46:../drivers/fsl_dspi_edma.c ****     SPI_Type *base;                    /*!< DSPI peripheral base address. */
  47:../drivers/fsl_dspi_edma.c ****     dspi_master_edma_handle_t *handle; /*!< dspi_master_edma_handle_t handle */
  48:../drivers/fsl_dspi_edma.c **** } dspi_master_edma_private_handle_t;
  49:../drivers/fsl_dspi_edma.c **** 
  50:../drivers/fsl_dspi_edma.c **** /*!
  51:../drivers/fsl_dspi_edma.c **** * @brief Structure definition for dspi_slave_edma_private_handle_t. The structure is private.
  52:../drivers/fsl_dspi_edma.c **** */
  53:../drivers/fsl_dspi_edma.c **** typedef struct _dspi_slave_edma_private_handle
  54:../drivers/fsl_dspi_edma.c **** {
  55:../drivers/fsl_dspi_edma.c ****     SPI_Type *base;                   /*!< DSPI peripheral base address. */
  56:../drivers/fsl_dspi_edma.c ****     dspi_slave_edma_handle_t *handle; /*!< dspi_master_edma_handle_t handle */
  57:../drivers/fsl_dspi_edma.c **** } dspi_slave_edma_private_handle_t;
  58:../drivers/fsl_dspi_edma.c **** 
  59:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  60:../drivers/fsl_dspi_edma.c **** * Prototypes
  61:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
  62:../drivers/fsl_dspi_edma.c **** /*!
  63:../drivers/fsl_dspi_edma.c **** * @brief EDMA_DspiMasterCallback after the DSPI master transfer completed by using EDMA.
  64:../drivers/fsl_dspi_edma.c **** * This is not a public API.
  65:../drivers/fsl_dspi_edma.c **** */
  66:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiMasterCallback(edma_handle_t *edmaHandle,
  67:../drivers/fsl_dspi_edma.c ****                                     void *g_dspiEdmaPrivateHandle,
  68:../drivers/fsl_dspi_edma.c ****                                     bool transferDone,
  69:../drivers/fsl_dspi_edma.c ****                                     uint32_t tcds);
  70:../drivers/fsl_dspi_edma.c **** 
  71:../drivers/fsl_dspi_edma.c **** /*!
  72:../drivers/fsl_dspi_edma.c **** * @brief EDMA_DspiSlaveCallback after the DSPI slave transfer completed by using EDMA.
  73:../drivers/fsl_dspi_edma.c **** * This is not a public API.
  74:../drivers/fsl_dspi_edma.c **** */
  75:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiSlaveCallback(edma_handle_t *edmaHandle,
  76:../drivers/fsl_dspi_edma.c ****                                    void *g_dspiEdmaPrivateHandle,
  77:../drivers/fsl_dspi_edma.c ****                                    bool transferDone,
  78:../drivers/fsl_dspi_edma.c ****                                    uint32_t tcds);
  79:../drivers/fsl_dspi_edma.c **** /*!
  80:../drivers/fsl_dspi_edma.c **** * @brief Get instance number for DSPI module.
  81:../drivers/fsl_dspi_edma.c **** *
  82:../drivers/fsl_dspi_edma.c **** * This is not a public API and it's extern from fsl_dspi.c.
  83:../drivers/fsl_dspi_edma.c **** *
  84:../drivers/fsl_dspi_edma.c **** * @param base DSPI peripheral base address
  85:../drivers/fsl_dspi_edma.c **** */
  86:../drivers/fsl_dspi_edma.c **** extern uint32_t DSPI_GetInstance(SPI_Type *base);
  87:../drivers/fsl_dspi_edma.c **** 
  88:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  89:../drivers/fsl_dspi_edma.c **** * Variables
  90:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
  91:../drivers/fsl_dspi_edma.c **** 
  92:../drivers/fsl_dspi_edma.c **** /*! @brief Pointers to dspi edma handles for each instance. */
  93:../drivers/fsl_dspi_edma.c **** static dspi_master_edma_private_handle_t s_dspiMasterEdmaPrivateHandle[FSL_FEATURE_SOC_DSPI_COUNT];
  94:../drivers/fsl_dspi_edma.c **** static dspi_slave_edma_private_handle_t s_dspiSlaveEdmaPrivateHandle[FSL_FEATURE_SOC_DSPI_COUNT];
  95:../drivers/fsl_dspi_edma.c **** 
  96:../drivers/fsl_dspi_edma.c **** /*! @brief Global variable for dummy data value setting. */
  97:../drivers/fsl_dspi_edma.c **** extern volatile uint8_t s_dummyData[];
  98:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  99:../drivers/fsl_dspi_edma.c **** * Code
 100:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
 101:../drivers/fsl_dspi_edma.c **** 
 102:../drivers/fsl_dspi_edma.c **** void DSPI_MasterTransferCreateHandleEDMA(SPI_Type *base,
 103:../drivers/fsl_dspi_edma.c ****                                          dspi_master_edma_handle_t *handle,
 104:../drivers/fsl_dspi_edma.c ****                                          dspi_master_edma_transfer_callback_t callback,
 105:../drivers/fsl_dspi_edma.c ****                                          void *userData,
 106:../drivers/fsl_dspi_edma.c ****                                          edma_handle_t *edmaRxRegToRxDataHandle,
 107:../drivers/fsl_dspi_edma.c ****                                          edma_handle_t *edmaTxDataToIntermediaryHandle,
 108:../drivers/fsl_dspi_edma.c ****                                          edma_handle_t *edmaIntermediaryToTxRegHandle)
 109:../drivers/fsl_dspi_edma.c **** {
 110:../drivers/fsl_dspi_edma.c ****     assert(handle);
 111:../drivers/fsl_dspi_edma.c ****     assert(edmaRxRegToRxDataHandle);
 112:../drivers/fsl_dspi_edma.c **** #if (!(defined(FSL_FEATURE_DSPI_HAS_GASKET) && FSL_FEATURE_DSPI_HAS_GASKET))
 113:../drivers/fsl_dspi_edma.c ****     assert(edmaTxDataToIntermediaryHandle);
 114:../drivers/fsl_dspi_edma.c **** #endif
 115:../drivers/fsl_dspi_edma.c ****     assert(edmaIntermediaryToTxRegHandle);
 116:../drivers/fsl_dspi_edma.c **** 
 117:../drivers/fsl_dspi_edma.c ****     /* Zero the handle. */
 118:../drivers/fsl_dspi_edma.c ****     memset(handle, 0, sizeof(*handle));
 119:../drivers/fsl_dspi_edma.c **** 
 120:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
 121:../drivers/fsl_dspi_edma.c **** 
 122:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].base = base;
 123:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].handle = handle;
 124:../drivers/fsl_dspi_edma.c **** 
 125:../drivers/fsl_dspi_edma.c ****     handle->callback = callback;
 126:../drivers/fsl_dspi_edma.c ****     handle->userData = userData;
 127:../drivers/fsl_dspi_edma.c **** 
 128:../drivers/fsl_dspi_edma.c ****     handle->edmaRxRegToRxDataHandle = edmaRxRegToRxDataHandle;
 129:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToIntermediaryHandle = edmaTxDataToIntermediaryHandle;
 130:../drivers/fsl_dspi_edma.c ****     handle->edmaIntermediaryToTxRegHandle = edmaIntermediaryToTxRegHandle;
 131:../drivers/fsl_dspi_edma.c **** }
 132:../drivers/fsl_dspi_edma.c **** 
 133:../drivers/fsl_dspi_edma.c **** status_t DSPI_MasterTransferEDMA(SPI_Type *base, dspi_master_edma_handle_t *handle, dspi_transfer_t
 134:../drivers/fsl_dspi_edma.c **** {
 135:../drivers/fsl_dspi_edma.c ****     assert(handle);
 136:../drivers/fsl_dspi_edma.c ****     assert(transfer);
 137:../drivers/fsl_dspi_edma.c **** 
 138:../drivers/fsl_dspi_edma.c ****     /* If the transfer count is zero, then return immediately.*/
 139:../drivers/fsl_dspi_edma.c ****     if (transfer->dataSize == 0)
 140:../drivers/fsl_dspi_edma.c ****     {
 141:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 142:../drivers/fsl_dspi_edma.c ****     }
 143:../drivers/fsl_dspi_edma.c **** 
 144:../drivers/fsl_dspi_edma.c ****     /* If both send buffer and receive buffer is null */
 145:../drivers/fsl_dspi_edma.c ****     if ((!(transfer->txData)) && (!(transfer->rxData)))
 146:../drivers/fsl_dspi_edma.c ****     {
 147:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 148:../drivers/fsl_dspi_edma.c ****     }
 149:../drivers/fsl_dspi_edma.c **** 
 150:../drivers/fsl_dspi_edma.c ****     /* Check that we're not busy.*/
 151:../drivers/fsl_dspi_edma.c ****     if (handle->state == kDSPI_Busy)
 152:../drivers/fsl_dspi_edma.c ****     {
 153:../drivers/fsl_dspi_edma.c ****         return kStatus_DSPI_Busy;
 154:../drivers/fsl_dspi_edma.c ****     }
 155:../drivers/fsl_dspi_edma.c **** 
 156:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Busy;
 157:../drivers/fsl_dspi_edma.c **** 
 158:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
 159:../drivers/fsl_dspi_edma.c ****     uint16_t wordToSend = 0;
 160:../drivers/fsl_dspi_edma.c ****     uint8_t dummyData = s_dummyData[DSPI_GetInstance(base)];
 161:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 162:../drivers/fsl_dspi_edma.c ****     uint8_t dataFedMax = 2;
 163:../drivers/fsl_dspi_edma.c **** 
 164:../drivers/fsl_dspi_edma.c ****     uint32_t rxAddr = DSPI_GetRxRegisterAddress(base);
 165:../drivers/fsl_dspi_edma.c ****     uint32_t txAddr = DSPI_MasterGetTxRegisterAddress(base);
 166:../drivers/fsl_dspi_edma.c **** 
 167:../drivers/fsl_dspi_edma.c ****     edma_tcd_t *softwareTCD = (edma_tcd_t *)((uint32_t)(&handle->dspiSoftwareTCD[1]) & (~0x1FU));
 168:../drivers/fsl_dspi_edma.c **** 
 169:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigA;
 170:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigB;
 171:../drivers/fsl_dspi_edma.c **** 
 172:../drivers/fsl_dspi_edma.c ****     handle->txBuffIfNull = ((uint32_t)dummyData << 8) | dummyData;
 173:../drivers/fsl_dspi_edma.c **** 
 174:../drivers/fsl_dspi_edma.c ****     dspi_command_data_config_t commandStruct;
 175:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
 176:../drivers/fsl_dspi_edma.c ****     DSPI_FlushFifo(base, true, true);
 177:../drivers/fsl_dspi_edma.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
 178:../drivers/fsl_dspi_edma.c **** 
 179:../drivers/fsl_dspi_edma.c ****     commandStruct.whichPcs =
 180:../drivers/fsl_dspi_edma.c ****         (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS
 181:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 182:../drivers/fsl_dspi_edma.c ****     commandStruct.clearTransferCount = false;
 183:../drivers/fsl_dspi_edma.c ****     commandStruct.whichCtar =
 184:../drivers/fsl_dspi_edma.c ****         (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR
 185:../drivers/fsl_dspi_edma.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 186:../drivers/fsl_dspi_edma.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 187:../drivers/fsl_dspi_edma.c **** 
 188:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = true;
 189:../drivers/fsl_dspi_edma.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer)
 190:../drivers/fsl_dspi_edma.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 191:../drivers/fsl_dspi_edma.c **** 
 192:../drivers/fsl_dspi_edma.c ****     handle->bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_
 193:../drivers/fsl_dspi_edma.c **** 
 194:../drivers/fsl_dspi_edma.c ****     if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
 195:../drivers/fsl_dspi_edma.c ****     {
 196:../drivers/fsl_dspi_edma.c ****         handle->fifoSize = 1;
 197:../drivers/fsl_dspi_edma.c ****     }
 198:../drivers/fsl_dspi_edma.c ****     else
 199:../drivers/fsl_dspi_edma.c ****     {
 200:../drivers/fsl_dspi_edma.c ****         handle->fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
 201:../drivers/fsl_dspi_edma.c ****     }
 202:../drivers/fsl_dspi_edma.c ****     handle->txData = transfer->txData;
 203:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
 204:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
 205:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 206:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
 207:../drivers/fsl_dspi_edma.c **** 
 208:../drivers/fsl_dspi_edma.c ****     /* If using a shared RX/TX DMA request, then this limits the amount of data we can transfer
 209:../drivers/fsl_dspi_edma.c ****     * due to the linked channel. The max bytes is 511 if 8-bit/frame or 1022 if 16-bit/frame
 210:../drivers/fsl_dspi_edma.c ****     */
 211:../drivers/fsl_dspi_edma.c ****     uint32_t limited_size = 0;
 212:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 213:../drivers/fsl_dspi_edma.c ****     {
 214:../drivers/fsl_dspi_edma.c ****         limited_size = 32767u;
 215:../drivers/fsl_dspi_edma.c ****     }
 216:../drivers/fsl_dspi_edma.c ****     else
 217:../drivers/fsl_dspi_edma.c ****     {
 218:../drivers/fsl_dspi_edma.c ****         limited_size = 511u;
 219:../drivers/fsl_dspi_edma.c ****     }
 220:../drivers/fsl_dspi_edma.c **** 
 221:../drivers/fsl_dspi_edma.c ****     if (handle->bitsPerFrame > 8)
 222:../drivers/fsl_dspi_edma.c ****     {
 223:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > (limited_size << 1u))
 224:../drivers/fsl_dspi_edma.c ****         {
 225:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
 226:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 227:../drivers/fsl_dspi_edma.c ****         }
 228:../drivers/fsl_dspi_edma.c ****     }
 229:../drivers/fsl_dspi_edma.c ****     else
 230:../drivers/fsl_dspi_edma.c ****     {
 231:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > limited_size)
 232:../drivers/fsl_dspi_edma.c ****         {
 233:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
 234:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 235:../drivers/fsl_dspi_edma.c ****         }
 236:../drivers/fsl_dspi_edma.c ****     }
 237:../drivers/fsl_dspi_edma.c **** 
 238:../drivers/fsl_dspi_edma.c ****     /*The data size should be even if the bitsPerFrame is greater than 8 (that is 2 bytes per frame
 239:../drivers/fsl_dspi_edma.c ****     if ((handle->bitsPerFrame > 8) && (transfer->dataSize & 0x1))
 240:../drivers/fsl_dspi_edma.c ****     {
 241:../drivers/fsl_dspi_edma.c ****         handle->state = kDSPI_Idle;
 242:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 243:../drivers/fsl_dspi_edma.c ****     }
 244:../drivers/fsl_dspi_edma.c **** 
 245:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 246:../drivers/fsl_dspi_edma.c **** 
 247:../drivers/fsl_dspi_edma.c ****     EDMA_SetCallback(handle->edmaRxRegToRxDataHandle, EDMA_DspiMasterCallback,
 248:../drivers/fsl_dspi_edma.c ****                      &s_dspiMasterEdmaPrivateHandle[instance]);
 249:../drivers/fsl_dspi_edma.c **** 
 250:../drivers/fsl_dspi_edma.c ****     /*
 251:../drivers/fsl_dspi_edma.c ****     (1)For DSPI instances with shared RX/TX DMA requests: Rx DMA request -> channel_A -> channel_B-
 252:../drivers/fsl_dspi_edma.c ****     channel_A minor link to channel_B , channel_B minor link to channel_C.
 253:../drivers/fsl_dspi_edma.c **** 
 254:../drivers/fsl_dspi_edma.c ****     Already pushed 1 or 2 data in SPI_PUSHR , then start the DMA tansfer.
 255:../drivers/fsl_dspi_edma.c ****     channel_A:SPI_POPR to rxData,
 256:../drivers/fsl_dspi_edma.c ****     channel_B:next txData to handle->command (low 16 bits),
 257:../drivers/fsl_dspi_edma.c ****     channel_C:handle->command (32 bits) to SPI_PUSHR, and use the scatter/gather to transfer the la
 258:../drivers/fsl_dspi_edma.c ****     (handle->lastCommand to SPI_PUSHR).
 259:../drivers/fsl_dspi_edma.c **** 
 260:../drivers/fsl_dspi_edma.c ****     (2)For DSPI instances with separate RX and TX DMA requests:
 261:../drivers/fsl_dspi_edma.c ****     Rx DMA request -> channel_A
 262:../drivers/fsl_dspi_edma.c ****     Tx DMA request -> channel_C -> channel_B .
 263:../drivers/fsl_dspi_edma.c ****     channel_C major link to channel_B.
 264:../drivers/fsl_dspi_edma.c ****     So need prepare the first data in "intermediary"  before the DMA
 265:../drivers/fsl_dspi_edma.c ****     transfer and then channel_B is used to prepare the next data to "intermediary"
 266:../drivers/fsl_dspi_edma.c **** 
 267:../drivers/fsl_dspi_edma.c ****     channel_A:SPI_POPR to rxData,
 268:../drivers/fsl_dspi_edma.c ****     channel_C: handle->command (32 bits) to SPI_PUSHR,
 269:../drivers/fsl_dspi_edma.c ****     channel_B: next txData to handle->command (low 16 bits), and use the scatter/gather to prepare 
 270:../drivers/fsl_dspi_edma.c ****     (handle->lastCommand to handle->Command).
 271:../drivers/fsl_dspi_edma.c ****     */
 272:../drivers/fsl_dspi_edma.c **** 
 273:../drivers/fsl_dspi_edma.c ****     /*If dspi has separate dma request , prepare the first data in "intermediary" .
 274:../drivers/fsl_dspi_edma.c ****     else (dspi has shared dma request) , send first 2 data if there is fifo or send first 1 data if
 275:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 276:../drivers/fsl_dspi_edma.c ****     {
 277:../drivers/fsl_dspi_edma.c ****         /* For DSPI instances with separate RX/TX DMA requests, we'll use the TX DMA request to
 278:../drivers/fsl_dspi_edma.c ****         * trigger the TX DMA channel and RX DMA request to trigger the RX DMA channel
 279:../drivers/fsl_dspi_edma.c ****         */
 280:../drivers/fsl_dspi_edma.c **** 
 281:../drivers/fsl_dspi_edma.c ****         /*Prepare the firt data*/
 282:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame > 8)
 283:../drivers/fsl_dspi_edma.c ****         {
 284:../drivers/fsl_dspi_edma.c ****             /* If it's the last word */
 285:../drivers/fsl_dspi_edma.c ****             if (handle->remainingSendByteCount <= 2)
 286:../drivers/fsl_dspi_edma.c ****             {
 287:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
 288:../drivers/fsl_dspi_edma.c ****                 {
 289:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
 290:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 291:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 292:../drivers/fsl_dspi_edma.c ****                 }
 293:../drivers/fsl_dspi_edma.c ****                 else
 294:../drivers/fsl_dspi_edma.c ****                 {
 295:../drivers/fsl_dspi_edma.c ****                     wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 296:../drivers/fsl_dspi_edma.c ****                 }
 297:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) | wordToSend;
 298:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 299:../drivers/fsl_dspi_edma.c ****             }
 300:../drivers/fsl_dspi_edma.c ****             else /* For all words except the last word , frame > 8bits */
 301:../drivers/fsl_dspi_edma.c ****             {
 302:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
 303:../drivers/fsl_dspi_edma.c ****                 {
 304:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
 305:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 306:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 307:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 308:../drivers/fsl_dspi_edma.c ****                 }
 309:../drivers/fsl_dspi_edma.c ****                 else
 310:../drivers/fsl_dspi_edma.c ****                 {
 311:../drivers/fsl_dspi_edma.c ****                     wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 312:../drivers/fsl_dspi_edma.c ****                 }
 313:../drivers/fsl_dspi_edma.c ****                 handle->command = (handle->command & 0xffff0000U) | wordToSend;
 314:../drivers/fsl_dspi_edma.c ****             }
 315:../drivers/fsl_dspi_edma.c ****         }
 316:../drivers/fsl_dspi_edma.c ****         else /* Optimized for bits/frame less than or equal to one byte. */
 317:../drivers/fsl_dspi_edma.c ****         {
 318:../drivers/fsl_dspi_edma.c ****             if (handle->txData)
 319:../drivers/fsl_dspi_edma.c ****             {
 320:../drivers/fsl_dspi_edma.c ****                 wordToSend = *(handle->txData);
 321:../drivers/fsl_dspi_edma.c ****                 ++handle->txData; /* increment to next data word*/
 322:../drivers/fsl_dspi_edma.c ****             }
 323:../drivers/fsl_dspi_edma.c ****             else
 324:../drivers/fsl_dspi_edma.c ****             {
 325:../drivers/fsl_dspi_edma.c ****                 wordToSend = dummyData;
 326:../drivers/fsl_dspi_edma.c ****             }
 327:../drivers/fsl_dspi_edma.c **** 
 328:../drivers/fsl_dspi_edma.c ****             if (handle->remainingSendByteCount == 1)
 329:../drivers/fsl_dspi_edma.c ****             {
 330:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) | wordToSend;
 331:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 332:../drivers/fsl_dspi_edma.c ****             }
 333:../drivers/fsl_dspi_edma.c ****             else
 334:../drivers/fsl_dspi_edma.c ****             {
 335:../drivers/fsl_dspi_edma.c ****                 handle->command = (handle->command & 0xffff0000U) | wordToSend;
 336:../drivers/fsl_dspi_edma.c ****             }
 337:../drivers/fsl_dspi_edma.c ****         }
 338:../drivers/fsl_dspi_edma.c ****     }
 339:../drivers/fsl_dspi_edma.c **** 
 340:../drivers/fsl_dspi_edma.c ****     else /*dspi has shared dma request*/
 341:../drivers/fsl_dspi_edma.c ****     {
 342:../drivers/fsl_dspi_edma.c ****         /* For DSPI instances with shared RX/TX DMA requests, we'll use the RX DMA request to
 343:../drivers/fsl_dspi_edma.c ****          * trigger ongoing transfers and will link to the TX DMA channel from the RX DMA channel.
 344:../drivers/fsl_dspi_edma.c ****          */
 345:../drivers/fsl_dspi_edma.c **** 
 346:../drivers/fsl_dspi_edma.c ****         /* If bits/frame is greater than one byte */
 347:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame > 8)
 348:../drivers/fsl_dspi_edma.c ****         {
 349:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
 350:../drivers/fsl_dspi_edma.c ****             {
 351:../drivers/fsl_dspi_edma.c ****                 if (handle->remainingSendByteCount <= 2)
 352:../drivers/fsl_dspi_edma.c ****                 {
 353:../drivers/fsl_dspi_edma.c ****                     if (handle->txData)
 354:../drivers/fsl_dspi_edma.c ****                     {
 355:../drivers/fsl_dspi_edma.c ****                         wordToSend = *(handle->txData);
 356:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 357:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 358:../drivers/fsl_dspi_edma.c ****                     }
 359:../drivers/fsl_dspi_edma.c ****                     else
 360:../drivers/fsl_dspi_edma.c ****                     {
 361:../drivers/fsl_dspi_edma.c ****                         wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 362:../drivers/fsl_dspi_edma.c ****                     }
 363:../drivers/fsl_dspi_edma.c ****                     handle->remainingSendByteCount = 0;
 364:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 365:../drivers/fsl_dspi_edma.c ****                 }
 366:../drivers/fsl_dspi_edma.c ****                 /* For all words except the last word */
 367:../drivers/fsl_dspi_edma.c ****                 else
 368:../drivers/fsl_dspi_edma.c ****                 {
 369:../drivers/fsl_dspi_edma.c ****                     if (handle->txData)
 370:../drivers/fsl_dspi_edma.c ****                     {
 371:../drivers/fsl_dspi_edma.c ****                         wordToSend = *(handle->txData);
 372:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 373:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 374:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 375:../drivers/fsl_dspi_edma.c ****                     }
 376:../drivers/fsl_dspi_edma.c ****                     else
 377:../drivers/fsl_dspi_edma.c ****                     {
 378:../drivers/fsl_dspi_edma.c ****                         wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 379:../drivers/fsl_dspi_edma.c ****                     }
 380:../drivers/fsl_dspi_edma.c ****                     handle->remainingSendByteCount -= 2;
 381:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->command & 0xffff0000U) | wordToSend;
 382:../drivers/fsl_dspi_edma.c ****                 }
 383:../drivers/fsl_dspi_edma.c **** 
 384:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
 385:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 386:../drivers/fsl_dspi_edma.c **** 
 387:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed += 2;
 388:../drivers/fsl_dspi_edma.c **** 
 389:../drivers/fsl_dspi_edma.c ****                 /* exit loop if send count is zero, else update local variables for next loop */
 390:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == (dataFedMax * 2)))
 391:../drivers/fsl_dspi_edma.c ****                 {
 392:../drivers/fsl_dspi_edma.c ****                     break;
 393:../drivers/fsl_dspi_edma.c ****                 }
 394:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
 395:../drivers/fsl_dspi_edma.c ****         }
 396:../drivers/fsl_dspi_edma.c ****         else /* Optimized for bits/frame less than or equal to one byte. */
 397:../drivers/fsl_dspi_edma.c ****         {
 398:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
 399:../drivers/fsl_dspi_edma.c ****             {
 400:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
 401:../drivers/fsl_dspi_edma.c ****                 {
 402:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
 403:../drivers/fsl_dspi_edma.c ****                     ++handle->txData;
 404:../drivers/fsl_dspi_edma.c ****                 }
 405:../drivers/fsl_dspi_edma.c ****                 else
 406:../drivers/fsl_dspi_edma.c ****                 {
 407:../drivers/fsl_dspi_edma.c ****                     wordToSend = dummyData;
 408:../drivers/fsl_dspi_edma.c ****                 }
 409:../drivers/fsl_dspi_edma.c **** 
 410:../drivers/fsl_dspi_edma.c ****                 if (handle->remainingSendByteCount == 1)
 411:../drivers/fsl_dspi_edma.c ****                 {
 412:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 413:../drivers/fsl_dspi_edma.c ****                 }
 414:../drivers/fsl_dspi_edma.c ****                 else
 415:../drivers/fsl_dspi_edma.c ****                 {
 416:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->command & 0xffff0000U) | wordToSend;
 417:../drivers/fsl_dspi_edma.c ****                 }
 418:../drivers/fsl_dspi_edma.c **** 
 419:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
 420:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 421:../drivers/fsl_dspi_edma.c **** 
 422:../drivers/fsl_dspi_edma.c ****                 --handle->remainingSendByteCount;
 423:../drivers/fsl_dspi_edma.c **** 
 424:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed++;
 425:../drivers/fsl_dspi_edma.c **** 
 426:../drivers/fsl_dspi_edma.c ****                 /* exit loop if send count is zero, else update local variables for next loop */
 427:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == dataFedMax))
 428:../drivers/fsl_dspi_edma.c ****                 {
 429:../drivers/fsl_dspi_edma.c ****                     break;
 430:../drivers/fsl_dspi_edma.c ****                 }
 431:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
 432:../drivers/fsl_dspi_edma.c ****         }
 433:../drivers/fsl_dspi_edma.c ****     }
 434:../drivers/fsl_dspi_edma.c **** 
 435:../drivers/fsl_dspi_edma.c ****     /***channel_A *** used for carry the data from Rx_Data_Register(POPR) to User_Receive_Buffer(rx
 436:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHandle->chann
 437:../drivers/fsl_dspi_edma.c **** 
 438:../drivers/fsl_dspi_edma.c ****     transferConfigA.srcAddr = (uint32_t)rxAddr;
 439:../drivers/fsl_dspi_edma.c ****     transferConfigA.srcOffset = 0;
 440:../drivers/fsl_dspi_edma.c **** 
 441:../drivers/fsl_dspi_edma.c ****     if (handle->rxData)
 442:../drivers/fsl_dspi_edma.c ****     {
 443:../drivers/fsl_dspi_edma.c ****         transferConfigA.destAddr = (uint32_t) & (handle->rxData[0]);
 444:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 1;
 445:../drivers/fsl_dspi_edma.c ****     }
 446:../drivers/fsl_dspi_edma.c ****     else
 447:../drivers/fsl_dspi_edma.c ****     {
 448:../drivers/fsl_dspi_edma.c ****         transferConfigA.destAddr = (uint32_t) & (handle->rxBuffIfNull);
 449:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 0;
 450:../drivers/fsl_dspi_edma.c ****     }
 451:../drivers/fsl_dspi_edma.c **** 
 452:../drivers/fsl_dspi_edma.c ****     transferConfigA.destTransferSize = kEDMA_TransferSize1Bytes;
 453:../drivers/fsl_dspi_edma.c **** 
 454:../drivers/fsl_dspi_edma.c ****     if (handle->bitsPerFrame <= 8)
 455:../drivers/fsl_dspi_edma.c ****     {
 456:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcTransferSize = kEDMA_TransferSize1Bytes;
 457:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 1;
 458:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
 459:../drivers/fsl_dspi_edma.c ****     }
 460:../drivers/fsl_dspi_edma.c ****     else
 461:../drivers/fsl_dspi_edma.c ****     {
 462:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcTransferSize = kEDMA_TransferSize2Bytes;
 463:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 2;
 464:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
 465:../drivers/fsl_dspi_edma.c ****     }
 466:../drivers/fsl_dspi_edma.c **** 
 467:../drivers/fsl_dspi_edma.c ****     /* Store the initially configured eDMA minor byte transfer count into the DSPI handle */
 468:../drivers/fsl_dspi_edma.c ****     handle->nbytes = transferConfigA.minorLoopBytes;
 469:../drivers/fsl_dspi_edma.c **** 
 470:../drivers/fsl_dspi_edma.c ****     EDMA_SetTransferConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHandle->
 471:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 472:../drivers/fsl_dspi_edma.c ****     EDMA_EnableChannelInterrupts(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHa
 473:../drivers/fsl_dspi_edma.c ****                                  kEDMA_MajorInterruptEnable);
 474:../drivers/fsl_dspi_edma.c **** 
 475:../drivers/fsl_dspi_edma.c ****     /*Calculate the last data : handle->lastCommand*/
 476:../drivers/fsl_dspi_edma.c ****     if (((handle->remainingSendByteCount > 0) && (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn
 477:../drivers/fsl_dspi_edma.c ****         ((((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 478:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 479:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
 480:../drivers/fsl_dspi_edma.c ****     {
 481:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
 482:../drivers/fsl_dspi_edma.c ****         {
 483:../drivers/fsl_dspi_edma.c ****             uint32_t bufferIndex = 0;
 484:../drivers/fsl_dspi_edma.c **** 
 485:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 486:../drivers/fsl_dspi_edma.c ****             {
 487:../drivers/fsl_dspi_edma.c ****                 if (handle->bitsPerFrame <= 8)
 488:../drivers/fsl_dspi_edma.c ****                 {
 489:../drivers/fsl_dspi_edma.c ****                     bufferIndex = handle->remainingSendByteCount - 1;
 490:../drivers/fsl_dspi_edma.c ****                 }
 491:../drivers/fsl_dspi_edma.c ****                 else
 492:../drivers/fsl_dspi_edma.c ****                 {
 493:../drivers/fsl_dspi_edma.c ****                     bufferIndex = handle->remainingSendByteCount - 2;
 494:../drivers/fsl_dspi_edma.c ****                 }
 495:../drivers/fsl_dspi_edma.c ****             }
 496:../drivers/fsl_dspi_edma.c ****             else
 497:../drivers/fsl_dspi_edma.c ****             {
 498:../drivers/fsl_dspi_edma.c ****                 bufferIndex = handle->remainingSendByteCount;
 499:../drivers/fsl_dspi_edma.c ****             }
 500:../drivers/fsl_dspi_edma.c **** 
 501:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 502:../drivers/fsl_dspi_edma.c ****             {
 503:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) | handle->txData[bufferIn
 504:../drivers/fsl_dspi_edma.c ****             }
 505:../drivers/fsl_dspi_edma.c ****             else
 506:../drivers/fsl_dspi_edma.c ****             {
 507:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) |
 508:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 509:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 510:../drivers/fsl_dspi_edma.c ****             }
 511:../drivers/fsl_dspi_edma.c ****         }
 512:../drivers/fsl_dspi_edma.c ****         else
 513:../drivers/fsl_dspi_edma.c ****         {
 514:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 515:../drivers/fsl_dspi_edma.c ****             {
 516:../drivers/fsl_dspi_edma.c ****                 wordToSend = dummyData;
 517:../drivers/fsl_dspi_edma.c ****             }
 518:../drivers/fsl_dspi_edma.c ****             else
 519:../drivers/fsl_dspi_edma.c ****             {
 520:../drivers/fsl_dspi_edma.c ****                 wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 521:../drivers/fsl_dspi_edma.c ****             }
 522:../drivers/fsl_dspi_edma.c ****             handle->lastCommand = (handle->lastCommand & 0xffff0000U) | wordToSend;
 523:../drivers/fsl_dspi_edma.c ****         }
 524:../drivers/fsl_dspi_edma.c ****     }
 525:../drivers/fsl_dspi_edma.c **** 
 526:../drivers/fsl_dspi_edma.c **** /* The feature of GASKET is that the SPI supports 8-bit or 16-bit writes to the PUSH TX FIFO,
 527:../drivers/fsl_dspi_edma.c ****  * allowing a single write to the command word followed by multiple writes to the transmit word.
 528:../drivers/fsl_dspi_edma.c ****  * The TX FIFO will save the last command word written, and convert a 8-bit/16-bit write to the
 529:../drivers/fsl_dspi_edma.c ****  * transmit word into a 32-bit write that pushes both the command word and transmit word into
 530:../drivers/fsl_dspi_edma.c ****  * the TX FIFO (PUSH TX FIFO Register In Master Mode)
 531:../drivers/fsl_dspi_edma.c ****  * So, if this feature is supported, we can use use one channel to carry the receive data from
 532:../drivers/fsl_dspi_edma.c ****  * receive regsiter to user data buffer, use the other channel to carry the data from user data buf
 533:../drivers/fsl_dspi_edma.c ****  * to transmit register,and use the scatter/gather function to prepare the last data.
 534:../drivers/fsl_dspi_edma.c ****  * That is to say, if GASKET feature is supported, we can use only two channels for tansferring dat
 535:../drivers/fsl_dspi_edma.c ****  */
 536:../drivers/fsl_dspi_edma.c **** #if defined(FSL_FEATURE_DSPI_HAS_GASKET) && FSL_FEATURE_DSPI_HAS_GASKET
 537:../drivers/fsl_dspi_edma.c ****     /*  For DSPI instances with separate RX and TX DMA requests: use the scatter/gather to prepare 
 538:../drivers/fsl_dspi_edma.c ****      * (handle->lastCommand) to PUSHR register.
 539:../drivers/fsl_dspi_edma.c ****      */
 540:../drivers/fsl_dspi_edma.c **** 
 541:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaIntermediaryToTxRegHandle->base, handle->edmaIntermediaryToTxRegH
 542:../drivers/fsl_dspi_edma.c **** 
 543:../drivers/fsl_dspi_edma.c ****     if ((1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)) ||
 544:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 0) && (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn
 545:../drivers/fsl_dspi_edma.c ****     {
 546:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcAddr = (uint32_t) & (handle->lastCommand);
 547:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t)txAddr;
 548:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize4Bytes;
 549:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 550:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcOffset = 0;
 551:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 552:../drivers/fsl_dspi_edma.c ****         transferConfigB.minorLoopBytes = 4;
 553:../drivers/fsl_dspi_edma.c ****         transferConfigB.majorLoopCounts = 1;
 554:../drivers/fsl_dspi_edma.c **** 
 555:../drivers/fsl_dspi_edma.c ****         EDMA_TcdReset(softwareTCD);
 556:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 557:../drivers/fsl_dspi_edma.c ****     }
 558:../drivers/fsl_dspi_edma.c **** 
 559:../drivers/fsl_dspi_edma.c ****     /*User_Send_Buffer(txData) to PUSHR register. */
 560:../drivers/fsl_dspi_edma.c ****     if (((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame <= 8)) ||
 561:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8)))
 562:../drivers/fsl_dspi_edma.c ****     {
 563:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
 564:../drivers/fsl_dspi_edma.c ****         {
 565:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 566:../drivers/fsl_dspi_edma.c ****             {
 567:../drivers/fsl_dspi_edma.c ****                 /* For DSPI with separate RX and TX DMA requests, one frame data has been carry
 568:../drivers/fsl_dspi_edma.c ****                  * to handle->command, so need to reduce the pointer of txData.
 569:../drivers/fsl_dspi_edma.c ****                  */
 570:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcAddr =
 571:../drivers/fsl_dspi_edma.c ****                     (uint32_t)((uint8_t *)(handle->txData) - ((handle->bitsPerFrame <= 8) ? (1U) : 
 572:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcOffset = 1;
 573:../drivers/fsl_dspi_edma.c ****             }
 574:../drivers/fsl_dspi_edma.c ****             else
 575:../drivers/fsl_dspi_edma.c ****             {
 576:../drivers/fsl_dspi_edma.c ****                 /* For DSPI with shared RX and TX DMA requests, one or two frame data have been car
 577:../drivers/fsl_dspi_edma.c ****                  * to PUSHR register, so no need to change the pointer of txData.
 578:../drivers/fsl_dspi_edma.c ****                  */
 579:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcAddr = (uint32_t)((uint8_t *)(handle->txData));
 580:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcOffset = 1;
 581:../drivers/fsl_dspi_edma.c ****             }
 582:../drivers/fsl_dspi_edma.c ****         }
 583:../drivers/fsl_dspi_edma.c ****         else
 584:../drivers/fsl_dspi_edma.c ****         {
 585:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcAddr = (uint32_t)(&handle->txBuffIfNull);
 586:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 0;
 587:../drivers/fsl_dspi_edma.c ****         }
 588:../drivers/fsl_dspi_edma.c **** 
 589:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t)txAddr;
 590:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 591:../drivers/fsl_dspi_edma.c **** 
 592:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize1Bytes;
 593:../drivers/fsl_dspi_edma.c **** 
 594:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
 595:../drivers/fsl_dspi_edma.c ****         {
 596:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize1Bytes;
 597:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 1;
 598:../drivers/fsl_dspi_edma.c **** 
 599:../drivers/fsl_dspi_edma.c ****             transferConfigB.majorLoopCounts = handle->remainingSendByteCount - 1;
 600:../drivers/fsl_dspi_edma.c ****         }
 601:../drivers/fsl_dspi_edma.c ****         else
 602:../drivers/fsl_dspi_edma.c ****         {
 603:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize2Bytes;
 604:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 2;
 605:../drivers/fsl_dspi_edma.c ****             transferConfigB.majorLoopCounts = (handle->remainingSendByteCount / 2) - 1;
 606:../drivers/fsl_dspi_edma.c ****         }
 607:../drivers/fsl_dspi_edma.c **** 
 608:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 609:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigB, so
 610:../drivers/fsl_dspi_edma.c ****     }
 611:../drivers/fsl_dspi_edma.c ****     /* If only one word to transmit, only carry the lastcommand. */
 612:../drivers/fsl_dspi_edma.c ****     else
 613:../drivers/fsl_dspi_edma.c ****     {
 614:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 615:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigB, NU
 616:../drivers/fsl_dspi_edma.c ****     }
 617:../drivers/fsl_dspi_edma.c **** 
 618:../drivers/fsl_dspi_edma.c ****     /*Start the EDMA channel_A , channel_C. */
 619:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaRxRegToRxDataHandle);
 620:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaIntermediaryToTxRegHandle);
 621:../drivers/fsl_dspi_edma.c **** 
 622:../drivers/fsl_dspi_edma.c ****     /* Set the channel link.
 623:../drivers/fsl_dspi_edma.c ****      * For DSPI instances with shared TX and RX DMA requests, setup channel minor link, first recei
 624:../drivers/fsl_dspi_edma.c ****      * receive register, and then carry transmit data to PUSHER register.
 625:../drivers/fsl_dspi_edma.c ****      * For DSPI instance with separate TX and RX DMA requests, there is no need to set up channel l
 626:../drivers/fsl_dspi_edma.c ****      */
 627:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 628:../drivers/fsl_dspi_edma.c ****     {
 629:../drivers/fsl_dspi_edma.c ****         /*Set channel priority*/
 630:../drivers/fsl_dspi_edma.c ****         uint8_t channelPriorityLow = handle->edmaRxRegToRxDataHandle->channel;
 631:../drivers/fsl_dspi_edma.c ****         uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 632:../drivers/fsl_dspi_edma.c ****         uint8_t t = 0;
 633:../drivers/fsl_dspi_edma.c **** 
 634:../drivers/fsl_dspi_edma.c ****         if (channelPriorityLow > channelPriorityHigh)
 635:../drivers/fsl_dspi_edma.c ****         {
 636:../drivers/fsl_dspi_edma.c ****             t = channelPriorityLow;
 637:../drivers/fsl_dspi_edma.c ****             channelPriorityLow = channelPriorityHigh;
 638:../drivers/fsl_dspi_edma.c ****             channelPriorityHigh = t;
 639:../drivers/fsl_dspi_edma.c ****         }
 640:../drivers/fsl_dspi_edma.c **** 
 641:../drivers/fsl_dspi_edma.c ****         edma_channel_Preemption_config_t preemption_config_t;
 642:../drivers/fsl_dspi_edma.c ****         preemption_config_t.enableChannelPreemption = true;
 643:../drivers/fsl_dspi_edma.c ****         preemption_config_t.enablePreemptAbility = true;
 644:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityLow;
 645:../drivers/fsl_dspi_edma.c **** 
 646:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 647:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 648:../drivers/fsl_dspi_edma.c **** 
 649:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
 650:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 651:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 652:../drivers/fsl_dspi_edma.c ****         /*if there is Rx DMA request , carry the 32bits data (handle->command) to user data first ,
 653:../drivers/fsl_dspi_edma.c ****           channelC to carry the next data to PUSHER register.(txData to PUSHER) */
 654:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 0)
 655:../drivers/fsl_dspi_edma.c ****         {
 656:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHan
 657:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaIntermediaryToTxRegHandle->channel);
 658:../drivers/fsl_dspi_edma.c ****         }
 659:../drivers/fsl_dspi_edma.c ****     }
 660:../drivers/fsl_dspi_edma.c **** 
 661:../drivers/fsl_dspi_edma.c ****     DSPI_EnableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 662:../drivers/fsl_dspi_edma.c **** 
 663:../drivers/fsl_dspi_edma.c ****     /* Setup control info to PUSHER register. */
 664:../drivers/fsl_dspi_edma.c ****     *((uint16_t *)&(base->PUSHR) + 1) = (handle->command >> 16U);
 665:../drivers/fsl_dspi_edma.c **** #else
 666:../drivers/fsl_dspi_edma.c **** 
 667:../drivers/fsl_dspi_edma.c ****     /***channel_B *** used for carry the data from User_Send_Buffer to "intermediary" because the S
 668:../drivers/fsl_dspi_edma.c ****     write the 32bits at once time . Then use channel_C to carry the "intermediary" to SPIx_PUSHR. N
 669:../drivers/fsl_dspi_edma.c ****     SPIx_PUSHR upper 16 bits are the "command" and the low 16bits are data */
 670:../drivers/fsl_dspi_edma.c **** 
 671:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaTxDataToIntermediaryHandle->base, handle->edmaTxDataToIntermediar
 672:../drivers/fsl_dspi_edma.c **** 
 673:../drivers/fsl_dspi_edma.c ****     /*For DSPI instances with separate RX and TX DMA requests: use the scatter/gather to prepare th
 674:../drivers/fsl_dspi_edma.c ****      * (handle->lastCommand) to handle->Command*/
 675:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 676:../drivers/fsl_dspi_edma.c ****     {
 677:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcAddr = (uint32_t) & (handle->lastCommand);
 678:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t) & (handle->command);
 679:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize4Bytes;
 680:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 681:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcOffset = 0;
 682:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 683:../drivers/fsl_dspi_edma.c ****         transferConfigB.minorLoopBytes = 4;
 684:../drivers/fsl_dspi_edma.c ****         transferConfigB.majorLoopCounts = 1;
 685:../drivers/fsl_dspi_edma.c **** 
 686:../drivers/fsl_dspi_edma.c ****         EDMA_TcdReset(softwareTCD);
 687:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 688:../drivers/fsl_dspi_edma.c ****     }
 689:../drivers/fsl_dspi_edma.c **** 
 690:../drivers/fsl_dspi_edma.c ****     /*User_Send_Buffer(txData) to intermediary(handle->command)*/
 691:../drivers/fsl_dspi_edma.c ****     if (((((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame <= 8)) ||
 692:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8))) &&
 693:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))) ||
 694:../drivers/fsl_dspi_edma.c ****         (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 695:../drivers/fsl_dspi_edma.c ****     {
 696:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
 697:../drivers/fsl_dspi_edma.c ****         {
 698:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcAddr = (uint32_t)(handle->txData);
 699:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 1;
 700:../drivers/fsl_dspi_edma.c ****         }
 701:../drivers/fsl_dspi_edma.c ****         else
 702:../drivers/fsl_dspi_edma.c ****         {
 703:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcAddr = (uint32_t)(&handle->txBuffIfNull);
 704:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 0;
 705:../drivers/fsl_dspi_edma.c ****         }
 706:../drivers/fsl_dspi_edma.c **** 
 707:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t)(&handle->command);
 708:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 709:../drivers/fsl_dspi_edma.c **** 
 710:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize1Bytes;
 711:../drivers/fsl_dspi_edma.c **** 
 712:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
 713:../drivers/fsl_dspi_edma.c ****         {
 714:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize1Bytes;
 715:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 1;
 716:../drivers/fsl_dspi_edma.c **** 
 717:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 718:../drivers/fsl_dspi_edma.c ****             {
 719:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount - 2;
 720:../drivers/fsl_dspi_edma.c ****             }
 721:../drivers/fsl_dspi_edma.c ****             else
 722:../drivers/fsl_dspi_edma.c ****             {
 723:../drivers/fsl_dspi_edma.c ****                 /*Only enable channel_B minorlink to channel_C , so need to add one count due to th
 724:../drivers/fsl_dspi_edma.c ****                 majorlink , the majorlink would not trigger the channel_C*/
 725:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount + 1;
 726:../drivers/fsl_dspi_edma.c ****             }
 727:../drivers/fsl_dspi_edma.c ****         }
 728:../drivers/fsl_dspi_edma.c ****         else
 729:../drivers/fsl_dspi_edma.c ****         {
 730:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize2Bytes;
 731:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 2;
 732:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 733:../drivers/fsl_dspi_edma.c ****             {
 734:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount / 2 - 2;
 735:../drivers/fsl_dspi_edma.c ****             }
 736:../drivers/fsl_dspi_edma.c ****             else
 737:../drivers/fsl_dspi_edma.c ****             {
 738:../drivers/fsl_dspi_edma.c ****                 /*Only enable channel_B minorlink to channel_C , so need to add one count due to th
 739:../drivers/fsl_dspi_edma.c ****                 * majorlink*/
 740:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount / 2 + 1;
 741:../drivers/fsl_dspi_edma.c ****             }
 742:../drivers/fsl_dspi_edma.c ****         }
 743:../drivers/fsl_dspi_edma.c **** 
 744:../drivers/fsl_dspi_edma.c ****         if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 745:../drivers/fsl_dspi_edma.c ****         {
 746:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaTxDataToIntermediaryHandle->base,
 747:../drivers/fsl_dspi_edma.c ****                                    handle->edmaTxDataToIntermediaryHandle->channel, &transferConfig
 748:../drivers/fsl_dspi_edma.c ****             EDMA_EnableAutoStopRequest(handle->edmaIntermediaryToTxRegHandle->base,
 749:../drivers/fsl_dspi_edma.c ****                                        handle->edmaIntermediaryToTxRegHandle->channel, false);
 750:../drivers/fsl_dspi_edma.c ****         }
 751:../drivers/fsl_dspi_edma.c ****         else
 752:../drivers/fsl_dspi_edma.c ****         {
 753:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaTxDataToIntermediaryHandle->base,
 754:../drivers/fsl_dspi_edma.c ****                                    handle->edmaTxDataToIntermediaryHandle->channel, &transferConfig
 755:../drivers/fsl_dspi_edma.c ****         }
 756:../drivers/fsl_dspi_edma.c ****     }
 757:../drivers/fsl_dspi_edma.c ****     else
 758:../drivers/fsl_dspi_edma.c ****     {
 759:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaTxDataToIntermediaryHandle->base,
 760:../drivers/fsl_dspi_edma.c ****                                handle->edmaTxDataToIntermediaryHandle->channel, &transferConfigB, N
 761:../drivers/fsl_dspi_edma.c ****     }
 762:../drivers/fsl_dspi_edma.c **** 
 763:../drivers/fsl_dspi_edma.c ****     /***channel_C ***carry the "intermediary" to SPIx_PUSHR. used the edma Scatter Gather function 
 764:../drivers/fsl_dspi_edma.c ****     handle the last data */
 765:../drivers/fsl_dspi_edma.c **** 
 766:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigC;
 767:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaIntermediaryToTxRegHandle->base, handle->edmaIntermediaryToTxRegH
 768:../drivers/fsl_dspi_edma.c **** 
 769:../drivers/fsl_dspi_edma.c ****     /*For DSPI instances with shared RX/TX DMA requests: use the scatter/gather to prepare the last
 770:../drivers/fsl_dspi_edma.c ****      * (handle->lastCommand) to SPI_PUSHR*/
 771:../drivers/fsl_dspi_edma.c ****     if (((1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)) && (handle->remainingSendByteCou
 772:../drivers/fsl_dspi_edma.c ****     {
 773:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcAddr = (uint32_t) & (handle->lastCommand);
 774:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 775:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize4Bytes;
 776:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 777:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 778:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 779:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 780:../drivers/fsl_dspi_edma.c ****         transferConfigC.majorLoopCounts = 1;
 781:../drivers/fsl_dspi_edma.c **** 
 782:../drivers/fsl_dspi_edma.c ****         EDMA_TcdReset(softwareTCD);
 783:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigC, NULL);
 784:../drivers/fsl_dspi_edma.c ****     }
 785:../drivers/fsl_dspi_edma.c **** 
 786:../drivers/fsl_dspi_edma.c ****     if (((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 787:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8)) ||
 788:../drivers/fsl_dspi_edma.c ****         (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 789:../drivers/fsl_dspi_edma.c ****     {
 790:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcAddr = (uint32_t)(&(handle->command));
 791:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 792:../drivers/fsl_dspi_edma.c **** 
 793:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize4Bytes;
 794:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 795:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 796:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 797:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 798:../drivers/fsl_dspi_edma.c ****         if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 799:../drivers/fsl_dspi_edma.c ****         {
 800:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 801:../drivers/fsl_dspi_edma.c ****             {
 802:../drivers/fsl_dspi_edma.c ****                 transferConfigC.majorLoopCounts = handle->remainingSendByteCount - 1;
 803:../drivers/fsl_dspi_edma.c ****             }
 804:../drivers/fsl_dspi_edma.c ****             else
 805:../drivers/fsl_dspi_edma.c ****             {
 806:../drivers/fsl_dspi_edma.c ****                 transferConfigC.majorLoopCounts = handle->remainingSendByteCount / 2 - 1;
 807:../drivers/fsl_dspi_edma.c ****             }
 808:../drivers/fsl_dspi_edma.c **** 
 809:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 810:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 811:../drivers/fsl_dspi_edma.c ****         }
 812:../drivers/fsl_dspi_edma.c ****         else
 813:../drivers/fsl_dspi_edma.c ****         {
 814:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = 1;
 815:../drivers/fsl_dspi_edma.c **** 
 816:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 817:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 818:../drivers/fsl_dspi_edma.c ****         }
 819:../drivers/fsl_dspi_edma.c **** 
 820:../drivers/fsl_dspi_edma.c ****         EDMA_EnableAutoStopRequest(handle->edmaIntermediaryToTxRegHandle->base,
 821:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, false);
 822:../drivers/fsl_dspi_edma.c ****     }
 823:../drivers/fsl_dspi_edma.c ****     else
 824:../drivers/fsl_dspi_edma.c ****     {
 825:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 826:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC, NU
 827:../drivers/fsl_dspi_edma.c ****     }
 828:../drivers/fsl_dspi_edma.c **** 
 829:../drivers/fsl_dspi_edma.c ****     /*Start the EDMA channel_A , channel_B , channel_C transfer*/
 830:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaRxRegToRxDataHandle);
 831:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaTxDataToIntermediaryHandle);
 832:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaIntermediaryToTxRegHandle);
 833:../drivers/fsl_dspi_edma.c **** 
 834:../drivers/fsl_dspi_edma.c ****     /*Set channel priority*/
 835:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityLow = handle->edmaRxRegToRxDataHandle->channel;
 836:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityMid = handle->edmaTxDataToIntermediaryHandle->channel;
 837:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 838:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 839:../drivers/fsl_dspi_edma.c ****     if (channelPriorityLow > channelPriorityMid)
 840:../drivers/fsl_dspi_edma.c ****     {
 841:../drivers/fsl_dspi_edma.c ****         t = channelPriorityLow;
 842:../drivers/fsl_dspi_edma.c ****         channelPriorityLow = channelPriorityMid;
 843:../drivers/fsl_dspi_edma.c ****         channelPriorityMid = t;
 844:../drivers/fsl_dspi_edma.c ****     }
 845:../drivers/fsl_dspi_edma.c **** 
 846:../drivers/fsl_dspi_edma.c ****     if (channelPriorityLow > channelPriorityHigh)
 847:../drivers/fsl_dspi_edma.c ****     {
 848:../drivers/fsl_dspi_edma.c ****         t = channelPriorityLow;
 849:../drivers/fsl_dspi_edma.c ****         channelPriorityLow = channelPriorityHigh;
 850:../drivers/fsl_dspi_edma.c ****         channelPriorityHigh = t;
 851:../drivers/fsl_dspi_edma.c ****     }
 852:../drivers/fsl_dspi_edma.c **** 
 853:../drivers/fsl_dspi_edma.c ****     if (channelPriorityMid > channelPriorityHigh)
 854:../drivers/fsl_dspi_edma.c ****     {
 855:../drivers/fsl_dspi_edma.c ****         t = channelPriorityMid;
 856:../drivers/fsl_dspi_edma.c ****         channelPriorityMid = channelPriorityHigh;
 857:../drivers/fsl_dspi_edma.c ****         channelPriorityHigh = t;
 858:../drivers/fsl_dspi_edma.c ****     }
 859:../drivers/fsl_dspi_edma.c ****     edma_channel_Preemption_config_t preemption_config_t;
 860:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enableChannelPreemption = true;
 861:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 862:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
 863:../drivers/fsl_dspi_edma.c **** 
 864:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 865:../drivers/fsl_dspi_edma.c ****     {
 866:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 867:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 868:../drivers/fsl_dspi_edma.c **** 
 869:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityMid;
 870:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 871:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 872:../drivers/fsl_dspi_edma.c **** 
 873:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
 874:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 875:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 876:../drivers/fsl_dspi_edma.c ****     }
 877:../drivers/fsl_dspi_edma.c ****     else
 878:../drivers/fsl_dspi_edma.c ****     {
 879:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 880:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 881:../drivers/fsl_dspi_edma.c **** 
 882:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityMid;
 883:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 884:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 885:../drivers/fsl_dspi_edma.c **** 
 886:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
 887:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 888:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 889:../drivers/fsl_dspi_edma.c ****     }
 890:../drivers/fsl_dspi_edma.c **** 
 891:../drivers/fsl_dspi_edma.c ****     /*Set the channel link.*/
 892:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 893:../drivers/fsl_dspi_edma.c ****     {
 894:../drivers/fsl_dspi_edma.c ****         /*if there is Tx DMA request , carry the 32bits data (handle->command) to PUSHR first , the
 895:../drivers/fsl_dspi_edma.c ****         to prepare the next 32bits data (txData to handle->command) */
 896:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 1)
 897:../drivers/fsl_dspi_edma.c ****         {
 898:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaIntermediaryToTxRegHandle->base,
 899:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel, kEDMA_MajorLink,
 900:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel);
 901:../drivers/fsl_dspi_edma.c ****         }
 902:../drivers/fsl_dspi_edma.c **** 
 903:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 904:../drivers/fsl_dspi_edma.c ****     }
 905:../drivers/fsl_dspi_edma.c ****     else
 906:../drivers/fsl_dspi_edma.c ****     {
 907:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 0)
 908:../drivers/fsl_dspi_edma.c ****         {
 909:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHan
 910:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToIntermediaryHandle->channel);
 911:../drivers/fsl_dspi_edma.c **** 
 912:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaTxDataToIntermediaryHandle->base,
 913:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel, kEDMA_MinorLink,
 914:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel);
 915:../drivers/fsl_dspi_edma.c ****         }
 916:../drivers/fsl_dspi_edma.c **** 
 917:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable);
 918:../drivers/fsl_dspi_edma.c ****     }
 919:../drivers/fsl_dspi_edma.c **** #endif
 920:../drivers/fsl_dspi_edma.c ****     DSPI_StartTransfer(base);
 921:../drivers/fsl_dspi_edma.c **** 
 922:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
 923:../drivers/fsl_dspi_edma.c **** }
 924:../drivers/fsl_dspi_edma.c **** 
 925:../drivers/fsl_dspi_edma.c **** status_t DSPI_MasterHalfDuplexTransferEDMA(SPI_Type *base,
 926:../drivers/fsl_dspi_edma.c ****                                            dspi_master_edma_handle_t *handle,
 927:../drivers/fsl_dspi_edma.c ****                                            dspi_half_duplex_transfer_t *xfer)
 928:../drivers/fsl_dspi_edma.c **** {
 929:../drivers/fsl_dspi_edma.c ****     assert(xfer);
 930:../drivers/fsl_dspi_edma.c ****     assert(handle);
 931:../drivers/fsl_dspi_edma.c ****     dspi_transfer_t tempXfer = {0};
 932:../drivers/fsl_dspi_edma.c ****     status_t status;
 933:../drivers/fsl_dspi_edma.c **** 
 934:../drivers/fsl_dspi_edma.c ****     if (xfer->isTransmitFirst)
 935:../drivers/fsl_dspi_edma.c ****     {
 936:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = xfer->txData;
 937:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 938:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->txDataSize;
 939:../drivers/fsl_dspi_edma.c ****     }
 940:../drivers/fsl_dspi_edma.c ****     else
 941:../drivers/fsl_dspi_edma.c ****     {
 942:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = NULL;
 943:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = xfer->rxData;
 944:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 945:../drivers/fsl_dspi_edma.c ****     }
 946:../drivers/fsl_dspi_edma.c ****     /* If the pcs pin keep assert between transmit and receive. */
 947:../drivers/fsl_dspi_edma.c ****     if (xfer->isPcsAssertInTransfer)
 948:../drivers/fsl_dspi_edma.c ****     {
 949:../drivers/fsl_dspi_edma.c ****         tempXfer.configFlags = (xfer->configFlags) | kDSPI_MasterActiveAfterTransfer;
 950:../drivers/fsl_dspi_edma.c ****     }
 951:../drivers/fsl_dspi_edma.c ****     else
 952:../drivers/fsl_dspi_edma.c ****     {
 953:../drivers/fsl_dspi_edma.c ****         tempXfer.configFlags = (xfer->configFlags) & (uint32_t)(~kDSPI_MasterActiveAfterTransfer);
 954:../drivers/fsl_dspi_edma.c ****     }
 955:../drivers/fsl_dspi_edma.c **** 
 956:../drivers/fsl_dspi_edma.c ****     status = DSPI_MasterTransferBlocking(base, &tempXfer);
 957:../drivers/fsl_dspi_edma.c ****     if (status != kStatus_Success)
 958:../drivers/fsl_dspi_edma.c ****     {
 959:../drivers/fsl_dspi_edma.c ****         return status;
 960:../drivers/fsl_dspi_edma.c ****     }
 961:../drivers/fsl_dspi_edma.c **** 
 962:../drivers/fsl_dspi_edma.c ****     if (xfer->isTransmitFirst)
 963:../drivers/fsl_dspi_edma.c ****     {
 964:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = NULL;
 965:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = xfer->rxData;
 966:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 967:../drivers/fsl_dspi_edma.c ****     }
 968:../drivers/fsl_dspi_edma.c ****     else
 969:../drivers/fsl_dspi_edma.c ****     {
 970:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = xfer->txData;
 971:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 972:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->txDataSize;
 973:../drivers/fsl_dspi_edma.c ****     }
 974:../drivers/fsl_dspi_edma.c ****     tempXfer.configFlags = xfer->configFlags;
 975:../drivers/fsl_dspi_edma.c **** 
 976:../drivers/fsl_dspi_edma.c ****     status = DSPI_MasterTransferEDMA(base, handle, &tempXfer);
 977:../drivers/fsl_dspi_edma.c **** 
 978:../drivers/fsl_dspi_edma.c ****     return status;
 979:../drivers/fsl_dspi_edma.c **** }
 980:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiMasterCallback(edma_handle_t *edmaHandle,
 981:../drivers/fsl_dspi_edma.c ****                                     void *g_dspiEdmaPrivateHandle,
 982:../drivers/fsl_dspi_edma.c ****                                     bool transferDone,
 983:../drivers/fsl_dspi_edma.c ****                                     uint32_t tcds)
 984:../drivers/fsl_dspi_edma.c **** {
  76              		.loc 2 984 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 0, uses_anonymous_args = 0
  80              		@ link register save eliminated.
  81              	.LVL4:
 985:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
 986:../drivers/fsl_dspi_edma.c ****     assert(g_dspiEdmaPrivateHandle);
 987:../drivers/fsl_dspi_edma.c **** 
 988:../drivers/fsl_dspi_edma.c ****     dspi_master_edma_private_handle_t *dspiEdmaPrivateHandle;
 989:../drivers/fsl_dspi_edma.c **** 
 990:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle = (dspi_master_edma_private_handle_t *)g_dspiEdmaPrivateHandle;
 991:../drivers/fsl_dspi_edma.c **** 
 992:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA((dspiEdmaPrivateHandle->base), kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
  82              		.loc 2 992 0
  83 0000 0868     		ldr	r0, [r1]
  84              	.LVL5:
 993:../drivers/fsl_dspi_edma.c **** 
 994:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle->handle->state = kDSPI_Idle;
  85              		.loc 2 994 0
  86 0002 4968     		ldr	r1, [r1, #4]
  87              	.LVL6:
  88              	.LBB102:
  89              	.LBB103:
  90              		.file 3 "../drivers/fsl_dspi.h"
   1:../drivers/fsl_dspi.h **** /*
   2:../drivers/fsl_dspi.h ****  * The Clear BSD License
   3:../drivers/fsl_dspi.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dspi.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dspi.h ****  * All rights reserved.
   6:../drivers/fsl_dspi.h ****  *
   7:../drivers/fsl_dspi.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dspi.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dspi.h ****  * that the following conditions are met:
  10:../drivers/fsl_dspi.h ****  *
  11:../drivers/fsl_dspi.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dspi.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dspi.h ****  *
  14:../drivers/fsl_dspi.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dspi.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dspi.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dspi.h ****  *
  18:../drivers/fsl_dspi.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dspi.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dspi.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dspi.h ****  *
  22:../drivers/fsl_dspi.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dspi.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dspi.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dspi.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dspi.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dspi.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dspi.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dspi.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dspi.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dspi.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dspi.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dspi.h ****  */
  34:../drivers/fsl_dspi.h **** #ifndef _FSL_DSPI_H_
  35:../drivers/fsl_dspi.h **** #define _FSL_DSPI_H_
  36:../drivers/fsl_dspi.h **** 
  37:../drivers/fsl_dspi.h **** #include "fsl_common.h"
  38:../drivers/fsl_dspi.h **** 
  39:../drivers/fsl_dspi.h **** /*!
  40:../drivers/fsl_dspi.h ****  * @addtogroup dspi_driver
  41:../drivers/fsl_dspi.h ****  * @{
  42:../drivers/fsl_dspi.h ****  */
  43:../drivers/fsl_dspi.h **** 
  44:../drivers/fsl_dspi.h **** /**************************************************************************************************
  45:../drivers/fsl_dspi.h ****  * Definitions
  46:../drivers/fsl_dspi.h ****  **************************************************************************************************
  47:../drivers/fsl_dspi.h **** 
  48:../drivers/fsl_dspi.h **** /*! @name Driver version */
  49:../drivers/fsl_dspi.h **** /*@{*/
  50:../drivers/fsl_dspi.h **** /*! @brief DSPI driver version 2.2.0. */
  51:../drivers/fsl_dspi.h **** #define FSL_DSPI_DRIVER_VERSION (MAKE_VERSION(2, 2, 0))
  52:../drivers/fsl_dspi.h **** /*@}*/
  53:../drivers/fsl_dspi.h **** 
  54:../drivers/fsl_dspi.h **** #ifndef DSPI_DUMMY_DATA
  55:../drivers/fsl_dspi.h **** /*! @brief DSPI dummy data if there is no Tx data.*/
  56:../drivers/fsl_dspi.h **** #define DSPI_DUMMY_DATA (0x00U) /*!< Dummy data used for Tx if there is no txData. */
  57:../drivers/fsl_dspi.h **** #endif
  58:../drivers/fsl_dspi.h **** 
  59:../drivers/fsl_dspi.h **** /*! @brief Status for the DSPI driver.*/
  60:../drivers/fsl_dspi.h **** enum _dspi_status
  61:../drivers/fsl_dspi.h **** {
  62:../drivers/fsl_dspi.h ****     kStatus_DSPI_Busy = MAKE_STATUS(kStatusGroup_DSPI, 0),      /*!< DSPI transfer is busy.*/
  63:../drivers/fsl_dspi.h ****     kStatus_DSPI_Error = MAKE_STATUS(kStatusGroup_DSPI, 1),     /*!< DSPI driver error. */
  64:../drivers/fsl_dspi.h ****     kStatus_DSPI_Idle = MAKE_STATUS(kStatusGroup_DSPI, 2),      /*!< DSPI is idle.*/
  65:../drivers/fsl_dspi.h ****     kStatus_DSPI_OutOfRange = MAKE_STATUS(kStatusGroup_DSPI, 3) /*!< DSPI transfer out of range. */
  66:../drivers/fsl_dspi.h **** };
  67:../drivers/fsl_dspi.h **** 
  68:../drivers/fsl_dspi.h **** /*! @brief DSPI status flags in SPIx_SR register.*/
  69:../drivers/fsl_dspi.h **** enum _dspi_flags
  70:../drivers/fsl_dspi.h **** {
  71:../drivers/fsl_dspi.h ****     kDSPI_TxCompleteFlag = SPI_SR_TCF_MASK,          /*!< Transfer Complete Flag. */
  72:../drivers/fsl_dspi.h ****     kDSPI_EndOfQueueFlag = SPI_SR_EOQF_MASK,         /*!< End of Queue Flag.*/
  73:../drivers/fsl_dspi.h ****     kDSPI_TxFifoUnderflowFlag = SPI_SR_TFUF_MASK,    /*!< Transmit FIFO Underflow Flag.*/
  74:../drivers/fsl_dspi.h ****     kDSPI_TxFifoFillRequestFlag = SPI_SR_TFFF_MASK,  /*!< Transmit FIFO Fill Flag.*/
  75:../drivers/fsl_dspi.h ****     kDSPI_RxFifoOverflowFlag = SPI_SR_RFOF_MASK,     /*!< Receive FIFO Overflow Flag.*/
  76:../drivers/fsl_dspi.h ****     kDSPI_RxFifoDrainRequestFlag = SPI_SR_RFDF_MASK, /*!< Receive FIFO Drain Flag.*/
  77:../drivers/fsl_dspi.h ****     kDSPI_TxAndRxStatusFlag = SPI_SR_TXRXS_MASK,     /*!< The module is in Stopped/Running state.*/
  78:../drivers/fsl_dspi.h ****     kDSPI_AllStatusFlag = SPI_SR_TCF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK 
  79:../drivers/fsl_dspi.h ****                           SPI_SR_RFDF_MASK | SPI_SR_TXRXS_MASK /*!< All statuses above.*/
  80:../drivers/fsl_dspi.h **** };
  81:../drivers/fsl_dspi.h **** 
  82:../drivers/fsl_dspi.h **** /*! @brief DSPI interrupt source.*/
  83:../drivers/fsl_dspi.h **** enum _dspi_interrupt_enable
  84:../drivers/fsl_dspi.h **** {
  85:../drivers/fsl_dspi.h ****     kDSPI_TxCompleteInterruptEnable = SPI_RSER_TCF_RE_MASK,          /*!< TCF  interrupt enable.*/
  86:../drivers/fsl_dspi.h ****     kDSPI_EndOfQueueInterruptEnable = SPI_RSER_EOQF_RE_MASK,         /*!< EOQF interrupt enable.*/
  87:../drivers/fsl_dspi.h ****     kDSPI_TxFifoUnderflowInterruptEnable = SPI_RSER_TFUF_RE_MASK,    /*!< TFUF interrupt enable.*/
  88:../drivers/fsl_dspi.h ****     kDSPI_TxFifoFillRequestInterruptEnable = SPI_RSER_TFFF_RE_MASK,  /*!< TFFF interrupt enable, DM
  89:../drivers/fsl_dspi.h ****     kDSPI_RxFifoOverflowInterruptEnable = SPI_RSER_RFOF_RE_MASK,     /*!< RFOF interrupt enable.*/
  90:../drivers/fsl_dspi.h ****     kDSPI_RxFifoDrainRequestInterruptEnable = SPI_RSER_RFDF_RE_MASK, /*!< RFDF interrupt enable, DM
  91:../drivers/fsl_dspi.h ****     kDSPI_AllInterruptEnable = SPI_RSER_TCF_RE_MASK | SPI_RSER_EOQF_RE_MASK | SPI_RSER_TFUF_RE_MASK
  92:../drivers/fsl_dspi.h ****                                SPI_RSER_TFFF_RE_MASK | SPI_RSER_RFOF_RE_MASK | SPI_RSER_RFDF_RE_MAS
  93:../drivers/fsl_dspi.h ****     /*!< All above interrupts enable.*/
  94:../drivers/fsl_dspi.h **** };
  95:../drivers/fsl_dspi.h **** 
  96:../drivers/fsl_dspi.h **** /*! @brief DSPI DMA source.*/
  97:../drivers/fsl_dspi.h **** enum _dspi_dma_enable
  98:../drivers/fsl_dspi.h **** {
  99:../drivers/fsl_dspi.h ****     kDSPI_TxDmaEnable = (SPI_RSER_TFFF_RE_MASK | SPI_RSER_TFFF_DIRS_MASK), /*!< TFFF flag generates
 100:../drivers/fsl_dspi.h ****                                                                                 No Tx interrupt req
 101:../drivers/fsl_dspi.h ****     kDSPI_RxDmaEnable = (SPI_RSER_RFDF_RE_MASK | SPI_RSER_RFDF_DIRS_MASK)  /*!< RFDF flag generates
 102:../drivers/fsl_dspi.h ****                                                                                 No Rx interrupt req
 103:../drivers/fsl_dspi.h **** };
 104:../drivers/fsl_dspi.h **** 
 105:../drivers/fsl_dspi.h **** /*! @brief DSPI master or slave mode configuration.*/
 106:../drivers/fsl_dspi.h **** typedef enum _dspi_master_slave_mode
 107:../drivers/fsl_dspi.h **** {
 108:../drivers/fsl_dspi.h ****     kDSPI_Master = 1U, /*!< DSPI peripheral operates in master mode.*/
 109:../drivers/fsl_dspi.h ****     kDSPI_Slave = 0U   /*!< DSPI peripheral operates in slave mode.*/
 110:../drivers/fsl_dspi.h **** } dspi_master_slave_mode_t;
 111:../drivers/fsl_dspi.h **** 
 112:../drivers/fsl_dspi.h **** /*!
 113:../drivers/fsl_dspi.h ****  * @brief DSPI Sample Point: Controls when the DSPI master samples SIN in the Modified Transfer For
 114:../drivers/fsl_dspi.h ****  * valid
 115:../drivers/fsl_dspi.h ****  * only when the CPHA bit in the CTAR register is 0.
 116:../drivers/fsl_dspi.h ****  */
 117:../drivers/fsl_dspi.h **** typedef enum _dspi_master_sample_point
 118:../drivers/fsl_dspi.h **** {
 119:../drivers/fsl_dspi.h ****     kDSPI_SckToSin0Clock = 0U, /*!< 0 system clocks between SCK edge and SIN sample.*/
 120:../drivers/fsl_dspi.h ****     kDSPI_SckToSin1Clock = 1U, /*!< 1 system clock  between SCK edge and SIN sample.*/
 121:../drivers/fsl_dspi.h ****     kDSPI_SckToSin2Clock = 2U  /*!< 2 system clocks between SCK edge and SIN sample.*/
 122:../drivers/fsl_dspi.h **** } dspi_master_sample_point_t;
 123:../drivers/fsl_dspi.h **** 
 124:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) configuration (which Pcs to configure).*/
 125:../drivers/fsl_dspi.h **** typedef enum _dspi_which_pcs_config
 126:../drivers/fsl_dspi.h **** {
 127:../drivers/fsl_dspi.h ****     kDSPI_Pcs0 = 1U << 0, /*!< Pcs[0] */
 128:../drivers/fsl_dspi.h ****     kDSPI_Pcs1 = 1U << 1, /*!< Pcs[1] */
 129:../drivers/fsl_dspi.h ****     kDSPI_Pcs2 = 1U << 2, /*!< Pcs[2] */
 130:../drivers/fsl_dspi.h ****     kDSPI_Pcs3 = 1U << 3, /*!< Pcs[3] */
 131:../drivers/fsl_dspi.h ****     kDSPI_Pcs4 = 1U << 4, /*!< Pcs[4] */
 132:../drivers/fsl_dspi.h ****     kDSPI_Pcs5 = 1U << 5  /*!< Pcs[5] */
 133:../drivers/fsl_dspi.h **** } dspi_which_pcs_t;
 134:../drivers/fsl_dspi.h **** 
 135:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) Polarity configuration.*/
 136:../drivers/fsl_dspi.h **** typedef enum _dspi_pcs_polarity_config
 137:../drivers/fsl_dspi.h **** {
 138:../drivers/fsl_dspi.h ****     kDSPI_PcsActiveHigh = 0U, /*!< Pcs Active High (idles low). */
 139:../drivers/fsl_dspi.h ****     kDSPI_PcsActiveLow = 1U   /*!< Pcs Active Low (idles high). */
 140:../drivers/fsl_dspi.h **** } dspi_pcs_polarity_config_t;
 141:../drivers/fsl_dspi.h **** 
 142:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) Polarity.*/
 143:../drivers/fsl_dspi.h **** enum _dspi_pcs_polarity
 144:../drivers/fsl_dspi.h **** {
 145:../drivers/fsl_dspi.h ****     kDSPI_Pcs0ActiveLow = 1U << 0, /*!< Pcs0 Active Low (idles high). */
 146:../drivers/fsl_dspi.h ****     kDSPI_Pcs1ActiveLow = 1U << 1, /*!< Pcs1 Active Low (idles high). */
 147:../drivers/fsl_dspi.h ****     kDSPI_Pcs2ActiveLow = 1U << 2, /*!< Pcs2 Active Low (idles high). */
 148:../drivers/fsl_dspi.h ****     kDSPI_Pcs3ActiveLow = 1U << 3, /*!< Pcs3 Active Low (idles high). */
 149:../drivers/fsl_dspi.h ****     kDSPI_Pcs4ActiveLow = 1U << 4, /*!< Pcs4 Active Low (idles high). */
 150:../drivers/fsl_dspi.h ****     kDSPI_Pcs5ActiveLow = 1U << 5, /*!< Pcs5 Active Low (idles high). */
 151:../drivers/fsl_dspi.h ****     kDSPI_PcsAllActiveLow = 0xFFU  /*!< Pcs0 to Pcs5 Active Low (idles high). */
 152:../drivers/fsl_dspi.h **** };
 153:../drivers/fsl_dspi.h **** 
 154:../drivers/fsl_dspi.h **** /*! @brief DSPI clock polarity configuration for a given CTAR.*/
 155:../drivers/fsl_dspi.h **** typedef enum _dspi_clock_polarity
 156:../drivers/fsl_dspi.h **** {
 157:../drivers/fsl_dspi.h ****     kDSPI_ClockPolarityActiveHigh = 0U, /*!< CPOL=0. Active-high DSPI clock (idles low).*/
 158:../drivers/fsl_dspi.h ****     kDSPI_ClockPolarityActiveLow = 1U   /*!< CPOL=1. Active-low DSPI clock (idles high).*/
 159:../drivers/fsl_dspi.h **** } dspi_clock_polarity_t;
 160:../drivers/fsl_dspi.h **** 
 161:../drivers/fsl_dspi.h **** /*! @brief DSPI clock phase configuration for a given CTAR.*/
 162:../drivers/fsl_dspi.h **** typedef enum _dspi_clock_phase
 163:../drivers/fsl_dspi.h **** {
 164:../drivers/fsl_dspi.h ****     kDSPI_ClockPhaseFirstEdge = 0U, /*!< CPHA=0. Data is captured on the leading edge of the SCK an
 165:../drivers/fsl_dspi.h ****                                          following edge.*/
 166:../drivers/fsl_dspi.h ****     kDSPI_ClockPhaseSecondEdge = 1U /*!< CPHA=1. Data is changed on the leading edge of the SCK and
 167:../drivers/fsl_dspi.h ****                                         following edge.*/
 168:../drivers/fsl_dspi.h **** } dspi_clock_phase_t;
 169:../drivers/fsl_dspi.h **** 
 170:../drivers/fsl_dspi.h **** /*! @brief DSPI data shifter direction options for a given CTAR.*/
 171:../drivers/fsl_dspi.h **** typedef enum _dspi_shift_direction
 172:../drivers/fsl_dspi.h **** {
 173:../drivers/fsl_dspi.h ****     kDSPI_MsbFirst = 0U, /*!< Data transfers start with most significant bit.*/
 174:../drivers/fsl_dspi.h ****     kDSPI_LsbFirst = 1U  /*!< Data transfers start with least significant bit.
 175:../drivers/fsl_dspi.h ****                               Shifting out of LSB is not supported for slave */
 176:../drivers/fsl_dspi.h **** } dspi_shift_direction_t;
 177:../drivers/fsl_dspi.h **** 
 178:../drivers/fsl_dspi.h **** /*! @brief DSPI delay type selection.*/
 179:../drivers/fsl_dspi.h **** typedef enum _dspi_delay_type
 180:../drivers/fsl_dspi.h **** {
 181:../drivers/fsl_dspi.h ****     kDSPI_PcsToSck = 1U,  /*!< Pcs-to-SCK delay. */
 182:../drivers/fsl_dspi.h ****     kDSPI_LastSckToPcs,   /*!< The last SCK edge to Pcs delay. */
 183:../drivers/fsl_dspi.h ****     kDSPI_BetweenTransfer /*!< Delay between transfers. */
 184:../drivers/fsl_dspi.h **** } dspi_delay_type_t;
 185:../drivers/fsl_dspi.h **** 
 186:../drivers/fsl_dspi.h **** /*! @brief DSPI Clock and Transfer Attributes Register (CTAR) selection.*/
 187:../drivers/fsl_dspi.h **** typedef enum _dspi_ctar_selection
 188:../drivers/fsl_dspi.h **** {
 189:../drivers/fsl_dspi.h ****     kDSPI_Ctar0 = 0U, /*!< CTAR0 selection option for master or slave mode; note that CTAR0 and CTA
 190:../drivers/fsl_dspi.h ****                          same register address. */
 191:../drivers/fsl_dspi.h ****     kDSPI_Ctar1 = 1U, /*!< CTAR1 selection option for master mode only. */
 192:../drivers/fsl_dspi.h ****     kDSPI_Ctar2 = 2U, /*!< CTAR2 selection option for master mode only; note that some devices do n
 193:../drivers/fsl_dspi.h ****     kDSPI_Ctar3 = 3U, /*!< CTAR3 selection option for master mode only; note that some devices do n
 194:../drivers/fsl_dspi.h ****     kDSPI_Ctar4 = 4U, /*!< CTAR4 selection option for master mode only; note that some devices do n
 195:../drivers/fsl_dspi.h ****     kDSPI_Ctar5 = 5U, /*!< CTAR5 selection option for master mode only; note that some devices do n
 196:../drivers/fsl_dspi.h ****     kDSPI_Ctar6 = 6U, /*!< CTAR6 selection option for master mode only; note that some devices do n
 197:../drivers/fsl_dspi.h ****     kDSPI_Ctar7 = 7U  /*!< CTAR7 selection option for master mode only; note that some devices do n
 198:../drivers/fsl_dspi.h **** } dspi_ctar_selection_t;
 199:../drivers/fsl_dspi.h **** 
 200:../drivers/fsl_dspi.h **** #define DSPI_MASTER_CTAR_SHIFT (0U)   /*!< DSPI master CTAR shift macro; used internally. */
 201:../drivers/fsl_dspi.h **** #define DSPI_MASTER_CTAR_MASK (0x0FU) /*!< DSPI master CTAR mask macro; used internally. */
 202:../drivers/fsl_dspi.h **** #define DSPI_MASTER_PCS_SHIFT (4U)    /*!< DSPI master PCS shift macro; used internally. */
 203:../drivers/fsl_dspi.h **** #define DSPI_MASTER_PCS_MASK (0xF0U)  /*!< DSPI master PCS mask macro; used internally. */
 204:../drivers/fsl_dspi.h **** /*! @brief Use this enumeration for the DSPI master transfer configFlags. */
 205:../drivers/fsl_dspi.h **** enum _dspi_transfer_config_flag_for_master
 206:../drivers/fsl_dspi.h **** {
 207:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar0 = 0U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR0 setting. 
 208:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar1 = 1U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR1 setting. 
 209:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar2 = 2U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR2 setting. 
 210:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar3 = 3U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR3 setting. 
 211:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar4 = 4U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR4 setting. 
 212:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar5 = 5U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR5 setting. 
 213:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar6 = 6U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR6 setting. 
 214:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar7 = 7U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR7 setting. 
 215:../drivers/fsl_dspi.h **** 
 216:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs0 = 0U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS0 signal. */
 217:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs1 = 1U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS1 signal. */
 218:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs2 = 2U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS2 signal.*/
 219:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs3 = 3U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS3 signal. */
 220:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs4 = 4U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS4 signal. */
 221:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs5 = 5U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS5 signal. */
 222:../drivers/fsl_dspi.h **** 
 223:../drivers/fsl_dspi.h ****     kDSPI_MasterPcsContinuous = 1U << 20, /*!< Indicates whether the PCS signal is continuous. */
 224:../drivers/fsl_dspi.h ****     kDSPI_MasterActiveAfterTransfer =
 225:../drivers/fsl_dspi.h ****         1U << 21, /*!< Indicates whether the PCS signal is active after the last frame transfer.*/
 226:../drivers/fsl_dspi.h **** };
 227:../drivers/fsl_dspi.h **** 
 228:../drivers/fsl_dspi.h **** #define DSPI_SLAVE_CTAR_SHIFT (0U)   /*!< DSPI slave CTAR shift macro; used internally. */
 229:../drivers/fsl_dspi.h **** #define DSPI_SLAVE_CTAR_MASK (0x07U) /*!< DSPI slave CTAR mask macro; used internally. */
 230:../drivers/fsl_dspi.h **** /*! @brief Use this enumeration for the DSPI slave transfer configFlags. */
 231:../drivers/fsl_dspi.h **** enum _dspi_transfer_config_flag_for_slave
 232:../drivers/fsl_dspi.h **** {
 233:../drivers/fsl_dspi.h ****     kDSPI_SlaveCtar0 = 0U << DSPI_SLAVE_CTAR_SHIFT, /*!< DSPI slave transfer use CTAR0 setting. */
 234:../drivers/fsl_dspi.h ****                                                     /*!< DSPI slave can only use PCS0. */
 235:../drivers/fsl_dspi.h **** };
 236:../drivers/fsl_dspi.h **** 
 237:../drivers/fsl_dspi.h **** /*! @brief DSPI transfer state, which is used for DSPI transactional API state machine. */
 238:../drivers/fsl_dspi.h **** enum _dspi_transfer_state
 239:../drivers/fsl_dspi.h **** {
 240:../drivers/fsl_dspi.h ****     kDSPI_Idle = 0x0U, /*!< Nothing in the transmitter/receiver. */
 241:../drivers/fsl_dspi.h ****     kDSPI_Busy,        /*!< Transfer queue is not finished. */
 242:../drivers/fsl_dspi.h ****     kDSPI_Error        /*!< Transfer error. */
 243:../drivers/fsl_dspi.h **** };
 244:../drivers/fsl_dspi.h **** 
 245:../drivers/fsl_dspi.h **** /*! @brief DSPI master command date configuration used for the SPIx_PUSHR.*/
 246:../drivers/fsl_dspi.h **** typedef struct _dspi_command_data_config
 247:../drivers/fsl_dspi.h **** {
 248:../drivers/fsl_dspi.h ****     bool isPcsContinuous; /*!< Option to enable the continuous assertion of the chip select between
 249:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar; /*!< The desired Clock and Transfer Attributes
 250:../drivers/fsl_dspi.h ****                                           Register (CTAR) to use for CTAS.*/
 251:../drivers/fsl_dspi.h ****     dspi_which_pcs_t whichPcs;       /*!< The desired PCS signal to use for the data transfer.*/
 252:../drivers/fsl_dspi.h ****     bool isEndOfQueue;               /*!< Signals that the current transfer is the last in the queu
 253:../drivers/fsl_dspi.h ****     bool clearTransferCount;         /*!< Clears the SPI Transfer Counter (SPI_TCNT) before transmi
 254:../drivers/fsl_dspi.h **** } dspi_command_data_config_t;
 255:../drivers/fsl_dspi.h **** 
 256:../drivers/fsl_dspi.h **** /*! @brief DSPI master ctar configuration structure.*/
 257:../drivers/fsl_dspi.h **** typedef struct _dspi_master_ctar_config
 258:../drivers/fsl_dspi.h **** {
 259:../drivers/fsl_dspi.h ****     uint32_t baudRate;                /*!< Baud Rate for DSPI. */
 260:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;            /*!< Bits per frame, minimum 4, maximum 16.*/
 261:../drivers/fsl_dspi.h ****     dspi_clock_polarity_t cpol;       /*!< Clock polarity. */
 262:../drivers/fsl_dspi.h ****     dspi_clock_phase_t cpha;          /*!< Clock phase. */
 263:../drivers/fsl_dspi.h ****     dspi_shift_direction_t direction; /*!< MSB or LSB data shift direction. */
 264:../drivers/fsl_dspi.h **** 
 265:../drivers/fsl_dspi.h ****     uint32_t pcsToSckDelayInNanoSec;     /*!< PCS to SCK delay time in nanoseconds; setting to 0 se
 266:../drivers/fsl_dspi.h ****                                             delay. It also sets the boundary value if out of range.
 267:../drivers/fsl_dspi.h ****     uint32_t lastSckToPcsDelayInNanoSec; /*!< The last SCK to PCS delay time in nanoseconds; settin
 268:../drivers/fsl_dspi.h ****                                             minimum delay. It also sets the boundary value if out o
 269:../drivers/fsl_dspi.h **** 
 270:../drivers/fsl_dspi.h ****     uint32_t betweenTransferDelayInNanoSec; /*!< After the SCK delay time in nanoseconds; setting t
 271:../drivers/fsl_dspi.h ****                                              delay. It also sets the boundary value if out of range
 272:../drivers/fsl_dspi.h **** } dspi_master_ctar_config_t;
 273:../drivers/fsl_dspi.h **** 
 274:../drivers/fsl_dspi.h **** /*! @brief DSPI master configuration structure.*/
 275:../drivers/fsl_dspi.h **** typedef struct _dspi_master_config
 276:../drivers/fsl_dspi.h **** {
 277:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar;      /*!< The desired CTAR to use. */
 278:../drivers/fsl_dspi.h ****     dspi_master_ctar_config_t ctarConfig; /*!< Set the ctarConfig to the desired CTAR. */
 279:../drivers/fsl_dspi.h **** 
 280:../drivers/fsl_dspi.h ****     dspi_which_pcs_t whichPcs;                     /*!< The desired Peripheral Chip Select (pcs). *
 281:../drivers/fsl_dspi.h ****     dspi_pcs_polarity_config_t pcsActiveHighOrLow; /*!< The desired PCS active high or low. */
 282:../drivers/fsl_dspi.h **** 
 283:../drivers/fsl_dspi.h ****     bool enableContinuousSCK;   /*!< CONT_SCKE, continuous SCK enable. Note that the continuous SCK
 284:../drivers/fsl_dspi.h ****                                      supported for CPHA = 1.*/
 285:../drivers/fsl_dspi.h ****     bool enableRxFifoOverWrite; /*!< ROOE, receive FIFO overflow overwrite enable. If ROOE = 0, the
 286:../drivers/fsl_dspi.h ****                                      data is ignored and the data from the transfer that generated 
 287:../drivers/fsl_dspi.h ****                                      is also ignored. If ROOE = 1, the incoming data is shifted to 
 288:../drivers/fsl_dspi.h ****                                      shift register. */
 289:../drivers/fsl_dspi.h **** 
 290:../drivers/fsl_dspi.h ****     bool enableModifiedTimingFormat;        /*!< Enables a modified transfer format to be used if t
 291:../drivers/fsl_dspi.h ****     dspi_master_sample_point_t samplePoint; /*!< Controls when the module master samples SIN in the
 292:../drivers/fsl_dspi.h ****                                                  Format. It's valid only when CPHA=0. */
 293:../drivers/fsl_dspi.h **** } dspi_master_config_t;
 294:../drivers/fsl_dspi.h **** 
 295:../drivers/fsl_dspi.h **** /*! @brief DSPI slave ctar configuration structure.*/
 296:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_ctar_config
 297:../drivers/fsl_dspi.h **** {
 298:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;      /*!< Bits per frame, minimum 4, maximum 16.*/
 299:../drivers/fsl_dspi.h ****     dspi_clock_polarity_t cpol; /*!< Clock polarity. */
 300:../drivers/fsl_dspi.h ****     dspi_clock_phase_t cpha;    /*!< Clock phase. */
 301:../drivers/fsl_dspi.h ****                                 /*!< Slave only supports MSB and does not support LSB.*/
 302:../drivers/fsl_dspi.h **** } dspi_slave_ctar_config_t;
 303:../drivers/fsl_dspi.h **** 
 304:../drivers/fsl_dspi.h **** /*! @brief DSPI slave configuration structure.*/
 305:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_config
 306:../drivers/fsl_dspi.h **** {
 307:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar;     /*!< The desired CTAR to use. */
 308:../drivers/fsl_dspi.h ****     dspi_slave_ctar_config_t ctarConfig; /*!< Set the ctarConfig to the desired CTAR. */
 309:../drivers/fsl_dspi.h **** 
 310:../drivers/fsl_dspi.h ****     bool enableContinuousSCK;               /*!< CONT_SCKE, continuous SCK enable. Note that the co
 311:../drivers/fsl_dspi.h ****                                                  supported for CPHA = 1.*/
 312:../drivers/fsl_dspi.h ****     bool enableRxFifoOverWrite;             /*!< ROOE, receive FIFO overflow overwrite enable. If R
 313:../drivers/fsl_dspi.h ****                                                  data is ignored and the data from the transfer tha
 314:../drivers/fsl_dspi.h ****                                                  is also ignored. If ROOE = 1, the incoming data is
 315:../drivers/fsl_dspi.h ****                                                  shift register. */
 316:../drivers/fsl_dspi.h ****     bool enableModifiedTimingFormat;        /*!< Enables a modified transfer format to be used if t
 317:../drivers/fsl_dspi.h ****     dspi_master_sample_point_t samplePoint; /*!< Controls when the module master samples SIN in the
 318:../drivers/fsl_dspi.h ****                                                Format. It's valid only when CPHA=0. */
 319:../drivers/fsl_dspi.h **** } dspi_slave_config_t;
 320:../drivers/fsl_dspi.h **** 
 321:../drivers/fsl_dspi.h **** /*!
 322:../drivers/fsl_dspi.h **** * @brief Forward declaration of the _dspi_master_handle typedefs.
 323:../drivers/fsl_dspi.h **** */
 324:../drivers/fsl_dspi.h **** typedef struct _dspi_master_handle dspi_master_handle_t;
 325:../drivers/fsl_dspi.h **** 
 326:../drivers/fsl_dspi.h **** /*!
 327:../drivers/fsl_dspi.h **** * @brief Forward declaration of the _dspi_slave_handle typedefs.
 328:../drivers/fsl_dspi.h **** */
 329:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_handle dspi_slave_handle_t;
 330:../drivers/fsl_dspi.h **** 
 331:../drivers/fsl_dspi.h **** /*!
 332:../drivers/fsl_dspi.h ****  * @brief Completion callback function pointer type.
 333:../drivers/fsl_dspi.h ****  *
 334:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 335:../drivers/fsl_dspi.h ****  * @param handle Pointer to the handle for the DSPI master.
 336:../drivers/fsl_dspi.h ****  * @param status Success or error code describing whether the transfer completed.
 337:../drivers/fsl_dspi.h ****  * @param userData Arbitrary pointer-dataSized value passed from the application.
 338:../drivers/fsl_dspi.h ****  */
 339:../drivers/fsl_dspi.h **** typedef void (*dspi_master_transfer_callback_t)(SPI_Type *base,
 340:../drivers/fsl_dspi.h ****                                                 dspi_master_handle_t *handle,
 341:../drivers/fsl_dspi.h ****                                                 status_t status,
 342:../drivers/fsl_dspi.h ****                                                 void *userData);
 343:../drivers/fsl_dspi.h **** /*!
 344:../drivers/fsl_dspi.h ****  * @brief Completion callback function pointer type.
 345:../drivers/fsl_dspi.h ****  *
 346:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 347:../drivers/fsl_dspi.h ****  * @param handle Pointer to the handle for the DSPI slave.
 348:../drivers/fsl_dspi.h ****  * @param status Success or error code describing whether the transfer completed.
 349:../drivers/fsl_dspi.h ****  * @param userData Arbitrary pointer-dataSized value passed from the application.
 350:../drivers/fsl_dspi.h ****  */
 351:../drivers/fsl_dspi.h **** typedef void (*dspi_slave_transfer_callback_t)(SPI_Type *base,
 352:../drivers/fsl_dspi.h ****                                                dspi_slave_handle_t *handle,
 353:../drivers/fsl_dspi.h ****                                                status_t status,
 354:../drivers/fsl_dspi.h ****                                                void *userData);
 355:../drivers/fsl_dspi.h **** 
 356:../drivers/fsl_dspi.h **** /*! @brief DSPI master/slave transfer structure.*/
 357:../drivers/fsl_dspi.h **** typedef struct _dspi_transfer
 358:../drivers/fsl_dspi.h **** {
 359:../drivers/fsl_dspi.h ****     uint8_t *txData;          /*!< Send buffer. */
 360:../drivers/fsl_dspi.h ****     uint8_t *rxData;          /*!< Receive buffer. */
 361:../drivers/fsl_dspi.h ****     volatile size_t dataSize; /*!< Transfer bytes. */
 362:../drivers/fsl_dspi.h **** 
 363:../drivers/fsl_dspi.h ****     uint32_t
 364:../drivers/fsl_dspi.h ****         configFlags; /*!< Transfer transfer configuration flags; set from _dspi_transfer_config_fla
 365:../drivers/fsl_dspi.h ****                         transfer is used for master or _dspi_transfer_config_flag_for_slave enumera
 366:../drivers/fsl_dspi.h ****                         is used for slave.*/
 367:../drivers/fsl_dspi.h **** } dspi_transfer_t;
 368:../drivers/fsl_dspi.h **** 
 369:../drivers/fsl_dspi.h **** /*! @brief DSPI half-duplex(master) transfer structure */
 370:../drivers/fsl_dspi.h **** typedef struct _dspi_half_duplex_transfer
 371:../drivers/fsl_dspi.h **** {
 372:../drivers/fsl_dspi.h ****     uint8_t *txData;            /*!< Send buffer */
 373:../drivers/fsl_dspi.h ****     uint8_t *rxData;            /*!< Receive buffer */
 374:../drivers/fsl_dspi.h ****     size_t txDataSize;          /*!< Transfer bytes for transmit */
 375:../drivers/fsl_dspi.h ****     size_t rxDataSize;          /*!< Transfer bytes */
 376:../drivers/fsl_dspi.h ****     uint32_t configFlags;       /*!< Transfer configuration flags; set from _dspi_transfer_config_f
 377:../drivers/fsl_dspi.h ****     bool isPcsAssertInTransfer; /*!< If Pcs pin keep assert between transmit and receive. true for 
 378:../drivers/fsl_dspi.h ****                                    deassert. */
 379:../drivers/fsl_dspi.h ****     bool isTransmitFirst;       /*!< True for transmit first and false for receive first. */
 380:../drivers/fsl_dspi.h **** } dspi_half_duplex_transfer_t;
 381:../drivers/fsl_dspi.h **** 
 382:../drivers/fsl_dspi.h **** /*! @brief DSPI master transfer handle structure used for transactional API. */
 383:../drivers/fsl_dspi.h **** struct _dspi_master_handle
 384:../drivers/fsl_dspi.h **** {
 385:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;         /*!< The desired number of bits per frame. */
 386:../drivers/fsl_dspi.h ****     volatile uint32_t command;     /*!< The desired data command. */
 387:../drivers/fsl_dspi.h ****     volatile uint32_t lastCommand; /*!< The desired last data command. */
 388:../drivers/fsl_dspi.h **** 
 389:../drivers/fsl_dspi.h ****     uint8_t fifoSize; /*!< FIFO dataSize. */
 390:../drivers/fsl_dspi.h **** 
 391:../drivers/fsl_dspi.h ****     volatile bool
 392:../drivers/fsl_dspi.h ****         isPcsActiveAfterTransfer;   /*!< Indicates whether the PCS signal is active after the last 
 393:../drivers/fsl_dspi.h ****     volatile bool isThereExtraByte; /*!< Indicates whether there are extra bytes.*/
 394:../drivers/fsl_dspi.h **** 
 395:../drivers/fsl_dspi.h ****     uint8_t *volatile txData;                  /*!< Send buffer. */
 396:../drivers/fsl_dspi.h ****     uint8_t *volatile rxData;                  /*!< Receive buffer. */
 397:../drivers/fsl_dspi.h ****     volatile size_t remainingSendByteCount;    /*!< A number of bytes remaining to send.*/
 398:../drivers/fsl_dspi.h ****     volatile size_t remainingReceiveByteCount; /*!< A number of bytes remaining to receive.*/
 399:../drivers/fsl_dspi.h ****     size_t totalByteCount;                     /*!< A number of transfer bytes*/
 400:../drivers/fsl_dspi.h **** 
 401:../drivers/fsl_dspi.h ****     volatile uint8_t state; /*!< DSPI transfer state, see _dspi_transfer_state.*/
 402:../drivers/fsl_dspi.h **** 
 403:../drivers/fsl_dspi.h ****     dspi_master_transfer_callback_t callback; /*!< Completion callback. */
 404:../drivers/fsl_dspi.h ****     void *userData;                           /*!< Callback user data. */
 405:../drivers/fsl_dspi.h **** };
 406:../drivers/fsl_dspi.h **** 
 407:../drivers/fsl_dspi.h **** /*! @brief DSPI slave transfer handle structure used for the transactional API. */
 408:../drivers/fsl_dspi.h **** struct _dspi_slave_handle
 409:../drivers/fsl_dspi.h **** {
 410:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;          /*!< The desired number of bits per frame. */
 411:../drivers/fsl_dspi.h ****     volatile bool isThereExtraByte; /*!< Indicates whether there are extra bytes.*/
 412:../drivers/fsl_dspi.h **** 
 413:../drivers/fsl_dspi.h ****     uint8_t *volatile txData;                  /*!< Send buffer. */
 414:../drivers/fsl_dspi.h ****     uint8_t *volatile rxData;                  /*!< Receive buffer. */
 415:../drivers/fsl_dspi.h ****     volatile size_t remainingSendByteCount;    /*!< A number of bytes remaining to send.*/
 416:../drivers/fsl_dspi.h ****     volatile size_t remainingReceiveByteCount; /*!< A number of bytes remaining to receive.*/
 417:../drivers/fsl_dspi.h ****     size_t totalByteCount;                     /*!< A number of transfer bytes*/
 418:../drivers/fsl_dspi.h **** 
 419:../drivers/fsl_dspi.h ****     volatile uint8_t state; /*!< DSPI transfer state.*/
 420:../drivers/fsl_dspi.h **** 
 421:../drivers/fsl_dspi.h ****     volatile uint32_t errorCount; /*!< Error count for slave transfer.*/
 422:../drivers/fsl_dspi.h **** 
 423:../drivers/fsl_dspi.h ****     dspi_slave_transfer_callback_t callback; /*!< Completion callback. */
 424:../drivers/fsl_dspi.h ****     void *userData;                          /*!< Callback user data. */
 425:../drivers/fsl_dspi.h **** };
 426:../drivers/fsl_dspi.h **** 
 427:../drivers/fsl_dspi.h **** /**************************************************************************************************
 428:../drivers/fsl_dspi.h ****  * API
 429:../drivers/fsl_dspi.h ****  **************************************************************************************************
 430:../drivers/fsl_dspi.h **** #if defined(__cplusplus)
 431:../drivers/fsl_dspi.h **** extern "C" {
 432:../drivers/fsl_dspi.h **** #endif /*_cplusplus*/
 433:../drivers/fsl_dspi.h **** 
 434:../drivers/fsl_dspi.h **** /*!
 435:../drivers/fsl_dspi.h ****  * @name Initialization and deinitialization
 436:../drivers/fsl_dspi.h ****  * @{
 437:../drivers/fsl_dspi.h ****  */
 438:../drivers/fsl_dspi.h **** 
 439:../drivers/fsl_dspi.h **** /*!
 440:../drivers/fsl_dspi.h ****  * @brief Initializes the DSPI master.
 441:../drivers/fsl_dspi.h ****  *
 442:../drivers/fsl_dspi.h ****  * This function initializes the DSPI master configuration. This is an example use case.
 443:../drivers/fsl_dspi.h ****  *  @code
 444:../drivers/fsl_dspi.h ****  *   dspi_master_config_t  masterConfig;
 445:../drivers/fsl_dspi.h ****  *   masterConfig.whichCtar                                = kDSPI_Ctar0;
 446:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.baudRate                      = 500000000U;
 447:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.bitsPerFrame                  = 8;
 448:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.cpol                          = kDSPI_ClockPolarityActiveHigh;
 449:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.cpha                          = kDSPI_ClockPhaseFirstEdge;
 450:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.direction                     = kDSPI_MsbFirst;
 451:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.pcsToSckDelayInNanoSec        = 1000000000U / masterConfig.ctarConfig.
 452:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec    = 1000000000U / masterConfig.ctarConfig.
 453:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 1000000000U / masterConfig.ctarConfig.
 454:../drivers/fsl_dspi.h ****  *   masterConfig.whichPcs                                 = kDSPI_Pcs0;
 455:../drivers/fsl_dspi.h ****  *   masterConfig.pcsActiveHighOrLow                       = kDSPI_PcsActiveLow;
 456:../drivers/fsl_dspi.h ****  *   masterConfig.enableContinuousSCK                      = false;
 457:../drivers/fsl_dspi.h ****  *   masterConfig.enableRxFifoOverWrite                    = false;
 458:../drivers/fsl_dspi.h ****  *   masterConfig.enableModifiedTimingFormat               = false;
 459:../drivers/fsl_dspi.h ****  *   masterConfig.samplePoint                              = kDSPI_SckToSin0Clock;
 460:../drivers/fsl_dspi.h ****  *   DSPI_MasterInit(base, &masterConfig, srcClock_Hz);
 461:../drivers/fsl_dspi.h ****  *  @endcode
 462:../drivers/fsl_dspi.h ****  *
 463:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 464:../drivers/fsl_dspi.h ****  * @param masterConfig Pointer to the structure dspi_master_config_t.
 465:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz.
 466:../drivers/fsl_dspi.h ****  */
 467:../drivers/fsl_dspi.h **** void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz
 468:../drivers/fsl_dspi.h **** 
 469:../drivers/fsl_dspi.h **** /*!
 470:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_master_config_t structure to default values.
 471:../drivers/fsl_dspi.h ****  *
 472:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for the DSPI_MasterIni
 473:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_MasterInit() or modify the structu
 474:../drivers/fsl_dspi.h ****  * before calling the DSPI_MasterInit().
 475:../drivers/fsl_dspi.h ****  * Example:
 476:../drivers/fsl_dspi.h ****  * @code
 477:../drivers/fsl_dspi.h ****  *  dspi_master_config_t  masterConfig;
 478:../drivers/fsl_dspi.h ****  *  DSPI_MasterGetDefaultConfig(&masterConfig);
 479:../drivers/fsl_dspi.h ****  * @endcode
 480:../drivers/fsl_dspi.h ****  * @param masterConfig pointer to dspi_master_config_t structure
 481:../drivers/fsl_dspi.h ****  */
 482:../drivers/fsl_dspi.h **** void DSPI_MasterGetDefaultConfig(dspi_master_config_t *masterConfig);
 483:../drivers/fsl_dspi.h **** 
 484:../drivers/fsl_dspi.h **** /*!
 485:../drivers/fsl_dspi.h ****  * @brief DSPI slave configuration.
 486:../drivers/fsl_dspi.h ****  *
 487:../drivers/fsl_dspi.h ****  * This function initializes the DSPI slave configuration. This is an example use case.
 488:../drivers/fsl_dspi.h ****  *  @code
 489:../drivers/fsl_dspi.h ****  *   dspi_slave_config_t  slaveConfig;
 490:../drivers/fsl_dspi.h ****  *  slaveConfig->whichCtar                  = kDSPI_Ctar0;
 491:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.bitsPerFrame    = 8;
 492:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.cpol            = kDSPI_ClockPolarityActiveHigh;
 493:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.cpha            = kDSPI_ClockPhaseFirstEdge;
 494:../drivers/fsl_dspi.h ****  *  slaveConfig->enableContinuousSCK        = false;
 495:../drivers/fsl_dspi.h ****  *  slaveConfig->enableRxFifoOverWrite      = false;
 496:../drivers/fsl_dspi.h ****  *  slaveConfig->enableModifiedTimingFormat = false;
 497:../drivers/fsl_dspi.h ****  *  slaveConfig->samplePoint                = kDSPI_SckToSin0Clock;
 498:../drivers/fsl_dspi.h ****  *   DSPI_SlaveInit(base, &slaveConfig);
 499:../drivers/fsl_dspi.h ****  *  @endcode
 500:../drivers/fsl_dspi.h ****  *
 501:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 502:../drivers/fsl_dspi.h ****  * @param slaveConfig Pointer to the structure dspi_master_config_t.
 503:../drivers/fsl_dspi.h ****  */
 504:../drivers/fsl_dspi.h **** void DSPI_SlaveInit(SPI_Type *base, const dspi_slave_config_t *slaveConfig);
 505:../drivers/fsl_dspi.h **** 
 506:../drivers/fsl_dspi.h **** /*!
 507:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_slave_config_t structure to a default value.
 508:../drivers/fsl_dspi.h ****  *
 509:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for the DSPI_SlaveInit
 510:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_SlaveInit() or modify the structur
 511:../drivers/fsl_dspi.h ****  * before calling the DSPI_SlaveInit().
 512:../drivers/fsl_dspi.h ****  * This is an example.
 513:../drivers/fsl_dspi.h ****  * @code
 514:../drivers/fsl_dspi.h ****  *  dspi_slave_config_t  slaveConfig;
 515:../drivers/fsl_dspi.h ****  *  DSPI_SlaveGetDefaultConfig(&slaveConfig);
 516:../drivers/fsl_dspi.h ****  * @endcode
 517:../drivers/fsl_dspi.h ****  * @param slaveConfig Pointer to the dspi_slave_config_t structure.
 518:../drivers/fsl_dspi.h ****  */
 519:../drivers/fsl_dspi.h **** void DSPI_SlaveGetDefaultConfig(dspi_slave_config_t *slaveConfig);
 520:../drivers/fsl_dspi.h **** 
 521:../drivers/fsl_dspi.h **** /*!
 522:../drivers/fsl_dspi.h ****  * @brief De-initializes the DSPI peripheral. Call this API to disable the DSPI clock.
 523:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 524:../drivers/fsl_dspi.h ****  */
 525:../drivers/fsl_dspi.h **** void DSPI_Deinit(SPI_Type *base);
 526:../drivers/fsl_dspi.h **** 
 527:../drivers/fsl_dspi.h **** /*!
 528:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI peripheral and sets the MCR MDIS to 0.
 529:../drivers/fsl_dspi.h ****  *
 530:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 531:../drivers/fsl_dspi.h ****  * @param enable Pass true to enable module, false to disable module.
 532:../drivers/fsl_dspi.h ****  */
 533:../drivers/fsl_dspi.h **** static inline void DSPI_Enable(SPI_Type *base, bool enable)
 534:../drivers/fsl_dspi.h **** {
 535:../drivers/fsl_dspi.h ****     if (enable)
 536:../drivers/fsl_dspi.h ****     {
 537:../drivers/fsl_dspi.h ****         base->MCR &= ~SPI_MCR_MDIS_MASK;
 538:../drivers/fsl_dspi.h ****     }
 539:../drivers/fsl_dspi.h ****     else
 540:../drivers/fsl_dspi.h ****     {
 541:../drivers/fsl_dspi.h ****         base->MCR |= SPI_MCR_MDIS_MASK;
 542:../drivers/fsl_dspi.h ****     }
 543:../drivers/fsl_dspi.h **** }
 544:../drivers/fsl_dspi.h **** 
 545:../drivers/fsl_dspi.h **** /*!
 546:../drivers/fsl_dspi.h ****  *@}
 547:../drivers/fsl_dspi.h **** */
 548:../drivers/fsl_dspi.h **** 
 549:../drivers/fsl_dspi.h **** /*!
 550:../drivers/fsl_dspi.h ****  * @name Status
 551:../drivers/fsl_dspi.h ****  * @{
 552:../drivers/fsl_dspi.h ****  */
 553:../drivers/fsl_dspi.h **** 
 554:../drivers/fsl_dspi.h **** /*!
 555:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI status flag state.
 556:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 557:../drivers/fsl_dspi.h ****  * @return DSPI status (in SR register).
 558:../drivers/fsl_dspi.h ****  */
 559:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_GetStatusFlags(SPI_Type *base)
 560:../drivers/fsl_dspi.h **** {
 561:../drivers/fsl_dspi.h ****     return (base->SR);
 562:../drivers/fsl_dspi.h **** }
 563:../drivers/fsl_dspi.h **** 
 564:../drivers/fsl_dspi.h **** /*!
 565:../drivers/fsl_dspi.h ****  * @brief Clears the DSPI status flag.
 566:../drivers/fsl_dspi.h ****  *
 567:../drivers/fsl_dspi.h ****  * This function  clears the desired status bit by using a write-1-to-clear. The user passes in the
 568:../drivers/fsl_dspi.h ****  * desired status bit to clear.  The list of status bits is defined in the dspi_status_and_interrup
 569:../drivers/fsl_dspi.h ****  * function uses these bit positions in its algorithm to clear the desired flag state.
 570:../drivers/fsl_dspi.h ****  * This is an example.
 571:../drivers/fsl_dspi.h ****  * @code
 572:../drivers/fsl_dspi.h ****  *  DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag|kDSPI_EndOfQueueFlag);
 573:../drivers/fsl_dspi.h ****  * @endcode
 574:../drivers/fsl_dspi.h ****  *
 575:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 576:../drivers/fsl_dspi.h ****  * @param statusFlags The status flag used from the type dspi_flags.
 577:../drivers/fsl_dspi.h ****  */
 578:../drivers/fsl_dspi.h **** static inline void DSPI_ClearStatusFlags(SPI_Type *base, uint32_t statusFlags)
 579:../drivers/fsl_dspi.h **** {
 580:../drivers/fsl_dspi.h ****     base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
 581:../drivers/fsl_dspi.h **** }
 582:../drivers/fsl_dspi.h **** 
 583:../drivers/fsl_dspi.h **** /*!
 584:../drivers/fsl_dspi.h ****  *@}
 585:../drivers/fsl_dspi.h **** */
 586:../drivers/fsl_dspi.h **** 
 587:../drivers/fsl_dspi.h **** /*!
 588:../drivers/fsl_dspi.h ****  * @name Interrupts
 589:../drivers/fsl_dspi.h ****  * @{
 590:../drivers/fsl_dspi.h ****  */
 591:../drivers/fsl_dspi.h **** 
 592:../drivers/fsl_dspi.h **** /*!
 593:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI interrupts.
 594:../drivers/fsl_dspi.h ****  *
 595:../drivers/fsl_dspi.h ****  * This function configures the various interrupt masks of the DSPI.  The parameters are a base and
 596:../drivers/fsl_dspi.h ****  * Note, for Tx Fill and Rx FIFO drain requests, enable the interrupt request and disable the DMA r
 597:../drivers/fsl_dspi.h ****  *       Do not use this API(write to RSER register) while DSPI is in running state.
 598:../drivers/fsl_dspi.h ****  *
 599:../drivers/fsl_dspi.h ****  * @code
 600:../drivers/fsl_dspi.h ****  *  DSPI_EnableInterrupts(base, kDSPI_TxCompleteInterruptEnable | kDSPI_EndOfQueueInterruptEnable )
 601:../drivers/fsl_dspi.h ****  * @endcode
 602:../drivers/fsl_dspi.h ****  *
 603:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 604:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum _dspi_interrupt_enable.
 605:../drivers/fsl_dspi.h ****  */
 606:../drivers/fsl_dspi.h **** void DSPI_EnableInterrupts(SPI_Type *base, uint32_t mask);
 607:../drivers/fsl_dspi.h **** 
 608:../drivers/fsl_dspi.h **** /*!
 609:../drivers/fsl_dspi.h ****  * @brief Disables the DSPI interrupts.
 610:../drivers/fsl_dspi.h ****  *
 611:../drivers/fsl_dspi.h ****  * @code
 612:../drivers/fsl_dspi.h ****  *  DSPI_DisableInterrupts(base, kDSPI_TxCompleteInterruptEnable | kDSPI_EndOfQueueInterruptEnable 
 613:../drivers/fsl_dspi.h ****  * @endcode
 614:../drivers/fsl_dspi.h ****  *
 615:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 616:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum _dspi_interrupt_enable.
 617:../drivers/fsl_dspi.h ****  */
 618:../drivers/fsl_dspi.h **** static inline void DSPI_DisableInterrupts(SPI_Type *base, uint32_t mask)
 619:../drivers/fsl_dspi.h **** {
 620:../drivers/fsl_dspi.h ****     base->RSER &= ~mask;
 621:../drivers/fsl_dspi.h **** }
 622:../drivers/fsl_dspi.h **** 
 623:../drivers/fsl_dspi.h **** /*!
 624:../drivers/fsl_dspi.h ****  *@}
 625:../drivers/fsl_dspi.h **** */
 626:../drivers/fsl_dspi.h **** 
 627:../drivers/fsl_dspi.h **** /*!
 628:../drivers/fsl_dspi.h ****  * @name DMA Control
 629:../drivers/fsl_dspi.h ****  * @{
 630:../drivers/fsl_dspi.h ****  */
 631:../drivers/fsl_dspi.h **** 
 632:../drivers/fsl_dspi.h **** /*!
 633:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI DMA request.
 634:../drivers/fsl_dspi.h ****  *
 635:../drivers/fsl_dspi.h ****  * This function configures the Rx and Tx DMA mask of the DSPI.  The parameters are a base and a DM
 636:../drivers/fsl_dspi.h ****  * @code
 637:../drivers/fsl_dspi.h ****  *  DSPI_EnableDMA(base, kDSPI_TxDmaEnable | kDSPI_RxDmaEnable);
 638:../drivers/fsl_dspi.h ****  * @endcode
 639:../drivers/fsl_dspi.h ****  *
 640:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 641:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum dspi_dma_enable.
 642:../drivers/fsl_dspi.h ****  */
 643:../drivers/fsl_dspi.h **** static inline void DSPI_EnableDMA(SPI_Type *base, uint32_t mask)
 644:../drivers/fsl_dspi.h **** {
 645:../drivers/fsl_dspi.h ****     base->RSER |= mask;
 646:../drivers/fsl_dspi.h **** }
 647:../drivers/fsl_dspi.h **** 
 648:../drivers/fsl_dspi.h **** /*!
 649:../drivers/fsl_dspi.h ****  * @brief Disables the DSPI DMA request.
 650:../drivers/fsl_dspi.h ****  *
 651:../drivers/fsl_dspi.h ****  * This function configures the Rx and Tx DMA mask of the DSPI.  The parameters are a base and a DM
 652:../drivers/fsl_dspi.h ****  * @code
 653:../drivers/fsl_dspi.h ****  *  SPI_DisableDMA(base, kDSPI_TxDmaEnable | kDSPI_RxDmaEnable);
 654:../drivers/fsl_dspi.h ****  * @endcode
 655:../drivers/fsl_dspi.h ****  *
 656:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 657:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum dspi_dma_enable.
 658:../drivers/fsl_dspi.h ****  */
 659:../drivers/fsl_dspi.h **** static inline void DSPI_DisableDMA(SPI_Type *base, uint32_t mask)
 660:../drivers/fsl_dspi.h **** {
 661:../drivers/fsl_dspi.h ****     base->RSER &= ~mask;
  91              		.loc 3 661 0
  92 0004 036B     		ldr	r3, [r0, #48]
  93              	.LVL7:
  94              	.LBE103:
  95              	.LBE102:
 984:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
  96              		.loc 2 984 0
  97 0006 10B4     		push	{r4}
  98              		.cfi_def_cfa_offset 4
  99              		.cfi_offset 4, -4
 100              	.LBB107:
 101              	.LBB104:
 102              		.loc 3 661 0
 103 0008 23F04073 		bic	r3, r3, #50331648
 104              	.LBE104:
 105              	.LBE107:
 995:../drivers/fsl_dspi_edma.c **** 
 996:../drivers/fsl_dspi_edma.c ****     if (dspiEdmaPrivateHandle->handle->callback)
 106              		.loc 2 996 0
 107 000c CC6A     		ldr	r4, [r1, #44]
 108              	.LBB108:
 109              	.LBB105:
 110              		.loc 3 661 0
 111 000e 23F44033 		bic	r3, r3, #196608
 112              	.LBE105:
 113              	.LBE108:
 994:../drivers/fsl_dspi_edma.c **** 
 114              		.loc 2 994 0
 115 0012 0022     		movs	r2, #0
 116              	.LVL8:
 117              	.LBB109:
 118              	.LBB106:
 119              		.loc 3 661 0
 120 0014 0363     		str	r3, [r0, #48]
 121              	.LVL9:
 122              	.LBE106:
 123              	.LBE109:
 994:../drivers/fsl_dspi_edma.c **** 
 124              		.loc 2 994 0
 125 0016 CA73     		strb	r2, [r1, #15]
 126              		.loc 2 996 0
 127 0018 24B1     		cbz	r4, .L4
 997:../drivers/fsl_dspi_edma.c ****     {
 998:../drivers/fsl_dspi_edma.c ****         dspiEdmaPrivateHandle->handle->callback(dspiEdmaPrivateHandle->base, dspiEdmaPrivateHandle-
 128              		.loc 2 998 0
 129 001a A446     		mov	ip, r4
 130 001c 0B6B     		ldr	r3, [r1, #48]
 999:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
1000:../drivers/fsl_dspi_edma.c ****     }
1001:../drivers/fsl_dspi_edma.c **** }
 131              		.loc 2 1001 0
 132 001e 5DF8044B 		ldr	r4, [sp], #4
 133              		.cfi_remember_state
 134              		.cfi_restore 4
 135              		.cfi_def_cfa_offset 0
 998:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
 136              		.loc 2 998 0
 137 0022 6047     		bx	ip	@ indirect register sibling call
 138              	.LVL10:
 139              	.L4:
 140              		.cfi_restore_state
 141              		.loc 2 1001 0
 142 0024 5DF8044B 		ldr	r4, [sp], #4
 143              		.cfi_restore 4
 144              		.cfi_def_cfa_offset 0
 145 0028 7047     		bx	lr
 146              		.cfi_endproc
 147              	.LFE180:
 149              		.section	.text.EDMA_DspiSlaveCallback,"ax",%progbits
 150              		.align	1
 151              		.syntax unified
 152              		.thumb
 153              		.thumb_func
 154              		.fpu fpv4-sp-d16
 156              	EDMA_DspiSlaveCallback:
 157              	.LFB185:
1002:../drivers/fsl_dspi_edma.c **** 
1003:../drivers/fsl_dspi_edma.c **** void DSPI_MasterTransferAbortEDMA(SPI_Type *base, dspi_master_edma_handle_t *handle)
1004:../drivers/fsl_dspi_edma.c **** {
1005:../drivers/fsl_dspi_edma.c ****     assert(handle);
1006:../drivers/fsl_dspi_edma.c **** 
1007:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
1008:../drivers/fsl_dspi_edma.c **** 
1009:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1010:../drivers/fsl_dspi_edma.c **** 
1011:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaRxRegToRxDataHandle);
1012:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaTxDataToIntermediaryHandle);
1013:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaIntermediaryToTxRegHandle);
1014:../drivers/fsl_dspi_edma.c **** 
1015:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Idle;
1016:../drivers/fsl_dspi_edma.c **** }
1017:../drivers/fsl_dspi_edma.c **** 
1018:../drivers/fsl_dspi_edma.c **** status_t DSPI_MasterTransferGetCountEDMA(SPI_Type *base, dspi_master_edma_handle_t *handle, size_t 
1019:../drivers/fsl_dspi_edma.c **** {
1020:../drivers/fsl_dspi_edma.c ****     assert(handle);
1021:../drivers/fsl_dspi_edma.c **** 
1022:../drivers/fsl_dspi_edma.c ****     if (!count)
1023:../drivers/fsl_dspi_edma.c ****     {
1024:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1025:../drivers/fsl_dspi_edma.c ****     }
1026:../drivers/fsl_dspi_edma.c **** 
1027:../drivers/fsl_dspi_edma.c ****     /* Catch when there is not an active transfer. */
1028:../drivers/fsl_dspi_edma.c ****     if (handle->state != kDSPI_Busy)
1029:../drivers/fsl_dspi_edma.c ****     {
1030:../drivers/fsl_dspi_edma.c ****         *count = 0;
1031:../drivers/fsl_dspi_edma.c ****         return kStatus_NoTransferInProgress;
1032:../drivers/fsl_dspi_edma.c ****     }
1033:../drivers/fsl_dspi_edma.c **** 
1034:../drivers/fsl_dspi_edma.c ****     size_t bytes;
1035:../drivers/fsl_dspi_edma.c **** 
1036:../drivers/fsl_dspi_edma.c ****     bytes = (uint32_t)handle->nbytes * EDMA_GetRemainingMajorLoopCount(handle->edmaRxRegToRxDataHan
1037:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
1038:../drivers/fsl_dspi_edma.c **** 
1039:../drivers/fsl_dspi_edma.c ****     *count = handle->totalByteCount - bytes;
1040:../drivers/fsl_dspi_edma.c **** 
1041:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
1042:../drivers/fsl_dspi_edma.c **** }
1043:../drivers/fsl_dspi_edma.c **** 
1044:../drivers/fsl_dspi_edma.c **** void DSPI_SlaveTransferCreateHandleEDMA(SPI_Type *base,
1045:../drivers/fsl_dspi_edma.c ****                                         dspi_slave_edma_handle_t *handle,
1046:../drivers/fsl_dspi_edma.c ****                                         dspi_slave_edma_transfer_callback_t callback,
1047:../drivers/fsl_dspi_edma.c ****                                         void *userData,
1048:../drivers/fsl_dspi_edma.c ****                                         edma_handle_t *edmaRxRegToRxDataHandle,
1049:../drivers/fsl_dspi_edma.c ****                                         edma_handle_t *edmaTxDataToTxRegHandle)
1050:../drivers/fsl_dspi_edma.c **** {
1051:../drivers/fsl_dspi_edma.c ****     assert(handle);
1052:../drivers/fsl_dspi_edma.c ****     assert(edmaRxRegToRxDataHandle);
1053:../drivers/fsl_dspi_edma.c ****     assert(edmaTxDataToTxRegHandle);
1054:../drivers/fsl_dspi_edma.c **** 
1055:../drivers/fsl_dspi_edma.c ****     /* Zero the handle. */
1056:../drivers/fsl_dspi_edma.c ****     memset(handle, 0, sizeof(*handle));
1057:../drivers/fsl_dspi_edma.c **** 
1058:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
1059:../drivers/fsl_dspi_edma.c **** 
1060:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].base = base;
1061:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].handle = handle;
1062:../drivers/fsl_dspi_edma.c **** 
1063:../drivers/fsl_dspi_edma.c ****     handle->callback = callback;
1064:../drivers/fsl_dspi_edma.c ****     handle->userData = userData;
1065:../drivers/fsl_dspi_edma.c **** 
1066:../drivers/fsl_dspi_edma.c ****     handle->edmaRxRegToRxDataHandle = edmaRxRegToRxDataHandle;
1067:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToTxRegHandle = edmaTxDataToTxRegHandle;
1068:../drivers/fsl_dspi_edma.c **** }
1069:../drivers/fsl_dspi_edma.c **** 
1070:../drivers/fsl_dspi_edma.c **** status_t DSPI_SlaveTransferEDMA(SPI_Type *base, dspi_slave_edma_handle_t *handle, dspi_transfer_t *
1071:../drivers/fsl_dspi_edma.c **** {
1072:../drivers/fsl_dspi_edma.c ****     assert(handle);
1073:../drivers/fsl_dspi_edma.c ****     assert(transfer);
1074:../drivers/fsl_dspi_edma.c **** 
1075:../drivers/fsl_dspi_edma.c ****     /* If send/receive length is zero */
1076:../drivers/fsl_dspi_edma.c ****     if (transfer->dataSize == 0)
1077:../drivers/fsl_dspi_edma.c ****     {
1078:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1079:../drivers/fsl_dspi_edma.c ****     }
1080:../drivers/fsl_dspi_edma.c **** 
1081:../drivers/fsl_dspi_edma.c ****     /* If both send buffer and receive buffer is null */
1082:../drivers/fsl_dspi_edma.c ****     if ((!(transfer->txData)) && (!(transfer->rxData)))
1083:../drivers/fsl_dspi_edma.c ****     {
1084:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1085:../drivers/fsl_dspi_edma.c ****     }
1086:../drivers/fsl_dspi_edma.c **** 
1087:../drivers/fsl_dspi_edma.c ****     /* Check that we're not busy.*/
1088:../drivers/fsl_dspi_edma.c ****     if (handle->state == kDSPI_Busy)
1089:../drivers/fsl_dspi_edma.c ****     {
1090:../drivers/fsl_dspi_edma.c ****         return kStatus_DSPI_Busy;
1091:../drivers/fsl_dspi_edma.c ****     }
1092:../drivers/fsl_dspi_edma.c **** 
1093:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Busy;
1094:../drivers/fsl_dspi_edma.c **** 
1095:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
1096:../drivers/fsl_dspi_edma.c ****     uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
1097:../drivers/fsl_dspi_edma.c ****     handle->bitsPerFrame =
1098:../drivers/fsl_dspi_edma.c ****         (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) +
1099:../drivers/fsl_dspi_edma.c **** 
1100:../drivers/fsl_dspi_edma.c ****     /* If using a shared RX/TX DMA request, then this limits the amount of data we can transfer
1101:../drivers/fsl_dspi_edma.c ****     * due to the linked channel. The max bytes is 511 if 8-bit/frame or 1022 if 16-bit/frame
1102:../drivers/fsl_dspi_edma.c ****     */
1103:../drivers/fsl_dspi_edma.c ****     uint32_t limited_size = 0;
1104:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1105:../drivers/fsl_dspi_edma.c ****     {
1106:../drivers/fsl_dspi_edma.c ****         limited_size = 32767u;
1107:../drivers/fsl_dspi_edma.c ****     }
1108:../drivers/fsl_dspi_edma.c ****     else
1109:../drivers/fsl_dspi_edma.c ****     {
1110:../drivers/fsl_dspi_edma.c ****         limited_size = 511u;
1111:../drivers/fsl_dspi_edma.c ****     }
1112:../drivers/fsl_dspi_edma.c **** 
1113:../drivers/fsl_dspi_edma.c ****     if (handle->bitsPerFrame > 8)
1114:../drivers/fsl_dspi_edma.c ****     {
1115:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > (limited_size << 1u))
1116:../drivers/fsl_dspi_edma.c ****         {
1117:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
1118:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
1119:../drivers/fsl_dspi_edma.c ****         }
1120:../drivers/fsl_dspi_edma.c ****     }
1121:../drivers/fsl_dspi_edma.c ****     else
1122:../drivers/fsl_dspi_edma.c ****     {
1123:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > limited_size)
1124:../drivers/fsl_dspi_edma.c ****         {
1125:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
1126:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
1127:../drivers/fsl_dspi_edma.c ****         }
1128:../drivers/fsl_dspi_edma.c ****     }
1129:../drivers/fsl_dspi_edma.c **** 
1130:../drivers/fsl_dspi_edma.c ****     /*The data size should be even if the bitsPerFrame is greater than 8 (that is 2 bytes per frame
1131:../drivers/fsl_dspi_edma.c ****     if ((handle->bitsPerFrame > 8) && (transfer->dataSize & 0x1))
1132:../drivers/fsl_dspi_edma.c ****     {
1133:../drivers/fsl_dspi_edma.c ****         handle->state = kDSPI_Idle;
1134:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1135:../drivers/fsl_dspi_edma.c ****     }
1136:../drivers/fsl_dspi_edma.c **** 
1137:../drivers/fsl_dspi_edma.c ****     EDMA_SetCallback(handle->edmaRxRegToRxDataHandle, EDMA_DspiSlaveCallback, &s_dspiSlaveEdmaPriva
1138:../drivers/fsl_dspi_edma.c **** 
1139:../drivers/fsl_dspi_edma.c ****     /* Store transfer information */
1140:../drivers/fsl_dspi_edma.c ****     handle->txData = transfer->txData;
1141:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
1142:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
1143:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
1144:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
1145:../drivers/fsl_dspi_edma.c **** 
1146:../drivers/fsl_dspi_edma.c ****     uint16_t wordToSend = 0;
1147:../drivers/fsl_dspi_edma.c ****     uint8_t dummyData = s_dummyData[DSPI_GetInstance(base)];
1148:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
1149:../drivers/fsl_dspi_edma.c ****     uint8_t dataFedMax = 2;
1150:../drivers/fsl_dspi_edma.c **** 
1151:../drivers/fsl_dspi_edma.c ****     uint32_t rxAddr = DSPI_GetRxRegisterAddress(base);
1152:../drivers/fsl_dspi_edma.c ****     uint32_t txAddr = DSPI_SlaveGetTxRegisterAddress(base);
1153:../drivers/fsl_dspi_edma.c **** 
1154:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigA;
1155:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigC;
1156:../drivers/fsl_dspi_edma.c **** 
1157:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
1158:../drivers/fsl_dspi_edma.c **** 
1159:../drivers/fsl_dspi_edma.c ****     DSPI_FlushFifo(base, true, true);
1160:../drivers/fsl_dspi_edma.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
1161:../drivers/fsl_dspi_edma.c **** 
1162:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1163:../drivers/fsl_dspi_edma.c **** 
1164:../drivers/fsl_dspi_edma.c ****     DSPI_StartTransfer(base);
1165:../drivers/fsl_dspi_edma.c **** 
1166:../drivers/fsl_dspi_edma.c ****     /*if dspi has separate dma request , need not prepare data first .
1167:../drivers/fsl_dspi_edma.c ****     else (dspi has shared dma request) , send first 2 data into fifo if there is fifo or send first
1168:../drivers/fsl_dspi_edma.c ****     slaveGetTxRegister if there is no fifo*/
1169:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1170:../drivers/fsl_dspi_edma.c ****     {
1171:../drivers/fsl_dspi_edma.c ****         /* For DSPI instances with shared RX/TX DMA requests, we'll use the RX DMA request to
1172:../drivers/fsl_dspi_edma.c ****         * trigger ongoing transfers and will link to the TX DMA channel from the RX DMA channel.
1173:../drivers/fsl_dspi_edma.c ****         */
1174:../drivers/fsl_dspi_edma.c ****         /* If bits/frame is greater than one byte */
1175:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame > 8)
1176:../drivers/fsl_dspi_edma.c ****         {
1177:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
1178:../drivers/fsl_dspi_edma.c ****             {
1179:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
1180:../drivers/fsl_dspi_edma.c ****                 {
1181:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
1182:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
1183:../drivers/fsl_dspi_edma.c **** 
1184:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
1185:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
1186:../drivers/fsl_dspi_edma.c ****                 }
1187:../drivers/fsl_dspi_edma.c ****                 else
1188:../drivers/fsl_dspi_edma.c ****                 {
1189:../drivers/fsl_dspi_edma.c ****                     wordToSend = ((uint32_t)dummyData << 8) | dummyData;
1190:../drivers/fsl_dspi_edma.c ****                 }
1191:../drivers/fsl_dspi_edma.c ****                 handle->remainingSendByteCount -= 2; /* decrement remainingSendByteCount by 2 */
1192:../drivers/fsl_dspi_edma.c ****                 base->PUSHR_SLAVE = wordToSend;
1193:../drivers/fsl_dspi_edma.c **** 
1194:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
1195:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1196:../drivers/fsl_dspi_edma.c **** 
1197:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed += 2;
1198:../drivers/fsl_dspi_edma.c **** 
1199:../drivers/fsl_dspi_edma.c ****                 /* Exit loop if send count is zero, else update local variables for next loop */
1200:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == (dataFedMax * 2)))
1201:../drivers/fsl_dspi_edma.c ****                 {
1202:../drivers/fsl_dspi_edma.c ****                     break;
1203:../drivers/fsl_dspi_edma.c ****                 }
1204:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
1205:../drivers/fsl_dspi_edma.c ****         }
1206:../drivers/fsl_dspi_edma.c ****         else /* Optimized for bits/frame less than or equal to one byte. */
1207:../drivers/fsl_dspi_edma.c ****         {
1208:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
1209:../drivers/fsl_dspi_edma.c ****             {
1210:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
1211:../drivers/fsl_dspi_edma.c ****                 {
1212:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
1213:../drivers/fsl_dspi_edma.c ****                     /* Increment to next data word*/
1214:../drivers/fsl_dspi_edma.c ****                     ++handle->txData;
1215:../drivers/fsl_dspi_edma.c ****                 }
1216:../drivers/fsl_dspi_edma.c ****                 else
1217:../drivers/fsl_dspi_edma.c ****                 {
1218:../drivers/fsl_dspi_edma.c ****                     wordToSend = dummyData;
1219:../drivers/fsl_dspi_edma.c ****                 }
1220:../drivers/fsl_dspi_edma.c **** 
1221:../drivers/fsl_dspi_edma.c ****                 base->PUSHR_SLAVE = wordToSend;
1222:../drivers/fsl_dspi_edma.c **** 
1223:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
1224:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1225:../drivers/fsl_dspi_edma.c ****                 /* Decrement remainingSendByteCount*/
1226:../drivers/fsl_dspi_edma.c ****                 --handle->remainingSendByteCount;
1227:../drivers/fsl_dspi_edma.c **** 
1228:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed++;
1229:../drivers/fsl_dspi_edma.c **** 
1230:../drivers/fsl_dspi_edma.c ****                 /* Exit loop if send count is zero, else update local variables for next loop */
1231:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == dataFedMax))
1232:../drivers/fsl_dspi_edma.c ****                 {
1233:../drivers/fsl_dspi_edma.c ****                     break;
1234:../drivers/fsl_dspi_edma.c ****                 }
1235:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
1236:../drivers/fsl_dspi_edma.c ****         }
1237:../drivers/fsl_dspi_edma.c ****     }
1238:../drivers/fsl_dspi_edma.c **** 
1239:../drivers/fsl_dspi_edma.c ****     /***channel_A *** used for carry the data from Rx_Data_Register(POPR) to User_Receive_Buffer*/
1240:../drivers/fsl_dspi_edma.c ****     if (handle->remainingReceiveByteCount > 0)
1241:../drivers/fsl_dspi_edma.c ****     {
1242:../drivers/fsl_dspi_edma.c ****         EDMA_ResetChannel(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHandle->c
1243:../drivers/fsl_dspi_edma.c **** 
1244:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcAddr = (uint32_t)rxAddr;
1245:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcOffset = 0;
1246:../drivers/fsl_dspi_edma.c **** 
1247:../drivers/fsl_dspi_edma.c ****         if (handle->rxData)
1248:../drivers/fsl_dspi_edma.c ****         {
1249:../drivers/fsl_dspi_edma.c ****             transferConfigA.destAddr = (uint32_t) & (handle->rxData[0]);
1250:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 1;
1251:../drivers/fsl_dspi_edma.c ****         }
1252:../drivers/fsl_dspi_edma.c ****         else
1253:../drivers/fsl_dspi_edma.c ****         {
1254:../drivers/fsl_dspi_edma.c ****             transferConfigA.destAddr = (uint32_t) & (handle->rxBuffIfNull);
1255:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 0;
1256:../drivers/fsl_dspi_edma.c ****         }
1257:../drivers/fsl_dspi_edma.c **** 
1258:../drivers/fsl_dspi_edma.c ****         transferConfigA.destTransferSize = kEDMA_TransferSize1Bytes;
1259:../drivers/fsl_dspi_edma.c **** 
1260:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
1261:../drivers/fsl_dspi_edma.c ****         {
1262:../drivers/fsl_dspi_edma.c ****             transferConfigA.srcTransferSize = kEDMA_TransferSize1Bytes;
1263:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 1;
1264:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
1265:../drivers/fsl_dspi_edma.c ****         }
1266:../drivers/fsl_dspi_edma.c ****         else
1267:../drivers/fsl_dspi_edma.c ****         {
1268:../drivers/fsl_dspi_edma.c ****             transferConfigA.srcTransferSize = kEDMA_TransferSize2Bytes;
1269:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 2;
1270:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
1271:../drivers/fsl_dspi_edma.c ****         }
1272:../drivers/fsl_dspi_edma.c **** 
1273:../drivers/fsl_dspi_edma.c ****         /* Store the initially configured eDMA minor byte transfer count into the DSPI handle */
1274:../drivers/fsl_dspi_edma.c ****         handle->nbytes = transferConfigA.minorLoopBytes;
1275:../drivers/fsl_dspi_edma.c **** 
1276:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHand
1277:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
1278:../drivers/fsl_dspi_edma.c ****         EDMA_EnableChannelInterrupts(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDa
1279:../drivers/fsl_dspi_edma.c ****                                      kEDMA_MajorInterruptEnable);
1280:../drivers/fsl_dspi_edma.c ****     }
1281:../drivers/fsl_dspi_edma.c **** 
1282:../drivers/fsl_dspi_edma.c ****     if (handle->remainingSendByteCount > 0)
1283:../drivers/fsl_dspi_edma.c ****     {
1284:../drivers/fsl_dspi_edma.c ****         /***channel_C *** used for carry the data from User_Send_Buffer to Tx_Data_Register(PUSHR_S
1285:../drivers/fsl_dspi_edma.c ****         EDMA_ResetChannel(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataToTxRegHandle->c
1286:../drivers/fsl_dspi_edma.c **** 
1287:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
1288:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
1289:../drivers/fsl_dspi_edma.c **** 
1290:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
1291:../drivers/fsl_dspi_edma.c ****         {
1292:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcAddr = (uint32_t)(&(handle->txData[0]));
1293:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 1;
1294:../drivers/fsl_dspi_edma.c ****         }
1295:../drivers/fsl_dspi_edma.c ****         else
1296:../drivers/fsl_dspi_edma.c ****         {
1297:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcAddr = (uint32_t)(&handle->txBuffIfNull);
1298:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 0;
1299:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
1300:../drivers/fsl_dspi_edma.c ****             {
1301:../drivers/fsl_dspi_edma.c ****                 handle->txBuffIfNull = dummyData;
1302:../drivers/fsl_dspi_edma.c ****             }
1303:../drivers/fsl_dspi_edma.c ****             else
1304:../drivers/fsl_dspi_edma.c ****             {
1305:../drivers/fsl_dspi_edma.c ****                 handle->txBuffIfNull = ((uint32_t)dummyData << 8) | dummyData;
1306:../drivers/fsl_dspi_edma.c ****             }
1307:../drivers/fsl_dspi_edma.c ****         }
1308:../drivers/fsl_dspi_edma.c **** 
1309:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize1Bytes;
1310:../drivers/fsl_dspi_edma.c **** 
1311:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
1312:../drivers/fsl_dspi_edma.c ****         {
1313:../drivers/fsl_dspi_edma.c ****             transferConfigC.destTransferSize = kEDMA_TransferSize1Bytes;
1314:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 1;
1315:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount;
1316:../drivers/fsl_dspi_edma.c ****         }
1317:../drivers/fsl_dspi_edma.c ****         else
1318:../drivers/fsl_dspi_edma.c ****         {
1319:../drivers/fsl_dspi_edma.c ****             transferConfigC.destTransferSize = kEDMA_TransferSize2Bytes;
1320:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 2;
1321:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount / 2;
1322:../drivers/fsl_dspi_edma.c ****         }
1323:../drivers/fsl_dspi_edma.c **** 
1324:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataToTxRegHand
1325:../drivers/fsl_dspi_edma.c ****                                &transferConfigC, NULL);
1326:../drivers/fsl_dspi_edma.c **** 
1327:../drivers/fsl_dspi_edma.c ****         EDMA_StartTransfer(handle->edmaTxDataToTxRegHandle);
1328:../drivers/fsl_dspi_edma.c ****     }
1329:../drivers/fsl_dspi_edma.c **** 
1330:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaRxRegToRxDataHandle);
1331:../drivers/fsl_dspi_edma.c **** 
1332:../drivers/fsl_dspi_edma.c ****     /*Set channel priority*/
1333:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityLow = handle->edmaRxRegToRxDataHandle->channel;
1334:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaTxDataToTxRegHandle->channel;
1335:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
1336:../drivers/fsl_dspi_edma.c **** 
1337:../drivers/fsl_dspi_edma.c ****     if (channelPriorityLow > channelPriorityHigh)
1338:../drivers/fsl_dspi_edma.c ****     {
1339:../drivers/fsl_dspi_edma.c ****         t = channelPriorityLow;
1340:../drivers/fsl_dspi_edma.c ****         channelPriorityLow = channelPriorityHigh;
1341:../drivers/fsl_dspi_edma.c ****         channelPriorityHigh = t;
1342:../drivers/fsl_dspi_edma.c ****     }
1343:../drivers/fsl_dspi_edma.c **** 
1344:../drivers/fsl_dspi_edma.c ****     edma_channel_Preemption_config_t preemption_config_t;
1345:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enableChannelPreemption = true;
1346:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
1347:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
1348:../drivers/fsl_dspi_edma.c **** 
1349:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1350:../drivers/fsl_dspi_edma.c ****     {
1351:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
1352:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1353:../drivers/fsl_dspi_edma.c **** 
1354:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
1355:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataTo
1356:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1357:../drivers/fsl_dspi_edma.c ****     }
1358:../drivers/fsl_dspi_edma.c ****     else
1359:../drivers/fsl_dspi_edma.c ****     {
1360:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataTo
1361:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1362:../drivers/fsl_dspi_edma.c **** 
1363:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
1364:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
1365:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1366:../drivers/fsl_dspi_edma.c ****     }
1367:../drivers/fsl_dspi_edma.c **** 
1368:../drivers/fsl_dspi_edma.c ****     /*Set the channel link.
1369:../drivers/fsl_dspi_edma.c ****     For DSPI instances with shared RX/TX DMA requests: Rx DMA request -> channel_A -> channel_C.
1370:../drivers/fsl_dspi_edma.c ****     For DSPI instances with separate RX and TX DMA requests:
1371:../drivers/fsl_dspi_edma.c ****     Rx DMA request -> channel_A
1372:../drivers/fsl_dspi_edma.c ****     Tx DMA request -> channel_C */
1373:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1374:../drivers/fsl_dspi_edma.c ****     {
1375:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 0)
1376:../drivers/fsl_dspi_edma.c ****         {
1377:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHan
1378:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToTxRegHandle->channel);
1379:../drivers/fsl_dspi_edma.c ****         }
1380:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable);
1381:../drivers/fsl_dspi_edma.c ****     }
1382:../drivers/fsl_dspi_edma.c ****     else
1383:../drivers/fsl_dspi_edma.c ****     {
1384:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1385:../drivers/fsl_dspi_edma.c ****     }
1386:../drivers/fsl_dspi_edma.c **** 
1387:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
1388:../drivers/fsl_dspi_edma.c **** }
1389:../drivers/fsl_dspi_edma.c **** 
1390:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiSlaveCallback(edma_handle_t *edmaHandle,
1391:../drivers/fsl_dspi_edma.c ****                                    void *g_dspiEdmaPrivateHandle,
1392:../drivers/fsl_dspi_edma.c ****                                    bool transferDone,
1393:../drivers/fsl_dspi_edma.c ****                                    uint32_t tcds)
1394:../drivers/fsl_dspi_edma.c **** {
 158              		.loc 2 1394 0
 159              		.cfi_startproc
 160              		@ args = 0, pretend = 0, frame = 0
 161              		@ frame_needed = 0, uses_anonymous_args = 0
 162              		@ link register save eliminated.
 163              	.LVL11:
1395:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
1396:../drivers/fsl_dspi_edma.c ****     assert(g_dspiEdmaPrivateHandle);
1397:../drivers/fsl_dspi_edma.c **** 
1398:../drivers/fsl_dspi_edma.c ****     dspi_slave_edma_private_handle_t *dspiEdmaPrivateHandle;
1399:../drivers/fsl_dspi_edma.c **** 
1400:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle = (dspi_slave_edma_private_handle_t *)g_dspiEdmaPrivateHandle;
1401:../drivers/fsl_dspi_edma.c **** 
1402:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA((dspiEdmaPrivateHandle->base), kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 164              		.loc 2 1402 0
 165 0000 0868     		ldr	r0, [r1]
 166              	.LVL12:
1403:../drivers/fsl_dspi_edma.c **** 
1404:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle->handle->state = kDSPI_Idle;
 167              		.loc 2 1404 0
 168 0002 4968     		ldr	r1, [r1, #4]
 169              	.LVL13:
 170              	.LBB110:
 171              	.LBB111:
 172              		.loc 3 661 0
 173 0004 036B     		ldr	r3, [r0, #48]
 174              	.LVL14:
 175              	.LBE111:
 176              	.LBE110:
1394:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
 177              		.loc 2 1394 0
 178 0006 10B4     		push	{r4}
 179              		.cfi_def_cfa_offset 4
 180              		.cfi_offset 4, -4
 181              	.LBB115:
 182              	.LBB112:
 183              		.loc 3 661 0
 184 0008 23F04073 		bic	r3, r3, #50331648
 185              	.LBE112:
 186              	.LBE115:
1405:../drivers/fsl_dspi_edma.c **** 
1406:../drivers/fsl_dspi_edma.c ****     if (dspiEdmaPrivateHandle->handle->callback)
 187              		.loc 2 1406 0
 188 000c 8C6A     		ldr	r4, [r1, #40]
 189              	.LBB116:
 190              	.LBB113:
 191              		.loc 3 661 0
 192 000e 23F44033 		bic	r3, r3, #196608
 193              	.LBE113:
 194              	.LBE116:
1404:../drivers/fsl_dspi_edma.c **** 
 195              		.loc 2 1404 0
 196 0012 0022     		movs	r2, #0
 197              	.LVL15:
 198              	.LBB117:
 199              	.LBB114:
 200              		.loc 3 661 0
 201 0014 0363     		str	r3, [r0, #48]
 202              	.LVL16:
 203              	.LBE114:
 204              	.LBE117:
1404:../drivers/fsl_dspi_edma.c **** 
 205              		.loc 2 1404 0
 206 0016 81F82520 		strb	r2, [r1, #37]
 207              		.loc 2 1406 0
 208 001a 24B1     		cbz	r4, .L6
1407:../drivers/fsl_dspi_edma.c ****     {
1408:../drivers/fsl_dspi_edma.c ****         dspiEdmaPrivateHandle->handle->callback(dspiEdmaPrivateHandle->base, dspiEdmaPrivateHandle-
 209              		.loc 2 1408 0
 210 001c A446     		mov	ip, r4
 211 001e CB6A     		ldr	r3, [r1, #44]
1409:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
1410:../drivers/fsl_dspi_edma.c ****     }
1411:../drivers/fsl_dspi_edma.c **** }
 212              		.loc 2 1411 0
 213 0020 5DF8044B 		ldr	r4, [sp], #4
 214              		.cfi_remember_state
 215              		.cfi_restore 4
 216              		.cfi_def_cfa_offset 0
1408:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
 217              		.loc 2 1408 0
 218 0024 6047     		bx	ip	@ indirect register sibling call
 219              	.LVL17:
 220              	.L6:
 221              		.cfi_restore_state
 222              		.loc 2 1411 0
 223 0026 5DF8044B 		ldr	r4, [sp], #4
 224              		.cfi_restore 4
 225              		.cfi_def_cfa_offset 0
 226 002a 7047     		bx	lr
 227              		.cfi_endproc
 228              	.LFE185:
 230              		.section	.text.DSPI_MasterTransferCreateHandleEDMA,"ax",%progbits
 231              		.align	1
 232              		.global	DSPI_MasterTransferCreateHandleEDMA
 233              		.syntax unified
 234              		.thumb
 235              		.thumb_func
 236              		.fpu fpv4-sp-d16
 238              	DSPI_MasterTransferCreateHandleEDMA:
 239              	.LFB177:
 109:../drivers/fsl_dspi_edma.c ****     assert(handle);
 240              		.loc 2 109 0
 241              		.cfi_startproc
 242              		@ args = 12, pretend = 0, frame = 0
 243              		@ frame_needed = 0, uses_anonymous_args = 0
 244              	.LVL18:
 245 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 246              		.cfi_def_cfa_offset 24
 247              		.cfi_offset 3, -24
 248              		.cfi_offset 4, -20
 249              		.cfi_offset 5, -16
 250              		.cfi_offset 6, -12
 251              		.cfi_offset 7, -8
 252              		.cfi_offset 14, -4
 109:../drivers/fsl_dspi_edma.c ****     assert(handle);
 253              		.loc 2 109 0
 254 0002 0C46     		mov	r4, r1
 255 0004 0546     		mov	r5, r0
 256 0006 1746     		mov	r7, r2
 118:../drivers/fsl_dspi_edma.c **** 
 257              		.loc 2 118 0
 258 0008 0021     		movs	r1, #0
 259              	.LVL19:
 260 000a 8022     		movs	r2, #128
 261              	.LVL20:
 262 000c 2046     		mov	r0, r4
 263              	.LVL21:
 109:../drivers/fsl_dspi_edma.c ****     assert(handle);
 264              		.loc 2 109 0
 265 000e 1E46     		mov	r6, r3
 118:../drivers/fsl_dspi_edma.c **** 
 266              		.loc 2 118 0
 267 0010 FFF7FEFF 		bl	memset
 268              	.LVL22:
 120:../drivers/fsl_dspi_edma.c **** 
 269              		.loc 2 120 0
 270 0014 2846     		mov	r0, r5
 271 0016 FFF7FEFF 		bl	DSPI_GetInstance
 272              	.LVL23:
 122:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].handle = handle;
 273              		.loc 2 122 0
 274 001a 074A     		ldr	r2, .L9
 128:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToIntermediaryHandle = edmaTxDataToIntermediaryHandle;
 275              		.loc 2 128 0
 276 001c 069B     		ldr	r3, [sp, #24]
 122:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].handle = handle;
 277              		.loc 2 122 0
 278 001e 42F83050 		str	r5, [r2, r0, lsl #3]
 128:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToIntermediaryHandle = edmaTxDataToIntermediaryHandle;
 279              		.loc 2 128 0
 280 0022 6363     		str	r3, [r4, #52]
 123:../drivers/fsl_dspi_edma.c **** 
 281              		.loc 2 123 0
 282 0024 02EBC002 		add	r2, r2, r0, lsl #3
 129:../drivers/fsl_dspi_edma.c ****     handle->edmaIntermediaryToTxRegHandle = edmaIntermediaryToTxRegHandle;
 283              		.loc 2 129 0
 284 0028 079B     		ldr	r3, [sp, #28]
 285 002a A363     		str	r3, [r4, #56]
 130:../drivers/fsl_dspi_edma.c **** }
 286              		.loc 2 130 0
 287 002c 089B     		ldr	r3, [sp, #32]
 123:../drivers/fsl_dspi_edma.c **** 
 288              		.loc 2 123 0
 289 002e 5460     		str	r4, [r2, #4]
 126:../drivers/fsl_dspi_edma.c **** 
 290              		.loc 2 126 0
 291 0030 C4E90B76 		strd	r7, r6, [r4, #44]
 130:../drivers/fsl_dspi_edma.c **** }
 292              		.loc 2 130 0
 293 0034 E363     		str	r3, [r4, #60]
 131:../drivers/fsl_dspi_edma.c **** 
 294              		.loc 2 131 0
 295 0036 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 296              	.LVL24:
 297              	.L10:
 298              		.align	2
 299              	.L9:
 300 0038 00000000 		.word	.LANCHOR0
 301              		.cfi_endproc
 302              	.LFE177:
 304              		.section	.text.DSPI_MasterTransferEDMA,"ax",%progbits
 305              		.align	1
 306              		.global	DSPI_MasterTransferEDMA
 307              		.syntax unified
 308              		.thumb
 309              		.thumb_func
 310              		.fpu fpv4-sp-d16
 312              	DSPI_MasterTransferEDMA:
 313              	.LFB178:
 134:../drivers/fsl_dspi_edma.c ****     assert(handle);
 314              		.loc 2 134 0
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 80
 317              		@ frame_needed = 0, uses_anonymous_args = 0
 318              	.LVL25:
 319 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 320              		.cfi_def_cfa_offset 28
 321              		.cfi_offset 4, -28
 322              		.cfi_offset 5, -24
 323              		.cfi_offset 6, -20
 324              		.cfi_offset 7, -16
 325              		.cfi_offset 8, -12
 326              		.cfi_offset 9, -8
 327              		.cfi_offset 14, -4
 139:../drivers/fsl_dspi_edma.c ****     {
 328              		.loc 2 139 0
 329 0004 9368     		ldr	r3, [r2, #8]
 134:../drivers/fsl_dspi_edma.c ****     assert(handle);
 330              		.loc 2 134 0
 331 0006 95B0     		sub	sp, sp, #84
 332              		.cfi_def_cfa_offset 112
 134:../drivers/fsl_dspi_edma.c ****     assert(handle);
 333              		.loc 2 134 0
 334 0008 0546     		mov	r5, r0
 335 000a 0C46     		mov	r4, r1
 336 000c 1746     		mov	r7, r2
 139:../drivers/fsl_dspi_edma.c ****     {
 337              		.loc 2 139 0
 338 000e 002B     		cmp	r3, #0
 339 0010 00F0B480 		beq	.L96
 145:../drivers/fsl_dspi_edma.c ****     {
 340              		.loc 2 145 0
 341 0014 1368     		ldr	r3, [r2]
 342 0016 1BB9     		cbnz	r3, .L13
 145:../drivers/fsl_dspi_edma.c ****     {
 343              		.loc 2 145 0 is_stmt 0 discriminator 1
 344 0018 5368     		ldr	r3, [r2, #4]
 345 001a 002B     		cmp	r3, #0
 346 001c 00F0AE80 		beq	.L96
 347              	.L13:
 151:../drivers/fsl_dspi_edma.c ****     {
 348              		.loc 2 151 0 is_stmt 1
 349 0020 E37B     		ldrb	r3, [r4, #15]	@ zero_extendqisi2
 350 0022 012B     		cmp	r3, #1
 351 0024 00F05983 		beq	.L97
 352              	.LVL26:
 353              	.LBB155:
 354              	.LBB156:
 156:../drivers/fsl_dspi_edma.c **** 
 355              		.loc 2 156 0
 356 0028 4FF00109 		mov	r9, #1
 357 002c 84F80F90 		strb	r9, [r4, #15]
 158:../drivers/fsl_dspi_edma.c ****     uint16_t wordToSend = 0;
 358              		.loc 2 158 0
 359 0030 2846     		mov	r0, r5
 360              	.LVL27:
 361 0032 FFF7FEFF 		bl	DSPI_GetInstance
 362              	.LVL28:
 363 0036 8046     		mov	r8, r0
 364              	.LVL29:
 160:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 365              		.loc 2 160 0
 366 0038 2846     		mov	r0, r5
 367              	.LVL30:
 368 003a FFF7FEFF 		bl	DSPI_GetInstance
 369              	.LVL31:
 370 003e 524B     		ldr	r3, .L141
 180:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 371              		.loc 2 180 0
 372 0040 F968     		ldr	r1, [r7, #12]
 160:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 373              		.loc 2 160 0
 374 0042 1E5C     		ldrb	r6, [r3, r0]	@ zero_extendqisi2
 375 0044 F6B2     		uxtb	r6, r6
 376              	.LVL32:
 172:../drivers/fsl_dspi_edma.c **** 
 377              		.loc 2 172 0
 378 0046 46EA0623 		orr	r3, r6, r6, lsl #8
 379 004a A362     		str	r3, [r4, #40]
 380              	.LVL33:
 381              	.LBB157:
 382              	.LBB158:
 662:../drivers/fsl_dspi.h **** }
 663:../drivers/fsl_dspi.h **** 
 664:../drivers/fsl_dspi.h **** /*!
 665:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI master PUSHR data register address for the DMA operation.
 666:../drivers/fsl_dspi.h ****  *
 667:../drivers/fsl_dspi.h ****  * This function gets the DSPI master PUSHR data register address because this value is needed for 
 668:../drivers/fsl_dspi.h ****  *
 669:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 670:../drivers/fsl_dspi.h ****  * @return The DSPI master PUSHR data register address.
 671:../drivers/fsl_dspi.h ****  */
 672:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_MasterGetTxRegisterAddress(SPI_Type *base)
 673:../drivers/fsl_dspi.h **** {
 674:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->PUSHR);
 675:../drivers/fsl_dspi.h **** }
 676:../drivers/fsl_dspi.h **** 
 677:../drivers/fsl_dspi.h **** /*!
 678:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI slave PUSHR data register address for the DMA operation.
 679:../drivers/fsl_dspi.h ****  *
 680:../drivers/fsl_dspi.h ****  * This function gets the DSPI slave PUSHR data register address as this value is needed for the DM
 681:../drivers/fsl_dspi.h ****  *
 682:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 683:../drivers/fsl_dspi.h ****  * @return The DSPI slave PUSHR data register address.
 684:../drivers/fsl_dspi.h ****  */
 685:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_SlaveGetTxRegisterAddress(SPI_Type *base)
 686:../drivers/fsl_dspi.h **** {
 687:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->PUSHR_SLAVE);
 688:../drivers/fsl_dspi.h **** }
 689:../drivers/fsl_dspi.h **** 
 690:../drivers/fsl_dspi.h **** /*!
 691:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI POPR data register address for the DMA operation.
 692:../drivers/fsl_dspi.h ****  *
 693:../drivers/fsl_dspi.h ****  * This function gets the DSPI POPR data register address as this value is needed for the DMA opera
 694:../drivers/fsl_dspi.h ****  *
 695:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 696:../drivers/fsl_dspi.h ****  * @return The DSPI POPR data register address.
 697:../drivers/fsl_dspi.h ****  */
 698:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_GetRxRegisterAddress(SPI_Type *base)
 699:../drivers/fsl_dspi.h **** {
 700:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->POPR);
 701:../drivers/fsl_dspi.h **** }
 702:../drivers/fsl_dspi.h **** 
 703:../drivers/fsl_dspi.h **** /*!
 704:../drivers/fsl_dspi.h ****  *@}
 705:../drivers/fsl_dspi.h **** */
 706:../drivers/fsl_dspi.h **** 
 707:../drivers/fsl_dspi.h **** /*!
 708:../drivers/fsl_dspi.h ****  * @name Bus Operations
 709:../drivers/fsl_dspi.h ****  * @{
 710:../drivers/fsl_dspi.h ****  */
 711:../drivers/fsl_dspi.h **** 
 712:../drivers/fsl_dspi.h **** /*!
 713:../drivers/fsl_dspi.h ****  * @brief Configures the DSPI for master or slave.
 714:../drivers/fsl_dspi.h ****  *
 715:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 716:../drivers/fsl_dspi.h ****  * @param mode Mode setting (master or slave) of type dspi_master_slave_mode_t.
 717:../drivers/fsl_dspi.h ****  */
 718:../drivers/fsl_dspi.h **** static inline void DSPI_SetMasterSlaveMode(SPI_Type *base, dspi_master_slave_mode_t mode)
 719:../drivers/fsl_dspi.h **** {
 720:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~SPI_MCR_MSTR_MASK)) | SPI_MCR_MSTR(mode);
 721:../drivers/fsl_dspi.h **** }
 722:../drivers/fsl_dspi.h **** 
 723:../drivers/fsl_dspi.h **** /*!
 724:../drivers/fsl_dspi.h ****  * @brief Returns whether the DSPI module is in master mode.
 725:../drivers/fsl_dspi.h ****  *
 726:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 727:../drivers/fsl_dspi.h ****  * @return Returns true if the module is in master mode or false if the module is in slave mode.
 728:../drivers/fsl_dspi.h ****  */
 729:../drivers/fsl_dspi.h **** static inline bool DSPI_IsMaster(SPI_Type *base)
 730:../drivers/fsl_dspi.h **** {
 731:../drivers/fsl_dspi.h ****     return (bool)((base->MCR) & SPI_MCR_MSTR_MASK);
 732:../drivers/fsl_dspi.h **** }
 733:../drivers/fsl_dspi.h **** /*!
 734:../drivers/fsl_dspi.h ****  * @brief Starts the DSPI transfers and clears HALT bit in MCR.
 735:../drivers/fsl_dspi.h ****  *
 736:../drivers/fsl_dspi.h ****  * This function sets the module to start data transfer in either master or slave mode.
 737:../drivers/fsl_dspi.h ****  *
 738:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 739:../drivers/fsl_dspi.h ****  */
 740:../drivers/fsl_dspi.h **** static inline void DSPI_StartTransfer(SPI_Type *base)
 741:../drivers/fsl_dspi.h **** {
 742:../drivers/fsl_dspi.h ****     base->MCR &= ~SPI_MCR_HALT_MASK;
 743:../drivers/fsl_dspi.h **** }
 744:../drivers/fsl_dspi.h **** /*!
 745:../drivers/fsl_dspi.h ****  * @brief Stops DSPI transfers and sets the HALT bit in MCR.
 746:../drivers/fsl_dspi.h ****  *
 747:../drivers/fsl_dspi.h ****  * This function stops data transfers in either master or slave modes.
 748:../drivers/fsl_dspi.h ****  *
 749:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 750:../drivers/fsl_dspi.h ****  */
 751:../drivers/fsl_dspi.h **** static inline void DSPI_StopTransfer(SPI_Type *base)
 752:../drivers/fsl_dspi.h **** {
 753:../drivers/fsl_dspi.h ****     base->MCR |= SPI_MCR_HALT_MASK;
 383              		.loc 3 753 0
 384 004c 2B68     		ldr	r3, [r5]
 385 004e 43EA0903 		orr	r3, r3, r9
 386 0052 2B60     		str	r3, [r5]
 387              	.LVL34:
 388              	.LBE158:
 389              	.LBE157:
 390              	.LBB159:
 391              	.LBB160:
 754:../drivers/fsl_dspi.h **** }
 755:../drivers/fsl_dspi.h **** 
 756:../drivers/fsl_dspi.h **** /*!
 757:../drivers/fsl_dspi.h ****  * @brief Enables or disables the DSPI FIFOs.
 758:../drivers/fsl_dspi.h ****  *
 759:../drivers/fsl_dspi.h ****  * This function  allows the caller to disable/enable the Tx and Rx FIFOs independently.
 760:../drivers/fsl_dspi.h ****  * Note that to disable, pass in a logic 0 (false) for the particular FIFO configuration.  To enabl
 761:../drivers/fsl_dspi.h ****  * pass in a logic 1 (true).
 762:../drivers/fsl_dspi.h ****  *
 763:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 764:../drivers/fsl_dspi.h ****  * @param enableTxFifo Disables (false) the TX FIFO; Otherwise, enables (true) the TX FIFO
 765:../drivers/fsl_dspi.h ****  * @param enableRxFifo Disables (false) the RX FIFO; Otherwise, enables (true) the RX FIFO
 766:../drivers/fsl_dspi.h ****  */
 767:../drivers/fsl_dspi.h **** static inline void DSPI_SetFifoEnable(SPI_Type *base, bool enableTxFifo, bool enableRxFifo)
 768:../drivers/fsl_dspi.h **** {
 769:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~(SPI_MCR_DIS_RXF_MASK | SPI_MCR_DIS_TXF_MASK))) | SPI_MCR_DIS_TXF(!e
 770:../drivers/fsl_dspi.h ****                 SPI_MCR_DIS_RXF(!enableRxFifo);
 771:../drivers/fsl_dspi.h **** }
 772:../drivers/fsl_dspi.h **** 
 773:../drivers/fsl_dspi.h **** /*!
 774:../drivers/fsl_dspi.h ****  * @brief Flushes the DSPI FIFOs.
 775:../drivers/fsl_dspi.h ****  *
 776:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 777:../drivers/fsl_dspi.h ****  * @param flushTxFifo Flushes (true) the Tx FIFO; Otherwise, does not flush (false) the Tx FIFO
 778:../drivers/fsl_dspi.h ****  * @param flushRxFifo Flushes (true) the Rx FIFO; Otherwise, does not flush (false) the Rx FIFO
 779:../drivers/fsl_dspi.h ****  */
 780:../drivers/fsl_dspi.h **** static inline void DSPI_FlushFifo(SPI_Type *base, bool flushTxFifo, bool flushRxFifo)
 781:../drivers/fsl_dspi.h **** {
 782:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) | SPI_MCR_CLR_TXF(fl
 392              		.loc 3 782 0
 393 0054 2B68     		ldr	r3, [r5]
 394 0056 43F44063 		orr	r3, r3, #3072
 395 005a 2B60     		str	r3, [r5]
 396              	.LVL35:
 397              	.LBE160:
 398              	.LBE159:
 184:../drivers/fsl_dspi_edma.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 399              		.loc 2 184 0
 400 005c 01F00F00 		and	r0, r1, #15
 401              	.LBB161:
 402              	.LBB162:
 580:../drivers/fsl_dspi.h **** }
 403              		.loc 3 580 0
 404 0060 4A4B     		ldr	r3, .L141+4
 405 0062 EB62     		str	r3, [r5, #44]
 406              	.LVL36:
 407              	.LBE162:
 408              	.LBE161:
 180:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 409              		.loc 2 180 0
 410 0064 C1F30312 		ubfx	r2, r1, #4, #4
 411              	.LBB163:
 412              	.LBB164:
 783:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 784:../drivers/fsl_dspi.h **** }
 785:../drivers/fsl_dspi.h **** 
 786:../drivers/fsl_dspi.h **** /*!
 787:../drivers/fsl_dspi.h ****  * @brief Configures the DSPI peripheral chip select polarity simultaneously.
 788:../drivers/fsl_dspi.h ****  * For example, PCS0 and PCS1 are set to active low and other PCS is set to active high. Note that 
 789:../drivers/fsl_dspi.h ****  * PCSs is specific to the device.
 790:../drivers/fsl_dspi.h ****  * @code
 791:../drivers/fsl_dspi.h ****  *  DSPI_SetAllPcsPolarity(base, kDSPI_Pcs0ActiveLow | kDSPI_Pcs1ActiveLow);
 792:../drivers/fsl_dspi.h ****    @endcode
 793:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 794:../drivers/fsl_dspi.h ****  * @param mask The PCS polarity mask; use the enum _dspi_pcs_polarity.
 795:../drivers/fsl_dspi.h ****  */
 796:../drivers/fsl_dspi.h **** static inline void DSPI_SetAllPcsPolarity(SPI_Type *base, uint32_t mask)
 797:../drivers/fsl_dspi.h **** {
 798:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & ~SPI_MCR_PCSIS_MASK) | SPI_MCR_PCSIS(mask);
 799:../drivers/fsl_dspi.h **** }
 800:../drivers/fsl_dspi.h **** 
 801:../drivers/fsl_dspi.h **** /*!
 802:../drivers/fsl_dspi.h ****  * @brief Sets the DSPI baud rate in bits per second.
 803:../drivers/fsl_dspi.h ****  *
 804:../drivers/fsl_dspi.h ****  * This function  takes in the desired baudRate_Bps (baud rate) and calculates the nearest possible
 805:../drivers/fsl_dspi.h ****  * exceeding the desired baud rate, and returns the calculated baud rate in bits-per-second. It req
 806:../drivers/fsl_dspi.h ****  * caller also provide the frequency of the module source clock (in Hertz).
 807:../drivers/fsl_dspi.h ****  *
 808:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 809:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of the type dspi_ctar
 810:../drivers/fsl_dspi.h ****  * @param baudRate_Bps The desired baud rate in bits per second
 811:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz
 812:../drivers/fsl_dspi.h ****  * @return The actual calculated baud rate
 813:../drivers/fsl_dspi.h ****  */
 814:../drivers/fsl_dspi.h **** uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
 815:../drivers/fsl_dspi.h ****                                 dspi_ctar_selection_t whichCtar,
 816:../drivers/fsl_dspi.h ****                                 uint32_t baudRate_Bps,
 817:../drivers/fsl_dspi.h ****                                 uint32_t srcClock_Hz);
 818:../drivers/fsl_dspi.h **** 
 819:../drivers/fsl_dspi.h **** /*!
 820:../drivers/fsl_dspi.h ****  * @brief Manually configures the delay prescaler and scaler for a particular CTAR.
 821:../drivers/fsl_dspi.h ****  *
 822:../drivers/fsl_dspi.h ****  * This function configures the PCS to SCK delay pre-scalar (PcsSCK) and scalar (CSSCK), after SCK 
 823:../drivers/fsl_dspi.h ****  * (PASC) and scalar (ASC), and the delay after transfer pre-scalar (PDT) and scalar (DT).
 824:../drivers/fsl_dspi.h ****  *
 825:../drivers/fsl_dspi.h ****  * These delay names are available in the type dspi_delay_type_t.
 826:../drivers/fsl_dspi.h ****  *
 827:../drivers/fsl_dspi.h ****  * The user passes the delay to the configuration along with the prescaler and scaler value.
 828:../drivers/fsl_dspi.h ****  * This allows the user to directly set the prescaler/scaler values if pre-calculated or
 829:../drivers/fsl_dspi.h ****  * to manually increment either value.
 830:../drivers/fsl_dspi.h ****  *
 831:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 832:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of type dspi_ctar_sel
 833:../drivers/fsl_dspi.h ****  * @param prescaler The prescaler delay value (can be an integer 0, 1, 2, or 3).
 834:../drivers/fsl_dspi.h ****  * @param scaler The scaler delay value (can be any integer between 0 to 15).
 835:../drivers/fsl_dspi.h ****  * @param whichDelay The desired delay to configure; must be of type dspi_delay_type_t
 836:../drivers/fsl_dspi.h ****  */
 837:../drivers/fsl_dspi.h **** void DSPI_MasterSetDelayScaler(
 838:../drivers/fsl_dspi.h ****     SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_dela
 839:../drivers/fsl_dspi.h **** 
 840:../drivers/fsl_dspi.h **** /*!
 841:../drivers/fsl_dspi.h ****  * @brief Calculates the delay prescaler and scaler based on the desired delay input in nanoseconds
 842:../drivers/fsl_dspi.h ****  *
 843:../drivers/fsl_dspi.h ****  * This function calculates the values for the following.
 844:../drivers/fsl_dspi.h ****  * PCS to SCK delay pre-scalar (PCSSCK) and scalar (CSSCK), or
 845:../drivers/fsl_dspi.h ****  * After SCK delay pre-scalar (PASC) and scalar (ASC), or
 846:../drivers/fsl_dspi.h ****  * Delay after transfer pre-scalar (PDT) and scalar (DT).
 847:../drivers/fsl_dspi.h ****  *
 848:../drivers/fsl_dspi.h ****  * These delay names are available in the type dspi_delay_type_t.
 849:../drivers/fsl_dspi.h ****  *
 850:../drivers/fsl_dspi.h ****  * The user passes which delay to configure along with the desired delay value in nanoseconds.  The
 851:../drivers/fsl_dspi.h ****  * calculates the values needed for the prescaler and scaler. Note that returning the calculated de
 852:../drivers/fsl_dspi.h ****  * delay match may not be possible. In this case, the closest match is calculated without going bel
 853:../drivers/fsl_dspi.h ****  * delay value input.
 854:../drivers/fsl_dspi.h ****  * It is possible to input a very large delay value that exceeds the capability of the part, in whi
 855:../drivers/fsl_dspi.h ****  * supported delay is returned. The higher-level peripheral driver alerts the user of an out of ran
 856:../drivers/fsl_dspi.h ****  * input.
 857:../drivers/fsl_dspi.h ****  *
 858:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 859:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of type dspi_ctar_sel
 860:../drivers/fsl_dspi.h ****  * @param whichDelay The desired delay to configure, must be of type dspi_delay_type_t
 861:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz
 862:../drivers/fsl_dspi.h ****  * @param delayTimeInNanoSec The desired delay value in nanoseconds.
 863:../drivers/fsl_dspi.h ****  * @return The actual calculated delay value.
 864:../drivers/fsl_dspi.h ****  */
 865:../drivers/fsl_dspi.h **** uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
 866:../drivers/fsl_dspi.h ****                                   dspi_ctar_selection_t whichCtar,
 867:../drivers/fsl_dspi.h ****                                   dspi_delay_type_t whichDelay,
 868:../drivers/fsl_dspi.h ****                                   uint32_t srcClock_Hz,
 869:../drivers/fsl_dspi.h ****                                   uint32_t delayTimeInNanoSec);
 870:../drivers/fsl_dspi.h **** 
 871:../drivers/fsl_dspi.h **** /*!
 872:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer for master mode.
 873:../drivers/fsl_dspi.h ****  *
 874:../drivers/fsl_dspi.h ****  * In master mode, the 16-bit data is appended to the 16-bit command info. The command portion
 875:../drivers/fsl_dspi.h ****  * provides characteristics of the data, such as the optional continuous chip select
 876:../drivers/fsl_dspi.h ****  * operation between transfers, the desired Clock and Transfer Attributes register to use for the
 877:../drivers/fsl_dspi.h ****  * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
 878:../drivers/fsl_dspi.h ****  * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
 879:../drivers/fsl_dspi.h ****  * sending the first frame of a data packet). This is an example.
 880:../drivers/fsl_dspi.h ****  * @code
 881:../drivers/fsl_dspi.h ****  *  dspi_command_data_config_t commandConfig;
 882:../drivers/fsl_dspi.h ****  *  commandConfig.isPcsContinuous = true;
 883:../drivers/fsl_dspi.h ****  *  commandConfig.whichCtar = kDSPICtar0;
 884:../drivers/fsl_dspi.h ****  *  commandConfig.whichPcs = kDSPIPcs0;
 885:../drivers/fsl_dspi.h ****  *  commandConfig.clearTransferCount = false;
 886:../drivers/fsl_dspi.h ****  *  commandConfig.isEndOfQueue = false;
 887:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteData(base, &commandConfig, dataWord);
 888:../drivers/fsl_dspi.h ****    @endcode
 889:../drivers/fsl_dspi.h ****  *
 890:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 891:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 892:../drivers/fsl_dspi.h ****  * @param data The data word to be sent.
 893:../drivers/fsl_dspi.h ****  */
 894:../drivers/fsl_dspi.h **** static inline void DSPI_MasterWriteData(SPI_Type *base, dspi_command_data_config_t *command, uint16
 895:../drivers/fsl_dspi.h **** {
 896:../drivers/fsl_dspi.h ****     base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
 897:../drivers/fsl_dspi.h ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 898:../drivers/fsl_dspi.h ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 899:../drivers/fsl_dspi.h **** }
 900:../drivers/fsl_dspi.h **** 
 901:../drivers/fsl_dspi.h **** /*!
 902:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_command_data_config_t structure to default values.
 903:../drivers/fsl_dspi.h ****  *
 904:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for use in the DSPI_Ma
 905:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_MasterWrite_xx() or modify the str
 906:../drivers/fsl_dspi.h ****  * before calling the DSPI_MasterWrite_xx().
 907:../drivers/fsl_dspi.h ****  * This is an example.
 908:../drivers/fsl_dspi.h ****  * @code
 909:../drivers/fsl_dspi.h ****  *  dspi_command_data_config_t  command;
 910:../drivers/fsl_dspi.h ****  *  DSPI_GetDefaultDataCommandConfig(&command);
 911:../drivers/fsl_dspi.h ****  * @endcode
 912:../drivers/fsl_dspi.h ****  * @param command Pointer to the dspi_command_data_config_t structure.
 913:../drivers/fsl_dspi.h ****  */
 914:../drivers/fsl_dspi.h **** void DSPI_GetDefaultDataCommandConfig(dspi_command_data_config_t *command);
 915:../drivers/fsl_dspi.h **** 
 916:../drivers/fsl_dspi.h **** /*!
 917:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer master mode and waits till complete to return.
 918:../drivers/fsl_dspi.h ****  *
 919:../drivers/fsl_dspi.h ****  * In master mode, the 16-bit data is appended to the 16-bit command info. The command portion
 920:../drivers/fsl_dspi.h ****  * provides characteristics of the data, such as the optional continuous chip select
 921:../drivers/fsl_dspi.h ****  * operation between transfers, the desired Clock and Transfer Attributes register to use for the
 922:../drivers/fsl_dspi.h ****  * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
 923:../drivers/fsl_dspi.h ****  * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
 924:../drivers/fsl_dspi.h ****  * sending the first frame of a data packet). This is an example.
 925:../drivers/fsl_dspi.h ****  * @code
 926:../drivers/fsl_dspi.h ****  *  dspi_command_config_t commandConfig;
 927:../drivers/fsl_dspi.h ****  *  commandConfig.isPcsContinuous = true;
 928:../drivers/fsl_dspi.h ****  *  commandConfig.whichCtar = kDSPICtar0;
 929:../drivers/fsl_dspi.h ****  *  commandConfig.whichPcs = kDSPIPcs1;
 930:../drivers/fsl_dspi.h ****  *  commandConfig.clearTransferCount = false;
 931:../drivers/fsl_dspi.h ****  *  commandConfig.isEndOfQueue = false;
 932:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteDataBlocking(base, &commandConfig, dataWord);
 933:../drivers/fsl_dspi.h ****  * @endcode
 934:../drivers/fsl_dspi.h ****  *
 935:../drivers/fsl_dspi.h ****  * Note that this function does not return until after the transmit is complete. Also note that the
 936:../drivers/fsl_dspi.h ****  * enabled and running to transmit data (MCR[MDIS] & [HALT] = 0). Because the SPI is a synchronous 
 937:../drivers/fsl_dspi.h ****  * the received data is available when the transmit completes.
 938:../drivers/fsl_dspi.h ****  *
 939:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 940:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 941:../drivers/fsl_dspi.h ****  * @param data The data word to be sent.
 942:../drivers/fsl_dspi.h ****  */
 943:../drivers/fsl_dspi.h **** void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t dat
 944:../drivers/fsl_dspi.h **** 
 945:../drivers/fsl_dspi.h **** /*!
 946:../drivers/fsl_dspi.h ****  * @brief Returns the DSPI command word formatted to the PUSHR data register bit field.
 947:../drivers/fsl_dspi.h ****  *
 948:../drivers/fsl_dspi.h ****  * This function allows the caller to pass in the data command structure and returns the command wo
 949:../drivers/fsl_dspi.h ****  * according to the DSPI PUSHR register bit field placement. The user can then "OR" the returned co
 950:../drivers/fsl_dspi.h ****  * desired data to send and use the function DSPI_HAL_WriteCommandDataMastermode or
 951:../drivers/fsl_dspi.h ****  * DSPI_HAL_WriteCommandDataMastermodeBlocking to write the entire 32-bit command data word to the 
 952:../drivers/fsl_dspi.h ****  * improve performance in cases where the command structure is constant. For example, the user call
 953:../drivers/fsl_dspi.h ****  * before starting a transfer to generate the command word. When they are ready to transmit the dat
 954:../drivers/fsl_dspi.h ****  * this formatted command word with the desired data to transmit. This process increases transmit p
 955:../drivers/fsl_dspi.h ****  * compared to calling send functions, such as DSPI_HAL_WriteDataMastermode,  which format the comm
 956:../drivers/fsl_dspi.h ****  * data word is to be sent.
 957:../drivers/fsl_dspi.h ****  *
 958:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 959:../drivers/fsl_dspi.h ****  * @return The command word formatted to the PUSHR data register bit field.
 960:../drivers/fsl_dspi.h ****  */
 961:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_MasterGetFormattedCommand(dspi_command_data_config_t *command)
 962:../drivers/fsl_dspi.h **** {
 963:../drivers/fsl_dspi.h ****     /* Format the 16-bit command word according to the PUSHR data register bit field*/
 964:../drivers/fsl_dspi.h ****     return (uint32_t)(SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar)
 413              		.loc 3 964 0
 414 0068 0307     		lsls	r3, r0, #28
 415              	.LBE164:
 416              	.LBE163:
 180:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 417              		.loc 2 180 0
 418 006a 09FA02F2 		lsl	r2, r9, r2
 419              	.LBB170:
 420              	.LBB165:
 421              		.loc 3 964 0
 422 006e 03F0E043 		and	r3, r3, #1879048192
 423              	.LBE165:
 424              	.LBE170:
 185:../drivers/fsl_dspi_edma.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 425              		.loc 2 185 0
 426 0072 C1F3005E 		ubfx	lr, r1, #20, #1
 427              	.LBB171:
 428              	.LBB166:
 965:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 429              		.loc 3 965 0
 430 0076 1204     		lsls	r2, r2, #16
 431              	.LBE166:
 432              	.LBE171:
 189:../drivers/fsl_dspi_edma.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 433              		.loc 2 189 0
 434 0078 C1F34051 		ubfx	r1, r1, #21, #1
 435              	.LBB172:
 436              	.LBB167:
 437              		.loc 3 965 0
 438 007c 02F47C12 		and	r2, r2, #4128768
 439              	.LBE167:
 440              	.LBE172:
 441              	.LBB173:
 442              	.LBB174:
 443 0080 43EAC171 		orr	r1, r3, r1, lsl #31
 444              	.LBE174:
 445              	.LBE173:
 446              	.LBB177:
 447              	.LBB168:
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 448              		.loc 3 964 0
 449 0084 43EA020C 		orr	ip, r3, r2
 450              	.LBE168:
 451              	.LBE177:
 452              	.LBB178:
 453              	.LBB175:
 454              		.loc 3 965 0
 455 0088 41F00061 		orr	r1, r1, #134217728
 456              	.LBE175:
 457              	.LBE178:
 192:../drivers/fsl_dspi_edma.c **** 
 458              		.loc 2 192 0
 459 008c 831C     		adds	r3, r0, #2
 460              	.LBB179:
 461              	.LBB176:
 462              		.loc 3 965 0
 463 008e 1143     		orrs	r1, r1, r2
 464              	.LBE176:
 465              	.LBE179:
 192:../drivers/fsl_dspi_edma.c **** 
 466              		.loc 2 192 0
 467 0090 05EB8303 		add	r3, r5, r3, lsl #2
 468              	.LBB180:
 469              	.LBB169:
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 470              		.loc 3 964 0
 471 0094 4CEACE7C 		orr	ip, ip, lr, lsl #31
 472              	.LVL37:
 473              	.LBE169:
 474              	.LBE180:
 186:../drivers/fsl_dspi_edma.c **** 
 475              		.loc 2 186 0
 476 0098 C4F804C0 		str	ip, [r4, #4]
 477              	.LVL38:
 190:../drivers/fsl_dspi_edma.c **** 
 478              		.loc 2 190 0
 479 009c A160     		str	r1, [r4, #8]
 192:../drivers/fsl_dspi_edma.c **** 
 480              		.loc 2 192 0
 481 009e 5A68     		ldr	r2, [r3, #4]
 194:../drivers/fsl_dspi_edma.c ****     {
 482              		.loc 2 194 0
 483 00a0 2B68     		ldr	r3, [r5]
 192:../drivers/fsl_dspi_edma.c **** 
 484              		.loc 2 192 0
 485 00a2 C2F3C362 		ubfx	r2, r2, #27, #4
 486 00a6 4A44     		add	r2, r2, r9
 194:../drivers/fsl_dspi_edma.c ****     {
 487              		.loc 2 194 0
 488 00a8 D804     		lsls	r0, r3, #19
 192:../drivers/fsl_dspi_edma.c **** 
 489              		.loc 2 192 0
 490 00aa 2260     		str	r2, [r4]
 194:../drivers/fsl_dspi_edma.c ****     {
 491              		.loc 2 194 0
 492 00ac 02D4     		bmi	.L14
 493 00ae 2B68     		ldr	r3, [r5]
 494 00b0 9904     		lsls	r1, r3, #18
 495 00b2 20D5     		bpl	.L15
 496              	.L14:
 196:../drivers/fsl_dspi_edma.c ****     }
 497              		.loc 2 196 0
 498 00b4 0123     		movs	r3, #1
 499              	.L17:
 200:../drivers/fsl_dspi_edma.c ****     }
 500              		.loc 2 200 0
 501 00b6 2373     		strb	r3, [r4, #12]
 202:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
 502              		.loc 2 202 0
 503 00b8 3B68     		ldr	r3, [r7]
 504 00ba 2361     		str	r3, [r4, #16]
 203:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
 505              		.loc 2 203 0
 506 00bc 7B68     		ldr	r3, [r7, #4]
 507 00be 6361     		str	r3, [r4, #20]
 204:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 508              		.loc 2 204 0
 509 00c0 BB68     		ldr	r3, [r7, #8]
 510 00c2 A361     		str	r3, [r4, #24]
 205:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
 511              		.loc 2 205 0
 512 00c4 BB68     		ldr	r3, [r7, #8]
 513 00c6 E361     		str	r3, [r4, #28]
 206:../drivers/fsl_dspi_edma.c **** 
 514              		.loc 2 206 0
 515 00c8 BB68     		ldr	r3, [r7, #8]
 214:../drivers/fsl_dspi_edma.c ****     }
 516              		.loc 2 214 0
 517 00ca 3148     		ldr	r0, .L141+8
 206:../drivers/fsl_dspi_edma.c **** 
 518              		.loc 2 206 0
 519 00cc 2362     		str	r3, [r4, #32]
 520              	.LVL39:
 214:../drivers/fsl_dspi_edma.c ****     }
 521              		.loc 2 214 0
 522 00ce 47F6FF71 		movw	r1, #32767
 523 00d2 40F2FF13 		movw	r3, #511
 524 00d6 8542     		cmp	r5, r0
 525 00d8 08BF     		it	eq
 526 00da 0B46     		moveq	r3, r1
 527              	.LVL40:
 221:../drivers/fsl_dspi_edma.c ****     {
 528              		.loc 2 221 0
 529 00dc 082A     		cmp	r2, #8
 223:../drivers/fsl_dspi_edma.c ****         {
 530              		.loc 2 223 0
 531 00de BA68     		ldr	r2, [r7, #8]
 221:../drivers/fsl_dspi_edma.c ****     {
 532              		.loc 2 221 0
 533 00e0 1BD9     		bls	.L19
 223:../drivers/fsl_dspi_edma.c ****         {
 534              		.loc 2 223 0
 535 00e2 B2EB430F 		cmp	r2, r3, lsl #1
 536 00e6 44D9     		bls	.L20
 537              	.L137:
 233:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 538              		.loc 2 233 0
 539 00e8 0023     		movs	r3, #0
 540              	.LVL41:
 541 00ea E373     		strb	r3, [r4, #15]
 234:../drivers/fsl_dspi_edma.c ****         }
 542              		.loc 2 234 0
 543 00ec 40F25B20 		movw	r0, #603
 544              	.LVL42:
 545              	.L11:
 546              	.LBE156:
 547              	.LBE155:
 923:../drivers/fsl_dspi_edma.c **** 
 548              		.loc 2 923 0
 549 00f0 15B0     		add	sp, sp, #84
 550              		.cfi_remember_state
 551              		.cfi_def_cfa_offset 28
 552              		@ sp needed
 553 00f2 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 554              	.LVL43:
 555              	.L15:
 556              		.cfi_restore_state
 557              	.LBB216:
 558              	.LBB213:
 200:../drivers/fsl_dspi_edma.c ****     }
 559              		.loc 2 200 0
 560 00f6 264B     		ldr	r3, .L141+8
 561 00f8 9D42     		cmp	r5, r3
 562 00fa 0AD0     		beq	.L98
 563 00fc 03F58053 		add	r3, r3, #4096
 564 0100 9D42     		cmp	r5, r3
 565 0102 08D0     		beq	.L99
 566 0104 03F5FE23 		add	r3, r3, #520192
 567 0108 9D42     		cmp	r5, r3
 568 010a 14BF     		ite	ne
 569 010c FF23     		movne	r3, #255
 570 010e 0123     		moveq	r3, #1
 571 0110 D1E7     		b	.L17
 572              	.L98:
 573 0112 0423     		movs	r3, #4
 574 0114 CFE7     		b	.L17
 575              	.L99:
 576 0116 4B46     		mov	r3, r9
 577 0118 CDE7     		b	.L17
 578              	.LVL44:
 579              	.L19:
 231:../drivers/fsl_dspi_edma.c ****         {
 580              		.loc 2 231 0
 581 011a 9342     		cmp	r3, r2
 582 011c E4D3     		bcc	.L137
 583              	.LVL45:
 584              	.L22:
 585              	.LBB181:
 586              	.LBB182:
 661:../drivers/fsl_dspi.h **** }
 587              		.loc 3 661 0
 588 011e 2B6B     		ldr	r3, [r5, #48]
 589              	.LBE182:
 590              	.LBE181:
 247:../drivers/fsl_dspi_edma.c ****                      &s_dspiMasterEdmaPrivateHandle[instance]);
 591              		.loc 2 247 0
 592 0120 1C4A     		ldr	r2, .L141+12
 593 0122 1D49     		ldr	r1, .L141+16
 594              	.LVL46:
 595 0124 606B     		ldr	r0, [r4, #52]
 596              	.LVL47:
 597              	.LBB184:
 598              	.LBB183:
 661:../drivers/fsl_dspi.h **** }
 599              		.loc 3 661 0
 600 0126 23F04073 		bic	r3, r3, #50331648
 601 012a 23F44033 		bic	r3, r3, #196608
 602 012e 2B63     		str	r3, [r5, #48]
 603              	.LVL48:
 604              	.LBE183:
 605              	.LBE184:
 247:../drivers/fsl_dspi_edma.c ****                      &s_dspiMasterEdmaPrivateHandle[instance]);
 606              		.loc 2 247 0
 607 0130 02EBC802 		add	r2, r2, r8, lsl #3
 608 0134 FFF7FEFF 		bl	EDMA_SetCallback
 609              	.LVL49:
 275:../drivers/fsl_dspi_edma.c ****     {
 610              		.loc 2 275 0
 611 0138 154B     		ldr	r3, .L141+8
 612              	.LVL50:
 613 013a 9D42     		cmp	r5, r3
 614 013c 2368     		ldr	r3, [r4]
 615              	.LVL51:
 616 013e 40F0F681 		bne	.L23
 282:../drivers/fsl_dspi_edma.c ****         {
 617              		.loc 2 282 0
 618 0142 082B     		cmp	r3, #8
 619 0144 40F2E081 		bls	.L24
 285:../drivers/fsl_dspi_edma.c ****             {
 620              		.loc 2 285 0
 621 0148 A369     		ldr	r3, [r4, #24]
 622 014a 022B     		cmp	r3, #2
 287:../drivers/fsl_dspi_edma.c ****                 {
 623              		.loc 2 287 0
 624 014c 2369     		ldr	r3, [r4, #16]
 285:../drivers/fsl_dspi_edma.c ****             {
 625              		.loc 2 285 0
 626 014e 25D8     		bhi	.L25
 287:../drivers/fsl_dspi_edma.c ****                 {
 627              		.loc 2 287 0
 628 0150 B3B1     		cbz	r3, .L26
 289:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 629              		.loc 2 289 0
 630 0152 2369     		ldr	r3, [r4, #16]
 290:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 631              		.loc 2 290 0
 632 0154 2269     		ldr	r2, [r4, #16]
 289:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 633              		.loc 2 289 0
 634 0156 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 635              	.LVL52:
 290:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 636              		.loc 2 290 0
 637 0158 0132     		adds	r2, r2, #1
 638 015a 2261     		str	r2, [r4, #16]
 291:../drivers/fsl_dspi_edma.c ****                 }
 639              		.loc 2 291 0
 640 015c 2269     		ldr	r2, [r4, #16]
 641 015e 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 642 0160 43EA0222 		orr	r2, r3, r2, lsl #8
 643              	.LVL53:
 644              	.L27:
 297:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 645              		.loc 2 297 0
 646 0164 A368     		ldr	r3, [r4, #8]
 647 0166 1B0C     		lsrs	r3, r3, #16
 648 0168 1B04     		lsls	r3, r3, #16
 649              	.L138:
 330:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 650              		.loc 2 330 0
 651 016a 1343     		orrs	r3, r3, r2
 652 016c A360     		str	r3, [r4, #8]
 331:../drivers/fsl_dspi_edma.c ****             }
 653              		.loc 2 331 0
 654 016e A368     		ldr	r3, [r4, #8]
 655 0170 27E0     		b	.L128
 656              	.LVL54:
 657              	.L20:
 239:../drivers/fsl_dspi_edma.c ****     {
 658              		.loc 2 239 0
 659 0172 BB68     		ldr	r3, [r7, #8]
 660              	.LVL55:
 661 0174 DA07     		lsls	r2, r3, #31
 662 0176 D2D5     		bpl	.L22
 241:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 663              		.loc 2 241 0
 664 0178 0023     		movs	r3, #0
 665 017a E373     		strb	r3, [r4, #15]
 666              	.LVL56:
 667              	.L96:
 668              	.LBE213:
 669              	.LBE216:
 141:../drivers/fsl_dspi_edma.c ****     }
 670              		.loc 2 141 0
 671 017c 0420     		movs	r0, #4
 672 017e B7E7     		b	.L11
 673              	.LVL57:
 674              	.L26:
 675              	.LBB217:
 676              	.LBB214:
 295:../drivers/fsl_dspi_edma.c ****                 }
 677              		.loc 2 295 0
 678 0180 46EA0622 		orr	r2, r6, r6, lsl #8
 679              	.LVL58:
 680 0184 EEE7     		b	.L27
 681              	.L142:
 682 0186 00BF     		.align	2
 683              	.L141:
 684 0188 00000000 		.word	s_dummyData
 685 018c 00000ADA 		.word	-636878848
 686 0190 00C00240 		.word	1073922048
 687 0194 00000000 		.word	.LANCHOR0
 688 0198 00000000 		.word	EDMA_DspiMasterCallback
 689              	.LVL59:
 690              	.L25:
 302:../drivers/fsl_dspi_edma.c ****                 {
 691              		.loc 2 302 0
 692 019c 002B     		cmp	r3, #0
 693 019e 00F0AC81 		beq	.L29
 304:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 694              		.loc 2 304 0
 695 01a2 2369     		ldr	r3, [r4, #16]
 305:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 696              		.loc 2 305 0
 697 01a4 2269     		ldr	r2, [r4, #16]
 304:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 698              		.loc 2 304 0
 699 01a6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 700              	.LVL60:
 305:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 701              		.loc 2 305 0
 702 01a8 0132     		adds	r2, r2, #1
 703 01aa 2261     		str	r2, [r4, #16]
 306:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 704              		.loc 2 306 0
 705 01ac 2269     		ldr	r2, [r4, #16]
 706 01ae 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 707 01b0 43EA0222 		orr	r2, r3, r2, lsl #8
 708              	.LVL61:
 307:../drivers/fsl_dspi_edma.c ****                 }
 709              		.loc 2 307 0
 710 01b4 2369     		ldr	r3, [r4, #16]
 711 01b6 0133     		adds	r3, r3, #1
 712 01b8 2361     		str	r3, [r4, #16]
 713              	.L30:
 313:../drivers/fsl_dspi_edma.c ****             }
 714              		.loc 2 313 0
 715 01ba 6368     		ldr	r3, [r4, #4]
 716 01bc 1B0C     		lsrs	r3, r3, #16
 717 01be 1B04     		lsls	r3, r3, #16
 718              	.L129:
 719 01c0 1343     		orrs	r3, r3, r2
 720              	.L128:
 721 01c2 6360     		str	r3, [r4, #4]
 722              	.LVL62:
 723              	.L28:
 436:../drivers/fsl_dspi_edma.c **** 
 724              		.loc 2 436 0
 725 01c4 636B     		ldr	r3, [r4, #52]
 726 01c6 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 727 01c8 9868     		ldr	r0, [r3, #8]
 728 01ca FFF7FEFF 		bl	EDMA_ResetChannel
 729              	.LVL63:
 730              	.LBB185:
 731              	.LBB186:
 700:../drivers/fsl_dspi.h **** }
 732              		.loc 3 700 0
 733 01ce 05F13803 		add	r3, r5, #56
 734              	.LBE186:
 735              	.LBE185:
 438:../drivers/fsl_dspi_edma.c ****     transferConfigA.srcOffset = 0;
 736              		.loc 2 438 0
 737 01d2 0293     		str	r3, [sp, #8]
 439:../drivers/fsl_dspi_edma.c **** 
 738              		.loc 2 439 0
 739 01d4 0023     		movs	r3, #0
 740 01d6 ADF81230 		strh	r3, [sp, #18]	@ movhi
 441:../drivers/fsl_dspi_edma.c ****     {
 741              		.loc 2 441 0
 742 01da 6369     		ldr	r3, [r4, #20]
 743 01dc 002B     		cmp	r3, #0
 744 01de 00F01782 		beq	.L48
 443:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 1;
 745              		.loc 2 443 0
 746 01e2 6369     		ldr	r3, [r4, #20]
 747 01e4 0393     		str	r3, [sp, #12]
 444:../drivers/fsl_dspi_edma.c ****     }
 748              		.loc 2 444 0
 749 01e6 0123     		movs	r3, #1
 750              	.L130:
 449:../drivers/fsl_dspi_edma.c ****     }
 751              		.loc 2 449 0
 752 01e8 ADF81430 		strh	r3, [sp, #20]	@ movhi
 454:../drivers/fsl_dspi_edma.c ****     {
 753              		.loc 2 454 0
 754 01ec 2368     		ldr	r3, [r4]
 470:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 755              		.loc 2 470 0
 756 01ee 606B     		ldr	r0, [r4, #52]
 454:../drivers/fsl_dspi_edma.c ****     {
 757              		.loc 2 454 0
 758 01f0 082B     		cmp	r3, #8
 759 01f2 4FF00103 		mov	r3, #1
 462:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 2;
 760              		.loc 2 462 0
 761 01f6 81BF     		itttt	hi
 762 01f8 8DF81030 		strbhi	r3, [sp, #16]
 463:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
 763              		.loc 2 463 0
 764 01fc 0223     		movhi	r3, #2
 765 01fe 0693     		strhi	r3, [sp, #24]
 464:../drivers/fsl_dspi_edma.c ****     }
 766              		.loc 2 464 0
 767 0200 E369     		ldrhi	r3, [r4, #28]
 457:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
 768              		.loc 2 457 0
 769 0202 96BF     		itet	ls
 770 0204 0693     		strls	r3, [sp, #24]
 464:../drivers/fsl_dspi_edma.c ****     }
 771              		.loc 2 464 0
 772 0206 5B08     		lsrhi	r3, r3, #1
 458:../drivers/fsl_dspi_edma.c ****     }
 773              		.loc 2 458 0
 774 0208 E369     		ldrls	r3, [r4, #28]
 464:../drivers/fsl_dspi_edma.c ****     }
 775              		.loc 2 464 0
 776 020a 0793     		str	r3, [sp, #28]
 468:../drivers/fsl_dspi_edma.c **** 
 777              		.loc 2 468 0
 778 020c 069B     		ldr	r3, [sp, #24]
 779 020e A373     		strb	r3, [r4, #14]
 452:../drivers/fsl_dspi_edma.c **** 
 780              		.loc 2 452 0
 781 0210 4FF00002 		mov	r2, #0
 456:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 1;
 782              		.loc 2 456 0
 783 0214 98BF     		it	ls
 784 0216 8DF81020 		strbls	r2, [sp, #16]
 470:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 785              		.loc 2 470 0
 786 021a 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 452:../drivers/fsl_dspi_edma.c **** 
 787              		.loc 2 452 0
 788 021c 8DF81120 		strb	r2, [sp, #17]
 470:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 789              		.loc 2 470 0
 790 0220 0023     		movs	r3, #0
 791 0222 02AA     		add	r2, sp, #8
 792 0224 8068     		ldr	r0, [r0, #8]
 793 0226 FFF7FEFF 		bl	EDMA_SetTransferConfig
 794              	.LVL64:
 472:../drivers/fsl_dspi_edma.c ****                                  kEDMA_MajorInterruptEnable);
 795              		.loc 2 472 0
 796 022a 636B     		ldr	r3, [r4, #52]
 797 022c 0222     		movs	r2, #2
 798 022e 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 799 0230 9868     		ldr	r0, [r3, #8]
 800 0232 FFF7FEFF 		bl	EDMA_EnableChannelInterrupts
 801              	.LVL65:
 476:../drivers/fsl_dspi_edma.c ****         ((((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 802              		.loc 2 476 0
 803 0236 A369     		ldr	r3, [r4, #24]
 804 0238 13B1     		cbz	r3, .L52
 805 023a B14B     		ldr	r3, .L143
 806              	.LVL66:
 807 023c 9D42     		cmp	r5, r3
 808 023e 0ED1     		bne	.L53
 809              	.LVL67:
 810              	.L52:
 477:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 811              		.loc 2 477 0
 812 0240 A369     		ldr	r3, [r4, #24]
 476:../drivers/fsl_dspi_edma.c ****         ((((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 813              		.loc 2 476 0
 814 0242 012B     		cmp	r3, #1
 815 0244 02D9     		bls	.L54
 477:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 816              		.loc 2 477 0
 817 0246 2368     		ldr	r3, [r4]
 818 0248 082B     		cmp	r3, #8
 819 024a 05D9     		bls	.L55
 820              	.L54:
 478:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
 821              		.loc 2 478 0
 822 024c A369     		ldr	r3, [r4, #24]
 477:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 823              		.loc 2 477 0
 824 024e 022B     		cmp	r3, #2
 825 0250 1FD9     		bls	.L56
 478:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
 826              		.loc 2 478 0
 827 0252 2368     		ldr	r3, [r4]
 828 0254 082B     		cmp	r3, #8
 829 0256 1CD9     		bls	.L56
 830              	.L55:
 831 0258 A94B     		ldr	r3, .L143
 832              	.LVL68:
 833 025a 9D42     		cmp	r5, r3
 834 025c 19D1     		bne	.L56
 835              	.L53:
 481:../drivers/fsl_dspi_edma.c ****         {
 836              		.loc 2 481 0
 837 025e 2369     		ldr	r3, [r4, #16]
 838              	.LVL69:
 839 0260 2268     		ldr	r2, [r4]
 840 0262 002B     		cmp	r3, #0
 841 0264 00F0E481 		beq	.L57
 842              	.LVL70:
 843              	.LBB187:
 485:../drivers/fsl_dspi_edma.c ****             {
 844              		.loc 2 485 0
 845 0268 A54B     		ldr	r3, .L143
 846              	.LVL71:
 847 026a 9D42     		cmp	r5, r3
 489:../drivers/fsl_dspi_edma.c ****                 }
 848              		.loc 2 489 0
 849 026c A369     		ldr	r3, [r4, #24]
 850              	.LVL72:
 485:../drivers/fsl_dspi_edma.c ****             {
 851              		.loc 2 485 0
 852 026e 04D1     		bne	.L60
 487:../drivers/fsl_dspi_edma.c ****                 {
 853              		.loc 2 487 0
 854 0270 082A     		cmp	r2, #8
 489:../drivers/fsl_dspi_edma.c ****                 }
 855              		.loc 2 489 0
 856 0272 94BF     		ite	ls
 857 0274 03F1FF33 		addls	r3, r3, #-1
 858              	.LVL73:
 493:../drivers/fsl_dspi_edma.c ****                 }
 859              		.loc 2 493 0
 860 0278 023B     		subhi	r3, r3, #2
 861              	.LVL74:
 862              	.L60:
 501:../drivers/fsl_dspi_edma.c ****             {
 863              		.loc 2 501 0
 864 027a 082A     		cmp	r2, #8
 865 027c 03F1FF30 		add	r0, r3, #-1
 866 0280 A04E     		ldr	r6, .L143+4
 867              	.LVL75:
 868 0282 00F2C981 		bhi	.L61
 503:../drivers/fsl_dspi_edma.c ****             }
 869              		.loc 2 503 0
 870 0286 A368     		ldr	r3, [r4, #8]
 871 0288 2269     		ldr	r2, [r4, #16]
 872 028a 115C     		ldrb	r1, [r2, r0]	@ zero_extendqisi2
 873 028c 3340     		ands	r3, r3, r6
 874 028e 0B43     		orrs	r3, r3, r1
 875              	.L132:
 507:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 876              		.loc 2 507 0
 877 0290 A360     		str	r3, [r4, #8]
 878              	.L56:
 879              	.LBE187:
 671:../drivers/fsl_dspi_edma.c **** 
 880              		.loc 2 671 0
 881 0292 A36B     		ldr	r3, [r4, #56]
 882 0294 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 883 0296 9868     		ldr	r0, [r3, #8]
 884 0298 FFF7FEFF 		bl	EDMA_ResetChannel
 885              	.LVL76:
 675:../drivers/fsl_dspi_edma.c ****     {
 886              		.loc 2 675 0
 887 029c 984B     		ldr	r3, .L143
 888              	.LVL77:
 167:../drivers/fsl_dspi_edma.c **** 
 889              		.loc 2 167 0
 890 029e 04F16006 		add	r6, r4, #96
 675:../drivers/fsl_dspi_edma.c ****     {
 891              		.loc 2 675 0
 892 02a2 9D42     		cmp	r5, r3
 167:../drivers/fsl_dspi_edma.c **** 
 893              		.loc 2 167 0
 894 02a4 26F01F06 		bic	r6, r6, #31
 675:../drivers/fsl_dspi_edma.c ****     {
 895              		.loc 2 675 0
 896 02a8 1AD1     		bne	.L63
 677:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t) & (handle->command);
 897              		.loc 2 677 0
 898 02aa 04F10803 		add	r3, r4, #8
 899              	.LVL78:
 900 02ae 0893     		str	r3, [sp, #32]
 678:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize4Bytes;
 901              		.loc 2 678 0
 902 02b0 231D     		adds	r3, r4, #4
 903 02b2 0993     		str	r3, [sp, #36]
 679:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 904              		.loc 2 679 0
 905 02b4 0223     		movs	r3, #2
 681:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 906              		.loc 2 681 0
 907 02b6 0027     		movs	r7, #0
 684:../drivers/fsl_dspi_edma.c **** 
 908              		.loc 2 684 0
 909 02b8 0421     		movs	r1, #4
 679:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 910              		.loc 2 679 0
 911 02ba 8DF82830 		strb	r3, [sp, #40]
 680:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcOffset = 0;
 912              		.loc 2 680 0
 913 02be 8DF82930 		strb	r3, [sp, #41]
 686:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 914              		.loc 2 686 0
 915 02c2 3046     		mov	r0, r6
 684:../drivers/fsl_dspi_edma.c **** 
 916              		.loc 2 684 0
 917 02c4 0123     		movs	r3, #1
 918 02c6 CDE90C13 		strd	r1, r3, [sp, #48]
 681:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 919              		.loc 2 681 0
 920 02ca ADF82A70 		strh	r7, [sp, #42]	@ movhi
 682:../drivers/fsl_dspi_edma.c ****         transferConfigB.minorLoopBytes = 4;
 921              		.loc 2 682 0
 922 02ce ADF82C70 		strh	r7, [sp, #44]	@ movhi
 686:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 923              		.loc 2 686 0
 924 02d2 FFF7FEFF 		bl	EDMA_TcdReset
 925              	.LVL79:
 687:../drivers/fsl_dspi_edma.c ****     }
 926              		.loc 2 687 0
 927 02d6 3A46     		mov	r2, r7
 928 02d8 08A9     		add	r1, sp, #32
 929 02da 3046     		mov	r0, r6
 930 02dc FFF7FEFF 		bl	EDMA_TcdSetTransferConfig
 931              	.LVL80:
 932              	.L63:
 691:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8))) &&
 933              		.loc 2 691 0
 934 02e0 A369     		ldr	r3, [r4, #24]
 935 02e2 A06B     		ldr	r0, [r4, #56]
 936 02e4 022B     		cmp	r3, #2
 937 02e6 02D9     		bls	.L64
 938 02e8 2368     		ldr	r3, [r4]
 939 02ea 082B     		cmp	r3, #8
 940 02ec 09D9     		bls	.L65
 941              	.L64:
 692:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))) ||
 942              		.loc 2 692 0
 943 02ee A369     		ldr	r3, [r4, #24]
 691:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8))) &&
 944              		.loc 2 691 0
 945 02f0 042B     		cmp	r3, #4
 946 02f2 02D9     		bls	.L66
 692:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))) ||
 947              		.loc 2 692 0
 948 02f4 2368     		ldr	r3, [r4]
 949 02f6 082B     		cmp	r3, #8
 950 02f8 03D8     		bhi	.L65
 951              	.L66:
 693:../drivers/fsl_dspi_edma.c ****         (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 952              		.loc 2 693 0
 953 02fa 814B     		ldr	r3, .L143
 954              	.LVL81:
 955 02fc 9D42     		cmp	r5, r3
 956 02fe 00F0A981 		beq	.L67
 957              	.LVL82:
 958              	.L65:
 696:../drivers/fsl_dspi_edma.c ****         {
 959              		.loc 2 696 0
 960 0302 2369     		ldr	r3, [r4, #16]
 961 0304 002B     		cmp	r3, #0
 962 0306 00F09F81 		beq	.L68
 698:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 1;
 963              		.loc 2 698 0
 964 030a 2369     		ldr	r3, [r4, #16]
 965 030c 0893     		str	r3, [sp, #32]
 699:../drivers/fsl_dspi_edma.c ****         }
 966              		.loc 2 699 0
 967 030e 0123     		movs	r3, #1
 968              	.L133:
 712:../drivers/fsl_dspi_edma.c ****         {
 969              		.loc 2 712 0
 970 0310 2268     		ldr	r2, [r4]
 704:../drivers/fsl_dspi_edma.c ****         }
 971              		.loc 2 704 0
 972 0312 ADF82A30 		strh	r3, [sp, #42]	@ movhi
 707:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 973              		.loc 2 707 0
 974 0316 231D     		adds	r3, r4, #4
 712:../drivers/fsl_dspi_edma.c ****         {
 975              		.loc 2 712 0
 976 0318 082A     		cmp	r2, #8
 707:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 977              		.loc 2 707 0
 978 031a 0993     		str	r3, [sp, #36]
 708:../drivers/fsl_dspi_edma.c **** 
 979              		.loc 2 708 0
 980 031c 4FF00003 		mov	r3, #0
 981 0320 ADF82C30 		strh	r3, [sp, #44]	@ movhi
 710:../drivers/fsl_dspi_edma.c **** 
 982              		.loc 2 710 0
 983 0324 8DF82830 		strb	r3, [sp, #40]
 731:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 984              		.loc 2 731 0
 985 0328 84BF     		itt	hi
 986 032a 0223     		movhi	r3, #2
 987 032c 0C93     		strhi	r3, [sp, #48]
 988 032e 744A     		ldr	r2, .L143
 989              	.LVL83:
 734:../drivers/fsl_dspi_edma.c ****             }
 990              		.loc 2 734 0
 991 0330 8CBF     		ite	hi
 992 0332 A369     		ldrhi	r3, [r4, #24]
 714:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 1;
 993              		.loc 2 714 0
 994 0334 8DF82930 		strbls	r3, [sp, #41]
 995 0338 4FF00101 		mov	r1, #1
 715:../drivers/fsl_dspi_edma.c **** 
 996              		.loc 2 715 0
 997 033c 99BF     		ittee	ls
 998 033e 0C91     		strls	r1, [sp, #48]
 719:../drivers/fsl_dspi_edma.c ****             }
 999              		.loc 2 719 0
 1000 0340 A369     		ldrls	r3, [r4, #24]
 730:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 2;
 1001              		.loc 2 730 0
 1002 0342 8DF82910 		strbhi	r1, [sp, #41]
 734:../drivers/fsl_dspi_edma.c ****             }
 1003              		.loc 2 734 0
 1004 0346 5B08     		lsrhi	r3, r3, #1
 732:../drivers/fsl_dspi_edma.c ****             {
 1005              		.loc 2 732 0
 1006 0348 9542     		cmp	r5, r2
 1007 034a 40F08181 		bne	.L74
 734:../drivers/fsl_dspi_edma.c ****             }
 1008              		.loc 2 734 0
 1009 034e 023B     		subs	r3, r3, #2
 1010 0350 0D93     		str	r3, [sp, #52]
 746:../drivers/fsl_dspi_edma.c ****                                    handle->edmaTxDataToIntermediaryHandle->channel, &transferConfig
 1011              		.loc 2 746 0
 1012 0352 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1013 0354 8068     		ldr	r0, [r0, #8]
 1014 0356 3346     		mov	r3, r6
 1015 0358 08AA     		add	r2, sp, #32
 1016              	.LVL84:
 1017 035a FFF7FEFF 		bl	EDMA_SetTransferConfig
 1018              	.LVL85:
 748:../drivers/fsl_dspi_edma.c ****                                        handle->edmaIntermediaryToTxRegHandle->channel, false);
 1019              		.loc 2 748 0
 1020 035e E36B     		ldr	r3, [r4, #60]
 1021 0360 9A68     		ldr	r2, [r3, #8]
 1022 0362 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1023              	.LVL86:
 1024              	.LBB188:
 1025              	.LBB189:
 407:../drivers/fsl_edma.h **** 
 408:../drivers/fsl_edma.h **** /*!
 409:../drivers/fsl_edma.h ****  * @brief Sets the channel link for the eDMA transfer.
 410:../drivers/fsl_edma.h ****  *
 411:../drivers/fsl_edma.h ****  * This function configures either the minor link or the major link mode. The minor link means that
 412:../drivers/fsl_edma.h ****  * triggered every time CITER decreases by 1. The major link means that the channel link is trigger
 413:../drivers/fsl_edma.h ****  * exhausted.
 414:../drivers/fsl_edma.h ****  *
 415:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 416:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 417:../drivers/fsl_edma.h ****  * @param type A channel link type, which can be one of the following:
 418:../drivers/fsl_edma.h ****  *   @arg kEDMA_LinkNone
 419:../drivers/fsl_edma.h ****  *   @arg kEDMA_MinorLink
 420:../drivers/fsl_edma.h ****  *   @arg kEDMA_MajorLink
 421:../drivers/fsl_edma.h ****  * @param linkedChannel The linked channel number.
 422:../drivers/fsl_edma.h ****  * @note Users should ensure that DONE flag is cleared before calling this interface, or the config
 423:../drivers/fsl_edma.h ****  */
 424:../drivers/fsl_edma.h **** void EDMA_SetChannelLink(DMA_Type *base, uint32_t channel, edma_channel_link_type_t type, uint32_t 
 425:../drivers/fsl_edma.h **** 
 426:../drivers/fsl_edma.h **** /*!
 427:../drivers/fsl_edma.h ****  * @brief Sets the bandwidth for the eDMA transfer.
 428:../drivers/fsl_edma.h ****  *
 429:../drivers/fsl_edma.h ****  * Because the eDMA processes the minor loop, it continuously generates read/write sequences
 430:../drivers/fsl_edma.h ****  * until the minor count is exhausted. The bandwidth forces the eDMA to stall after the completion 
 431:../drivers/fsl_edma.h ****  * each read/write access to control the bus request bandwidth seen by the crossbar switch.
 432:../drivers/fsl_edma.h ****  *
 433:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 434:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 435:../drivers/fsl_edma.h ****  * @param bandWidth A bandwidth setting, which can be one of the following:
 436:../drivers/fsl_edma.h ****  *     @arg kEDMABandwidthStallNone
 437:../drivers/fsl_edma.h ****  *     @arg kEDMABandwidthStall4Cycle
 438:../drivers/fsl_edma.h ****  *     @arg kEDMABandwidthStall8Cycle
 439:../drivers/fsl_edma.h ****  */
 440:../drivers/fsl_edma.h **** void EDMA_SetBandWidth(DMA_Type *base, uint32_t channel, edma_bandwidth_t bandWidth);
 441:../drivers/fsl_edma.h **** 
 442:../drivers/fsl_edma.h **** /*!
 443:../drivers/fsl_edma.h ****  * @brief Sets the source modulo and the destination modulo for the eDMA transfer.
 444:../drivers/fsl_edma.h ****  *
 445:../drivers/fsl_edma.h ****  * This function defines a specific address range specified to be the value after (SADDR + SOFF)/(D
 446:../drivers/fsl_edma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 447:../drivers/fsl_edma.h ****  * queue easily.
 448:../drivers/fsl_edma.h ****  *
 449:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 450:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 451:../drivers/fsl_edma.h ****  * @param srcModulo A source modulo value.
 452:../drivers/fsl_edma.h ****  * @param destModulo A destination modulo value.
 453:../drivers/fsl_edma.h ****  */
 454:../drivers/fsl_edma.h **** void EDMA_SetModulo(DMA_Type *base, uint32_t channel, edma_modulo_t srcModulo, edma_modulo_t destMo
 455:../drivers/fsl_edma.h **** 
 456:../drivers/fsl_edma.h **** #if defined(FSL_FEATURE_EDMA_ASYNCHRO_REQUEST_CHANNEL_COUNT) && FSL_FEATURE_EDMA_ASYNCHRO_REQUEST_C
 457:../drivers/fsl_edma.h **** /*!
 458:../drivers/fsl_edma.h ****  * @brief Enables an async request for the eDMA transfer.
 459:../drivers/fsl_edma.h ****  *
 460:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 461:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 462:../drivers/fsl_edma.h ****  * @param enable The command to enable (true) or disable (false).
 463:../drivers/fsl_edma.h ****  */
 464:../drivers/fsl_edma.h **** static inline void EDMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 465:../drivers/fsl_edma.h **** {
 466:../drivers/fsl_edma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 467:../drivers/fsl_edma.h **** 
 468:../drivers/fsl_edma.h ****     base->EARS = (base->EARS & (~(1U << channel))) | ((uint32_t)enable << channel);
 469:../drivers/fsl_edma.h **** }
 470:../drivers/fsl_edma.h **** #endif /* FSL_FEATURE_EDMA_ASYNCHRO_REQUEST_CHANNEL_COUNT */
 471:../drivers/fsl_edma.h **** 
 472:../drivers/fsl_edma.h **** /*!
 473:../drivers/fsl_edma.h ****  * @brief Enables an auto stop request for the eDMA transfer.
 474:../drivers/fsl_edma.h ****  *
 475:../drivers/fsl_edma.h ****  * If enabling the auto stop request, the eDMA hardware automatically disables the hardware channel
 476:../drivers/fsl_edma.h ****  *
 477:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 478:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 479:../drivers/fsl_edma.h ****  * @param enable The command to enable (true) or disable (false).
 480:../drivers/fsl_edma.h ****  */
 481:../drivers/fsl_edma.h **** static inline void EDMA_EnableAutoStopRequest(DMA_Type *base, uint32_t channel, bool enable)
 482:../drivers/fsl_edma.h **** {
 483:../drivers/fsl_edma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 484:../drivers/fsl_edma.h **** 
 485:../drivers/fsl_edma.h ****     base->TCD[channel].CSR = (base->TCD[channel].CSR & (~DMA_CSR_DREQ_MASK)) | DMA_CSR_DREQ(enable)
 1026              		.loc 1 485 0
 1027 0364 41F21C01 		movw	r1, #4124
 1028 0368 02EB4312 		add	r2, r2, r3, lsl #5
 1029              	.LVL87:
 1030 036c 535A     		ldrh	r3, [r2, r1]
 1031              	.LVL88:
 1032 036e 23F00803 		bic	r3, r3, #8
 1033 0372 1B04     		lsls	r3, r3, #16
 1034 0374 1B0C     		lsrs	r3, r3, #16
 1035 0376 5352     		strh	r3, [r2, r1]	@ movhi
 1036              	.LVL89:
 1037              	.L93:
 1038              	.LBE189:
 1039              	.LBE188:
 767:../drivers/fsl_dspi_edma.c **** 
 1040              		.loc 2 767 0
 1041 0378 E36B     		ldr	r3, [r4, #60]
 1042 037a 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1043 037c 9868     		ldr	r0, [r3, #8]
 1044 037e FFF7FEFF 		bl	EDMA_ResetChannel
 1045              	.LVL90:
 771:../drivers/fsl_dspi_edma.c ****     {
 1046              		.loc 2 771 0
 1047 0382 5F4B     		ldr	r3, .L143
 1048              	.LVL91:
 1049 0384 9D42     		cmp	r5, r3
 1050              	.LBB190:
 1051              	.LBB191:
 674:../drivers/fsl_dspi.h **** }
 1052              		.loc 3 674 0
 1053 0386 05F13408 		add	r8, r5, #52
 1054              	.LVL92:
 1055              	.LBE191:
 1056              	.LBE190:
 771:../drivers/fsl_dspi_edma.c ****     {
 1057              		.loc 2 771 0
 1058 038a 1BD0     		beq	.L75
 1059 038c A369     		ldr	r3, [r4, #24]
 1060              	.LVL93:
 1061 038e CBB1     		cbz	r3, .L75
 773:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 1062              		.loc 2 773 0
 1063 0390 04F10803 		add	r3, r4, #8
 774:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize4Bytes;
 1064              		.loc 2 774 0
 1065 0394 CDE90E38 		strd	r3, r8, [sp, #56]
 775:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 1066              		.loc 2 775 0
 1067 0398 0223     		movs	r3, #2
 777:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1068              		.loc 2 777 0
 1069 039a 0027     		movs	r7, #0
 780:../drivers/fsl_dspi_edma.c **** 
 1070              		.loc 2 780 0
 1071 039c 0422     		movs	r2, #4
 775:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 1072              		.loc 2 775 0
 1073 039e 8DF84030 		strb	r3, [sp, #64]
 776:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 1074              		.loc 2 776 0
 1075 03a2 8DF84130 		strb	r3, [sp, #65]
 782:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigC, NULL);
 1076              		.loc 2 782 0
 1077 03a6 3046     		mov	r0, r6
 780:../drivers/fsl_dspi_edma.c **** 
 1078              		.loc 2 780 0
 1079 03a8 0123     		movs	r3, #1
 1080 03aa CDE91223 		strd	r2, r3, [sp, #72]
 777:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1081              		.loc 2 777 0
 1082 03ae ADF84270 		strh	r7, [sp, #66]	@ movhi
 778:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 1083              		.loc 2 778 0
 1084 03b2 ADF84470 		strh	r7, [sp, #68]	@ movhi
 782:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigC, NULL);
 1085              		.loc 2 782 0
 1086 03b6 FFF7FEFF 		bl	EDMA_TcdReset
 1087              	.LVL94:
 783:../drivers/fsl_dspi_edma.c ****     }
 1088              		.loc 2 783 0
 1089 03ba 3A46     		mov	r2, r7
 1090 03bc 0EA9     		add	r1, sp, #56
 1091 03be 3046     		mov	r0, r6
 1092 03c0 FFF7FEFF 		bl	EDMA_TcdSetTransferConfig
 1093              	.LVL95:
 1094              	.L75:
 786:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8)) ||
 1095              		.loc 2 786 0
 1096 03c4 A369     		ldr	r3, [r4, #24]
 1097 03c6 E76B     		ldr	r7, [r4, #60]
 1098 03c8 012B     		cmp	r3, #1
 1099 03ca 02D9     		bls	.L76
 1100 03cc 2368     		ldr	r3, [r4]
 1101 03ce 082B     		cmp	r3, #8
 1102 03d0 09D9     		bls	.L77
 1103              	.L76:
 787:../drivers/fsl_dspi_edma.c ****         (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 1104              		.loc 2 787 0
 1105 03d2 A369     		ldr	r3, [r4, #24]
 786:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8)) ||
 1106              		.loc 2 786 0
 1107 03d4 022B     		cmp	r3, #2
 1108 03d6 02D9     		bls	.L78
 787:../drivers/fsl_dspi_edma.c ****         (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 1109              		.loc 2 787 0
 1110 03d8 2368     		ldr	r3, [r4]
 1111 03da 082B     		cmp	r3, #8
 1112 03dc 03D8     		bhi	.L77
 1113              	.L78:
 1114 03de 484B     		ldr	r3, .L143
 1115              	.LVL96:
 1116 03e0 9D42     		cmp	r5, r3
 1117 03e2 40F04181 		bne	.L79
 1118              	.LVL97:
 1119              	.L77:
 797:../drivers/fsl_dspi_edma.c ****         if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 1120              		.loc 2 797 0
 1121 03e6 0422     		movs	r2, #4
 790:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 1122              		.loc 2 790 0
 1123 03e8 231D     		adds	r3, r4, #4
 797:../drivers/fsl_dspi_edma.c ****         if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 1124              		.loc 2 797 0
 1125 03ea 1292     		str	r2, [sp, #72]
 798:../drivers/fsl_dspi_edma.c ****         {
 1126              		.loc 2 798 0
 1127 03ec 444A     		ldr	r2, .L143
 1128              	.LVL98:
 1129 03ee B868     		ldr	r0, [r7, #8]
 1130 03f0 397C     		ldrb	r1, [r7, #16]	@ zero_extendqisi2
 791:../drivers/fsl_dspi_edma.c **** 
 1131              		.loc 2 791 0
 1132 03f2 CDE90E38 		strd	r3, r8, [sp, #56]
 793:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 1133              		.loc 2 793 0
 1134 03f6 0223     		movs	r3, #2
 1135 03f8 8DF84030 		strb	r3, [sp, #64]
 794:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 1136              		.loc 2 794 0
 1137 03fc 8DF84130 		strb	r3, [sp, #65]
 798:../drivers/fsl_dspi_edma.c ****         {
 1138              		.loc 2 798 0
 1139 0400 9542     		cmp	r5, r2
 795:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1140              		.loc 2 795 0
 1141 0402 4FF00003 		mov	r3, #0
 1142 0406 ADF84230 		strh	r3, [sp, #66]	@ movhi
 796:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 1143              		.loc 2 796 0
 1144 040a ADF84430 		strh	r3, [sp, #68]	@ movhi
 798:../drivers/fsl_dspi_edma.c ****         {
 1145              		.loc 2 798 0
 1146 040e 00F02881 		beq	.L80
 800:../drivers/fsl_dspi_edma.c ****             {
 1147              		.loc 2 800 0
 1148 0412 2368     		ldr	r3, [r4]
 1149 0414 082B     		cmp	r3, #8
 802:../drivers/fsl_dspi_edma.c ****             }
 1150              		.loc 2 802 0
 1151 0416 A369     		ldr	r3, [r4, #24]
 806:../drivers/fsl_dspi_edma.c ****             }
 1152              		.loc 2 806 0
 1153 0418 88BF     		it	hi
 1154 041a 5B08     		lsrhi	r3, r3, #1
 1155 041c 013B     		subs	r3, r3, #1
 1156 041e 1393     		str	r3, [sp, #76]
 809:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 1157              		.loc 2 809 0
 1158 0420 3346     		mov	r3, r6
 1159              	.LVL99:
 1160              	.L135:
 816:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 1161              		.loc 2 816 0
 1162 0422 0EAA     		add	r2, sp, #56
 1163 0424 FFF7FEFF 		bl	EDMA_SetTransferConfig
 1164              	.LVL100:
 820:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, false);
 1165              		.loc 2 820 0
 1166 0428 E36B     		ldr	r3, [r4, #60]
 1167 042a 9A68     		ldr	r2, [r3, #8]
 1168 042c 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1169              	.LVL101:
 1170              	.LBB192:
 1171              	.LBB193:
 1172              		.loc 1 485 0
 1173 042e 41F21C01 		movw	r1, #4124
 1174 0432 02EB4312 		add	r2, r2, r3, lsl #5
 1175              	.LVL102:
 1176 0436 535A     		ldrh	r3, [r2, r1]
 1177              	.LVL103:
 1178 0438 23F00803 		bic	r3, r3, #8
 1179 043c 1B04     		lsls	r3, r3, #16
 1180 043e 1B0C     		lsrs	r3, r3, #16
 1181 0440 5352     		strh	r3, [r2, r1]	@ movhi
 1182              	.LVL104:
 1183              	.L84:
 1184              	.LBE193:
 1185              	.LBE192:
 830:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaTxDataToIntermediaryHandle);
 1186              		.loc 2 830 0
 1187 0442 606B     		ldr	r0, [r4, #52]
 1188 0444 FFF7FEFF 		bl	EDMA_StartTransfer
 1189              	.LVL105:
 831:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaIntermediaryToTxRegHandle);
 1190              		.loc 2 831 0
 1191 0448 A06B     		ldr	r0, [r4, #56]
 1192 044a FFF7FEFF 		bl	EDMA_StartTransfer
 1193              	.LVL106:
 832:../drivers/fsl_dspi_edma.c **** 
 1194              		.loc 2 832 0
 1195 044e E06B     		ldr	r0, [r4, #60]
 1196 0450 FFF7FEFF 		bl	EDMA_StartTransfer
 1197              	.LVL107:
 835:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityMid = handle->edmaTxDataToIntermediaryHandle->channel;
 1198              		.loc 2 835 0
 1199 0454 D4F834C0 		ldr	ip, [r4, #52]
 836:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 1200              		.loc 2 836 0
 1201 0458 A26B     		ldr	r2, [r4, #56]
 835:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityMid = handle->edmaTxDataToIntermediaryHandle->channel;
 1202              		.loc 2 835 0
 1203 045a 9CF81030 		ldrb	r3, [ip, #16]	@ zero_extendqisi2
 1204              	.LVL108:
 836:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 1205              		.loc 2 836 0
 1206 045e 167C     		ldrb	r6, [r2, #16]	@ zero_extendqisi2
 1207              	.LVL109:
 837:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 1208              		.loc 2 837 0
 1209 0460 D4F83CE0 		ldr	lr, [r4, #60]
 839:../drivers/fsl_dspi_edma.c ****     {
 1210              		.loc 2 839 0
 1211 0464 B342     		cmp	r3, r6
 837:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 1212              		.loc 2 837 0
 1213 0466 9EF81010 		ldrb	r1, [lr, #16]	@ zero_extendqisi2
 1214              	.LVL110:
 839:../drivers/fsl_dspi_edma.c ****     {
 1215              		.loc 2 839 0
 1216 046a 00F23981 		bhi	.L85
 846:../drivers/fsl_dspi_edma.c ****     {
 1217              		.loc 2 846 0
 1218 046e 8B42     		cmp	r3, r1
 1219 0470 00F20181 		bhi	.L105
 1220 0474 3046     		mov	r0, r6
 1221 0476 1E46     		mov	r6, r3
 1222              	.LVL111:
 1223              	.L94:
 837:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 1224              		.loc 2 837 0
 1225 0478 3246     		mov	r2, r6
 1226 047a 0F46     		mov	r7, r1
 1227 047c 0646     		mov	r6, r0
 1228              	.L86:
 1229              	.LVL112:
 853:../drivers/fsl_dspi_edma.c ****     {
 1230              		.loc 2 853 0
 1231 047e B742     		cmp	r7, r6
 1232 0480 02D2     		bcs	.L87
 1233 0482 3046     		mov	r0, r6
 1234 0484 3E46     		mov	r6, r7
 1235 0486 0746     		mov	r7, r0
 1236              	.LVL113:
 1237              	.L87:
 862:../drivers/fsl_dspi_edma.c **** 
 1238              		.loc 2 862 0
 1239 0488 8DF80620 		strb	r2, [sp, #6]
 864:../drivers/fsl_dspi_edma.c ****     {
 1240              		.loc 2 864 0
 1241 048c 1C4A     		ldr	r2, .L143
 1242              	.LVL114:
 860:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 1243              		.loc 2 860 0
 1244 048e 4FF00108 		mov	r8, #1
 864:../drivers/fsl_dspi_edma.c ****     {
 1245              		.loc 2 864 0
 1246 0492 9542     		cmp	r5, r2
 860:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 1247              		.loc 2 860 0
 1248 0494 8DF80480 		strb	r8, [sp, #4]
 861:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
 1249              		.loc 2 861 0
 1250 0498 8DF80580 		strb	r8, [sp, #5]
 866:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1251              		.loc 2 866 0
 1252 049c 01AA     		add	r2, sp, #4
 1253              	.LVL115:
 864:../drivers/fsl_dspi_edma.c ****     {
 1254              		.loc 2 864 0
 1255 049e 00F0F080 		beq	.L88
 866:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1256              		.loc 2 866 0
 1257 04a2 DCF80800 		ldr	r0, [ip, #8]
 1258 04a6 1946     		mov	r1, r3
 1259 04a8 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1260              	.LVL116:
 870:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1261              		.loc 2 870 0
 1262 04ac A36B     		ldr	r3, [r4, #56]
 869:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 1263              		.loc 2 869 0
 1264 04ae 8DF80660 		strb	r6, [sp, #6]
 870:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1265              		.loc 2 870 0
 1266 04b2 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1267 04b4 9868     		ldr	r0, [r3, #8]
 1268 04b6 01AA     		add	r2, sp, #4
 1269 04b8 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1270              	.LVL117:
 874:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 1271              		.loc 2 874 0
 1272 04bc E36B     		ldr	r3, [r4, #60]
 873:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 1273              		.loc 2 873 0
 1274 04be 8DF80670 		strb	r7, [sp, #6]
 874:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 1275              		.loc 2 874 0
 1276 04c2 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1277 04c4 9868     		ldr	r0, [r3, #8]
 1278 04c6 01AA     		add	r2, sp, #4
 1279 04c8 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1280              	.LVL118:
 907:../drivers/fsl_dspi_edma.c ****         {
 1281              		.loc 2 907 0
 1282 04cc A369     		ldr	r3, [r4, #24]
 1283 04ce 7BB1     		cbz	r3, .L90
 910:../drivers/fsl_dspi_edma.c **** 
 1284              		.loc 2 910 0
 1285 04d0 D4E90D03 		ldrd	r0, r3, [r4, #52]
 909:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToIntermediaryHandle->channel);
 1286              		.loc 2 909 0
 1287 04d4 4246     		mov	r2, r8
 1288 04d6 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1289 04d8 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1290 04da 8068     		ldr	r0, [r0, #8]
 1291 04dc FFF7FEFF 		bl	EDMA_SetChannelLink
 1292              	.LVL119:
 914:../drivers/fsl_dspi_edma.c ****         }
 1293              		.loc 2 914 0
 1294 04e0 D4E90E03 		ldrd	r0, r3, [r4, #56]
 912:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel, kEDMA_MinorLink,
 1295              		.loc 2 912 0
 1296 04e4 4246     		mov	r2, r8
 1297 04e6 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1298 04e8 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1299 04ea 8068     		ldr	r0, [r0, #8]
 1300 04ec FFF7FEFF 		bl	EDMA_SetChannelLink
 1301              	.LVL120:
 1302              	.L90:
 1303              	.LBB194:
 1304              	.LBB195:
 645:../drivers/fsl_dspi.h **** }
 1305              		.loc 3 645 0
 1306 04f0 2B6B     		ldr	r3, [r5, #48]
 1307 04f2 43F44033 		orr	r3, r3, #196608
 1308 04f6 2B63     		str	r3, [r5, #48]
 1309 04f8 E9E0     		b	.L92
 1310              	.LVL121:
 1311              	.L29:
 1312              	.LBE195:
 1313              	.LBE194:
 311:../drivers/fsl_dspi_edma.c ****                 }
 1314              		.loc 2 311 0
 1315 04fa 46EA0622 		orr	r2, r6, r6, lsl #8
 1316              	.LVL122:
 1317 04fe 5CE6     		b	.L30
 1318              	.L144:
 1319              		.align	2
 1320              	.L143:
 1321 0500 00C00240 		.word	1073922048
 1322 0504 0000FFFF 		.word	-65536
 1323              	.LVL123:
 1324              	.L24:
 318:../drivers/fsl_dspi_edma.c ****             {
 1325              		.loc 2 318 0
 1326 0508 2369     		ldr	r3, [r4, #16]
 1327 050a 5BB1     		cbz	r3, .L31
 320:../drivers/fsl_dspi_edma.c ****                 ++handle->txData; /* increment to next data word*/
 1328              		.loc 2 320 0
 1329 050c 2369     		ldr	r3, [r4, #16]
 1330 050e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1331              	.LVL124:
 321:../drivers/fsl_dspi_edma.c ****             }
 1332              		.loc 2 321 0
 1333 0510 2369     		ldr	r3, [r4, #16]
 1334 0512 0133     		adds	r3, r3, #1
 1335 0514 2361     		str	r3, [r4, #16]
 1336              	.L32:
 328:../drivers/fsl_dspi_edma.c ****             {
 1337              		.loc 2 328 0
 1338 0516 A369     		ldr	r3, [r4, #24]
 1339 0518 7349     		ldr	r1, .L145
 1340 051a 012B     		cmp	r3, #1
 1341 051c 04D1     		bne	.L33
 330:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 1342              		.loc 2 330 0
 1343 051e A368     		ldr	r3, [r4, #8]
 1344 0520 0B40     		ands	r3, r3, r1
 1345 0522 22E6     		b	.L138
 1346              	.LVL125:
 1347              	.L31:
 325:../drivers/fsl_dspi_edma.c ****             }
 1348              		.loc 2 325 0
 1349 0524 B2B2     		uxth	r2, r6
 1350              	.LVL126:
 1351 0526 F6E7     		b	.L32
 1352              	.L33:
 335:../drivers/fsl_dspi_edma.c ****             }
 1353              		.loc 2 335 0
 1354 0528 6368     		ldr	r3, [r4, #4]
 1355 052a 0B40     		ands	r3, r3, r1
 1356 052c 48E6     		b	.L129
 1357              	.LVL127:
 1358              	.L23:
 347:../drivers/fsl_dspi_edma.c ****         {
 1359              		.loc 2 347 0
 1360 052e 082B     		cmp	r3, #8
 1361 0530 68D9     		bls	.L102
 381:../drivers/fsl_dspi_edma.c ****                 }
 1362              		.loc 2 381 0
 1363 0532 6D48     		ldr	r0, .L145
 378:../drivers/fsl_dspi_edma.c ****                     }
 1364              		.loc 2 378 0
 1365 0534 46EA0621 		orr	r1, r6, r6, lsl #8
 1366 0538 0222     		movs	r2, #2
 363:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 1367              		.loc 2 363 0
 1368 053a 0027     		movs	r7, #0
 1369              	.LVL128:
 1370              	.LBB196:
 1371              	.LBB197:
 580:../drivers/fsl_dspi.h **** }
 1372              		.loc 3 580 0
 1373 053c 4FF0007C 		mov	ip, #33554432
 1374              	.LVL129:
 1375              	.L35:
 1376              	.LBE197:
 1377              	.LBE196:
 1378              	.LBB199:
 1379              	.LBB200:
 561:../drivers/fsl_dspi.h **** }
 1380              		.loc 3 561 0
 1381 0540 EB6A     		ldr	r3, [r5, #44]
 1382              	.LVL130:
 1383              	.LBE200:
 1384              	.LBE199:
 349:../drivers/fsl_dspi_edma.c ****             {
 1385              		.loc 2 349 0
 1386 0542 9B01     		lsls	r3, r3, #6
 1387 0544 7FF53EAE 		bpl	.L28
 351:../drivers/fsl_dspi_edma.c ****                 {
 1388              		.loc 2 351 0
 1389 0548 A369     		ldr	r3, [r4, #24]
 1390 054a 022B     		cmp	r3, #2
 353:../drivers/fsl_dspi_edma.c ****                     {
 1391              		.loc 2 353 0
 1392 054c 2369     		ldr	r3, [r4, #16]
 351:../drivers/fsl_dspi_edma.c ****                 {
 1393              		.loc 2 351 0
 1394 054e 21D8     		bhi	.L36
 353:../drivers/fsl_dspi_edma.c ****                     {
 1395              		.loc 2 353 0
 1396 0550 F3B1     		cbz	r3, .L103
 355:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1397              		.loc 2 355 0
 1398 0552 2369     		ldr	r3, [r4, #16]
 356:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 1399              		.loc 2 356 0
 1400 0554 D4F810E0 		ldr	lr, [r4, #16]
 355:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1401              		.loc 2 355 0
 1402 0558 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1403              	.LVL131:
 356:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 1404              		.loc 2 356 0
 1405 055a 0EF1010E 		add	lr, lr, #1
 1406 055e C4F810E0 		str	lr, [r4, #16]
 357:../drivers/fsl_dspi_edma.c ****                     }
 1407              		.loc 2 357 0
 1408 0562 D4F810E0 		ldr	lr, [r4, #16]
 1409 0566 9EF800E0 		ldrb	lr, [lr]	@ zero_extendqisi2
 1410 056a 43EA0E2E 		orr	lr, r3, lr, lsl #8
 1411              	.LVL132:
 1412              	.L37:
 363:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 1413              		.loc 2 363 0
 1414 056e A761     		str	r7, [r4, #24]
 364:../drivers/fsl_dspi_edma.c ****                 }
 1415              		.loc 2 364 0
 1416 0570 A368     		ldr	r3, [r4, #8]
 1417              	.L126:
 381:../drivers/fsl_dspi_edma.c ****                 }
 1418              		.loc 2 381 0
 1419 0572 0340     		ands	r3, r3, r0
 1420 0574 43EA0E03 		orr	r3, r3, lr
 1421 0578 6B63     		str	r3, [r5, #52]
 1422              	.LVL133:
 1423              	.LBB201:
 1424              	.LBB198:
 580:../drivers/fsl_dspi.h **** }
 1425              		.loc 3 580 0
 1426 057a C5F82CC0 		str	ip, [r5, #44]
 1427              	.LVL134:
 1428              	.LBE198:
 1429              	.LBE201:
 390:../drivers/fsl_dspi_edma.c ****                 {
 1430              		.loc 2 390 0
 1431 057e A369     		ldr	r3, [r4, #24]
 1432 0580 002B     		cmp	r3, #0
 1433 0582 3FF41FAE 		beq	.L28
 1434 0586 012A     		cmp	r2, #1
 1435 0588 3FF41CAE 		beq	.L28
 1436 058c 0122     		movs	r2, #1
 1437              	.LVL135:
 1438 058e D7E7     		b	.L35
 1439              	.LVL136:
 1440              	.L103:
 361:../drivers/fsl_dspi_edma.c ****                     }
 1441              		.loc 2 361 0
 1442 0590 8E46     		mov	lr, r1
 1443 0592 ECE7     		b	.L37
 1444              	.L36:
 369:../drivers/fsl_dspi_edma.c ****                     {
 1445              		.loc 2 369 0
 1446 0594 8BB1     		cbz	r3, .L104
 371:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1447              		.loc 2 371 0
 1448 0596 2369     		ldr	r3, [r4, #16]
 1449 0598 93F800E0 		ldrb	lr, [r3]	@ zero_extendqisi2
 1450              	.LVL137:
 372:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 1451              		.loc 2 372 0
 1452 059c 2369     		ldr	r3, [r4, #16]
 1453 059e 0133     		adds	r3, r3, #1
 1454 05a0 2361     		str	r3, [r4, #16]
 373:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1455              		.loc 2 373 0
 1456 05a2 2369     		ldr	r3, [r4, #16]
 1457 05a4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1458 05a6 4EEA032E 		orr	lr, lr, r3, lsl #8
 1459              	.LVL138:
 374:../drivers/fsl_dspi_edma.c ****                     }
 1460              		.loc 2 374 0
 1461 05aa 2369     		ldr	r3, [r4, #16]
 1462 05ac 0133     		adds	r3, r3, #1
 1463 05ae 2361     		str	r3, [r4, #16]
 1464              	.LVL139:
 1465              	.L39:
 380:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->command & 0xffff0000U) | wordToSend;
 1466              		.loc 2 380 0
 1467 05b0 A369     		ldr	r3, [r4, #24]
 1468 05b2 023B     		subs	r3, r3, #2
 1469 05b4 A361     		str	r3, [r4, #24]
 381:../drivers/fsl_dspi_edma.c ****                 }
 1470              		.loc 2 381 0
 1471 05b6 6368     		ldr	r3, [r4, #4]
 1472 05b8 DBE7     		b	.L126
 1473              	.LVL140:
 1474              	.L104:
 378:../drivers/fsl_dspi_edma.c ****                     }
 1475              		.loc 2 378 0
 1476 05ba 8E46     		mov	lr, r1
 1477 05bc F8E7     		b	.L39
 1478              	.LVL141:
 1479              	.L47:
 400:../drivers/fsl_dspi_edma.c ****                 {
 1480              		.loc 2 400 0
 1481 05be 2369     		ldr	r3, [r4, #16]
 1482 05c0 F3B1     		cbz	r3, .L43
 402:../drivers/fsl_dspi_edma.c ****                     ++handle->txData;
 1483              		.loc 2 402 0
 1484 05c2 2369     		ldr	r3, [r4, #16]
 1485 05c4 93F800C0 		ldrb	ip, [r3]	@ zero_extendqisi2
 1486              	.LVL142:
 403:../drivers/fsl_dspi_edma.c ****                 }
 1487              		.loc 2 403 0
 1488 05c8 2369     		ldr	r3, [r4, #16]
 1489 05ca 0133     		adds	r3, r3, #1
 1490 05cc 2361     		str	r3, [r4, #16]
 1491              	.LVL143:
 1492              	.L44:
 410:../drivers/fsl_dspi_edma.c ****                 {
 1493              		.loc 2 410 0
 1494 05ce A369     		ldr	r3, [r4, #24]
 1495 05d0 012B     		cmp	r3, #1
 412:../drivers/fsl_dspi_edma.c ****                 }
 1496              		.loc 2 412 0
 1497 05d2 0CBF     		ite	eq
 1498 05d4 A368     		ldreq	r3, [r4, #8]
 416:../drivers/fsl_dspi_edma.c ****                 }
 1499              		.loc 2 416 0
 1500 05d6 6368     		ldrne	r3, [r4, #4]
 1501 05d8 0B40     		ands	r3, r3, r1
 1502 05da 43EA0C03 		orr	r3, r3, ip
 1503 05de 6B63     		str	r3, [r5, #52]
 1504              	.LVL144:
 1505              	.LBB202:
 1506              	.LBB203:
 580:../drivers/fsl_dspi.h **** }
 1507              		.loc 3 580 0
 1508 05e0 EF62     		str	r7, [r5, #44]
 1509              	.LVL145:
 1510              	.LBE203:
 1511              	.LBE202:
 422:../drivers/fsl_dspi_edma.c **** 
 1512              		.loc 2 422 0
 1513 05e2 A369     		ldr	r3, [r4, #24]
 1514 05e4 013B     		subs	r3, r3, #1
 1515 05e6 A361     		str	r3, [r4, #24]
 427:../drivers/fsl_dspi_edma.c ****                 {
 1516              		.loc 2 427 0
 1517 05e8 A369     		ldr	r3, [r4, #24]
 1518 05ea 002B     		cmp	r3, #0
 1519 05ec 3FF4EAAD 		beq	.L28
 1520 05f0 012A     		cmp	r2, #1
 1521 05f2 3FF4E7AD 		beq	.L28
 1522 05f6 0122     		movs	r2, #1
 1523              	.LVL146:
 1524              	.L34:
 1525              	.LBB205:
 1526              	.LBB206:
 561:../drivers/fsl_dspi.h **** }
 1527              		.loc 3 561 0
 1528 05f8 EB6A     		ldr	r3, [r5, #44]
 1529              	.LVL147:
 1530              	.LBE206:
 1531              	.LBE205:
 398:../drivers/fsl_dspi_edma.c ****             {
 1532              		.loc 2 398 0
 1533 05fa 9B01     		lsls	r3, r3, #6
 1534 05fc DFD4     		bmi	.L47
 1535 05fe E1E5     		b	.L28
 1536              	.L43:
 407:../drivers/fsl_dspi_edma.c ****                 }
 1537              		.loc 2 407 0
 1538 0600 8446     		mov	ip, r0
 1539              	.LVL148:
 1540 0602 E4E7     		b	.L44
 1541              	.LVL149:
 1542              	.L102:
 347:../drivers/fsl_dspi_edma.c ****         {
 1543              		.loc 2 347 0
 1544 0604 0222     		movs	r2, #2
 407:../drivers/fsl_dspi_edma.c ****                 }
 1545              		.loc 2 407 0
 1546 0606 B0B2     		uxth	r0, r6
 1547 0608 3749     		ldr	r1, .L145
 1548              	.LBB207:
 1549              	.LBB204:
 580:../drivers/fsl_dspi.h **** }
 1550              		.loc 3 580 0
 1551 060a 4FF00077 		mov	r7, #33554432
 1552              	.LVL150:
 1553 060e F3E7     		b	.L34
 1554              	.LVL151:
 1555              	.L48:
 1556              	.LBE204:
 1557              	.LBE207:
 448:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 0;
 1558              		.loc 2 448 0
 1559 0610 04F12402 		add	r2, r4, #36
 1560 0614 0392     		str	r2, [sp, #12]
 1561 0616 E7E5     		b	.L130
 1562              	.LVL152:
 1563              	.L61:
 1564              	.LBB208:
 507:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 1565              		.loc 2 507 0
 1566 0618 A268     		ldr	r2, [r4, #8]
 508:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 1567              		.loc 2 508 0
 1568 061a 2769     		ldr	r7, [r4, #16]
 509:../drivers/fsl_dspi_edma.c ****             }
 1569              		.loc 2 509 0
 1570 061c 2169     		ldr	r1, [r4, #16]
 1571 061e 0B44     		add	r3, r3, r1
 507:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 1572              		.loc 2 507 0
 1573 0620 3240     		ands	r2, r2, r6
 509:../drivers/fsl_dspi_edma.c ****             }
 1574              		.loc 2 509 0
 1575 0622 13F8023C 		ldrb	r3, [r3, #-2]	@ zero_extendqisi2
 508:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 1576              		.loc 2 508 0
 1577 0626 1343     		orrs	r3, r3, r2
 1578 0628 3A5C     		ldrb	r2, [r7, r0]	@ zero_extendqisi2
 1579 062a 43EA0223 		orr	r3, r3, r2, lsl #8
 1580 062e 2FE6     		b	.L132
 1581              	.LVL153:
 1582              	.L57:
 1583              	.LBE208:
 522:../drivers/fsl_dspi_edma.c ****         }
 1584              		.loc 2 522 0
 1585 0630 A368     		ldr	r3, [r4, #8]
 1586 0632 B6B2     		uxth	r6, r6
 1587              	.LVL154:
 514:../drivers/fsl_dspi_edma.c ****             {
 1588              		.loc 2 514 0
 1589 0634 082A     		cmp	r2, #8
 522:../drivers/fsl_dspi_edma.c ****         }
 1590              		.loc 2 522 0
 1591 0636 4FEA1343 		lsr	r3, r3, #16
 520:../drivers/fsl_dspi_edma.c ****             }
 1592              		.loc 2 520 0
 1593 063a 88BF     		it	hi
 1594 063c 46EA0626 		orrhi	r6, r6, r6, lsl #8
 1595              	.LVL155:
 522:../drivers/fsl_dspi_edma.c ****         }
 1596              		.loc 2 522 0
 1597 0640 1B04     		lsls	r3, r3, #16
 1598 0642 1E43     		orrs	r6, r6, r3
 1599              	.LVL156:
 1600 0644 A660     		str	r6, [r4, #8]
 1601 0646 24E6     		b	.L56
 1602              	.L68:
 703:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 0;
 1603              		.loc 2 703 0
 1604 0648 04F12802 		add	r2, r4, #40
 1605 064c 0892     		str	r2, [sp, #32]
 1606 064e 5FE6     		b	.L133
 1607              	.LVL157:
 1608              	.L74:
 740:../drivers/fsl_dspi_edma.c ****             }
 1609              		.loc 2 740 0
 1610 0650 0133     		adds	r3, r3, #1
 1611 0652 0D93     		str	r3, [sp, #52]
 1612              	.LVL158:
 1613              	.L67:
 759:../drivers/fsl_dspi_edma.c ****                                handle->edmaTxDataToIntermediaryHandle->channel, &transferConfigB, N
 1614              		.loc 2 759 0
 1615 0654 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1616 0656 8068     		ldr	r0, [r0, #8]
 1617 0658 0023     		movs	r3, #0
 1618 065a 08AA     		add	r2, sp, #32
 1619 065c FFF7FEFF 		bl	EDMA_SetTransferConfig
 1620              	.LVL159:
 1621 0660 8AE6     		b	.L93
 1622              	.LVL160:
 1623              	.L80:
 814:../drivers/fsl_dspi_edma.c **** 
 1624              		.loc 2 814 0
 1625 0662 0122     		movs	r2, #1
 1626              	.LVL161:
 1627 0664 1392     		str	r2, [sp, #76]
 1628 0666 DCE6     		b	.L135
 1629              	.LVL162:
 1630              	.L79:
 825:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC, NU
 1631              		.loc 2 825 0
 1632 0668 0023     		movs	r3, #0
 1633              	.LVL163:
 1634 066a 0EAA     		add	r2, sp, #56
 1635 066c 397C     		ldrb	r1, [r7, #16]	@ zero_extendqisi2
 1636 066e B868     		ldr	r0, [r7, #8]
 1637 0670 FFF7FEFF 		bl	EDMA_SetTransferConfig
 1638              	.LVL164:
 1639 0674 E5E6     		b	.L84
 1640              	.LVL165:
 1641              	.L105:
 846:../drivers/fsl_dspi_edma.c ****     {
 1642              		.loc 2 846 0
 1643 0676 1F46     		mov	r7, r3
 1644 0678 0A46     		mov	r2, r1
 1645 067a 00E7     		b	.L86
 1646              	.LVL166:
 1647              	.L107:
 1648 067c 0A46     		mov	r2, r1
 1649 067e 1F46     		mov	r7, r3
 1650 0680 02E7     		b	.L87
 1651              	.LVL167:
 1652              	.L88:
 879:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 1653              		.loc 2 879 0
 1654 0682 DEF80800 		ldr	r0, [lr, #8]
 1655 0686 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1656              	.LVL168:
 883:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1657              		.loc 2 883 0
 1658 068a A36B     		ldr	r3, [r4, #56]
 882:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 1659              		.loc 2 882 0
 1660 068c 8DF80660 		strb	r6, [sp, #6]
 883:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1661              		.loc 2 883 0
 1662 0690 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1663 0692 9868     		ldr	r0, [r3, #8]
 1664 0694 01AA     		add	r2, sp, #4
 1665 0696 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1666              	.LVL169:
 887:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1667              		.loc 2 887 0
 1668 069a 636B     		ldr	r3, [r4, #52]
 886:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 1669              		.loc 2 886 0
 1670 069c 8DF80670 		strb	r7, [sp, #6]
 887:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1671              		.loc 2 887 0
 1672 06a0 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1673 06a2 9868     		ldr	r0, [r3, #8]
 1674 06a4 01AA     		add	r2, sp, #4
 1675 06a6 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1676              	.LVL170:
 896:../drivers/fsl_dspi_edma.c ****         {
 1677              		.loc 2 896 0
 1678 06aa A369     		ldr	r3, [r4, #24]
 1679 06ac 012B     		cmp	r3, #1
 1680 06ae 07D9     		bls	.L91
 900:../drivers/fsl_dspi_edma.c ****         }
 1681              		.loc 2 900 0
 1682 06b0 D4E90E30 		ldrd	r3, r0, [r4, #56]
 898:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel, kEDMA_MajorLink,
 1683              		.loc 2 898 0
 1684 06b4 0222     		movs	r2, #2
 1685 06b6 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1686 06b8 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1687 06ba 8068     		ldr	r0, [r0, #8]
 1688 06bc FFF7FEFF 		bl	EDMA_SetChannelLink
 1689              	.LVL171:
 1690              	.L91:
 1691              	.LBB209:
 1692              	.LBB210:
 645:../drivers/fsl_dspi.h **** }
 1693              		.loc 3 645 0
 1694 06c0 0A4A     		ldr	r2, .L145+4
 1695              	.LVL172:
 1696 06c2 136B     		ldr	r3, [r2, #48]
 1697 06c4 43F04073 		orr	r3, r3, #50331648
 1698 06c8 43F44033 		orr	r3, r3, #196608
 1699 06cc 1363     		str	r3, [r2, #48]
 1700              	.LVL173:
 1701              	.L92:
 1702              	.LBE210:
 1703              	.LBE209:
 1704              	.LBB211:
 1705              	.LBB212:
 742:../drivers/fsl_dspi.h **** }
 1706              		.loc 3 742 0
 1707 06ce 2B68     		ldr	r3, [r5]
 1708 06d0 23F00103 		bic	r3, r3, #1
 1709 06d4 2B60     		str	r3, [r5]
 1710              	.LVL174:
 1711              	.LBE212:
 1712              	.LBE211:
 922:../drivers/fsl_dspi_edma.c **** }
 1713              		.loc 2 922 0
 1714 06d6 0020     		movs	r0, #0
 1715              	.LVL175:
 1716 06d8 0AE5     		b	.L11
 1717              	.LVL176:
 1718              	.L97:
 1719              	.LBE214:
 1720              	.LBE217:
 153:../drivers/fsl_dspi_edma.c ****     }
 1721              		.loc 2 153 0
 1722 06da 4FF41670 		mov	r0, #600
 1723              	.LVL177:
 1724 06de 07E5     		b	.L11
 1725              	.LVL178:
 1726              	.L85:
 1727              	.LBB218:
 1728              	.LBB215:
 846:../drivers/fsl_dspi_edma.c ****     {
 1729              		.loc 2 846 0
 1730 06e0 8E42     		cmp	r6, r1
 1731 06e2 CBD8     		bhi	.L107
 1732 06e4 1846     		mov	r0, r3
 1733 06e6 C7E6     		b	.L94
 1734              	.L146:
 1735              		.align	2
 1736              	.L145:
 1737 06e8 0000FFFF 		.word	-65536
 1738 06ec 00C00240 		.word	1073922048
 1739              	.LBE215:
 1740              	.LBE218:
 1741              		.cfi_endproc
 1742              	.LFE178:
 1744              		.section	.text.DSPI_MasterHalfDuplexTransferEDMA,"ax",%progbits
 1745              		.align	1
 1746              		.global	DSPI_MasterHalfDuplexTransferEDMA
 1747              		.syntax unified
 1748              		.thumb
 1749              		.thumb_func
 1750              		.fpu fpv4-sp-d16
 1752              	DSPI_MasterHalfDuplexTransferEDMA:
 1753              	.LFB179:
 928:../drivers/fsl_dspi_edma.c ****     assert(xfer);
 1754              		.loc 2 928 0
 1755              		.cfi_startproc
 1756              		@ args = 0, pretend = 0, frame = 16
 1757              		@ frame_needed = 0, uses_anonymous_args = 0
 1758              	.LVL179:
 1759 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1760              		.cfi_def_cfa_offset 32
 1761              		.cfi_offset 4, -16
 1762              		.cfi_offset 5, -12
 1763              		.cfi_offset 6, -8
 1764              		.cfi_offset 14, -4
 928:../drivers/fsl_dspi_edma.c ****     assert(xfer);
 1765              		.loc 2 928 0
 1766 0002 1446     		mov	r4, r2
 1767 0004 0546     		mov	r5, r0
 1768 0006 0E46     		mov	r6, r1
 931:../drivers/fsl_dspi_edma.c ****     status_t status;
 1769              		.loc 2 931 0
 1770 0008 1022     		movs	r2, #16
 1771              	.LVL180:
 1772 000a 0021     		movs	r1, #0
 1773              	.LVL181:
 1774 000c 6846     		mov	r0, sp
 1775              	.LVL182:
 1776 000e FFF7FEFF 		bl	memset
 1777              	.LVL183:
 934:../drivers/fsl_dspi_edma.c ****     {
 1778              		.loc 2 934 0
 1779 0012 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 1780 0014 F3B1     		cbz	r3, .L148
 936:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 1781              		.loc 2 936 0
 1782 0016 2368     		ldr	r3, [r4]
 1783 0018 0093     		str	r3, [sp]
 938:../drivers/fsl_dspi_edma.c ****     }
 1784              		.loc 2 938 0
 1785 001a A368     		ldr	r3, [r4, #8]
 1786              	.L155:
 947:../drivers/fsl_dspi_edma.c ****     {
 1787              		.loc 2 947 0
 1788 001c 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 944:../drivers/fsl_dspi_edma.c ****     }
 1789              		.loc 2 944 0
 1790 001e 0293     		str	r3, [sp, #8]
 1791 0020 2369     		ldr	r3, [r4, #16]
 947:../drivers/fsl_dspi_edma.c ****     {
 1792              		.loc 2 947 0
 1793 0022 DAB1     		cbz	r2, .L150
 949:../drivers/fsl_dspi_edma.c ****     }
 1794              		.loc 2 949 0
 1795 0024 43F40013 		orr	r3, r3, #2097152
 1796              	.L156:
 956:../drivers/fsl_dspi_edma.c ****     if (status != kStatus_Success)
 1797              		.loc 2 956 0
 1798 0028 6946     		mov	r1, sp
 1799 002a 2846     		mov	r0, r5
 953:../drivers/fsl_dspi_edma.c ****     }
 1800              		.loc 2 953 0
 1801 002c 0393     		str	r3, [sp, #12]
 956:../drivers/fsl_dspi_edma.c ****     if (status != kStatus_Success)
 1802              		.loc 2 956 0
 1803 002e FFF7FEFF 		bl	DSPI_MasterTransferBlocking
 1804              	.LVL184:
 957:../drivers/fsl_dspi_edma.c ****     {
 1805              		.loc 2 957 0
 1806 0032 68B9     		cbnz	r0, .L147
 962:../drivers/fsl_dspi_edma.c ****     {
 1807              		.loc 2 962 0
 1808 0034 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 1809 0036 A3B1     		cbz	r3, .L153
 965:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 1810              		.loc 2 965 0
 1811 0038 6368     		ldr	r3, [r4, #4]
 1812 003a 0193     		str	r3, [sp, #4]
 966:../drivers/fsl_dspi_edma.c ****     }
 1813              		.loc 2 966 0
 1814 003c E368     		ldr	r3, [r4, #12]
 964:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = xfer->rxData;
 1815              		.loc 2 964 0
 1816 003e 0090     		str	r0, [sp]
 1817              	.L157:
 972:../drivers/fsl_dspi_edma.c ****     }
 1818              		.loc 2 972 0
 1819 0040 0293     		str	r3, [sp, #8]
 976:../drivers/fsl_dspi_edma.c **** 
 1820              		.loc 2 976 0
 1821 0042 6A46     		mov	r2, sp
 974:../drivers/fsl_dspi_edma.c **** 
 1822              		.loc 2 974 0
 1823 0044 2369     		ldr	r3, [r4, #16]
 1824 0046 0393     		str	r3, [sp, #12]
 976:../drivers/fsl_dspi_edma.c **** 
 1825              		.loc 2 976 0
 1826 0048 3146     		mov	r1, r6
 1827 004a 2846     		mov	r0, r5
 1828              	.LVL185:
 1829 004c FFF7FEFF 		bl	DSPI_MasterTransferEDMA
 1830              	.LVL186:
 1831              	.L147:
 979:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiMasterCallback(edma_handle_t *edmaHandle,
 1832              		.loc 2 979 0
 1833 0050 04B0     		add	sp, sp, #16
 1834              		.cfi_remember_state
 1835              		.cfi_def_cfa_offset 16
 1836              		@ sp needed
 1837 0052 70BD     		pop	{r4, r5, r6, pc}
 1838              	.LVL187:
 1839              	.L148:
 1840              		.cfi_restore_state
 943:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 1841              		.loc 2 943 0
 1842 0054 6368     		ldr	r3, [r4, #4]
 1843 0056 0193     		str	r3, [sp, #4]
 944:../drivers/fsl_dspi_edma.c ****     }
 1844              		.loc 2 944 0
 1845 0058 E368     		ldr	r3, [r4, #12]
 1846 005a DFE7     		b	.L155
 1847              	.L150:
 953:../drivers/fsl_dspi_edma.c ****     }
 1848              		.loc 2 953 0
 1849 005c 23F40013 		bic	r3, r3, #2097152
 1850 0060 E2E7     		b	.L156
 1851              	.LVL188:
 1852              	.L153:
 970:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 1853              		.loc 2 970 0
 1854 0062 2268     		ldr	r2, [r4]
 971:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->txDataSize;
 1855              		.loc 2 971 0
 1856 0064 CDE90023 		strd	r2, r3, [sp]
 972:../drivers/fsl_dspi_edma.c ****     }
 1857              		.loc 2 972 0
 1858 0068 A368     		ldr	r3, [r4, #8]
 1859 006a E9E7     		b	.L157
 1860              		.cfi_endproc
 1861              	.LFE179:
 1863              		.section	.text.DSPI_MasterTransferAbortEDMA,"ax",%progbits
 1864              		.align	1
 1865              		.global	DSPI_MasterTransferAbortEDMA
 1866              		.syntax unified
 1867              		.thumb
 1868              		.thumb_func
 1869              		.fpu fpv4-sp-d16
 1871              	DSPI_MasterTransferAbortEDMA:
 1872              	.LFB181:
1004:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1873              		.loc 2 1004 0
 1874              		.cfi_startproc
 1875              		@ args = 0, pretend = 0, frame = 0
 1876              		@ frame_needed = 0, uses_anonymous_args = 0
 1877              	.LVL189:
 1878              	.LBB219:
 1879              	.LBB220:
 753:../drivers/fsl_dspi.h **** }
 1880              		.loc 3 753 0
 1881 0000 0368     		ldr	r3, [r0]
 1882 0002 43F00103 		orr	r3, r3, #1
 1883              	.LBE220:
 1884              	.LBE219:
1004:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1885              		.loc 2 1004 0
 1886 0006 10B5     		push	{r4, lr}
 1887              		.cfi_def_cfa_offset 8
 1888              		.cfi_offset 4, -8
 1889              		.cfi_offset 14, -4
 1890              	.LBB222:
 1891              	.LBB221:
 753:../drivers/fsl_dspi.h **** }
 1892              		.loc 3 753 0
 1893 0008 0360     		str	r3, [r0]
 1894              	.LVL190:
 1895              	.LBE221:
 1896              	.LBE222:
 1897              	.LBB223:
 1898              	.LBB224:
 661:../drivers/fsl_dspi.h **** }
 1899              		.loc 3 661 0
 1900 000a 036B     		ldr	r3, [r0, #48]
 1901 000c 23F04073 		bic	r3, r3, #50331648
 1902              	.LBE224:
 1903              	.LBE223:
1004:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1904              		.loc 2 1004 0
 1905 0010 0C46     		mov	r4, r1
 1906              	.LBB226:
 1907              	.LBB225:
 661:../drivers/fsl_dspi.h **** }
 1908              		.loc 3 661 0
 1909 0012 23F44033 		bic	r3, r3, #196608
 1910 0016 0363     		str	r3, [r0, #48]
 1911              	.LVL191:
 1912              	.LBE225:
 1913              	.LBE226:
1011:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaTxDataToIntermediaryHandle);
 1914              		.loc 2 1011 0
 1915 0018 486B     		ldr	r0, [r1, #52]
 1916              	.LVL192:
 1917 001a FFF7FEFF 		bl	EDMA_AbortTransfer
 1918              	.LVL193:
1012:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaIntermediaryToTxRegHandle);
 1919              		.loc 2 1012 0
 1920 001e A06B     		ldr	r0, [r4, #56]
 1921 0020 FFF7FEFF 		bl	EDMA_AbortTransfer
 1922              	.LVL194:
1013:../drivers/fsl_dspi_edma.c **** 
 1923              		.loc 2 1013 0
 1924 0024 E06B     		ldr	r0, [r4, #60]
 1925 0026 FFF7FEFF 		bl	EDMA_AbortTransfer
 1926              	.LVL195:
1015:../drivers/fsl_dspi_edma.c **** }
 1927              		.loc 2 1015 0
 1928 002a 0023     		movs	r3, #0
 1929 002c E373     		strb	r3, [r4, #15]
1016:../drivers/fsl_dspi_edma.c **** 
 1930              		.loc 2 1016 0
 1931 002e 10BD     		pop	{r4, pc}
 1932              		.cfi_endproc
 1933              	.LFE181:
 1935              		.section	.text.DSPI_MasterTransferGetCountEDMA,"ax",%progbits
 1936              		.align	1
 1937              		.global	DSPI_MasterTransferGetCountEDMA
 1938              		.syntax unified
 1939              		.thumb
 1940              		.thumb_func
 1941              		.fpu fpv4-sp-d16
 1943              	DSPI_MasterTransferGetCountEDMA:
 1944              	.LFB182:
1019:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1945              		.loc 2 1019 0
 1946              		.cfi_startproc
 1947              		@ args = 0, pretend = 0, frame = 0
 1948              		@ frame_needed = 0, uses_anonymous_args = 0
 1949              	.LVL196:
 1950 0000 70B5     		push	{r4, r5, r6, lr}
 1951              		.cfi_def_cfa_offset 16
 1952              		.cfi_offset 4, -16
 1953              		.cfi_offset 5, -12
 1954              		.cfi_offset 6, -8
 1955              		.cfi_offset 14, -4
1019:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1956              		.loc 2 1019 0
 1957 0002 0C46     		mov	r4, r1
1022:../drivers/fsl_dspi_edma.c ****     {
 1958              		.loc 2 1022 0
 1959 0004 1546     		mov	r5, r2
 1960 0006 92B1     		cbz	r2, .L162
1028:../drivers/fsl_dspi_edma.c ****     {
 1961              		.loc 2 1028 0
 1962 0008 CB7B     		ldrb	r3, [r1, #15]	@ zero_extendqisi2
 1963 000a 012B     		cmp	r3, #1
 1964 000c 03D0     		beq	.L161
1030:../drivers/fsl_dspi_edma.c ****         return kStatus_NoTransferInProgress;
 1965              		.loc 2 1030 0
 1966 000e 0023     		movs	r3, #0
 1967 0010 1360     		str	r3, [r2]
1031:../drivers/fsl_dspi_edma.c ****     }
 1968              		.loc 2 1031 0
 1969 0012 0620     		movs	r0, #6
 1970              	.LVL197:
 1971              	.L159:
1042:../drivers/fsl_dspi_edma.c **** 
 1972              		.loc 2 1042 0
 1973 0014 70BD     		pop	{r4, r5, r6, pc}
 1974              	.LVL198:
 1975              	.L161:
1036:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
 1976              		.loc 2 1036 0
 1977 0016 4B6B     		ldr	r3, [r1, #52]
 1978 0018 8E7B     		ldrb	r6, [r1, #14]	@ zero_extendqisi2
 1979 001a 9868     		ldr	r0, [r3, #8]
 1980              	.LVL199:
 1981 001c 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1982              	.LVL200:
 1983 001e FFF7FEFF 		bl	EDMA_GetRemainingMajorLoopCount
 1984              	.LVL201:
1039:../drivers/fsl_dspi_edma.c **** 
 1985              		.loc 2 1039 0
 1986 0022 236A     		ldr	r3, [r4, #32]
 1987 0024 00FB1630 		mls	r0, r0, r6, r3
 1988              	.LVL202:
 1989 0028 2860     		str	r0, [r5]
1041:../drivers/fsl_dspi_edma.c **** }
 1990              		.loc 2 1041 0
 1991 002a 0020     		movs	r0, #0
 1992 002c F2E7     		b	.L159
 1993              	.LVL203:
 1994              	.L162:
1024:../drivers/fsl_dspi_edma.c ****     }
 1995              		.loc 2 1024 0
 1996 002e 0420     		movs	r0, #4
 1997              	.LVL204:
 1998 0030 F0E7     		b	.L159
 1999              		.cfi_endproc
 2000              	.LFE182:
 2002              		.section	.text.DSPI_SlaveTransferCreateHandleEDMA,"ax",%progbits
 2003              		.align	1
 2004              		.global	DSPI_SlaveTransferCreateHandleEDMA
 2005              		.syntax unified
 2006              		.thumb
 2007              		.thumb_func
 2008              		.fpu fpv4-sp-d16
 2010              	DSPI_SlaveTransferCreateHandleEDMA:
 2011              	.LFB183:
1050:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2012              		.loc 2 1050 0
 2013              		.cfi_startproc
 2014              		@ args = 8, pretend = 0, frame = 0
 2015              		@ frame_needed = 0, uses_anonymous_args = 0
 2016              	.LVL205:
 2017 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2018              		.cfi_def_cfa_offset 24
 2019              		.cfi_offset 3, -24
 2020              		.cfi_offset 4, -20
 2021              		.cfi_offset 5, -16
 2022              		.cfi_offset 6, -12
 2023              		.cfi_offset 7, -8
 2024              		.cfi_offset 14, -4
1050:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2025              		.loc 2 1050 0
 2026 0002 0C46     		mov	r4, r1
 2027 0004 0546     		mov	r5, r0
 2028 0006 1746     		mov	r7, r2
1056:../drivers/fsl_dspi_edma.c **** 
 2029              		.loc 2 1056 0
 2030 0008 0021     		movs	r1, #0
 2031              	.LVL206:
 2032 000a 3822     		movs	r2, #56
 2033              	.LVL207:
 2034 000c 2046     		mov	r0, r4
 2035              	.LVL208:
1050:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2036              		.loc 2 1050 0
 2037 000e 1E46     		mov	r6, r3
1056:../drivers/fsl_dspi_edma.c **** 
 2038              		.loc 2 1056 0
 2039 0010 FFF7FEFF 		bl	memset
 2040              	.LVL209:
1058:../drivers/fsl_dspi_edma.c **** 
 2041              		.loc 2 1058 0
 2042 0014 2846     		mov	r0, r5
 2043 0016 FFF7FEFF 		bl	DSPI_GetInstance
 2044              	.LVL210:
1060:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].handle = handle;
 2045              		.loc 2 1060 0
 2046 001a 064A     		ldr	r2, .L164
1066:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToTxRegHandle = edmaTxDataToTxRegHandle;
 2047              		.loc 2 1066 0
 2048 001c 069B     		ldr	r3, [sp, #24]
1060:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].handle = handle;
 2049              		.loc 2 1060 0
 2050 001e 42F83050 		str	r5, [r2, r0, lsl #3]
1061:../drivers/fsl_dspi_edma.c **** 
 2051              		.loc 2 1061 0
 2052 0022 02EBC002 		add	r2, r2, r0, lsl #3
1066:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToTxRegHandle = edmaTxDataToTxRegHandle;
 2053              		.loc 2 1066 0
 2054 0026 2363     		str	r3, [r4, #48]
1067:../drivers/fsl_dspi_edma.c **** }
 2055              		.loc 2 1067 0
 2056 0028 079B     		ldr	r3, [sp, #28]
1061:../drivers/fsl_dspi_edma.c **** 
 2057              		.loc 2 1061 0
 2058 002a 5460     		str	r4, [r2, #4]
1064:../drivers/fsl_dspi_edma.c **** 
 2059              		.loc 2 1064 0
 2060 002c C4E90A76 		strd	r7, r6, [r4, #40]
1067:../drivers/fsl_dspi_edma.c **** }
 2061              		.loc 2 1067 0
 2062 0030 6363     		str	r3, [r4, #52]
1068:../drivers/fsl_dspi_edma.c **** 
 2063              		.loc 2 1068 0
 2064 0032 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2065              	.LVL211:
 2066              	.L165:
 2067              		.align	2
 2068              	.L164:
 2069 0034 00000000 		.word	.LANCHOR1
 2070              		.cfi_endproc
 2071              	.LFE183:
 2073              		.section	.text.DSPI_SlaveTransferEDMA,"ax",%progbits
 2074              		.align	1
 2075              		.global	DSPI_SlaveTransferEDMA
 2076              		.syntax unified
 2077              		.thumb
 2078              		.thumb_func
 2079              		.fpu fpv4-sp-d16
 2081              	DSPI_SlaveTransferEDMA:
 2082              	.LFB184:
1071:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2083              		.loc 2 1071 0
 2084              		.cfi_startproc
 2085              		@ args = 0, pretend = 0, frame = 56
 2086              		@ frame_needed = 0, uses_anonymous_args = 0
 2087              	.LVL212:
 2088 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2089              		.cfi_def_cfa_offset 20
 2090              		.cfi_offset 4, -20
 2091              		.cfi_offset 5, -16
 2092              		.cfi_offset 6, -12
 2093              		.cfi_offset 7, -8
 2094              		.cfi_offset 14, -4
1076:../drivers/fsl_dspi_edma.c ****     {
 2095              		.loc 2 1076 0
 2096 0002 9368     		ldr	r3, [r2, #8]
1071:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2097              		.loc 2 1071 0
 2098 0004 8FB0     		sub	sp, sp, #60
 2099              		.cfi_def_cfa_offset 80
1071:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2100              		.loc 2 1071 0
 2101 0006 0546     		mov	r5, r0
 2102 0008 0C46     		mov	r4, r1
 2103 000a 1646     		mov	r6, r2
1076:../drivers/fsl_dspi_edma.c ****     {
 2104              		.loc 2 1076 0
 2105 000c 002B     		cmp	r3, #0
 2106 000e 00F01281 		beq	.L199
1082:../drivers/fsl_dspi_edma.c ****     {
 2107              		.loc 2 1082 0
 2108 0012 1368     		ldr	r3, [r2]
 2109 0014 1BB9     		cbnz	r3, .L168
1082:../drivers/fsl_dspi_edma.c ****     {
 2110              		.loc 2 1082 0 is_stmt 0 discriminator 1
 2111 0016 5368     		ldr	r3, [r2, #4]
 2112 0018 002B     		cmp	r3, #0
 2113 001a 00F00C81 		beq	.L199
 2114              	.L168:
1088:../drivers/fsl_dspi_edma.c ****     {
 2115              		.loc 2 1088 0 is_stmt 1
 2116 001e 94F82530 		ldrb	r3, [r4, #37]	@ zero_extendqisi2
 2117 0022 012B     		cmp	r3, #1
 2118 0024 00F07F81 		beq	.L200
1093:../drivers/fsl_dspi_edma.c **** 
 2119              		.loc 2 1093 0
 2120 0028 0123     		movs	r3, #1
 2121 002a 84F82530 		strb	r3, [r4, #37]
1095:../drivers/fsl_dspi_edma.c ****     uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
 2122              		.loc 2 1095 0
 2123 002e 2846     		mov	r0, r5
 2124              	.LVL213:
 2125 0030 FFF7FEFF 		bl	DSPI_GetInstance
 2126              	.LVL214:
1096:../drivers/fsl_dspi_edma.c ****     handle->bitsPerFrame =
 2127              		.loc 2 1096 0
 2128 0034 F368     		ldr	r3, [r6, #12]
1106:../drivers/fsl_dspi_edma.c ****     }
 2129              		.loc 2 1106 0
 2130 0036 A74F     		ldr	r7, .L229
1098:../drivers/fsl_dspi_edma.c **** 
 2131              		.loc 2 1098 0
 2132 0038 03F00703 		and	r3, r3, #7
 2133 003c 0233     		adds	r3, r3, #2
 2134 003e 05EB8303 		add	r3, r5, r3, lsl #2
1106:../drivers/fsl_dspi_edma.c ****     }
 2135              		.loc 2 1106 0
 2136 0042 40F2FF11 		movw	r1, #511
1098:../drivers/fsl_dspi_edma.c **** 
 2137              		.loc 2 1098 0
 2138 0046 5B68     		ldr	r3, [r3, #4]
 2139 0048 DB0E     		lsrs	r3, r3, #27
 2140 004a 0133     		adds	r3, r3, #1
1106:../drivers/fsl_dspi_edma.c ****     }
 2141              		.loc 2 1106 0
 2142 004c 47F6FF72 		movw	r2, #32767
 2143 0050 BD42     		cmp	r5, r7
 2144 0052 08BF     		it	eq
 2145 0054 1146     		moveq	r1, r2
1113:../drivers/fsl_dspi_edma.c ****     {
 2146              		.loc 2 1113 0
 2147 0056 082B     		cmp	r3, #8
1097:../drivers/fsl_dspi_edma.c ****         (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) +
 2148              		.loc 2 1097 0
 2149 0058 2360     		str	r3, [r4]
 2150              	.LVL215:
1115:../drivers/fsl_dspi_edma.c ****         {
 2151              		.loc 2 1115 0
 2152 005a B368     		ldr	r3, [r6, #8]
1113:../drivers/fsl_dspi_edma.c ****     {
 2153              		.loc 2 1113 0
 2154 005c 0AD9     		bls	.L170
1115:../drivers/fsl_dspi_edma.c ****         {
 2155              		.loc 2 1115 0
 2156 005e B3EB410F 		cmp	r3, r1, lsl #1
 2157 0062 40F2E180 		bls	.L171
 2158              	.L227:
1125:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 2159              		.loc 2 1125 0
 2160 0066 0023     		movs	r3, #0
 2161 0068 84F82530 		strb	r3, [r4, #37]
 2162              	.LVL216:
1126:../drivers/fsl_dspi_edma.c ****         }
 2163              		.loc 2 1126 0
 2164 006c 40F25B20 		movw	r0, #603
 2165              	.LVL217:
 2166              	.L166:
1388:../drivers/fsl_dspi_edma.c **** 
 2167              		.loc 2 1388 0
 2168 0070 0FB0     		add	sp, sp, #60
 2169              		.cfi_remember_state
 2170              		.cfi_def_cfa_offset 20
 2171              		@ sp needed
 2172 0072 F0BD     		pop	{r4, r5, r6, r7, pc}
 2173              	.LVL218:
 2174              	.L170:
 2175              		.cfi_restore_state
1123:../drivers/fsl_dspi_edma.c ****         {
 2176              		.loc 2 1123 0
 2177 0074 8B42     		cmp	r3, r1
 2178 0076 F6D8     		bhi	.L227
 2179              	.LVL219:
 2180              	.L172:
1137:../drivers/fsl_dspi_edma.c **** 
 2181              		.loc 2 1137 0
 2182 0078 974A     		ldr	r2, .L229+4
 2183              	.LVL220:
 2184 007a 9849     		ldr	r1, .L229+8
 2185 007c 02EBC002 		add	r2, r2, r0, lsl #3
 2186 0080 206B     		ldr	r0, [r4, #48]
 2187              	.LVL221:
 2188 0082 FFF7FEFF 		bl	EDMA_SetCallback
 2189              	.LVL222:
1140:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
 2190              		.loc 2 1140 0
 2191 0086 3368     		ldr	r3, [r6]
 2192 0088 6360     		str	r3, [r4, #4]
1141:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
 2193              		.loc 2 1141 0
 2194 008a 7368     		ldr	r3, [r6, #4]
 2195 008c A360     		str	r3, [r4, #8]
1142:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 2196              		.loc 2 1142 0
 2197 008e B368     		ldr	r3, [r6, #8]
 2198 0090 E360     		str	r3, [r4, #12]
1143:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
 2199              		.loc 2 1143 0
 2200 0092 B368     		ldr	r3, [r6, #8]
 2201 0094 2361     		str	r3, [r4, #16]
1144:../drivers/fsl_dspi_edma.c **** 
 2202              		.loc 2 1144 0
 2203 0096 B368     		ldr	r3, [r6, #8]
 2204 0098 6361     		str	r3, [r4, #20]
 2205              	.LVL223:
1147:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 2206              		.loc 2 1147 0
 2207 009a 2846     		mov	r0, r5
 2208 009c FFF7FEFF 		bl	DSPI_GetInstance
 2209              	.LVL224:
 2210 00a0 8F4B     		ldr	r3, .L229+12
 2211 00a2 1E5C     		ldrb	r6, [r3, r0]	@ zero_extendqisi2
 2212              	.LVL225:
 2213              	.LBB227:
 2214              	.LBB228:
 753:../drivers/fsl_dspi.h **** }
 2215              		.loc 3 753 0
 2216 00a4 2B68     		ldr	r3, [r5]
 2217 00a6 43F00103 		orr	r3, r3, #1
 2218 00aa 2B60     		str	r3, [r5]
 2219              	.LBE228:
 2220              	.LBE227:
 2221              	.LBB229:
 2222              	.LBB230:
 782:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 2223              		.loc 3 782 0
 2224 00ac 2B68     		ldr	r3, [r5]
 2225 00ae 43F44063 		orr	r3, r3, #3072
 2226 00b2 2B60     		str	r3, [r5]
 2227              	.LBE230:
 2228              	.LBE229:
 2229              	.LBB231:
 2230              	.LBB232:
 580:../drivers/fsl_dspi.h **** }
 2231              		.loc 3 580 0
 2232 00b4 8B4B     		ldr	r3, .L229+16
 2233 00b6 EB62     		str	r3, [r5, #44]
 2234              	.LBE232:
 2235              	.LBE231:
 2236              	.LBB233:
 2237              	.LBB234:
 661:../drivers/fsl_dspi.h **** }
 2238              		.loc 3 661 0
 2239 00b8 2B6B     		ldr	r3, [r5, #48]
 2240 00ba 23F04073 		bic	r3, r3, #50331648
 2241 00be 23F44033 		bic	r3, r3, #196608
 2242 00c2 2B63     		str	r3, [r5, #48]
 2243              	.LBE234:
 2244              	.LBE233:
 2245              	.LBB235:
 2246              	.LBB236:
 742:../drivers/fsl_dspi.h **** }
 2247              		.loc 3 742 0
 2248 00c4 2B68     		ldr	r3, [r5]
 2249 00c6 23F00103 		bic	r3, r3, #1
 2250 00ca 2B60     		str	r3, [r5]
 2251              	.LBE236:
 2252              	.LBE235:
1169:../drivers/fsl_dspi_edma.c ****     {
 2253              		.loc 2 1169 0
 2254 00cc 814B     		ldr	r3, .L229
 2255 00ce 9D42     		cmp	r5, r3
1147:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 2256              		.loc 2 1147 0
 2257 00d0 F6B2     		uxtb	r6, r6
 2258              	.LVL226:
1169:../drivers/fsl_dspi_edma.c ****     {
 2259              		.loc 2 1169 0
 2260 00d2 40F0B280 		bne	.L173
 2261              	.LVL227:
 2262              	.L179:
1240:../drivers/fsl_dspi_edma.c ****     {
 2263              		.loc 2 1240 0
 2264 00d6 2369     		ldr	r3, [r4, #16]
 2265 00d8 002B     		cmp	r3, #0
 2266 00da 39D0     		beq	.L175
1242:../drivers/fsl_dspi_edma.c **** 
 2267              		.loc 2 1242 0
 2268 00dc 236B     		ldr	r3, [r4, #48]
 2269 00de 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2270 00e0 9868     		ldr	r0, [r3, #8]
 2271 00e2 FFF7FEFF 		bl	EDMA_ResetChannel
 2272              	.LVL228:
 2273              	.LBB237:
 2274              	.LBB238:
 700:../drivers/fsl_dspi.h **** }
 2275              		.loc 3 700 0
 2276 00e6 05F13803 		add	r3, r5, #56
 2277              	.LBE238:
 2278              	.LBE237:
1244:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcOffset = 0;
 2279              		.loc 2 1244 0
 2280 00ea 0293     		str	r3, [sp, #8]
1245:../drivers/fsl_dspi_edma.c **** 
 2281              		.loc 2 1245 0
 2282 00ec 0023     		movs	r3, #0
 2283 00ee ADF81230 		strh	r3, [sp, #18]	@ movhi
1247:../drivers/fsl_dspi_edma.c ****         {
 2284              		.loc 2 1247 0
 2285 00f2 A368     		ldr	r3, [r4, #8]
 2286 00f4 002B     		cmp	r3, #0
 2287 00f6 00F0E980 		beq	.L184
1249:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 1;
 2288              		.loc 2 1249 0
 2289 00fa A368     		ldr	r3, [r4, #8]
 2290 00fc 0393     		str	r3, [sp, #12]
1250:../drivers/fsl_dspi_edma.c ****         }
 2291              		.loc 2 1250 0
 2292 00fe 0123     		movs	r3, #1
 2293              	.L223:
1255:../drivers/fsl_dspi_edma.c ****         }
 2294              		.loc 2 1255 0
 2295 0100 ADF81430 		strh	r3, [sp, #20]	@ movhi
1260:../drivers/fsl_dspi_edma.c ****         {
 2296              		.loc 2 1260 0
 2297 0104 2368     		ldr	r3, [r4]
1276:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
 2298              		.loc 2 1276 0
 2299 0106 206B     		ldr	r0, [r4, #48]
1260:../drivers/fsl_dspi_edma.c ****         {
 2300              		.loc 2 1260 0
 2301 0108 082B     		cmp	r3, #8
 2302 010a 4FF00103 		mov	r3, #1
1268:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 2;
 2303              		.loc 2 1268 0
 2304 010e 81BF     		itttt	hi
 2305 0110 8DF81030 		strbhi	r3, [sp, #16]
1269:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
 2306              		.loc 2 1269 0
 2307 0114 0223     		movhi	r3, #2
 2308 0116 0693     		strhi	r3, [sp, #24]
1270:../drivers/fsl_dspi_edma.c ****         }
 2309              		.loc 2 1270 0
 2310 0118 2369     		ldrhi	r3, [r4, #16]
1263:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
 2311              		.loc 2 1263 0
 2312 011a 96BF     		itet	ls
 2313 011c 0693     		strls	r3, [sp, #24]
1270:../drivers/fsl_dspi_edma.c ****         }
 2314              		.loc 2 1270 0
 2315 011e 5B08     		lsrhi	r3, r3, #1
1264:../drivers/fsl_dspi_edma.c ****         }
 2316              		.loc 2 1264 0
 2317 0120 2369     		ldrls	r3, [r4, #16]
1270:../drivers/fsl_dspi_edma.c ****         }
 2318              		.loc 2 1270 0
 2319 0122 0793     		str	r3, [sp, #28]
1274:../drivers/fsl_dspi_edma.c **** 
 2320              		.loc 2 1274 0
 2321 0124 069B     		ldr	r3, [sp, #24]
 2322 0126 84F82430 		strb	r3, [r4, #36]
1258:../drivers/fsl_dspi_edma.c **** 
 2323              		.loc 2 1258 0
 2324 012a 4FF00002 		mov	r2, #0
1276:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
 2325              		.loc 2 1276 0
 2326 012e 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
1258:../drivers/fsl_dspi_edma.c **** 
 2327              		.loc 2 1258 0
 2328 0130 8DF81120 		strb	r2, [sp, #17]
1262:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 1;
 2329              		.loc 2 1262 0
 2330 0134 98BF     		it	ls
 2331 0136 8DF81020 		strbls	r2, [sp, #16]
1276:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
 2332              		.loc 2 1276 0
 2333 013a 0023     		movs	r3, #0
 2334 013c 02AA     		add	r2, sp, #8
 2335 013e 8068     		ldr	r0, [r0, #8]
 2336 0140 FFF7FEFF 		bl	EDMA_SetTransferConfig
 2337              	.LVL229:
1278:../drivers/fsl_dspi_edma.c ****                                      kEDMA_MajorInterruptEnable);
 2338              		.loc 2 1278 0
 2339 0144 236B     		ldr	r3, [r4, #48]
 2340 0146 0222     		movs	r2, #2
 2341 0148 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2342 014a 9868     		ldr	r0, [r3, #8]
 2343 014c FFF7FEFF 		bl	EDMA_EnableChannelInterrupts
 2344              	.LVL230:
 2345              	.L175:
1282:../drivers/fsl_dspi_edma.c ****     {
 2346              		.loc 2 1282 0
 2347 0150 E368     		ldr	r3, [r4, #12]
 2348 0152 002B     		cmp	r3, #0
 2349 0154 33D0     		beq	.L188
1285:../drivers/fsl_dspi_edma.c **** 
 2350              		.loc 2 1285 0
 2351 0156 636B     		ldr	r3, [r4, #52]
 2352 0158 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2353 015a 9868     		ldr	r0, [r3, #8]
 2354 015c FFF7FEFF 		bl	EDMA_ResetChannel
 2355              	.LVL231:
 2356              	.LBB239:
 2357              	.LBB240:
 687:../drivers/fsl_dspi.h **** }
 2358              		.loc 3 687 0
 2359 0160 05F13403 		add	r3, r5, #52
 2360              	.LBE240:
 2361              	.LBE239:
1290:../drivers/fsl_dspi_edma.c ****         {
 2362              		.loc 2 1290 0
 2363 0164 6268     		ldr	r2, [r4, #4]
1287:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 2364              		.loc 2 1287 0
 2365 0166 0993     		str	r3, [sp, #36]
1288:../drivers/fsl_dspi_edma.c **** 
 2366              		.loc 2 1288 0
 2367 0168 0023     		movs	r3, #0
 2368 016a ADF82C30 		strh	r3, [sp, #44]	@ movhi
 2369 016e 2368     		ldr	r3, [r4]
1290:../drivers/fsl_dspi_edma.c ****         {
 2370              		.loc 2 1290 0
 2371 0170 002A     		cmp	r2, #0
 2372 0172 00F0B980 		beq	.L189
1292:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 1;
 2373              		.loc 2 1292 0
 2374 0176 6268     		ldr	r2, [r4, #4]
 2375 0178 0892     		str	r2, [sp, #32]
1293:../drivers/fsl_dspi_edma.c ****         }
 2376              		.loc 2 1293 0
 2377 017a 0122     		movs	r2, #1
 2378 017c ADF82A20 		strh	r2, [sp, #42]	@ movhi
 2379              	.LVL232:
 2380              	.L190:
1311:../drivers/fsl_dspi_edma.c ****         {
 2381              		.loc 2 1311 0
 2382 0180 082B     		cmp	r3, #8
 2383 0182 4FF00103 		mov	r3, #1
1319:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 2;
 2384              		.loc 2 1319 0
 2385 0186 81BF     		itttt	hi
 2386 0188 8DF82930 		strbhi	r3, [sp, #41]
1320:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount / 2;
 2387              		.loc 2 1320 0
 2388 018c 0223     		movhi	r3, #2
 2389 018e 0C93     		strhi	r3, [sp, #48]
1321:../drivers/fsl_dspi_edma.c ****         }
 2390              		.loc 2 1321 0
 2391 0190 E368     		ldrhi	r3, [r4, #12]
1314:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount;
 2392              		.loc 2 1314 0
 2393 0192 96BF     		itet	ls
 2394 0194 0C93     		strls	r3, [sp, #48]
1321:../drivers/fsl_dspi_edma.c ****         }
 2395              		.loc 2 1321 0
 2396 0196 5B08     		lsrhi	r3, r3, #1
1315:../drivers/fsl_dspi_edma.c ****         }
 2397              		.loc 2 1315 0
 2398 0198 E368     		ldrls	r3, [r4, #12]
1324:../drivers/fsl_dspi_edma.c ****                                &transferConfigC, NULL);
 2399              		.loc 2 1324 0
 2400 019a 606B     		ldr	r0, [r4, #52]
1321:../drivers/fsl_dspi_edma.c ****         }
 2401              		.loc 2 1321 0
 2402 019c 0D93     		str	r3, [sp, #52]
1309:../drivers/fsl_dspi_edma.c **** 
 2403              		.loc 2 1309 0
 2404 019e 4FF00002 		mov	r2, #0
 2405 01a2 8DF82820 		strb	r2, [sp, #40]
1313:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 1;
 2406              		.loc 2 1313 0
 2407 01a6 98BF     		it	ls
 2408 01a8 8DF82920 		strbls	r2, [sp, #41]
1324:../drivers/fsl_dspi_edma.c ****                                &transferConfigC, NULL);
 2409              		.loc 2 1324 0
 2410 01ac 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 2411 01ae 8068     		ldr	r0, [r0, #8]
 2412 01b0 0023     		movs	r3, #0
 2413 01b2 08AA     		add	r2, sp, #32
 2414 01b4 FFF7FEFF 		bl	EDMA_SetTransferConfig
 2415              	.LVL233:
1327:../drivers/fsl_dspi_edma.c ****     }
 2416              		.loc 2 1327 0
 2417 01b8 606B     		ldr	r0, [r4, #52]
 2418 01ba FFF7FEFF 		bl	EDMA_StartTransfer
 2419              	.LVL234:
 2420              	.L188:
1330:../drivers/fsl_dspi_edma.c **** 
 2421              		.loc 2 1330 0
 2422 01be 206B     		ldr	r0, [r4, #48]
 2423 01c0 FFF7FEFF 		bl	EDMA_StartTransfer
 2424              	.LVL235:
1333:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaTxDataToTxRegHandle->channel;
 2425              		.loc 2 1333 0
 2426 01c4 D4F830C0 		ldr	ip, [r4, #48]
1334:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 2427              		.loc 2 1334 0
 2428 01c8 606B     		ldr	r0, [r4, #52]
1333:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaTxDataToTxRegHandle->channel;
 2429              		.loc 2 1333 0
 2430 01ca 9CF81010 		ldrb	r1, [ip, #16]	@ zero_extendqisi2
 2431              	.LVL236:
1334:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 2432              		.loc 2 1334 0
 2433 01ce 037C     		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 2434              	.LVL237:
1337:../drivers/fsl_dspi_edma.c ****     {
 2435              		.loc 2 1337 0
 2436 01d0 9942     		cmp	r1, r3
 2437 01d2 94BF     		ite	ls
 2438 01d4 0A46     		movls	r2, r1
 2439 01d6 1A46     		movhi	r2, r3
1347:../drivers/fsl_dspi_edma.c **** 
 2440              		.loc 2 1347 0
 2441 01d8 8DF80620 		strb	r2, [sp, #6]
1349:../drivers/fsl_dspi_edma.c ****     {
 2442              		.loc 2 1349 0
 2443 01dc 3D4A     		ldr	r2, .L229
 2444              	.LVL238:
1345:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 2445              		.loc 2 1345 0
 2446 01de 4FF00106 		mov	r6, #1
1337:../drivers/fsl_dspi_edma.c ****     {
 2447              		.loc 2 1337 0
 2448 01e2 94BF     		ite	ls
 2449 01e4 1F46     		movls	r7, r3
 2450 01e6 0F46     		movhi	r7, r1
 2451              	.LVL239:
1349:../drivers/fsl_dspi_edma.c ****     {
 2452              		.loc 2 1349 0
 2453 01e8 9542     		cmp	r5, r2
1345:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 2454              		.loc 2 1345 0
 2455 01ea 8DF80460 		strb	r6, [sp, #4]
1346:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
 2456              		.loc 2 1346 0
 2457 01ee 8DF80560 		strb	r6, [sp, #5]
1351:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2458              		.loc 2 1351 0
 2459 01f2 01AA     		add	r2, sp, #4
 2460              	.LVL240:
1349:../drivers/fsl_dspi_edma.c ****     {
 2461              		.loc 2 1349 0
 2462 01f4 00F08380 		beq	.L195
1351:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2463              		.loc 2 1351 0
 2464 01f8 DCF80800 		ldr	r0, [ip, #8]
 2465 01fc FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2466              	.LVL241:
1355:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2467              		.loc 2 1355 0
 2468 0200 636B     		ldr	r3, [r4, #52]
1354:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataTo
 2469              		.loc 2 1354 0
 2470 0202 8DF80670 		strb	r7, [sp, #6]
1355:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2471              		.loc 2 1355 0
 2472 0206 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2473 0208 9868     		ldr	r0, [r3, #8]
 2474 020a 01AA     		add	r2, sp, #4
 2475 020c FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2476              	.LVL242:
1375:../drivers/fsl_dspi_edma.c ****         {
 2477              		.loc 2 1375 0
 2478 0210 E368     		ldr	r3, [r4, #12]
 2479 0212 3BB1     		cbz	r3, .L197
1378:../drivers/fsl_dspi_edma.c ****         }
 2480              		.loc 2 1378 0
 2481 0214 D4E90C03 		ldrd	r0, r3, [r4, #48]
1377:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToTxRegHandle->channel);
 2482              		.loc 2 1377 0
 2483 0218 3246     		mov	r2, r6
 2484 021a 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 2485 021c 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 2486 021e 8068     		ldr	r0, [r0, #8]
 2487 0220 FFF7FEFF 		bl	EDMA_SetChannelLink
 2488              	.LVL243:
 2489              	.L197:
 2490              	.LBB241:
 2491              	.LBB242:
 645:../drivers/fsl_dspi.h **** }
 2492              		.loc 3 645 0
 2493 0224 2B6B     		ldr	r3, [r5, #48]
 2494 0226 79E0     		b	.L228
 2495              	.LVL244:
 2496              	.L171:
 2497              	.LBE242:
 2498              	.LBE241:
1131:../drivers/fsl_dspi_edma.c ****     {
 2499              		.loc 2 1131 0 discriminator 1
 2500 0228 B368     		ldr	r3, [r6, #8]
 2501 022a D907     		lsls	r1, r3, #31
 2502              	.LVL245:
 2503 022c 7FF524AF 		bpl	.L172
1133:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 2504              		.loc 2 1133 0
 2505 0230 0023     		movs	r3, #0
 2506 0232 84F82530 		strb	r3, [r4, #37]
 2507              	.LVL246:
 2508              	.L199:
1078:../drivers/fsl_dspi_edma.c ****     }
 2509              		.loc 2 1078 0
 2510 0236 0420     		movs	r0, #4
 2511 0238 1AE7     		b	.L166
 2512              	.LVL247:
 2513              	.L173:
1175:../drivers/fsl_dspi_edma.c ****         {
 2514              		.loc 2 1175 0
 2515 023a 2368     		ldr	r3, [r4]
 2516              	.LVL248:
 2517 023c 082B     		cmp	r3, #8
 2518 023e 40D9     		bls	.L202
1189:../drivers/fsl_dspi_edma.c ****                 }
 2519              		.loc 2 1189 0
 2520 0240 46EA0620 		orr	r0, r6, r6, lsl #8
 2521 0244 0221     		movs	r1, #2
 2522              	.LBB244:
 2523              	.LBB245:
 580:../drivers/fsl_dspi.h **** }
 2524              		.loc 3 580 0
 2525 0246 4FF00077 		mov	r7, #33554432
 2526              	.LVL249:
 2527              	.L177:
 2528              	.LBE245:
 2529              	.LBE244:
 2530              	.LBB247:
 2531              	.LBB248:
 561:../drivers/fsl_dspi.h **** }
 2532              		.loc 3 561 0
 2533 024a EB6A     		ldr	r3, [r5, #44]
 2534              	.LVL250:
 2535              	.LBE248:
 2536              	.LBE247:
1177:../drivers/fsl_dspi_edma.c ****             {
 2537              		.loc 2 1177 0
 2538 024c 9A01     		lsls	r2, r3, #6
 2539 024e 7FF542AF 		bpl	.L179
1179:../drivers/fsl_dspi_edma.c ****                 {
 2540              		.loc 2 1179 0
 2541 0252 6368     		ldr	r3, [r4, #4]
 2542 0254 CBB1     		cbz	r3, .L203
1181:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
 2543              		.loc 2 1181 0
 2544 0256 6368     		ldr	r3, [r4, #4]
1182:../drivers/fsl_dspi_edma.c **** 
 2545              		.loc 2 1182 0
 2546 0258 6268     		ldr	r2, [r4, #4]
1181:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
 2547              		.loc 2 1181 0
 2548 025a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2549              	.LVL251:
1182:../drivers/fsl_dspi_edma.c **** 
 2550              		.loc 2 1182 0
 2551 025c 0132     		adds	r2, r2, #1
 2552 025e 6260     		str	r2, [r4, #4]
1184:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
 2553              		.loc 2 1184 0
 2554 0260 6268     		ldr	r2, [r4, #4]
 2555 0262 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 2556 0264 43EA0223 		orr	r3, r3, r2, lsl #8
 2557              	.LVL252:
1185:../drivers/fsl_dspi_edma.c ****                 }
 2558              		.loc 2 1185 0
 2559 0268 6268     		ldr	r2, [r4, #4]
 2560 026a 0132     		adds	r2, r2, #1
 2561 026c 6260     		str	r2, [r4, #4]
 2562              	.LVL253:
 2563              	.L178:
1191:../drivers/fsl_dspi_edma.c ****                 base->PUSHR_SLAVE = wordToSend;
 2564              		.loc 2 1191 0
 2565 026e E268     		ldr	r2, [r4, #12]
 2566 0270 023A     		subs	r2, r2, #2
 2567 0272 E260     		str	r2, [r4, #12]
1192:../drivers/fsl_dspi_edma.c **** 
 2568              		.loc 2 1192 0
 2569 0274 6B63     		str	r3, [r5, #52]
 2570              	.LVL254:
 2571              	.LBB249:
 2572              	.LBB246:
 580:../drivers/fsl_dspi.h **** }
 2573              		.loc 3 580 0
 2574 0276 EF62     		str	r7, [r5, #44]
 2575              	.LVL255:
 2576              	.LBE246:
 2577              	.LBE249:
1200:../drivers/fsl_dspi_edma.c ****                 {
 2578              		.loc 2 1200 0
 2579 0278 E368     		ldr	r3, [r4, #12]
 2580              	.LVL256:
 2581 027a 002B     		cmp	r3, #0
 2582 027c 3FF42BAF 		beq	.L179
1200:../drivers/fsl_dspi_edma.c ****                 {
 2583              		.loc 2 1200 0 is_stmt 0 discriminator 1
 2584 0280 0129     		cmp	r1, #1
 2585 0282 3FF428AF 		beq	.L179
 2586 0286 0121     		movs	r1, #1
 2587              	.LVL257:
 2588 0288 DFE7     		b	.L177
 2589              	.LVL258:
 2590              	.L203:
1189:../drivers/fsl_dspi_edma.c ****                 }
 2591              		.loc 2 1189 0 is_stmt 1
 2592 028a 0346     		mov	r3, r0
 2593 028c EFE7     		b	.L178
 2594              	.LVL259:
 2595              	.L183:
1210:../drivers/fsl_dspi_edma.c ****                 {
 2596              		.loc 2 1210 0
 2597 028e 6368     		ldr	r3, [r4, #4]
 2598 0290 ABB1     		cbz	r3, .L181
1212:../drivers/fsl_dspi_edma.c ****                     /* Increment to next data word*/
 2599              		.loc 2 1212 0
 2600 0292 6368     		ldr	r3, [r4, #4]
 2601 0294 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 2602              	.LVL260:
1214:../drivers/fsl_dspi_edma.c ****                 }
 2603              		.loc 2 1214 0
 2604 0296 6368     		ldr	r3, [r4, #4]
 2605 0298 0133     		adds	r3, r3, #1
 2606 029a 6360     		str	r3, [r4, #4]
 2607              	.LVL261:
 2608              	.L182:
1221:../drivers/fsl_dspi_edma.c **** 
 2609              		.loc 2 1221 0
 2610 029c 6963     		str	r1, [r5, #52]
 2611              	.LVL262:
 2612              	.LBB250:
 2613              	.LBB251:
 580:../drivers/fsl_dspi.h **** }
 2614              		.loc 3 580 0
 2615 029e EF62     		str	r7, [r5, #44]
 2616              	.LVL263:
 2617              	.LBE251:
 2618              	.LBE250:
1226:../drivers/fsl_dspi_edma.c **** 
 2619              		.loc 2 1226 0
 2620 02a0 E368     		ldr	r3, [r4, #12]
 2621 02a2 013B     		subs	r3, r3, #1
 2622 02a4 E360     		str	r3, [r4, #12]
1231:../drivers/fsl_dspi_edma.c ****                 {
 2623              		.loc 2 1231 0
 2624 02a6 E368     		ldr	r3, [r4, #12]
 2625 02a8 002B     		cmp	r3, #0
 2626 02aa 3FF414AF 		beq	.L179
1231:../drivers/fsl_dspi_edma.c ****                 {
 2627              		.loc 2 1231 0 is_stmt 0 discriminator 1
 2628 02ae 012A     		cmp	r2, #1
 2629 02b0 3FF411AF 		beq	.L179
 2630 02b4 0122     		movs	r2, #1
 2631              	.LVL264:
 2632              	.L176:
 2633              	.LBB253:
 2634              	.LBB254:
 561:../drivers/fsl_dspi.h **** }
 2635              		.loc 3 561 0 is_stmt 1
 2636 02b6 EB6A     		ldr	r3, [r5, #44]
 2637              	.LVL265:
 2638              	.LBE254:
 2639              	.LBE253:
1208:../drivers/fsl_dspi_edma.c ****             {
 2640              		.loc 2 1208 0
 2641 02b8 9B01     		lsls	r3, r3, #6
 2642 02ba E8D4     		bmi	.L183
 2643 02bc 0BE7     		b	.L179
 2644              	.L181:
1218:../drivers/fsl_dspi_edma.c ****                 }
 2645              		.loc 2 1218 0
 2646 02be 0146     		mov	r1, r0
 2647              	.LVL266:
 2648 02c0 ECE7     		b	.L182
 2649              	.LVL267:
 2650              	.L202:
 2651 02c2 0222     		movs	r2, #2
 2652 02c4 B0B2     		uxth	r0, r6
 2653              	.LBB255:
 2654              	.LBB252:
 580:../drivers/fsl_dspi.h **** }
 2655              		.loc 3 580 0
 2656 02c6 4FF00077 		mov	r7, #33554432
 2657              	.LVL268:
 2658 02ca F4E7     		b	.L176
 2659              	.LVL269:
 2660              	.L184:
 2661              	.LBE252:
 2662              	.LBE255:
1254:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 0;
 2663              		.loc 2 1254 0
 2664 02cc 04F11802 		add	r2, r4, #24
 2665 02d0 0392     		str	r2, [sp, #12]
 2666 02d2 15E7     		b	.L223
 2667              	.L230:
 2668              		.align	2
 2669              	.L229:
 2670 02d4 00C00240 		.word	1073922048
 2671 02d8 00000000 		.word	.LANCHOR1
 2672 02dc 00000000 		.word	EDMA_DspiSlaveCallback
 2673 02e0 00000000 		.word	s_dummyData
 2674 02e4 00000ADA 		.word	-636878848
 2675              	.L189:
1299:../drivers/fsl_dspi_edma.c ****             {
 2676              		.loc 2 1299 0
 2677 02e8 082B     		cmp	r3, #8
1297:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 0;
 2678              		.loc 2 1297 0
 2679 02ea 04F11C01 		add	r1, r4, #28
1305:../drivers/fsl_dspi_edma.c ****             }
 2680              		.loc 2 1305 0
 2681 02ee 88BF     		it	hi
 2682 02f0 46EA0626 		orrhi	r6, r6, r6, lsl #8
 2683              	.LVL270:
1297:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 0;
 2684              		.loc 2 1297 0
 2685 02f4 0891     		str	r1, [sp, #32]
1298:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 2686              		.loc 2 1298 0
 2687 02f6 ADF82A20 		strh	r2, [sp, #42]	@ movhi
1305:../drivers/fsl_dspi_edma.c ****             }
 2688              		.loc 2 1305 0
 2689 02fa E661     		str	r6, [r4, #28]
 2690 02fc 40E7     		b	.L190
 2691              	.LVL271:
 2692              	.L195:
1360:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2693              		.loc 2 1360 0
 2694 02fe 1946     		mov	r1, r3
 2695 0300 8068     		ldr	r0, [r0, #8]
 2696 0302 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2697              	.LVL272:
1364:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2698              		.loc 2 1364 0
 2699 0306 236B     		ldr	r3, [r4, #48]
1363:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 2700              		.loc 2 1363 0
 2701 0308 8DF80670 		strb	r7, [sp, #6]
1364:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2702              		.loc 2 1364 0
 2703 030c 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2704 030e 9868     		ldr	r0, [r3, #8]
 2705 0310 01AA     		add	r2, sp, #4
 2706 0312 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2707              	.LVL273:
 2708              	.LBB256:
 2709              	.LBB257:
 645:../drivers/fsl_dspi.h **** }
 2710              		.loc 3 645 0
 2711 0316 2B6B     		ldr	r3, [r5, #48]
 2712 0318 43F04073 		orr	r3, r3, #50331648
 2713              	.LVL274:
 2714              	.L228:
 2715              	.LBE257:
 2716              	.LBE256:
 2717              	.LBB258:
 2718              	.LBB243:
 2719 031c 43F44033 		orr	r3, r3, #196608
 2720 0320 2B63     		str	r3, [r5, #48]
 2721              	.LBE243:
 2722              	.LBE258:
1387:../drivers/fsl_dspi_edma.c **** }
 2723              		.loc 2 1387 0
 2724 0322 0020     		movs	r0, #0
 2725 0324 A4E6     		b	.L166
 2726              	.LVL275:
 2727              	.L200:
1090:../drivers/fsl_dspi_edma.c ****     }
 2728              		.loc 2 1090 0
 2729 0326 4FF41670 		mov	r0, #600
 2730              	.LVL276:
 2731 032a A1E6     		b	.L166
 2732              		.cfi_endproc
 2733              	.LFE184:
 2735              		.section	.text.DSPI_SlaveTransferAbortEDMA,"ax",%progbits
 2736              		.align	1
 2737              		.global	DSPI_SlaveTransferAbortEDMA
 2738              		.syntax unified
 2739              		.thumb
 2740              		.thumb_func
 2741              		.fpu fpv4-sp-d16
 2743              	DSPI_SlaveTransferAbortEDMA:
 2744              	.LFB186:
1412:../drivers/fsl_dspi_edma.c **** 
1413:../drivers/fsl_dspi_edma.c **** void DSPI_SlaveTransferAbortEDMA(SPI_Type *base, dspi_slave_edma_handle_t *handle)
1414:../drivers/fsl_dspi_edma.c **** {
 2745              		.loc 2 1414 0
 2746              		.cfi_startproc
 2747              		@ args = 0, pretend = 0, frame = 0
 2748              		@ frame_needed = 0, uses_anonymous_args = 0
 2749              	.LVL277:
 2750              	.LBB259:
 2751              	.LBB260:
 753:../drivers/fsl_dspi.h **** }
 2752              		.loc 3 753 0
 2753 0000 0368     		ldr	r3, [r0]
 2754 0002 43F00103 		orr	r3, r3, #1
 2755              	.LBE260:
 2756              	.LBE259:
 2757              		.loc 2 1414 0
 2758 0006 10B5     		push	{r4, lr}
 2759              		.cfi_def_cfa_offset 8
 2760              		.cfi_offset 4, -8
 2761              		.cfi_offset 14, -4
 2762              	.LBB262:
 2763              	.LBB261:
 753:../drivers/fsl_dspi.h **** }
 2764              		.loc 3 753 0
 2765 0008 0360     		str	r3, [r0]
 2766              	.LVL278:
 2767              	.LBE261:
 2768              	.LBE262:
 2769              	.LBB263:
 2770              	.LBB264:
 661:../drivers/fsl_dspi.h **** }
 2771              		.loc 3 661 0
 2772 000a 036B     		ldr	r3, [r0, #48]
 2773 000c 23F04073 		bic	r3, r3, #50331648
 2774              	.LBE264:
 2775              	.LBE263:
 2776              		.loc 2 1414 0
 2777 0010 0C46     		mov	r4, r1
 2778              	.LBB266:
 2779              	.LBB265:
 661:../drivers/fsl_dspi.h **** }
 2780              		.loc 3 661 0
 2781 0012 23F44033 		bic	r3, r3, #196608
 2782 0016 0363     		str	r3, [r0, #48]
 2783              	.LVL279:
 2784              	.LBE265:
 2785              	.LBE266:
1415:../drivers/fsl_dspi_edma.c ****     assert(handle);
1416:../drivers/fsl_dspi_edma.c **** 
1417:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
1418:../drivers/fsl_dspi_edma.c **** 
1419:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1420:../drivers/fsl_dspi_edma.c **** 
1421:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaRxRegToRxDataHandle);
 2786              		.loc 2 1421 0
 2787 0018 086B     		ldr	r0, [r1, #48]
 2788              	.LVL280:
 2789 001a FFF7FEFF 		bl	EDMA_AbortTransfer
 2790              	.LVL281:
1422:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaTxDataToTxRegHandle);
 2791              		.loc 2 1422 0
 2792 001e 606B     		ldr	r0, [r4, #52]
 2793 0020 FFF7FEFF 		bl	EDMA_AbortTransfer
 2794              	.LVL282:
1423:../drivers/fsl_dspi_edma.c **** 
1424:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Idle;
 2795              		.loc 2 1424 0
 2796 0024 0023     		movs	r3, #0
 2797 0026 84F82530 		strb	r3, [r4, #37]
1425:../drivers/fsl_dspi_edma.c **** }
 2798              		.loc 2 1425 0
 2799 002a 10BD     		pop	{r4, pc}
 2800              		.cfi_endproc
 2801              	.LFE186:
 2803              		.section	.text.DSPI_SlaveTransferGetCountEDMA,"ax",%progbits
 2804              		.align	1
 2805              		.global	DSPI_SlaveTransferGetCountEDMA
 2806              		.syntax unified
 2807              		.thumb
 2808              		.thumb_func
 2809              		.fpu fpv4-sp-d16
 2811              	DSPI_SlaveTransferGetCountEDMA:
 2812              	.LFB187:
1426:../drivers/fsl_dspi_edma.c **** 
1427:../drivers/fsl_dspi_edma.c **** status_t DSPI_SlaveTransferGetCountEDMA(SPI_Type *base, dspi_slave_edma_handle_t *handle, size_t *c
1428:../drivers/fsl_dspi_edma.c **** {
 2813              		.loc 2 1428 0
 2814              		.cfi_startproc
 2815              		@ args = 0, pretend = 0, frame = 0
 2816              		@ frame_needed = 0, uses_anonymous_args = 0
 2817              	.LVL283:
 2818 0000 70B5     		push	{r4, r5, r6, lr}
 2819              		.cfi_def_cfa_offset 16
 2820              		.cfi_offset 4, -16
 2821              		.cfi_offset 5, -12
 2822              		.cfi_offset 6, -8
 2823              		.cfi_offset 14, -4
 2824              		.loc 2 1428 0
 2825 0002 0C46     		mov	r4, r1
1429:../drivers/fsl_dspi_edma.c ****     assert(handle);
1430:../drivers/fsl_dspi_edma.c **** 
1431:../drivers/fsl_dspi_edma.c ****     if (!count)
 2826              		.loc 2 1431 0
 2827 0004 1546     		mov	r5, r2
 2828 0006 A2B1     		cbz	r2, .L235
1432:../drivers/fsl_dspi_edma.c ****     {
1433:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1434:../drivers/fsl_dspi_edma.c ****     }
1435:../drivers/fsl_dspi_edma.c **** 
1436:../drivers/fsl_dspi_edma.c ****     /* Catch when there is not an active transfer. */
1437:../drivers/fsl_dspi_edma.c ****     if (handle->state != kDSPI_Busy)
 2829              		.loc 2 1437 0
 2830 0008 91F82530 		ldrb	r3, [r1, #37]	@ zero_extendqisi2
 2831 000c 012B     		cmp	r3, #1
 2832 000e 03D0     		beq	.L234
1438:../drivers/fsl_dspi_edma.c ****     {
1439:../drivers/fsl_dspi_edma.c ****         *count = 0;
 2833              		.loc 2 1439 0
 2834 0010 0023     		movs	r3, #0
 2835 0012 1360     		str	r3, [r2]
1440:../drivers/fsl_dspi_edma.c ****         return kStatus_NoTransferInProgress;
 2836              		.loc 2 1440 0
 2837 0014 0620     		movs	r0, #6
 2838              	.LVL284:
 2839              	.L232:
1441:../drivers/fsl_dspi_edma.c ****     }
1442:../drivers/fsl_dspi_edma.c **** 
1443:../drivers/fsl_dspi_edma.c ****     size_t bytes;
1444:../drivers/fsl_dspi_edma.c **** 
1445:../drivers/fsl_dspi_edma.c ****     bytes = (uint32_t)handle->nbytes * EDMA_GetRemainingMajorLoopCount(handle->edmaRxRegToRxDataHan
1446:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
1447:../drivers/fsl_dspi_edma.c **** 
1448:../drivers/fsl_dspi_edma.c ****     *count = handle->totalByteCount - bytes;
1449:../drivers/fsl_dspi_edma.c **** 
1450:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
1451:../drivers/fsl_dspi_edma.c **** }
 2840              		.loc 2 1451 0
 2841 0016 70BD     		pop	{r4, r5, r6, pc}
 2842              	.LVL285:
 2843              	.L234:
1445:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
 2844              		.loc 2 1445 0
 2845 0018 0B6B     		ldr	r3, [r1, #48]
 2846 001a 91F82460 		ldrb	r6, [r1, #36]	@ zero_extendqisi2
 2847 001e 9868     		ldr	r0, [r3, #8]
 2848              	.LVL286:
 2849 0020 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2850              	.LVL287:
 2851 0022 FFF7FEFF 		bl	EDMA_GetRemainingMajorLoopCount
 2852              	.LVL288:
1448:../drivers/fsl_dspi_edma.c **** 
 2853              		.loc 2 1448 0
 2854 0026 6369     		ldr	r3, [r4, #20]
 2855 0028 00FB1630 		mls	r0, r0, r6, r3
 2856              	.LVL289:
 2857 002c 2860     		str	r0, [r5]
1450:../drivers/fsl_dspi_edma.c **** }
 2858              		.loc 2 1450 0
 2859 002e 0020     		movs	r0, #0
 2860 0030 F1E7     		b	.L232
 2861              	.LVL290:
 2862              	.L235:
1433:../drivers/fsl_dspi_edma.c ****     }
 2863              		.loc 2 1433 0
 2864 0032 0420     		movs	r0, #4
 2865              	.LVL291:
 2866 0034 EFE7     		b	.L232
 2867              		.cfi_endproc
 2868              	.LFE187:
 2870              		.section	.bss.s_dspiMasterEdmaPrivateHandle,"aw",%nobits
 2871              		.align	2
 2872              		.set	.LANCHOR0,. + 0
 2875              	s_dspiMasterEdmaPrivateHandle:
 2876 0000 00000000 		.space	24
 2876      00000000 
 2876      00000000 
 2876      00000000 
 2876      00000000 
 2877              		.section	.bss.s_dspiSlaveEdmaPrivateHandle,"aw",%nobits
 2878              		.align	2
 2879              		.set	.LANCHOR1,. + 0
 2882              	s_dspiSlaveEdmaPrivateHandle:
 2883 0000 00000000 		.space	24
 2883      00000000 
 2883      00000000 
 2883      00000000 
 2883      00000000 
 2884              		.text
 2885              	.Letext0:
 2886              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 2887              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2888              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 2889              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 2890              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 2891              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 2892              		.file 10 "../CMSIS/core_cm4.h"
 2893              		.file 11 "../CMSIS/system_MK64F12.h"
 2894              		.file 12 "../CMSIS/MK64F12.h"
 2895              		.file 13 "../drivers/fsl_common.h"
 2896              		.file 14 "../drivers/fsl_clock.h"
 2897              		.file 15 "../drivers/fsl_dspi_edma.h"
 2898              		.file 16 "<built-in>"
