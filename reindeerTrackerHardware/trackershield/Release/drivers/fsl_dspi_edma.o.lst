   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_dspi_edma.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.EDMA_SetChannelPreemptionConfig,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	EDMA_SetChannelPreemptionConfig:
  25              	.LFB167:
  26              		.file 1 "../drivers/fsl_edma.h"
   1:../drivers/fsl_edma.h **** /*
   2:../drivers/fsl_edma.h ****  * The Clear BSD License
   3:../drivers/fsl_edma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_edma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_edma.h ****  * All rights reserved.
   6:../drivers/fsl_edma.h ****  *
   7:../drivers/fsl_edma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_edma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_edma.h ****  * that the following conditions are met:
  10:../drivers/fsl_edma.h ****  *
  11:../drivers/fsl_edma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_edma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_edma.h ****  *
  14:../drivers/fsl_edma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_edma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_edma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_edma.h ****  *
  18:../drivers/fsl_edma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_edma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_edma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_edma.h ****  *
  22:../drivers/fsl_edma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_edma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_edma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_edma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_edma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_edma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_edma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_edma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_edma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_edma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_edma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_edma.h ****  */
  34:../drivers/fsl_edma.h **** 
  35:../drivers/fsl_edma.h **** #ifndef _FSL_EDMA_H_
  36:../drivers/fsl_edma.h **** #define _FSL_EDMA_H_
  37:../drivers/fsl_edma.h **** 
  38:../drivers/fsl_edma.h **** #include "fsl_common.h"
  39:../drivers/fsl_edma.h **** 
  40:../drivers/fsl_edma.h **** /*!
  41:../drivers/fsl_edma.h ****  * @addtogroup edma
  42:../drivers/fsl_edma.h ****  * @{
  43:../drivers/fsl_edma.h ****  */
  44:../drivers/fsl_edma.h **** 
  45:../drivers/fsl_edma.h **** /*******************************************************************************
  46:../drivers/fsl_edma.h ****  * Definitions
  47:../drivers/fsl_edma.h ****  ******************************************************************************/
  48:../drivers/fsl_edma.h **** 
  49:../drivers/fsl_edma.h **** /*! @name Driver version */
  50:../drivers/fsl_edma.h **** /*@{*/
  51:../drivers/fsl_edma.h **** /*! @brief eDMA driver version */
  52:../drivers/fsl_edma.h **** #define FSL_EDMA_DRIVER_VERSION (MAKE_VERSION(2, 1, 2)) /*!< Version 2.1.2. */
  53:../drivers/fsl_edma.h **** /*@}*/
  54:../drivers/fsl_edma.h **** 
  55:../drivers/fsl_edma.h **** /*! @brief Compute the offset unit from DCHPRI3 */
  56:../drivers/fsl_edma.h **** #define DMA_DCHPRI_INDEX(channel) (((channel) & ~0x03U) | (3 - ((channel)&0x03U)))
  57:../drivers/fsl_edma.h **** 
  58:../drivers/fsl_edma.h **** /*! @brief Get the pointer of DCHPRIn */
  59:../drivers/fsl_edma.h **** #define DMA_DCHPRIn(base, channel) ((volatile uint8_t *)&(base->DCHPRI3))[DMA_DCHPRI_INDEX(channel)
  60:../drivers/fsl_edma.h **** 
  61:../drivers/fsl_edma.h **** /*! @brief eDMA transfer configuration */
  62:../drivers/fsl_edma.h **** typedef enum _edma_transfer_size
  63:../drivers/fsl_edma.h **** {
  64:../drivers/fsl_edma.h ****     kEDMA_TransferSize1Bytes = 0x0U,  /*!< Source/Destination data transfer size is 1 byte every ti
  65:../drivers/fsl_edma.h ****     kEDMA_TransferSize2Bytes = 0x1U,  /*!< Source/Destination data transfer size is 2 bytes every t
  66:../drivers/fsl_edma.h ****     kEDMA_TransferSize4Bytes = 0x2U,  /*!< Source/Destination data transfer size is 4 bytes every t
  67:../drivers/fsl_edma.h ****     kEDMA_TransferSize16Bytes = 0x4U, /*!< Source/Destination data transfer size is 16 bytes every 
  68:../drivers/fsl_edma.h ****     kEDMA_TransferSize32Bytes = 0x5U, /*!< Source/Destination data transfer size is 32 bytes every 
  69:../drivers/fsl_edma.h **** } edma_transfer_size_t;
  70:../drivers/fsl_edma.h **** 
  71:../drivers/fsl_edma.h **** /*! @brief eDMA modulo configuration */
  72:../drivers/fsl_edma.h **** typedef enum _edma_modulo
  73:../drivers/fsl_edma.h **** {
  74:../drivers/fsl_edma.h ****     kEDMA_ModuloDisable = 0x0U, /*!< Disable modulo */
  75:../drivers/fsl_edma.h ****     kEDMA_Modulo2bytes,         /*!< Circular buffer size is 2 bytes. */
  76:../drivers/fsl_edma.h ****     kEDMA_Modulo4bytes,         /*!< Circular buffer size is 4 bytes. */
  77:../drivers/fsl_edma.h ****     kEDMA_Modulo8bytes,         /*!< Circular buffer size is 8 bytes. */
  78:../drivers/fsl_edma.h ****     kEDMA_Modulo16bytes,        /*!< Circular buffer size is 16 bytes. */
  79:../drivers/fsl_edma.h ****     kEDMA_Modulo32bytes,        /*!< Circular buffer size is 32 bytes. */
  80:../drivers/fsl_edma.h ****     kEDMA_Modulo64bytes,        /*!< Circular buffer size is 64 bytes. */
  81:../drivers/fsl_edma.h ****     kEDMA_Modulo128bytes,       /*!< Circular buffer size is 128 bytes. */
  82:../drivers/fsl_edma.h ****     kEDMA_Modulo256bytes,       /*!< Circular buffer size is 256 bytes. */
  83:../drivers/fsl_edma.h ****     kEDMA_Modulo512bytes,       /*!< Circular buffer size is 512 bytes. */
  84:../drivers/fsl_edma.h ****     kEDMA_Modulo1Kbytes,        /*!< Circular buffer size is 1 K bytes. */
  85:../drivers/fsl_edma.h ****     kEDMA_Modulo2Kbytes,        /*!< Circular buffer size is 2 K bytes. */
  86:../drivers/fsl_edma.h ****     kEDMA_Modulo4Kbytes,        /*!< Circular buffer size is 4 K bytes. */
  87:../drivers/fsl_edma.h ****     kEDMA_Modulo8Kbytes,        /*!< Circular buffer size is 8 K bytes. */
  88:../drivers/fsl_edma.h ****     kEDMA_Modulo16Kbytes,       /*!< Circular buffer size is 16 K bytes. */
  89:../drivers/fsl_edma.h ****     kEDMA_Modulo32Kbytes,       /*!< Circular buffer size is 32 K bytes. */
  90:../drivers/fsl_edma.h ****     kEDMA_Modulo64Kbytes,       /*!< Circular buffer size is 64 K bytes. */
  91:../drivers/fsl_edma.h ****     kEDMA_Modulo128Kbytes,      /*!< Circular buffer size is 128 K bytes. */
  92:../drivers/fsl_edma.h ****     kEDMA_Modulo256Kbytes,      /*!< Circular buffer size is 256 K bytes. */
  93:../drivers/fsl_edma.h ****     kEDMA_Modulo512Kbytes,      /*!< Circular buffer size is 512 K bytes. */
  94:../drivers/fsl_edma.h ****     kEDMA_Modulo1Mbytes,        /*!< Circular buffer size is 1 M bytes. */
  95:../drivers/fsl_edma.h ****     kEDMA_Modulo2Mbytes,        /*!< Circular buffer size is 2 M bytes. */
  96:../drivers/fsl_edma.h ****     kEDMA_Modulo4Mbytes,        /*!< Circular buffer size is 4 M bytes. */
  97:../drivers/fsl_edma.h ****     kEDMA_Modulo8Mbytes,        /*!< Circular buffer size is 8 M bytes. */
  98:../drivers/fsl_edma.h ****     kEDMA_Modulo16Mbytes,       /*!< Circular buffer size is 16 M bytes. */
  99:../drivers/fsl_edma.h ****     kEDMA_Modulo32Mbytes,       /*!< Circular buffer size is 32 M bytes. */
 100:../drivers/fsl_edma.h ****     kEDMA_Modulo64Mbytes,       /*!< Circular buffer size is 64 M bytes. */
 101:../drivers/fsl_edma.h ****     kEDMA_Modulo128Mbytes,      /*!< Circular buffer size is 128 M bytes. */
 102:../drivers/fsl_edma.h ****     kEDMA_Modulo256Mbytes,      /*!< Circular buffer size is 256 M bytes. */
 103:../drivers/fsl_edma.h ****     kEDMA_Modulo512Mbytes,      /*!< Circular buffer size is 512 M bytes. */
 104:../drivers/fsl_edma.h ****     kEDMA_Modulo1Gbytes,        /*!< Circular buffer size is 1 G bytes. */
 105:../drivers/fsl_edma.h ****     kEDMA_Modulo2Gbytes,        /*!< Circular buffer size is 2 G bytes. */
 106:../drivers/fsl_edma.h **** } edma_modulo_t;
 107:../drivers/fsl_edma.h **** 
 108:../drivers/fsl_edma.h **** /*! @brief Bandwidth control */
 109:../drivers/fsl_edma.h **** typedef enum _edma_bandwidth
 110:../drivers/fsl_edma.h **** {
 111:../drivers/fsl_edma.h ****     kEDMA_BandwidthStallNone = 0x0U,   /*!< No eDMA engine stalls. */
 112:../drivers/fsl_edma.h ****     kEDMA_BandwidthStall4Cycle = 0x2U, /*!< eDMA engine stalls for 4 cycles after each read/write. 
 113:../drivers/fsl_edma.h ****     kEDMA_BandwidthStall8Cycle = 0x3U, /*!< eDMA engine stalls for 8 cycles after each read/write. 
 114:../drivers/fsl_edma.h **** } edma_bandwidth_t;
 115:../drivers/fsl_edma.h **** 
 116:../drivers/fsl_edma.h **** /*! @brief Channel link type */
 117:../drivers/fsl_edma.h **** typedef enum _edma_channel_link_type
 118:../drivers/fsl_edma.h **** {
 119:../drivers/fsl_edma.h ****     kEDMA_LinkNone = 0x0U, /*!< No channel link  */
 120:../drivers/fsl_edma.h ****     kEDMA_MinorLink,       /*!< Channel link after each minor loop */
 121:../drivers/fsl_edma.h ****     kEDMA_MajorLink,       /*!< Channel link while major loop count exhausted */
 122:../drivers/fsl_edma.h **** } edma_channel_link_type_t;
 123:../drivers/fsl_edma.h **** 
 124:../drivers/fsl_edma.h **** /*!@brief eDMA channel status flags. */
 125:../drivers/fsl_edma.h **** enum _edma_channel_status_flags
 126:../drivers/fsl_edma.h **** {
 127:../drivers/fsl_edma.h ****     kEDMA_DoneFlag = 0x1U,      /*!< DONE flag, set while transfer finished, CITER value exhausted*
 128:../drivers/fsl_edma.h ****     kEDMA_ErrorFlag = 0x2U,     /*!< eDMA error flag, an error occurred in a transfer */
 129:../drivers/fsl_edma.h ****     kEDMA_InterruptFlag = 0x4U, /*!< eDMA interrupt flag, set while an interrupt occurred of this c
 130:../drivers/fsl_edma.h **** };
 131:../drivers/fsl_edma.h **** 
 132:../drivers/fsl_edma.h **** /*! @brief eDMA channel error status flags. */
 133:../drivers/fsl_edma.h **** enum _edma_error_status_flags
 134:../drivers/fsl_edma.h **** {
 135:../drivers/fsl_edma.h ****     kEDMA_DestinationBusErrorFlag = DMA_ES_DBE_MASK,    /*!< Bus error on destination address */
 136:../drivers/fsl_edma.h ****     kEDMA_SourceBusErrorFlag = DMA_ES_SBE_MASK,         /*!< Bus error on the source address */
 137:../drivers/fsl_edma.h ****     kEDMA_ScatterGatherErrorFlag = DMA_ES_SGE_MASK,     /*!< Error on the Scatter/Gather address, n
 138:../drivers/fsl_edma.h ****     kEDMA_NbytesErrorFlag = DMA_ES_NCE_MASK,            /*!< NBYTES/CITER configuration error */
 139:../drivers/fsl_edma.h ****     kEDMA_DestinationOffsetErrorFlag = DMA_ES_DOE_MASK, /*!< Destination offset not aligned with de
 140:../drivers/fsl_edma.h ****     kEDMA_DestinationAddressErrorFlag = DMA_ES_DAE_MASK, /*!< Destination address not aligned with 
 141:../drivers/fsl_edma.h ****     kEDMA_SourceOffsetErrorFlag = DMA_ES_SOE_MASK,       /*!< Source offset not aligned with source
 142:../drivers/fsl_edma.h ****     kEDMA_SourceAddressErrorFlag = DMA_ES_SAE_MASK,      /*!< Source address not aligned with sourc
 143:../drivers/fsl_edma.h ****     kEDMA_ErrorChannelFlag = DMA_ES_ERRCHN_MASK,         /*!< Error channel number of the cancelled
 144:../drivers/fsl_edma.h ****     kEDMA_ChannelPriorityErrorFlag = DMA_ES_CPE_MASK,    /*!< Channel priority is not unique. */
 145:../drivers/fsl_edma.h ****     kEDMA_TransferCanceledFlag = DMA_ES_ECX_MASK,        /*!< Transfer cancelled */
 146:../drivers/fsl_edma.h **** #if defined(FSL_FEATURE_EDMA_CHANNEL_GROUP_COUNT) && FSL_FEATURE_EDMA_CHANNEL_GROUP_COUNT > 1
 147:../drivers/fsl_edma.h ****     kEDMA_GroupPriorityErrorFlag = DMA_ES_GPE_MASK, /*!< Group priority is not unique. */
 148:../drivers/fsl_edma.h **** #endif
 149:../drivers/fsl_edma.h ****     kEDMA_ValidFlag = DMA_ES_VLD_MASK, /*!< No error occurred, this bit is 0. Otherwise, it is 1. *
 150:../drivers/fsl_edma.h **** };
 151:../drivers/fsl_edma.h **** 
 152:../drivers/fsl_edma.h **** /*! @brief eDMA interrupt source */
 153:../drivers/fsl_edma.h **** typedef enum _edma_interrupt_enable
 154:../drivers/fsl_edma.h **** {
 155:../drivers/fsl_edma.h ****     kEDMA_ErrorInterruptEnable = 0x1U,                  /*!< Enable interrupt while channel error o
 156:../drivers/fsl_edma.h ****     kEDMA_MajorInterruptEnable = DMA_CSR_INTMAJOR_MASK, /*!< Enable interrupt while major count exh
 157:../drivers/fsl_edma.h ****     kEDMA_HalfInterruptEnable = DMA_CSR_INTHALF_MASK,   /*!< Enable interrupt while major count to 
 158:../drivers/fsl_edma.h **** } edma_interrupt_enable_t;
 159:../drivers/fsl_edma.h **** 
 160:../drivers/fsl_edma.h **** /*! @brief eDMA transfer type */
 161:../drivers/fsl_edma.h **** typedef enum _edma_transfer_type
 162:../drivers/fsl_edma.h **** {
 163:../drivers/fsl_edma.h ****     kEDMA_MemoryToMemory = 0x0U, /*!< Transfer from memory to memory */
 164:../drivers/fsl_edma.h ****     kEDMA_PeripheralToMemory,    /*!< Transfer from peripheral to memory */
 165:../drivers/fsl_edma.h ****     kEDMA_MemoryToPeripheral,    /*!< Transfer from memory to peripheral */
 166:../drivers/fsl_edma.h **** } edma_transfer_type_t;
 167:../drivers/fsl_edma.h **** 
 168:../drivers/fsl_edma.h **** /*! @brief eDMA transfer status */
 169:../drivers/fsl_edma.h **** enum _edma_transfer_status
 170:../drivers/fsl_edma.h **** {
 171:../drivers/fsl_edma.h ****     kStatus_EDMA_QueueFull = MAKE_STATUS(kStatusGroup_EDMA, 0), /*!< TCD queue is full. */
 172:../drivers/fsl_edma.h ****     kStatus_EDMA_Busy = MAKE_STATUS(kStatusGroup_EDMA, 1),      /*!< Channel is busy and can't hand
 173:../drivers/fsl_edma.h ****                                                                      transfer request. */
 174:../drivers/fsl_edma.h **** };
 175:../drivers/fsl_edma.h **** 
 176:../drivers/fsl_edma.h **** /*! @brief eDMA global configuration structure.*/
 177:../drivers/fsl_edma.h **** typedef struct _edma_config
 178:../drivers/fsl_edma.h **** {
 179:../drivers/fsl_edma.h ****     bool enableContinuousLinkMode;    /*!< Enable (true) continuous link mode. Upon minor loop comp
 180:../drivers/fsl_edma.h ****                                            activates again if that channel has a minor loop channel
 181:../drivers/fsl_edma.h ****                                            the link channel is itself. */
 182:../drivers/fsl_edma.h ****     bool enableHaltOnError;           /*!< Enable (true) transfer halt on error. Any error causes t
 183:../drivers/fsl_edma.h ****                                            Subsequently, all service requests are ignored until the
 184:../drivers/fsl_edma.h ****     bool enableRoundRobinArbitration; /*!< Enable (true) round robin channel arbitration method or 
 185:../drivers/fsl_edma.h ****                                            arbitration is used for channel selection */
 186:../drivers/fsl_edma.h ****     bool enableDebugMode; /*!< Enable(true) eDMA debug mode. When in debug mode, the eDMA stalls th
 187:../drivers/fsl_edma.h ****                                a new channel. Executing channels are allowed to complete. */
 188:../drivers/fsl_edma.h **** } edma_config_t;
 189:../drivers/fsl_edma.h **** 
 190:../drivers/fsl_edma.h **** /*!
 191:../drivers/fsl_edma.h ****  * @brief eDMA transfer configuration
 192:../drivers/fsl_edma.h ****  *
 193:../drivers/fsl_edma.h ****  * This structure configures the source/destination transfer attribute.
 194:../drivers/fsl_edma.h ****  */
 195:../drivers/fsl_edma.h **** typedef struct _edma_transfer_config
 196:../drivers/fsl_edma.h **** {
 197:../drivers/fsl_edma.h ****     uint32_t srcAddr;                      /*!< Source data address. */
 198:../drivers/fsl_edma.h ****     uint32_t destAddr;                     /*!< Destination data address. */
 199:../drivers/fsl_edma.h ****     edma_transfer_size_t srcTransferSize;  /*!< Source data transfer size. */
 200:../drivers/fsl_edma.h ****     edma_transfer_size_t destTransferSize; /*!< Destination data transfer size. */
 201:../drivers/fsl_edma.h ****     int16_t srcOffset;                     /*!< Sign-extended offset applied to the current source 
 202:../drivers/fsl_edma.h ****                                                 form the next-state value as each source read is co
 203:../drivers/fsl_edma.h ****     int16_t destOffset;                    /*!< Sign-extended offset applied to the current destina
 204:../drivers/fsl_edma.h ****                                                 form the next-state value as each destination write
 205:../drivers/fsl_edma.h ****     uint32_t minorLoopBytes;               /*!< Bytes to transfer in a minor loop*/
 206:../drivers/fsl_edma.h ****     uint32_t majorLoopCounts;              /*!< Major loop iteration count. */
 207:../drivers/fsl_edma.h **** } edma_transfer_config_t;
 208:../drivers/fsl_edma.h **** 
 209:../drivers/fsl_edma.h **** /*! @brief eDMA channel priority configuration */
 210:../drivers/fsl_edma.h **** typedef struct _edma_channel_Preemption_config
 211:../drivers/fsl_edma.h **** {
 212:../drivers/fsl_edma.h ****     bool enableChannelPreemption; /*!< If true: a channel can be suspended by other channel with hi
 213:../drivers/fsl_edma.h ****     bool enablePreemptAbility;    /*!< If true: a channel can suspend other channel with low priori
 214:../drivers/fsl_edma.h ****     uint8_t channelPriority;      /*!< Channel priority */
 215:../drivers/fsl_edma.h **** } edma_channel_Preemption_config_t;
 216:../drivers/fsl_edma.h **** 
 217:../drivers/fsl_edma.h **** /*! @brief eDMA minor offset configuration */
 218:../drivers/fsl_edma.h **** typedef struct _edma_minor_offset_config
 219:../drivers/fsl_edma.h **** {
 220:../drivers/fsl_edma.h ****     bool enableSrcMinorOffset;  /*!< Enable(true) or Disable(false) source minor loop offset. */
 221:../drivers/fsl_edma.h ****     bool enableDestMinorOffset; /*!< Enable(true) or Disable(false) destination minor loop offset. 
 222:../drivers/fsl_edma.h ****     uint32_t minorOffset;       /*!< Offset for a minor loop mapping. */
 223:../drivers/fsl_edma.h **** } edma_minor_offset_config_t;
 224:../drivers/fsl_edma.h **** 
 225:../drivers/fsl_edma.h **** /*!
 226:../drivers/fsl_edma.h ****  * @brief eDMA TCD.
 227:../drivers/fsl_edma.h ****  *
 228:../drivers/fsl_edma.h ****  * This structure is same as TCD register which is described in reference manual,
 229:../drivers/fsl_edma.h ****  * and is used to configure the scatter/gather feature as a next hardware TCD.
 230:../drivers/fsl_edma.h ****  */
 231:../drivers/fsl_edma.h **** typedef struct _edma_tcd
 232:../drivers/fsl_edma.h **** {
 233:../drivers/fsl_edma.h ****     __IO uint32_t SADDR;     /*!< SADDR register, used to save source address */
 234:../drivers/fsl_edma.h ****     __IO uint16_t SOFF;      /*!< SOFF register, save offset bytes every transfer */
 235:../drivers/fsl_edma.h ****     __IO uint16_t ATTR;      /*!< ATTR register, source/destination transfer size and modulo */
 236:../drivers/fsl_edma.h ****     __IO uint32_t NBYTES;    /*!< Nbytes register, minor loop length in bytes */
 237:../drivers/fsl_edma.h ****     __IO uint32_t SLAST;     /*!< SLAST register */
 238:../drivers/fsl_edma.h ****     __IO uint32_t DADDR;     /*!< DADDR register, used for destination address */
 239:../drivers/fsl_edma.h ****     __IO uint16_t DOFF;      /*!< DOFF register, used for destination offset */
 240:../drivers/fsl_edma.h ****     __IO uint16_t CITER;     /*!< CITER register, current minor loop numbers, for unfinished minor 
 241:../drivers/fsl_edma.h ****     __IO uint32_t DLAST_SGA; /*!< DLASTSGA register, next stcd address used in scatter-gather mode 
 242:../drivers/fsl_edma.h ****     __IO uint16_t CSR;       /*!< CSR register, for TCD control status */
 243:../drivers/fsl_edma.h ****     __IO uint16_t BITER;     /*!< BITER register, begin minor loop count. */
 244:../drivers/fsl_edma.h **** } edma_tcd_t;
 245:../drivers/fsl_edma.h **** 
 246:../drivers/fsl_edma.h **** /*! @brief Callback for eDMA */
 247:../drivers/fsl_edma.h **** struct _edma_handle;
 248:../drivers/fsl_edma.h **** 
 249:../drivers/fsl_edma.h **** /*! @brief Define callback function for eDMA. */
 250:../drivers/fsl_edma.h **** typedef void (*edma_callback)(struct _edma_handle *handle, void *userData, bool transferDone, uint3
 251:../drivers/fsl_edma.h **** 
 252:../drivers/fsl_edma.h **** /*! @brief eDMA transfer handle structure */
 253:../drivers/fsl_edma.h **** typedef struct _edma_handle
 254:../drivers/fsl_edma.h **** {
 255:../drivers/fsl_edma.h ****     edma_callback callback; /*!< Callback function for major count exhausted. */
 256:../drivers/fsl_edma.h ****     void *userData;         /*!< Callback function parameter. */
 257:../drivers/fsl_edma.h ****     DMA_Type *base;         /*!< eDMA peripheral base address. */
 258:../drivers/fsl_edma.h ****     edma_tcd_t *tcdPool;    /*!< Pointer to memory stored TCDs. */
 259:../drivers/fsl_edma.h ****     uint8_t channel;        /*!< eDMA channel number. */
 260:../drivers/fsl_edma.h ****     volatile int8_t header; /*!< The first TCD index. Should point to the next TCD to be loaded int
 261:../drivers/fsl_edma.h ****     volatile int8_t tail;   /*!< The last TCD index. Should point to the next TCD to be stored into
 262:../drivers/fsl_edma.h ****     volatile int8_t tcdUsed; /*!< The number of used TCD slots. Should reflect the number of TCDs c
 263:../drivers/fsl_edma.h ****                                 the memory. */
 264:../drivers/fsl_edma.h ****     volatile int8_t tcdSize; /*!< The total number of TCD slots in the queue. */
 265:../drivers/fsl_edma.h ****     uint8_t flags;           /*!< The status of the current channel. */
 266:../drivers/fsl_edma.h **** } edma_handle_t;
 267:../drivers/fsl_edma.h **** 
 268:../drivers/fsl_edma.h **** /*******************************************************************************
 269:../drivers/fsl_edma.h ****  * APIs
 270:../drivers/fsl_edma.h ****  ******************************************************************************/
 271:../drivers/fsl_edma.h **** #if defined(__cplusplus)
 272:../drivers/fsl_edma.h **** extern "C" {
 273:../drivers/fsl_edma.h **** #endif /* __cplusplus */
 274:../drivers/fsl_edma.h **** 
 275:../drivers/fsl_edma.h **** /*!
 276:../drivers/fsl_edma.h ****  * @name eDMA initialization and de-initialization
 277:../drivers/fsl_edma.h ****  * @{
 278:../drivers/fsl_edma.h ****  */
 279:../drivers/fsl_edma.h **** 
 280:../drivers/fsl_edma.h **** /*!
 281:../drivers/fsl_edma.h ****  * @brief Initializes the eDMA peripheral.
 282:../drivers/fsl_edma.h ****  *
 283:../drivers/fsl_edma.h ****  * This function ungates the eDMA clock and configures the eDMA peripheral according
 284:../drivers/fsl_edma.h ****  * to the configuration structure.
 285:../drivers/fsl_edma.h ****  *
 286:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 287:../drivers/fsl_edma.h ****  * @param config A pointer to the configuration structure, see "edma_config_t".
 288:../drivers/fsl_edma.h ****  * @note This function enables the minor loop map feature.
 289:../drivers/fsl_edma.h ****  */
 290:../drivers/fsl_edma.h **** void EDMA_Init(DMA_Type *base, const edma_config_t *config);
 291:../drivers/fsl_edma.h **** 
 292:../drivers/fsl_edma.h **** /*!
 293:../drivers/fsl_edma.h ****  * @brief Deinitializes the eDMA peripheral.
 294:../drivers/fsl_edma.h ****  *
 295:../drivers/fsl_edma.h ****  * This function gates the eDMA clock.
 296:../drivers/fsl_edma.h ****  *
 297:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 298:../drivers/fsl_edma.h ****  */
 299:../drivers/fsl_edma.h **** void EDMA_Deinit(DMA_Type *base);
 300:../drivers/fsl_edma.h **** 
 301:../drivers/fsl_edma.h **** /*!
 302:../drivers/fsl_edma.h ****  * @brief Push content of TCD structure into hardware TCD register.
 303:../drivers/fsl_edma.h ****  *
 304:../drivers/fsl_edma.h ****  * @param base EDMA peripheral base address.
 305:../drivers/fsl_edma.h ****  * @param channel EDMA channel number.
 306:../drivers/fsl_edma.h ****  * @param tcd Point to TCD structure.
 307:../drivers/fsl_edma.h ****  */
 308:../drivers/fsl_edma.h **** void EDMA_InstallTCD(DMA_Type *base, uint32_t channel, edma_tcd_t *tcd);
 309:../drivers/fsl_edma.h **** 
 310:../drivers/fsl_edma.h **** /*!
 311:../drivers/fsl_edma.h ****  * @brief Gets the eDMA default configuration structure.
 312:../drivers/fsl_edma.h ****  *
 313:../drivers/fsl_edma.h ****  * This function sets the configuration structure to default values.
 314:../drivers/fsl_edma.h ****  * The default configuration is set to the following values.
 315:../drivers/fsl_edma.h ****  * @code
 316:../drivers/fsl_edma.h ****  *   config.enableContinuousLinkMode = false;
 317:../drivers/fsl_edma.h ****  *   config.enableHaltOnError = true;
 318:../drivers/fsl_edma.h ****  *   config.enableRoundRobinArbitration = false;
 319:../drivers/fsl_edma.h ****  *   config.enableDebugMode = false;
 320:../drivers/fsl_edma.h ****  * @endcode
 321:../drivers/fsl_edma.h ****  *
 322:../drivers/fsl_edma.h ****  * @param config A pointer to the eDMA configuration structure.
 323:../drivers/fsl_edma.h ****  */
 324:../drivers/fsl_edma.h **** void EDMA_GetDefaultConfig(edma_config_t *config);
 325:../drivers/fsl_edma.h **** 
 326:../drivers/fsl_edma.h **** /* @} */
 327:../drivers/fsl_edma.h **** /*!
 328:../drivers/fsl_edma.h ****  * @name eDMA Channel Operation
 329:../drivers/fsl_edma.h ****  * @{
 330:../drivers/fsl_edma.h ****  */
 331:../drivers/fsl_edma.h **** 
 332:../drivers/fsl_edma.h **** /*!
 333:../drivers/fsl_edma.h ****  * @brief Sets all TCD registers to default values.
 334:../drivers/fsl_edma.h ****  *
 335:../drivers/fsl_edma.h ****  * This function sets TCD registers for this channel to default values.
 336:../drivers/fsl_edma.h ****  *
 337:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 338:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 339:../drivers/fsl_edma.h ****  * @note This function must not be called while the channel transfer is ongoing
 340:../drivers/fsl_edma.h ****  *       or it causes unpredictable results.
 341:../drivers/fsl_edma.h ****  * @note This function enables the auto stop request feature.
 342:../drivers/fsl_edma.h ****  */
 343:../drivers/fsl_edma.h **** void EDMA_ResetChannel(DMA_Type *base, uint32_t channel);
 344:../drivers/fsl_edma.h **** 
 345:../drivers/fsl_edma.h **** /*!
 346:../drivers/fsl_edma.h ****  * @brief Configures the eDMA transfer attribute.
 347:../drivers/fsl_edma.h ****  *
 348:../drivers/fsl_edma.h ****  * This function configures the transfer attribute, including source address, destination address,
 349:../drivers/fsl_edma.h ****  * transfer size, address offset, and so on. It also configures the scatter gather feature if the
 350:../drivers/fsl_edma.h ****  * user supplies the TCD address.
 351:../drivers/fsl_edma.h ****  * Example:
 352:../drivers/fsl_edma.h ****  * @code
 353:../drivers/fsl_edma.h ****  *  edma_transfer_t config;
 354:../drivers/fsl_edma.h ****  *  edma_tcd_t tcd;
 355:../drivers/fsl_edma.h ****  *  config.srcAddr = ..;
 356:../drivers/fsl_edma.h ****  *  config.destAddr = ..;
 357:../drivers/fsl_edma.h ****  *  ...
 358:../drivers/fsl_edma.h ****  *  EDMA_SetTransferConfig(DMA0, channel, &config, &stcd);
 359:../drivers/fsl_edma.h ****  * @endcode
 360:../drivers/fsl_edma.h ****  *
 361:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 362:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 363:../drivers/fsl_edma.h ****  * @param config Pointer to eDMA transfer configuration structure.
 364:../drivers/fsl_edma.h ****  * @param nextTcd Point to TCD structure. It can be NULL if users
 365:../drivers/fsl_edma.h ****  *                do not want to enable scatter/gather feature.
 366:../drivers/fsl_edma.h ****  * @note If nextTcd is not NULL, it means scatter gather feature is enabled
 367:../drivers/fsl_edma.h ****  *       and DREQ bit is cleared in the previous transfer configuration, which
 368:../drivers/fsl_edma.h ****  *       is set in the eDMA_ResetChannel.
 369:../drivers/fsl_edma.h ****  */
 370:../drivers/fsl_edma.h **** void EDMA_SetTransferConfig(DMA_Type *base,
 371:../drivers/fsl_edma.h ****                             uint32_t channel,
 372:../drivers/fsl_edma.h ****                             const edma_transfer_config_t *config,
 373:../drivers/fsl_edma.h ****                             edma_tcd_t *nextTcd);
 374:../drivers/fsl_edma.h **** 
 375:../drivers/fsl_edma.h **** /*!
 376:../drivers/fsl_edma.h ****  * @brief Configures the eDMA minor offset feature.
 377:../drivers/fsl_edma.h ****  *
 378:../drivers/fsl_edma.h ****  * The minor offset means that the signed-extended value is added to the source address or destinat
 379:../drivers/fsl_edma.h ****  * address after each minor loop.
 380:../drivers/fsl_edma.h ****  *
 381:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 382:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 383:../drivers/fsl_edma.h ****  * @param config A pointer to the minor offset configuration structure.
 384:../drivers/fsl_edma.h ****  */
 385:../drivers/fsl_edma.h **** void EDMA_SetMinorOffsetConfig(DMA_Type *base, uint32_t channel, const edma_minor_offset_config_t *
 386:../drivers/fsl_edma.h **** 
 387:../drivers/fsl_edma.h **** /*!
 388:../drivers/fsl_edma.h ****  * @brief Configures the eDMA channel preemption feature.
 389:../drivers/fsl_edma.h ****  *
 390:../drivers/fsl_edma.h ****  * This function configures the channel preemption attribute and the priority of the channel.
 391:../drivers/fsl_edma.h ****  *
 392:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 393:../drivers/fsl_edma.h ****  * @param channel eDMA channel number
 394:../drivers/fsl_edma.h ****  * @param config A pointer to the channel preemption configuration structure.
 395:../drivers/fsl_edma.h ****  */
 396:../drivers/fsl_edma.h **** static inline void EDMA_SetChannelPreemptionConfig(DMA_Type *base,
 397:../drivers/fsl_edma.h ****                                                    uint32_t channel,
 398:../drivers/fsl_edma.h ****                                                    const edma_channel_Preemption_config_t *config)
 399:../drivers/fsl_edma.h **** {
  27              		.loc 1 399 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 10B5     		push	{r4, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 4, -8
  35              		.cfi_offset 14, -4
 400:../drivers/fsl_edma.h ****     assert(channel < FSL_FEATURE_EDMA_MODULE_CHANNEL);
 401:../drivers/fsl_edma.h ****     assert(config != NULL);
 402:../drivers/fsl_edma.h **** 
 403:../drivers/fsl_edma.h ****     DMA_DCHPRIn(base, channel) =
 404:../drivers/fsl_edma.h ****         (DMA_DCHPRI0_DPA(!config->enablePreemptAbility) | DMA_DCHPRI0_ECP(config->enableChannelPree
  36              		.loc 1 404 0
  37 0002 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
  38 0004 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
 405:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  39              		.loc 1 405 0
  40 0006 9278     		ldrb	r2, [r2, #2]	@ zero_extendqisi2
  41              	.LVL1:
 404:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  42              		.loc 1 404 0
  43 0008 002B     		cmp	r3, #0
  44              		.loc 1 405 0
  45 000a 02F00F02 		and	r2, r2, #15
 404:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  46              		.loc 1 404 0
  47 000e 0CBF     		ite	eq
  48 0010 4023     		moveq	r3, #64
  49 0012 0023     		movne	r3, #0
  50 0014 42EAC412 		orr	r2, r2, r4, lsl #7
 403:../drivers/fsl_edma.h ****         (DMA_DCHPRI0_DPA(!config->enablePreemptAbility) | DMA_DCHPRI0_ECP(config->enableChannelPree
  51              		.loc 1 403 0
  52 0018 00F58070 		add	r0, r0, #256
  53              	.LVL2:
  54 001c 81F00301 		eor	r1, r1, #3
  55              	.LVL3:
 404:../drivers/fsl_edma.h ****          DMA_DCHPRI0_CHPRI(config->channelPriority));
  56              		.loc 1 404 0
  57 0020 1343     		orrs	r3, r3, r2
  58 0022 DBB2     		uxtb	r3, r3
 403:../drivers/fsl_edma.h ****         (DMA_DCHPRI0_DPA(!config->enablePreemptAbility) | DMA_DCHPRI0_ECP(config->enableChannelPree
  59              		.loc 1 403 0
  60 0024 4354     		strb	r3, [r0, r1]
  61 0026 10BD     		pop	{r4, pc}
  62              		.cfi_endproc
  63              	.LFE167:
  65              		.section	.text.EDMA_DspiMasterCallback,"ax",%progbits
  66              		.align	1
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu fpv4-sp-d16
  72              	EDMA_DspiMasterCallback:
  73              	.LFB180:
  74              		.file 2 "../drivers/fsl_dspi_edma.c"
   1:../drivers/fsl_dspi_edma.c **** /*
   2:../drivers/fsl_dspi_edma.c ****  * The Clear BSD License
   3:../drivers/fsl_dspi_edma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dspi_edma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dspi_edma.c ****  * All rights reserved.
   6:../drivers/fsl_dspi_edma.c ****  *
   7:../drivers/fsl_dspi_edma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dspi_edma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dspi_edma.c ****  * that the following conditions are met:
  10:../drivers/fsl_dspi_edma.c ****  *
  11:../drivers/fsl_dspi_edma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dspi_edma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dspi_edma.c ****  *
  14:../drivers/fsl_dspi_edma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dspi_edma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dspi_edma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dspi_edma.c ****  *
  18:../drivers/fsl_dspi_edma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dspi_edma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dspi_edma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_dspi_edma.c ****  *
  22:../drivers/fsl_dspi_edma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dspi_edma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dspi_edma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dspi_edma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dspi_edma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dspi_edma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dspi_edma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dspi_edma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dspi_edma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dspi_edma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dspi_edma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dspi_edma.c ****  */
  34:../drivers/fsl_dspi_edma.c **** 
  35:../drivers/fsl_dspi_edma.c **** #include "fsl_dspi_edma.h"
  36:../drivers/fsl_dspi_edma.c **** 
  37:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  38:../drivers/fsl_dspi_edma.c **** * Definitons
  39:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
  40:../drivers/fsl_dspi_edma.c **** 
  41:../drivers/fsl_dspi_edma.c **** /*!
  42:../drivers/fsl_dspi_edma.c **** * @brief Structure definition for dspi_master_edma_private_handle_t. The structure is private.
  43:../drivers/fsl_dspi_edma.c **** */
  44:../drivers/fsl_dspi_edma.c **** typedef struct _dspi_master_edma_private_handle
  45:../drivers/fsl_dspi_edma.c **** {
  46:../drivers/fsl_dspi_edma.c ****     SPI_Type *base;                    /*!< DSPI peripheral base address. */
  47:../drivers/fsl_dspi_edma.c ****     dspi_master_edma_handle_t *handle; /*!< dspi_master_edma_handle_t handle */
  48:../drivers/fsl_dspi_edma.c **** } dspi_master_edma_private_handle_t;
  49:../drivers/fsl_dspi_edma.c **** 
  50:../drivers/fsl_dspi_edma.c **** /*!
  51:../drivers/fsl_dspi_edma.c **** * @brief Structure definition for dspi_slave_edma_private_handle_t. The structure is private.
  52:../drivers/fsl_dspi_edma.c **** */
  53:../drivers/fsl_dspi_edma.c **** typedef struct _dspi_slave_edma_private_handle
  54:../drivers/fsl_dspi_edma.c **** {
  55:../drivers/fsl_dspi_edma.c ****     SPI_Type *base;                   /*!< DSPI peripheral base address. */
  56:../drivers/fsl_dspi_edma.c ****     dspi_slave_edma_handle_t *handle; /*!< dspi_master_edma_handle_t handle */
  57:../drivers/fsl_dspi_edma.c **** } dspi_slave_edma_private_handle_t;
  58:../drivers/fsl_dspi_edma.c **** 
  59:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  60:../drivers/fsl_dspi_edma.c **** * Prototypes
  61:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
  62:../drivers/fsl_dspi_edma.c **** /*!
  63:../drivers/fsl_dspi_edma.c **** * @brief EDMA_DspiMasterCallback after the DSPI master transfer completed by using EDMA.
  64:../drivers/fsl_dspi_edma.c **** * This is not a public API.
  65:../drivers/fsl_dspi_edma.c **** */
  66:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiMasterCallback(edma_handle_t *edmaHandle,
  67:../drivers/fsl_dspi_edma.c ****                                     void *g_dspiEdmaPrivateHandle,
  68:../drivers/fsl_dspi_edma.c ****                                     bool transferDone,
  69:../drivers/fsl_dspi_edma.c ****                                     uint32_t tcds);
  70:../drivers/fsl_dspi_edma.c **** 
  71:../drivers/fsl_dspi_edma.c **** /*!
  72:../drivers/fsl_dspi_edma.c **** * @brief EDMA_DspiSlaveCallback after the DSPI slave transfer completed by using EDMA.
  73:../drivers/fsl_dspi_edma.c **** * This is not a public API.
  74:../drivers/fsl_dspi_edma.c **** */
  75:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiSlaveCallback(edma_handle_t *edmaHandle,
  76:../drivers/fsl_dspi_edma.c ****                                    void *g_dspiEdmaPrivateHandle,
  77:../drivers/fsl_dspi_edma.c ****                                    bool transferDone,
  78:../drivers/fsl_dspi_edma.c ****                                    uint32_t tcds);
  79:../drivers/fsl_dspi_edma.c **** /*!
  80:../drivers/fsl_dspi_edma.c **** * @brief Get instance number for DSPI module.
  81:../drivers/fsl_dspi_edma.c **** *
  82:../drivers/fsl_dspi_edma.c **** * This is not a public API and it's extern from fsl_dspi.c.
  83:../drivers/fsl_dspi_edma.c **** *
  84:../drivers/fsl_dspi_edma.c **** * @param base DSPI peripheral base address
  85:../drivers/fsl_dspi_edma.c **** */
  86:../drivers/fsl_dspi_edma.c **** extern uint32_t DSPI_GetInstance(SPI_Type *base);
  87:../drivers/fsl_dspi_edma.c **** 
  88:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  89:../drivers/fsl_dspi_edma.c **** * Variables
  90:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
  91:../drivers/fsl_dspi_edma.c **** 
  92:../drivers/fsl_dspi_edma.c **** /*! @brief Pointers to dspi edma handles for each instance. */
  93:../drivers/fsl_dspi_edma.c **** static dspi_master_edma_private_handle_t s_dspiMasterEdmaPrivateHandle[FSL_FEATURE_SOC_DSPI_COUNT];
  94:../drivers/fsl_dspi_edma.c **** static dspi_slave_edma_private_handle_t s_dspiSlaveEdmaPrivateHandle[FSL_FEATURE_SOC_DSPI_COUNT];
  95:../drivers/fsl_dspi_edma.c **** 
  96:../drivers/fsl_dspi_edma.c **** /*! @brief Global variable for dummy data value setting. */
  97:../drivers/fsl_dspi_edma.c **** extern volatile uint8_t s_dummyData[];
  98:../drivers/fsl_dspi_edma.c **** /**************************************************************************************************
  99:../drivers/fsl_dspi_edma.c **** * Code
 100:../drivers/fsl_dspi_edma.c **** ***************************************************************************************************
 101:../drivers/fsl_dspi_edma.c **** 
 102:../drivers/fsl_dspi_edma.c **** void DSPI_MasterTransferCreateHandleEDMA(SPI_Type *base,
 103:../drivers/fsl_dspi_edma.c ****                                          dspi_master_edma_handle_t *handle,
 104:../drivers/fsl_dspi_edma.c ****                                          dspi_master_edma_transfer_callback_t callback,
 105:../drivers/fsl_dspi_edma.c ****                                          void *userData,
 106:../drivers/fsl_dspi_edma.c ****                                          edma_handle_t *edmaRxRegToRxDataHandle,
 107:../drivers/fsl_dspi_edma.c ****                                          edma_handle_t *edmaTxDataToIntermediaryHandle,
 108:../drivers/fsl_dspi_edma.c ****                                          edma_handle_t *edmaIntermediaryToTxRegHandle)
 109:../drivers/fsl_dspi_edma.c **** {
 110:../drivers/fsl_dspi_edma.c ****     assert(handle);
 111:../drivers/fsl_dspi_edma.c ****     assert(edmaRxRegToRxDataHandle);
 112:../drivers/fsl_dspi_edma.c **** #if (!(defined(FSL_FEATURE_DSPI_HAS_GASKET) && FSL_FEATURE_DSPI_HAS_GASKET))
 113:../drivers/fsl_dspi_edma.c ****     assert(edmaTxDataToIntermediaryHandle);
 114:../drivers/fsl_dspi_edma.c **** #endif
 115:../drivers/fsl_dspi_edma.c ****     assert(edmaIntermediaryToTxRegHandle);
 116:../drivers/fsl_dspi_edma.c **** 
 117:../drivers/fsl_dspi_edma.c ****     /* Zero the handle. */
 118:../drivers/fsl_dspi_edma.c ****     memset(handle, 0, sizeof(*handle));
 119:../drivers/fsl_dspi_edma.c **** 
 120:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
 121:../drivers/fsl_dspi_edma.c **** 
 122:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].base = base;
 123:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].handle = handle;
 124:../drivers/fsl_dspi_edma.c **** 
 125:../drivers/fsl_dspi_edma.c ****     handle->callback = callback;
 126:../drivers/fsl_dspi_edma.c ****     handle->userData = userData;
 127:../drivers/fsl_dspi_edma.c **** 
 128:../drivers/fsl_dspi_edma.c ****     handle->edmaRxRegToRxDataHandle = edmaRxRegToRxDataHandle;
 129:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToIntermediaryHandle = edmaTxDataToIntermediaryHandle;
 130:../drivers/fsl_dspi_edma.c ****     handle->edmaIntermediaryToTxRegHandle = edmaIntermediaryToTxRegHandle;
 131:../drivers/fsl_dspi_edma.c **** }
 132:../drivers/fsl_dspi_edma.c **** 
 133:../drivers/fsl_dspi_edma.c **** status_t DSPI_MasterTransferEDMA(SPI_Type *base, dspi_master_edma_handle_t *handle, dspi_transfer_t
 134:../drivers/fsl_dspi_edma.c **** {
 135:../drivers/fsl_dspi_edma.c ****     assert(handle);
 136:../drivers/fsl_dspi_edma.c ****     assert(transfer);
 137:../drivers/fsl_dspi_edma.c **** 
 138:../drivers/fsl_dspi_edma.c ****     /* If the transfer count is zero, then return immediately.*/
 139:../drivers/fsl_dspi_edma.c ****     if (transfer->dataSize == 0)
 140:../drivers/fsl_dspi_edma.c ****     {
 141:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 142:../drivers/fsl_dspi_edma.c ****     }
 143:../drivers/fsl_dspi_edma.c **** 
 144:../drivers/fsl_dspi_edma.c ****     /* If both send buffer and receive buffer is null */
 145:../drivers/fsl_dspi_edma.c ****     if ((!(transfer->txData)) && (!(transfer->rxData)))
 146:../drivers/fsl_dspi_edma.c ****     {
 147:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 148:../drivers/fsl_dspi_edma.c ****     }
 149:../drivers/fsl_dspi_edma.c **** 
 150:../drivers/fsl_dspi_edma.c ****     /* Check that we're not busy.*/
 151:../drivers/fsl_dspi_edma.c ****     if (handle->state == kDSPI_Busy)
 152:../drivers/fsl_dspi_edma.c ****     {
 153:../drivers/fsl_dspi_edma.c ****         return kStatus_DSPI_Busy;
 154:../drivers/fsl_dspi_edma.c ****     }
 155:../drivers/fsl_dspi_edma.c **** 
 156:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Busy;
 157:../drivers/fsl_dspi_edma.c **** 
 158:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
 159:../drivers/fsl_dspi_edma.c ****     uint16_t wordToSend = 0;
 160:../drivers/fsl_dspi_edma.c ****     uint8_t dummyData = s_dummyData[DSPI_GetInstance(base)];
 161:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 162:../drivers/fsl_dspi_edma.c ****     uint8_t dataFedMax = 2;
 163:../drivers/fsl_dspi_edma.c **** 
 164:../drivers/fsl_dspi_edma.c ****     uint32_t rxAddr = DSPI_GetRxRegisterAddress(base);
 165:../drivers/fsl_dspi_edma.c ****     uint32_t txAddr = DSPI_MasterGetTxRegisterAddress(base);
 166:../drivers/fsl_dspi_edma.c **** 
 167:../drivers/fsl_dspi_edma.c ****     edma_tcd_t *softwareTCD = (edma_tcd_t *)((uint32_t)(&handle->dspiSoftwareTCD[1]) & (~0x1FU));
 168:../drivers/fsl_dspi_edma.c **** 
 169:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigA;
 170:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigB;
 171:../drivers/fsl_dspi_edma.c **** 
 172:../drivers/fsl_dspi_edma.c ****     handle->txBuffIfNull = ((uint32_t)dummyData << 8) | dummyData;
 173:../drivers/fsl_dspi_edma.c **** 
 174:../drivers/fsl_dspi_edma.c ****     dspi_command_data_config_t commandStruct;
 175:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
 176:../drivers/fsl_dspi_edma.c ****     DSPI_FlushFifo(base, true, true);
 177:../drivers/fsl_dspi_edma.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
 178:../drivers/fsl_dspi_edma.c **** 
 179:../drivers/fsl_dspi_edma.c ****     commandStruct.whichPcs =
 180:../drivers/fsl_dspi_edma.c ****         (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS
 181:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 182:../drivers/fsl_dspi_edma.c ****     commandStruct.clearTransferCount = false;
 183:../drivers/fsl_dspi_edma.c ****     commandStruct.whichCtar =
 184:../drivers/fsl_dspi_edma.c ****         (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR
 185:../drivers/fsl_dspi_edma.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 186:../drivers/fsl_dspi_edma.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 187:../drivers/fsl_dspi_edma.c **** 
 188:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = true;
 189:../drivers/fsl_dspi_edma.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer)
 190:../drivers/fsl_dspi_edma.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 191:../drivers/fsl_dspi_edma.c **** 
 192:../drivers/fsl_dspi_edma.c ****     handle->bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_
 193:../drivers/fsl_dspi_edma.c **** 
 194:../drivers/fsl_dspi_edma.c ****     if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
 195:../drivers/fsl_dspi_edma.c ****     {
 196:../drivers/fsl_dspi_edma.c ****         handle->fifoSize = 1;
 197:../drivers/fsl_dspi_edma.c ****     }
 198:../drivers/fsl_dspi_edma.c ****     else
 199:../drivers/fsl_dspi_edma.c ****     {
 200:../drivers/fsl_dspi_edma.c ****         handle->fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
 201:../drivers/fsl_dspi_edma.c ****     }
 202:../drivers/fsl_dspi_edma.c ****     handle->txData = transfer->txData;
 203:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
 204:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
 205:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 206:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
 207:../drivers/fsl_dspi_edma.c **** 
 208:../drivers/fsl_dspi_edma.c ****     /* If using a shared RX/TX DMA request, then this limits the amount of data we can transfer
 209:../drivers/fsl_dspi_edma.c ****     * due to the linked channel. The max bytes is 511 if 8-bit/frame or 1022 if 16-bit/frame
 210:../drivers/fsl_dspi_edma.c ****     */
 211:../drivers/fsl_dspi_edma.c ****     uint32_t limited_size = 0;
 212:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 213:../drivers/fsl_dspi_edma.c ****     {
 214:../drivers/fsl_dspi_edma.c ****         limited_size = 32767u;
 215:../drivers/fsl_dspi_edma.c ****     }
 216:../drivers/fsl_dspi_edma.c ****     else
 217:../drivers/fsl_dspi_edma.c ****     {
 218:../drivers/fsl_dspi_edma.c ****         limited_size = 511u;
 219:../drivers/fsl_dspi_edma.c ****     }
 220:../drivers/fsl_dspi_edma.c **** 
 221:../drivers/fsl_dspi_edma.c ****     if (handle->bitsPerFrame > 8)
 222:../drivers/fsl_dspi_edma.c ****     {
 223:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > (limited_size << 1u))
 224:../drivers/fsl_dspi_edma.c ****         {
 225:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
 226:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 227:../drivers/fsl_dspi_edma.c ****         }
 228:../drivers/fsl_dspi_edma.c ****     }
 229:../drivers/fsl_dspi_edma.c ****     else
 230:../drivers/fsl_dspi_edma.c ****     {
 231:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > limited_size)
 232:../drivers/fsl_dspi_edma.c ****         {
 233:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
 234:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 235:../drivers/fsl_dspi_edma.c ****         }
 236:../drivers/fsl_dspi_edma.c ****     }
 237:../drivers/fsl_dspi_edma.c **** 
 238:../drivers/fsl_dspi_edma.c ****     /*The data size should be even if the bitsPerFrame is greater than 8 (that is 2 bytes per frame
 239:../drivers/fsl_dspi_edma.c ****     if ((handle->bitsPerFrame > 8) && (transfer->dataSize & 0x1))
 240:../drivers/fsl_dspi_edma.c ****     {
 241:../drivers/fsl_dspi_edma.c ****         handle->state = kDSPI_Idle;
 242:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 243:../drivers/fsl_dspi_edma.c ****     }
 244:../drivers/fsl_dspi_edma.c **** 
 245:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 246:../drivers/fsl_dspi_edma.c **** 
 247:../drivers/fsl_dspi_edma.c ****     EDMA_SetCallback(handle->edmaRxRegToRxDataHandle, EDMA_DspiMasterCallback,
 248:../drivers/fsl_dspi_edma.c ****                      &s_dspiMasterEdmaPrivateHandle[instance]);
 249:../drivers/fsl_dspi_edma.c **** 
 250:../drivers/fsl_dspi_edma.c ****     /*
 251:../drivers/fsl_dspi_edma.c ****     (1)For DSPI instances with shared RX/TX DMA requests: Rx DMA request -> channel_A -> channel_B-
 252:../drivers/fsl_dspi_edma.c ****     channel_A minor link to channel_B , channel_B minor link to channel_C.
 253:../drivers/fsl_dspi_edma.c **** 
 254:../drivers/fsl_dspi_edma.c ****     Already pushed 1 or 2 data in SPI_PUSHR , then start the DMA tansfer.
 255:../drivers/fsl_dspi_edma.c ****     channel_A:SPI_POPR to rxData,
 256:../drivers/fsl_dspi_edma.c ****     channel_B:next txData to handle->command (low 16 bits),
 257:../drivers/fsl_dspi_edma.c ****     channel_C:handle->command (32 bits) to SPI_PUSHR, and use the scatter/gather to transfer the la
 258:../drivers/fsl_dspi_edma.c ****     (handle->lastCommand to SPI_PUSHR).
 259:../drivers/fsl_dspi_edma.c **** 
 260:../drivers/fsl_dspi_edma.c ****     (2)For DSPI instances with separate RX and TX DMA requests:
 261:../drivers/fsl_dspi_edma.c ****     Rx DMA request -> channel_A
 262:../drivers/fsl_dspi_edma.c ****     Tx DMA request -> channel_C -> channel_B .
 263:../drivers/fsl_dspi_edma.c ****     channel_C major link to channel_B.
 264:../drivers/fsl_dspi_edma.c ****     So need prepare the first data in "intermediary"  before the DMA
 265:../drivers/fsl_dspi_edma.c ****     transfer and then channel_B is used to prepare the next data to "intermediary"
 266:../drivers/fsl_dspi_edma.c **** 
 267:../drivers/fsl_dspi_edma.c ****     channel_A:SPI_POPR to rxData,
 268:../drivers/fsl_dspi_edma.c ****     channel_C: handle->command (32 bits) to SPI_PUSHR,
 269:../drivers/fsl_dspi_edma.c ****     channel_B: next txData to handle->command (low 16 bits), and use the scatter/gather to prepare 
 270:../drivers/fsl_dspi_edma.c ****     (handle->lastCommand to handle->Command).
 271:../drivers/fsl_dspi_edma.c ****     */
 272:../drivers/fsl_dspi_edma.c **** 
 273:../drivers/fsl_dspi_edma.c ****     /*If dspi has separate dma request , prepare the first data in "intermediary" .
 274:../drivers/fsl_dspi_edma.c ****     else (dspi has shared dma request) , send first 2 data if there is fifo or send first 1 data if
 275:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 276:../drivers/fsl_dspi_edma.c ****     {
 277:../drivers/fsl_dspi_edma.c ****         /* For DSPI instances with separate RX/TX DMA requests, we'll use the TX DMA request to
 278:../drivers/fsl_dspi_edma.c ****         * trigger the TX DMA channel and RX DMA request to trigger the RX DMA channel
 279:../drivers/fsl_dspi_edma.c ****         */
 280:../drivers/fsl_dspi_edma.c **** 
 281:../drivers/fsl_dspi_edma.c ****         /*Prepare the firt data*/
 282:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame > 8)
 283:../drivers/fsl_dspi_edma.c ****         {
 284:../drivers/fsl_dspi_edma.c ****             /* If it's the last word */
 285:../drivers/fsl_dspi_edma.c ****             if (handle->remainingSendByteCount <= 2)
 286:../drivers/fsl_dspi_edma.c ****             {
 287:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
 288:../drivers/fsl_dspi_edma.c ****                 {
 289:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
 290:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 291:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 292:../drivers/fsl_dspi_edma.c ****                 }
 293:../drivers/fsl_dspi_edma.c ****                 else
 294:../drivers/fsl_dspi_edma.c ****                 {
 295:../drivers/fsl_dspi_edma.c ****                     wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 296:../drivers/fsl_dspi_edma.c ****                 }
 297:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) | wordToSend;
 298:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 299:../drivers/fsl_dspi_edma.c ****             }
 300:../drivers/fsl_dspi_edma.c ****             else /* For all words except the last word , frame > 8bits */
 301:../drivers/fsl_dspi_edma.c ****             {
 302:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
 303:../drivers/fsl_dspi_edma.c ****                 {
 304:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
 305:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 306:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 307:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 308:../drivers/fsl_dspi_edma.c ****                 }
 309:../drivers/fsl_dspi_edma.c ****                 else
 310:../drivers/fsl_dspi_edma.c ****                 {
 311:../drivers/fsl_dspi_edma.c ****                     wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 312:../drivers/fsl_dspi_edma.c ****                 }
 313:../drivers/fsl_dspi_edma.c ****                 handle->command = (handle->command & 0xffff0000U) | wordToSend;
 314:../drivers/fsl_dspi_edma.c ****             }
 315:../drivers/fsl_dspi_edma.c ****         }
 316:../drivers/fsl_dspi_edma.c ****         else /* Optimized for bits/frame less than or equal to one byte. */
 317:../drivers/fsl_dspi_edma.c ****         {
 318:../drivers/fsl_dspi_edma.c ****             if (handle->txData)
 319:../drivers/fsl_dspi_edma.c ****             {
 320:../drivers/fsl_dspi_edma.c ****                 wordToSend = *(handle->txData);
 321:../drivers/fsl_dspi_edma.c ****                 ++handle->txData; /* increment to next data word*/
 322:../drivers/fsl_dspi_edma.c ****             }
 323:../drivers/fsl_dspi_edma.c ****             else
 324:../drivers/fsl_dspi_edma.c ****             {
 325:../drivers/fsl_dspi_edma.c ****                 wordToSend = dummyData;
 326:../drivers/fsl_dspi_edma.c ****             }
 327:../drivers/fsl_dspi_edma.c **** 
 328:../drivers/fsl_dspi_edma.c ****             if (handle->remainingSendByteCount == 1)
 329:../drivers/fsl_dspi_edma.c ****             {
 330:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) | wordToSend;
 331:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 332:../drivers/fsl_dspi_edma.c ****             }
 333:../drivers/fsl_dspi_edma.c ****             else
 334:../drivers/fsl_dspi_edma.c ****             {
 335:../drivers/fsl_dspi_edma.c ****                 handle->command = (handle->command & 0xffff0000U) | wordToSend;
 336:../drivers/fsl_dspi_edma.c ****             }
 337:../drivers/fsl_dspi_edma.c ****         }
 338:../drivers/fsl_dspi_edma.c ****     }
 339:../drivers/fsl_dspi_edma.c **** 
 340:../drivers/fsl_dspi_edma.c ****     else /*dspi has shared dma request*/
 341:../drivers/fsl_dspi_edma.c ****     {
 342:../drivers/fsl_dspi_edma.c ****         /* For DSPI instances with shared RX/TX DMA requests, we'll use the RX DMA request to
 343:../drivers/fsl_dspi_edma.c ****          * trigger ongoing transfers and will link to the TX DMA channel from the RX DMA channel.
 344:../drivers/fsl_dspi_edma.c ****          */
 345:../drivers/fsl_dspi_edma.c **** 
 346:../drivers/fsl_dspi_edma.c ****         /* If bits/frame is greater than one byte */
 347:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame > 8)
 348:../drivers/fsl_dspi_edma.c ****         {
 349:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
 350:../drivers/fsl_dspi_edma.c ****             {
 351:../drivers/fsl_dspi_edma.c ****                 if (handle->remainingSendByteCount <= 2)
 352:../drivers/fsl_dspi_edma.c ****                 {
 353:../drivers/fsl_dspi_edma.c ****                     if (handle->txData)
 354:../drivers/fsl_dspi_edma.c ****                     {
 355:../drivers/fsl_dspi_edma.c ****                         wordToSend = *(handle->txData);
 356:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 357:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 358:../drivers/fsl_dspi_edma.c ****                     }
 359:../drivers/fsl_dspi_edma.c ****                     else
 360:../drivers/fsl_dspi_edma.c ****                     {
 361:../drivers/fsl_dspi_edma.c ****                         wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 362:../drivers/fsl_dspi_edma.c ****                     }
 363:../drivers/fsl_dspi_edma.c ****                     handle->remainingSendByteCount = 0;
 364:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 365:../drivers/fsl_dspi_edma.c ****                 }
 366:../drivers/fsl_dspi_edma.c ****                 /* For all words except the last word */
 367:../drivers/fsl_dspi_edma.c ****                 else
 368:../drivers/fsl_dspi_edma.c ****                 {
 369:../drivers/fsl_dspi_edma.c ****                     if (handle->txData)
 370:../drivers/fsl_dspi_edma.c ****                     {
 371:../drivers/fsl_dspi_edma.c ****                         wordToSend = *(handle->txData);
 372:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 373:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 374:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 375:../drivers/fsl_dspi_edma.c ****                     }
 376:../drivers/fsl_dspi_edma.c ****                     else
 377:../drivers/fsl_dspi_edma.c ****                     {
 378:../drivers/fsl_dspi_edma.c ****                         wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 379:../drivers/fsl_dspi_edma.c ****                     }
 380:../drivers/fsl_dspi_edma.c ****                     handle->remainingSendByteCount -= 2;
 381:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->command & 0xffff0000U) | wordToSend;
 382:../drivers/fsl_dspi_edma.c ****                 }
 383:../drivers/fsl_dspi_edma.c **** 
 384:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
 385:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 386:../drivers/fsl_dspi_edma.c **** 
 387:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed += 2;
 388:../drivers/fsl_dspi_edma.c **** 
 389:../drivers/fsl_dspi_edma.c ****                 /* exit loop if send count is zero, else update local variables for next loop */
 390:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == (dataFedMax * 2)))
 391:../drivers/fsl_dspi_edma.c ****                 {
 392:../drivers/fsl_dspi_edma.c ****                     break;
 393:../drivers/fsl_dspi_edma.c ****                 }
 394:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
 395:../drivers/fsl_dspi_edma.c ****         }
 396:../drivers/fsl_dspi_edma.c ****         else /* Optimized for bits/frame less than or equal to one byte. */
 397:../drivers/fsl_dspi_edma.c ****         {
 398:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
 399:../drivers/fsl_dspi_edma.c ****             {
 400:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
 401:../drivers/fsl_dspi_edma.c ****                 {
 402:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
 403:../drivers/fsl_dspi_edma.c ****                     ++handle->txData;
 404:../drivers/fsl_dspi_edma.c ****                 }
 405:../drivers/fsl_dspi_edma.c ****                 else
 406:../drivers/fsl_dspi_edma.c ****                 {
 407:../drivers/fsl_dspi_edma.c ****                     wordToSend = dummyData;
 408:../drivers/fsl_dspi_edma.c ****                 }
 409:../drivers/fsl_dspi_edma.c **** 
 410:../drivers/fsl_dspi_edma.c ****                 if (handle->remainingSendByteCount == 1)
 411:../drivers/fsl_dspi_edma.c ****                 {
 412:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 413:../drivers/fsl_dspi_edma.c ****                 }
 414:../drivers/fsl_dspi_edma.c ****                 else
 415:../drivers/fsl_dspi_edma.c ****                 {
 416:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->command & 0xffff0000U) | wordToSend;
 417:../drivers/fsl_dspi_edma.c ****                 }
 418:../drivers/fsl_dspi_edma.c **** 
 419:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
 420:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 421:../drivers/fsl_dspi_edma.c **** 
 422:../drivers/fsl_dspi_edma.c ****                 --handle->remainingSendByteCount;
 423:../drivers/fsl_dspi_edma.c **** 
 424:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed++;
 425:../drivers/fsl_dspi_edma.c **** 
 426:../drivers/fsl_dspi_edma.c ****                 /* exit loop if send count is zero, else update local variables for next loop */
 427:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == dataFedMax))
 428:../drivers/fsl_dspi_edma.c ****                 {
 429:../drivers/fsl_dspi_edma.c ****                     break;
 430:../drivers/fsl_dspi_edma.c ****                 }
 431:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
 432:../drivers/fsl_dspi_edma.c ****         }
 433:../drivers/fsl_dspi_edma.c ****     }
 434:../drivers/fsl_dspi_edma.c **** 
 435:../drivers/fsl_dspi_edma.c ****     /***channel_A *** used for carry the data from Rx_Data_Register(POPR) to User_Receive_Buffer(rx
 436:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHandle->chann
 437:../drivers/fsl_dspi_edma.c **** 
 438:../drivers/fsl_dspi_edma.c ****     transferConfigA.srcAddr = (uint32_t)rxAddr;
 439:../drivers/fsl_dspi_edma.c ****     transferConfigA.srcOffset = 0;
 440:../drivers/fsl_dspi_edma.c **** 
 441:../drivers/fsl_dspi_edma.c ****     if (handle->rxData)
 442:../drivers/fsl_dspi_edma.c ****     {
 443:../drivers/fsl_dspi_edma.c ****         transferConfigA.destAddr = (uint32_t) & (handle->rxData[0]);
 444:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 1;
 445:../drivers/fsl_dspi_edma.c ****     }
 446:../drivers/fsl_dspi_edma.c ****     else
 447:../drivers/fsl_dspi_edma.c ****     {
 448:../drivers/fsl_dspi_edma.c ****         transferConfigA.destAddr = (uint32_t) & (handle->rxBuffIfNull);
 449:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 0;
 450:../drivers/fsl_dspi_edma.c ****     }
 451:../drivers/fsl_dspi_edma.c **** 
 452:../drivers/fsl_dspi_edma.c ****     transferConfigA.destTransferSize = kEDMA_TransferSize1Bytes;
 453:../drivers/fsl_dspi_edma.c **** 
 454:../drivers/fsl_dspi_edma.c ****     if (handle->bitsPerFrame <= 8)
 455:../drivers/fsl_dspi_edma.c ****     {
 456:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcTransferSize = kEDMA_TransferSize1Bytes;
 457:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 1;
 458:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
 459:../drivers/fsl_dspi_edma.c ****     }
 460:../drivers/fsl_dspi_edma.c ****     else
 461:../drivers/fsl_dspi_edma.c ****     {
 462:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcTransferSize = kEDMA_TransferSize2Bytes;
 463:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 2;
 464:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
 465:../drivers/fsl_dspi_edma.c ****     }
 466:../drivers/fsl_dspi_edma.c **** 
 467:../drivers/fsl_dspi_edma.c ****     /* Store the initially configured eDMA minor byte transfer count into the DSPI handle */
 468:../drivers/fsl_dspi_edma.c ****     handle->nbytes = transferConfigA.minorLoopBytes;
 469:../drivers/fsl_dspi_edma.c **** 
 470:../drivers/fsl_dspi_edma.c ****     EDMA_SetTransferConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHandle->
 471:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 472:../drivers/fsl_dspi_edma.c ****     EDMA_EnableChannelInterrupts(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHa
 473:../drivers/fsl_dspi_edma.c ****                                  kEDMA_MajorInterruptEnable);
 474:../drivers/fsl_dspi_edma.c **** 
 475:../drivers/fsl_dspi_edma.c ****     /*Calculate the last data : handle->lastCommand*/
 476:../drivers/fsl_dspi_edma.c ****     if (((handle->remainingSendByteCount > 0) && (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn
 477:../drivers/fsl_dspi_edma.c ****         ((((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 478:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 479:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
 480:../drivers/fsl_dspi_edma.c ****     {
 481:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
 482:../drivers/fsl_dspi_edma.c ****         {
 483:../drivers/fsl_dspi_edma.c ****             uint32_t bufferIndex = 0;
 484:../drivers/fsl_dspi_edma.c **** 
 485:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 486:../drivers/fsl_dspi_edma.c ****             {
 487:../drivers/fsl_dspi_edma.c ****                 if (handle->bitsPerFrame <= 8)
 488:../drivers/fsl_dspi_edma.c ****                 {
 489:../drivers/fsl_dspi_edma.c ****                     bufferIndex = handle->remainingSendByteCount - 1;
 490:../drivers/fsl_dspi_edma.c ****                 }
 491:../drivers/fsl_dspi_edma.c ****                 else
 492:../drivers/fsl_dspi_edma.c ****                 {
 493:../drivers/fsl_dspi_edma.c ****                     bufferIndex = handle->remainingSendByteCount - 2;
 494:../drivers/fsl_dspi_edma.c ****                 }
 495:../drivers/fsl_dspi_edma.c ****             }
 496:../drivers/fsl_dspi_edma.c ****             else
 497:../drivers/fsl_dspi_edma.c ****             {
 498:../drivers/fsl_dspi_edma.c ****                 bufferIndex = handle->remainingSendByteCount;
 499:../drivers/fsl_dspi_edma.c ****             }
 500:../drivers/fsl_dspi_edma.c **** 
 501:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 502:../drivers/fsl_dspi_edma.c ****             {
 503:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) | handle->txData[bufferIn
 504:../drivers/fsl_dspi_edma.c ****             }
 505:../drivers/fsl_dspi_edma.c ****             else
 506:../drivers/fsl_dspi_edma.c ****             {
 507:../drivers/fsl_dspi_edma.c ****                 handle->lastCommand = (handle->lastCommand & 0xffff0000U) |
 508:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 509:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 510:../drivers/fsl_dspi_edma.c ****             }
 511:../drivers/fsl_dspi_edma.c ****         }
 512:../drivers/fsl_dspi_edma.c ****         else
 513:../drivers/fsl_dspi_edma.c ****         {
 514:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 515:../drivers/fsl_dspi_edma.c ****             {
 516:../drivers/fsl_dspi_edma.c ****                 wordToSend = dummyData;
 517:../drivers/fsl_dspi_edma.c ****             }
 518:../drivers/fsl_dspi_edma.c ****             else
 519:../drivers/fsl_dspi_edma.c ****             {
 520:../drivers/fsl_dspi_edma.c ****                 wordToSend = ((uint32_t)dummyData << 8) | dummyData;
 521:../drivers/fsl_dspi_edma.c ****             }
 522:../drivers/fsl_dspi_edma.c ****             handle->lastCommand = (handle->lastCommand & 0xffff0000U) | wordToSend;
 523:../drivers/fsl_dspi_edma.c ****         }
 524:../drivers/fsl_dspi_edma.c ****     }
 525:../drivers/fsl_dspi_edma.c **** 
 526:../drivers/fsl_dspi_edma.c **** /* The feature of GASKET is that the SPI supports 8-bit or 16-bit writes to the PUSH TX FIFO,
 527:../drivers/fsl_dspi_edma.c ****  * allowing a single write to the command word followed by multiple writes to the transmit word.
 528:../drivers/fsl_dspi_edma.c ****  * The TX FIFO will save the last command word written, and convert a 8-bit/16-bit write to the
 529:../drivers/fsl_dspi_edma.c ****  * transmit word into a 32-bit write that pushes both the command word and transmit word into
 530:../drivers/fsl_dspi_edma.c ****  * the TX FIFO (PUSH TX FIFO Register In Master Mode)
 531:../drivers/fsl_dspi_edma.c ****  * So, if this feature is supported, we can use use one channel to carry the receive data from
 532:../drivers/fsl_dspi_edma.c ****  * receive regsiter to user data buffer, use the other channel to carry the data from user data buf
 533:../drivers/fsl_dspi_edma.c ****  * to transmit register,and use the scatter/gather function to prepare the last data.
 534:../drivers/fsl_dspi_edma.c ****  * That is to say, if GASKET feature is supported, we can use only two channels for tansferring dat
 535:../drivers/fsl_dspi_edma.c ****  */
 536:../drivers/fsl_dspi_edma.c **** #if defined(FSL_FEATURE_DSPI_HAS_GASKET) && FSL_FEATURE_DSPI_HAS_GASKET
 537:../drivers/fsl_dspi_edma.c ****     /*  For DSPI instances with separate RX and TX DMA requests: use the scatter/gather to prepare 
 538:../drivers/fsl_dspi_edma.c ****      * (handle->lastCommand) to PUSHR register.
 539:../drivers/fsl_dspi_edma.c ****      */
 540:../drivers/fsl_dspi_edma.c **** 
 541:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaIntermediaryToTxRegHandle->base, handle->edmaIntermediaryToTxRegH
 542:../drivers/fsl_dspi_edma.c **** 
 543:../drivers/fsl_dspi_edma.c ****     if ((1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)) ||
 544:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 0) && (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn
 545:../drivers/fsl_dspi_edma.c ****     {
 546:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcAddr = (uint32_t) & (handle->lastCommand);
 547:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t)txAddr;
 548:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize4Bytes;
 549:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 550:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcOffset = 0;
 551:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 552:../drivers/fsl_dspi_edma.c ****         transferConfigB.minorLoopBytes = 4;
 553:../drivers/fsl_dspi_edma.c ****         transferConfigB.majorLoopCounts = 1;
 554:../drivers/fsl_dspi_edma.c **** 
 555:../drivers/fsl_dspi_edma.c ****         EDMA_TcdReset(softwareTCD);
 556:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 557:../drivers/fsl_dspi_edma.c ****     }
 558:../drivers/fsl_dspi_edma.c **** 
 559:../drivers/fsl_dspi_edma.c ****     /*User_Send_Buffer(txData) to PUSHR register. */
 560:../drivers/fsl_dspi_edma.c ****     if (((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame <= 8)) ||
 561:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8)))
 562:../drivers/fsl_dspi_edma.c ****     {
 563:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
 564:../drivers/fsl_dspi_edma.c ****         {
 565:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 566:../drivers/fsl_dspi_edma.c ****             {
 567:../drivers/fsl_dspi_edma.c ****                 /* For DSPI with separate RX and TX DMA requests, one frame data has been carry
 568:../drivers/fsl_dspi_edma.c ****                  * to handle->command, so need to reduce the pointer of txData.
 569:../drivers/fsl_dspi_edma.c ****                  */
 570:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcAddr =
 571:../drivers/fsl_dspi_edma.c ****                     (uint32_t)((uint8_t *)(handle->txData) - ((handle->bitsPerFrame <= 8) ? (1U) : 
 572:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcOffset = 1;
 573:../drivers/fsl_dspi_edma.c ****             }
 574:../drivers/fsl_dspi_edma.c ****             else
 575:../drivers/fsl_dspi_edma.c ****             {
 576:../drivers/fsl_dspi_edma.c ****                 /* For DSPI with shared RX and TX DMA requests, one or two frame data have been car
 577:../drivers/fsl_dspi_edma.c ****                  * to PUSHR register, so no need to change the pointer of txData.
 578:../drivers/fsl_dspi_edma.c ****                  */
 579:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcAddr = (uint32_t)((uint8_t *)(handle->txData));
 580:../drivers/fsl_dspi_edma.c ****                 transferConfigB.srcOffset = 1;
 581:../drivers/fsl_dspi_edma.c ****             }
 582:../drivers/fsl_dspi_edma.c ****         }
 583:../drivers/fsl_dspi_edma.c ****         else
 584:../drivers/fsl_dspi_edma.c ****         {
 585:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcAddr = (uint32_t)(&handle->txBuffIfNull);
 586:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 0;
 587:../drivers/fsl_dspi_edma.c ****         }
 588:../drivers/fsl_dspi_edma.c **** 
 589:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t)txAddr;
 590:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 591:../drivers/fsl_dspi_edma.c **** 
 592:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize1Bytes;
 593:../drivers/fsl_dspi_edma.c **** 
 594:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
 595:../drivers/fsl_dspi_edma.c ****         {
 596:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize1Bytes;
 597:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 1;
 598:../drivers/fsl_dspi_edma.c **** 
 599:../drivers/fsl_dspi_edma.c ****             transferConfigB.majorLoopCounts = handle->remainingSendByteCount - 1;
 600:../drivers/fsl_dspi_edma.c ****         }
 601:../drivers/fsl_dspi_edma.c ****         else
 602:../drivers/fsl_dspi_edma.c ****         {
 603:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize2Bytes;
 604:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 2;
 605:../drivers/fsl_dspi_edma.c ****             transferConfigB.majorLoopCounts = (handle->remainingSendByteCount / 2) - 1;
 606:../drivers/fsl_dspi_edma.c ****         }
 607:../drivers/fsl_dspi_edma.c **** 
 608:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 609:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigB, so
 610:../drivers/fsl_dspi_edma.c ****     }
 611:../drivers/fsl_dspi_edma.c ****     /* If only one word to transmit, only carry the lastcommand. */
 612:../drivers/fsl_dspi_edma.c ****     else
 613:../drivers/fsl_dspi_edma.c ****     {
 614:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 615:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigB, NU
 616:../drivers/fsl_dspi_edma.c ****     }
 617:../drivers/fsl_dspi_edma.c **** 
 618:../drivers/fsl_dspi_edma.c ****     /*Start the EDMA channel_A , channel_C. */
 619:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaRxRegToRxDataHandle);
 620:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaIntermediaryToTxRegHandle);
 621:../drivers/fsl_dspi_edma.c **** 
 622:../drivers/fsl_dspi_edma.c ****     /* Set the channel link.
 623:../drivers/fsl_dspi_edma.c ****      * For DSPI instances with shared TX and RX DMA requests, setup channel minor link, first recei
 624:../drivers/fsl_dspi_edma.c ****      * receive register, and then carry transmit data to PUSHER register.
 625:../drivers/fsl_dspi_edma.c ****      * For DSPI instance with separate TX and RX DMA requests, there is no need to set up channel l
 626:../drivers/fsl_dspi_edma.c ****      */
 627:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 628:../drivers/fsl_dspi_edma.c ****     {
 629:../drivers/fsl_dspi_edma.c ****         /*Set channel priority*/
 630:../drivers/fsl_dspi_edma.c ****         uint8_t channelPriorityLow = handle->edmaRxRegToRxDataHandle->channel;
 631:../drivers/fsl_dspi_edma.c ****         uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 632:../drivers/fsl_dspi_edma.c ****         uint8_t t = 0;
 633:../drivers/fsl_dspi_edma.c **** 
 634:../drivers/fsl_dspi_edma.c ****         if (channelPriorityLow > channelPriorityHigh)
 635:../drivers/fsl_dspi_edma.c ****         {
 636:../drivers/fsl_dspi_edma.c ****             t = channelPriorityLow;
 637:../drivers/fsl_dspi_edma.c ****             channelPriorityLow = channelPriorityHigh;
 638:../drivers/fsl_dspi_edma.c ****             channelPriorityHigh = t;
 639:../drivers/fsl_dspi_edma.c ****         }
 640:../drivers/fsl_dspi_edma.c **** 
 641:../drivers/fsl_dspi_edma.c ****         edma_channel_Preemption_config_t preemption_config_t;
 642:../drivers/fsl_dspi_edma.c ****         preemption_config_t.enableChannelPreemption = true;
 643:../drivers/fsl_dspi_edma.c ****         preemption_config_t.enablePreemptAbility = true;
 644:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityLow;
 645:../drivers/fsl_dspi_edma.c **** 
 646:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 647:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 648:../drivers/fsl_dspi_edma.c **** 
 649:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
 650:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 651:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 652:../drivers/fsl_dspi_edma.c ****         /*if there is Rx DMA request , carry the 32bits data (handle->command) to user data first ,
 653:../drivers/fsl_dspi_edma.c ****           channelC to carry the next data to PUSHER register.(txData to PUSHER) */
 654:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 0)
 655:../drivers/fsl_dspi_edma.c ****         {
 656:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHan
 657:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaIntermediaryToTxRegHandle->channel);
 658:../drivers/fsl_dspi_edma.c ****         }
 659:../drivers/fsl_dspi_edma.c ****     }
 660:../drivers/fsl_dspi_edma.c **** 
 661:../drivers/fsl_dspi_edma.c ****     DSPI_EnableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 662:../drivers/fsl_dspi_edma.c **** 
 663:../drivers/fsl_dspi_edma.c ****     /* Setup control info to PUSHER register. */
 664:../drivers/fsl_dspi_edma.c ****     *((uint16_t *)&(base->PUSHR) + 1) = (handle->command >> 16U);
 665:../drivers/fsl_dspi_edma.c **** #else
 666:../drivers/fsl_dspi_edma.c **** 
 667:../drivers/fsl_dspi_edma.c ****     /***channel_B *** used for carry the data from User_Send_Buffer to "intermediary" because the S
 668:../drivers/fsl_dspi_edma.c ****     write the 32bits at once time . Then use channel_C to carry the "intermediary" to SPIx_PUSHR. N
 669:../drivers/fsl_dspi_edma.c ****     SPIx_PUSHR upper 16 bits are the "command" and the low 16bits are data */
 670:../drivers/fsl_dspi_edma.c **** 
 671:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaTxDataToIntermediaryHandle->base, handle->edmaTxDataToIntermediar
 672:../drivers/fsl_dspi_edma.c **** 
 673:../drivers/fsl_dspi_edma.c ****     /*For DSPI instances with separate RX and TX DMA requests: use the scatter/gather to prepare th
 674:../drivers/fsl_dspi_edma.c ****      * (handle->lastCommand) to handle->Command*/
 675:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 676:../drivers/fsl_dspi_edma.c ****     {
 677:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcAddr = (uint32_t) & (handle->lastCommand);
 678:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t) & (handle->command);
 679:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize4Bytes;
 680:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 681:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcOffset = 0;
 682:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 683:../drivers/fsl_dspi_edma.c ****         transferConfigB.minorLoopBytes = 4;
 684:../drivers/fsl_dspi_edma.c ****         transferConfigB.majorLoopCounts = 1;
 685:../drivers/fsl_dspi_edma.c **** 
 686:../drivers/fsl_dspi_edma.c ****         EDMA_TcdReset(softwareTCD);
 687:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 688:../drivers/fsl_dspi_edma.c ****     }
 689:../drivers/fsl_dspi_edma.c **** 
 690:../drivers/fsl_dspi_edma.c ****     /*User_Send_Buffer(txData) to intermediary(handle->command)*/
 691:../drivers/fsl_dspi_edma.c ****     if (((((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame <= 8)) ||
 692:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8))) &&
 693:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))) ||
 694:../drivers/fsl_dspi_edma.c ****         (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 695:../drivers/fsl_dspi_edma.c ****     {
 696:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
 697:../drivers/fsl_dspi_edma.c ****         {
 698:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcAddr = (uint32_t)(handle->txData);
 699:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 1;
 700:../drivers/fsl_dspi_edma.c ****         }
 701:../drivers/fsl_dspi_edma.c ****         else
 702:../drivers/fsl_dspi_edma.c ****         {
 703:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcAddr = (uint32_t)(&handle->txBuffIfNull);
 704:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 0;
 705:../drivers/fsl_dspi_edma.c ****         }
 706:../drivers/fsl_dspi_edma.c **** 
 707:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t)(&handle->command);
 708:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 709:../drivers/fsl_dspi_edma.c **** 
 710:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize1Bytes;
 711:../drivers/fsl_dspi_edma.c **** 
 712:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
 713:../drivers/fsl_dspi_edma.c ****         {
 714:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize1Bytes;
 715:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 1;
 716:../drivers/fsl_dspi_edma.c **** 
 717:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 718:../drivers/fsl_dspi_edma.c ****             {
 719:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount - 2;
 720:../drivers/fsl_dspi_edma.c ****             }
 721:../drivers/fsl_dspi_edma.c ****             else
 722:../drivers/fsl_dspi_edma.c ****             {
 723:../drivers/fsl_dspi_edma.c ****                 /*Only enable channel_B minorlink to channel_C , so need to add one count due to th
 724:../drivers/fsl_dspi_edma.c ****                 majorlink , the majorlink would not trigger the channel_C*/
 725:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount + 1;
 726:../drivers/fsl_dspi_edma.c ****             }
 727:../drivers/fsl_dspi_edma.c ****         }
 728:../drivers/fsl_dspi_edma.c ****         else
 729:../drivers/fsl_dspi_edma.c ****         {
 730:../drivers/fsl_dspi_edma.c ****             transferConfigB.destTransferSize = kEDMA_TransferSize2Bytes;
 731:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 2;
 732:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 733:../drivers/fsl_dspi_edma.c ****             {
 734:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount / 2 - 2;
 735:../drivers/fsl_dspi_edma.c ****             }
 736:../drivers/fsl_dspi_edma.c ****             else
 737:../drivers/fsl_dspi_edma.c ****             {
 738:../drivers/fsl_dspi_edma.c ****                 /*Only enable channel_B minorlink to channel_C , so need to add one count due to th
 739:../drivers/fsl_dspi_edma.c ****                 * majorlink*/
 740:../drivers/fsl_dspi_edma.c ****                 transferConfigB.majorLoopCounts = handle->remainingSendByteCount / 2 + 1;
 741:../drivers/fsl_dspi_edma.c ****             }
 742:../drivers/fsl_dspi_edma.c ****         }
 743:../drivers/fsl_dspi_edma.c **** 
 744:../drivers/fsl_dspi_edma.c ****         if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 745:../drivers/fsl_dspi_edma.c ****         {
 746:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaTxDataToIntermediaryHandle->base,
 747:../drivers/fsl_dspi_edma.c ****                                    handle->edmaTxDataToIntermediaryHandle->channel, &transferConfig
 748:../drivers/fsl_dspi_edma.c ****             EDMA_EnableAutoStopRequest(handle->edmaIntermediaryToTxRegHandle->base,
 749:../drivers/fsl_dspi_edma.c ****                                        handle->edmaIntermediaryToTxRegHandle->channel, false);
 750:../drivers/fsl_dspi_edma.c ****         }
 751:../drivers/fsl_dspi_edma.c ****         else
 752:../drivers/fsl_dspi_edma.c ****         {
 753:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaTxDataToIntermediaryHandle->base,
 754:../drivers/fsl_dspi_edma.c ****                                    handle->edmaTxDataToIntermediaryHandle->channel, &transferConfig
 755:../drivers/fsl_dspi_edma.c ****         }
 756:../drivers/fsl_dspi_edma.c ****     }
 757:../drivers/fsl_dspi_edma.c ****     else
 758:../drivers/fsl_dspi_edma.c ****     {
 759:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaTxDataToIntermediaryHandle->base,
 760:../drivers/fsl_dspi_edma.c ****                                handle->edmaTxDataToIntermediaryHandle->channel, &transferConfigB, N
 761:../drivers/fsl_dspi_edma.c ****     }
 762:../drivers/fsl_dspi_edma.c **** 
 763:../drivers/fsl_dspi_edma.c ****     /***channel_C ***carry the "intermediary" to SPIx_PUSHR. used the edma Scatter Gather function 
 764:../drivers/fsl_dspi_edma.c ****     handle the last data */
 765:../drivers/fsl_dspi_edma.c **** 
 766:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigC;
 767:../drivers/fsl_dspi_edma.c ****     EDMA_ResetChannel(handle->edmaIntermediaryToTxRegHandle->base, handle->edmaIntermediaryToTxRegH
 768:../drivers/fsl_dspi_edma.c **** 
 769:../drivers/fsl_dspi_edma.c ****     /*For DSPI instances with shared RX/TX DMA requests: use the scatter/gather to prepare the last
 770:../drivers/fsl_dspi_edma.c ****      * (handle->lastCommand) to SPI_PUSHR*/
 771:../drivers/fsl_dspi_edma.c ****     if (((1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)) && (handle->remainingSendByteCou
 772:../drivers/fsl_dspi_edma.c ****     {
 773:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcAddr = (uint32_t) & (handle->lastCommand);
 774:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 775:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize4Bytes;
 776:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 777:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 778:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 779:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 780:../drivers/fsl_dspi_edma.c ****         transferConfigC.majorLoopCounts = 1;
 781:../drivers/fsl_dspi_edma.c **** 
 782:../drivers/fsl_dspi_edma.c ****         EDMA_TcdReset(softwareTCD);
 783:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigC, NULL);
 784:../drivers/fsl_dspi_edma.c ****     }
 785:../drivers/fsl_dspi_edma.c **** 
 786:../drivers/fsl_dspi_edma.c ****     if (((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 787:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8)) ||
 788:../drivers/fsl_dspi_edma.c ****         (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 789:../drivers/fsl_dspi_edma.c ****     {
 790:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcAddr = (uint32_t)(&(handle->command));
 791:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 792:../drivers/fsl_dspi_edma.c **** 
 793:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize4Bytes;
 794:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 795:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 796:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 797:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 798:../drivers/fsl_dspi_edma.c ****         if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 799:../drivers/fsl_dspi_edma.c ****         {
 800:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 801:../drivers/fsl_dspi_edma.c ****             {
 802:../drivers/fsl_dspi_edma.c ****                 transferConfigC.majorLoopCounts = handle->remainingSendByteCount - 1;
 803:../drivers/fsl_dspi_edma.c ****             }
 804:../drivers/fsl_dspi_edma.c ****             else
 805:../drivers/fsl_dspi_edma.c ****             {
 806:../drivers/fsl_dspi_edma.c ****                 transferConfigC.majorLoopCounts = handle->remainingSendByteCount / 2 - 1;
 807:../drivers/fsl_dspi_edma.c ****             }
 808:../drivers/fsl_dspi_edma.c **** 
 809:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 810:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 811:../drivers/fsl_dspi_edma.c ****         }
 812:../drivers/fsl_dspi_edma.c ****         else
 813:../drivers/fsl_dspi_edma.c ****         {
 814:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = 1;
 815:../drivers/fsl_dspi_edma.c **** 
 816:../drivers/fsl_dspi_edma.c ****             EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 817:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 818:../drivers/fsl_dspi_edma.c ****         }
 819:../drivers/fsl_dspi_edma.c **** 
 820:../drivers/fsl_dspi_edma.c ****         EDMA_EnableAutoStopRequest(handle->edmaIntermediaryToTxRegHandle->base,
 821:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, false);
 822:../drivers/fsl_dspi_edma.c ****     }
 823:../drivers/fsl_dspi_edma.c ****     else
 824:../drivers/fsl_dspi_edma.c ****     {
 825:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaIntermediaryToTxRegHandle->base,
 826:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC, NU
 827:../drivers/fsl_dspi_edma.c ****     }
 828:../drivers/fsl_dspi_edma.c **** 
 829:../drivers/fsl_dspi_edma.c ****     /*Start the EDMA channel_A , channel_B , channel_C transfer*/
 830:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaRxRegToRxDataHandle);
 831:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaTxDataToIntermediaryHandle);
 832:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaIntermediaryToTxRegHandle);
 833:../drivers/fsl_dspi_edma.c **** 
 834:../drivers/fsl_dspi_edma.c ****     /*Set channel priority*/
 835:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityLow = handle->edmaRxRegToRxDataHandle->channel;
 836:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityMid = handle->edmaTxDataToIntermediaryHandle->channel;
 837:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 838:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 839:../drivers/fsl_dspi_edma.c ****     if (channelPriorityLow > channelPriorityMid)
 840:../drivers/fsl_dspi_edma.c ****     {
 841:../drivers/fsl_dspi_edma.c ****         t = channelPriorityLow;
 842:../drivers/fsl_dspi_edma.c ****         channelPriorityLow = channelPriorityMid;
 843:../drivers/fsl_dspi_edma.c ****         channelPriorityMid = t;
 844:../drivers/fsl_dspi_edma.c ****     }
 845:../drivers/fsl_dspi_edma.c **** 
 846:../drivers/fsl_dspi_edma.c ****     if (channelPriorityLow > channelPriorityHigh)
 847:../drivers/fsl_dspi_edma.c ****     {
 848:../drivers/fsl_dspi_edma.c ****         t = channelPriorityLow;
 849:../drivers/fsl_dspi_edma.c ****         channelPriorityLow = channelPriorityHigh;
 850:../drivers/fsl_dspi_edma.c ****         channelPriorityHigh = t;
 851:../drivers/fsl_dspi_edma.c ****     }
 852:../drivers/fsl_dspi_edma.c **** 
 853:../drivers/fsl_dspi_edma.c ****     if (channelPriorityMid > channelPriorityHigh)
 854:../drivers/fsl_dspi_edma.c ****     {
 855:../drivers/fsl_dspi_edma.c ****         t = channelPriorityMid;
 856:../drivers/fsl_dspi_edma.c ****         channelPriorityMid = channelPriorityHigh;
 857:../drivers/fsl_dspi_edma.c ****         channelPriorityHigh = t;
 858:../drivers/fsl_dspi_edma.c ****     }
 859:../drivers/fsl_dspi_edma.c ****     edma_channel_Preemption_config_t preemption_config_t;
 860:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enableChannelPreemption = true;
 861:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 862:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
 863:../drivers/fsl_dspi_edma.c **** 
 864:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 865:../drivers/fsl_dspi_edma.c ****     {
 866:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 867:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 868:../drivers/fsl_dspi_edma.c **** 
 869:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityMid;
 870:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 871:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 872:../drivers/fsl_dspi_edma.c **** 
 873:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
 874:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 875:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 876:../drivers/fsl_dspi_edma.c ****     }
 877:../drivers/fsl_dspi_edma.c ****     else
 878:../drivers/fsl_dspi_edma.c ****     {
 879:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 880:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 881:../drivers/fsl_dspi_edma.c **** 
 882:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityMid;
 883:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 884:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 885:../drivers/fsl_dspi_edma.c **** 
 886:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
 887:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 888:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 889:../drivers/fsl_dspi_edma.c ****     }
 890:../drivers/fsl_dspi_edma.c **** 
 891:../drivers/fsl_dspi_edma.c ****     /*Set the channel link.*/
 892:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 893:../drivers/fsl_dspi_edma.c ****     {
 894:../drivers/fsl_dspi_edma.c ****         /*if there is Tx DMA request , carry the 32bits data (handle->command) to PUSHR first , the
 895:../drivers/fsl_dspi_edma.c ****         to prepare the next 32bits data (txData to handle->command) */
 896:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 1)
 897:../drivers/fsl_dspi_edma.c ****         {
 898:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaIntermediaryToTxRegHandle->base,
 899:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel, kEDMA_MajorLink,
 900:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel);
 901:../drivers/fsl_dspi_edma.c ****         }
 902:../drivers/fsl_dspi_edma.c **** 
 903:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 904:../drivers/fsl_dspi_edma.c ****     }
 905:../drivers/fsl_dspi_edma.c ****     else
 906:../drivers/fsl_dspi_edma.c ****     {
 907:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 0)
 908:../drivers/fsl_dspi_edma.c ****         {
 909:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHan
 910:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToIntermediaryHandle->channel);
 911:../drivers/fsl_dspi_edma.c **** 
 912:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaTxDataToIntermediaryHandle->base,
 913:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel, kEDMA_MinorLink,
 914:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel);
 915:../drivers/fsl_dspi_edma.c ****         }
 916:../drivers/fsl_dspi_edma.c **** 
 917:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable);
 918:../drivers/fsl_dspi_edma.c ****     }
 919:../drivers/fsl_dspi_edma.c **** #endif
 920:../drivers/fsl_dspi_edma.c ****     DSPI_StartTransfer(base);
 921:../drivers/fsl_dspi_edma.c **** 
 922:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
 923:../drivers/fsl_dspi_edma.c **** }
 924:../drivers/fsl_dspi_edma.c **** 
 925:../drivers/fsl_dspi_edma.c **** status_t DSPI_MasterHalfDuplexTransferEDMA(SPI_Type *base,
 926:../drivers/fsl_dspi_edma.c ****                                            dspi_master_edma_handle_t *handle,
 927:../drivers/fsl_dspi_edma.c ****                                            dspi_half_duplex_transfer_t *xfer)
 928:../drivers/fsl_dspi_edma.c **** {
 929:../drivers/fsl_dspi_edma.c ****     assert(xfer);
 930:../drivers/fsl_dspi_edma.c ****     assert(handle);
 931:../drivers/fsl_dspi_edma.c ****     dspi_transfer_t tempXfer = {0};
 932:../drivers/fsl_dspi_edma.c ****     status_t status;
 933:../drivers/fsl_dspi_edma.c **** 
 934:../drivers/fsl_dspi_edma.c ****     if (xfer->isTransmitFirst)
 935:../drivers/fsl_dspi_edma.c ****     {
 936:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = xfer->txData;
 937:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 938:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->txDataSize;
 939:../drivers/fsl_dspi_edma.c ****     }
 940:../drivers/fsl_dspi_edma.c ****     else
 941:../drivers/fsl_dspi_edma.c ****     {
 942:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = NULL;
 943:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = xfer->rxData;
 944:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 945:../drivers/fsl_dspi_edma.c ****     }
 946:../drivers/fsl_dspi_edma.c ****     /* If the pcs pin keep assert between transmit and receive. */
 947:../drivers/fsl_dspi_edma.c ****     if (xfer->isPcsAssertInTransfer)
 948:../drivers/fsl_dspi_edma.c ****     {
 949:../drivers/fsl_dspi_edma.c ****         tempXfer.configFlags = (xfer->configFlags) | kDSPI_MasterActiveAfterTransfer;
 950:../drivers/fsl_dspi_edma.c ****     }
 951:../drivers/fsl_dspi_edma.c ****     else
 952:../drivers/fsl_dspi_edma.c ****     {
 953:../drivers/fsl_dspi_edma.c ****         tempXfer.configFlags = (xfer->configFlags) & (uint32_t)(~kDSPI_MasterActiveAfterTransfer);
 954:../drivers/fsl_dspi_edma.c ****     }
 955:../drivers/fsl_dspi_edma.c **** 
 956:../drivers/fsl_dspi_edma.c ****     status = DSPI_MasterTransferBlocking(base, &tempXfer);
 957:../drivers/fsl_dspi_edma.c ****     if (status != kStatus_Success)
 958:../drivers/fsl_dspi_edma.c ****     {
 959:../drivers/fsl_dspi_edma.c ****         return status;
 960:../drivers/fsl_dspi_edma.c ****     }
 961:../drivers/fsl_dspi_edma.c **** 
 962:../drivers/fsl_dspi_edma.c ****     if (xfer->isTransmitFirst)
 963:../drivers/fsl_dspi_edma.c ****     {
 964:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = NULL;
 965:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = xfer->rxData;
 966:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 967:../drivers/fsl_dspi_edma.c ****     }
 968:../drivers/fsl_dspi_edma.c ****     else
 969:../drivers/fsl_dspi_edma.c ****     {
 970:../drivers/fsl_dspi_edma.c ****         tempXfer.txData = xfer->txData;
 971:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 972:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->txDataSize;
 973:../drivers/fsl_dspi_edma.c ****     }
 974:../drivers/fsl_dspi_edma.c ****     tempXfer.configFlags = xfer->configFlags;
 975:../drivers/fsl_dspi_edma.c **** 
 976:../drivers/fsl_dspi_edma.c ****     status = DSPI_MasterTransferEDMA(base, handle, &tempXfer);
 977:../drivers/fsl_dspi_edma.c **** 
 978:../drivers/fsl_dspi_edma.c ****     return status;
 979:../drivers/fsl_dspi_edma.c **** }
 980:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiMasterCallback(edma_handle_t *edmaHandle,
 981:../drivers/fsl_dspi_edma.c ****                                     void *g_dspiEdmaPrivateHandle,
 982:../drivers/fsl_dspi_edma.c ****                                     bool transferDone,
 983:../drivers/fsl_dspi_edma.c ****                                     uint32_t tcds)
 984:../drivers/fsl_dspi_edma.c **** {
  75              		.loc 2 984 0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
  79              		@ link register save eliminated.
  80              	.LVL4:
 985:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
 986:../drivers/fsl_dspi_edma.c ****     assert(g_dspiEdmaPrivateHandle);
 987:../drivers/fsl_dspi_edma.c **** 
 988:../drivers/fsl_dspi_edma.c ****     dspi_master_edma_private_handle_t *dspiEdmaPrivateHandle;
 989:../drivers/fsl_dspi_edma.c **** 
 990:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle = (dspi_master_edma_private_handle_t *)g_dspiEdmaPrivateHandle;
 991:../drivers/fsl_dspi_edma.c **** 
 992:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA((dspiEdmaPrivateHandle->base), kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
  81              		.loc 2 992 0
  82 0000 0868     		ldr	r0, [r1]
  83              	.LVL5:
 993:../drivers/fsl_dspi_edma.c **** 
 994:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle->handle->state = kDSPI_Idle;
  84              		.loc 2 994 0
  85 0002 4968     		ldr	r1, [r1, #4]
  86              	.LVL6:
  87              	.LBB102:
  88              	.LBB103:
  89              		.file 3 "../drivers/fsl_dspi.h"
   1:../drivers/fsl_dspi.h **** /*
   2:../drivers/fsl_dspi.h ****  * The Clear BSD License
   3:../drivers/fsl_dspi.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dspi.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dspi.h ****  * All rights reserved.
   6:../drivers/fsl_dspi.h ****  *
   7:../drivers/fsl_dspi.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dspi.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dspi.h ****  * that the following conditions are met:
  10:../drivers/fsl_dspi.h ****  *
  11:../drivers/fsl_dspi.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dspi.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dspi.h ****  *
  14:../drivers/fsl_dspi.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dspi.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dspi.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dspi.h ****  *
  18:../drivers/fsl_dspi.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dspi.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dspi.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dspi.h ****  *
  22:../drivers/fsl_dspi.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dspi.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dspi.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dspi.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dspi.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dspi.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dspi.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dspi.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dspi.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dspi.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dspi.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dspi.h ****  */
  34:../drivers/fsl_dspi.h **** #ifndef _FSL_DSPI_H_
  35:../drivers/fsl_dspi.h **** #define _FSL_DSPI_H_
  36:../drivers/fsl_dspi.h **** 
  37:../drivers/fsl_dspi.h **** #include "fsl_common.h"
  38:../drivers/fsl_dspi.h **** 
  39:../drivers/fsl_dspi.h **** /*!
  40:../drivers/fsl_dspi.h ****  * @addtogroup dspi_driver
  41:../drivers/fsl_dspi.h ****  * @{
  42:../drivers/fsl_dspi.h ****  */
  43:../drivers/fsl_dspi.h **** 
  44:../drivers/fsl_dspi.h **** /**************************************************************************************************
  45:../drivers/fsl_dspi.h ****  * Definitions
  46:../drivers/fsl_dspi.h ****  **************************************************************************************************
  47:../drivers/fsl_dspi.h **** 
  48:../drivers/fsl_dspi.h **** /*! @name Driver version */
  49:../drivers/fsl_dspi.h **** /*@{*/
  50:../drivers/fsl_dspi.h **** /*! @brief DSPI driver version 2.2.0. */
  51:../drivers/fsl_dspi.h **** #define FSL_DSPI_DRIVER_VERSION (MAKE_VERSION(2, 2, 0))
  52:../drivers/fsl_dspi.h **** /*@}*/
  53:../drivers/fsl_dspi.h **** 
  54:../drivers/fsl_dspi.h **** #ifndef DSPI_DUMMY_DATA
  55:../drivers/fsl_dspi.h **** /*! @brief DSPI dummy data if there is no Tx data.*/
  56:../drivers/fsl_dspi.h **** #define DSPI_DUMMY_DATA (0x00U) /*!< Dummy data used for Tx if there is no txData. */
  57:../drivers/fsl_dspi.h **** #endif
  58:../drivers/fsl_dspi.h **** 
  59:../drivers/fsl_dspi.h **** /*! @brief Status for the DSPI driver.*/
  60:../drivers/fsl_dspi.h **** enum _dspi_status
  61:../drivers/fsl_dspi.h **** {
  62:../drivers/fsl_dspi.h ****     kStatus_DSPI_Busy = MAKE_STATUS(kStatusGroup_DSPI, 0),      /*!< DSPI transfer is busy.*/
  63:../drivers/fsl_dspi.h ****     kStatus_DSPI_Error = MAKE_STATUS(kStatusGroup_DSPI, 1),     /*!< DSPI driver error. */
  64:../drivers/fsl_dspi.h ****     kStatus_DSPI_Idle = MAKE_STATUS(kStatusGroup_DSPI, 2),      /*!< DSPI is idle.*/
  65:../drivers/fsl_dspi.h ****     kStatus_DSPI_OutOfRange = MAKE_STATUS(kStatusGroup_DSPI, 3) /*!< DSPI transfer out of range. */
  66:../drivers/fsl_dspi.h **** };
  67:../drivers/fsl_dspi.h **** 
  68:../drivers/fsl_dspi.h **** /*! @brief DSPI status flags in SPIx_SR register.*/
  69:../drivers/fsl_dspi.h **** enum _dspi_flags
  70:../drivers/fsl_dspi.h **** {
  71:../drivers/fsl_dspi.h ****     kDSPI_TxCompleteFlag = SPI_SR_TCF_MASK,          /*!< Transfer Complete Flag. */
  72:../drivers/fsl_dspi.h ****     kDSPI_EndOfQueueFlag = SPI_SR_EOQF_MASK,         /*!< End of Queue Flag.*/
  73:../drivers/fsl_dspi.h ****     kDSPI_TxFifoUnderflowFlag = SPI_SR_TFUF_MASK,    /*!< Transmit FIFO Underflow Flag.*/
  74:../drivers/fsl_dspi.h ****     kDSPI_TxFifoFillRequestFlag = SPI_SR_TFFF_MASK,  /*!< Transmit FIFO Fill Flag.*/
  75:../drivers/fsl_dspi.h ****     kDSPI_RxFifoOverflowFlag = SPI_SR_RFOF_MASK,     /*!< Receive FIFO Overflow Flag.*/
  76:../drivers/fsl_dspi.h ****     kDSPI_RxFifoDrainRequestFlag = SPI_SR_RFDF_MASK, /*!< Receive FIFO Drain Flag.*/
  77:../drivers/fsl_dspi.h ****     kDSPI_TxAndRxStatusFlag = SPI_SR_TXRXS_MASK,     /*!< The module is in Stopped/Running state.*/
  78:../drivers/fsl_dspi.h ****     kDSPI_AllStatusFlag = SPI_SR_TCF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK 
  79:../drivers/fsl_dspi.h ****                           SPI_SR_RFDF_MASK | SPI_SR_TXRXS_MASK /*!< All statuses above.*/
  80:../drivers/fsl_dspi.h **** };
  81:../drivers/fsl_dspi.h **** 
  82:../drivers/fsl_dspi.h **** /*! @brief DSPI interrupt source.*/
  83:../drivers/fsl_dspi.h **** enum _dspi_interrupt_enable
  84:../drivers/fsl_dspi.h **** {
  85:../drivers/fsl_dspi.h ****     kDSPI_TxCompleteInterruptEnable = SPI_RSER_TCF_RE_MASK,          /*!< TCF  interrupt enable.*/
  86:../drivers/fsl_dspi.h ****     kDSPI_EndOfQueueInterruptEnable = SPI_RSER_EOQF_RE_MASK,         /*!< EOQF interrupt enable.*/
  87:../drivers/fsl_dspi.h ****     kDSPI_TxFifoUnderflowInterruptEnable = SPI_RSER_TFUF_RE_MASK,    /*!< TFUF interrupt enable.*/
  88:../drivers/fsl_dspi.h ****     kDSPI_TxFifoFillRequestInterruptEnable = SPI_RSER_TFFF_RE_MASK,  /*!< TFFF interrupt enable, DM
  89:../drivers/fsl_dspi.h ****     kDSPI_RxFifoOverflowInterruptEnable = SPI_RSER_RFOF_RE_MASK,     /*!< RFOF interrupt enable.*/
  90:../drivers/fsl_dspi.h ****     kDSPI_RxFifoDrainRequestInterruptEnable = SPI_RSER_RFDF_RE_MASK, /*!< RFDF interrupt enable, DM
  91:../drivers/fsl_dspi.h ****     kDSPI_AllInterruptEnable = SPI_RSER_TCF_RE_MASK | SPI_RSER_EOQF_RE_MASK | SPI_RSER_TFUF_RE_MASK
  92:../drivers/fsl_dspi.h ****                                SPI_RSER_TFFF_RE_MASK | SPI_RSER_RFOF_RE_MASK | SPI_RSER_RFDF_RE_MAS
  93:../drivers/fsl_dspi.h ****     /*!< All above interrupts enable.*/
  94:../drivers/fsl_dspi.h **** };
  95:../drivers/fsl_dspi.h **** 
  96:../drivers/fsl_dspi.h **** /*! @brief DSPI DMA source.*/
  97:../drivers/fsl_dspi.h **** enum _dspi_dma_enable
  98:../drivers/fsl_dspi.h **** {
  99:../drivers/fsl_dspi.h ****     kDSPI_TxDmaEnable = (SPI_RSER_TFFF_RE_MASK | SPI_RSER_TFFF_DIRS_MASK), /*!< TFFF flag generates
 100:../drivers/fsl_dspi.h ****                                                                                 No Tx interrupt req
 101:../drivers/fsl_dspi.h ****     kDSPI_RxDmaEnable = (SPI_RSER_RFDF_RE_MASK | SPI_RSER_RFDF_DIRS_MASK)  /*!< RFDF flag generates
 102:../drivers/fsl_dspi.h ****                                                                                 No Rx interrupt req
 103:../drivers/fsl_dspi.h **** };
 104:../drivers/fsl_dspi.h **** 
 105:../drivers/fsl_dspi.h **** /*! @brief DSPI master or slave mode configuration.*/
 106:../drivers/fsl_dspi.h **** typedef enum _dspi_master_slave_mode
 107:../drivers/fsl_dspi.h **** {
 108:../drivers/fsl_dspi.h ****     kDSPI_Master = 1U, /*!< DSPI peripheral operates in master mode.*/
 109:../drivers/fsl_dspi.h ****     kDSPI_Slave = 0U   /*!< DSPI peripheral operates in slave mode.*/
 110:../drivers/fsl_dspi.h **** } dspi_master_slave_mode_t;
 111:../drivers/fsl_dspi.h **** 
 112:../drivers/fsl_dspi.h **** /*!
 113:../drivers/fsl_dspi.h ****  * @brief DSPI Sample Point: Controls when the DSPI master samples SIN in the Modified Transfer For
 114:../drivers/fsl_dspi.h ****  * valid
 115:../drivers/fsl_dspi.h ****  * only when the CPHA bit in the CTAR register is 0.
 116:../drivers/fsl_dspi.h ****  */
 117:../drivers/fsl_dspi.h **** typedef enum _dspi_master_sample_point
 118:../drivers/fsl_dspi.h **** {
 119:../drivers/fsl_dspi.h ****     kDSPI_SckToSin0Clock = 0U, /*!< 0 system clocks between SCK edge and SIN sample.*/
 120:../drivers/fsl_dspi.h ****     kDSPI_SckToSin1Clock = 1U, /*!< 1 system clock  between SCK edge and SIN sample.*/
 121:../drivers/fsl_dspi.h ****     kDSPI_SckToSin2Clock = 2U  /*!< 2 system clocks between SCK edge and SIN sample.*/
 122:../drivers/fsl_dspi.h **** } dspi_master_sample_point_t;
 123:../drivers/fsl_dspi.h **** 
 124:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) configuration (which Pcs to configure).*/
 125:../drivers/fsl_dspi.h **** typedef enum _dspi_which_pcs_config
 126:../drivers/fsl_dspi.h **** {
 127:../drivers/fsl_dspi.h ****     kDSPI_Pcs0 = 1U << 0, /*!< Pcs[0] */
 128:../drivers/fsl_dspi.h ****     kDSPI_Pcs1 = 1U << 1, /*!< Pcs[1] */
 129:../drivers/fsl_dspi.h ****     kDSPI_Pcs2 = 1U << 2, /*!< Pcs[2] */
 130:../drivers/fsl_dspi.h ****     kDSPI_Pcs3 = 1U << 3, /*!< Pcs[3] */
 131:../drivers/fsl_dspi.h ****     kDSPI_Pcs4 = 1U << 4, /*!< Pcs[4] */
 132:../drivers/fsl_dspi.h ****     kDSPI_Pcs5 = 1U << 5  /*!< Pcs[5] */
 133:../drivers/fsl_dspi.h **** } dspi_which_pcs_t;
 134:../drivers/fsl_dspi.h **** 
 135:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) Polarity configuration.*/
 136:../drivers/fsl_dspi.h **** typedef enum _dspi_pcs_polarity_config
 137:../drivers/fsl_dspi.h **** {
 138:../drivers/fsl_dspi.h ****     kDSPI_PcsActiveHigh = 0U, /*!< Pcs Active High (idles low). */
 139:../drivers/fsl_dspi.h ****     kDSPI_PcsActiveLow = 1U   /*!< Pcs Active Low (idles high). */
 140:../drivers/fsl_dspi.h **** } dspi_pcs_polarity_config_t;
 141:../drivers/fsl_dspi.h **** 
 142:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) Polarity.*/
 143:../drivers/fsl_dspi.h **** enum _dspi_pcs_polarity
 144:../drivers/fsl_dspi.h **** {
 145:../drivers/fsl_dspi.h ****     kDSPI_Pcs0ActiveLow = 1U << 0, /*!< Pcs0 Active Low (idles high). */
 146:../drivers/fsl_dspi.h ****     kDSPI_Pcs1ActiveLow = 1U << 1, /*!< Pcs1 Active Low (idles high). */
 147:../drivers/fsl_dspi.h ****     kDSPI_Pcs2ActiveLow = 1U << 2, /*!< Pcs2 Active Low (idles high). */
 148:../drivers/fsl_dspi.h ****     kDSPI_Pcs3ActiveLow = 1U << 3, /*!< Pcs3 Active Low (idles high). */
 149:../drivers/fsl_dspi.h ****     kDSPI_Pcs4ActiveLow = 1U << 4, /*!< Pcs4 Active Low (idles high). */
 150:../drivers/fsl_dspi.h ****     kDSPI_Pcs5ActiveLow = 1U << 5, /*!< Pcs5 Active Low (idles high). */
 151:../drivers/fsl_dspi.h ****     kDSPI_PcsAllActiveLow = 0xFFU  /*!< Pcs0 to Pcs5 Active Low (idles high). */
 152:../drivers/fsl_dspi.h **** };
 153:../drivers/fsl_dspi.h **** 
 154:../drivers/fsl_dspi.h **** /*! @brief DSPI clock polarity configuration for a given CTAR.*/
 155:../drivers/fsl_dspi.h **** typedef enum _dspi_clock_polarity
 156:../drivers/fsl_dspi.h **** {
 157:../drivers/fsl_dspi.h ****     kDSPI_ClockPolarityActiveHigh = 0U, /*!< CPOL=0. Active-high DSPI clock (idles low).*/
 158:../drivers/fsl_dspi.h ****     kDSPI_ClockPolarityActiveLow = 1U   /*!< CPOL=1. Active-low DSPI clock (idles high).*/
 159:../drivers/fsl_dspi.h **** } dspi_clock_polarity_t;
 160:../drivers/fsl_dspi.h **** 
 161:../drivers/fsl_dspi.h **** /*! @brief DSPI clock phase configuration for a given CTAR.*/
 162:../drivers/fsl_dspi.h **** typedef enum _dspi_clock_phase
 163:../drivers/fsl_dspi.h **** {
 164:../drivers/fsl_dspi.h ****     kDSPI_ClockPhaseFirstEdge = 0U, /*!< CPHA=0. Data is captured on the leading edge of the SCK an
 165:../drivers/fsl_dspi.h ****                                          following edge.*/
 166:../drivers/fsl_dspi.h ****     kDSPI_ClockPhaseSecondEdge = 1U /*!< CPHA=1. Data is changed on the leading edge of the SCK and
 167:../drivers/fsl_dspi.h ****                                         following edge.*/
 168:../drivers/fsl_dspi.h **** } dspi_clock_phase_t;
 169:../drivers/fsl_dspi.h **** 
 170:../drivers/fsl_dspi.h **** /*! @brief DSPI data shifter direction options for a given CTAR.*/
 171:../drivers/fsl_dspi.h **** typedef enum _dspi_shift_direction
 172:../drivers/fsl_dspi.h **** {
 173:../drivers/fsl_dspi.h ****     kDSPI_MsbFirst = 0U, /*!< Data transfers start with most significant bit.*/
 174:../drivers/fsl_dspi.h ****     kDSPI_LsbFirst = 1U  /*!< Data transfers start with least significant bit.
 175:../drivers/fsl_dspi.h ****                               Shifting out of LSB is not supported for slave */
 176:../drivers/fsl_dspi.h **** } dspi_shift_direction_t;
 177:../drivers/fsl_dspi.h **** 
 178:../drivers/fsl_dspi.h **** /*! @brief DSPI delay type selection.*/
 179:../drivers/fsl_dspi.h **** typedef enum _dspi_delay_type
 180:../drivers/fsl_dspi.h **** {
 181:../drivers/fsl_dspi.h ****     kDSPI_PcsToSck = 1U,  /*!< Pcs-to-SCK delay. */
 182:../drivers/fsl_dspi.h ****     kDSPI_LastSckToPcs,   /*!< The last SCK edge to Pcs delay. */
 183:../drivers/fsl_dspi.h ****     kDSPI_BetweenTransfer /*!< Delay between transfers. */
 184:../drivers/fsl_dspi.h **** } dspi_delay_type_t;
 185:../drivers/fsl_dspi.h **** 
 186:../drivers/fsl_dspi.h **** /*! @brief DSPI Clock and Transfer Attributes Register (CTAR) selection.*/
 187:../drivers/fsl_dspi.h **** typedef enum _dspi_ctar_selection
 188:../drivers/fsl_dspi.h **** {
 189:../drivers/fsl_dspi.h ****     kDSPI_Ctar0 = 0U, /*!< CTAR0 selection option for master or slave mode; note that CTAR0 and CTA
 190:../drivers/fsl_dspi.h ****                          same register address. */
 191:../drivers/fsl_dspi.h ****     kDSPI_Ctar1 = 1U, /*!< CTAR1 selection option for master mode only. */
 192:../drivers/fsl_dspi.h ****     kDSPI_Ctar2 = 2U, /*!< CTAR2 selection option for master mode only; note that some devices do n
 193:../drivers/fsl_dspi.h ****     kDSPI_Ctar3 = 3U, /*!< CTAR3 selection option for master mode only; note that some devices do n
 194:../drivers/fsl_dspi.h ****     kDSPI_Ctar4 = 4U, /*!< CTAR4 selection option for master mode only; note that some devices do n
 195:../drivers/fsl_dspi.h ****     kDSPI_Ctar5 = 5U, /*!< CTAR5 selection option for master mode only; note that some devices do n
 196:../drivers/fsl_dspi.h ****     kDSPI_Ctar6 = 6U, /*!< CTAR6 selection option for master mode only; note that some devices do n
 197:../drivers/fsl_dspi.h ****     kDSPI_Ctar7 = 7U  /*!< CTAR7 selection option for master mode only; note that some devices do n
 198:../drivers/fsl_dspi.h **** } dspi_ctar_selection_t;
 199:../drivers/fsl_dspi.h **** 
 200:../drivers/fsl_dspi.h **** #define DSPI_MASTER_CTAR_SHIFT (0U)   /*!< DSPI master CTAR shift macro; used internally. */
 201:../drivers/fsl_dspi.h **** #define DSPI_MASTER_CTAR_MASK (0x0FU) /*!< DSPI master CTAR mask macro; used internally. */
 202:../drivers/fsl_dspi.h **** #define DSPI_MASTER_PCS_SHIFT (4U)    /*!< DSPI master PCS shift macro; used internally. */
 203:../drivers/fsl_dspi.h **** #define DSPI_MASTER_PCS_MASK (0xF0U)  /*!< DSPI master PCS mask macro; used internally. */
 204:../drivers/fsl_dspi.h **** /*! @brief Use this enumeration for the DSPI master transfer configFlags. */
 205:../drivers/fsl_dspi.h **** enum _dspi_transfer_config_flag_for_master
 206:../drivers/fsl_dspi.h **** {
 207:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar0 = 0U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR0 setting. 
 208:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar1 = 1U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR1 setting. 
 209:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar2 = 2U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR2 setting. 
 210:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar3 = 3U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR3 setting. 
 211:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar4 = 4U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR4 setting. 
 212:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar5 = 5U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR5 setting. 
 213:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar6 = 6U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR6 setting. 
 214:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar7 = 7U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR7 setting. 
 215:../drivers/fsl_dspi.h **** 
 216:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs0 = 0U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS0 signal. */
 217:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs1 = 1U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS1 signal. */
 218:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs2 = 2U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS2 signal.*/
 219:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs3 = 3U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS3 signal. */
 220:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs4 = 4U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS4 signal. */
 221:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs5 = 5U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS5 signal. */
 222:../drivers/fsl_dspi.h **** 
 223:../drivers/fsl_dspi.h ****     kDSPI_MasterPcsContinuous = 1U << 20, /*!< Indicates whether the PCS signal is continuous. */
 224:../drivers/fsl_dspi.h ****     kDSPI_MasterActiveAfterTransfer =
 225:../drivers/fsl_dspi.h ****         1U << 21, /*!< Indicates whether the PCS signal is active after the last frame transfer.*/
 226:../drivers/fsl_dspi.h **** };
 227:../drivers/fsl_dspi.h **** 
 228:../drivers/fsl_dspi.h **** #define DSPI_SLAVE_CTAR_SHIFT (0U)   /*!< DSPI slave CTAR shift macro; used internally. */
 229:../drivers/fsl_dspi.h **** #define DSPI_SLAVE_CTAR_MASK (0x07U) /*!< DSPI slave CTAR mask macro; used internally. */
 230:../drivers/fsl_dspi.h **** /*! @brief Use this enumeration for the DSPI slave transfer configFlags. */
 231:../drivers/fsl_dspi.h **** enum _dspi_transfer_config_flag_for_slave
 232:../drivers/fsl_dspi.h **** {
 233:../drivers/fsl_dspi.h ****     kDSPI_SlaveCtar0 = 0U << DSPI_SLAVE_CTAR_SHIFT, /*!< DSPI slave transfer use CTAR0 setting. */
 234:../drivers/fsl_dspi.h ****                                                     /*!< DSPI slave can only use PCS0. */
 235:../drivers/fsl_dspi.h **** };
 236:../drivers/fsl_dspi.h **** 
 237:../drivers/fsl_dspi.h **** /*! @brief DSPI transfer state, which is used for DSPI transactional API state machine. */
 238:../drivers/fsl_dspi.h **** enum _dspi_transfer_state
 239:../drivers/fsl_dspi.h **** {
 240:../drivers/fsl_dspi.h ****     kDSPI_Idle = 0x0U, /*!< Nothing in the transmitter/receiver. */
 241:../drivers/fsl_dspi.h ****     kDSPI_Busy,        /*!< Transfer queue is not finished. */
 242:../drivers/fsl_dspi.h ****     kDSPI_Error        /*!< Transfer error. */
 243:../drivers/fsl_dspi.h **** };
 244:../drivers/fsl_dspi.h **** 
 245:../drivers/fsl_dspi.h **** /*! @brief DSPI master command date configuration used for the SPIx_PUSHR.*/
 246:../drivers/fsl_dspi.h **** typedef struct _dspi_command_data_config
 247:../drivers/fsl_dspi.h **** {
 248:../drivers/fsl_dspi.h ****     bool isPcsContinuous; /*!< Option to enable the continuous assertion of the chip select between
 249:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar; /*!< The desired Clock and Transfer Attributes
 250:../drivers/fsl_dspi.h ****                                           Register (CTAR) to use for CTAS.*/
 251:../drivers/fsl_dspi.h ****     dspi_which_pcs_t whichPcs;       /*!< The desired PCS signal to use for the data transfer.*/
 252:../drivers/fsl_dspi.h ****     bool isEndOfQueue;               /*!< Signals that the current transfer is the last in the queu
 253:../drivers/fsl_dspi.h ****     bool clearTransferCount;         /*!< Clears the SPI Transfer Counter (SPI_TCNT) before transmi
 254:../drivers/fsl_dspi.h **** } dspi_command_data_config_t;
 255:../drivers/fsl_dspi.h **** 
 256:../drivers/fsl_dspi.h **** /*! @brief DSPI master ctar configuration structure.*/
 257:../drivers/fsl_dspi.h **** typedef struct _dspi_master_ctar_config
 258:../drivers/fsl_dspi.h **** {
 259:../drivers/fsl_dspi.h ****     uint32_t baudRate;                /*!< Baud Rate for DSPI. */
 260:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;            /*!< Bits per frame, minimum 4, maximum 16.*/
 261:../drivers/fsl_dspi.h ****     dspi_clock_polarity_t cpol;       /*!< Clock polarity. */
 262:../drivers/fsl_dspi.h ****     dspi_clock_phase_t cpha;          /*!< Clock phase. */
 263:../drivers/fsl_dspi.h ****     dspi_shift_direction_t direction; /*!< MSB or LSB data shift direction. */
 264:../drivers/fsl_dspi.h **** 
 265:../drivers/fsl_dspi.h ****     uint32_t pcsToSckDelayInNanoSec;     /*!< PCS to SCK delay time in nanoseconds; setting to 0 se
 266:../drivers/fsl_dspi.h ****                                             delay. It also sets the boundary value if out of range.
 267:../drivers/fsl_dspi.h ****     uint32_t lastSckToPcsDelayInNanoSec; /*!< The last SCK to PCS delay time in nanoseconds; settin
 268:../drivers/fsl_dspi.h ****                                             minimum delay. It also sets the boundary value if out o
 269:../drivers/fsl_dspi.h **** 
 270:../drivers/fsl_dspi.h ****     uint32_t betweenTransferDelayInNanoSec; /*!< After the SCK delay time in nanoseconds; setting t
 271:../drivers/fsl_dspi.h ****                                              delay. It also sets the boundary value if out of range
 272:../drivers/fsl_dspi.h **** } dspi_master_ctar_config_t;
 273:../drivers/fsl_dspi.h **** 
 274:../drivers/fsl_dspi.h **** /*! @brief DSPI master configuration structure.*/
 275:../drivers/fsl_dspi.h **** typedef struct _dspi_master_config
 276:../drivers/fsl_dspi.h **** {
 277:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar;      /*!< The desired CTAR to use. */
 278:../drivers/fsl_dspi.h ****     dspi_master_ctar_config_t ctarConfig; /*!< Set the ctarConfig to the desired CTAR. */
 279:../drivers/fsl_dspi.h **** 
 280:../drivers/fsl_dspi.h ****     dspi_which_pcs_t whichPcs;                     /*!< The desired Peripheral Chip Select (pcs). *
 281:../drivers/fsl_dspi.h ****     dspi_pcs_polarity_config_t pcsActiveHighOrLow; /*!< The desired PCS active high or low. */
 282:../drivers/fsl_dspi.h **** 
 283:../drivers/fsl_dspi.h ****     bool enableContinuousSCK;   /*!< CONT_SCKE, continuous SCK enable. Note that the continuous SCK
 284:../drivers/fsl_dspi.h ****                                      supported for CPHA = 1.*/
 285:../drivers/fsl_dspi.h ****     bool enableRxFifoOverWrite; /*!< ROOE, receive FIFO overflow overwrite enable. If ROOE = 0, the
 286:../drivers/fsl_dspi.h ****                                      data is ignored and the data from the transfer that generated 
 287:../drivers/fsl_dspi.h ****                                      is also ignored. If ROOE = 1, the incoming data is shifted to 
 288:../drivers/fsl_dspi.h ****                                      shift register. */
 289:../drivers/fsl_dspi.h **** 
 290:../drivers/fsl_dspi.h ****     bool enableModifiedTimingFormat;        /*!< Enables a modified transfer format to be used if t
 291:../drivers/fsl_dspi.h ****     dspi_master_sample_point_t samplePoint; /*!< Controls when the module master samples SIN in the
 292:../drivers/fsl_dspi.h ****                                                  Format. It's valid only when CPHA=0. */
 293:../drivers/fsl_dspi.h **** } dspi_master_config_t;
 294:../drivers/fsl_dspi.h **** 
 295:../drivers/fsl_dspi.h **** /*! @brief DSPI slave ctar configuration structure.*/
 296:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_ctar_config
 297:../drivers/fsl_dspi.h **** {
 298:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;      /*!< Bits per frame, minimum 4, maximum 16.*/
 299:../drivers/fsl_dspi.h ****     dspi_clock_polarity_t cpol; /*!< Clock polarity. */
 300:../drivers/fsl_dspi.h ****     dspi_clock_phase_t cpha;    /*!< Clock phase. */
 301:../drivers/fsl_dspi.h ****                                 /*!< Slave only supports MSB and does not support LSB.*/
 302:../drivers/fsl_dspi.h **** } dspi_slave_ctar_config_t;
 303:../drivers/fsl_dspi.h **** 
 304:../drivers/fsl_dspi.h **** /*! @brief DSPI slave configuration structure.*/
 305:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_config
 306:../drivers/fsl_dspi.h **** {
 307:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar;     /*!< The desired CTAR to use. */
 308:../drivers/fsl_dspi.h ****     dspi_slave_ctar_config_t ctarConfig; /*!< Set the ctarConfig to the desired CTAR. */
 309:../drivers/fsl_dspi.h **** 
 310:../drivers/fsl_dspi.h ****     bool enableContinuousSCK;               /*!< CONT_SCKE, continuous SCK enable. Note that the co
 311:../drivers/fsl_dspi.h ****                                                  supported for CPHA = 1.*/
 312:../drivers/fsl_dspi.h ****     bool enableRxFifoOverWrite;             /*!< ROOE, receive FIFO overflow overwrite enable. If R
 313:../drivers/fsl_dspi.h ****                                                  data is ignored and the data from the transfer tha
 314:../drivers/fsl_dspi.h ****                                                  is also ignored. If ROOE = 1, the incoming data is
 315:../drivers/fsl_dspi.h ****                                                  shift register. */
 316:../drivers/fsl_dspi.h ****     bool enableModifiedTimingFormat;        /*!< Enables a modified transfer format to be used if t
 317:../drivers/fsl_dspi.h ****     dspi_master_sample_point_t samplePoint; /*!< Controls when the module master samples SIN in the
 318:../drivers/fsl_dspi.h ****                                                Format. It's valid only when CPHA=0. */
 319:../drivers/fsl_dspi.h **** } dspi_slave_config_t;
 320:../drivers/fsl_dspi.h **** 
 321:../drivers/fsl_dspi.h **** /*!
 322:../drivers/fsl_dspi.h **** * @brief Forward declaration of the _dspi_master_handle typedefs.
 323:../drivers/fsl_dspi.h **** */
 324:../drivers/fsl_dspi.h **** typedef struct _dspi_master_handle dspi_master_handle_t;
 325:../drivers/fsl_dspi.h **** 
 326:../drivers/fsl_dspi.h **** /*!
 327:../drivers/fsl_dspi.h **** * @brief Forward declaration of the _dspi_slave_handle typedefs.
 328:../drivers/fsl_dspi.h **** */
 329:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_handle dspi_slave_handle_t;
 330:../drivers/fsl_dspi.h **** 
 331:../drivers/fsl_dspi.h **** /*!
 332:../drivers/fsl_dspi.h ****  * @brief Completion callback function pointer type.
 333:../drivers/fsl_dspi.h ****  *
 334:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 335:../drivers/fsl_dspi.h ****  * @param handle Pointer to the handle for the DSPI master.
 336:../drivers/fsl_dspi.h ****  * @param status Success or error code describing whether the transfer completed.
 337:../drivers/fsl_dspi.h ****  * @param userData Arbitrary pointer-dataSized value passed from the application.
 338:../drivers/fsl_dspi.h ****  */
 339:../drivers/fsl_dspi.h **** typedef void (*dspi_master_transfer_callback_t)(SPI_Type *base,
 340:../drivers/fsl_dspi.h ****                                                 dspi_master_handle_t *handle,
 341:../drivers/fsl_dspi.h ****                                                 status_t status,
 342:../drivers/fsl_dspi.h ****                                                 void *userData);
 343:../drivers/fsl_dspi.h **** /*!
 344:../drivers/fsl_dspi.h ****  * @brief Completion callback function pointer type.
 345:../drivers/fsl_dspi.h ****  *
 346:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 347:../drivers/fsl_dspi.h ****  * @param handle Pointer to the handle for the DSPI slave.
 348:../drivers/fsl_dspi.h ****  * @param status Success or error code describing whether the transfer completed.
 349:../drivers/fsl_dspi.h ****  * @param userData Arbitrary pointer-dataSized value passed from the application.
 350:../drivers/fsl_dspi.h ****  */
 351:../drivers/fsl_dspi.h **** typedef void (*dspi_slave_transfer_callback_t)(SPI_Type *base,
 352:../drivers/fsl_dspi.h ****                                                dspi_slave_handle_t *handle,
 353:../drivers/fsl_dspi.h ****                                                status_t status,
 354:../drivers/fsl_dspi.h ****                                                void *userData);
 355:../drivers/fsl_dspi.h **** 
 356:../drivers/fsl_dspi.h **** /*! @brief DSPI master/slave transfer structure.*/
 357:../drivers/fsl_dspi.h **** typedef struct _dspi_transfer
 358:../drivers/fsl_dspi.h **** {
 359:../drivers/fsl_dspi.h ****     uint8_t *txData;          /*!< Send buffer. */
 360:../drivers/fsl_dspi.h ****     uint8_t *rxData;          /*!< Receive buffer. */
 361:../drivers/fsl_dspi.h ****     volatile size_t dataSize; /*!< Transfer bytes. */
 362:../drivers/fsl_dspi.h **** 
 363:../drivers/fsl_dspi.h ****     uint32_t
 364:../drivers/fsl_dspi.h ****         configFlags; /*!< Transfer transfer configuration flags; set from _dspi_transfer_config_fla
 365:../drivers/fsl_dspi.h ****                         transfer is used for master or _dspi_transfer_config_flag_for_slave enumera
 366:../drivers/fsl_dspi.h ****                         is used for slave.*/
 367:../drivers/fsl_dspi.h **** } dspi_transfer_t;
 368:../drivers/fsl_dspi.h **** 
 369:../drivers/fsl_dspi.h **** /*! @brief DSPI half-duplex(master) transfer structure */
 370:../drivers/fsl_dspi.h **** typedef struct _dspi_half_duplex_transfer
 371:../drivers/fsl_dspi.h **** {
 372:../drivers/fsl_dspi.h ****     uint8_t *txData;            /*!< Send buffer */
 373:../drivers/fsl_dspi.h ****     uint8_t *rxData;            /*!< Receive buffer */
 374:../drivers/fsl_dspi.h ****     size_t txDataSize;          /*!< Transfer bytes for transmit */
 375:../drivers/fsl_dspi.h ****     size_t rxDataSize;          /*!< Transfer bytes */
 376:../drivers/fsl_dspi.h ****     uint32_t configFlags;       /*!< Transfer configuration flags; set from _dspi_transfer_config_f
 377:../drivers/fsl_dspi.h ****     bool isPcsAssertInTransfer; /*!< If Pcs pin keep assert between transmit and receive. true for 
 378:../drivers/fsl_dspi.h ****                                    deassert. */
 379:../drivers/fsl_dspi.h ****     bool isTransmitFirst;       /*!< True for transmit first and false for receive first. */
 380:../drivers/fsl_dspi.h **** } dspi_half_duplex_transfer_t;
 381:../drivers/fsl_dspi.h **** 
 382:../drivers/fsl_dspi.h **** /*! @brief DSPI master transfer handle structure used for transactional API. */
 383:../drivers/fsl_dspi.h **** struct _dspi_master_handle
 384:../drivers/fsl_dspi.h **** {
 385:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;         /*!< The desired number of bits per frame. */
 386:../drivers/fsl_dspi.h ****     volatile uint32_t command;     /*!< The desired data command. */
 387:../drivers/fsl_dspi.h ****     volatile uint32_t lastCommand; /*!< The desired last data command. */
 388:../drivers/fsl_dspi.h **** 
 389:../drivers/fsl_dspi.h ****     uint8_t fifoSize; /*!< FIFO dataSize. */
 390:../drivers/fsl_dspi.h **** 
 391:../drivers/fsl_dspi.h ****     volatile bool
 392:../drivers/fsl_dspi.h ****         isPcsActiveAfterTransfer;   /*!< Indicates whether the PCS signal is active after the last 
 393:../drivers/fsl_dspi.h ****     volatile bool isThereExtraByte; /*!< Indicates whether there are extra bytes.*/
 394:../drivers/fsl_dspi.h **** 
 395:../drivers/fsl_dspi.h ****     uint8_t *volatile txData;                  /*!< Send buffer. */
 396:../drivers/fsl_dspi.h ****     uint8_t *volatile rxData;                  /*!< Receive buffer. */
 397:../drivers/fsl_dspi.h ****     volatile size_t remainingSendByteCount;    /*!< A number of bytes remaining to send.*/
 398:../drivers/fsl_dspi.h ****     volatile size_t remainingReceiveByteCount; /*!< A number of bytes remaining to receive.*/
 399:../drivers/fsl_dspi.h ****     size_t totalByteCount;                     /*!< A number of transfer bytes*/
 400:../drivers/fsl_dspi.h **** 
 401:../drivers/fsl_dspi.h ****     volatile uint8_t state; /*!< DSPI transfer state, see _dspi_transfer_state.*/
 402:../drivers/fsl_dspi.h **** 
 403:../drivers/fsl_dspi.h ****     dspi_master_transfer_callback_t callback; /*!< Completion callback. */
 404:../drivers/fsl_dspi.h ****     void *userData;                           /*!< Callback user data. */
 405:../drivers/fsl_dspi.h **** };
 406:../drivers/fsl_dspi.h **** 
 407:../drivers/fsl_dspi.h **** /*! @brief DSPI slave transfer handle structure used for the transactional API. */
 408:../drivers/fsl_dspi.h **** struct _dspi_slave_handle
 409:../drivers/fsl_dspi.h **** {
 410:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;          /*!< The desired number of bits per frame. */
 411:../drivers/fsl_dspi.h ****     volatile bool isThereExtraByte; /*!< Indicates whether there are extra bytes.*/
 412:../drivers/fsl_dspi.h **** 
 413:../drivers/fsl_dspi.h ****     uint8_t *volatile txData;                  /*!< Send buffer. */
 414:../drivers/fsl_dspi.h ****     uint8_t *volatile rxData;                  /*!< Receive buffer. */
 415:../drivers/fsl_dspi.h ****     volatile size_t remainingSendByteCount;    /*!< A number of bytes remaining to send.*/
 416:../drivers/fsl_dspi.h ****     volatile size_t remainingReceiveByteCount; /*!< A number of bytes remaining to receive.*/
 417:../drivers/fsl_dspi.h ****     size_t totalByteCount;                     /*!< A number of transfer bytes*/
 418:../drivers/fsl_dspi.h **** 
 419:../drivers/fsl_dspi.h ****     volatile uint8_t state; /*!< DSPI transfer state.*/
 420:../drivers/fsl_dspi.h **** 
 421:../drivers/fsl_dspi.h ****     volatile uint32_t errorCount; /*!< Error count for slave transfer.*/
 422:../drivers/fsl_dspi.h **** 
 423:../drivers/fsl_dspi.h ****     dspi_slave_transfer_callback_t callback; /*!< Completion callback. */
 424:../drivers/fsl_dspi.h ****     void *userData;                          /*!< Callback user data. */
 425:../drivers/fsl_dspi.h **** };
 426:../drivers/fsl_dspi.h **** 
 427:../drivers/fsl_dspi.h **** /**************************************************************************************************
 428:../drivers/fsl_dspi.h ****  * API
 429:../drivers/fsl_dspi.h ****  **************************************************************************************************
 430:../drivers/fsl_dspi.h **** #if defined(__cplusplus)
 431:../drivers/fsl_dspi.h **** extern "C" {
 432:../drivers/fsl_dspi.h **** #endif /*_cplusplus*/
 433:../drivers/fsl_dspi.h **** 
 434:../drivers/fsl_dspi.h **** /*!
 435:../drivers/fsl_dspi.h ****  * @name Initialization and deinitialization
 436:../drivers/fsl_dspi.h ****  * @{
 437:../drivers/fsl_dspi.h ****  */
 438:../drivers/fsl_dspi.h **** 
 439:../drivers/fsl_dspi.h **** /*!
 440:../drivers/fsl_dspi.h ****  * @brief Initializes the DSPI master.
 441:../drivers/fsl_dspi.h ****  *
 442:../drivers/fsl_dspi.h ****  * This function initializes the DSPI master configuration. This is an example use case.
 443:../drivers/fsl_dspi.h ****  *  @code
 444:../drivers/fsl_dspi.h ****  *   dspi_master_config_t  masterConfig;
 445:../drivers/fsl_dspi.h ****  *   masterConfig.whichCtar                                = kDSPI_Ctar0;
 446:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.baudRate                      = 500000000U;
 447:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.bitsPerFrame                  = 8;
 448:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.cpol                          = kDSPI_ClockPolarityActiveHigh;
 449:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.cpha                          = kDSPI_ClockPhaseFirstEdge;
 450:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.direction                     = kDSPI_MsbFirst;
 451:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.pcsToSckDelayInNanoSec        = 1000000000U / masterConfig.ctarConfig.
 452:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec    = 1000000000U / masterConfig.ctarConfig.
 453:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 1000000000U / masterConfig.ctarConfig.
 454:../drivers/fsl_dspi.h ****  *   masterConfig.whichPcs                                 = kDSPI_Pcs0;
 455:../drivers/fsl_dspi.h ****  *   masterConfig.pcsActiveHighOrLow                       = kDSPI_PcsActiveLow;
 456:../drivers/fsl_dspi.h ****  *   masterConfig.enableContinuousSCK                      = false;
 457:../drivers/fsl_dspi.h ****  *   masterConfig.enableRxFifoOverWrite                    = false;
 458:../drivers/fsl_dspi.h ****  *   masterConfig.enableModifiedTimingFormat               = false;
 459:../drivers/fsl_dspi.h ****  *   masterConfig.samplePoint                              = kDSPI_SckToSin0Clock;
 460:../drivers/fsl_dspi.h ****  *   DSPI_MasterInit(base, &masterConfig, srcClock_Hz);
 461:../drivers/fsl_dspi.h ****  *  @endcode
 462:../drivers/fsl_dspi.h ****  *
 463:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 464:../drivers/fsl_dspi.h ****  * @param masterConfig Pointer to the structure dspi_master_config_t.
 465:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz.
 466:../drivers/fsl_dspi.h ****  */
 467:../drivers/fsl_dspi.h **** void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz
 468:../drivers/fsl_dspi.h **** 
 469:../drivers/fsl_dspi.h **** /*!
 470:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_master_config_t structure to default values.
 471:../drivers/fsl_dspi.h ****  *
 472:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for the DSPI_MasterIni
 473:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_MasterInit() or modify the structu
 474:../drivers/fsl_dspi.h ****  * before calling the DSPI_MasterInit().
 475:../drivers/fsl_dspi.h ****  * Example:
 476:../drivers/fsl_dspi.h ****  * @code
 477:../drivers/fsl_dspi.h ****  *  dspi_master_config_t  masterConfig;
 478:../drivers/fsl_dspi.h ****  *  DSPI_MasterGetDefaultConfig(&masterConfig);
 479:../drivers/fsl_dspi.h ****  * @endcode
 480:../drivers/fsl_dspi.h ****  * @param masterConfig pointer to dspi_master_config_t structure
 481:../drivers/fsl_dspi.h ****  */
 482:../drivers/fsl_dspi.h **** void DSPI_MasterGetDefaultConfig(dspi_master_config_t *masterConfig);
 483:../drivers/fsl_dspi.h **** 
 484:../drivers/fsl_dspi.h **** /*!
 485:../drivers/fsl_dspi.h ****  * @brief DSPI slave configuration.
 486:../drivers/fsl_dspi.h ****  *
 487:../drivers/fsl_dspi.h ****  * This function initializes the DSPI slave configuration. This is an example use case.
 488:../drivers/fsl_dspi.h ****  *  @code
 489:../drivers/fsl_dspi.h ****  *   dspi_slave_config_t  slaveConfig;
 490:../drivers/fsl_dspi.h ****  *  slaveConfig->whichCtar                  = kDSPI_Ctar0;
 491:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.bitsPerFrame    = 8;
 492:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.cpol            = kDSPI_ClockPolarityActiveHigh;
 493:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.cpha            = kDSPI_ClockPhaseFirstEdge;
 494:../drivers/fsl_dspi.h ****  *  slaveConfig->enableContinuousSCK        = false;
 495:../drivers/fsl_dspi.h ****  *  slaveConfig->enableRxFifoOverWrite      = false;
 496:../drivers/fsl_dspi.h ****  *  slaveConfig->enableModifiedTimingFormat = false;
 497:../drivers/fsl_dspi.h ****  *  slaveConfig->samplePoint                = kDSPI_SckToSin0Clock;
 498:../drivers/fsl_dspi.h ****  *   DSPI_SlaveInit(base, &slaveConfig);
 499:../drivers/fsl_dspi.h ****  *  @endcode
 500:../drivers/fsl_dspi.h ****  *
 501:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 502:../drivers/fsl_dspi.h ****  * @param slaveConfig Pointer to the structure dspi_master_config_t.
 503:../drivers/fsl_dspi.h ****  */
 504:../drivers/fsl_dspi.h **** void DSPI_SlaveInit(SPI_Type *base, const dspi_slave_config_t *slaveConfig);
 505:../drivers/fsl_dspi.h **** 
 506:../drivers/fsl_dspi.h **** /*!
 507:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_slave_config_t structure to a default value.
 508:../drivers/fsl_dspi.h ****  *
 509:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for the DSPI_SlaveInit
 510:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_SlaveInit() or modify the structur
 511:../drivers/fsl_dspi.h ****  * before calling the DSPI_SlaveInit().
 512:../drivers/fsl_dspi.h ****  * This is an example.
 513:../drivers/fsl_dspi.h ****  * @code
 514:../drivers/fsl_dspi.h ****  *  dspi_slave_config_t  slaveConfig;
 515:../drivers/fsl_dspi.h ****  *  DSPI_SlaveGetDefaultConfig(&slaveConfig);
 516:../drivers/fsl_dspi.h ****  * @endcode
 517:../drivers/fsl_dspi.h ****  * @param slaveConfig Pointer to the dspi_slave_config_t structure.
 518:../drivers/fsl_dspi.h ****  */
 519:../drivers/fsl_dspi.h **** void DSPI_SlaveGetDefaultConfig(dspi_slave_config_t *slaveConfig);
 520:../drivers/fsl_dspi.h **** 
 521:../drivers/fsl_dspi.h **** /*!
 522:../drivers/fsl_dspi.h ****  * @brief De-initializes the DSPI peripheral. Call this API to disable the DSPI clock.
 523:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 524:../drivers/fsl_dspi.h ****  */
 525:../drivers/fsl_dspi.h **** void DSPI_Deinit(SPI_Type *base);
 526:../drivers/fsl_dspi.h **** 
 527:../drivers/fsl_dspi.h **** /*!
 528:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI peripheral and sets the MCR MDIS to 0.
 529:../drivers/fsl_dspi.h ****  *
 530:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 531:../drivers/fsl_dspi.h ****  * @param enable Pass true to enable module, false to disable module.
 532:../drivers/fsl_dspi.h ****  */
 533:../drivers/fsl_dspi.h **** static inline void DSPI_Enable(SPI_Type *base, bool enable)
 534:../drivers/fsl_dspi.h **** {
 535:../drivers/fsl_dspi.h ****     if (enable)
 536:../drivers/fsl_dspi.h ****     {
 537:../drivers/fsl_dspi.h ****         base->MCR &= ~SPI_MCR_MDIS_MASK;
 538:../drivers/fsl_dspi.h ****     }
 539:../drivers/fsl_dspi.h ****     else
 540:../drivers/fsl_dspi.h ****     {
 541:../drivers/fsl_dspi.h ****         base->MCR |= SPI_MCR_MDIS_MASK;
 542:../drivers/fsl_dspi.h ****     }
 543:../drivers/fsl_dspi.h **** }
 544:../drivers/fsl_dspi.h **** 
 545:../drivers/fsl_dspi.h **** /*!
 546:../drivers/fsl_dspi.h ****  *@}
 547:../drivers/fsl_dspi.h **** */
 548:../drivers/fsl_dspi.h **** 
 549:../drivers/fsl_dspi.h **** /*!
 550:../drivers/fsl_dspi.h ****  * @name Status
 551:../drivers/fsl_dspi.h ****  * @{
 552:../drivers/fsl_dspi.h ****  */
 553:../drivers/fsl_dspi.h **** 
 554:../drivers/fsl_dspi.h **** /*!
 555:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI status flag state.
 556:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 557:../drivers/fsl_dspi.h ****  * @return DSPI status (in SR register).
 558:../drivers/fsl_dspi.h ****  */
 559:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_GetStatusFlags(SPI_Type *base)
 560:../drivers/fsl_dspi.h **** {
 561:../drivers/fsl_dspi.h ****     return (base->SR);
 562:../drivers/fsl_dspi.h **** }
 563:../drivers/fsl_dspi.h **** 
 564:../drivers/fsl_dspi.h **** /*!
 565:../drivers/fsl_dspi.h ****  * @brief Clears the DSPI status flag.
 566:../drivers/fsl_dspi.h ****  *
 567:../drivers/fsl_dspi.h ****  * This function  clears the desired status bit by using a write-1-to-clear. The user passes in the
 568:../drivers/fsl_dspi.h ****  * desired status bit to clear.  The list of status bits is defined in the dspi_status_and_interrup
 569:../drivers/fsl_dspi.h ****  * function uses these bit positions in its algorithm to clear the desired flag state.
 570:../drivers/fsl_dspi.h ****  * This is an example.
 571:../drivers/fsl_dspi.h ****  * @code
 572:../drivers/fsl_dspi.h ****  *  DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag|kDSPI_EndOfQueueFlag);
 573:../drivers/fsl_dspi.h ****  * @endcode
 574:../drivers/fsl_dspi.h ****  *
 575:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 576:../drivers/fsl_dspi.h ****  * @param statusFlags The status flag used from the type dspi_flags.
 577:../drivers/fsl_dspi.h ****  */
 578:../drivers/fsl_dspi.h **** static inline void DSPI_ClearStatusFlags(SPI_Type *base, uint32_t statusFlags)
 579:../drivers/fsl_dspi.h **** {
 580:../drivers/fsl_dspi.h ****     base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
 581:../drivers/fsl_dspi.h **** }
 582:../drivers/fsl_dspi.h **** 
 583:../drivers/fsl_dspi.h **** /*!
 584:../drivers/fsl_dspi.h ****  *@}
 585:../drivers/fsl_dspi.h **** */
 586:../drivers/fsl_dspi.h **** 
 587:../drivers/fsl_dspi.h **** /*!
 588:../drivers/fsl_dspi.h ****  * @name Interrupts
 589:../drivers/fsl_dspi.h ****  * @{
 590:../drivers/fsl_dspi.h ****  */
 591:../drivers/fsl_dspi.h **** 
 592:../drivers/fsl_dspi.h **** /*!
 593:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI interrupts.
 594:../drivers/fsl_dspi.h ****  *
 595:../drivers/fsl_dspi.h ****  * This function configures the various interrupt masks of the DSPI.  The parameters are a base and
 596:../drivers/fsl_dspi.h ****  * Note, for Tx Fill and Rx FIFO drain requests, enable the interrupt request and disable the DMA r
 597:../drivers/fsl_dspi.h ****  *       Do not use this API(write to RSER register) while DSPI is in running state.
 598:../drivers/fsl_dspi.h ****  *
 599:../drivers/fsl_dspi.h ****  * @code
 600:../drivers/fsl_dspi.h ****  *  DSPI_EnableInterrupts(base, kDSPI_TxCompleteInterruptEnable | kDSPI_EndOfQueueInterruptEnable )
 601:../drivers/fsl_dspi.h ****  * @endcode
 602:../drivers/fsl_dspi.h ****  *
 603:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 604:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum _dspi_interrupt_enable.
 605:../drivers/fsl_dspi.h ****  */
 606:../drivers/fsl_dspi.h **** void DSPI_EnableInterrupts(SPI_Type *base, uint32_t mask);
 607:../drivers/fsl_dspi.h **** 
 608:../drivers/fsl_dspi.h **** /*!
 609:../drivers/fsl_dspi.h ****  * @brief Disables the DSPI interrupts.
 610:../drivers/fsl_dspi.h ****  *
 611:../drivers/fsl_dspi.h ****  * @code
 612:../drivers/fsl_dspi.h ****  *  DSPI_DisableInterrupts(base, kDSPI_TxCompleteInterruptEnable | kDSPI_EndOfQueueInterruptEnable 
 613:../drivers/fsl_dspi.h ****  * @endcode
 614:../drivers/fsl_dspi.h ****  *
 615:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 616:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum _dspi_interrupt_enable.
 617:../drivers/fsl_dspi.h ****  */
 618:../drivers/fsl_dspi.h **** static inline void DSPI_DisableInterrupts(SPI_Type *base, uint32_t mask)
 619:../drivers/fsl_dspi.h **** {
 620:../drivers/fsl_dspi.h ****     base->RSER &= ~mask;
 621:../drivers/fsl_dspi.h **** }
 622:../drivers/fsl_dspi.h **** 
 623:../drivers/fsl_dspi.h **** /*!
 624:../drivers/fsl_dspi.h ****  *@}
 625:../drivers/fsl_dspi.h **** */
 626:../drivers/fsl_dspi.h **** 
 627:../drivers/fsl_dspi.h **** /*!
 628:../drivers/fsl_dspi.h ****  * @name DMA Control
 629:../drivers/fsl_dspi.h ****  * @{
 630:../drivers/fsl_dspi.h ****  */
 631:../drivers/fsl_dspi.h **** 
 632:../drivers/fsl_dspi.h **** /*!
 633:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI DMA request.
 634:../drivers/fsl_dspi.h ****  *
 635:../drivers/fsl_dspi.h ****  * This function configures the Rx and Tx DMA mask of the DSPI.  The parameters are a base and a DM
 636:../drivers/fsl_dspi.h ****  * @code
 637:../drivers/fsl_dspi.h ****  *  DSPI_EnableDMA(base, kDSPI_TxDmaEnable | kDSPI_RxDmaEnable);
 638:../drivers/fsl_dspi.h ****  * @endcode
 639:../drivers/fsl_dspi.h ****  *
 640:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 641:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum dspi_dma_enable.
 642:../drivers/fsl_dspi.h ****  */
 643:../drivers/fsl_dspi.h **** static inline void DSPI_EnableDMA(SPI_Type *base, uint32_t mask)
 644:../drivers/fsl_dspi.h **** {
 645:../drivers/fsl_dspi.h ****     base->RSER |= mask;
 646:../drivers/fsl_dspi.h **** }
 647:../drivers/fsl_dspi.h **** 
 648:../drivers/fsl_dspi.h **** /*!
 649:../drivers/fsl_dspi.h ****  * @brief Disables the DSPI DMA request.
 650:../drivers/fsl_dspi.h ****  *
 651:../drivers/fsl_dspi.h ****  * This function configures the Rx and Tx DMA mask of the DSPI.  The parameters are a base and a DM
 652:../drivers/fsl_dspi.h ****  * @code
 653:../drivers/fsl_dspi.h ****  *  SPI_DisableDMA(base, kDSPI_TxDmaEnable | kDSPI_RxDmaEnable);
 654:../drivers/fsl_dspi.h ****  * @endcode
 655:../drivers/fsl_dspi.h ****  *
 656:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 657:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum dspi_dma_enable.
 658:../drivers/fsl_dspi.h ****  */
 659:../drivers/fsl_dspi.h **** static inline void DSPI_DisableDMA(SPI_Type *base, uint32_t mask)
 660:../drivers/fsl_dspi.h **** {
 661:../drivers/fsl_dspi.h ****     base->RSER &= ~mask;
  90              		.loc 3 661 0
  91 0004 036B     		ldr	r3, [r0, #48]
  92              	.LVL7:
  93              	.LBE103:
  94              	.LBE102:
 984:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
  95              		.loc 2 984 0
  96 0006 10B4     		push	{r4}
  97              		.cfi_def_cfa_offset 4
  98              		.cfi_offset 4, -4
  99              	.LBB107:
 100              	.LBB104:
 101              		.loc 3 661 0
 102 0008 23F04073 		bic	r3, r3, #50331648
 103              	.LBE104:
 104              	.LBE107:
 995:../drivers/fsl_dspi_edma.c **** 
 996:../drivers/fsl_dspi_edma.c ****     if (dspiEdmaPrivateHandle->handle->callback)
 105              		.loc 2 996 0
 106 000c CC6A     		ldr	r4, [r1, #44]
 107              	.LBB108:
 108              	.LBB105:
 109              		.loc 3 661 0
 110 000e 23F44033 		bic	r3, r3, #196608
 111              	.LBE105:
 112              	.LBE108:
 994:../drivers/fsl_dspi_edma.c **** 
 113              		.loc 2 994 0
 114 0012 0022     		movs	r2, #0
 115              	.LVL8:
 116              	.LBB109:
 117              	.LBB106:
 118              		.loc 3 661 0
 119 0014 0363     		str	r3, [r0, #48]
 120              	.LVL9:
 121              	.LBE106:
 122              	.LBE109:
 994:../drivers/fsl_dspi_edma.c **** 
 123              		.loc 2 994 0
 124 0016 CA73     		strb	r2, [r1, #15]
 125              		.loc 2 996 0
 126 0018 24B1     		cbz	r4, .L4
 997:../drivers/fsl_dspi_edma.c ****     {
 998:../drivers/fsl_dspi_edma.c ****         dspiEdmaPrivateHandle->handle->callback(dspiEdmaPrivateHandle->base, dspiEdmaPrivateHandle-
 127              		.loc 2 998 0
 128 001a A446     		mov	ip, r4
 129 001c 0B6B     		ldr	r3, [r1, #48]
 999:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
1000:../drivers/fsl_dspi_edma.c ****     }
1001:../drivers/fsl_dspi_edma.c **** }
 130              		.loc 2 1001 0
 131 001e 5DF8044B 		ldr	r4, [sp], #4
 132              		.cfi_remember_state
 133              		.cfi_restore 4
 134              		.cfi_def_cfa_offset 0
 998:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
 135              		.loc 2 998 0
 136 0022 6047     		bx	ip	@ indirect register sibling call
 137              	.LVL10:
 138              	.L4:
 139              		.cfi_restore_state
 140              		.loc 2 1001 0
 141 0024 5DF8044B 		ldr	r4, [sp], #4
 142              		.cfi_restore 4
 143              		.cfi_def_cfa_offset 0
 144 0028 7047     		bx	lr
 145              		.cfi_endproc
 146              	.LFE180:
 148              		.section	.text.EDMA_DspiSlaveCallback,"ax",%progbits
 149              		.align	1
 150              		.syntax unified
 151              		.thumb
 152              		.thumb_func
 153              		.fpu fpv4-sp-d16
 155              	EDMA_DspiSlaveCallback:
 156              	.LFB185:
1002:../drivers/fsl_dspi_edma.c **** 
1003:../drivers/fsl_dspi_edma.c **** void DSPI_MasterTransferAbortEDMA(SPI_Type *base, dspi_master_edma_handle_t *handle)
1004:../drivers/fsl_dspi_edma.c **** {
1005:../drivers/fsl_dspi_edma.c ****     assert(handle);
1006:../drivers/fsl_dspi_edma.c **** 
1007:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
1008:../drivers/fsl_dspi_edma.c **** 
1009:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1010:../drivers/fsl_dspi_edma.c **** 
1011:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaRxRegToRxDataHandle);
1012:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaTxDataToIntermediaryHandle);
1013:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaIntermediaryToTxRegHandle);
1014:../drivers/fsl_dspi_edma.c **** 
1015:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Idle;
1016:../drivers/fsl_dspi_edma.c **** }
1017:../drivers/fsl_dspi_edma.c **** 
1018:../drivers/fsl_dspi_edma.c **** status_t DSPI_MasterTransferGetCountEDMA(SPI_Type *base, dspi_master_edma_handle_t *handle, size_t 
1019:../drivers/fsl_dspi_edma.c **** {
1020:../drivers/fsl_dspi_edma.c ****     assert(handle);
1021:../drivers/fsl_dspi_edma.c **** 
1022:../drivers/fsl_dspi_edma.c ****     if (!count)
1023:../drivers/fsl_dspi_edma.c ****     {
1024:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1025:../drivers/fsl_dspi_edma.c ****     }
1026:../drivers/fsl_dspi_edma.c **** 
1027:../drivers/fsl_dspi_edma.c ****     /* Catch when there is not an active transfer. */
1028:../drivers/fsl_dspi_edma.c ****     if (handle->state != kDSPI_Busy)
1029:../drivers/fsl_dspi_edma.c ****     {
1030:../drivers/fsl_dspi_edma.c ****         *count = 0;
1031:../drivers/fsl_dspi_edma.c ****         return kStatus_NoTransferInProgress;
1032:../drivers/fsl_dspi_edma.c ****     }
1033:../drivers/fsl_dspi_edma.c **** 
1034:../drivers/fsl_dspi_edma.c ****     size_t bytes;
1035:../drivers/fsl_dspi_edma.c **** 
1036:../drivers/fsl_dspi_edma.c ****     bytes = (uint32_t)handle->nbytes * EDMA_GetRemainingMajorLoopCount(handle->edmaRxRegToRxDataHan
1037:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
1038:../drivers/fsl_dspi_edma.c **** 
1039:../drivers/fsl_dspi_edma.c ****     *count = handle->totalByteCount - bytes;
1040:../drivers/fsl_dspi_edma.c **** 
1041:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
1042:../drivers/fsl_dspi_edma.c **** }
1043:../drivers/fsl_dspi_edma.c **** 
1044:../drivers/fsl_dspi_edma.c **** void DSPI_SlaveTransferCreateHandleEDMA(SPI_Type *base,
1045:../drivers/fsl_dspi_edma.c ****                                         dspi_slave_edma_handle_t *handle,
1046:../drivers/fsl_dspi_edma.c ****                                         dspi_slave_edma_transfer_callback_t callback,
1047:../drivers/fsl_dspi_edma.c ****                                         void *userData,
1048:../drivers/fsl_dspi_edma.c ****                                         edma_handle_t *edmaRxRegToRxDataHandle,
1049:../drivers/fsl_dspi_edma.c ****                                         edma_handle_t *edmaTxDataToTxRegHandle)
1050:../drivers/fsl_dspi_edma.c **** {
1051:../drivers/fsl_dspi_edma.c ****     assert(handle);
1052:../drivers/fsl_dspi_edma.c ****     assert(edmaRxRegToRxDataHandle);
1053:../drivers/fsl_dspi_edma.c ****     assert(edmaTxDataToTxRegHandle);
1054:../drivers/fsl_dspi_edma.c **** 
1055:../drivers/fsl_dspi_edma.c ****     /* Zero the handle. */
1056:../drivers/fsl_dspi_edma.c ****     memset(handle, 0, sizeof(*handle));
1057:../drivers/fsl_dspi_edma.c **** 
1058:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
1059:../drivers/fsl_dspi_edma.c **** 
1060:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].base = base;
1061:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].handle = handle;
1062:../drivers/fsl_dspi_edma.c **** 
1063:../drivers/fsl_dspi_edma.c ****     handle->callback = callback;
1064:../drivers/fsl_dspi_edma.c ****     handle->userData = userData;
1065:../drivers/fsl_dspi_edma.c **** 
1066:../drivers/fsl_dspi_edma.c ****     handle->edmaRxRegToRxDataHandle = edmaRxRegToRxDataHandle;
1067:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToTxRegHandle = edmaTxDataToTxRegHandle;
1068:../drivers/fsl_dspi_edma.c **** }
1069:../drivers/fsl_dspi_edma.c **** 
1070:../drivers/fsl_dspi_edma.c **** status_t DSPI_SlaveTransferEDMA(SPI_Type *base, dspi_slave_edma_handle_t *handle, dspi_transfer_t *
1071:../drivers/fsl_dspi_edma.c **** {
1072:../drivers/fsl_dspi_edma.c ****     assert(handle);
1073:../drivers/fsl_dspi_edma.c ****     assert(transfer);
1074:../drivers/fsl_dspi_edma.c **** 
1075:../drivers/fsl_dspi_edma.c ****     /* If send/receive length is zero */
1076:../drivers/fsl_dspi_edma.c ****     if (transfer->dataSize == 0)
1077:../drivers/fsl_dspi_edma.c ****     {
1078:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1079:../drivers/fsl_dspi_edma.c ****     }
1080:../drivers/fsl_dspi_edma.c **** 
1081:../drivers/fsl_dspi_edma.c ****     /* If both send buffer and receive buffer is null */
1082:../drivers/fsl_dspi_edma.c ****     if ((!(transfer->txData)) && (!(transfer->rxData)))
1083:../drivers/fsl_dspi_edma.c ****     {
1084:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1085:../drivers/fsl_dspi_edma.c ****     }
1086:../drivers/fsl_dspi_edma.c **** 
1087:../drivers/fsl_dspi_edma.c ****     /* Check that we're not busy.*/
1088:../drivers/fsl_dspi_edma.c ****     if (handle->state == kDSPI_Busy)
1089:../drivers/fsl_dspi_edma.c ****     {
1090:../drivers/fsl_dspi_edma.c ****         return kStatus_DSPI_Busy;
1091:../drivers/fsl_dspi_edma.c ****     }
1092:../drivers/fsl_dspi_edma.c **** 
1093:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Busy;
1094:../drivers/fsl_dspi_edma.c **** 
1095:../drivers/fsl_dspi_edma.c ****     uint32_t instance = DSPI_GetInstance(base);
1096:../drivers/fsl_dspi_edma.c ****     uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
1097:../drivers/fsl_dspi_edma.c ****     handle->bitsPerFrame =
1098:../drivers/fsl_dspi_edma.c ****         (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) +
1099:../drivers/fsl_dspi_edma.c **** 
1100:../drivers/fsl_dspi_edma.c ****     /* If using a shared RX/TX DMA request, then this limits the amount of data we can transfer
1101:../drivers/fsl_dspi_edma.c ****     * due to the linked channel. The max bytes is 511 if 8-bit/frame or 1022 if 16-bit/frame
1102:../drivers/fsl_dspi_edma.c ****     */
1103:../drivers/fsl_dspi_edma.c ****     uint32_t limited_size = 0;
1104:../drivers/fsl_dspi_edma.c ****     if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1105:../drivers/fsl_dspi_edma.c ****     {
1106:../drivers/fsl_dspi_edma.c ****         limited_size = 32767u;
1107:../drivers/fsl_dspi_edma.c ****     }
1108:../drivers/fsl_dspi_edma.c ****     else
1109:../drivers/fsl_dspi_edma.c ****     {
1110:../drivers/fsl_dspi_edma.c ****         limited_size = 511u;
1111:../drivers/fsl_dspi_edma.c ****     }
1112:../drivers/fsl_dspi_edma.c **** 
1113:../drivers/fsl_dspi_edma.c ****     if (handle->bitsPerFrame > 8)
1114:../drivers/fsl_dspi_edma.c ****     {
1115:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > (limited_size << 1u))
1116:../drivers/fsl_dspi_edma.c ****         {
1117:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
1118:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
1119:../drivers/fsl_dspi_edma.c ****         }
1120:../drivers/fsl_dspi_edma.c ****     }
1121:../drivers/fsl_dspi_edma.c ****     else
1122:../drivers/fsl_dspi_edma.c ****     {
1123:../drivers/fsl_dspi_edma.c ****         if (transfer->dataSize > limited_size)
1124:../drivers/fsl_dspi_edma.c ****         {
1125:../drivers/fsl_dspi_edma.c ****             handle->state = kDSPI_Idle;
1126:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
1127:../drivers/fsl_dspi_edma.c ****         }
1128:../drivers/fsl_dspi_edma.c ****     }
1129:../drivers/fsl_dspi_edma.c **** 
1130:../drivers/fsl_dspi_edma.c ****     /*The data size should be even if the bitsPerFrame is greater than 8 (that is 2 bytes per frame
1131:../drivers/fsl_dspi_edma.c ****     if ((handle->bitsPerFrame > 8) && (transfer->dataSize & 0x1))
1132:../drivers/fsl_dspi_edma.c ****     {
1133:../drivers/fsl_dspi_edma.c ****         handle->state = kDSPI_Idle;
1134:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1135:../drivers/fsl_dspi_edma.c ****     }
1136:../drivers/fsl_dspi_edma.c **** 
1137:../drivers/fsl_dspi_edma.c ****     EDMA_SetCallback(handle->edmaRxRegToRxDataHandle, EDMA_DspiSlaveCallback, &s_dspiSlaveEdmaPriva
1138:../drivers/fsl_dspi_edma.c **** 
1139:../drivers/fsl_dspi_edma.c ****     /* Store transfer information */
1140:../drivers/fsl_dspi_edma.c ****     handle->txData = transfer->txData;
1141:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
1142:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
1143:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
1144:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
1145:../drivers/fsl_dspi_edma.c **** 
1146:../drivers/fsl_dspi_edma.c ****     uint16_t wordToSend = 0;
1147:../drivers/fsl_dspi_edma.c ****     uint8_t dummyData = s_dummyData[DSPI_GetInstance(base)];
1148:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
1149:../drivers/fsl_dspi_edma.c ****     uint8_t dataFedMax = 2;
1150:../drivers/fsl_dspi_edma.c **** 
1151:../drivers/fsl_dspi_edma.c ****     uint32_t rxAddr = DSPI_GetRxRegisterAddress(base);
1152:../drivers/fsl_dspi_edma.c ****     uint32_t txAddr = DSPI_SlaveGetTxRegisterAddress(base);
1153:../drivers/fsl_dspi_edma.c **** 
1154:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigA;
1155:../drivers/fsl_dspi_edma.c ****     edma_transfer_config_t transferConfigC;
1156:../drivers/fsl_dspi_edma.c **** 
1157:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
1158:../drivers/fsl_dspi_edma.c **** 
1159:../drivers/fsl_dspi_edma.c ****     DSPI_FlushFifo(base, true, true);
1160:../drivers/fsl_dspi_edma.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
1161:../drivers/fsl_dspi_edma.c **** 
1162:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1163:../drivers/fsl_dspi_edma.c **** 
1164:../drivers/fsl_dspi_edma.c ****     DSPI_StartTransfer(base);
1165:../drivers/fsl_dspi_edma.c **** 
1166:../drivers/fsl_dspi_edma.c ****     /*if dspi has separate dma request , need not prepare data first .
1167:../drivers/fsl_dspi_edma.c ****     else (dspi has shared dma request) , send first 2 data into fifo if there is fifo or send first
1168:../drivers/fsl_dspi_edma.c ****     slaveGetTxRegister if there is no fifo*/
1169:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1170:../drivers/fsl_dspi_edma.c ****     {
1171:../drivers/fsl_dspi_edma.c ****         /* For DSPI instances with shared RX/TX DMA requests, we'll use the RX DMA request to
1172:../drivers/fsl_dspi_edma.c ****         * trigger ongoing transfers and will link to the TX DMA channel from the RX DMA channel.
1173:../drivers/fsl_dspi_edma.c ****         */
1174:../drivers/fsl_dspi_edma.c ****         /* If bits/frame is greater than one byte */
1175:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame > 8)
1176:../drivers/fsl_dspi_edma.c ****         {
1177:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
1178:../drivers/fsl_dspi_edma.c ****             {
1179:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
1180:../drivers/fsl_dspi_edma.c ****                 {
1181:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
1182:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
1183:../drivers/fsl_dspi_edma.c **** 
1184:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
1185:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
1186:../drivers/fsl_dspi_edma.c ****                 }
1187:../drivers/fsl_dspi_edma.c ****                 else
1188:../drivers/fsl_dspi_edma.c ****                 {
1189:../drivers/fsl_dspi_edma.c ****                     wordToSend = ((uint32_t)dummyData << 8) | dummyData;
1190:../drivers/fsl_dspi_edma.c ****                 }
1191:../drivers/fsl_dspi_edma.c ****                 handle->remainingSendByteCount -= 2; /* decrement remainingSendByteCount by 2 */
1192:../drivers/fsl_dspi_edma.c ****                 base->PUSHR_SLAVE = wordToSend;
1193:../drivers/fsl_dspi_edma.c **** 
1194:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
1195:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1196:../drivers/fsl_dspi_edma.c **** 
1197:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed += 2;
1198:../drivers/fsl_dspi_edma.c **** 
1199:../drivers/fsl_dspi_edma.c ****                 /* Exit loop if send count is zero, else update local variables for next loop */
1200:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == (dataFedMax * 2)))
1201:../drivers/fsl_dspi_edma.c ****                 {
1202:../drivers/fsl_dspi_edma.c ****                     break;
1203:../drivers/fsl_dspi_edma.c ****                 }
1204:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
1205:../drivers/fsl_dspi_edma.c ****         }
1206:../drivers/fsl_dspi_edma.c ****         else /* Optimized for bits/frame less than or equal to one byte. */
1207:../drivers/fsl_dspi_edma.c ****         {
1208:../drivers/fsl_dspi_edma.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
1209:../drivers/fsl_dspi_edma.c ****             {
1210:../drivers/fsl_dspi_edma.c ****                 if (handle->txData)
1211:../drivers/fsl_dspi_edma.c ****                 {
1212:../drivers/fsl_dspi_edma.c ****                     wordToSend = *(handle->txData);
1213:../drivers/fsl_dspi_edma.c ****                     /* Increment to next data word*/
1214:../drivers/fsl_dspi_edma.c ****                     ++handle->txData;
1215:../drivers/fsl_dspi_edma.c ****                 }
1216:../drivers/fsl_dspi_edma.c ****                 else
1217:../drivers/fsl_dspi_edma.c ****                 {
1218:../drivers/fsl_dspi_edma.c ****                     wordToSend = dummyData;
1219:../drivers/fsl_dspi_edma.c ****                 }
1220:../drivers/fsl_dspi_edma.c **** 
1221:../drivers/fsl_dspi_edma.c ****                 base->PUSHR_SLAVE = wordToSend;
1222:../drivers/fsl_dspi_edma.c **** 
1223:../drivers/fsl_dspi_edma.c ****                 /* Try to clear the TFFF; if the TX FIFO is full this will clear */
1224:../drivers/fsl_dspi_edma.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1225:../drivers/fsl_dspi_edma.c ****                 /* Decrement remainingSendByteCount*/
1226:../drivers/fsl_dspi_edma.c ****                 --handle->remainingSendByteCount;
1227:../drivers/fsl_dspi_edma.c **** 
1228:../drivers/fsl_dspi_edma.c ****                 dataAlreadyFed++;
1229:../drivers/fsl_dspi_edma.c **** 
1230:../drivers/fsl_dspi_edma.c ****                 /* Exit loop if send count is zero, else update local variables for next loop */
1231:../drivers/fsl_dspi_edma.c ****                 if ((handle->remainingSendByteCount == 0) || (dataAlreadyFed == dataFedMax))
1232:../drivers/fsl_dspi_edma.c ****                 {
1233:../drivers/fsl_dspi_edma.c ****                     break;
1234:../drivers/fsl_dspi_edma.c ****                 }
1235:../drivers/fsl_dspi_edma.c ****             } /* End of TX FIFO fill while loop */
1236:../drivers/fsl_dspi_edma.c ****         }
1237:../drivers/fsl_dspi_edma.c ****     }
1238:../drivers/fsl_dspi_edma.c **** 
1239:../drivers/fsl_dspi_edma.c ****     /***channel_A *** used for carry the data from Rx_Data_Register(POPR) to User_Receive_Buffer*/
1240:../drivers/fsl_dspi_edma.c ****     if (handle->remainingReceiveByteCount > 0)
1241:../drivers/fsl_dspi_edma.c ****     {
1242:../drivers/fsl_dspi_edma.c ****         EDMA_ResetChannel(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHandle->c
1243:../drivers/fsl_dspi_edma.c **** 
1244:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcAddr = (uint32_t)rxAddr;
1245:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcOffset = 0;
1246:../drivers/fsl_dspi_edma.c **** 
1247:../drivers/fsl_dspi_edma.c ****         if (handle->rxData)
1248:../drivers/fsl_dspi_edma.c ****         {
1249:../drivers/fsl_dspi_edma.c ****             transferConfigA.destAddr = (uint32_t) & (handle->rxData[0]);
1250:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 1;
1251:../drivers/fsl_dspi_edma.c ****         }
1252:../drivers/fsl_dspi_edma.c ****         else
1253:../drivers/fsl_dspi_edma.c ****         {
1254:../drivers/fsl_dspi_edma.c ****             transferConfigA.destAddr = (uint32_t) & (handle->rxBuffIfNull);
1255:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 0;
1256:../drivers/fsl_dspi_edma.c ****         }
1257:../drivers/fsl_dspi_edma.c **** 
1258:../drivers/fsl_dspi_edma.c ****         transferConfigA.destTransferSize = kEDMA_TransferSize1Bytes;
1259:../drivers/fsl_dspi_edma.c **** 
1260:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
1261:../drivers/fsl_dspi_edma.c ****         {
1262:../drivers/fsl_dspi_edma.c ****             transferConfigA.srcTransferSize = kEDMA_TransferSize1Bytes;
1263:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 1;
1264:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
1265:../drivers/fsl_dspi_edma.c ****         }
1266:../drivers/fsl_dspi_edma.c ****         else
1267:../drivers/fsl_dspi_edma.c ****         {
1268:../drivers/fsl_dspi_edma.c ****             transferConfigA.srcTransferSize = kEDMA_TransferSize2Bytes;
1269:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 2;
1270:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
1271:../drivers/fsl_dspi_edma.c ****         }
1272:../drivers/fsl_dspi_edma.c **** 
1273:../drivers/fsl_dspi_edma.c ****         /* Store the initially configured eDMA minor byte transfer count into the DSPI handle */
1274:../drivers/fsl_dspi_edma.c ****         handle->nbytes = transferConfigA.minorLoopBytes;
1275:../drivers/fsl_dspi_edma.c **** 
1276:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHand
1277:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
1278:../drivers/fsl_dspi_edma.c ****         EDMA_EnableChannelInterrupts(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDa
1279:../drivers/fsl_dspi_edma.c ****                                      kEDMA_MajorInterruptEnable);
1280:../drivers/fsl_dspi_edma.c ****     }
1281:../drivers/fsl_dspi_edma.c **** 
1282:../drivers/fsl_dspi_edma.c ****     if (handle->remainingSendByteCount > 0)
1283:../drivers/fsl_dspi_edma.c ****     {
1284:../drivers/fsl_dspi_edma.c ****         /***channel_C *** used for carry the data from User_Send_Buffer to Tx_Data_Register(PUSHR_S
1285:../drivers/fsl_dspi_edma.c ****         EDMA_ResetChannel(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataToTxRegHandle->c
1286:../drivers/fsl_dspi_edma.c **** 
1287:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
1288:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
1289:../drivers/fsl_dspi_edma.c **** 
1290:../drivers/fsl_dspi_edma.c ****         if (handle->txData)
1291:../drivers/fsl_dspi_edma.c ****         {
1292:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcAddr = (uint32_t)(&(handle->txData[0]));
1293:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 1;
1294:../drivers/fsl_dspi_edma.c ****         }
1295:../drivers/fsl_dspi_edma.c ****         else
1296:../drivers/fsl_dspi_edma.c ****         {
1297:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcAddr = (uint32_t)(&handle->txBuffIfNull);
1298:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 0;
1299:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
1300:../drivers/fsl_dspi_edma.c ****             {
1301:../drivers/fsl_dspi_edma.c ****                 handle->txBuffIfNull = dummyData;
1302:../drivers/fsl_dspi_edma.c ****             }
1303:../drivers/fsl_dspi_edma.c ****             else
1304:../drivers/fsl_dspi_edma.c ****             {
1305:../drivers/fsl_dspi_edma.c ****                 handle->txBuffIfNull = ((uint32_t)dummyData << 8) | dummyData;
1306:../drivers/fsl_dspi_edma.c ****             }
1307:../drivers/fsl_dspi_edma.c ****         }
1308:../drivers/fsl_dspi_edma.c **** 
1309:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize1Bytes;
1310:../drivers/fsl_dspi_edma.c **** 
1311:../drivers/fsl_dspi_edma.c ****         if (handle->bitsPerFrame <= 8)
1312:../drivers/fsl_dspi_edma.c ****         {
1313:../drivers/fsl_dspi_edma.c ****             transferConfigC.destTransferSize = kEDMA_TransferSize1Bytes;
1314:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 1;
1315:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount;
1316:../drivers/fsl_dspi_edma.c ****         }
1317:../drivers/fsl_dspi_edma.c ****         else
1318:../drivers/fsl_dspi_edma.c ****         {
1319:../drivers/fsl_dspi_edma.c ****             transferConfigC.destTransferSize = kEDMA_TransferSize2Bytes;
1320:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 2;
1321:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount / 2;
1322:../drivers/fsl_dspi_edma.c ****         }
1323:../drivers/fsl_dspi_edma.c **** 
1324:../drivers/fsl_dspi_edma.c ****         EDMA_SetTransferConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataToTxRegHand
1325:../drivers/fsl_dspi_edma.c ****                                &transferConfigC, NULL);
1326:../drivers/fsl_dspi_edma.c **** 
1327:../drivers/fsl_dspi_edma.c ****         EDMA_StartTransfer(handle->edmaTxDataToTxRegHandle);
1328:../drivers/fsl_dspi_edma.c ****     }
1329:../drivers/fsl_dspi_edma.c **** 
1330:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaRxRegToRxDataHandle);
1331:../drivers/fsl_dspi_edma.c **** 
1332:../drivers/fsl_dspi_edma.c ****     /*Set channel priority*/
1333:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityLow = handle->edmaRxRegToRxDataHandle->channel;
1334:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaTxDataToTxRegHandle->channel;
1335:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
1336:../drivers/fsl_dspi_edma.c **** 
1337:../drivers/fsl_dspi_edma.c ****     if (channelPriorityLow > channelPriorityHigh)
1338:../drivers/fsl_dspi_edma.c ****     {
1339:../drivers/fsl_dspi_edma.c ****         t = channelPriorityLow;
1340:../drivers/fsl_dspi_edma.c ****         channelPriorityLow = channelPriorityHigh;
1341:../drivers/fsl_dspi_edma.c ****         channelPriorityHigh = t;
1342:../drivers/fsl_dspi_edma.c ****     }
1343:../drivers/fsl_dspi_edma.c **** 
1344:../drivers/fsl_dspi_edma.c ****     edma_channel_Preemption_config_t preemption_config_t;
1345:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enableChannelPreemption = true;
1346:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
1347:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
1348:../drivers/fsl_dspi_edma.c **** 
1349:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1350:../drivers/fsl_dspi_edma.c ****     {
1351:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
1352:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1353:../drivers/fsl_dspi_edma.c **** 
1354:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
1355:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataTo
1356:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1357:../drivers/fsl_dspi_edma.c ****     }
1358:../drivers/fsl_dspi_edma.c ****     else
1359:../drivers/fsl_dspi_edma.c ****     {
1360:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataTo
1361:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1362:../drivers/fsl_dspi_edma.c **** 
1363:../drivers/fsl_dspi_edma.c ****         preemption_config_t.channelPriority = channelPriorityHigh;
1364:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
1365:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
1366:../drivers/fsl_dspi_edma.c ****     }
1367:../drivers/fsl_dspi_edma.c **** 
1368:../drivers/fsl_dspi_edma.c ****     /*Set the channel link.
1369:../drivers/fsl_dspi_edma.c ****     For DSPI instances with shared RX/TX DMA requests: Rx DMA request -> channel_A -> channel_C.
1370:../drivers/fsl_dspi_edma.c ****     For DSPI instances with separate RX and TX DMA requests:
1371:../drivers/fsl_dspi_edma.c ****     Rx DMA request -> channel_A
1372:../drivers/fsl_dspi_edma.c ****     Tx DMA request -> channel_C */
1373:../drivers/fsl_dspi_edma.c ****     if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
1374:../drivers/fsl_dspi_edma.c ****     {
1375:../drivers/fsl_dspi_edma.c ****         if (handle->remainingSendByteCount > 0)
1376:../drivers/fsl_dspi_edma.c ****         {
1377:../drivers/fsl_dspi_edma.c ****             EDMA_SetChannelLink(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToRxDataHan
1378:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToTxRegHandle->channel);
1379:../drivers/fsl_dspi_edma.c ****         }
1380:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable);
1381:../drivers/fsl_dspi_edma.c ****     }
1382:../drivers/fsl_dspi_edma.c ****     else
1383:../drivers/fsl_dspi_edma.c ****     {
1384:../drivers/fsl_dspi_edma.c ****         DSPI_EnableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1385:../drivers/fsl_dspi_edma.c ****     }
1386:../drivers/fsl_dspi_edma.c **** 
1387:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
1388:../drivers/fsl_dspi_edma.c **** }
1389:../drivers/fsl_dspi_edma.c **** 
1390:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiSlaveCallback(edma_handle_t *edmaHandle,
1391:../drivers/fsl_dspi_edma.c ****                                    void *g_dspiEdmaPrivateHandle,
1392:../drivers/fsl_dspi_edma.c ****                                    bool transferDone,
1393:../drivers/fsl_dspi_edma.c ****                                    uint32_t tcds)
1394:../drivers/fsl_dspi_edma.c **** {
 157              		.loc 2 1394 0
 158              		.cfi_startproc
 159              		@ args = 0, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              		@ link register save eliminated.
 162              	.LVL11:
1395:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
1396:../drivers/fsl_dspi_edma.c ****     assert(g_dspiEdmaPrivateHandle);
1397:../drivers/fsl_dspi_edma.c **** 
1398:../drivers/fsl_dspi_edma.c ****     dspi_slave_edma_private_handle_t *dspiEdmaPrivateHandle;
1399:../drivers/fsl_dspi_edma.c **** 
1400:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle = (dspi_slave_edma_private_handle_t *)g_dspiEdmaPrivateHandle;
1401:../drivers/fsl_dspi_edma.c **** 
1402:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA((dspiEdmaPrivateHandle->base), kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
 163              		.loc 2 1402 0
 164 0000 0868     		ldr	r0, [r1]
 165              	.LVL12:
1403:../drivers/fsl_dspi_edma.c **** 
1404:../drivers/fsl_dspi_edma.c ****     dspiEdmaPrivateHandle->handle->state = kDSPI_Idle;
 166              		.loc 2 1404 0
 167 0002 4968     		ldr	r1, [r1, #4]
 168              	.LVL13:
 169              	.LBB110:
 170              	.LBB111:
 171              		.loc 3 661 0
 172 0004 036B     		ldr	r3, [r0, #48]
 173              	.LVL14:
 174              	.LBE111:
 175              	.LBE110:
1394:../drivers/fsl_dspi_edma.c ****     assert(edmaHandle);
 176              		.loc 2 1394 0
 177 0006 10B4     		push	{r4}
 178              		.cfi_def_cfa_offset 4
 179              		.cfi_offset 4, -4
 180              	.LBB115:
 181              	.LBB112:
 182              		.loc 3 661 0
 183 0008 23F04073 		bic	r3, r3, #50331648
 184              	.LBE112:
 185              	.LBE115:
1405:../drivers/fsl_dspi_edma.c **** 
1406:../drivers/fsl_dspi_edma.c ****     if (dspiEdmaPrivateHandle->handle->callback)
 186              		.loc 2 1406 0
 187 000c 8C6A     		ldr	r4, [r1, #40]
 188              	.LBB116:
 189              	.LBB113:
 190              		.loc 3 661 0
 191 000e 23F44033 		bic	r3, r3, #196608
 192              	.LBE113:
 193              	.LBE116:
1404:../drivers/fsl_dspi_edma.c **** 
 194              		.loc 2 1404 0
 195 0012 0022     		movs	r2, #0
 196              	.LVL15:
 197              	.LBB117:
 198              	.LBB114:
 199              		.loc 3 661 0
 200 0014 0363     		str	r3, [r0, #48]
 201              	.LVL16:
 202              	.LBE114:
 203              	.LBE117:
1404:../drivers/fsl_dspi_edma.c **** 
 204              		.loc 2 1404 0
 205 0016 81F82520 		strb	r2, [r1, #37]
 206              		.loc 2 1406 0
 207 001a 24B1     		cbz	r4, .L6
1407:../drivers/fsl_dspi_edma.c ****     {
1408:../drivers/fsl_dspi_edma.c ****         dspiEdmaPrivateHandle->handle->callback(dspiEdmaPrivateHandle->base, dspiEdmaPrivateHandle-
 208              		.loc 2 1408 0
 209 001c A446     		mov	ip, r4
 210 001e CB6A     		ldr	r3, [r1, #44]
1409:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
1410:../drivers/fsl_dspi_edma.c ****     }
1411:../drivers/fsl_dspi_edma.c **** }
 211              		.loc 2 1411 0
 212 0020 5DF8044B 		ldr	r4, [sp], #4
 213              		.cfi_remember_state
 214              		.cfi_restore 4
 215              		.cfi_def_cfa_offset 0
1408:../drivers/fsl_dspi_edma.c ****                                                 kStatus_Success, dspiEdmaPrivateHandle->handle->use
 216              		.loc 2 1408 0
 217 0024 6047     		bx	ip	@ indirect register sibling call
 218              	.LVL17:
 219              	.L6:
 220              		.cfi_restore_state
 221              		.loc 2 1411 0
 222 0026 5DF8044B 		ldr	r4, [sp], #4
 223              		.cfi_restore 4
 224              		.cfi_def_cfa_offset 0
 225 002a 7047     		bx	lr
 226              		.cfi_endproc
 227              	.LFE185:
 229              		.section	.text.DSPI_MasterTransferCreateHandleEDMA,"ax",%progbits
 230              		.align	1
 231              		.global	DSPI_MasterTransferCreateHandleEDMA
 232              		.syntax unified
 233              		.thumb
 234              		.thumb_func
 235              		.fpu fpv4-sp-d16
 237              	DSPI_MasterTransferCreateHandleEDMA:
 238              	.LFB177:
 109:../drivers/fsl_dspi_edma.c ****     assert(handle);
 239              		.loc 2 109 0
 240              		.cfi_startproc
 241              		@ args = 12, pretend = 0, frame = 0
 242              		@ frame_needed = 0, uses_anonymous_args = 0
 243              	.LVL18:
 244 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 245              		.cfi_def_cfa_offset 24
 246              		.cfi_offset 3, -24
 247              		.cfi_offset 4, -20
 248              		.cfi_offset 5, -16
 249              		.cfi_offset 6, -12
 250              		.cfi_offset 7, -8
 251              		.cfi_offset 14, -4
 109:../drivers/fsl_dspi_edma.c ****     assert(handle);
 252              		.loc 2 109 0
 253 0002 0C46     		mov	r4, r1
 254 0004 0546     		mov	r5, r0
 255 0006 1746     		mov	r7, r2
 118:../drivers/fsl_dspi_edma.c **** 
 256              		.loc 2 118 0
 257 0008 0021     		movs	r1, #0
 258              	.LVL19:
 259 000a 8022     		movs	r2, #128
 260              	.LVL20:
 261 000c 2046     		mov	r0, r4
 262              	.LVL21:
 109:../drivers/fsl_dspi_edma.c ****     assert(handle);
 263              		.loc 2 109 0
 264 000e 1E46     		mov	r6, r3
 118:../drivers/fsl_dspi_edma.c **** 
 265              		.loc 2 118 0
 266 0010 FFF7FEFF 		bl	memset
 267              	.LVL22:
 120:../drivers/fsl_dspi_edma.c **** 
 268              		.loc 2 120 0
 269 0014 2846     		mov	r0, r5
 270 0016 FFF7FEFF 		bl	DSPI_GetInstance
 271              	.LVL23:
 122:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].handle = handle;
 272              		.loc 2 122 0
 273 001a 074A     		ldr	r2, .L9
 128:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToIntermediaryHandle = edmaTxDataToIntermediaryHandle;
 274              		.loc 2 128 0
 275 001c 069B     		ldr	r3, [sp, #24]
 122:../drivers/fsl_dspi_edma.c ****     s_dspiMasterEdmaPrivateHandle[instance].handle = handle;
 276              		.loc 2 122 0
 277 001e 42F83050 		str	r5, [r2, r0, lsl #3]
 128:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToIntermediaryHandle = edmaTxDataToIntermediaryHandle;
 278              		.loc 2 128 0
 279 0022 6363     		str	r3, [r4, #52]
 123:../drivers/fsl_dspi_edma.c **** 
 280              		.loc 2 123 0
 281 0024 02EBC002 		add	r2, r2, r0, lsl #3
 129:../drivers/fsl_dspi_edma.c ****     handle->edmaIntermediaryToTxRegHandle = edmaIntermediaryToTxRegHandle;
 282              		.loc 2 129 0
 283 0028 079B     		ldr	r3, [sp, #28]
 284 002a A363     		str	r3, [r4, #56]
 130:../drivers/fsl_dspi_edma.c **** }
 285              		.loc 2 130 0
 286 002c 089B     		ldr	r3, [sp, #32]
 123:../drivers/fsl_dspi_edma.c **** 
 287              		.loc 2 123 0
 288 002e 5460     		str	r4, [r2, #4]
 125:../drivers/fsl_dspi_edma.c ****     handle->userData = userData;
 289              		.loc 2 125 0
 290 0030 E762     		str	r7, [r4, #44]
 126:../drivers/fsl_dspi_edma.c **** 
 291              		.loc 2 126 0
 292 0032 2663     		str	r6, [r4, #48]
 130:../drivers/fsl_dspi_edma.c **** }
 293              		.loc 2 130 0
 294 0034 E363     		str	r3, [r4, #60]
 295 0036 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 296              	.LVL24:
 297              	.L10:
 298              		.align	2
 299              	.L9:
 300 0038 00000000 		.word	.LANCHOR0
 301              		.cfi_endproc
 302              	.LFE177:
 304              		.section	.text.DSPI_MasterTransferEDMA,"ax",%progbits
 305              		.align	1
 306              		.global	DSPI_MasterTransferEDMA
 307              		.syntax unified
 308              		.thumb
 309              		.thumb_func
 310              		.fpu fpv4-sp-d16
 312              	DSPI_MasterTransferEDMA:
 313              	.LFB178:
 134:../drivers/fsl_dspi_edma.c ****     assert(handle);
 314              		.loc 2 134 0
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 80
 317              		@ frame_needed = 0, uses_anonymous_args = 0
 318              	.LVL25:
 319 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 320              		.cfi_def_cfa_offset 28
 321              		.cfi_offset 4, -28
 322              		.cfi_offset 5, -24
 323              		.cfi_offset 6, -20
 324              		.cfi_offset 7, -16
 325              		.cfi_offset 8, -12
 326              		.cfi_offset 9, -8
 327              		.cfi_offset 14, -4
 139:../drivers/fsl_dspi_edma.c ****     {
 328              		.loc 2 139 0
 329 0004 9368     		ldr	r3, [r2, #8]
 134:../drivers/fsl_dspi_edma.c ****     assert(handle);
 330              		.loc 2 134 0
 331 0006 95B0     		sub	sp, sp, #84
 332              		.cfi_def_cfa_offset 112
 134:../drivers/fsl_dspi_edma.c ****     assert(handle);
 333              		.loc 2 134 0
 334 0008 0546     		mov	r5, r0
 335 000a 0C46     		mov	r4, r1
 336 000c 1746     		mov	r7, r2
 139:../drivers/fsl_dspi_edma.c ****     {
 337              		.loc 2 139 0
 338 000e 002B     		cmp	r3, #0
 339 0010 00F0B480 		beq	.L99
 145:../drivers/fsl_dspi_edma.c ****     {
 340              		.loc 2 145 0
 341 0014 1368     		ldr	r3, [r2]
 342 0016 1BB9     		cbnz	r3, .L13
 145:../drivers/fsl_dspi_edma.c ****     {
 343              		.loc 2 145 0 is_stmt 0 discriminator 1
 344 0018 5368     		ldr	r3, [r2, #4]
 345 001a 002B     		cmp	r3, #0
 346 001c 00F0AE80 		beq	.L99
 347              	.L13:
 151:../drivers/fsl_dspi_edma.c ****     {
 348              		.loc 2 151 0 is_stmt 1
 349 0020 E37B     		ldrb	r3, [r4, #15]	@ zero_extendqisi2
 350 0022 012B     		cmp	r3, #1
 351 0024 00F05F83 		beq	.L100
 352              	.LVL26:
 353              	.LBB155:
 354              	.LBB156:
 156:../drivers/fsl_dspi_edma.c **** 
 355              		.loc 2 156 0
 356 0028 4FF00109 		mov	r9, #1
 357 002c 84F80F90 		strb	r9, [r4, #15]
 158:../drivers/fsl_dspi_edma.c ****     uint16_t wordToSend = 0;
 358              		.loc 2 158 0
 359 0030 2846     		mov	r0, r5
 360              	.LVL27:
 361 0032 FFF7FEFF 		bl	DSPI_GetInstance
 362              	.LVL28:
 363 0036 8046     		mov	r8, r0
 364              	.LVL29:
 160:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 365              		.loc 2 160 0
 366 0038 2846     		mov	r0, r5
 367              	.LVL30:
 368 003a FFF7FEFF 		bl	DSPI_GetInstance
 369              	.LVL31:
 370 003e 524B     		ldr	r3, .L142
 180:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 371              		.loc 2 180 0
 372 0040 F968     		ldr	r1, [r7, #12]
 160:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 373              		.loc 2 160 0
 374 0042 1E5C     		ldrb	r6, [r3, r0]	@ zero_extendqisi2
 375 0044 F6B2     		uxtb	r6, r6
 376              	.LVL32:
 172:../drivers/fsl_dspi_edma.c **** 
 377              		.loc 2 172 0
 378 0046 46EA0623 		orr	r3, r6, r6, lsl #8
 379 004a A362     		str	r3, [r4, #40]
 380              	.LVL33:
 381              	.LBB157:
 382              	.LBB158:
 662:../drivers/fsl_dspi.h **** }
 663:../drivers/fsl_dspi.h **** 
 664:../drivers/fsl_dspi.h **** /*!
 665:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI master PUSHR data register address for the DMA operation.
 666:../drivers/fsl_dspi.h ****  *
 667:../drivers/fsl_dspi.h ****  * This function gets the DSPI master PUSHR data register address because this value is needed for 
 668:../drivers/fsl_dspi.h ****  *
 669:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 670:../drivers/fsl_dspi.h ****  * @return The DSPI master PUSHR data register address.
 671:../drivers/fsl_dspi.h ****  */
 672:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_MasterGetTxRegisterAddress(SPI_Type *base)
 673:../drivers/fsl_dspi.h **** {
 674:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->PUSHR);
 675:../drivers/fsl_dspi.h **** }
 676:../drivers/fsl_dspi.h **** 
 677:../drivers/fsl_dspi.h **** /*!
 678:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI slave PUSHR data register address for the DMA operation.
 679:../drivers/fsl_dspi.h ****  *
 680:../drivers/fsl_dspi.h ****  * This function gets the DSPI slave PUSHR data register address as this value is needed for the DM
 681:../drivers/fsl_dspi.h ****  *
 682:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 683:../drivers/fsl_dspi.h ****  * @return The DSPI slave PUSHR data register address.
 684:../drivers/fsl_dspi.h ****  */
 685:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_SlaveGetTxRegisterAddress(SPI_Type *base)
 686:../drivers/fsl_dspi.h **** {
 687:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->PUSHR_SLAVE);
 688:../drivers/fsl_dspi.h **** }
 689:../drivers/fsl_dspi.h **** 
 690:../drivers/fsl_dspi.h **** /*!
 691:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI POPR data register address for the DMA operation.
 692:../drivers/fsl_dspi.h ****  *
 693:../drivers/fsl_dspi.h ****  * This function gets the DSPI POPR data register address as this value is needed for the DMA opera
 694:../drivers/fsl_dspi.h ****  *
 695:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 696:../drivers/fsl_dspi.h ****  * @return The DSPI POPR data register address.
 697:../drivers/fsl_dspi.h ****  */
 698:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_GetRxRegisterAddress(SPI_Type *base)
 699:../drivers/fsl_dspi.h **** {
 700:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->POPR);
 701:../drivers/fsl_dspi.h **** }
 702:../drivers/fsl_dspi.h **** 
 703:../drivers/fsl_dspi.h **** /*!
 704:../drivers/fsl_dspi.h ****  *@}
 705:../drivers/fsl_dspi.h **** */
 706:../drivers/fsl_dspi.h **** 
 707:../drivers/fsl_dspi.h **** /*!
 708:../drivers/fsl_dspi.h ****  * @name Bus Operations
 709:../drivers/fsl_dspi.h ****  * @{
 710:../drivers/fsl_dspi.h ****  */
 711:../drivers/fsl_dspi.h **** 
 712:../drivers/fsl_dspi.h **** /*!
 713:../drivers/fsl_dspi.h ****  * @brief Configures the DSPI for master or slave.
 714:../drivers/fsl_dspi.h ****  *
 715:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 716:../drivers/fsl_dspi.h ****  * @param mode Mode setting (master or slave) of type dspi_master_slave_mode_t.
 717:../drivers/fsl_dspi.h ****  */
 718:../drivers/fsl_dspi.h **** static inline void DSPI_SetMasterSlaveMode(SPI_Type *base, dspi_master_slave_mode_t mode)
 719:../drivers/fsl_dspi.h **** {
 720:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~SPI_MCR_MSTR_MASK)) | SPI_MCR_MSTR(mode);
 721:../drivers/fsl_dspi.h **** }
 722:../drivers/fsl_dspi.h **** 
 723:../drivers/fsl_dspi.h **** /*!
 724:../drivers/fsl_dspi.h ****  * @brief Returns whether the DSPI module is in master mode.
 725:../drivers/fsl_dspi.h ****  *
 726:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 727:../drivers/fsl_dspi.h ****  * @return Returns true if the module is in master mode or false if the module is in slave mode.
 728:../drivers/fsl_dspi.h ****  */
 729:../drivers/fsl_dspi.h **** static inline bool DSPI_IsMaster(SPI_Type *base)
 730:../drivers/fsl_dspi.h **** {
 731:../drivers/fsl_dspi.h ****     return (bool)((base->MCR) & SPI_MCR_MSTR_MASK);
 732:../drivers/fsl_dspi.h **** }
 733:../drivers/fsl_dspi.h **** /*!
 734:../drivers/fsl_dspi.h ****  * @brief Starts the DSPI transfers and clears HALT bit in MCR.
 735:../drivers/fsl_dspi.h ****  *
 736:../drivers/fsl_dspi.h ****  * This function sets the module to start data transfer in either master or slave mode.
 737:../drivers/fsl_dspi.h ****  *
 738:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 739:../drivers/fsl_dspi.h ****  */
 740:../drivers/fsl_dspi.h **** static inline void DSPI_StartTransfer(SPI_Type *base)
 741:../drivers/fsl_dspi.h **** {
 742:../drivers/fsl_dspi.h ****     base->MCR &= ~SPI_MCR_HALT_MASK;
 743:../drivers/fsl_dspi.h **** }
 744:../drivers/fsl_dspi.h **** /*!
 745:../drivers/fsl_dspi.h ****  * @brief Stops DSPI transfers and sets the HALT bit in MCR.
 746:../drivers/fsl_dspi.h ****  *
 747:../drivers/fsl_dspi.h ****  * This function stops data transfers in either master or slave modes.
 748:../drivers/fsl_dspi.h ****  *
 749:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 750:../drivers/fsl_dspi.h ****  */
 751:../drivers/fsl_dspi.h **** static inline void DSPI_StopTransfer(SPI_Type *base)
 752:../drivers/fsl_dspi.h **** {
 753:../drivers/fsl_dspi.h ****     base->MCR |= SPI_MCR_HALT_MASK;
 383              		.loc 3 753 0
 384 004c 2B68     		ldr	r3, [r5]
 385 004e 43EA0903 		orr	r3, r3, r9
 386 0052 2B60     		str	r3, [r5]
 387              	.LVL34:
 388              	.LBE158:
 389              	.LBE157:
 390              	.LBB159:
 391              	.LBB160:
 754:../drivers/fsl_dspi.h **** }
 755:../drivers/fsl_dspi.h **** 
 756:../drivers/fsl_dspi.h **** /*!
 757:../drivers/fsl_dspi.h ****  * @brief Enables or disables the DSPI FIFOs.
 758:../drivers/fsl_dspi.h ****  *
 759:../drivers/fsl_dspi.h ****  * This function  allows the caller to disable/enable the Tx and Rx FIFOs independently.
 760:../drivers/fsl_dspi.h ****  * Note that to disable, pass in a logic 0 (false) for the particular FIFO configuration.  To enabl
 761:../drivers/fsl_dspi.h ****  * pass in a logic 1 (true).
 762:../drivers/fsl_dspi.h ****  *
 763:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 764:../drivers/fsl_dspi.h ****  * @param enableTxFifo Disables (false) the TX FIFO; Otherwise, enables (true) the TX FIFO
 765:../drivers/fsl_dspi.h ****  * @param enableRxFifo Disables (false) the RX FIFO; Otherwise, enables (true) the RX FIFO
 766:../drivers/fsl_dspi.h ****  */
 767:../drivers/fsl_dspi.h **** static inline void DSPI_SetFifoEnable(SPI_Type *base, bool enableTxFifo, bool enableRxFifo)
 768:../drivers/fsl_dspi.h **** {
 769:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~(SPI_MCR_DIS_RXF_MASK | SPI_MCR_DIS_TXF_MASK))) | SPI_MCR_DIS_TXF(!e
 770:../drivers/fsl_dspi.h ****                 SPI_MCR_DIS_RXF(!enableRxFifo);
 771:../drivers/fsl_dspi.h **** }
 772:../drivers/fsl_dspi.h **** 
 773:../drivers/fsl_dspi.h **** /*!
 774:../drivers/fsl_dspi.h ****  * @brief Flushes the DSPI FIFOs.
 775:../drivers/fsl_dspi.h ****  *
 776:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 777:../drivers/fsl_dspi.h ****  * @param flushTxFifo Flushes (true) the Tx FIFO; Otherwise, does not flush (false) the Tx FIFO
 778:../drivers/fsl_dspi.h ****  * @param flushRxFifo Flushes (true) the Rx FIFO; Otherwise, does not flush (false) the Rx FIFO
 779:../drivers/fsl_dspi.h ****  */
 780:../drivers/fsl_dspi.h **** static inline void DSPI_FlushFifo(SPI_Type *base, bool flushTxFifo, bool flushRxFifo)
 781:../drivers/fsl_dspi.h **** {
 782:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) | SPI_MCR_CLR_TXF(fl
 392              		.loc 3 782 0
 393 0054 2B68     		ldr	r3, [r5]
 394 0056 43F44063 		orr	r3, r3, #3072
 395 005a 2B60     		str	r3, [r5]
 396              	.LVL35:
 397              	.LBE160:
 398              	.LBE159:
 184:../drivers/fsl_dspi_edma.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 399              		.loc 2 184 0
 400 005c 01F00F00 		and	r0, r1, #15
 401              	.LBB161:
 402              	.LBB162:
 580:../drivers/fsl_dspi.h **** }
 403              		.loc 3 580 0
 404 0060 4A4B     		ldr	r3, .L142+4
 405 0062 EB62     		str	r3, [r5, #44]
 406              	.LVL36:
 407              	.LBE162:
 408              	.LBE161:
 180:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 409              		.loc 2 180 0
 410 0064 C1F30312 		ubfx	r2, r1, #4, #4
 411              	.LBB163:
 412              	.LBB164:
 783:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 784:../drivers/fsl_dspi.h **** }
 785:../drivers/fsl_dspi.h **** 
 786:../drivers/fsl_dspi.h **** /*!
 787:../drivers/fsl_dspi.h ****  * @brief Configures the DSPI peripheral chip select polarity simultaneously.
 788:../drivers/fsl_dspi.h ****  * For example, PCS0 and PCS1 are set to active low and other PCS is set to active high. Note that 
 789:../drivers/fsl_dspi.h ****  * PCSs is specific to the device.
 790:../drivers/fsl_dspi.h ****  * @code
 791:../drivers/fsl_dspi.h ****  *  DSPI_SetAllPcsPolarity(base, kDSPI_Pcs0ActiveLow | kDSPI_Pcs1ActiveLow);
 792:../drivers/fsl_dspi.h ****    @endcode
 793:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 794:../drivers/fsl_dspi.h ****  * @param mask The PCS polarity mask; use the enum _dspi_pcs_polarity.
 795:../drivers/fsl_dspi.h ****  */
 796:../drivers/fsl_dspi.h **** static inline void DSPI_SetAllPcsPolarity(SPI_Type *base, uint32_t mask)
 797:../drivers/fsl_dspi.h **** {
 798:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & ~SPI_MCR_PCSIS_MASK) | SPI_MCR_PCSIS(mask);
 799:../drivers/fsl_dspi.h **** }
 800:../drivers/fsl_dspi.h **** 
 801:../drivers/fsl_dspi.h **** /*!
 802:../drivers/fsl_dspi.h ****  * @brief Sets the DSPI baud rate in bits per second.
 803:../drivers/fsl_dspi.h ****  *
 804:../drivers/fsl_dspi.h ****  * This function  takes in the desired baudRate_Bps (baud rate) and calculates the nearest possible
 805:../drivers/fsl_dspi.h ****  * exceeding the desired baud rate, and returns the calculated baud rate in bits-per-second. It req
 806:../drivers/fsl_dspi.h ****  * caller also provide the frequency of the module source clock (in Hertz).
 807:../drivers/fsl_dspi.h ****  *
 808:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 809:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of the type dspi_ctar
 810:../drivers/fsl_dspi.h ****  * @param baudRate_Bps The desired baud rate in bits per second
 811:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz
 812:../drivers/fsl_dspi.h ****  * @return The actual calculated baud rate
 813:../drivers/fsl_dspi.h ****  */
 814:../drivers/fsl_dspi.h **** uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
 815:../drivers/fsl_dspi.h ****                                 dspi_ctar_selection_t whichCtar,
 816:../drivers/fsl_dspi.h ****                                 uint32_t baudRate_Bps,
 817:../drivers/fsl_dspi.h ****                                 uint32_t srcClock_Hz);
 818:../drivers/fsl_dspi.h **** 
 819:../drivers/fsl_dspi.h **** /*!
 820:../drivers/fsl_dspi.h ****  * @brief Manually configures the delay prescaler and scaler for a particular CTAR.
 821:../drivers/fsl_dspi.h ****  *
 822:../drivers/fsl_dspi.h ****  * This function configures the PCS to SCK delay pre-scalar (PcsSCK) and scalar (CSSCK), after SCK 
 823:../drivers/fsl_dspi.h ****  * (PASC) and scalar (ASC), and the delay after transfer pre-scalar (PDT) and scalar (DT).
 824:../drivers/fsl_dspi.h ****  *
 825:../drivers/fsl_dspi.h ****  * These delay names are available in the type dspi_delay_type_t.
 826:../drivers/fsl_dspi.h ****  *
 827:../drivers/fsl_dspi.h ****  * The user passes the delay to the configuration along with the prescaler and scaler value.
 828:../drivers/fsl_dspi.h ****  * This allows the user to directly set the prescaler/scaler values if pre-calculated or
 829:../drivers/fsl_dspi.h ****  * to manually increment either value.
 830:../drivers/fsl_dspi.h ****  *
 831:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 832:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of type dspi_ctar_sel
 833:../drivers/fsl_dspi.h ****  * @param prescaler The prescaler delay value (can be an integer 0, 1, 2, or 3).
 834:../drivers/fsl_dspi.h ****  * @param scaler The scaler delay value (can be any integer between 0 to 15).
 835:../drivers/fsl_dspi.h ****  * @param whichDelay The desired delay to configure; must be of type dspi_delay_type_t
 836:../drivers/fsl_dspi.h ****  */
 837:../drivers/fsl_dspi.h **** void DSPI_MasterSetDelayScaler(
 838:../drivers/fsl_dspi.h ****     SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_dela
 839:../drivers/fsl_dspi.h **** 
 840:../drivers/fsl_dspi.h **** /*!
 841:../drivers/fsl_dspi.h ****  * @brief Calculates the delay prescaler and scaler based on the desired delay input in nanoseconds
 842:../drivers/fsl_dspi.h ****  *
 843:../drivers/fsl_dspi.h ****  * This function calculates the values for the following.
 844:../drivers/fsl_dspi.h ****  * PCS to SCK delay pre-scalar (PCSSCK) and scalar (CSSCK), or
 845:../drivers/fsl_dspi.h ****  * After SCK delay pre-scalar (PASC) and scalar (ASC), or
 846:../drivers/fsl_dspi.h ****  * Delay after transfer pre-scalar (PDT) and scalar (DT).
 847:../drivers/fsl_dspi.h ****  *
 848:../drivers/fsl_dspi.h ****  * These delay names are available in the type dspi_delay_type_t.
 849:../drivers/fsl_dspi.h ****  *
 850:../drivers/fsl_dspi.h ****  * The user passes which delay to configure along with the desired delay value in nanoseconds.  The
 851:../drivers/fsl_dspi.h ****  * calculates the values needed for the prescaler and scaler. Note that returning the calculated de
 852:../drivers/fsl_dspi.h ****  * delay match may not be possible. In this case, the closest match is calculated without going bel
 853:../drivers/fsl_dspi.h ****  * delay value input.
 854:../drivers/fsl_dspi.h ****  * It is possible to input a very large delay value that exceeds the capability of the part, in whi
 855:../drivers/fsl_dspi.h ****  * supported delay is returned. The higher-level peripheral driver alerts the user of an out of ran
 856:../drivers/fsl_dspi.h ****  * input.
 857:../drivers/fsl_dspi.h ****  *
 858:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 859:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of type dspi_ctar_sel
 860:../drivers/fsl_dspi.h ****  * @param whichDelay The desired delay to configure, must be of type dspi_delay_type_t
 861:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz
 862:../drivers/fsl_dspi.h ****  * @param delayTimeInNanoSec The desired delay value in nanoseconds.
 863:../drivers/fsl_dspi.h ****  * @return The actual calculated delay value.
 864:../drivers/fsl_dspi.h ****  */
 865:../drivers/fsl_dspi.h **** uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
 866:../drivers/fsl_dspi.h ****                                   dspi_ctar_selection_t whichCtar,
 867:../drivers/fsl_dspi.h ****                                   dspi_delay_type_t whichDelay,
 868:../drivers/fsl_dspi.h ****                                   uint32_t srcClock_Hz,
 869:../drivers/fsl_dspi.h ****                                   uint32_t delayTimeInNanoSec);
 870:../drivers/fsl_dspi.h **** 
 871:../drivers/fsl_dspi.h **** /*!
 872:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer for master mode.
 873:../drivers/fsl_dspi.h ****  *
 874:../drivers/fsl_dspi.h ****  * In master mode, the 16-bit data is appended to the 16-bit command info. The command portion
 875:../drivers/fsl_dspi.h ****  * provides characteristics of the data, such as the optional continuous chip select
 876:../drivers/fsl_dspi.h ****  * operation between transfers, the desired Clock and Transfer Attributes register to use for the
 877:../drivers/fsl_dspi.h ****  * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
 878:../drivers/fsl_dspi.h ****  * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
 879:../drivers/fsl_dspi.h ****  * sending the first frame of a data packet). This is an example.
 880:../drivers/fsl_dspi.h ****  * @code
 881:../drivers/fsl_dspi.h ****  *  dspi_command_data_config_t commandConfig;
 882:../drivers/fsl_dspi.h ****  *  commandConfig.isPcsContinuous = true;
 883:../drivers/fsl_dspi.h ****  *  commandConfig.whichCtar = kDSPICtar0;
 884:../drivers/fsl_dspi.h ****  *  commandConfig.whichPcs = kDSPIPcs0;
 885:../drivers/fsl_dspi.h ****  *  commandConfig.clearTransferCount = false;
 886:../drivers/fsl_dspi.h ****  *  commandConfig.isEndOfQueue = false;
 887:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteData(base, &commandConfig, dataWord);
 888:../drivers/fsl_dspi.h ****    @endcode
 889:../drivers/fsl_dspi.h ****  *
 890:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 891:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 892:../drivers/fsl_dspi.h ****  * @param data The data word to be sent.
 893:../drivers/fsl_dspi.h ****  */
 894:../drivers/fsl_dspi.h **** static inline void DSPI_MasterWriteData(SPI_Type *base, dspi_command_data_config_t *command, uint16
 895:../drivers/fsl_dspi.h **** {
 896:../drivers/fsl_dspi.h ****     base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
 897:../drivers/fsl_dspi.h ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 898:../drivers/fsl_dspi.h ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 899:../drivers/fsl_dspi.h **** }
 900:../drivers/fsl_dspi.h **** 
 901:../drivers/fsl_dspi.h **** /*!
 902:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_command_data_config_t structure to default values.
 903:../drivers/fsl_dspi.h ****  *
 904:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for use in the DSPI_Ma
 905:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_MasterWrite_xx() or modify the str
 906:../drivers/fsl_dspi.h ****  * before calling the DSPI_MasterWrite_xx().
 907:../drivers/fsl_dspi.h ****  * This is an example.
 908:../drivers/fsl_dspi.h ****  * @code
 909:../drivers/fsl_dspi.h ****  *  dspi_command_data_config_t  command;
 910:../drivers/fsl_dspi.h ****  *  DSPI_GetDefaultDataCommandConfig(&command);
 911:../drivers/fsl_dspi.h ****  * @endcode
 912:../drivers/fsl_dspi.h ****  * @param command Pointer to the dspi_command_data_config_t structure.
 913:../drivers/fsl_dspi.h ****  */
 914:../drivers/fsl_dspi.h **** void DSPI_GetDefaultDataCommandConfig(dspi_command_data_config_t *command);
 915:../drivers/fsl_dspi.h **** 
 916:../drivers/fsl_dspi.h **** /*!
 917:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer master mode and waits till complete to return.
 918:../drivers/fsl_dspi.h ****  *
 919:../drivers/fsl_dspi.h ****  * In master mode, the 16-bit data is appended to the 16-bit command info. The command portion
 920:../drivers/fsl_dspi.h ****  * provides characteristics of the data, such as the optional continuous chip select
 921:../drivers/fsl_dspi.h ****  * operation between transfers, the desired Clock and Transfer Attributes register to use for the
 922:../drivers/fsl_dspi.h ****  * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
 923:../drivers/fsl_dspi.h ****  * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
 924:../drivers/fsl_dspi.h ****  * sending the first frame of a data packet). This is an example.
 925:../drivers/fsl_dspi.h ****  * @code
 926:../drivers/fsl_dspi.h ****  *  dspi_command_config_t commandConfig;
 927:../drivers/fsl_dspi.h ****  *  commandConfig.isPcsContinuous = true;
 928:../drivers/fsl_dspi.h ****  *  commandConfig.whichCtar = kDSPICtar0;
 929:../drivers/fsl_dspi.h ****  *  commandConfig.whichPcs = kDSPIPcs1;
 930:../drivers/fsl_dspi.h ****  *  commandConfig.clearTransferCount = false;
 931:../drivers/fsl_dspi.h ****  *  commandConfig.isEndOfQueue = false;
 932:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteDataBlocking(base, &commandConfig, dataWord);
 933:../drivers/fsl_dspi.h ****  * @endcode
 934:../drivers/fsl_dspi.h ****  *
 935:../drivers/fsl_dspi.h ****  * Note that this function does not return until after the transmit is complete. Also note that the
 936:../drivers/fsl_dspi.h ****  * enabled and running to transmit data (MCR[MDIS] & [HALT] = 0). Because the SPI is a synchronous 
 937:../drivers/fsl_dspi.h ****  * the received data is available when the transmit completes.
 938:../drivers/fsl_dspi.h ****  *
 939:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 940:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 941:../drivers/fsl_dspi.h ****  * @param data The data word to be sent.
 942:../drivers/fsl_dspi.h ****  */
 943:../drivers/fsl_dspi.h **** void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t dat
 944:../drivers/fsl_dspi.h **** 
 945:../drivers/fsl_dspi.h **** /*!
 946:../drivers/fsl_dspi.h ****  * @brief Returns the DSPI command word formatted to the PUSHR data register bit field.
 947:../drivers/fsl_dspi.h ****  *
 948:../drivers/fsl_dspi.h ****  * This function allows the caller to pass in the data command structure and returns the command wo
 949:../drivers/fsl_dspi.h ****  * according to the DSPI PUSHR register bit field placement. The user can then "OR" the returned co
 950:../drivers/fsl_dspi.h ****  * desired data to send and use the function DSPI_HAL_WriteCommandDataMastermode or
 951:../drivers/fsl_dspi.h ****  * DSPI_HAL_WriteCommandDataMastermodeBlocking to write the entire 32-bit command data word to the 
 952:../drivers/fsl_dspi.h ****  * improve performance in cases where the command structure is constant. For example, the user call
 953:../drivers/fsl_dspi.h ****  * before starting a transfer to generate the command word. When they are ready to transmit the dat
 954:../drivers/fsl_dspi.h ****  * this formatted command word with the desired data to transmit. This process increases transmit p
 955:../drivers/fsl_dspi.h ****  * compared to calling send functions, such as DSPI_HAL_WriteDataMastermode,  which format the comm
 956:../drivers/fsl_dspi.h ****  * data word is to be sent.
 957:../drivers/fsl_dspi.h ****  *
 958:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 959:../drivers/fsl_dspi.h ****  * @return The command word formatted to the PUSHR data register bit field.
 960:../drivers/fsl_dspi.h ****  */
 961:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_MasterGetFormattedCommand(dspi_command_data_config_t *command)
 962:../drivers/fsl_dspi.h **** {
 963:../drivers/fsl_dspi.h ****     /* Format the 16-bit command word according to the PUSHR data register bit field*/
 964:../drivers/fsl_dspi.h ****     return (uint32_t)(SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar)
 413              		.loc 3 964 0
 414 0068 0307     		lsls	r3, r0, #28
 415              	.LBE164:
 416              	.LBE163:
 180:../drivers/fsl_dspi_edma.c ****     commandStruct.isEndOfQueue = false;
 417              		.loc 2 180 0
 418 006a 09FA02F2 		lsl	r2, r9, r2
 419              	.LBB170:
 420              	.LBB165:
 421              		.loc 3 964 0
 422 006e 03F0E043 		and	r3, r3, #1879048192
 423              	.LBE165:
 424              	.LBE170:
 185:../drivers/fsl_dspi_edma.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 425              		.loc 2 185 0
 426 0072 C1F3005C 		ubfx	ip, r1, #20, #1
 427              	.LBB171:
 428              	.LBB166:
 965:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 429              		.loc 3 965 0
 430 0076 1204     		lsls	r2, r2, #16
 431              	.LBE166:
 432              	.LBE171:
 189:../drivers/fsl_dspi_edma.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 433              		.loc 2 189 0
 434 0078 C1F34051 		ubfx	r1, r1, #21, #1
 435              	.LBB172:
 436              	.LBB167:
 437              		.loc 3 965 0
 438 007c 02F47C12 		and	r2, r2, #4128768
 439              	.LBE167:
 440              	.LBE172:
 441              	.LBB173:
 442              	.LBB174:
 443 0080 43EAC171 		orr	r1, r3, r1, lsl #31
 444              	.LBE174:
 445              	.LBE173:
 446              	.LBB177:
 447              	.LBB168:
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 448              		.loc 3 964 0
 449 0084 43EA020E 		orr	lr, r3, r2
 450              	.LBE168:
 451              	.LBE177:
 452              	.LBB178:
 453              	.LBB175:
 454              		.loc 3 965 0
 455 0088 41F00061 		orr	r1, r1, #134217728
 456              	.LBE175:
 457              	.LBE178:
 192:../drivers/fsl_dspi_edma.c **** 
 458              		.loc 2 192 0
 459 008c 831C     		adds	r3, r0, #2
 460              	.LBB179:
 461              	.LBB176:
 462              		.loc 3 965 0
 463 008e 1143     		orrs	r1, r1, r2
 464              	.LBE176:
 465              	.LBE179:
 192:../drivers/fsl_dspi_edma.c **** 
 466              		.loc 2 192 0
 467 0090 05EB8303 		add	r3, r5, r3, lsl #2
 468              	.LBB180:
 469              	.LBB169:
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 470              		.loc 3 964 0
 471 0094 4EEACC7E 		orr	lr, lr, ip, lsl #31
 472              	.LVL37:
 473              	.LBE169:
 474              	.LBE180:
 186:../drivers/fsl_dspi_edma.c **** 
 475              		.loc 2 186 0
 476 0098 C4F804E0 		str	lr, [r4, #4]
 477              	.LVL38:
 190:../drivers/fsl_dspi_edma.c **** 
 478              		.loc 2 190 0
 479 009c A160     		str	r1, [r4, #8]
 192:../drivers/fsl_dspi_edma.c **** 
 480              		.loc 2 192 0
 481 009e 5A68     		ldr	r2, [r3, #4]
 194:../drivers/fsl_dspi_edma.c ****     {
 482              		.loc 2 194 0
 483 00a0 2B68     		ldr	r3, [r5]
 192:../drivers/fsl_dspi_edma.c **** 
 484              		.loc 2 192 0
 485 00a2 C2F3C362 		ubfx	r2, r2, #27, #4
 486 00a6 4A44     		add	r2, r2, r9
 194:../drivers/fsl_dspi_edma.c ****     {
 487              		.loc 2 194 0
 488 00a8 D804     		lsls	r0, r3, #19
 192:../drivers/fsl_dspi_edma.c **** 
 489              		.loc 2 192 0
 490 00aa 2260     		str	r2, [r4]
 194:../drivers/fsl_dspi_edma.c ****     {
 491              		.loc 2 194 0
 492 00ac 02D4     		bmi	.L14
 493 00ae 2B68     		ldr	r3, [r5]
 494 00b0 9904     		lsls	r1, r3, #18
 495 00b2 20D5     		bpl	.L15
 496              	.L14:
 196:../drivers/fsl_dspi_edma.c ****     }
 497              		.loc 2 196 0
 498 00b4 0123     		movs	r3, #1
 499              	.L17:
 200:../drivers/fsl_dspi_edma.c ****     }
 500              		.loc 2 200 0
 501 00b6 2373     		strb	r3, [r4, #12]
 202:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
 502              		.loc 2 202 0
 503 00b8 3B68     		ldr	r3, [r7]
 504 00ba 2361     		str	r3, [r4, #16]
 203:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
 505              		.loc 2 203 0
 506 00bc 7B68     		ldr	r3, [r7, #4]
 507 00be 6361     		str	r3, [r4, #20]
 204:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 508              		.loc 2 204 0
 509 00c0 BB68     		ldr	r3, [r7, #8]
 510 00c2 A361     		str	r3, [r4, #24]
 205:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
 511              		.loc 2 205 0
 512 00c4 BB68     		ldr	r3, [r7, #8]
 513 00c6 E361     		str	r3, [r4, #28]
 206:../drivers/fsl_dspi_edma.c **** 
 514              		.loc 2 206 0
 515 00c8 BB68     		ldr	r3, [r7, #8]
 214:../drivers/fsl_dspi_edma.c ****     }
 516              		.loc 2 214 0
 517 00ca 3148     		ldr	r0, .L142+8
 206:../drivers/fsl_dspi_edma.c **** 
 518              		.loc 2 206 0
 519 00cc 2362     		str	r3, [r4, #32]
 520              	.LVL39:
 214:../drivers/fsl_dspi_edma.c ****     }
 521              		.loc 2 214 0
 522 00ce 47F6FF71 		movw	r1, #32767
 523 00d2 40F2FF13 		movw	r3, #511
 524 00d6 8542     		cmp	r5, r0
 525 00d8 08BF     		it	eq
 526 00da 0B46     		moveq	r3, r1
 527              	.LVL40:
 221:../drivers/fsl_dspi_edma.c ****     {
 528              		.loc 2 221 0
 529 00dc 082A     		cmp	r2, #8
 223:../drivers/fsl_dspi_edma.c ****         {
 530              		.loc 2 223 0
 531 00de BA68     		ldr	r2, [r7, #8]
 221:../drivers/fsl_dspi_edma.c ****     {
 532              		.loc 2 221 0
 533 00e0 1BD9     		bls	.L19
 223:../drivers/fsl_dspi_edma.c ****         {
 534              		.loc 2 223 0
 535 00e2 B2EB430F 		cmp	r2, r3, lsl #1
 536 00e6 44D9     		bls	.L20
 537              	.L138:
 233:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 538              		.loc 2 233 0
 539 00e8 0023     		movs	r3, #0
 540              	.LVL41:
 541 00ea E373     		strb	r3, [r4, #15]
 234:../drivers/fsl_dspi_edma.c ****         }
 542              		.loc 2 234 0
 543 00ec 40F25B20 		movw	r0, #603
 544              	.LVL42:
 545              	.L11:
 546              	.LBE156:
 547              	.LBE155:
 923:../drivers/fsl_dspi_edma.c **** 
 548              		.loc 2 923 0
 549 00f0 15B0     		add	sp, sp, #84
 550              		.cfi_remember_state
 551              		.cfi_def_cfa_offset 28
 552              		@ sp needed
 553 00f2 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 554              	.LVL43:
 555              	.L15:
 556              		.cfi_restore_state
 557              	.LBB216:
 558              	.LBB213:
 200:../drivers/fsl_dspi_edma.c ****     }
 559              		.loc 2 200 0
 560 00f6 264B     		ldr	r3, .L142+8
 561 00f8 9D42     		cmp	r5, r3
 562 00fa 0AD0     		beq	.L101
 563 00fc 03F58053 		add	r3, r3, #4096
 564 0100 9D42     		cmp	r5, r3
 565 0102 08D0     		beq	.L102
 566 0104 03F5FE23 		add	r3, r3, #520192
 567 0108 9D42     		cmp	r5, r3
 568 010a 14BF     		ite	ne
 569 010c FF23     		movne	r3, #255
 570 010e 0123     		moveq	r3, #1
 571 0110 D1E7     		b	.L17
 572              	.L101:
 573 0112 0423     		movs	r3, #4
 574 0114 CFE7     		b	.L17
 575              	.L102:
 576 0116 4B46     		mov	r3, r9
 577 0118 CDE7     		b	.L17
 578              	.LVL44:
 579              	.L19:
 231:../drivers/fsl_dspi_edma.c ****         {
 580              		.loc 2 231 0
 581 011a 9342     		cmp	r3, r2
 582 011c E4D3     		bcc	.L138
 583              	.LVL45:
 584              	.L22:
 585              	.LBB181:
 586              	.LBB182:
 661:../drivers/fsl_dspi.h **** }
 587              		.loc 3 661 0
 588 011e 2B6B     		ldr	r3, [r5, #48]
 589              	.LBE182:
 590              	.LBE181:
 247:../drivers/fsl_dspi_edma.c ****                      &s_dspiMasterEdmaPrivateHandle[instance]);
 591              		.loc 2 247 0
 592 0120 1C4A     		ldr	r2, .L142+12
 593 0122 1D49     		ldr	r1, .L142+16
 594              	.LVL46:
 595 0124 606B     		ldr	r0, [r4, #52]
 596              	.LVL47:
 597              	.LBB184:
 598              	.LBB183:
 661:../drivers/fsl_dspi.h **** }
 599              		.loc 3 661 0
 600 0126 23F04073 		bic	r3, r3, #50331648
 601 012a 23F44033 		bic	r3, r3, #196608
 602 012e 2B63     		str	r3, [r5, #48]
 603              	.LVL48:
 604              	.LBE183:
 605              	.LBE184:
 247:../drivers/fsl_dspi_edma.c ****                      &s_dspiMasterEdmaPrivateHandle[instance]);
 606              		.loc 2 247 0
 607 0130 02EBC802 		add	r2, r2, r8, lsl #3
 608 0134 FFF7FEFF 		bl	EDMA_SetCallback
 609              	.LVL49:
 275:../drivers/fsl_dspi_edma.c ****     {
 610              		.loc 2 275 0
 611 0138 154B     		ldr	r3, .L142+8
 612              	.LVL50:
 613 013a 9D42     		cmp	r5, r3
 614 013c 2368     		ldr	r3, [r4]
 615              	.LVL51:
 616 013e 40F0F881 		bne	.L23
 282:../drivers/fsl_dspi_edma.c ****         {
 617              		.loc 2 282 0
 618 0142 082B     		cmp	r3, #8
 619 0144 40F2E281 		bls	.L24
 285:../drivers/fsl_dspi_edma.c ****             {
 620              		.loc 2 285 0
 621 0148 A369     		ldr	r3, [r4, #24]
 622 014a 022B     		cmp	r3, #2
 287:../drivers/fsl_dspi_edma.c ****                 {
 623              		.loc 2 287 0
 624 014c 2369     		ldr	r3, [r4, #16]
 285:../drivers/fsl_dspi_edma.c ****             {
 625              		.loc 2 285 0
 626 014e 25D8     		bhi	.L25
 287:../drivers/fsl_dspi_edma.c ****                 {
 627              		.loc 2 287 0
 628 0150 B3B1     		cbz	r3, .L26
 289:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 629              		.loc 2 289 0
 630 0152 2369     		ldr	r3, [r4, #16]
 290:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 631              		.loc 2 290 0
 632 0154 2269     		ldr	r2, [r4, #16]
 289:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 633              		.loc 2 289 0
 634 0156 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 635              	.LVL52:
 290:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 636              		.loc 2 290 0
 637 0158 0132     		adds	r2, r2, #1
 638 015a 2261     		str	r2, [r4, #16]
 291:../drivers/fsl_dspi_edma.c ****                 }
 639              		.loc 2 291 0
 640 015c 2269     		ldr	r2, [r4, #16]
 641 015e 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 642 0160 43EA0222 		orr	r2, r3, r2, lsl #8
 643              	.LVL53:
 644              	.L27:
 297:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 645              		.loc 2 297 0
 646 0164 A368     		ldr	r3, [r4, #8]
 647 0166 1B0C     		lsrs	r3, r3, #16
 648 0168 1B04     		lsls	r3, r3, #16
 649              	.L139:
 330:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 650              		.loc 2 330 0
 651 016a 1343     		orrs	r3, r3, r2
 652 016c A360     		str	r3, [r4, #8]
 331:../drivers/fsl_dspi_edma.c ****             }
 653              		.loc 2 331 0
 654 016e A368     		ldr	r3, [r4, #8]
 655 0170 27E0     		b	.L130
 656              	.LVL54:
 657              	.L20:
 239:../drivers/fsl_dspi_edma.c ****     {
 658              		.loc 2 239 0
 659 0172 BB68     		ldr	r3, [r7, #8]
 660              	.LVL55:
 661 0174 DA07     		lsls	r2, r3, #31
 662 0176 D2D5     		bpl	.L22
 241:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 663              		.loc 2 241 0
 664 0178 0023     		movs	r3, #0
 665 017a E373     		strb	r3, [r4, #15]
 666              	.LVL56:
 667              	.L99:
 668              	.LBE213:
 669              	.LBE216:
 141:../drivers/fsl_dspi_edma.c ****     }
 670              		.loc 2 141 0
 671 017c 0420     		movs	r0, #4
 672 017e B7E7     		b	.L11
 673              	.LVL57:
 674              	.L26:
 675              	.LBB217:
 676              	.LBB214:
 295:../drivers/fsl_dspi_edma.c ****                 }
 677              		.loc 2 295 0
 678 0180 46EA0622 		orr	r2, r6, r6, lsl #8
 679              	.LVL58:
 680 0184 EEE7     		b	.L27
 681              	.L143:
 682 0186 00BF     		.align	2
 683              	.L142:
 684 0188 00000000 		.word	s_dummyData
 685 018c 00000ADA 		.word	-636878848
 686 0190 00C00240 		.word	1073922048
 687 0194 00000000 		.word	.LANCHOR0
 688 0198 00000000 		.word	EDMA_DspiMasterCallback
 689              	.LVL59:
 690              	.L25:
 302:../drivers/fsl_dspi_edma.c ****                 {
 691              		.loc 2 302 0
 692 019c 002B     		cmp	r3, #0
 693 019e 00F0AE81 		beq	.L29
 304:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 694              		.loc 2 304 0
 695 01a2 2369     		ldr	r3, [r4, #16]
 305:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 696              		.loc 2 305 0
 697 01a4 2269     		ldr	r2, [r4, #16]
 304:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 698              		.loc 2 304 0
 699 01a6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 700              	.LVL60:
 305:../drivers/fsl_dspi_edma.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 701              		.loc 2 305 0
 702 01a8 0132     		adds	r2, r2, #1
 703 01aa 2261     		str	r2, [r4, #16]
 306:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* increment to next data byte */
 704              		.loc 2 306 0
 705 01ac 2269     		ldr	r2, [r4, #16]
 706 01ae 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 707 01b0 43EA0222 		orr	r2, r3, r2, lsl #8
 708              	.LVL61:
 307:../drivers/fsl_dspi_edma.c ****                 }
 709              		.loc 2 307 0
 710 01b4 2369     		ldr	r3, [r4, #16]
 711 01b6 0133     		adds	r3, r3, #1
 712 01b8 2361     		str	r3, [r4, #16]
 713              	.L30:
 313:../drivers/fsl_dspi_edma.c ****             }
 714              		.loc 2 313 0
 715 01ba 6368     		ldr	r3, [r4, #4]
 716 01bc 1B0C     		lsrs	r3, r3, #16
 717 01be 1B04     		lsls	r3, r3, #16
 718              	.L131:
 719 01c0 1343     		orrs	r3, r3, r2
 720              	.L130:
 721 01c2 6360     		str	r3, [r4, #4]
 722              	.LVL62:
 723              	.L28:
 436:../drivers/fsl_dspi_edma.c **** 
 724              		.loc 2 436 0
 725 01c4 636B     		ldr	r3, [r4, #52]
 726 01c6 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 727 01c8 9868     		ldr	r0, [r3, #8]
 728 01ca FFF7FEFF 		bl	EDMA_ResetChannel
 729              	.LVL63:
 730              	.LBB185:
 731              	.LBB186:
 700:../drivers/fsl_dspi.h **** }
 732              		.loc 3 700 0
 733 01ce 05F13803 		add	r3, r5, #56
 734              	.LBE186:
 735              	.LBE185:
 438:../drivers/fsl_dspi_edma.c ****     transferConfigA.srcOffset = 0;
 736              		.loc 2 438 0
 737 01d2 0293     		str	r3, [sp, #8]
 439:../drivers/fsl_dspi_edma.c **** 
 738              		.loc 2 439 0
 739 01d4 0023     		movs	r3, #0
 740 01d6 ADF81230 		strh	r3, [sp, #18]	@ movhi
 441:../drivers/fsl_dspi_edma.c ****     {
 741              		.loc 2 441 0
 742 01da 6369     		ldr	r3, [r4, #20]
 743 01dc 002B     		cmp	r3, #0
 744 01de 00F01C82 		beq	.L50
 443:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 1;
 745              		.loc 2 443 0
 746 01e2 6369     		ldr	r3, [r4, #20]
 747 01e4 0393     		str	r3, [sp, #12]
 444:../drivers/fsl_dspi_edma.c ****     }
 748              		.loc 2 444 0
 749 01e6 0123     		movs	r3, #1
 750              	.L132:
 449:../drivers/fsl_dspi_edma.c ****     }
 751              		.loc 2 449 0
 752 01e8 ADF81430 		strh	r3, [sp, #20]	@ movhi
 454:../drivers/fsl_dspi_edma.c ****     {
 753              		.loc 2 454 0
 754 01ec 2368     		ldr	r3, [r4]
 470:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 755              		.loc 2 470 0
 756 01ee 606B     		ldr	r0, [r4, #52]
 454:../drivers/fsl_dspi_edma.c ****     {
 757              		.loc 2 454 0
 758 01f0 082B     		cmp	r3, #8
 759 01f2 4FF00103 		mov	r3, #1
 462:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 2;
 760              		.loc 2 462 0
 761 01f6 81BF     		itttt	hi
 762 01f8 8DF81030 		strbhi	r3, [sp, #16]
 463:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
 763              		.loc 2 463 0
 764 01fc 0223     		movhi	r3, #2
 765 01fe 0693     		strhi	r3, [sp, #24]
 464:../drivers/fsl_dspi_edma.c ****     }
 766              		.loc 2 464 0
 767 0200 E369     		ldrhi	r3, [r4, #28]
 457:../drivers/fsl_dspi_edma.c ****         transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
 768              		.loc 2 457 0
 769 0202 96BF     		itet	ls
 770 0204 0693     		strls	r3, [sp, #24]
 464:../drivers/fsl_dspi_edma.c ****     }
 771              		.loc 2 464 0
 772 0206 5B08     		lsrhi	r3, r3, #1
 458:../drivers/fsl_dspi_edma.c ****     }
 773              		.loc 2 458 0
 774 0208 E369     		ldrls	r3, [r4, #28]
 464:../drivers/fsl_dspi_edma.c ****     }
 775              		.loc 2 464 0
 776 020a 0793     		str	r3, [sp, #28]
 468:../drivers/fsl_dspi_edma.c **** 
 777              		.loc 2 468 0
 778 020c 069B     		ldr	r3, [sp, #24]
 779 020e A373     		strb	r3, [r4, #14]
 452:../drivers/fsl_dspi_edma.c **** 
 780              		.loc 2 452 0
 781 0210 4FF00002 		mov	r2, #0
 456:../drivers/fsl_dspi_edma.c ****         transferConfigA.minorLoopBytes = 1;
 782              		.loc 2 456 0
 783 0214 98BF     		it	ls
 784 0216 8DF81020 		strbls	r2, [sp, #16]
 470:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 785              		.loc 2 470 0
 786 021a 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 452:../drivers/fsl_dspi_edma.c **** 
 787              		.loc 2 452 0
 788 021c 8DF81120 		strb	r2, [sp, #17]
 470:../drivers/fsl_dspi_edma.c ****                            &transferConfigA, NULL);
 789              		.loc 2 470 0
 790 0220 0023     		movs	r3, #0
 791 0222 02AA     		add	r2, sp, #8
 792 0224 8068     		ldr	r0, [r0, #8]
 793 0226 FFF7FEFF 		bl	EDMA_SetTransferConfig
 794              	.LVL64:
 472:../drivers/fsl_dspi_edma.c ****                                  kEDMA_MajorInterruptEnable);
 795              		.loc 2 472 0
 796 022a 636B     		ldr	r3, [r4, #52]
 797 022c 0222     		movs	r2, #2
 798 022e 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 799 0230 9868     		ldr	r0, [r3, #8]
 800 0232 FFF7FEFF 		bl	EDMA_EnableChannelInterrupts
 801              	.LVL65:
 476:../drivers/fsl_dspi_edma.c ****         ((((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 802              		.loc 2 476 0
 803 0236 A369     		ldr	r3, [r4, #24]
 804 0238 13B1     		cbz	r3, .L54
 805 023a B24B     		ldr	r3, .L144
 806              	.LVL66:
 807 023c 9D42     		cmp	r5, r3
 808 023e 0ED1     		bne	.L55
 809              	.LVL67:
 810              	.L54:
 477:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 811              		.loc 2 477 0
 812 0240 A369     		ldr	r3, [r4, #24]
 476:../drivers/fsl_dspi_edma.c ****         ((((handle->remainingSendByteCount > 1) && (handle->bitsPerFrame <= 8)) ||
 813              		.loc 2 476 0
 814 0242 012B     		cmp	r3, #1
 815 0244 02D9     		bls	.L56
 477:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 816              		.loc 2 477 0
 817 0246 2368     		ldr	r3, [r4]
 818 0248 082B     		cmp	r3, #8
 819 024a 05D9     		bls	.L57
 820              	.L56:
 478:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
 821              		.loc 2 478 0
 822 024c A369     		ldr	r3, [r4, #24]
 477:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8))) &&
 823              		.loc 2 477 0
 824 024e 022B     		cmp	r3, #2
 825 0250 1FD9     		bls	.L58
 478:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
 826              		.loc 2 478 0
 827 0252 2368     		ldr	r3, [r4]
 828 0254 082B     		cmp	r3, #8
 829 0256 1CD9     		bls	.L58
 830              	.L57:
 831 0258 AA4B     		ldr	r3, .L144
 832              	.LVL68:
 833 025a 9D42     		cmp	r5, r3
 834 025c 19D1     		bne	.L58
 835              	.L55:
 481:../drivers/fsl_dspi_edma.c ****         {
 836              		.loc 2 481 0
 837 025e 2369     		ldr	r3, [r4, #16]
 838              	.LVL69:
 839 0260 2268     		ldr	r2, [r4]
 840 0262 002B     		cmp	r3, #0
 841 0264 00F0EA81 		beq	.L59
 842              	.LVL70:
 843              	.LBB187:
 485:../drivers/fsl_dspi_edma.c ****             {
 844              		.loc 2 485 0
 845 0268 A64B     		ldr	r3, .L144
 846              	.LVL71:
 847 026a 9D42     		cmp	r5, r3
 489:../drivers/fsl_dspi_edma.c ****                 }
 848              		.loc 2 489 0
 849 026c A369     		ldr	r3, [r4, #24]
 850              	.LVL72:
 485:../drivers/fsl_dspi_edma.c ****             {
 851              		.loc 2 485 0
 852 026e 04D1     		bne	.L62
 487:../drivers/fsl_dspi_edma.c ****                 {
 853              		.loc 2 487 0
 854 0270 082A     		cmp	r2, #8
 489:../drivers/fsl_dspi_edma.c ****                 }
 855              		.loc 2 489 0
 856 0272 94BF     		ite	ls
 857 0274 03F1FF33 		addls	r3, r3, #-1
 858              	.LVL73:
 493:../drivers/fsl_dspi_edma.c ****                 }
 859              		.loc 2 493 0
 860 0278 023B     		subhi	r3, r3, #2
 861              	.LVL74:
 862              	.L62:
 501:../drivers/fsl_dspi_edma.c ****             {
 863              		.loc 2 501 0
 864 027a 082A     		cmp	r2, #8
 503:../drivers/fsl_dspi_edma.c ****             }
 865              		.loc 2 503 0
 866 027c A068     		ldr	r0, [r4, #8]
 867 027e A24F     		ldr	r7, .L144+4
 868 0280 2169     		ldr	r1, [r4, #16]
 501:../drivers/fsl_dspi_edma.c ****             {
 869              		.loc 2 501 0
 870 0282 00F2CE81 		bhi	.L63
 503:../drivers/fsl_dspi_edma.c ****             }
 871              		.loc 2 503 0
 872 0286 0B44     		add	r3, r3, r1
 873              	.LVL75:
 874 0288 3840     		ands	r0, r0, r7
 875 028a 13F8012C 		ldrb	r2, [r3, #-1]	@ zero_extendqisi2
 876 028e 0243     		orrs	r2, r2, r0
 877 0290 A260     		str	r2, [r4, #8]
 878              	.LVL76:
 879              	.L58:
 880              	.LBE187:
 671:../drivers/fsl_dspi_edma.c **** 
 881              		.loc 2 671 0
 882 0292 A36B     		ldr	r3, [r4, #56]
 883 0294 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 884 0296 9868     		ldr	r0, [r3, #8]
 885 0298 FFF7FEFF 		bl	EDMA_ResetChannel
 886              	.LVL77:
 675:../drivers/fsl_dspi_edma.c ****     {
 887              		.loc 2 675 0
 888 029c 994B     		ldr	r3, .L144
 889              	.LVL78:
 167:../drivers/fsl_dspi_edma.c **** 
 890              		.loc 2 167 0
 891 029e 04F16006 		add	r6, r4, #96
 675:../drivers/fsl_dspi_edma.c ****     {
 892              		.loc 2 675 0
 893 02a2 9D42     		cmp	r5, r3
 167:../drivers/fsl_dspi_edma.c **** 
 894              		.loc 2 167 0
 895 02a4 26F01F06 		bic	r6, r6, #31
 675:../drivers/fsl_dspi_edma.c ****     {
 896              		.loc 2 675 0
 897 02a8 1AD1     		bne	.L66
 677:../drivers/fsl_dspi_edma.c ****         transferConfigB.destAddr = (uint32_t) & (handle->command);
 898              		.loc 2 677 0
 899 02aa 04F10803 		add	r3, r4, #8
 900              	.LVL79:
 901 02ae 0893     		str	r3, [sp, #32]
 678:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcTransferSize = kEDMA_TransferSize4Bytes;
 902              		.loc 2 678 0
 903 02b0 231D     		adds	r3, r4, #4
 904 02b2 0993     		str	r3, [sp, #36]
 679:../drivers/fsl_dspi_edma.c ****         transferConfigB.destTransferSize = kEDMA_TransferSize4Bytes;
 905              		.loc 2 679 0
 906 02b4 0223     		movs	r3, #2
 907 02b6 8DF82830 		strb	r3, [sp, #40]
 680:../drivers/fsl_dspi_edma.c ****         transferConfigB.srcOffset = 0;
 908              		.loc 2 680 0
 909 02ba 8DF82930 		strb	r3, [sp, #41]
 683:../drivers/fsl_dspi_edma.c ****         transferConfigB.majorLoopCounts = 1;
 910              		.loc 2 683 0
 911 02be 0423     		movs	r3, #4
 681:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 912              		.loc 2 681 0
 913 02c0 0027     		movs	r7, #0
 683:../drivers/fsl_dspi_edma.c ****         transferConfigB.majorLoopCounts = 1;
 914              		.loc 2 683 0
 915 02c2 0C93     		str	r3, [sp, #48]
 686:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 916              		.loc 2 686 0
 917 02c4 3046     		mov	r0, r6
 684:../drivers/fsl_dspi_edma.c **** 
 918              		.loc 2 684 0
 919 02c6 0123     		movs	r3, #1
 681:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 920              		.loc 2 681 0
 921 02c8 ADF82A70 		strh	r7, [sp, #42]	@ movhi
 682:../drivers/fsl_dspi_edma.c ****         transferConfigB.minorLoopBytes = 4;
 922              		.loc 2 682 0
 923 02cc ADF82C70 		strh	r7, [sp, #44]	@ movhi
 684:../drivers/fsl_dspi_edma.c **** 
 924              		.loc 2 684 0
 925 02d0 0D93     		str	r3, [sp, #52]
 686:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigB, NULL);
 926              		.loc 2 686 0
 927 02d2 FFF7FEFF 		bl	EDMA_TcdReset
 928              	.LVL80:
 687:../drivers/fsl_dspi_edma.c ****     }
 929              		.loc 2 687 0
 930 02d6 3A46     		mov	r2, r7
 931 02d8 08A9     		add	r1, sp, #32
 932 02da 3046     		mov	r0, r6
 933 02dc FFF7FEFF 		bl	EDMA_TcdSetTransferConfig
 934              	.LVL81:
 935              	.L66:
 691:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8))) &&
 936              		.loc 2 691 0
 937 02e0 A369     		ldr	r3, [r4, #24]
 938 02e2 A06B     		ldr	r0, [r4, #56]
 939 02e4 022B     		cmp	r3, #2
 940 02e6 02D9     		bls	.L67
 941 02e8 2368     		ldr	r3, [r4]
 942 02ea 082B     		cmp	r3, #8
 943 02ec 09D9     		bls	.L68
 944              	.L67:
 692:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))) ||
 945              		.loc 2 692 0
 946 02ee A369     		ldr	r3, [r4, #24]
 691:../drivers/fsl_dspi_edma.c ****           ((handle->remainingSendByteCount > 4) && (handle->bitsPerFrame > 8))) &&
 947              		.loc 2 691 0
 948 02f0 042B     		cmp	r3, #4
 949 02f2 02D9     		bls	.L69
 692:../drivers/fsl_dspi_edma.c ****          (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))) ||
 950              		.loc 2 692 0
 951 02f4 2368     		ldr	r3, [r4]
 952 02f6 082B     		cmp	r3, #8
 953 02f8 03D8     		bhi	.L68
 954              	.L69:
 693:../drivers/fsl_dspi_edma.c ****         (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 955              		.loc 2 693 0
 956 02fa 824B     		ldr	r3, .L144
 957              	.LVL82:
 958 02fc 9D42     		cmp	r5, r3
 959 02fe 00F0AF81 		beq	.L70
 960              	.LVL83:
 961              	.L68:
 696:../drivers/fsl_dspi_edma.c ****         {
 962              		.loc 2 696 0
 963 0302 2369     		ldr	r3, [r4, #16]
 964 0304 002B     		cmp	r3, #0
 965 0306 00F0A581 		beq	.L71
 698:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 1;
 966              		.loc 2 698 0
 967 030a 2369     		ldr	r3, [r4, #16]
 968 030c 0893     		str	r3, [sp, #32]
 699:../drivers/fsl_dspi_edma.c ****         }
 969              		.loc 2 699 0
 970 030e 0123     		movs	r3, #1
 971              	.L134:
 712:../drivers/fsl_dspi_edma.c ****         {
 972              		.loc 2 712 0
 973 0310 2268     		ldr	r2, [r4]
 704:../drivers/fsl_dspi_edma.c ****         }
 974              		.loc 2 704 0
 975 0312 ADF82A30 		strh	r3, [sp, #42]	@ movhi
 707:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 976              		.loc 2 707 0
 977 0316 231D     		adds	r3, r4, #4
 712:../drivers/fsl_dspi_edma.c ****         {
 978              		.loc 2 712 0
 979 0318 082A     		cmp	r2, #8
 707:../drivers/fsl_dspi_edma.c ****         transferConfigB.destOffset = 0;
 980              		.loc 2 707 0
 981 031a 0993     		str	r3, [sp, #36]
 708:../drivers/fsl_dspi_edma.c **** 
 982              		.loc 2 708 0
 983 031c 4FF00003 		mov	r3, #0
 984 0320 ADF82C30 		strh	r3, [sp, #44]	@ movhi
 710:../drivers/fsl_dspi_edma.c **** 
 985              		.loc 2 710 0
 986 0324 8DF82830 		strb	r3, [sp, #40]
 731:../drivers/fsl_dspi_edma.c ****             if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 987              		.loc 2 731 0
 988 0328 84BF     		itt	hi
 989 032a 0223     		movhi	r3, #2
 990 032c 0C93     		strhi	r3, [sp, #48]
 991 032e 754A     		ldr	r2, .L144
 992              	.LVL84:
 734:../drivers/fsl_dspi_edma.c ****             }
 993              		.loc 2 734 0
 994 0330 8CBF     		ite	hi
 995 0332 A369     		ldrhi	r3, [r4, #24]
 714:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 1;
 996              		.loc 2 714 0
 997 0334 8DF82930 		strbls	r3, [sp, #41]
 998 0338 4FF00101 		mov	r1, #1
 715:../drivers/fsl_dspi_edma.c **** 
 999              		.loc 2 715 0
 1000 033c 99BF     		ittee	ls
 1001 033e 0C91     		strls	r1, [sp, #48]
 719:../drivers/fsl_dspi_edma.c ****             }
 1002              		.loc 2 719 0
 1003 0340 A369     		ldrls	r3, [r4, #24]
 730:../drivers/fsl_dspi_edma.c ****             transferConfigB.minorLoopBytes = 2;
 1004              		.loc 2 730 0
 1005 0342 8DF82910 		strbhi	r1, [sp, #41]
 734:../drivers/fsl_dspi_edma.c ****             }
 1006              		.loc 2 734 0
 1007 0346 5B08     		lsrhi	r3, r3, #1
 732:../drivers/fsl_dspi_edma.c ****             {
 1008              		.loc 2 732 0
 1009 0348 9542     		cmp	r5, r2
 1010 034a 40F08781 		bne	.L77
 734:../drivers/fsl_dspi_edma.c ****             }
 1011              		.loc 2 734 0
 1012 034e 023B     		subs	r3, r3, #2
 1013 0350 0D93     		str	r3, [sp, #52]
 746:../drivers/fsl_dspi_edma.c ****                                    handle->edmaTxDataToIntermediaryHandle->channel, &transferConfig
 1014              		.loc 2 746 0
 1015 0352 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1016 0354 8068     		ldr	r0, [r0, #8]
 1017 0356 3346     		mov	r3, r6
 1018 0358 08AA     		add	r2, sp, #32
 1019              	.LVL85:
 1020 035a FFF7FEFF 		bl	EDMA_SetTransferConfig
 1021              	.LVL86:
 748:../drivers/fsl_dspi_edma.c ****                                        handle->edmaIntermediaryToTxRegHandle->channel, false);
 1022              		.loc 2 748 0
 1023 035e E36B     		ldr	r3, [r4, #60]
 1024 0360 9A68     		ldr	r2, [r3, #8]
 1025 0362 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1026              	.LVL87:
 1027              	.LBB188:
 1028              	.LBB189:
 406:../drivers/fsl_edma.h **** }
 407:../drivers/fsl_edma.h **** 
 408:../drivers/fsl_edma.h **** /*!
 409:../drivers/fsl_edma.h ****  * @brief Sets the channel link for the eDMA transfer.
 410:../drivers/fsl_edma.h ****  *
 411:../drivers/fsl_edma.h ****  * This function configures either the minor link or the major link mode. The minor link means that
 412:../drivers/fsl_edma.h ****  * triggered every time CITER decreases by 1. The major link means that the channel link is trigger
 413:../drivers/fsl_edma.h ****  * exhausted.
 414:../drivers/fsl_edma.h ****  *
 415:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 416:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 417:../drivers/fsl_edma.h ****  * @param type A channel link type, which can be one of the following:
 418:../drivers/fsl_edma.h ****  *   @arg kEDMA_LinkNone
 419:../drivers/fsl_edma.h ****  *   @arg kEDMA_MinorLink
 420:../drivers/fsl_edma.h ****  *   @arg kEDMA_MajorLink
 421:../drivers/fsl_edma.h ****  * @param linkedChannel The linked channel number.
 422:../drivers/fsl_edma.h ****  * @note Users should ensure that DONE flag is cleared before calling this interface, or the config
 423:../drivers/fsl_edma.h ****  */
 424:../drivers/fsl_edma.h **** void EDMA_SetChannelLink(DMA_Type *base, uint32_t channel, edma_channel_link_type_t type, uint32_t 
 425:../drivers/fsl_edma.h **** 
 426:../drivers/fsl_edma.h **** /*!
 427:../drivers/fsl_edma.h ****  * @brief Sets the bandwidth for the eDMA transfer.
 428:../drivers/fsl_edma.h ****  *
 429:../drivers/fsl_edma.h ****  * Because the eDMA processes the minor loop, it continuously generates read/write sequences
 430:../drivers/fsl_edma.h ****  * until the minor count is exhausted. The bandwidth forces the eDMA to stall after the completion 
 431:../drivers/fsl_edma.h ****  * each read/write access to control the bus request bandwidth seen by the crossbar switch.
 432:../drivers/fsl_edma.h ****  *
 433:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 434:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 435:../drivers/fsl_edma.h ****  * @param bandWidth A bandwidth setting, which can be one of the following:
 436:../drivers/fsl_edma.h ****  *     @arg kEDMABandwidthStallNone
 437:../drivers/fsl_edma.h ****  *     @arg kEDMABandwidthStall4Cycle
 438:../drivers/fsl_edma.h ****  *     @arg kEDMABandwidthStall8Cycle
 439:../drivers/fsl_edma.h ****  */
 440:../drivers/fsl_edma.h **** void EDMA_SetBandWidth(DMA_Type *base, uint32_t channel, edma_bandwidth_t bandWidth);
 441:../drivers/fsl_edma.h **** 
 442:../drivers/fsl_edma.h **** /*!
 443:../drivers/fsl_edma.h ****  * @brief Sets the source modulo and the destination modulo for the eDMA transfer.
 444:../drivers/fsl_edma.h ****  *
 445:../drivers/fsl_edma.h ****  * This function defines a specific address range specified to be the value after (SADDR + SOFF)/(D
 446:../drivers/fsl_edma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 447:../drivers/fsl_edma.h ****  * queue easily.
 448:../drivers/fsl_edma.h ****  *
 449:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 450:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 451:../drivers/fsl_edma.h ****  * @param srcModulo A source modulo value.
 452:../drivers/fsl_edma.h ****  * @param destModulo A destination modulo value.
 453:../drivers/fsl_edma.h ****  */
 454:../drivers/fsl_edma.h **** void EDMA_SetModulo(DMA_Type *base, uint32_t channel, edma_modulo_t srcModulo, edma_modulo_t destMo
 455:../drivers/fsl_edma.h **** 
 456:../drivers/fsl_edma.h **** #if defined(FSL_FEATURE_EDMA_ASYNCHRO_REQUEST_CHANNEL_COUNT) && FSL_FEATURE_EDMA_ASYNCHRO_REQUEST_C
 457:../drivers/fsl_edma.h **** /*!
 458:../drivers/fsl_edma.h ****  * @brief Enables an async request for the eDMA transfer.
 459:../drivers/fsl_edma.h ****  *
 460:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 461:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 462:../drivers/fsl_edma.h ****  * @param enable The command to enable (true) or disable (false).
 463:../drivers/fsl_edma.h ****  */
 464:../drivers/fsl_edma.h **** static inline void EDMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 465:../drivers/fsl_edma.h **** {
 466:../drivers/fsl_edma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 467:../drivers/fsl_edma.h **** 
 468:../drivers/fsl_edma.h ****     base->EARS = (base->EARS & (~(1U << channel))) | ((uint32_t)enable << channel);
 469:../drivers/fsl_edma.h **** }
 470:../drivers/fsl_edma.h **** #endif /* FSL_FEATURE_EDMA_ASYNCHRO_REQUEST_CHANNEL_COUNT */
 471:../drivers/fsl_edma.h **** 
 472:../drivers/fsl_edma.h **** /*!
 473:../drivers/fsl_edma.h ****  * @brief Enables an auto stop request for the eDMA transfer.
 474:../drivers/fsl_edma.h ****  *
 475:../drivers/fsl_edma.h ****  * If enabling the auto stop request, the eDMA hardware automatically disables the hardware channel
 476:../drivers/fsl_edma.h ****  *
 477:../drivers/fsl_edma.h ****  * @param base eDMA peripheral base address.
 478:../drivers/fsl_edma.h ****  * @param channel eDMA channel number.
 479:../drivers/fsl_edma.h ****  * @param enable The command to enable (true) or disable (false).
 480:../drivers/fsl_edma.h ****  */
 481:../drivers/fsl_edma.h **** static inline void EDMA_EnableAutoStopRequest(DMA_Type *base, uint32_t channel, bool enable)
 482:../drivers/fsl_edma.h **** {
 483:../drivers/fsl_edma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 484:../drivers/fsl_edma.h **** 
 485:../drivers/fsl_edma.h ****     base->TCD[channel].CSR = (base->TCD[channel].CSR & (~DMA_CSR_DREQ_MASK)) | DMA_CSR_DREQ(enable)
 1029              		.loc 1 485 0
 1030 0364 41F21C01 		movw	r1, #4124
 1031 0368 02EB4312 		add	r2, r2, r3, lsl #5
 1032              	.LVL88:
 1033 036c 535A     		ldrh	r3, [r2, r1]
 1034              	.LVL89:
 1035 036e 23F00803 		bic	r3, r3, #8
 1036 0372 1B04     		lsls	r3, r3, #16
 1037 0374 1B0C     		lsrs	r3, r3, #16
 1038 0376 5352     		strh	r3, [r2, r1]	@ movhi
 1039              	.LVL90:
 1040              	.L96:
 1041              	.LBE189:
 1042              	.LBE188:
 767:../drivers/fsl_dspi_edma.c **** 
 1043              		.loc 2 767 0
 1044 0378 E36B     		ldr	r3, [r4, #60]
 1045 037a 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1046 037c 9868     		ldr	r0, [r3, #8]
 1047 037e FFF7FEFF 		bl	EDMA_ResetChannel
 1048              	.LVL91:
 771:../drivers/fsl_dspi_edma.c ****     {
 1049              		.loc 2 771 0
 1050 0382 604B     		ldr	r3, .L144
 1051              	.LVL92:
 1052 0384 9D42     		cmp	r5, r3
 1053              	.LBB190:
 1054              	.LBB191:
 674:../drivers/fsl_dspi.h **** }
 1055              		.loc 3 674 0
 1056 0386 05F13408 		add	r8, r5, #52
 1057              	.LVL93:
 1058              	.LBE191:
 1059              	.LBE190:
 771:../drivers/fsl_dspi_edma.c ****     {
 1060              		.loc 2 771 0
 1061 038a 1CD0     		beq	.L78
 1062 038c A369     		ldr	r3, [r4, #24]
 1063              	.LVL94:
 1064 038e D3B1     		cbz	r3, .L78
 773:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 1065              		.loc 2 773 0
 1066 0390 04F10803 		add	r3, r4, #8
 1067 0394 0E93     		str	r3, [sp, #56]
 775:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 1068              		.loc 2 775 0
 1069 0396 0223     		movs	r3, #2
 1070 0398 8DF84030 		strb	r3, [sp, #64]
 776:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 1071              		.loc 2 776 0
 1072 039c 8DF84130 		strb	r3, [sp, #65]
 779:../drivers/fsl_dspi_edma.c ****         transferConfigC.majorLoopCounts = 1;
 1073              		.loc 2 779 0
 1074 03a0 0423     		movs	r3, #4
 777:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1075              		.loc 2 777 0
 1076 03a2 0027     		movs	r7, #0
 779:../drivers/fsl_dspi_edma.c ****         transferConfigC.majorLoopCounts = 1;
 1077              		.loc 2 779 0
 1078 03a4 1293     		str	r3, [sp, #72]
 782:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigC, NULL);
 1079              		.loc 2 782 0
 1080 03a6 3046     		mov	r0, r6
 780:../drivers/fsl_dspi_edma.c **** 
 1081              		.loc 2 780 0
 1082 03a8 0123     		movs	r3, #1
 774:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcTransferSize = kEDMA_TransferSize4Bytes;
 1083              		.loc 2 774 0
 1084 03aa CDF83C80 		str	r8, [sp, #60]
 777:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1085              		.loc 2 777 0
 1086 03ae ADF84270 		strh	r7, [sp, #66]	@ movhi
 778:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 1087              		.loc 2 778 0
 1088 03b2 ADF84470 		strh	r7, [sp, #68]	@ movhi
 780:../drivers/fsl_dspi_edma.c **** 
 1089              		.loc 2 780 0
 1090 03b6 1393     		str	r3, [sp, #76]
 782:../drivers/fsl_dspi_edma.c ****         EDMA_TcdSetTransferConfig(softwareTCD, &transferConfigC, NULL);
 1091              		.loc 2 782 0
 1092 03b8 FFF7FEFF 		bl	EDMA_TcdReset
 1093              	.LVL95:
 783:../drivers/fsl_dspi_edma.c ****     }
 1094              		.loc 2 783 0
 1095 03bc 3A46     		mov	r2, r7
 1096 03be 0EA9     		add	r1, sp, #56
 1097 03c0 3046     		mov	r0, r6
 1098 03c2 FFF7FEFF 		bl	EDMA_TcdSetTransferConfig
 1099              	.LVL96:
 1100              	.L78:
 786:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8)) ||
 1101              		.loc 2 786 0
 1102 03c6 A369     		ldr	r3, [r4, #24]
 1103 03c8 E06B     		ldr	r0, [r4, #60]
 1104 03ca 012B     		cmp	r3, #1
 1105 03cc 02D9     		bls	.L79
 1106 03ce 2368     		ldr	r3, [r4]
 1107 03d0 082B     		cmp	r3, #8
 1108 03d2 09D9     		bls	.L80
 1109              	.L79:
 787:../drivers/fsl_dspi_edma.c ****         (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 1110              		.loc 2 787 0
 1111 03d4 A369     		ldr	r3, [r4, #24]
 786:../drivers/fsl_dspi_edma.c ****         ((handle->remainingSendByteCount > 2) && (handle->bitsPerFrame > 8)) ||
 1112              		.loc 2 786 0
 1113 03d6 022B     		cmp	r3, #2
 1114 03d8 02D9     		bls	.L81
 787:../drivers/fsl_dspi_edma.c ****         (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
 1115              		.loc 2 787 0
 1116 03da 2368     		ldr	r3, [r4]
 1117 03dc 082B     		cmp	r3, #8
 1118 03de 03D8     		bhi	.L80
 1119              	.L81:
 1120 03e0 484B     		ldr	r3, .L144
 1121              	.LVL97:
 1122 03e2 9D42     		cmp	r5, r3
 1123 03e4 40F04681 		bne	.L82
 1124              	.LVL98:
 1125              	.L80:
 797:../drivers/fsl_dspi_edma.c ****         if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 1126              		.loc 2 797 0
 1127 03e8 0422     		movs	r2, #4
 790:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 1128              		.loc 2 790 0
 1129 03ea 231D     		adds	r3, r4, #4
 797:../drivers/fsl_dspi_edma.c ****         if (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
 1130              		.loc 2 797 0
 1131 03ec 1292     		str	r2, [sp, #72]
 798:../drivers/fsl_dspi_edma.c ****         {
 1132              		.loc 2 798 0
 1133 03ee 454A     		ldr	r2, .L144
 1134              	.LVL99:
 790:../drivers/fsl_dspi_edma.c ****         transferConfigC.destAddr = (uint32_t)txAddr;
 1135              		.loc 2 790 0
 1136 03f0 0E93     		str	r3, [sp, #56]
 793:../drivers/fsl_dspi_edma.c ****         transferConfigC.destTransferSize = kEDMA_TransferSize4Bytes;
 1137              		.loc 2 793 0
 1138 03f2 0223     		movs	r3, #2
 1139 03f4 8DF84030 		strb	r3, [sp, #64]
 794:../drivers/fsl_dspi_edma.c ****         transferConfigC.srcOffset = 0;
 1140              		.loc 2 794 0
 1141 03f8 8DF84130 		strb	r3, [sp, #65]
 798:../drivers/fsl_dspi_edma.c ****         {
 1142              		.loc 2 798 0
 1143 03fc 9542     		cmp	r5, r2
 795:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1144              		.loc 2 795 0
 1145 03fe 4FF00003 		mov	r3, #0
 791:../drivers/fsl_dspi_edma.c **** 
 1146              		.loc 2 791 0
 1147 0402 CDF83C80 		str	r8, [sp, #60]
 795:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 1148              		.loc 2 795 0
 1149 0406 ADF84230 		strh	r3, [sp, #66]	@ movhi
 796:../drivers/fsl_dspi_edma.c ****         transferConfigC.minorLoopBytes = 4;
 1150              		.loc 2 796 0
 1151 040a ADF84430 		strh	r3, [sp, #68]	@ movhi
 798:../drivers/fsl_dspi_edma.c ****         {
 1152              		.loc 2 798 0
 1153 040e 00F02E81 		beq	.L83
 800:../drivers/fsl_dspi_edma.c ****             {
 1154              		.loc 2 800 0
 1155 0412 2368     		ldr	r3, [r4]
 1156 0414 082B     		cmp	r3, #8
 802:../drivers/fsl_dspi_edma.c ****             }
 1157              		.loc 2 802 0
 1158 0416 A369     		ldr	r3, [r4, #24]
 806:../drivers/fsl_dspi_edma.c ****             }
 1159              		.loc 2 806 0
 1160 0418 88BF     		it	hi
 1161 041a 5B08     		lsrhi	r3, r3, #1
 1162 041c 013B     		subs	r3, r3, #1
 1163 041e 1393     		str	r3, [sp, #76]
 809:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 1164              		.loc 2 809 0
 1165 0420 3346     		mov	r3, r6
 1166              	.LVL100:
 1167              	.L136:
 816:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC
 1168              		.loc 2 816 0
 1169 0422 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1170 0424 8068     		ldr	r0, [r0, #8]
 1171 0426 0EAA     		add	r2, sp, #56
 1172 0428 FFF7FEFF 		bl	EDMA_SetTransferConfig
 1173              	.LVL101:
 820:../drivers/fsl_dspi_edma.c ****                                    handle->edmaIntermediaryToTxRegHandle->channel, false);
 1174              		.loc 2 820 0
 1175 042c E36B     		ldr	r3, [r4, #60]
 1176 042e 9A68     		ldr	r2, [r3, #8]
 1177 0430 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1178              	.LVL102:
 1179              	.LBB192:
 1180              	.LBB193:
 1181              		.loc 1 485 0
 1182 0432 41F21C01 		movw	r1, #4124
 1183 0436 02EB4312 		add	r2, r2, r3, lsl #5
 1184              	.LVL103:
 1185 043a 535A     		ldrh	r3, [r2, r1]
 1186              	.LVL104:
 1187 043c 23F00803 		bic	r3, r3, #8
 1188 0440 1B04     		lsls	r3, r3, #16
 1189 0442 1B0C     		lsrs	r3, r3, #16
 1190 0444 5352     		strh	r3, [r2, r1]	@ movhi
 1191              	.LVL105:
 1192              	.L87:
 1193              	.LBE193:
 1194              	.LBE192:
 830:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaTxDataToIntermediaryHandle);
 1195              		.loc 2 830 0
 1196 0446 606B     		ldr	r0, [r4, #52]
 1197 0448 FFF7FEFF 		bl	EDMA_StartTransfer
 1198              	.LVL106:
 831:../drivers/fsl_dspi_edma.c ****     EDMA_StartTransfer(handle->edmaIntermediaryToTxRegHandle);
 1199              		.loc 2 831 0
 1200 044c A06B     		ldr	r0, [r4, #56]
 1201 044e FFF7FEFF 		bl	EDMA_StartTransfer
 1202              	.LVL107:
 832:../drivers/fsl_dspi_edma.c **** 
 1203              		.loc 2 832 0
 1204 0452 E06B     		ldr	r0, [r4, #60]
 1205 0454 FFF7FEFF 		bl	EDMA_StartTransfer
 1206              	.LVL108:
 835:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityMid = handle->edmaTxDataToIntermediaryHandle->channel;
 1207              		.loc 2 835 0
 1208 0458 D4F834E0 		ldr	lr, [r4, #52]
 836:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 1209              		.loc 2 836 0
 1210 045c A26B     		ldr	r2, [r4, #56]
 835:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityMid = handle->edmaTxDataToIntermediaryHandle->channel;
 1211              		.loc 2 835 0
 1212 045e 9EF81030 		ldrb	r3, [lr, #16]	@ zero_extendqisi2
 1213              	.LVL109:
 836:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaIntermediaryToTxRegHandle->channel;
 1214              		.loc 2 836 0
 1215 0462 167C     		ldrb	r6, [r2, #16]	@ zero_extendqisi2
 1216              	.LVL110:
 837:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 1217              		.loc 2 837 0
 1218 0464 D4F83CC0 		ldr	ip, [r4, #60]
 839:../drivers/fsl_dspi_edma.c ****     {
 1219              		.loc 2 839 0
 1220 0468 B342     		cmp	r3, r6
 837:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 1221              		.loc 2 837 0
 1222 046a 9CF81010 		ldrb	r1, [ip, #16]	@ zero_extendqisi2
 1223              	.LVL111:
 839:../drivers/fsl_dspi_edma.c ****     {
 1224              		.loc 2 839 0
 1225 046e 00F23D81 		bhi	.L88
 846:../drivers/fsl_dspi_edma.c ****     {
 1226              		.loc 2 846 0
 1227 0472 8B42     		cmp	r3, r1
 1228 0474 00F20581 		bhi	.L107
 1229 0478 3046     		mov	r0, r6
 1230 047a 1E46     		mov	r6, r3
 1231              	.LVL112:
 1232              	.L97:
 837:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 1233              		.loc 2 837 0
 1234 047c 3246     		mov	r2, r6
 1235 047e 0F46     		mov	r7, r1
 1236 0480 0646     		mov	r6, r0
 1237              	.L89:
 1238              	.LVL113:
 853:../drivers/fsl_dspi_edma.c ****     {
 1239              		.loc 2 853 0
 1240 0482 B742     		cmp	r7, r6
 1241 0484 02D2     		bcs	.L90
 1242 0486 3046     		mov	r0, r6
 1243 0488 3E46     		mov	r6, r7
 1244 048a 0746     		mov	r7, r0
 1245              	.LVL114:
 1246              	.L90:
 862:../drivers/fsl_dspi_edma.c **** 
 1247              		.loc 2 862 0
 1248 048c 8DF80620 		strb	r2, [sp, #6]
 864:../drivers/fsl_dspi_edma.c ****     {
 1249              		.loc 2 864 0
 1250 0490 1C4A     		ldr	r2, .L144
 1251              	.LVL115:
 860:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 1252              		.loc 2 860 0
 1253 0492 4FF00108 		mov	r8, #1
 864:../drivers/fsl_dspi_edma.c ****     {
 1254              		.loc 2 864 0
 1255 0496 9542     		cmp	r5, r2
 860:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 1256              		.loc 2 860 0
 1257 0498 8DF80480 		strb	r8, [sp, #4]
 861:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
 1258              		.loc 2 861 0
 1259 049c 8DF80580 		strb	r8, [sp, #5]
 866:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1260              		.loc 2 866 0
 1261 04a0 01AA     		add	r2, sp, #4
 1262              	.LVL116:
 864:../drivers/fsl_dspi_edma.c ****     {
 1263              		.loc 2 864 0
 1264 04a2 00F0F480 		beq	.L91
 866:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1265              		.loc 2 866 0
 1266 04a6 DEF80800 		ldr	r0, [lr, #8]
 1267 04aa 1946     		mov	r1, r3
 1268 04ac FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1269              	.LVL117:
 870:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1270              		.loc 2 870 0
 1271 04b0 A36B     		ldr	r3, [r4, #56]
 869:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 1272              		.loc 2 869 0
 1273 04b2 8DF80660 		strb	r6, [sp, #6]
 870:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1274              		.loc 2 870 0
 1275 04b6 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1276 04b8 9868     		ldr	r0, [r3, #8]
 1277 04ba 01AA     		add	r2, sp, #4
 1278 04bc FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1279              	.LVL118:
 874:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 1280              		.loc 2 874 0
 1281 04c0 E36B     		ldr	r3, [r4, #60]
 873:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaIntermediaryToTxRegHandle->base,
 1282              		.loc 2 873 0
 1283 04c2 8DF80670 		strb	r7, [sp, #6]
 874:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 1284              		.loc 2 874 0
 1285 04c6 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1286 04c8 9868     		ldr	r0, [r3, #8]
 1287 04ca 01AA     		add	r2, sp, #4
 1288 04cc FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1289              	.LVL119:
 907:../drivers/fsl_dspi_edma.c ****         {
 1290              		.loc 2 907 0
 1291 04d0 A369     		ldr	r3, [r4, #24]
 1292 04d2 7BB1     		cbz	r3, .L93
 909:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToIntermediaryHandle->channel);
 1293              		.loc 2 909 0
 1294 04d4 606B     		ldr	r0, [r4, #52]
 910:../drivers/fsl_dspi_edma.c **** 
 1295              		.loc 2 910 0
 1296 04d6 A36B     		ldr	r3, [r4, #56]
 909:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToIntermediaryHandle->channel);
 1297              		.loc 2 909 0
 1298 04d8 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1299 04da 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1300 04dc 8068     		ldr	r0, [r0, #8]
 1301 04de 4246     		mov	r2, r8
 1302 04e0 FFF7FEFF 		bl	EDMA_SetChannelLink
 1303              	.LVL120:
 912:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel, kEDMA_MinorLink,
 1304              		.loc 2 912 0
 1305 04e4 A06B     		ldr	r0, [r4, #56]
 914:../drivers/fsl_dspi_edma.c ****         }
 1306              		.loc 2 914 0
 1307 04e6 E36B     		ldr	r3, [r4, #60]
 912:../drivers/fsl_dspi_edma.c ****                                 handle->edmaTxDataToIntermediaryHandle->channel, kEDMA_MinorLink,
 1308              		.loc 2 912 0
 1309 04e8 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1310 04ea 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1311 04ec 8068     		ldr	r0, [r0, #8]
 1312 04ee 4246     		mov	r2, r8
 1313 04f0 FFF7FEFF 		bl	EDMA_SetChannelLink
 1314              	.LVL121:
 1315              	.L93:
 1316              	.LBB194:
 1317              	.LBB195:
 645:../drivers/fsl_dspi.h **** }
 1318              		.loc 3 645 0
 1319 04f4 2B6B     		ldr	r3, [r5, #48]
 1320 04f6 43F44033 		orr	r3, r3, #196608
 1321 04fa 2B63     		str	r3, [r5, #48]
 1322 04fc EDE0     		b	.L95
 1323              	.LVL122:
 1324              	.L29:
 1325              	.LBE195:
 1326              	.LBE194:
 311:../drivers/fsl_dspi_edma.c ****                 }
 1327              		.loc 2 311 0
 1328 04fe 46EA0622 		orr	r2, r6, r6, lsl #8
 1329              	.LVL123:
 1330 0502 5AE6     		b	.L30
 1331              	.L145:
 1332              		.align	2
 1333              	.L144:
 1334 0504 00C00240 		.word	1073922048
 1335 0508 0000FFFF 		.word	-65536
 1336              	.LVL124:
 1337              	.L24:
 318:../drivers/fsl_dspi_edma.c ****             {
 1338              		.loc 2 318 0
 1339 050c 2369     		ldr	r3, [r4, #16]
 1340 050e 5BB1     		cbz	r3, .L31
 320:../drivers/fsl_dspi_edma.c ****                 ++handle->txData; /* increment to next data word*/
 1341              		.loc 2 320 0
 1342 0510 2369     		ldr	r3, [r4, #16]
 1343 0512 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1344              	.LVL125:
 321:../drivers/fsl_dspi_edma.c ****             }
 1345              		.loc 2 321 0
 1346 0514 2369     		ldr	r3, [r4, #16]
 1347 0516 0133     		adds	r3, r3, #1
 1348 0518 2361     		str	r3, [r4, #16]
 1349              	.L32:
 328:../drivers/fsl_dspi_edma.c ****             {
 1350              		.loc 2 328 0
 1351 051a A369     		ldr	r3, [r4, #24]
 1352 051c 7549     		ldr	r1, .L146
 1353 051e 012B     		cmp	r3, #1
 1354 0520 04D1     		bne	.L33
 330:../drivers/fsl_dspi_edma.c ****                 handle->command = handle->lastCommand;
 1355              		.loc 2 330 0
 1356 0522 A368     		ldr	r3, [r4, #8]
 1357 0524 0B40     		ands	r3, r3, r1
 1358 0526 20E6     		b	.L139
 1359              	.LVL126:
 1360              	.L31:
 325:../drivers/fsl_dspi_edma.c ****             }
 1361              		.loc 2 325 0
 1362 0528 B2B2     		uxth	r2, r6
 1363              	.LVL127:
 1364 052a F6E7     		b	.L32
 1365              	.L33:
 335:../drivers/fsl_dspi_edma.c ****             }
 1366              		.loc 2 335 0
 1367 052c 6368     		ldr	r3, [r4, #4]
 1368 052e 0B40     		ands	r3, r3, r1
 1369 0530 46E6     		b	.L131
 1370              	.LVL128:
 1371              	.L23:
 347:../drivers/fsl_dspi_edma.c ****         {
 1372              		.loc 2 347 0
 1373 0532 082B     		cmp	r3, #8
 1374 0534 67D8     		bhi	.L34
 1375 0536 6F49     		ldr	r1, .L146
 1376 0538 0222     		movs	r2, #2
 407:../drivers/fsl_dspi_edma.c ****                 }
 1377              		.loc 2 407 0
 1378 053a B0B2     		uxth	r0, r6
 1379              	.LBB196:
 1380              	.LBB197:
 580:../drivers/fsl_dspi.h **** }
 1381              		.loc 3 580 0
 1382 053c 4FF00077 		mov	r7, #33554432
 1383              	.LVL129:
 1384              	.L48:
 1385              	.LBE197:
 1386              	.LBE196:
 1387              	.LBB199:
 1388              	.LBB200:
 561:../drivers/fsl_dspi.h **** }
 1389              		.loc 3 561 0
 1390 0540 EB6A     		ldr	r3, [r5, #44]
 1391              	.LVL130:
 1392              	.LBE200:
 1393              	.LBE199:
 398:../drivers/fsl_dspi_edma.c ****             {
 1394              		.loc 2 398 0
 1395 0542 9B01     		lsls	r3, r3, #6
 1396 0544 7FF53EAE 		bpl	.L28
 400:../drivers/fsl_dspi_edma.c ****                 {
 1397              		.loc 2 400 0
 1398 0548 2369     		ldr	r3, [r4, #16]
 1399 054a 002B     		cmp	r3, #0
 1400 054c 63D0     		beq	.L44
 402:../drivers/fsl_dspi_edma.c ****                     ++handle->txData;
 1401              		.loc 2 402 0
 1402 054e 2369     		ldr	r3, [r4, #16]
 1403 0550 93F800E0 		ldrb	lr, [r3]	@ zero_extendqisi2
 1404              	.LVL131:
 403:../drivers/fsl_dspi_edma.c ****                 }
 1405              		.loc 2 403 0
 1406 0554 2369     		ldr	r3, [r4, #16]
 1407 0556 0133     		adds	r3, r3, #1
 1408 0558 2361     		str	r3, [r4, #16]
 1409              	.LVL132:
 1410              	.L45:
 410:../drivers/fsl_dspi_edma.c ****                 {
 1411              		.loc 2 410 0
 1412 055a A369     		ldr	r3, [r4, #24]
 1413 055c 012B     		cmp	r3, #1
 412:../drivers/fsl_dspi_edma.c ****                 }
 1414              		.loc 2 412 0
 1415 055e 0CBF     		ite	eq
 1416 0560 A368     		ldreq	r3, [r4, #8]
 416:../drivers/fsl_dspi_edma.c ****                 }
 1417              		.loc 2 416 0
 1418 0562 6368     		ldrne	r3, [r4, #4]
 1419 0564 0B40     		ands	r3, r3, r1
 1420 0566 43EA0E03 		orr	r3, r3, lr
 1421 056a 6B63     		str	r3, [r5, #52]
 1422              	.LVL133:
 1423              	.LBB201:
 1424              	.LBB198:
 580:../drivers/fsl_dspi.h **** }
 1425              		.loc 3 580 0
 1426 056c EF62     		str	r7, [r5, #44]
 1427              	.LVL134:
 1428              	.LBE198:
 1429              	.LBE201:
 422:../drivers/fsl_dspi_edma.c **** 
 1430              		.loc 2 422 0
 1431 056e A369     		ldr	r3, [r4, #24]
 1432 0570 013B     		subs	r3, r3, #1
 1433 0572 A361     		str	r3, [r4, #24]
 1434              	.LVL135:
 427:../drivers/fsl_dspi_edma.c ****                 {
 1435              		.loc 2 427 0
 1436 0574 A369     		ldr	r3, [r4, #24]
 1437 0576 002B     		cmp	r3, #0
 1438 0578 3FF424AE 		beq	.L28
 1439 057c 013A     		subs	r2, r2, #1
 1440              	.LVL136:
 1441 057e 12F0FF02 		ands	r2, r2, #255
 1442 0582 3FF41FAE 		beq	.L28
 1443 0586 DBE7     		b	.L48
 1444              	.LVL137:
 1445              	.L43:
 351:../drivers/fsl_dspi_edma.c ****                 {
 1446              		.loc 2 351 0
 1447 0588 A369     		ldr	r3, [r4, #24]
 1448 058a 022B     		cmp	r3, #2
 353:../drivers/fsl_dspi_edma.c ****                     {
 1449              		.loc 2 353 0
 1450 058c 2369     		ldr	r3, [r4, #16]
 351:../drivers/fsl_dspi_edma.c ****                 {
 1451              		.loc 2 351 0
 1452 058e 25D8     		bhi	.L36
 353:../drivers/fsl_dspi_edma.c ****                     {
 1453              		.loc 2 353 0
 1454 0590 13B3     		cbz	r3, .L105
 355:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1455              		.loc 2 355 0
 1456 0592 2369     		ldr	r3, [r4, #16]
 356:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 1457              		.loc 2 356 0
 1458 0594 D4F810C0 		ldr	ip, [r4, #16]
 355:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1459              		.loc 2 355 0
 1460 0598 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1461              	.LVL138:
 356:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 1462              		.loc 2 356 0
 1463 059a 0CF1010C 		add	ip, ip, #1
 1464 059e C4F810C0 		str	ip, [r4, #16]
 357:../drivers/fsl_dspi_edma.c ****                     }
 1465              		.loc 2 357 0
 1466 05a2 D4F810C0 		ldr	ip, [r4, #16]
 1467 05a6 9CF800C0 		ldrb	ip, [ip]	@ zero_extendqisi2
 1468 05aa 43EA0C2C 		orr	ip, r3, ip, lsl #8
 1469              	.LVL139:
 1470              	.L37:
 363:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 1471              		.loc 2 363 0
 1472 05ae A761     		str	r7, [r4, #24]
 364:../drivers/fsl_dspi_edma.c ****                 }
 1473              		.loc 2 364 0
 1474 05b0 A368     		ldr	r3, [r4, #8]
 1475              	.L128:
 381:../drivers/fsl_dspi_edma.c ****                 }
 1476              		.loc 2 381 0
 1477 05b2 0340     		ands	r3, r3, r0
 1478 05b4 43EA0C03 		orr	r3, r3, ip
 1479 05b8 6B63     		str	r3, [r5, #52]
 1480              	.LVL140:
 1481              	.LBB202:
 1482              	.LBB203:
 580:../drivers/fsl_dspi.h **** }
 1483              		.loc 3 580 0
 1484 05ba C5F82CE0 		str	lr, [r5, #44]
 1485              	.LVL141:
 1486              	.LBE203:
 1487              	.LBE202:
 390:../drivers/fsl_dspi_edma.c ****                 {
 1488              		.loc 2 390 0
 1489 05be A369     		ldr	r3, [r4, #24]
 1490 05c0 002B     		cmp	r3, #0
 1491 05c2 3FF4FFAD 		beq	.L28
 1492 05c6 013A     		subs	r2, r2, #1
 1493              	.LVL142:
 1494 05c8 12F0FF02 		ands	r2, r2, #255
 1495 05cc 3FF4FAAD 		beq	.L28
 1496              	.LVL143:
 1497              	.L42:
 1498              	.LBB205:
 1499              	.LBB206:
 561:../drivers/fsl_dspi.h **** }
 1500              		.loc 3 561 0
 1501 05d0 EB6A     		ldr	r3, [r5, #44]
 1502              	.LVL144:
 1503              	.LBE206:
 1504              	.LBE205:
 349:../drivers/fsl_dspi_edma.c ****             {
 1505              		.loc 2 349 0
 1506 05d2 9B01     		lsls	r3, r3, #6
 1507 05d4 D8D4     		bmi	.L43
 1508 05d6 F5E5     		b	.L28
 1509              	.L105:
 361:../drivers/fsl_dspi_edma.c ****                     }
 1510              		.loc 2 361 0
 1511 05d8 8C46     		mov	ip, r1
 1512 05da E8E7     		b	.L37
 1513              	.L36:
 369:../drivers/fsl_dspi_edma.c ****                     {
 1514              		.loc 2 369 0
 1515 05dc 8BB1     		cbz	r3, .L106
 371:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1516              		.loc 2 371 0
 1517 05de 2369     		ldr	r3, [r4, #16]
 1518 05e0 93F800C0 		ldrb	ip, [r3]	@ zero_extendqisi2
 1519              	.LVL145:
 372:../drivers/fsl_dspi_edma.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 1520              		.loc 2 372 0
 1521 05e4 2369     		ldr	r3, [r4, #16]
 1522 05e6 0133     		adds	r3, r3, #1
 1523 05e8 2361     		str	r3, [r4, #16]
 373:../drivers/fsl_dspi_edma.c ****                         ++handle->txData;
 1524              		.loc 2 373 0
 1525 05ea 2369     		ldr	r3, [r4, #16]
 1526 05ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1527 05ee 4CEA032C 		orr	ip, ip, r3, lsl #8
 1528              	.LVL146:
 374:../drivers/fsl_dspi_edma.c ****                     }
 1529              		.loc 2 374 0
 1530 05f2 2369     		ldr	r3, [r4, #16]
 1531 05f4 0133     		adds	r3, r3, #1
 1532 05f6 2361     		str	r3, [r4, #16]
 1533              	.LVL147:
 1534              	.L39:
 380:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->command & 0xffff0000U) | wordToSend;
 1535              		.loc 2 380 0
 1536 05f8 A369     		ldr	r3, [r4, #24]
 1537 05fa 023B     		subs	r3, r3, #2
 1538 05fc A361     		str	r3, [r4, #24]
 381:../drivers/fsl_dspi_edma.c ****                 }
 1539              		.loc 2 381 0
 1540 05fe 6368     		ldr	r3, [r4, #4]
 1541 0600 D7E7     		b	.L128
 1542              	.LVL148:
 1543              	.L106:
 378:../drivers/fsl_dspi_edma.c ****                     }
 1544              		.loc 2 378 0
 1545 0602 8C46     		mov	ip, r1
 1546 0604 F8E7     		b	.L39
 1547              	.LVL149:
 1548              	.L34:
 1549 0606 46EA0621 		orr	r1, r6, r6, lsl #8
 1550 060a 0222     		movs	r2, #2
 381:../drivers/fsl_dspi_edma.c ****                 }
 1551              		.loc 2 381 0
 1552 060c 3948     		ldr	r0, .L146
 363:../drivers/fsl_dspi_edma.c ****                     base->PUSHR = (handle->lastCommand & 0xffff0000U) | wordToSend;
 1553              		.loc 2 363 0
 1554 060e 0027     		movs	r7, #0
 1555              	.LVL150:
 1556              	.LBB207:
 1557              	.LBB204:
 580:../drivers/fsl_dspi.h **** }
 1558              		.loc 3 580 0
 1559 0610 4FF0007E 		mov	lr, #33554432
 1560 0614 DCE7     		b	.L42
 1561              	.LVL151:
 1562              	.L44:
 1563              	.LBE204:
 1564              	.LBE207:
 407:../drivers/fsl_dspi_edma.c ****                 }
 1565              		.loc 2 407 0
 1566 0616 8646     		mov	lr, r0
 1567              	.LVL152:
 1568 0618 9FE7     		b	.L45
 1569              	.LVL153:
 1570              	.L50:
 448:../drivers/fsl_dspi_edma.c ****         transferConfigA.destOffset = 0;
 1571              		.loc 2 448 0
 1572 061a 04F12402 		add	r2, r4, #36
 1573 061e 0392     		str	r2, [sp, #12]
 1574 0620 E2E5     		b	.L132
 1575              	.LVL154:
 1576              	.L63:
 1577              	.LBB208:
 509:../drivers/fsl_dspi_edma.c ****             }
 1578              		.loc 2 509 0
 1579 0622 2669     		ldr	r6, [r4, #16]
 1580              	.LVL155:
 1581 0624 1E44     		add	r6, r6, r3
 508:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 1582              		.loc 2 508 0
 1583 0626 0B44     		add	r3, r3, r1
 1584              	.LVL156:
 509:../drivers/fsl_dspi_edma.c ****             }
 1585              		.loc 2 509 0
 1586 0628 16F8022C 		ldrb	r2, [r6, #-2]	@ zero_extendqisi2
 508:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 1587              		.loc 2 508 0
 1588 062c 13F8013C 		ldrb	r3, [r3, #-1]	@ zero_extendqisi2
 507:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 1589              		.loc 2 507 0
 1590 0630 3840     		ands	r0, r0, r7
 508:../drivers/fsl_dspi_edma.c ****                                       handle->txData[bufferIndex - 2];
 1591              		.loc 2 508 0
 1592 0632 0243     		orrs	r2, r2, r0
 1593 0634 42EA0323 		orr	r3, r2, r3, lsl #8
 507:../drivers/fsl_dspi_edma.c ****                                       ((uint32_t)handle->txData[bufferIndex - 1] << 8) |
 1594              		.loc 2 507 0
 1595 0638 A360     		str	r3, [r4, #8]
 1596 063a 2AE6     		b	.L58
 1597              	.LVL157:
 1598              	.L59:
 1599              	.LBE208:
 522:../drivers/fsl_dspi_edma.c ****         }
 1600              		.loc 2 522 0
 1601 063c A368     		ldr	r3, [r4, #8]
 1602 063e B6B2     		uxth	r6, r6
 1603              	.LVL158:
 514:../drivers/fsl_dspi_edma.c ****             {
 1604              		.loc 2 514 0
 1605 0640 082A     		cmp	r2, #8
 522:../drivers/fsl_dspi_edma.c ****         }
 1606              		.loc 2 522 0
 1607 0642 4FEA1343 		lsr	r3, r3, #16
 520:../drivers/fsl_dspi_edma.c ****             }
 1608              		.loc 2 520 0
 1609 0646 88BF     		it	hi
 1610 0648 46EA0626 		orrhi	r6, r6, r6, lsl #8
 1611              	.LVL159:
 522:../drivers/fsl_dspi_edma.c ****         }
 1612              		.loc 2 522 0
 1613 064c 1B04     		lsls	r3, r3, #16
 1614 064e 1E43     		orrs	r6, r6, r3
 1615              	.LVL160:
 1616 0650 A660     		str	r6, [r4, #8]
 1617 0652 1EE6     		b	.L58
 1618              	.L71:
 703:../drivers/fsl_dspi_edma.c ****             transferConfigB.srcOffset = 0;
 1619              		.loc 2 703 0
 1620 0654 04F12802 		add	r2, r4, #40
 1621 0658 0892     		str	r2, [sp, #32]
 1622 065a 59E6     		b	.L134
 1623              	.LVL161:
 1624              	.L77:
 740:../drivers/fsl_dspi_edma.c ****             }
 1625              		.loc 2 740 0
 1626 065c 0133     		adds	r3, r3, #1
 1627 065e 0D93     		str	r3, [sp, #52]
 1628              	.LVL162:
 1629              	.L70:
 759:../drivers/fsl_dspi_edma.c ****                                handle->edmaTxDataToIntermediaryHandle->channel, &transferConfigB, N
 1630              		.loc 2 759 0
 1631 0660 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1632 0662 8068     		ldr	r0, [r0, #8]
 1633 0664 0023     		movs	r3, #0
 1634 0666 08AA     		add	r2, sp, #32
 1635 0668 FFF7FEFF 		bl	EDMA_SetTransferConfig
 1636              	.LVL163:
 1637 066c 84E6     		b	.L96
 1638              	.LVL164:
 1639              	.L83:
 814:../drivers/fsl_dspi_edma.c **** 
 1640              		.loc 2 814 0
 1641 066e 0122     		movs	r2, #1
 1642              	.LVL165:
 1643 0670 1392     		str	r2, [sp, #76]
 1644 0672 D6E6     		b	.L136
 1645              	.LVL166:
 1646              	.L82:
 825:../drivers/fsl_dspi_edma.c ****                                handle->edmaIntermediaryToTxRegHandle->channel, &transferConfigC, NU
 1647              		.loc 2 825 0
 1648 0674 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1649 0676 8068     		ldr	r0, [r0, #8]
 1650 0678 0023     		movs	r3, #0
 1651              	.LVL167:
 1652 067a 0EAA     		add	r2, sp, #56
 1653 067c FFF7FEFF 		bl	EDMA_SetTransferConfig
 1654              	.LVL168:
 1655 0680 E1E6     		b	.L87
 1656              	.LVL169:
 1657              	.L107:
 846:../drivers/fsl_dspi_edma.c ****     {
 1658              		.loc 2 846 0
 1659 0682 1F46     		mov	r7, r3
 1660 0684 0A46     		mov	r2, r1
 1661 0686 FCE6     		b	.L89
 1662              	.LVL170:
 1663              	.L109:
 1664 0688 0A46     		mov	r2, r1
 1665 068a 1F46     		mov	r7, r3
 1666 068c FEE6     		b	.L90
 1667              	.LVL171:
 1668              	.L91:
 879:../drivers/fsl_dspi_edma.c ****                                         handle->edmaIntermediaryToTxRegHandle->channel, &preemption
 1669              		.loc 2 879 0
 1670 068e DCF80800 		ldr	r0, [ip, #8]
 1671 0692 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1672              	.LVL172:
 883:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1673              		.loc 2 883 0
 1674 0696 A36B     		ldr	r3, [r4, #56]
 882:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToIntermediaryHandle->base,
 1675              		.loc 2 882 0
 1676 0698 8DF80660 		strb	r6, [sp, #6]
 883:../drivers/fsl_dspi_edma.c ****                                         handle->edmaTxDataToIntermediaryHandle->channel, &preemptio
 1677              		.loc 2 883 0
 1678 069c 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1679 069e 9868     		ldr	r0, [r3, #8]
 1680 06a0 01AA     		add	r2, sp, #4
 1681 06a2 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1682              	.LVL173:
 887:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1683              		.loc 2 887 0
 1684 06a6 636B     		ldr	r3, [r4, #52]
 886:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 1685              		.loc 2 886 0
 1686 06a8 8DF80670 		strb	r7, [sp, #6]
 887:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 1687              		.loc 2 887 0
 1688 06ac 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1689 06ae 9868     		ldr	r0, [r3, #8]
 1690 06b0 01AA     		add	r2, sp, #4
 1691 06b2 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 1692              	.LVL174:
 896:../drivers/fsl_dspi_edma.c ****         {
 1693              		.loc 2 896 0
 1694 06b6 A369     		ldr	r3, [r4, #24]
 1695 06b8 012B     		cmp	r3, #1
 1696 06ba 07D9     		bls	.L94
 898:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel, kEDMA_MajorLink,
 1697              		.loc 2 898 0
 1698 06bc E06B     		ldr	r0, [r4, #60]
 900:../drivers/fsl_dspi_edma.c ****         }
 1699              		.loc 2 900 0
 1700 06be A36B     		ldr	r3, [r4, #56]
 898:../drivers/fsl_dspi_edma.c ****                                 handle->edmaIntermediaryToTxRegHandle->channel, kEDMA_MajorLink,
 1701              		.loc 2 898 0
 1702 06c0 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 1703 06c2 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1704 06c4 8068     		ldr	r0, [r0, #8]
 1705 06c6 0222     		movs	r2, #2
 1706 06c8 FFF7FEFF 		bl	EDMA_SetChannelLink
 1707              	.LVL175:
 1708              	.L94:
 1709              	.LBB209:
 1710              	.LBB210:
 645:../drivers/fsl_dspi.h **** }
 1711              		.loc 3 645 0
 1712 06cc 0A4A     		ldr	r2, .L146+4
 1713              	.LVL176:
 1714 06ce 136B     		ldr	r3, [r2, #48]
 1715 06d0 43F04073 		orr	r3, r3, #50331648
 1716 06d4 43F44033 		orr	r3, r3, #196608
 1717 06d8 1363     		str	r3, [r2, #48]
 1718              	.LVL177:
 1719              	.L95:
 1720              	.LBE210:
 1721              	.LBE209:
 1722              	.LBB211:
 1723              	.LBB212:
 742:../drivers/fsl_dspi.h **** }
 1724              		.loc 3 742 0
 1725 06da 2B68     		ldr	r3, [r5]
 1726 06dc 23F00103 		bic	r3, r3, #1
 1727 06e0 2B60     		str	r3, [r5]
 1728              	.LVL178:
 1729              	.LBE212:
 1730              	.LBE211:
 922:../drivers/fsl_dspi_edma.c **** }
 1731              		.loc 2 922 0
 1732 06e2 0020     		movs	r0, #0
 1733              	.LVL179:
 1734 06e4 04E5     		b	.L11
 1735              	.LVL180:
 1736              	.L100:
 1737              	.LBE214:
 1738              	.LBE217:
 153:../drivers/fsl_dspi_edma.c ****     }
 1739              		.loc 2 153 0
 1740 06e6 4FF41670 		mov	r0, #600
 1741              	.LVL181:
 1742 06ea 01E5     		b	.L11
 1743              	.LVL182:
 1744              	.L88:
 1745              	.LBB218:
 1746              	.LBB215:
 846:../drivers/fsl_dspi_edma.c ****     {
 1747              		.loc 2 846 0
 1748 06ec 8E42     		cmp	r6, r1
 1749 06ee CBD8     		bhi	.L109
 1750 06f0 1846     		mov	r0, r3
 1751 06f2 C3E6     		b	.L97
 1752              	.L147:
 1753              		.align	2
 1754              	.L146:
 1755 06f4 0000FFFF 		.word	-65536
 1756 06f8 00C00240 		.word	1073922048
 1757              	.LBE215:
 1758              	.LBE218:
 1759              		.cfi_endproc
 1760              	.LFE178:
 1762              		.section	.text.DSPI_MasterHalfDuplexTransferEDMA,"ax",%progbits
 1763              		.align	1
 1764              		.global	DSPI_MasterHalfDuplexTransferEDMA
 1765              		.syntax unified
 1766              		.thumb
 1767              		.thumb_func
 1768              		.fpu fpv4-sp-d16
 1770              	DSPI_MasterHalfDuplexTransferEDMA:
 1771              	.LFB179:
 928:../drivers/fsl_dspi_edma.c ****     assert(xfer);
 1772              		.loc 2 928 0
 1773              		.cfi_startproc
 1774              		@ args = 0, pretend = 0, frame = 16
 1775              		@ frame_needed = 0, uses_anonymous_args = 0
 1776              	.LVL183:
 1777 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1778              		.cfi_def_cfa_offset 32
 1779              		.cfi_offset 4, -16
 1780              		.cfi_offset 5, -12
 1781              		.cfi_offset 6, -8
 1782              		.cfi_offset 14, -4
 928:../drivers/fsl_dspi_edma.c ****     assert(xfer);
 1783              		.loc 2 928 0
 1784 0002 1446     		mov	r4, r2
 1785 0004 0546     		mov	r5, r0
 1786 0006 0E46     		mov	r6, r1
 931:../drivers/fsl_dspi_edma.c ****     status_t status;
 1787              		.loc 2 931 0
 1788 0008 1022     		movs	r2, #16
 1789              	.LVL184:
 1790 000a 0021     		movs	r1, #0
 1791              	.LVL185:
 1792 000c 6846     		mov	r0, sp
 1793              	.LVL186:
 1794 000e FFF7FEFF 		bl	memset
 1795              	.LVL187:
 934:../drivers/fsl_dspi_edma.c ****     {
 1796              		.loc 2 934 0
 1797 0012 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 1798 0014 F3B1     		cbz	r3, .L149
 936:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 1799              		.loc 2 936 0
 1800 0016 2368     		ldr	r3, [r4]
 1801 0018 0093     		str	r3, [sp]
 938:../drivers/fsl_dspi_edma.c ****     }
 1802              		.loc 2 938 0
 1803 001a A368     		ldr	r3, [r4, #8]
 1804              	.L156:
 947:../drivers/fsl_dspi_edma.c ****     {
 1805              		.loc 2 947 0
 1806 001c 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 944:../drivers/fsl_dspi_edma.c ****     }
 1807              		.loc 2 944 0
 1808 001e 0293     		str	r3, [sp, #8]
 1809 0020 2369     		ldr	r3, [r4, #16]
 947:../drivers/fsl_dspi_edma.c ****     {
 1810              		.loc 2 947 0
 1811 0022 DAB1     		cbz	r2, .L151
 949:../drivers/fsl_dspi_edma.c ****     }
 1812              		.loc 2 949 0
 1813 0024 43F40013 		orr	r3, r3, #2097152
 1814              	.L157:
 956:../drivers/fsl_dspi_edma.c ****     if (status != kStatus_Success)
 1815              		.loc 2 956 0
 1816 0028 6946     		mov	r1, sp
 1817 002a 2846     		mov	r0, r5
 953:../drivers/fsl_dspi_edma.c ****     }
 1818              		.loc 2 953 0
 1819 002c 0393     		str	r3, [sp, #12]
 956:../drivers/fsl_dspi_edma.c ****     if (status != kStatus_Success)
 1820              		.loc 2 956 0
 1821 002e FFF7FEFF 		bl	DSPI_MasterTransferBlocking
 1822              	.LVL188:
 957:../drivers/fsl_dspi_edma.c ****     {
 1823              		.loc 2 957 0
 1824 0032 68B9     		cbnz	r0, .L148
 962:../drivers/fsl_dspi_edma.c ****     {
 1825              		.loc 2 962 0
 1826 0034 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 1827 0036 A3B1     		cbz	r3, .L154
 965:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 1828              		.loc 2 965 0
 1829 0038 6368     		ldr	r3, [r4, #4]
 1830 003a 0193     		str	r3, [sp, #4]
 966:../drivers/fsl_dspi_edma.c ****     }
 1831              		.loc 2 966 0
 1832 003c E368     		ldr	r3, [r4, #12]
 964:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = xfer->rxData;
 1833              		.loc 2 964 0
 1834 003e 0090     		str	r0, [sp]
 1835              	.L158:
 972:../drivers/fsl_dspi_edma.c ****     }
 1836              		.loc 2 972 0
 1837 0040 0293     		str	r3, [sp, #8]
 976:../drivers/fsl_dspi_edma.c **** 
 1838              		.loc 2 976 0
 1839 0042 6A46     		mov	r2, sp
 974:../drivers/fsl_dspi_edma.c **** 
 1840              		.loc 2 974 0
 1841 0044 2369     		ldr	r3, [r4, #16]
 1842 0046 0393     		str	r3, [sp, #12]
 976:../drivers/fsl_dspi_edma.c **** 
 1843              		.loc 2 976 0
 1844 0048 3146     		mov	r1, r6
 1845 004a 2846     		mov	r0, r5
 1846              	.LVL189:
 1847 004c FFF7FEFF 		bl	DSPI_MasterTransferEDMA
 1848              	.LVL190:
 1849              	.L148:
 979:../drivers/fsl_dspi_edma.c **** static void EDMA_DspiMasterCallback(edma_handle_t *edmaHandle,
 1850              		.loc 2 979 0
 1851 0050 04B0     		add	sp, sp, #16
 1852              		.cfi_remember_state
 1853              		.cfi_def_cfa_offset 16
 1854              		@ sp needed
 1855 0052 70BD     		pop	{r4, r5, r6, pc}
 1856              	.LVL191:
 1857              	.L149:
 1858              		.cfi_restore_state
 943:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->rxDataSize;
 1859              		.loc 2 943 0
 1860 0054 6368     		ldr	r3, [r4, #4]
 1861 0056 0193     		str	r3, [sp, #4]
 944:../drivers/fsl_dspi_edma.c ****     }
 1862              		.loc 2 944 0
 1863 0058 E368     		ldr	r3, [r4, #12]
 1864 005a DFE7     		b	.L156
 1865              	.L151:
 953:../drivers/fsl_dspi_edma.c ****     }
 1866              		.loc 2 953 0
 1867 005c 23F40013 		bic	r3, r3, #2097152
 1868 0060 E2E7     		b	.L157
 1869              	.LVL192:
 1870              	.L154:
 970:../drivers/fsl_dspi_edma.c ****         tempXfer.rxData = NULL;
 1871              		.loc 2 970 0
 1872 0062 2268     		ldr	r2, [r4]
 971:../drivers/fsl_dspi_edma.c ****         tempXfer.dataSize = xfer->txDataSize;
 1873              		.loc 2 971 0
 1874 0064 8DE80C00 		stm	sp, {r2, r3}
 972:../drivers/fsl_dspi_edma.c ****     }
 1875              		.loc 2 972 0
 1876 0068 A368     		ldr	r3, [r4, #8]
 1877 006a E9E7     		b	.L158
 1878              		.cfi_endproc
 1879              	.LFE179:
 1881              		.section	.text.DSPI_MasterTransferAbortEDMA,"ax",%progbits
 1882              		.align	1
 1883              		.global	DSPI_MasterTransferAbortEDMA
 1884              		.syntax unified
 1885              		.thumb
 1886              		.thumb_func
 1887              		.fpu fpv4-sp-d16
 1889              	DSPI_MasterTransferAbortEDMA:
 1890              	.LFB181:
1004:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1891              		.loc 2 1004 0
 1892              		.cfi_startproc
 1893              		@ args = 0, pretend = 0, frame = 0
 1894              		@ frame_needed = 0, uses_anonymous_args = 0
 1895              	.LVL193:
 1896              	.LBB219:
 1897              	.LBB220:
 753:../drivers/fsl_dspi.h **** }
 1898              		.loc 3 753 0
 1899 0000 0368     		ldr	r3, [r0]
 1900 0002 43F00103 		orr	r3, r3, #1
 1901              	.LBE220:
 1902              	.LBE219:
1004:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1903              		.loc 2 1004 0
 1904 0006 10B5     		push	{r4, lr}
 1905              		.cfi_def_cfa_offset 8
 1906              		.cfi_offset 4, -8
 1907              		.cfi_offset 14, -4
 1908              	.LBB222:
 1909              	.LBB221:
 753:../drivers/fsl_dspi.h **** }
 1910              		.loc 3 753 0
 1911 0008 0360     		str	r3, [r0]
 1912              	.LVL194:
 1913              	.LBE221:
 1914              	.LBE222:
 1915              	.LBB223:
 1916              	.LBB224:
 661:../drivers/fsl_dspi.h **** }
 1917              		.loc 3 661 0
 1918 000a 036B     		ldr	r3, [r0, #48]
 1919 000c 23F04073 		bic	r3, r3, #50331648
 1920              	.LBE224:
 1921              	.LBE223:
1004:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1922              		.loc 2 1004 0
 1923 0010 0C46     		mov	r4, r1
 1924              	.LBB226:
 1925              	.LBB225:
 661:../drivers/fsl_dspi.h **** }
 1926              		.loc 3 661 0
 1927 0012 23F44033 		bic	r3, r3, #196608
 1928 0016 0363     		str	r3, [r0, #48]
 1929              	.LVL195:
 1930              	.LBE225:
 1931              	.LBE226:
1011:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaTxDataToIntermediaryHandle);
 1932              		.loc 2 1011 0
 1933 0018 486B     		ldr	r0, [r1, #52]
 1934              	.LVL196:
 1935 001a FFF7FEFF 		bl	EDMA_AbortTransfer
 1936              	.LVL197:
1012:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaIntermediaryToTxRegHandle);
 1937              		.loc 2 1012 0
 1938 001e A06B     		ldr	r0, [r4, #56]
 1939 0020 FFF7FEFF 		bl	EDMA_AbortTransfer
 1940              	.LVL198:
1013:../drivers/fsl_dspi_edma.c **** 
 1941              		.loc 2 1013 0
 1942 0024 E06B     		ldr	r0, [r4, #60]
 1943 0026 FFF7FEFF 		bl	EDMA_AbortTransfer
 1944              	.LVL199:
1015:../drivers/fsl_dspi_edma.c **** }
 1945              		.loc 2 1015 0
 1946 002a 0023     		movs	r3, #0
 1947 002c E373     		strb	r3, [r4, #15]
 1948 002e 10BD     		pop	{r4, pc}
 1949              		.cfi_endproc
 1950              	.LFE181:
 1952              		.section	.text.DSPI_MasterTransferGetCountEDMA,"ax",%progbits
 1953              		.align	1
 1954              		.global	DSPI_MasterTransferGetCountEDMA
 1955              		.syntax unified
 1956              		.thumb
 1957              		.thumb_func
 1958              		.fpu fpv4-sp-d16
 1960              	DSPI_MasterTransferGetCountEDMA:
 1961              	.LFB182:
1019:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1962              		.loc 2 1019 0
 1963              		.cfi_startproc
 1964              		@ args = 0, pretend = 0, frame = 0
 1965              		@ frame_needed = 0, uses_anonymous_args = 0
 1966              	.LVL200:
 1967 0000 70B5     		push	{r4, r5, r6, lr}
 1968              		.cfi_def_cfa_offset 16
 1969              		.cfi_offset 4, -16
 1970              		.cfi_offset 5, -12
 1971              		.cfi_offset 6, -8
 1972              		.cfi_offset 14, -4
1019:../drivers/fsl_dspi_edma.c ****     assert(handle);
 1973              		.loc 2 1019 0
 1974 0002 0C46     		mov	r4, r1
1022:../drivers/fsl_dspi_edma.c ****     {
 1975              		.loc 2 1022 0
 1976 0004 1546     		mov	r5, r2
 1977 0006 92B1     		cbz	r2, .L163
1028:../drivers/fsl_dspi_edma.c ****     {
 1978              		.loc 2 1028 0
 1979 0008 CB7B     		ldrb	r3, [r1, #15]	@ zero_extendqisi2
 1980 000a 012B     		cmp	r3, #1
 1981 000c 03D0     		beq	.L162
1030:../drivers/fsl_dspi_edma.c ****         return kStatus_NoTransferInProgress;
 1982              		.loc 2 1030 0
 1983 000e 0023     		movs	r3, #0
 1984 0010 1360     		str	r3, [r2]
1031:../drivers/fsl_dspi_edma.c ****     }
 1985              		.loc 2 1031 0
 1986 0012 0620     		movs	r0, #6
 1987              	.LVL201:
 1988 0014 70BD     		pop	{r4, r5, r6, pc}
 1989              	.LVL202:
 1990              	.L162:
1036:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
 1991              		.loc 2 1036 0
 1992 0016 4B6B     		ldr	r3, [r1, #52]
 1993 0018 8E7B     		ldrb	r6, [r1, #14]	@ zero_extendqisi2
 1994 001a 9868     		ldr	r0, [r3, #8]
 1995              	.LVL203:
 1996 001c 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 1997              	.LVL204:
 1998 001e FFF7FEFF 		bl	EDMA_GetRemainingMajorLoopCount
 1999              	.LVL205:
1039:../drivers/fsl_dspi_edma.c **** 
 2000              		.loc 2 1039 0
 2001 0022 236A     		ldr	r3, [r4, #32]
 2002 0024 00FB1630 		mls	r0, r0, r6, r3
 2003              	.LVL206:
 2004 0028 2860     		str	r0, [r5]
1041:../drivers/fsl_dspi_edma.c **** }
 2005              		.loc 2 1041 0
 2006 002a 0020     		movs	r0, #0
 2007 002c 70BD     		pop	{r4, r5, r6, pc}
 2008              	.LVL207:
 2009              	.L163:
1024:../drivers/fsl_dspi_edma.c ****     }
 2010              		.loc 2 1024 0
 2011 002e 0420     		movs	r0, #4
 2012              	.LVL208:
1042:../drivers/fsl_dspi_edma.c **** 
 2013              		.loc 2 1042 0
 2014 0030 70BD     		pop	{r4, r5, r6, pc}
 2015              		.cfi_endproc
 2016              	.LFE182:
 2018              		.section	.text.DSPI_SlaveTransferCreateHandleEDMA,"ax",%progbits
 2019              		.align	1
 2020              		.global	DSPI_SlaveTransferCreateHandleEDMA
 2021              		.syntax unified
 2022              		.thumb
 2023              		.thumb_func
 2024              		.fpu fpv4-sp-d16
 2026              	DSPI_SlaveTransferCreateHandleEDMA:
 2027              	.LFB183:
1050:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2028              		.loc 2 1050 0
 2029              		.cfi_startproc
 2030              		@ args = 8, pretend = 0, frame = 0
 2031              		@ frame_needed = 0, uses_anonymous_args = 0
 2032              	.LVL209:
 2033 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2034              		.cfi_def_cfa_offset 24
 2035              		.cfi_offset 3, -24
 2036              		.cfi_offset 4, -20
 2037              		.cfi_offset 5, -16
 2038              		.cfi_offset 6, -12
 2039              		.cfi_offset 7, -8
 2040              		.cfi_offset 14, -4
1050:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2041              		.loc 2 1050 0
 2042 0002 0C46     		mov	r4, r1
 2043 0004 0546     		mov	r5, r0
 2044 0006 1746     		mov	r7, r2
1056:../drivers/fsl_dspi_edma.c **** 
 2045              		.loc 2 1056 0
 2046 0008 0021     		movs	r1, #0
 2047              	.LVL210:
 2048 000a 3822     		movs	r2, #56
 2049              	.LVL211:
 2050 000c 2046     		mov	r0, r4
 2051              	.LVL212:
1050:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2052              		.loc 2 1050 0
 2053 000e 1E46     		mov	r6, r3
1056:../drivers/fsl_dspi_edma.c **** 
 2054              		.loc 2 1056 0
 2055 0010 FFF7FEFF 		bl	memset
 2056              	.LVL213:
1058:../drivers/fsl_dspi_edma.c **** 
 2057              		.loc 2 1058 0
 2058 0014 2846     		mov	r0, r5
 2059 0016 FFF7FEFF 		bl	DSPI_GetInstance
 2060              	.LVL214:
1060:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].handle = handle;
 2061              		.loc 2 1060 0
 2062 001a 064A     		ldr	r2, .L165
1066:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToTxRegHandle = edmaTxDataToTxRegHandle;
 2063              		.loc 2 1066 0
 2064 001c 069B     		ldr	r3, [sp, #24]
1060:../drivers/fsl_dspi_edma.c ****     s_dspiSlaveEdmaPrivateHandle[instance].handle = handle;
 2065              		.loc 2 1060 0
 2066 001e 42F83050 		str	r5, [r2, r0, lsl #3]
1061:../drivers/fsl_dspi_edma.c **** 
 2067              		.loc 2 1061 0
 2068 0022 02EBC002 		add	r2, r2, r0, lsl #3
1066:../drivers/fsl_dspi_edma.c ****     handle->edmaTxDataToTxRegHandle = edmaTxDataToTxRegHandle;
 2069              		.loc 2 1066 0
 2070 0026 2363     		str	r3, [r4, #48]
1067:../drivers/fsl_dspi_edma.c **** }
 2071              		.loc 2 1067 0
 2072 0028 079B     		ldr	r3, [sp, #28]
1061:../drivers/fsl_dspi_edma.c **** 
 2073              		.loc 2 1061 0
 2074 002a 5460     		str	r4, [r2, #4]
1063:../drivers/fsl_dspi_edma.c ****     handle->userData = userData;
 2075              		.loc 2 1063 0
 2076 002c A762     		str	r7, [r4, #40]
1064:../drivers/fsl_dspi_edma.c **** 
 2077              		.loc 2 1064 0
 2078 002e E662     		str	r6, [r4, #44]
1067:../drivers/fsl_dspi_edma.c **** }
 2079              		.loc 2 1067 0
 2080 0030 6363     		str	r3, [r4, #52]
 2081 0032 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2082              	.LVL215:
 2083              	.L166:
 2084              		.align	2
 2085              	.L165:
 2086 0034 00000000 		.word	.LANCHOR1
 2087              		.cfi_endproc
 2088              	.LFE183:
 2090              		.section	.text.DSPI_SlaveTransferEDMA,"ax",%progbits
 2091              		.align	1
 2092              		.global	DSPI_SlaveTransferEDMA
 2093              		.syntax unified
 2094              		.thumb
 2095              		.thumb_func
 2096              		.fpu fpv4-sp-d16
 2098              	DSPI_SlaveTransferEDMA:
 2099              	.LFB184:
1071:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2100              		.loc 2 1071 0
 2101              		.cfi_startproc
 2102              		@ args = 0, pretend = 0, frame = 56
 2103              		@ frame_needed = 0, uses_anonymous_args = 0
 2104              	.LVL216:
 2105 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2106              		.cfi_def_cfa_offset 24
 2107              		.cfi_offset 4, -24
 2108              		.cfi_offset 5, -20
 2109              		.cfi_offset 6, -16
 2110              		.cfi_offset 7, -12
 2111              		.cfi_offset 8, -8
 2112              		.cfi_offset 14, -4
1076:../drivers/fsl_dspi_edma.c ****     {
 2113              		.loc 2 1076 0
 2114 0004 9368     		ldr	r3, [r2, #8]
1071:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2115              		.loc 2 1071 0
 2116 0006 8EB0     		sub	sp, sp, #56
 2117              		.cfi_def_cfa_offset 80
1071:../drivers/fsl_dspi_edma.c ****     assert(handle);
 2118              		.loc 2 1071 0
 2119 0008 0546     		mov	r5, r0
 2120 000a 0C46     		mov	r4, r1
 2121 000c 1646     		mov	r6, r2
1076:../drivers/fsl_dspi_edma.c ****     {
 2122              		.loc 2 1076 0
 2123 000e 002B     		cmp	r3, #0
 2124 0010 00F01081 		beq	.L201
1082:../drivers/fsl_dspi_edma.c ****     {
 2125              		.loc 2 1082 0
 2126 0014 1368     		ldr	r3, [r2]
 2127 0016 1BB9     		cbnz	r3, .L169
1082:../drivers/fsl_dspi_edma.c ****     {
 2128              		.loc 2 1082 0 is_stmt 0 discriminator 1
 2129 0018 5368     		ldr	r3, [r2, #4]
 2130 001a 002B     		cmp	r3, #0
 2131 001c 00F00A81 		beq	.L201
 2132              	.L169:
1088:../drivers/fsl_dspi_edma.c ****     {
 2133              		.loc 2 1088 0 is_stmt 1
 2134 0020 94F82530 		ldrb	r3, [r4, #37]	@ zero_extendqisi2
 2135 0024 012B     		cmp	r3, #1
 2136 0026 00F08081 		beq	.L202
1093:../drivers/fsl_dspi_edma.c **** 
 2137              		.loc 2 1093 0
 2138 002a 0123     		movs	r3, #1
 2139 002c 84F82530 		strb	r3, [r4, #37]
1095:../drivers/fsl_dspi_edma.c ****     uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
 2140              		.loc 2 1095 0
 2141 0030 2846     		mov	r0, r5
 2142              	.LVL217:
 2143 0032 FFF7FEFF 		bl	DSPI_GetInstance
 2144              	.LVL218:
1096:../drivers/fsl_dspi_edma.c ****     handle->bitsPerFrame =
 2145              		.loc 2 1096 0
 2146 0036 F368     		ldr	r3, [r6, #12]
1110:../drivers/fsl_dspi_edma.c ****     }
 2147              		.loc 2 1110 0
 2148 0038 A74F     		ldr	r7, .L230
1098:../drivers/fsl_dspi_edma.c **** 
 2149              		.loc 2 1098 0
 2150 003a 03F00703 		and	r3, r3, #7
 2151 003e 0233     		adds	r3, r3, #2
 2152 0040 05EB8303 		add	r3, r5, r3, lsl #2
1110:../drivers/fsl_dspi_edma.c ****     }
 2153              		.loc 2 1110 0
 2154 0044 40F2FF12 		movw	r2, #511
1098:../drivers/fsl_dspi_edma.c **** 
 2155              		.loc 2 1098 0
 2156 0048 5B68     		ldr	r3, [r3, #4]
 2157 004a DB0E     		lsrs	r3, r3, #27
 2158 004c 0133     		adds	r3, r3, #1
1110:../drivers/fsl_dspi_edma.c ****     }
 2159              		.loc 2 1110 0
 2160 004e 47F6FF71 		movw	r1, #32767
 2161 0052 BD42     		cmp	r5, r7
 2162 0054 18BF     		it	ne
 2163 0056 1146     		movne	r1, r2
1113:../drivers/fsl_dspi_edma.c ****     {
 2164              		.loc 2 1113 0
 2165 0058 082B     		cmp	r3, #8
1097:../drivers/fsl_dspi_edma.c ****         (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) +
 2166              		.loc 2 1097 0
 2167 005a 2360     		str	r3, [r4]
 2168              	.LVL219:
1115:../drivers/fsl_dspi_edma.c ****         {
 2169              		.loc 2 1115 0
 2170 005c B368     		ldr	r3, [r6, #8]
1113:../drivers/fsl_dspi_edma.c ****     {
 2171              		.loc 2 1113 0
 2172 005e 0BD9     		bls	.L171
1115:../drivers/fsl_dspi_edma.c ****         {
 2173              		.loc 2 1115 0
 2174 0060 B3EB410F 		cmp	r3, r1, lsl #1
 2175 0064 40F2DF80 		bls	.L172
 2176              	.L228:
1125:../drivers/fsl_dspi_edma.c ****             return kStatus_DSPI_OutOfRange;
 2177              		.loc 2 1125 0
 2178 0068 0023     		movs	r3, #0
 2179 006a 84F82530 		strb	r3, [r4, #37]
 2180              	.LVL220:
1126:../drivers/fsl_dspi_edma.c ****         }
 2181              		.loc 2 1126 0
 2182 006e 40F25B20 		movw	r0, #603
 2183              	.LVL221:
 2184              	.L167:
1388:../drivers/fsl_dspi_edma.c **** 
 2185              		.loc 2 1388 0
 2186 0072 0EB0     		add	sp, sp, #56
 2187              		.cfi_remember_state
 2188              		.cfi_def_cfa_offset 24
 2189              		@ sp needed
 2190 0074 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2191              	.LVL222:
 2192              	.L171:
 2193              		.cfi_restore_state
1123:../drivers/fsl_dspi_edma.c ****         {
 2194              		.loc 2 1123 0
 2195 0078 9942     		cmp	r1, r3
 2196 007a F5D3     		bcc	.L228
 2197              	.L173:
1137:../drivers/fsl_dspi_edma.c **** 
 2198              		.loc 2 1137 0
 2199 007c 974A     		ldr	r2, .L230+4
 2200 007e 9849     		ldr	r1, .L230+8
 2201              	.LVL223:
 2202 0080 02EBC002 		add	r2, r2, r0, lsl #3
 2203 0084 206B     		ldr	r0, [r4, #48]
 2204              	.LVL224:
 2205 0086 FFF7FEFF 		bl	EDMA_SetCallback
 2206              	.LVL225:
1140:../drivers/fsl_dspi_edma.c ****     handle->rxData = transfer->rxData;
 2207              		.loc 2 1140 0
 2208 008a 3368     		ldr	r3, [r6]
 2209 008c 6360     		str	r3, [r4, #4]
1141:../drivers/fsl_dspi_edma.c ****     handle->remainingSendByteCount = transfer->dataSize;
 2210              		.loc 2 1141 0
 2211 008e 7368     		ldr	r3, [r6, #4]
 2212 0090 A360     		str	r3, [r4, #8]
1142:../drivers/fsl_dspi_edma.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 2213              		.loc 2 1142 0
 2214 0092 B368     		ldr	r3, [r6, #8]
 2215 0094 E360     		str	r3, [r4, #12]
1143:../drivers/fsl_dspi_edma.c ****     handle->totalByteCount = transfer->dataSize;
 2216              		.loc 2 1143 0
 2217 0096 B368     		ldr	r3, [r6, #8]
 2218 0098 2361     		str	r3, [r4, #16]
1144:../drivers/fsl_dspi_edma.c **** 
 2219              		.loc 2 1144 0
 2220 009a B368     		ldr	r3, [r6, #8]
 2221 009c 6361     		str	r3, [r4, #20]
 2222              	.LVL226:
1147:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 2223              		.loc 2 1147 0
 2224 009e 2846     		mov	r0, r5
 2225 00a0 FFF7FEFF 		bl	DSPI_GetInstance
 2226              	.LVL227:
 2227 00a4 8F4B     		ldr	r3, .L230+12
 2228 00a6 1E5C     		ldrb	r6, [r3, r0]	@ zero_extendqisi2
 2229              	.LVL228:
 2230              	.LBB227:
 2231              	.LBB228:
 753:../drivers/fsl_dspi.h **** }
 2232              		.loc 3 753 0
 2233 00a8 2B68     		ldr	r3, [r5]
 2234 00aa 43F00103 		orr	r3, r3, #1
 2235 00ae 2B60     		str	r3, [r5]
 2236              	.LBE228:
 2237              	.LBE227:
 2238              	.LBB229:
 2239              	.LBB230:
 782:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 2240              		.loc 3 782 0
 2241 00b0 2B68     		ldr	r3, [r5]
 2242 00b2 43F44063 		orr	r3, r3, #3072
 2243 00b6 2B60     		str	r3, [r5]
 2244              	.LBE230:
 2245              	.LBE229:
 2246              	.LBB231:
 2247              	.LBB232:
 580:../drivers/fsl_dspi.h **** }
 2248              		.loc 3 580 0
 2249 00b8 8B4B     		ldr	r3, .L230+16
 2250 00ba EB62     		str	r3, [r5, #44]
 2251              	.LBE232:
 2252              	.LBE231:
 2253              	.LBB233:
 2254              	.LBB234:
 661:../drivers/fsl_dspi.h **** }
 2255              		.loc 3 661 0
 2256 00bc 2B6B     		ldr	r3, [r5, #48]
 2257 00be 23F04073 		bic	r3, r3, #50331648
 2258 00c2 23F44033 		bic	r3, r3, #196608
 2259 00c6 2B63     		str	r3, [r5, #48]
 2260              	.LBE234:
 2261              	.LBE233:
 2262              	.LBB235:
 2263              	.LBB236:
 742:../drivers/fsl_dspi.h **** }
 2264              		.loc 3 742 0
 2265 00c8 2B68     		ldr	r3, [r5]
 2266 00ca 23F00103 		bic	r3, r3, #1
 2267 00ce 2B60     		str	r3, [r5]
 2268              	.LBE236:
 2269              	.LBE235:
1169:../drivers/fsl_dspi_edma.c ****     {
 2270              		.loc 2 1169 0
 2271 00d0 814B     		ldr	r3, .L230
 2272              	.LVL229:
 2273 00d2 9D42     		cmp	r5, r3
1147:../drivers/fsl_dspi_edma.c ****     uint8_t dataAlreadyFed = 0;
 2274              		.loc 2 1147 0
 2275 00d4 F6B2     		uxtb	r6, r6
 2276              	.LVL230:
1169:../drivers/fsl_dspi_edma.c ****     {
 2277              		.loc 2 1169 0
 2278 00d6 40F0AF80 		bne	.L174
 2279              	.LVL231:
 2280              	.L180:
1240:../drivers/fsl_dspi_edma.c ****     {
 2281              		.loc 2 1240 0
 2282 00da 2369     		ldr	r3, [r4, #16]
 2283 00dc 002B     		cmp	r3, #0
 2284 00de 39D0     		beq	.L176
1242:../drivers/fsl_dspi_edma.c **** 
 2285              		.loc 2 1242 0
 2286 00e0 236B     		ldr	r3, [r4, #48]
 2287 00e2 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2288 00e4 9868     		ldr	r0, [r3, #8]
 2289 00e6 FFF7FEFF 		bl	EDMA_ResetChannel
 2290              	.LVL232:
 2291              	.LBB237:
 2292              	.LBB238:
 700:../drivers/fsl_dspi.h **** }
 2293              		.loc 3 700 0
 2294 00ea 05F13803 		add	r3, r5, #56
 2295              	.LBE238:
 2296              	.LBE237:
1244:../drivers/fsl_dspi_edma.c ****         transferConfigA.srcOffset = 0;
 2297              		.loc 2 1244 0
 2298 00ee 0293     		str	r3, [sp, #8]
1245:../drivers/fsl_dspi_edma.c **** 
 2299              		.loc 2 1245 0
 2300 00f0 0023     		movs	r3, #0
 2301 00f2 ADF81230 		strh	r3, [sp, #18]	@ movhi
1247:../drivers/fsl_dspi_edma.c ****         {
 2302              		.loc 2 1247 0
 2303 00f6 A368     		ldr	r3, [r4, #8]
 2304 00f8 002B     		cmp	r3, #0
 2305 00fa 00F0E880 		beq	.L186
1249:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 1;
 2306              		.loc 2 1249 0
 2307 00fe A368     		ldr	r3, [r4, #8]
 2308 0100 0393     		str	r3, [sp, #12]
1250:../drivers/fsl_dspi_edma.c ****         }
 2309              		.loc 2 1250 0
 2310 0102 0123     		movs	r3, #1
 2311              	.L224:
1255:../drivers/fsl_dspi_edma.c ****         }
 2312              		.loc 2 1255 0
 2313 0104 ADF81430 		strh	r3, [sp, #20]	@ movhi
1260:../drivers/fsl_dspi_edma.c ****         {
 2314              		.loc 2 1260 0
 2315 0108 2368     		ldr	r3, [r4]
1276:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
 2316              		.loc 2 1276 0
 2317 010a 206B     		ldr	r0, [r4, #48]
1260:../drivers/fsl_dspi_edma.c ****         {
 2318              		.loc 2 1260 0
 2319 010c 082B     		cmp	r3, #8
 2320 010e 4FF00103 		mov	r3, #1
1268:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 2;
 2321              		.loc 2 1268 0
 2322 0112 81BF     		itttt	hi
 2323 0114 8DF81030 		strbhi	r3, [sp, #16]
1269:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount / 2;
 2324              		.loc 2 1269 0
 2325 0118 0223     		movhi	r3, #2
 2326 011a 0693     		strhi	r3, [sp, #24]
1270:../drivers/fsl_dspi_edma.c ****         }
 2327              		.loc 2 1270 0
 2328 011c 2369     		ldrhi	r3, [r4, #16]
1263:../drivers/fsl_dspi_edma.c ****             transferConfigA.majorLoopCounts = handle->remainingReceiveByteCount;
 2329              		.loc 2 1263 0
 2330 011e 96BF     		itet	ls
 2331 0120 0693     		strls	r3, [sp, #24]
1270:../drivers/fsl_dspi_edma.c ****         }
 2332              		.loc 2 1270 0
 2333 0122 5B08     		lsrhi	r3, r3, #1
1264:../drivers/fsl_dspi_edma.c ****         }
 2334              		.loc 2 1264 0
 2335 0124 2369     		ldrls	r3, [r4, #16]
1270:../drivers/fsl_dspi_edma.c ****         }
 2336              		.loc 2 1270 0
 2337 0126 0793     		str	r3, [sp, #28]
1274:../drivers/fsl_dspi_edma.c **** 
 2338              		.loc 2 1274 0
 2339 0128 069B     		ldr	r3, [sp, #24]
 2340 012a 84F82430 		strb	r3, [r4, #36]
1258:../drivers/fsl_dspi_edma.c **** 
 2341              		.loc 2 1258 0
 2342 012e 4FF00002 		mov	r2, #0
1276:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
 2343              		.loc 2 1276 0
 2344 0132 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
1258:../drivers/fsl_dspi_edma.c **** 
 2345              		.loc 2 1258 0
 2346 0134 8DF81120 		strb	r2, [sp, #17]
1262:../drivers/fsl_dspi_edma.c ****             transferConfigA.minorLoopBytes = 1;
 2347              		.loc 2 1262 0
 2348 0138 98BF     		it	ls
 2349 013a 8DF81020 		strbls	r2, [sp, #16]
1276:../drivers/fsl_dspi_edma.c ****                                &transferConfigA, NULL);
 2350              		.loc 2 1276 0
 2351 013e 0023     		movs	r3, #0
 2352 0140 02AA     		add	r2, sp, #8
 2353 0142 8068     		ldr	r0, [r0, #8]
 2354 0144 FFF7FEFF 		bl	EDMA_SetTransferConfig
 2355              	.LVL233:
1278:../drivers/fsl_dspi_edma.c ****                                      kEDMA_MajorInterruptEnable);
 2356              		.loc 2 1278 0
 2357 0148 236B     		ldr	r3, [r4, #48]
 2358 014a 0222     		movs	r2, #2
 2359 014c 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2360 014e 9868     		ldr	r0, [r3, #8]
 2361 0150 FFF7FEFF 		bl	EDMA_EnableChannelInterrupts
 2362              	.LVL234:
 2363              	.L176:
1282:../drivers/fsl_dspi_edma.c ****     {
 2364              		.loc 2 1282 0
 2365 0154 E368     		ldr	r3, [r4, #12]
 2366 0156 002B     		cmp	r3, #0
 2367 0158 33D0     		beq	.L190
1285:../drivers/fsl_dspi_edma.c **** 
 2368              		.loc 2 1285 0
 2369 015a 636B     		ldr	r3, [r4, #52]
 2370 015c 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2371 015e 9868     		ldr	r0, [r3, #8]
 2372 0160 FFF7FEFF 		bl	EDMA_ResetChannel
 2373              	.LVL235:
 2374              	.LBB239:
 2375              	.LBB240:
 687:../drivers/fsl_dspi.h **** }
 2376              		.loc 3 687 0
 2377 0164 05F13403 		add	r3, r5, #52
 2378              	.LBE240:
 2379              	.LBE239:
1290:../drivers/fsl_dspi_edma.c ****         {
 2380              		.loc 2 1290 0
 2381 0168 6268     		ldr	r2, [r4, #4]
1287:../drivers/fsl_dspi_edma.c ****         transferConfigC.destOffset = 0;
 2382              		.loc 2 1287 0
 2383 016a 0993     		str	r3, [sp, #36]
1288:../drivers/fsl_dspi_edma.c **** 
 2384              		.loc 2 1288 0
 2385 016c 0023     		movs	r3, #0
 2386 016e ADF82C30 		strh	r3, [sp, #44]	@ movhi
 2387 0172 2368     		ldr	r3, [r4]
1290:../drivers/fsl_dspi_edma.c ****         {
 2388              		.loc 2 1290 0
 2389 0174 002A     		cmp	r2, #0
 2390 0176 00F0B980 		beq	.L191
1292:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 1;
 2391              		.loc 2 1292 0
 2392 017a 6268     		ldr	r2, [r4, #4]
 2393 017c 0892     		str	r2, [sp, #32]
1293:../drivers/fsl_dspi_edma.c ****         }
 2394              		.loc 2 1293 0
 2395 017e 0122     		movs	r2, #1
 2396 0180 ADF82A20 		strh	r2, [sp, #42]	@ movhi
 2397              	.LVL236:
 2398              	.L192:
1311:../drivers/fsl_dspi_edma.c ****         {
 2399              		.loc 2 1311 0
 2400 0184 082B     		cmp	r3, #8
 2401 0186 4FF00103 		mov	r3, #1
1319:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 2;
 2402              		.loc 2 1319 0
 2403 018a 81BF     		itttt	hi
 2404 018c 8DF82930 		strbhi	r3, [sp, #41]
1320:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount / 2;
 2405              		.loc 2 1320 0
 2406 0190 0223     		movhi	r3, #2
 2407 0192 0C93     		strhi	r3, [sp, #48]
1321:../drivers/fsl_dspi_edma.c ****         }
 2408              		.loc 2 1321 0
 2409 0194 E368     		ldrhi	r3, [r4, #12]
1314:../drivers/fsl_dspi_edma.c ****             transferConfigC.majorLoopCounts = handle->remainingSendByteCount;
 2410              		.loc 2 1314 0
 2411 0196 96BF     		itet	ls
 2412 0198 0C93     		strls	r3, [sp, #48]
1321:../drivers/fsl_dspi_edma.c ****         }
 2413              		.loc 2 1321 0
 2414 019a 5B08     		lsrhi	r3, r3, #1
1315:../drivers/fsl_dspi_edma.c ****         }
 2415              		.loc 2 1315 0
 2416 019c E368     		ldrls	r3, [r4, #12]
1324:../drivers/fsl_dspi_edma.c ****                                &transferConfigC, NULL);
 2417              		.loc 2 1324 0
 2418 019e 606B     		ldr	r0, [r4, #52]
1321:../drivers/fsl_dspi_edma.c ****         }
 2419              		.loc 2 1321 0
 2420 01a0 0D93     		str	r3, [sp, #52]
1309:../drivers/fsl_dspi_edma.c **** 
 2421              		.loc 2 1309 0
 2422 01a2 4FF00002 		mov	r2, #0
 2423 01a6 8DF82820 		strb	r2, [sp, #40]
1313:../drivers/fsl_dspi_edma.c ****             transferConfigC.minorLoopBytes = 1;
 2424              		.loc 2 1313 0
 2425 01aa 98BF     		it	ls
 2426 01ac 8DF82920 		strbls	r2, [sp, #41]
1324:../drivers/fsl_dspi_edma.c ****                                &transferConfigC, NULL);
 2427              		.loc 2 1324 0
 2428 01b0 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 2429 01b2 8068     		ldr	r0, [r0, #8]
 2430 01b4 0023     		movs	r3, #0
 2431 01b6 08AA     		add	r2, sp, #32
 2432 01b8 FFF7FEFF 		bl	EDMA_SetTransferConfig
 2433              	.LVL237:
1327:../drivers/fsl_dspi_edma.c ****     }
 2434              		.loc 2 1327 0
 2435 01bc 606B     		ldr	r0, [r4, #52]
 2436 01be FFF7FEFF 		bl	EDMA_StartTransfer
 2437              	.LVL238:
 2438              	.L190:
1330:../drivers/fsl_dspi_edma.c **** 
 2439              		.loc 2 1330 0
 2440 01c2 206B     		ldr	r0, [r4, #48]
 2441 01c4 FFF7FEFF 		bl	EDMA_StartTransfer
 2442              	.LVL239:
1333:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaTxDataToTxRegHandle->channel;
 2443              		.loc 2 1333 0
 2444 01c8 276B     		ldr	r7, [r4, #48]
1334:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 2445              		.loc 2 1334 0
 2446 01ca 606B     		ldr	r0, [r4, #52]
1333:../drivers/fsl_dspi_edma.c ****     uint8_t channelPriorityHigh = handle->edmaTxDataToTxRegHandle->channel;
 2447              		.loc 2 1333 0
 2448 01cc 397C     		ldrb	r1, [r7, #16]	@ zero_extendqisi2
 2449              	.LVL240:
1334:../drivers/fsl_dspi_edma.c ****     uint8_t t = 0;
 2450              		.loc 2 1334 0
 2451 01ce 037C     		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 2452              	.LVL241:
1337:../drivers/fsl_dspi_edma.c ****     {
 2453              		.loc 2 1337 0
 2454 01d0 9942     		cmp	r1, r3
 2455 01d2 8CBF     		ite	hi
 2456 01d4 1A46     		movhi	r2, r3
 2457 01d6 0A46     		movls	r2, r1
1347:../drivers/fsl_dspi_edma.c **** 
 2458              		.loc 2 1347 0
 2459 01d8 8DF80620 		strb	r2, [sp, #6]
1349:../drivers/fsl_dspi_edma.c ****     {
 2460              		.loc 2 1349 0
 2461 01dc 3E4A     		ldr	r2, .L230
 2462              	.LVL242:
1345:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 2463              		.loc 2 1345 0
 2464 01de 4FF00106 		mov	r6, #1
1337:../drivers/fsl_dspi_edma.c ****     {
 2465              		.loc 2 1337 0
 2466 01e2 8CBF     		ite	hi
 2467 01e4 8846     		movhi	r8, r1
 2468 01e6 9846     		movls	r8, r3
 2469              	.LVL243:
1349:../drivers/fsl_dspi_edma.c ****     {
 2470              		.loc 2 1349 0
 2471 01e8 9542     		cmp	r5, r2
1345:../drivers/fsl_dspi_edma.c ****     preemption_config_t.enablePreemptAbility = true;
 2472              		.loc 2 1345 0
 2473 01ea 8DF80460 		strb	r6, [sp, #4]
1346:../drivers/fsl_dspi_edma.c ****     preemption_config_t.channelPriority = channelPriorityLow;
 2474              		.loc 2 1346 0
 2475 01ee 8DF80560 		strb	r6, [sp, #5]
1351:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2476              		.loc 2 1351 0
 2477 01f2 01AA     		add	r2, sp, #4
 2478              	.LVL244:
1349:../drivers/fsl_dspi_edma.c ****     {
 2479              		.loc 2 1349 0
 2480 01f4 00F08580 		beq	.L197
1351:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2481              		.loc 2 1351 0
 2482 01f8 B868     		ldr	r0, [r7, #8]
 2483 01fa FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2484              	.LVL245:
1355:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2485              		.loc 2 1355 0
 2486 01fe 636B     		ldr	r3, [r4, #52]
1354:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaTxDataToTxRegHandle->base, handle->edmaTxDataTo
 2487              		.loc 2 1354 0
 2488 0200 8DF80680 		strb	r8, [sp, #6]
1355:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2489              		.loc 2 1355 0
 2490 0204 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2491 0206 9868     		ldr	r0, [r3, #8]
 2492 0208 01AA     		add	r2, sp, #4
 2493 020a FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2494              	.LVL246:
1375:../drivers/fsl_dspi_edma.c ****         {
 2495              		.loc 2 1375 0
 2496 020e E368     		ldr	r3, [r4, #12]
 2497 0210 3BB1     		cbz	r3, .L199
1377:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToTxRegHandle->channel);
 2498              		.loc 2 1377 0
 2499 0212 206B     		ldr	r0, [r4, #48]
1378:../drivers/fsl_dspi_edma.c ****         }
 2500              		.loc 2 1378 0
 2501 0214 636B     		ldr	r3, [r4, #52]
1377:../drivers/fsl_dspi_edma.c ****                                 kEDMA_MinorLink, handle->edmaTxDataToTxRegHandle->channel);
 2502              		.loc 2 1377 0
 2503 0216 017C     		ldrb	r1, [r0, #16]	@ zero_extendqisi2
 2504 0218 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 2505 021a 8068     		ldr	r0, [r0, #8]
 2506 021c 3246     		mov	r2, r6
 2507 021e FFF7FEFF 		bl	EDMA_SetChannelLink
 2508              	.LVL247:
 2509              	.L199:
 2510              	.LBB241:
 2511              	.LBB242:
 645:../drivers/fsl_dspi.h **** }
 2512              		.loc 3 645 0
 2513 0222 2B6B     		ldr	r3, [r5, #48]
 2514 0224 7CE0     		b	.L229
 2515              	.LVL248:
 2516              	.L172:
 2517              	.LBE242:
 2518              	.LBE241:
1131:../drivers/fsl_dspi_edma.c ****     {
 2519              		.loc 2 1131 0 discriminator 1
 2520 0226 B368     		ldr	r3, [r6, #8]
 2521 0228 DF07     		lsls	r7, r3, #31
 2522 022a 7FF527AF 		bpl	.L173
1133:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
 2523              		.loc 2 1133 0
 2524 022e 0023     		movs	r3, #0
 2525 0230 84F82530 		strb	r3, [r4, #37]
 2526              	.LVL249:
 2527              	.L201:
1078:../drivers/fsl_dspi_edma.c ****     }
 2528              		.loc 2 1078 0
 2529 0234 0420     		movs	r0, #4
 2530 0236 1CE7     		b	.L167
 2531              	.LVL250:
 2532              	.L174:
1175:../drivers/fsl_dspi_edma.c ****         {
 2533              		.loc 2 1175 0
 2534 0238 2368     		ldr	r3, [r4]
 2535              	.LVL251:
 2536 023a 082B     		cmp	r3, #8
 2537 023c 42D9     		bls	.L177
1189:../drivers/fsl_dspi_edma.c ****                 }
 2538              		.loc 2 1189 0
 2539 023e 46EA0620 		orr	r0, r6, r6, lsl #8
 2540 0242 0223     		movs	r3, #2
 2541              	.LBB244:
 2542              	.LBB245:
 580:../drivers/fsl_dspi.h **** }
 2543              		.loc 3 580 0
 2544 0244 4FF00077 		mov	r7, #33554432
 2545              	.LVL252:
 2546              	.L178:
 2547              	.LBE245:
 2548              	.LBE244:
 2549              	.LBB247:
 2550              	.LBB248:
 561:../drivers/fsl_dspi.h **** }
 2551              		.loc 3 561 0
 2552 0248 EA6A     		ldr	r2, [r5, #44]
 2553              	.LVL253:
 2554              	.LBE248:
 2555              	.LBE247:
1177:../drivers/fsl_dspi_edma.c ****             {
 2556              		.loc 2 1177 0
 2557 024a 9101     		lsls	r1, r2, #6
 2558 024c 7FF545AF 		bpl	.L180
1179:../drivers/fsl_dspi_edma.c ****                 {
 2559              		.loc 2 1179 0
 2560 0250 6268     		ldr	r2, [r4, #4]
 2561 0252 D2B1     		cbz	r2, .L204
1181:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
 2562              		.loc 2 1181 0
 2563 0254 6268     		ldr	r2, [r4, #4]
1182:../drivers/fsl_dspi_edma.c **** 
 2564              		.loc 2 1182 0
 2565 0256 6168     		ldr	r1, [r4, #4]
1181:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
 2566              		.loc 2 1181 0
 2567 0258 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 2568              	.LVL254:
1182:../drivers/fsl_dspi_edma.c **** 
 2569              		.loc 2 1182 0
 2570 025a 0131     		adds	r1, r1, #1
 2571 025c 6160     		str	r1, [r4, #4]
1184:../drivers/fsl_dspi_edma.c ****                     ++handle->txData; /* Increment to next data byte */
 2572              		.loc 2 1184 0
 2573 025e 6168     		ldr	r1, [r4, #4]
 2574 0260 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 2575 0262 42EA0122 		orr	r2, r2, r1, lsl #8
 2576              	.LVL255:
1185:../drivers/fsl_dspi_edma.c ****                 }
 2577              		.loc 2 1185 0
 2578 0266 6168     		ldr	r1, [r4, #4]
 2579 0268 0131     		adds	r1, r1, #1
 2580 026a 6160     		str	r1, [r4, #4]
 2581              	.LVL256:
 2582              	.L179:
1191:../drivers/fsl_dspi_edma.c ****                 base->PUSHR_SLAVE = wordToSend;
 2583              		.loc 2 1191 0
 2584 026c E168     		ldr	r1, [r4, #12]
 2585 026e 0239     		subs	r1, r1, #2
 2586 0270 E160     		str	r1, [r4, #12]
1192:../drivers/fsl_dspi_edma.c **** 
 2587              		.loc 2 1192 0
 2588 0272 6A63     		str	r2, [r5, #52]
 2589              	.LVL257:
 2590              	.LBB249:
 2591              	.LBB246:
 580:../drivers/fsl_dspi.h **** }
 2592              		.loc 3 580 0
 2593 0274 EF62     		str	r7, [r5, #44]
 2594              	.LVL258:
 2595              	.LBE246:
 2596              	.LBE249:
1200:../drivers/fsl_dspi_edma.c ****                 {
 2597              		.loc 2 1200 0
 2598 0276 E268     		ldr	r2, [r4, #12]
 2599              	.LVL259:
 2600 0278 002A     		cmp	r2, #0
 2601 027a 3FF42EAF 		beq	.L180
 2602 027e 013B     		subs	r3, r3, #1
 2603              	.LVL260:
1200:../drivers/fsl_dspi_edma.c ****                 {
 2604              		.loc 2 1200 0 is_stmt 0 discriminator 1
 2605 0280 13F0FF03 		ands	r3, r3, #255
 2606 0284 3FF429AF 		beq	.L180
 2607 0288 DEE7     		b	.L178
 2608              	.LVL261:
 2609              	.L204:
1189:../drivers/fsl_dspi_edma.c ****                 }
 2610              		.loc 2 1189 0 is_stmt 1
 2611 028a 0246     		mov	r2, r0
 2612 028c EEE7     		b	.L179
 2613              	.LVL262:
 2614              	.L185:
1210:../drivers/fsl_dspi_edma.c ****                 {
 2615              		.loc 2 1210 0
 2616 028e 6268     		ldr	r2, [r4, #4]
 2617 0290 B2B1     		cbz	r2, .L182
1212:../drivers/fsl_dspi_edma.c ****                     /* Increment to next data word*/
 2618              		.loc 2 1212 0
 2619 0292 6268     		ldr	r2, [r4, #4]
 2620 0294 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 2621              	.LVL263:
1214:../drivers/fsl_dspi_edma.c ****                 }
 2622              		.loc 2 1214 0
 2623 0296 6268     		ldr	r2, [r4, #4]
 2624 0298 0132     		adds	r2, r2, #1
 2625 029a 6260     		str	r2, [r4, #4]
 2626              	.LVL264:
 2627              	.L183:
1221:../drivers/fsl_dspi_edma.c **** 
 2628              		.loc 2 1221 0
 2629 029c 6963     		str	r1, [r5, #52]
 2630              	.LVL265:
 2631              	.LBB250:
 2632              	.LBB251:
 580:../drivers/fsl_dspi.h **** }
 2633              		.loc 3 580 0
 2634 029e EF62     		str	r7, [r5, #44]
 2635              	.LVL266:
 2636              	.LBE251:
 2637              	.LBE250:
1226:../drivers/fsl_dspi_edma.c **** 
 2638              		.loc 2 1226 0
 2639 02a0 E268     		ldr	r2, [r4, #12]
 2640 02a2 013A     		subs	r2, r2, #1
 2641 02a4 E260     		str	r2, [r4, #12]
 2642              	.LVL267:
1231:../drivers/fsl_dspi_edma.c ****                 {
 2643              		.loc 2 1231 0
 2644 02a6 E268     		ldr	r2, [r4, #12]
 2645 02a8 002A     		cmp	r2, #0
 2646 02aa 3FF416AF 		beq	.L180
 2647 02ae 013B     		subs	r3, r3, #1
 2648              	.LVL268:
1231:../drivers/fsl_dspi_edma.c ****                 {
 2649              		.loc 2 1231 0 is_stmt 0 discriminator 1
 2650 02b0 13F0FF03 		ands	r3, r3, #255
 2651 02b4 3FF411AF 		beq	.L180
 2652              	.LVL269:
 2653              	.L184:
 2654              	.LBB253:
 2655              	.LBB254:
 561:../drivers/fsl_dspi.h **** }
 2656              		.loc 3 561 0 is_stmt 1
 2657 02b8 EA6A     		ldr	r2, [r5, #44]
 2658              	.LVL270:
 2659              	.LBE254:
 2660              	.LBE253:
1208:../drivers/fsl_dspi_edma.c ****             {
 2661              		.loc 2 1208 0
 2662 02ba 9201     		lsls	r2, r2, #6
 2663 02bc E7D4     		bmi	.L185
 2664 02be 0CE7     		b	.L180
 2665              	.L182:
1218:../drivers/fsl_dspi_edma.c ****                 }
 2666              		.loc 2 1218 0
 2667 02c0 0146     		mov	r1, r0
 2668              	.LVL271:
 2669 02c2 EBE7     		b	.L183
 2670              	.LVL272:
 2671              	.L177:
 2672 02c4 0223     		movs	r3, #2
 2673 02c6 B0B2     		uxth	r0, r6
 2674              	.LBB255:
 2675              	.LBB252:
 580:../drivers/fsl_dspi.h **** }
 2676              		.loc 3 580 0
 2677 02c8 4FF00077 		mov	r7, #33554432
 2678 02cc F4E7     		b	.L184
 2679              	.LVL273:
 2680              	.L186:
 2681              	.LBE252:
 2682              	.LBE255:
1254:../drivers/fsl_dspi_edma.c ****             transferConfigA.destOffset = 0;
 2683              		.loc 2 1254 0
 2684 02ce 04F11802 		add	r2, r4, #24
 2685 02d2 0392     		str	r2, [sp, #12]
 2686 02d4 16E7     		b	.L224
 2687              	.L231:
 2688 02d6 00BF     		.align	2
 2689              	.L230:
 2690 02d8 00C00240 		.word	1073922048
 2691 02dc 00000000 		.word	.LANCHOR1
 2692 02e0 00000000 		.word	EDMA_DspiSlaveCallback
 2693 02e4 00000000 		.word	s_dummyData
 2694 02e8 00000ADA 		.word	-636878848
 2695              	.L191:
1299:../drivers/fsl_dspi_edma.c ****             {
 2696              		.loc 2 1299 0
 2697 02ec 082B     		cmp	r3, #8
1297:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 0;
 2698              		.loc 2 1297 0
 2699 02ee 04F11C01 		add	r1, r4, #28
1305:../drivers/fsl_dspi_edma.c ****             }
 2700              		.loc 2 1305 0
 2701 02f2 88BF     		it	hi
 2702 02f4 46EA0626 		orrhi	r6, r6, r6, lsl #8
 2703              	.LVL274:
1297:../drivers/fsl_dspi_edma.c ****             transferConfigC.srcOffset = 0;
 2704              		.loc 2 1297 0
 2705 02f8 0891     		str	r1, [sp, #32]
1298:../drivers/fsl_dspi_edma.c ****             if (handle->bitsPerFrame <= 8)
 2706              		.loc 2 1298 0
 2707 02fa ADF82A20 		strh	r2, [sp, #42]	@ movhi
1305:../drivers/fsl_dspi_edma.c ****             }
 2708              		.loc 2 1305 0
 2709 02fe E661     		str	r6, [r4, #28]
 2710 0300 40E7     		b	.L192
 2711              	.LVL275:
 2712              	.L197:
1360:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2713              		.loc 2 1360 0
 2714 0302 1946     		mov	r1, r3
 2715 0304 8068     		ldr	r0, [r0, #8]
 2716 0306 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2717              	.LVL276:
1364:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2718              		.loc 2 1364 0
 2719 030a 236B     		ldr	r3, [r4, #48]
1363:../drivers/fsl_dspi_edma.c ****         EDMA_SetChannelPreemptionConfig(handle->edmaRxRegToRxDataHandle->base, handle->edmaRxRegToR
 2720              		.loc 2 1363 0
 2721 030c 8DF80680 		strb	r8, [sp, #6]
1364:../drivers/fsl_dspi_edma.c ****                                         &preemption_config_t);
 2722              		.loc 2 1364 0
 2723 0310 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2724 0312 9868     		ldr	r0, [r3, #8]
 2725 0314 01AA     		add	r2, sp, #4
 2726 0316 FFF7FEFF 		bl	EDMA_SetChannelPreemptionConfig
 2727              	.LVL277:
 2728              	.LBB256:
 2729              	.LBB257:
 645:../drivers/fsl_dspi.h **** }
 2730              		.loc 3 645 0
 2731 031a 2B6B     		ldr	r3, [r5, #48]
 2732 031c 43F04073 		orr	r3, r3, #50331648
 2733              	.LVL278:
 2734              	.L229:
 2735              	.LBE257:
 2736              	.LBE256:
 2737              	.LBB258:
 2738              	.LBB243:
 2739 0320 43F44033 		orr	r3, r3, #196608
 2740 0324 2B63     		str	r3, [r5, #48]
 2741              	.LBE243:
 2742              	.LBE258:
1387:../drivers/fsl_dspi_edma.c **** }
 2743              		.loc 2 1387 0
 2744 0326 0020     		movs	r0, #0
 2745 0328 A3E6     		b	.L167
 2746              	.LVL279:
 2747              	.L202:
1090:../drivers/fsl_dspi_edma.c ****     }
 2748              		.loc 2 1090 0
 2749 032a 4FF41670 		mov	r0, #600
 2750              	.LVL280:
 2751 032e A0E6     		b	.L167
 2752              		.cfi_endproc
 2753              	.LFE184:
 2755              		.section	.text.DSPI_SlaveTransferAbortEDMA,"ax",%progbits
 2756              		.align	1
 2757              		.global	DSPI_SlaveTransferAbortEDMA
 2758              		.syntax unified
 2759              		.thumb
 2760              		.thumb_func
 2761              		.fpu fpv4-sp-d16
 2763              	DSPI_SlaveTransferAbortEDMA:
 2764              	.LFB186:
1412:../drivers/fsl_dspi_edma.c **** 
1413:../drivers/fsl_dspi_edma.c **** void DSPI_SlaveTransferAbortEDMA(SPI_Type *base, dspi_slave_edma_handle_t *handle)
1414:../drivers/fsl_dspi_edma.c **** {
 2765              		.loc 2 1414 0
 2766              		.cfi_startproc
 2767              		@ args = 0, pretend = 0, frame = 0
 2768              		@ frame_needed = 0, uses_anonymous_args = 0
 2769              	.LVL281:
 2770              	.LBB259:
 2771              	.LBB260:
 753:../drivers/fsl_dspi.h **** }
 2772              		.loc 3 753 0
 2773 0000 0368     		ldr	r3, [r0]
 2774 0002 43F00103 		orr	r3, r3, #1
 2775              	.LBE260:
 2776              	.LBE259:
 2777              		.loc 2 1414 0
 2778 0006 10B5     		push	{r4, lr}
 2779              		.cfi_def_cfa_offset 8
 2780              		.cfi_offset 4, -8
 2781              		.cfi_offset 14, -4
 2782              	.LBB262:
 2783              	.LBB261:
 753:../drivers/fsl_dspi.h **** }
 2784              		.loc 3 753 0
 2785 0008 0360     		str	r3, [r0]
 2786              	.LVL282:
 2787              	.LBE261:
 2788              	.LBE262:
 2789              	.LBB263:
 2790              	.LBB264:
 661:../drivers/fsl_dspi.h **** }
 2791              		.loc 3 661 0
 2792 000a 036B     		ldr	r3, [r0, #48]
 2793 000c 23F04073 		bic	r3, r3, #50331648
 2794              	.LBE264:
 2795              	.LBE263:
 2796              		.loc 2 1414 0
 2797 0010 0C46     		mov	r4, r1
 2798              	.LBB266:
 2799              	.LBB265:
 661:../drivers/fsl_dspi.h **** }
 2800              		.loc 3 661 0
 2801 0012 23F44033 		bic	r3, r3, #196608
 2802 0016 0363     		str	r3, [r0, #48]
 2803              	.LVL283:
 2804              	.LBE265:
 2805              	.LBE266:
1415:../drivers/fsl_dspi_edma.c ****     assert(handle);
1416:../drivers/fsl_dspi_edma.c **** 
1417:../drivers/fsl_dspi_edma.c ****     DSPI_StopTransfer(base);
1418:../drivers/fsl_dspi_edma.c **** 
1419:../drivers/fsl_dspi_edma.c ****     DSPI_DisableDMA(base, kDSPI_RxDmaEnable | kDSPI_TxDmaEnable);
1420:../drivers/fsl_dspi_edma.c **** 
1421:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaRxRegToRxDataHandle);
 2806              		.loc 2 1421 0
 2807 0018 086B     		ldr	r0, [r1, #48]
 2808              	.LVL284:
 2809 001a FFF7FEFF 		bl	EDMA_AbortTransfer
 2810              	.LVL285:
1422:../drivers/fsl_dspi_edma.c ****     EDMA_AbortTransfer(handle->edmaTxDataToTxRegHandle);
 2811              		.loc 2 1422 0
 2812 001e 606B     		ldr	r0, [r4, #52]
 2813 0020 FFF7FEFF 		bl	EDMA_AbortTransfer
 2814              	.LVL286:
1423:../drivers/fsl_dspi_edma.c **** 
1424:../drivers/fsl_dspi_edma.c ****     handle->state = kDSPI_Idle;
 2815              		.loc 2 1424 0
 2816 0024 0023     		movs	r3, #0
 2817 0026 84F82530 		strb	r3, [r4, #37]
 2818 002a 10BD     		pop	{r4, pc}
 2819              		.cfi_endproc
 2820              	.LFE186:
 2822              		.section	.text.DSPI_SlaveTransferGetCountEDMA,"ax",%progbits
 2823              		.align	1
 2824              		.global	DSPI_SlaveTransferGetCountEDMA
 2825              		.syntax unified
 2826              		.thumb
 2827              		.thumb_func
 2828              		.fpu fpv4-sp-d16
 2830              	DSPI_SlaveTransferGetCountEDMA:
 2831              	.LFB187:
1425:../drivers/fsl_dspi_edma.c **** }
1426:../drivers/fsl_dspi_edma.c **** 
1427:../drivers/fsl_dspi_edma.c **** status_t DSPI_SlaveTransferGetCountEDMA(SPI_Type *base, dspi_slave_edma_handle_t *handle, size_t *c
1428:../drivers/fsl_dspi_edma.c **** {
 2832              		.loc 2 1428 0
 2833              		.cfi_startproc
 2834              		@ args = 0, pretend = 0, frame = 0
 2835              		@ frame_needed = 0, uses_anonymous_args = 0
 2836              	.LVL287:
 2837 0000 70B5     		push	{r4, r5, r6, lr}
 2838              		.cfi_def_cfa_offset 16
 2839              		.cfi_offset 4, -16
 2840              		.cfi_offset 5, -12
 2841              		.cfi_offset 6, -8
 2842              		.cfi_offset 14, -4
 2843              		.loc 2 1428 0
 2844 0002 0C46     		mov	r4, r1
1429:../drivers/fsl_dspi_edma.c ****     assert(handle);
1430:../drivers/fsl_dspi_edma.c **** 
1431:../drivers/fsl_dspi_edma.c ****     if (!count)
 2845              		.loc 2 1431 0
 2846 0004 1546     		mov	r5, r2
 2847 0006 A2B1     		cbz	r2, .L236
1432:../drivers/fsl_dspi_edma.c ****     {
1433:../drivers/fsl_dspi_edma.c ****         return kStatus_InvalidArgument;
1434:../drivers/fsl_dspi_edma.c ****     }
1435:../drivers/fsl_dspi_edma.c **** 
1436:../drivers/fsl_dspi_edma.c ****     /* Catch when there is not an active transfer. */
1437:../drivers/fsl_dspi_edma.c ****     if (handle->state != kDSPI_Busy)
 2848              		.loc 2 1437 0
 2849 0008 91F82530 		ldrb	r3, [r1, #37]	@ zero_extendqisi2
 2850 000c 012B     		cmp	r3, #1
 2851 000e 03D0     		beq	.L235
1438:../drivers/fsl_dspi_edma.c ****     {
1439:../drivers/fsl_dspi_edma.c ****         *count = 0;
 2852              		.loc 2 1439 0
 2853 0010 0023     		movs	r3, #0
 2854 0012 1360     		str	r3, [r2]
1440:../drivers/fsl_dspi_edma.c ****         return kStatus_NoTransferInProgress;
 2855              		.loc 2 1440 0
 2856 0014 0620     		movs	r0, #6
 2857              	.LVL288:
 2858 0016 70BD     		pop	{r4, r5, r6, pc}
 2859              	.LVL289:
 2860              	.L235:
1441:../drivers/fsl_dspi_edma.c ****     }
1442:../drivers/fsl_dspi_edma.c **** 
1443:../drivers/fsl_dspi_edma.c ****     size_t bytes;
1444:../drivers/fsl_dspi_edma.c **** 
1445:../drivers/fsl_dspi_edma.c ****     bytes = (uint32_t)handle->nbytes * EDMA_GetRemainingMajorLoopCount(handle->edmaRxRegToRxDataHan
 2861              		.loc 2 1445 0
 2862 0018 0B6B     		ldr	r3, [r1, #48]
 2863 001a 91F82460 		ldrb	r6, [r1, #36]	@ zero_extendqisi2
 2864 001e 9868     		ldr	r0, [r3, #8]
 2865              	.LVL290:
 2866 0020 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 2867              	.LVL291:
 2868 0022 FFF7FEFF 		bl	EDMA_GetRemainingMajorLoopCount
 2869              	.LVL292:
1446:../drivers/fsl_dspi_edma.c ****                                                                        handle->edmaRxRegToRxDataHan
1447:../drivers/fsl_dspi_edma.c **** 
1448:../drivers/fsl_dspi_edma.c ****     *count = handle->totalByteCount - bytes;
 2870              		.loc 2 1448 0
 2871 0026 6369     		ldr	r3, [r4, #20]
 2872 0028 00FB1630 		mls	r0, r0, r6, r3
 2873              	.LVL293:
 2874 002c 2860     		str	r0, [r5]
1449:../drivers/fsl_dspi_edma.c **** 
1450:../drivers/fsl_dspi_edma.c ****     return kStatus_Success;
 2875              		.loc 2 1450 0
 2876 002e 0020     		movs	r0, #0
 2877 0030 70BD     		pop	{r4, r5, r6, pc}
 2878              	.LVL294:
 2879              	.L236:
1433:../drivers/fsl_dspi_edma.c ****     }
 2880              		.loc 2 1433 0
 2881 0032 0420     		movs	r0, #4
 2882              	.LVL295:
1451:../drivers/fsl_dspi_edma.c **** }
 2883              		.loc 2 1451 0
 2884 0034 70BD     		pop	{r4, r5, r6, pc}
 2885              		.cfi_endproc
 2886              	.LFE187:
 2888              		.section	.bss.s_dspiMasterEdmaPrivateHandle,"aw",%nobits
 2889              		.align	2
 2890              		.set	.LANCHOR0,. + 0
 2893              	s_dspiMasterEdmaPrivateHandle:
 2894 0000 00000000 		.space	24
 2894      00000000 
 2894      00000000 
 2894      00000000 
 2894      00000000 
 2895              		.section	.bss.s_dspiSlaveEdmaPrivateHandle,"aw",%nobits
 2896              		.align	2
 2897              		.set	.LANCHOR1,. + 0
 2900              	s_dspiSlaveEdmaPrivateHandle:
 2901 0000 00000000 		.space	24
 2901      00000000 
 2901      00000000 
 2901      00000000 
 2901      00000000 
 2902              		.text
 2903              	.Letext0:
 2904              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 2905              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 2906              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 2907              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 2908              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 2909              		.file 9 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 2910              		.file 10 "../CMSIS/core_cm4.h"
 2911              		.file 11 "../CMSIS/system_MK64F12.h"
 2912              		.file 12 "../CMSIS/MK64F12.h"
 2913              		.file 13 "../drivers/fsl_common.h"
 2914              		.file 14 "../drivers/fsl_clock.h"
 2915              		.file 15 "../drivers/fsl_dspi_edma.h"
