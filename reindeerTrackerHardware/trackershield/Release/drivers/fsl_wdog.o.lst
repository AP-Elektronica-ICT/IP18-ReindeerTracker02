   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_wdog.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.WDOG_GetDefaultConfig,"ax",%progbits
  18              		.align	1
  19              		.global	WDOG_GetDefaultConfig
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	WDOG_GetDefaultConfig:
  26              	.LFB156:
  27              		.file 1 "../drivers/fsl_wdog.c"
   1:../drivers/fsl_wdog.c **** /*
   2:../drivers/fsl_wdog.c ****  * The Clear BSD License
   3:../drivers/fsl_wdog.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_wdog.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_wdog.c ****  * All rights reserved.
   6:../drivers/fsl_wdog.c ****  *
   7:../drivers/fsl_wdog.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_wdog.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_wdog.c ****  * that the following conditions are met:
  10:../drivers/fsl_wdog.c ****  *
  11:../drivers/fsl_wdog.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_wdog.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_wdog.c ****  *
  14:../drivers/fsl_wdog.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_wdog.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_wdog.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_wdog.c ****  *
  18:../drivers/fsl_wdog.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_wdog.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_wdog.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_wdog.c ****  *
  22:../drivers/fsl_wdog.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_wdog.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_wdog.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_wdog.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_wdog.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_wdog.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_wdog.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_wdog.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_wdog.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_wdog.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_wdog.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_wdog.c ****  */
  34:../drivers/fsl_wdog.c **** 
  35:../drivers/fsl_wdog.c **** #include "fsl_wdog.h"
  36:../drivers/fsl_wdog.c **** 
  37:../drivers/fsl_wdog.c **** /*******************************************************************************
  38:../drivers/fsl_wdog.c ****  * Code
  39:../drivers/fsl_wdog.c ****  ******************************************************************************/
  40:../drivers/fsl_wdog.c **** 
  41:../drivers/fsl_wdog.c **** void WDOG_GetDefaultConfig(wdog_config_t *config)
  42:../drivers/fsl_wdog.c **** {
  28              		.loc 1 42 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  43:../drivers/fsl_wdog.c ****     assert(config);
  44:../drivers/fsl_wdog.c **** 
  45:../drivers/fsl_wdog.c ****     config->enableWdog = true;
  46:../drivers/fsl_wdog.c ****     config->clockSource = kWDOG_LpoClockSource;
  34              		.loc 1 46 0
  35 0000 0023     		movs	r3, #0
  45:../drivers/fsl_wdog.c ****     config->clockSource = kWDOG_LpoClockSource;
  36              		.loc 1 45 0
  37 0002 0122     		movs	r2, #1
  38              		.loc 1 46 0
  39 0004 4370     		strb	r3, [r0, #1]
  47:../drivers/fsl_wdog.c ****     config->prescaler = kWDOG_ClockPrescalerDivide1;
  40              		.loc 1 47 0
  41 0006 8370     		strb	r3, [r0, #2]
  48:../drivers/fsl_wdog.c **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
  49:../drivers/fsl_wdog.c ****     config->workMode.enableWait = true;
  50:../drivers/fsl_wdog.c **** #endif /* FSL_FEATURE_WDOG_HAS_WAITEN */
  51:../drivers/fsl_wdog.c ****     config->workMode.enableStop = false;
  42              		.loc 1 51 0
  43 0008 0371     		strb	r3, [r0, #4]
  52:../drivers/fsl_wdog.c ****     config->workMode.enableDebug = false;
  44              		.loc 1 52 0
  45 000a 4371     		strb	r3, [r0, #5]
  53:../drivers/fsl_wdog.c ****     config->enableUpdate = true;
  54:../drivers/fsl_wdog.c ****     config->enableInterrupt = false;
  46              		.loc 1 54 0
  47 000c C371     		strb	r3, [r0, #7]
  55:../drivers/fsl_wdog.c ****     config->enableWindowMode = false;
  48              		.loc 1 55 0
  49 000e 0372     		strb	r3, [r0, #8]
  56:../drivers/fsl_wdog.c ****     config->windowValue = 0U;
  50              		.loc 1 56 0
  51 0010 C360     		str	r3, [r0, #12]
  57:../drivers/fsl_wdog.c ****     config->timeoutValue = 0xFFFFU;
  52              		.loc 1 57 0
  53 0012 4FF6FF73 		movw	r3, #65535
  45:../drivers/fsl_wdog.c ****     config->clockSource = kWDOG_LpoClockSource;
  54              		.loc 1 45 0
  55 0016 0270     		strb	r2, [r0]
  49:../drivers/fsl_wdog.c **** #endif /* FSL_FEATURE_WDOG_HAS_WAITEN */
  56              		.loc 1 49 0
  57 0018 C270     		strb	r2, [r0, #3]
  53:../drivers/fsl_wdog.c ****     config->enableInterrupt = false;
  58              		.loc 1 53 0
  59 001a 8271     		strb	r2, [r0, #6]
  60              		.loc 1 57 0
  61 001c 0361     		str	r3, [r0, #16]
  62 001e 7047     		bx	lr
  63              		.cfi_endproc
  64              	.LFE156:
  66              		.section	.text.WDOG_Init,"ax",%progbits
  67              		.align	1
  68              		.global	WDOG_Init
  69              		.syntax unified
  70              		.thumb
  71              		.thumb_func
  72              		.fpu fpv4-sp-d16
  74              	WDOG_Init:
  75              	.LFB157:
  58:../drivers/fsl_wdog.c **** }
  59:../drivers/fsl_wdog.c **** 
  60:../drivers/fsl_wdog.c **** void WDOG_Init(WDOG_Type *base, const wdog_config_t *config)
  61:../drivers/fsl_wdog.c **** {
  76              		.loc 1 61 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 0, uses_anonymous_args = 0
  80              	.LVL1:
  62:../drivers/fsl_wdog.c ****     assert(config);
  63:../drivers/fsl_wdog.c **** 
  64:../drivers/fsl_wdog.c ****     uint32_t value = 0U;
  65:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
  66:../drivers/fsl_wdog.c **** 
  67:../drivers/fsl_wdog.c ****     value = WDOG_STCTRLH_WDOGEN(config->enableWdog) | WDOG_STCTRLH_CLKSRC(config->clockSource) |
  81              		.loc 1 67 0
  82 0000 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
  68:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  69:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_ALLOWUPDATE(config->enableUpdate) | WDOG_STCTRLH_DBGEN(config->workMode.en
  70:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_STOPEN(config->workMode.enableStop) |
  71:../drivers/fsl_wdog.c **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
  72:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_WAITEN(config->workMode.enableWait) |
  83              		.loc 1 72 0
  84 0002 CA78     		ldrb	r2, [r1, #3]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  85              		.loc 1 67 0
  86 0004 43F48043 		orr	r3, r3, #16384
  87 0008 43EAC213 		orr	r3, r3, r2, lsl #7
  88 000c 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
  89 000e 5200     		lsls	r2, r2, #1
  90 0010 02F00202 		and	r2, r2, #2
  91 0014 1343     		orrs	r3, r3, r2
  68:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  92              		.loc 1 68 0
  93 0016 CA79     		ldrb	r2, [r1, #7]	@ zero_extendqisi2
  94 0018 9200     		lsls	r2, r2, #2
  95 001a 02F00402 		and	r2, r2, #4
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  96              		.loc 1 67 0
  97 001e 1343     		orrs	r3, r3, r2
  68:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  98              		.loc 1 68 0
  99 0020 0A7A     		ldrb	r2, [r1, #8]	@ zero_extendqisi2
 100 0022 D200     		lsls	r2, r2, #3
 101 0024 02F00802 		and	r2, r2, #8
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 102              		.loc 1 67 0
 103 0028 1343     		orrs	r3, r3, r2
  69:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_STOPEN(config->workMode.enableStop) |
 104              		.loc 1 69 0
 105 002a 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 106 002c 1201     		lsls	r2, r2, #4
 107 002e 02F01002 		and	r2, r2, #16
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 108              		.loc 1 67 0
 109 0032 1343     		orrs	r3, r3, r2
  69:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_STOPEN(config->workMode.enableStop) |
 110              		.loc 1 69 0
 111 0034 4A79     		ldrb	r2, [r1, #5]	@ zero_extendqisi2
 112 0036 5201     		lsls	r2, r2, #5
 113 0038 02F02002 		and	r2, r2, #32
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 114              		.loc 1 67 0
 115 003c 1343     		orrs	r3, r3, r2
  70:../drivers/fsl_wdog.c **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
 116              		.loc 1 70 0
 117 003e 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
 118 0040 9201     		lsls	r2, r2, #6
 119 0042 02F04002 		and	r2, r2, #64
  61:../drivers/fsl_wdog.c ****     assert(config);
 120              		.loc 1 61 0
 121 0046 30B5     		push	{r4, r5, lr}
 122              		.cfi_def_cfa_offset 12
 123              		.cfi_offset 4, -12
 124              		.cfi_offset 5, -8
 125              		.cfi_offset 14, -4
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 126              		.loc 1 67 0
 127 0048 43EA0205 		orr	r5, r3, r2
 128              	.LVL2:
 129              	.LBB58:
 130              	.LBB59:
 131              	.LBB60:
 132              	.LBB61:
 133              		.file 2 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 134              		.loc 2 383 0
 135              		.syntax unified
 136              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 137 004c EFF31083 		MRS r3, primask
 138              	@ 0 "" 2
 139              		.thumb
 140              		.syntax unified
 141              	.LBE61:
 142              	.LBE60:
 143              	.LBB62:
 144              	.LBB63:
 139:../CMSIS/cmsis_gcc.h **** }
 145              		.loc 2 139 0
 146              		.syntax unified
 147              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 148 0050 72B6     		cpsid i
 149              	@ 0 "" 2
 150              	.LVL3:
 151              		.thumb
 152              		.syntax unified
 153              	.LBE63:
 154              	.LBE62:
 155              	.LBE59:
 156              	.LBE58:
 157              	.LBB64:
 158              	.LBB65:
 159              		.file 3 "../drivers/fsl_wdog.h"
   1:../drivers/fsl_wdog.h **** /*
   2:../drivers/fsl_wdog.h ****  * The Clear BSD License
   3:../drivers/fsl_wdog.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_wdog.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_wdog.h ****  * All rights reserved.
   6:../drivers/fsl_wdog.h ****  *
   7:../drivers/fsl_wdog.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_wdog.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_wdog.h ****  * that the following conditions are met:
  10:../drivers/fsl_wdog.h ****  *
  11:../drivers/fsl_wdog.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_wdog.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_wdog.h ****  *
  14:../drivers/fsl_wdog.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_wdog.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_wdog.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_wdog.h ****  *
  18:../drivers/fsl_wdog.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_wdog.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_wdog.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_wdog.h ****  *
  22:../drivers/fsl_wdog.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_wdog.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_wdog.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_wdog.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_wdog.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_wdog.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_wdog.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_wdog.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_wdog.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_wdog.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_wdog.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_wdog.h ****  */
  34:../drivers/fsl_wdog.h **** #ifndef _FSL_WDOG_H_
  35:../drivers/fsl_wdog.h **** #define _FSL_WDOG_H_
  36:../drivers/fsl_wdog.h **** 
  37:../drivers/fsl_wdog.h **** #include "fsl_common.h"
  38:../drivers/fsl_wdog.h **** 
  39:../drivers/fsl_wdog.h **** /*!
  40:../drivers/fsl_wdog.h ****  * @addtogroup wdog
  41:../drivers/fsl_wdog.h ****  * @{
  42:../drivers/fsl_wdog.h ****  */
  43:../drivers/fsl_wdog.h **** 
  44:../drivers/fsl_wdog.h **** 
  45:../drivers/fsl_wdog.h **** /*******************************************************************************
  46:../drivers/fsl_wdog.h ****  * Definitions
  47:../drivers/fsl_wdog.h ****  *******************************************************************************/
  48:../drivers/fsl_wdog.h **** 
  49:../drivers/fsl_wdog.h **** /*! @name Driver version */
  50:../drivers/fsl_wdog.h **** /*@{*/
  51:../drivers/fsl_wdog.h **** /*! @brief Defines WDOG driver version 2.0.0. */
  52:../drivers/fsl_wdog.h **** #define FSL_WDOG_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
  53:../drivers/fsl_wdog.h **** /*@}*/
  54:../drivers/fsl_wdog.h **** 
  55:../drivers/fsl_wdog.h **** /*! @name Unlock sequence */
  56:../drivers/fsl_wdog.h **** /*@{*/
  57:../drivers/fsl_wdog.h **** #define WDOG_FIRST_WORD_OF_UNLOCK (0xC520U)  /*!< First word of unlock sequence */
  58:../drivers/fsl_wdog.h **** #define WDOG_SECOND_WORD_OF_UNLOCK (0xD928U) /*!< Second word of unlock sequence */
  59:../drivers/fsl_wdog.h **** /*@}*/
  60:../drivers/fsl_wdog.h **** 
  61:../drivers/fsl_wdog.h **** /*! @name Refresh sequence */
  62:../drivers/fsl_wdog.h **** /*@{*/
  63:../drivers/fsl_wdog.h **** #define WDOG_FIRST_WORD_OF_REFRESH (0xA602U)  /*!< First word of refresh sequence */
  64:../drivers/fsl_wdog.h **** #define WDOG_SECOND_WORD_OF_REFRESH (0xB480U) /*!< Second word of refresh sequence */
  65:../drivers/fsl_wdog.h **** /*@}*/
  66:../drivers/fsl_wdog.h **** 
  67:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG clock source. */
  68:../drivers/fsl_wdog.h **** typedef enum _wdog_clock_source
  69:../drivers/fsl_wdog.h **** {
  70:../drivers/fsl_wdog.h ****     kWDOG_LpoClockSource = 0U,       /*!< WDOG clock sourced from LPO*/
  71:../drivers/fsl_wdog.h ****     kWDOG_AlternateClockSource = 1U, /*!< WDOG clock sourced from alternate clock source*/
  72:../drivers/fsl_wdog.h **** } wdog_clock_source_t;
  73:../drivers/fsl_wdog.h **** 
  74:../drivers/fsl_wdog.h **** /*! @brief Defines WDOG work mode. */
  75:../drivers/fsl_wdog.h **** typedef struct _wdog_work_mode
  76:../drivers/fsl_wdog.h **** {
  77:../drivers/fsl_wdog.h **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
  78:../drivers/fsl_wdog.h ****     bool enableWait;  /*!< Enables or disables WDOG in wait mode  */
  79:../drivers/fsl_wdog.h **** #endif                /* FSL_FEATURE_WDOG_HAS_WAITEN */
  80:../drivers/fsl_wdog.h ****     bool enableStop;  /*!< Enables or disables WDOG in stop mode  */
  81:../drivers/fsl_wdog.h ****     bool enableDebug; /*!< Enables or disables WDOG in debug mode */
  82:../drivers/fsl_wdog.h **** } wdog_work_mode_t;
  83:../drivers/fsl_wdog.h **** 
  84:../drivers/fsl_wdog.h **** /*! @brief Describes the selection of the clock prescaler. */
  85:../drivers/fsl_wdog.h **** typedef enum _wdog_clock_prescaler
  86:../drivers/fsl_wdog.h **** {
  87:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide1 = 0x0U, /*!< Divided by 1 */
  88:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide2 = 0x1U, /*!< Divided by 2 */
  89:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide3 = 0x2U, /*!< Divided by 3 */
  90:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide4 = 0x3U, /*!< Divided by 4 */
  91:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide5 = 0x4U, /*!< Divided by 5 */
  92:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide6 = 0x5U, /*!< Divided by 6 */
  93:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide7 = 0x6U, /*!< Divided by 7 */
  94:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide8 = 0x7U, /*!< Divided by 8 */
  95:../drivers/fsl_wdog.h **** } wdog_clock_prescaler_t;
  96:../drivers/fsl_wdog.h **** 
  97:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG configuration structure. */
  98:../drivers/fsl_wdog.h **** typedef struct _wdog_config
  99:../drivers/fsl_wdog.h **** {
 100:../drivers/fsl_wdog.h ****     bool enableWdog;                  /*!< Enables or disables WDOG */
 101:../drivers/fsl_wdog.h ****     wdog_clock_source_t clockSource;  /*!< Clock source select */
 102:../drivers/fsl_wdog.h ****     wdog_clock_prescaler_t prescaler; /*!< Clock prescaler value */
 103:../drivers/fsl_wdog.h ****     wdog_work_mode_t workMode;        /*!< Configures WDOG work mode in debug stop and wait mode */
 104:../drivers/fsl_wdog.h ****     bool enableUpdate;                /*!< Update write-once register enable */
 105:../drivers/fsl_wdog.h ****     bool enableInterrupt;             /*!< Enables or disables WDOG interrupt */
 106:../drivers/fsl_wdog.h ****     bool enableWindowMode;            /*!< Enables or disables WDOG window mode */
 107:../drivers/fsl_wdog.h ****     uint32_t windowValue;             /*!< Window value */
 108:../drivers/fsl_wdog.h ****     uint32_t timeoutValue;            /*!< Timeout value */
 109:../drivers/fsl_wdog.h **** } wdog_config_t;
 110:../drivers/fsl_wdog.h **** 
 111:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG test mode. */
 112:../drivers/fsl_wdog.h **** typedef enum _wdog_test_mode
 113:../drivers/fsl_wdog.h **** {
 114:../drivers/fsl_wdog.h ****     kWDOG_QuickTest = 0U, /*!< Selects quick test */
 115:../drivers/fsl_wdog.h ****     kWDOG_ByteTest = 1U,  /*!< Selects byte test */
 116:../drivers/fsl_wdog.h **** } wdog_test_mode_t;
 117:../drivers/fsl_wdog.h **** 
 118:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG tested byte selection in byte test mode. */
 119:../drivers/fsl_wdog.h **** typedef enum _wdog_tested_byte
 120:../drivers/fsl_wdog.h **** {
 121:../drivers/fsl_wdog.h ****     kWDOG_TestByte0 = 0U, /*!< Byte 0 selected in byte test mode */
 122:../drivers/fsl_wdog.h ****     kWDOG_TestByte1 = 1U, /*!< Byte 1 selected in byte test mode */
 123:../drivers/fsl_wdog.h ****     kWDOG_TestByte2 = 2U, /*!< Byte 2 selected in byte test mode */
 124:../drivers/fsl_wdog.h ****     kWDOG_TestByte3 = 3U, /*!< Byte 3 selected in byte test mode */
 125:../drivers/fsl_wdog.h **** } wdog_tested_byte_t;
 126:../drivers/fsl_wdog.h **** 
 127:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG test mode configuration structure. */
 128:../drivers/fsl_wdog.h **** typedef struct _wdog_test_config
 129:../drivers/fsl_wdog.h **** {
 130:../drivers/fsl_wdog.h ****     wdog_test_mode_t testMode;     /*!< Selects test mode */
 131:../drivers/fsl_wdog.h ****     wdog_tested_byte_t testedByte; /*!< Selects tested byte in byte test mode */
 132:../drivers/fsl_wdog.h ****     uint32_t timeoutValue;         /*!< Timeout value */
 133:../drivers/fsl_wdog.h **** } wdog_test_config_t;
 134:../drivers/fsl_wdog.h **** 
 135:../drivers/fsl_wdog.h **** /*!
 136:../drivers/fsl_wdog.h ****  * @brief WDOG interrupt configuration structure, default settings all disabled.
 137:../drivers/fsl_wdog.h ****  *
 138:../drivers/fsl_wdog.h ****  * This structure contains the settings for all of the WDOG interrupt configurations.
 139:../drivers/fsl_wdog.h ****  */
 140:../drivers/fsl_wdog.h **** enum _wdog_interrupt_enable_t
 141:../drivers/fsl_wdog.h **** {
 142:../drivers/fsl_wdog.h ****     kWDOG_InterruptEnable = WDOG_STCTRLH_IRQRSTEN_MASK, /*!< WDOG timeout generates an interrupt be
 143:../drivers/fsl_wdog.h **** };
 144:../drivers/fsl_wdog.h **** 
 145:../drivers/fsl_wdog.h **** /*!
 146:../drivers/fsl_wdog.h ****  * @brief WDOG status flags.
 147:../drivers/fsl_wdog.h ****  *
 148:../drivers/fsl_wdog.h ****  * This structure contains the WDOG status flags for use in the WDOG functions.
 149:../drivers/fsl_wdog.h ****  */
 150:../drivers/fsl_wdog.h **** enum _wdog_status_flags_t
 151:../drivers/fsl_wdog.h **** {
 152:../drivers/fsl_wdog.h ****     kWDOG_RunningFlag = WDOG_STCTRLH_WDOGEN_MASK, /*!< Running flag, set when WDOG is enabled*/
 153:../drivers/fsl_wdog.h ****     kWDOG_TimeoutFlag = WDOG_STCTRLL_INTFLG_MASK, /*!< Interrupt flag, set when an exception occurs
 154:../drivers/fsl_wdog.h **** };
 155:../drivers/fsl_wdog.h **** 
 156:../drivers/fsl_wdog.h **** /*******************************************************************************
 157:../drivers/fsl_wdog.h ****  * API
 158:../drivers/fsl_wdog.h ****  *******************************************************************************/
 159:../drivers/fsl_wdog.h **** 
 160:../drivers/fsl_wdog.h **** #if defined(__cplusplus)
 161:../drivers/fsl_wdog.h **** extern "C" {
 162:../drivers/fsl_wdog.h **** #endif /* __cplusplus */
 163:../drivers/fsl_wdog.h **** 
 164:../drivers/fsl_wdog.h **** /*!
 165:../drivers/fsl_wdog.h ****  * @name WDOG Initialization and De-initialization
 166:../drivers/fsl_wdog.h ****  * @{
 167:../drivers/fsl_wdog.h ****  */
 168:../drivers/fsl_wdog.h **** 
 169:../drivers/fsl_wdog.h **** /*!
 170:../drivers/fsl_wdog.h ****  * @brief Initializes the WDOG configuration sturcture.
 171:../drivers/fsl_wdog.h ****  *
 172:../drivers/fsl_wdog.h ****  * This function initializes the WDOG configuration structure to default values. The default
 173:../drivers/fsl_wdog.h ****  * values are as follows.
 174:../drivers/fsl_wdog.h ****  * @code
 175:../drivers/fsl_wdog.h ****  *   wdogConfig->enableWdog = true;
 176:../drivers/fsl_wdog.h ****  *   wdogConfig->clockSource = kWDOG_LpoClockSource;
 177:../drivers/fsl_wdog.h ****  *   wdogConfig->prescaler = kWDOG_ClockPrescalerDivide1;
 178:../drivers/fsl_wdog.h ****  *   wdogConfig->workMode.enableWait = true;
 179:../drivers/fsl_wdog.h ****  *   wdogConfig->workMode.enableStop = false;
 180:../drivers/fsl_wdog.h ****  *   wdogConfig->workMode.enableDebug = false;
 181:../drivers/fsl_wdog.h ****  *   wdogConfig->enableUpdate = true;
 182:../drivers/fsl_wdog.h ****  *   wdogConfig->enableInterrupt = false;
 183:../drivers/fsl_wdog.h ****  *   wdogConfig->enableWindowMode = false;
 184:../drivers/fsl_wdog.h ****  *   wdogConfig->windowValue = 0;
 185:../drivers/fsl_wdog.h ****  *   wdogConfig->timeoutValue = 0xFFFFU;
 186:../drivers/fsl_wdog.h ****  * @endcode
 187:../drivers/fsl_wdog.h ****  *
 188:../drivers/fsl_wdog.h ****  * @param config Pointer to the WDOG configuration structure.
 189:../drivers/fsl_wdog.h ****  * @see wdog_config_t
 190:../drivers/fsl_wdog.h ****  */
 191:../drivers/fsl_wdog.h **** void WDOG_GetDefaultConfig(wdog_config_t *config);
 192:../drivers/fsl_wdog.h **** 
 193:../drivers/fsl_wdog.h **** /*!
 194:../drivers/fsl_wdog.h ****  * @brief Initializes the WDOG.
 195:../drivers/fsl_wdog.h ****  *
 196:../drivers/fsl_wdog.h ****  * This function initializes the WDOG. When called, the WDOG runs according to the configuration.
 197:../drivers/fsl_wdog.h ****  * To reconfigure WDOG without forcing a reset first, enableUpdate must be set to true
 198:../drivers/fsl_wdog.h ****  * in the configuration.
 199:../drivers/fsl_wdog.h ****  *
 200:../drivers/fsl_wdog.h ****  * This is an example.
 201:../drivers/fsl_wdog.h ****  * @code
 202:../drivers/fsl_wdog.h ****  *   wdog_config_t config;
 203:../drivers/fsl_wdog.h ****  *   WDOG_GetDefaultConfig(&config);
 204:../drivers/fsl_wdog.h ****  *   config.timeoutValue = 0x7ffU;
 205:../drivers/fsl_wdog.h ****  *   config.enableUpdate = true;
 206:../drivers/fsl_wdog.h ****  *   WDOG_Init(wdog_base,&config);
 207:../drivers/fsl_wdog.h ****  * @endcode
 208:../drivers/fsl_wdog.h ****  *
 209:../drivers/fsl_wdog.h ****  * @param base   WDOG peripheral base address
 210:../drivers/fsl_wdog.h ****  * @param config The configuration of WDOG
 211:../drivers/fsl_wdog.h ****  */
 212:../drivers/fsl_wdog.h **** void WDOG_Init(WDOG_Type *base, const wdog_config_t *config);
 213:../drivers/fsl_wdog.h **** 
 214:../drivers/fsl_wdog.h **** /*!
 215:../drivers/fsl_wdog.h ****  * @brief Shuts down the WDOG.
 216:../drivers/fsl_wdog.h ****  *
 217:../drivers/fsl_wdog.h ****  * This function shuts down the WDOG.
 218:../drivers/fsl_wdog.h ****  * Ensure that the WDOG_STCTRLH.ALLOWUPDATE is 1 which indicates that the register update is enable
 219:../drivers/fsl_wdog.h ****  */
 220:../drivers/fsl_wdog.h **** void WDOG_Deinit(WDOG_Type *base);
 221:../drivers/fsl_wdog.h **** 
 222:../drivers/fsl_wdog.h **** /*!
 223:../drivers/fsl_wdog.h ****  * @brief Configures the WDOG functional test.
 224:../drivers/fsl_wdog.h ****  *
 225:../drivers/fsl_wdog.h ****  * This function is used to configure the WDOG functional test. When called, the WDOG goes into tes
 226:../drivers/fsl_wdog.h ****  * and runs according to the configuration.
 227:../drivers/fsl_wdog.h ****  * Ensure that the WDOG_STCTRLH.ALLOWUPDATE is 1 which means that the register update is enabled.
 228:../drivers/fsl_wdog.h ****  *
 229:../drivers/fsl_wdog.h ****  * This is an example.
 230:../drivers/fsl_wdog.h ****  * @code
 231:../drivers/fsl_wdog.h ****  *   wdog_test_config_t test_config;
 232:../drivers/fsl_wdog.h ****  *   test_config.testMode = kWDOG_QuickTest;
 233:../drivers/fsl_wdog.h ****  *   test_config.timeoutValue = 0xfffffu;
 234:../drivers/fsl_wdog.h ****  *   WDOG_SetTestModeConfig(wdog_base, &test_config);
 235:../drivers/fsl_wdog.h ****  * @endcode
 236:../drivers/fsl_wdog.h ****  * @param base   WDOG peripheral base address
 237:../drivers/fsl_wdog.h ****  * @param config The functional test configuration of WDOG
 238:../drivers/fsl_wdog.h ****  */
 239:../drivers/fsl_wdog.h **** void WDOG_SetTestModeConfig(WDOG_Type *base, wdog_test_config_t *config);
 240:../drivers/fsl_wdog.h **** 
 241:../drivers/fsl_wdog.h **** /* @} */
 242:../drivers/fsl_wdog.h **** 
 243:../drivers/fsl_wdog.h **** /*!
 244:../drivers/fsl_wdog.h ****  * @name WDOG Functional Operation
 245:../drivers/fsl_wdog.h ****  * @{
 246:../drivers/fsl_wdog.h ****  */
 247:../drivers/fsl_wdog.h **** 
 248:../drivers/fsl_wdog.h **** /*!
 249:../drivers/fsl_wdog.h ****  * @brief Enables the WDOG module.
 250:../drivers/fsl_wdog.h ****  *
 251:../drivers/fsl_wdog.h ****  * This function write value into WDOG_STCTRLH register to enable the WDOG, it is a write-once regi
 252:../drivers/fsl_wdog.h ****  * make sure that the WCT window is still open and this register has not been written in this WCT
 253:../drivers/fsl_wdog.h ****  * while this function is called.
 254:../drivers/fsl_wdog.h ****  *
 255:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 256:../drivers/fsl_wdog.h ****  */
 257:../drivers/fsl_wdog.h **** static inline void WDOG_Enable(WDOG_Type *base)
 258:../drivers/fsl_wdog.h **** {
 259:../drivers/fsl_wdog.h ****     base->STCTRLH |= WDOG_STCTRLH_WDOGEN_MASK;
 260:../drivers/fsl_wdog.h **** }
 261:../drivers/fsl_wdog.h **** 
 262:../drivers/fsl_wdog.h **** /*!
 263:../drivers/fsl_wdog.h ****  * @brief Disables the WDOG module.
 264:../drivers/fsl_wdog.h ****  *
 265:../drivers/fsl_wdog.h ****  * This function writes a value into the WDOG_STCTRLH register to disable the WDOG. It is a write-o
 266:../drivers/fsl_wdog.h ****  * Ensure that the WCT window is still open and that register has not been written to in this WCT
 267:../drivers/fsl_wdog.h ****  * while the function is called.
 268:../drivers/fsl_wdog.h ****  *
 269:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 270:../drivers/fsl_wdog.h ****  */
 271:../drivers/fsl_wdog.h **** static inline void WDOG_Disable(WDOG_Type *base)
 272:../drivers/fsl_wdog.h **** {
 273:../drivers/fsl_wdog.h ****     base->STCTRLH &= ~WDOG_STCTRLH_WDOGEN_MASK;
 274:../drivers/fsl_wdog.h **** }
 275:../drivers/fsl_wdog.h **** 
 276:../drivers/fsl_wdog.h **** /*!
 277:../drivers/fsl_wdog.h ****  * @brief Enables the WDOG interrupt.
 278:../drivers/fsl_wdog.h ****  *
 279:../drivers/fsl_wdog.h ****  * This function writes a value into the WDOG_STCTRLH register to enable the WDOG interrupt. It is 
 280:../drivers/fsl_wdog.h ****  * Ensure that the WCT window is still open and the register has not been written to in this WCT
 281:../drivers/fsl_wdog.h ****  * while the function is called.
 282:../drivers/fsl_wdog.h ****  *
 283:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 284:../drivers/fsl_wdog.h ****  * @param mask The interrupts to enable
 285:../drivers/fsl_wdog.h ****  *        The parameter can be combination of the following source if defined.
 286:../drivers/fsl_wdog.h ****  *        @arg kWDOG_InterruptEnable
 287:../drivers/fsl_wdog.h ****  */
 288:../drivers/fsl_wdog.h **** static inline void WDOG_EnableInterrupts(WDOG_Type *base, uint32_t mask)
 289:../drivers/fsl_wdog.h **** {
 290:../drivers/fsl_wdog.h ****     base->STCTRLH |= mask;
 291:../drivers/fsl_wdog.h **** }
 292:../drivers/fsl_wdog.h **** 
 293:../drivers/fsl_wdog.h **** /*!
 294:../drivers/fsl_wdog.h ****  * @brief Disables the WDOG interrupt.
 295:../drivers/fsl_wdog.h ****  *
 296:../drivers/fsl_wdog.h ****  * This function writes a value into the WDOG_STCTRLH register to disable the WDOG interrupt. It is
 297:../drivers/fsl_wdog.h ****  * Ensure that the WCT window is still open and the register has not been written to in this WCT
 298:../drivers/fsl_wdog.h ****  * while the function is called.
 299:../drivers/fsl_wdog.h ****  *
 300:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 301:../drivers/fsl_wdog.h ****  * @param mask The interrupts to disable
 302:../drivers/fsl_wdog.h ****  *        The parameter can be combination of the following source if defined.
 303:../drivers/fsl_wdog.h ****  *        @arg kWDOG_InterruptEnable
 304:../drivers/fsl_wdog.h ****  */
 305:../drivers/fsl_wdog.h **** static inline void WDOG_DisableInterrupts(WDOG_Type *base, uint32_t mask)
 306:../drivers/fsl_wdog.h **** {
 307:../drivers/fsl_wdog.h ****     base->STCTRLH &= ~mask;
 308:../drivers/fsl_wdog.h **** }
 309:../drivers/fsl_wdog.h **** 
 310:../drivers/fsl_wdog.h **** /*!
 311:../drivers/fsl_wdog.h ****  * @brief Gets the WDOG all status flags.
 312:../drivers/fsl_wdog.h ****  *
 313:../drivers/fsl_wdog.h ****  * This function gets all status flags.
 314:../drivers/fsl_wdog.h ****  *
 315:../drivers/fsl_wdog.h ****  * This is an example for getting the Running Flag.
 316:../drivers/fsl_wdog.h ****  * @code
 317:../drivers/fsl_wdog.h ****  *   uint32_t status;
 318:../drivers/fsl_wdog.h ****  *   status = WDOG_GetStatusFlags (wdog_base) & kWDOG_RunningFlag;
 319:../drivers/fsl_wdog.h ****  * @endcode
 320:../drivers/fsl_wdog.h ****  * @param base        WDOG peripheral base address
 321:../drivers/fsl_wdog.h ****  * @return            State of the status flag: asserted (true) or not-asserted (false).@see _wdog_
 322:../drivers/fsl_wdog.h ****  *                    - true: a related status flag has been set.
 323:../drivers/fsl_wdog.h ****  *                    - false: a related status flag is not set.
 324:../drivers/fsl_wdog.h ****  */
 325:../drivers/fsl_wdog.h **** uint32_t WDOG_GetStatusFlags(WDOG_Type *base);
 326:../drivers/fsl_wdog.h **** 
 327:../drivers/fsl_wdog.h **** /*!
 328:../drivers/fsl_wdog.h ****  * @brief Clears the WDOG flag.
 329:../drivers/fsl_wdog.h ****  *
 330:../drivers/fsl_wdog.h ****  * This function clears the WDOG status flag.
 331:../drivers/fsl_wdog.h ****  *
 332:../drivers/fsl_wdog.h ****  * This is an example for clearing the timeout (interrupt) flag.
 333:../drivers/fsl_wdog.h ****  * @code
 334:../drivers/fsl_wdog.h ****  *   WDOG_ClearStatusFlags(wdog_base,kWDOG_TimeoutFlag);
 335:../drivers/fsl_wdog.h ****  * @endcode
 336:../drivers/fsl_wdog.h ****  * @param base        WDOG peripheral base address
 337:../drivers/fsl_wdog.h ****  * @param mask        The status flags to clear.
 338:../drivers/fsl_wdog.h ****  *                    The parameter could be any combination of the following values.
 339:../drivers/fsl_wdog.h ****  *                    kWDOG_TimeoutFlag
 340:../drivers/fsl_wdog.h ****  */
 341:../drivers/fsl_wdog.h **** void WDOG_ClearStatusFlags(WDOG_Type *base, uint32_t mask);
 342:../drivers/fsl_wdog.h **** 
 343:../drivers/fsl_wdog.h **** /*!
 344:../drivers/fsl_wdog.h ****  * @brief Sets the WDOG timeout value.
 345:../drivers/fsl_wdog.h ****  *
 346:../drivers/fsl_wdog.h ****  * This function sets the timeout value.
 347:../drivers/fsl_wdog.h ****  * It should be ensured that the time-out value for the WDOG is always greater than
 348:../drivers/fsl_wdog.h ****  * 2xWCT time + 20 bus clock cycles.
 349:../drivers/fsl_wdog.h ****  * This function writes a value into WDOG_TOVALH and WDOG_TOVALL registers which are wirte-once.
 350:../drivers/fsl_wdog.h ****  * Ensure the WCT window is still open and the two registers have not been written to in this WCT
 351:../drivers/fsl_wdog.h ****  * while the function is called.
 352:../drivers/fsl_wdog.h ****  *
 353:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 354:../drivers/fsl_wdog.h ****  * @param timeoutCount WDOG timeout value; count of WDOG clock tick.
 355:../drivers/fsl_wdog.h ****  */
 356:../drivers/fsl_wdog.h **** static inline void WDOG_SetTimeoutValue(WDOG_Type *base, uint32_t timeoutCount)
 357:../drivers/fsl_wdog.h **** {
 358:../drivers/fsl_wdog.h ****     base->TOVALH = (uint16_t)((timeoutCount >> 16U) & 0xFFFFU);
 359:../drivers/fsl_wdog.h ****     base->TOVALL = (uint16_t)((timeoutCount)&0xFFFFU);
 360:../drivers/fsl_wdog.h **** }
 361:../drivers/fsl_wdog.h **** 
 362:../drivers/fsl_wdog.h **** /*!
 363:../drivers/fsl_wdog.h ****  * @brief Sets the WDOG window value.
 364:../drivers/fsl_wdog.h ****  *
 365:../drivers/fsl_wdog.h ****  * This function sets the WDOG window value.
 366:../drivers/fsl_wdog.h ****  * This function writes a value into WDOG_WINH and WDOG_WINL registers which are wirte-once.
 367:../drivers/fsl_wdog.h ****  * Ensure the WCT window is still open and the two registers have not been written to in this WCT
 368:../drivers/fsl_wdog.h ****  * while the function is called.
 369:../drivers/fsl_wdog.h ****  *
 370:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 371:../drivers/fsl_wdog.h ****  * @param windowValue WDOG window value.
 372:../drivers/fsl_wdog.h ****  */
 373:../drivers/fsl_wdog.h **** static inline void WDOG_SetWindowValue(WDOG_Type *base, uint32_t windowValue)
 374:../drivers/fsl_wdog.h **** {
 375:../drivers/fsl_wdog.h ****     base->WINH = (uint16_t)((windowValue >> 16U) & 0xFFFFU);
 376:../drivers/fsl_wdog.h ****     base->WINL = (uint16_t)((windowValue)&0xFFFFU);
 377:../drivers/fsl_wdog.h **** }
 378:../drivers/fsl_wdog.h **** 
 379:../drivers/fsl_wdog.h **** /*!
 380:../drivers/fsl_wdog.h ****  * @brief Unlocks the WDOG register written.
 381:../drivers/fsl_wdog.h ****  *
 382:../drivers/fsl_wdog.h ****  * This function unlocks the WDOG register written.
 383:../drivers/fsl_wdog.h ****  * Before starting the unlock sequence and following congfiguration, disable the global interrupts.
 384:../drivers/fsl_wdog.h ****  * Otherwise, an interrupt may invalidate the unlocking sequence and the WCT may expire.
 385:../drivers/fsl_wdog.h ****  * After the configuration finishes, re-enable the global interrupts.
 386:../drivers/fsl_wdog.h ****  *
 387:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 388:../drivers/fsl_wdog.h ****  */
 389:../drivers/fsl_wdog.h **** static inline void WDOG_Unlock(WDOG_Type *base)
 390:../drivers/fsl_wdog.h **** {
 391:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_FIRST_WORD_OF_UNLOCK;
 160              		.loc 3 391 0
 161 0052 4CF22052 		movw	r2, #50464
 162 0056 C281     		strh	r2, [r0, #14]	@ movhi
 392:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_SECOND_WORD_OF_UNLOCK;
 163              		.loc 3 392 0
 164 0058 4DF62812 		movw	r2, #55592
 165 005c C281     		strh	r2, [r0, #14]	@ movhi
 166              	.LVL4:
 167              	.LBE65:
 168              	.LBE64:
  73:../drivers/fsl_wdog.c **** #endif /* FSL_FEATURE_WDOG_HAS_WAITEN */
  74:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_DISTESTWDOG(1U);
  75:../drivers/fsl_wdog.c **** 
  76:../drivers/fsl_wdog.c ****     /* Disable the global interrupts. Otherwise, an interrupt could effectively invalidate the unlo
  77:../drivers/fsl_wdog.c ****      * and the WCT may expire. After the configuration finishes, re-enable the global interrupts. *
  78:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
  79:../drivers/fsl_wdog.c ****     WDOG_Unlock(base);
  80:../drivers/fsl_wdog.c ****     /* Wait one bus clock cycle */
  81:../drivers/fsl_wdog.c ****     base->RSTCNT = 0U;
 169              		.loc 1 81 0
 170 005e 0022     		movs	r2, #0
 171 0060 8282     		strh	r2, [r0, #20]	@ movhi
  82:../drivers/fsl_wdog.c ****     /* Set configruation */
  83:../drivers/fsl_wdog.c ****     base->PRESC = WDOG_PRESC_PRESCVAL(config->prescaler);
 172              		.loc 1 83 0
 173 0062 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
  84:../drivers/fsl_wdog.c ****     base->WINH = (uint16_t)((config->windowValue >> 16U) & 0xFFFFU);
 174              		.loc 1 84 0
 175 0064 CC68     		ldr	r4, [r1, #12]
  85:../drivers/fsl_wdog.c ****     base->WINL = (uint16_t)((config->windowValue) & 0xFFFFU);
  86:../drivers/fsl_wdog.c ****     base->TOVALH = (uint16_t)((config->timeoutValue >> 16U) & 0xFFFFU);
 176              		.loc 1 86 0
 177 0066 0969     		ldr	r1, [r1, #16]
 178              	.LVL5:
  83:../drivers/fsl_wdog.c ****     base->WINH = (uint16_t)((config->windowValue >> 16U) & 0xFFFFU);
 179              		.loc 1 83 0
 180 0068 1202     		lsls	r2, r2, #8
 181 006a 02F4E062 		and	r2, r2, #1792
 182 006e C282     		strh	r2, [r0, #22]	@ movhi
  84:../drivers/fsl_wdog.c ****     base->WINH = (uint16_t)((config->windowValue >> 16U) & 0xFFFFU);
 183              		.loc 1 84 0
 184 0070 220C     		lsrs	r2, r4, #16
 185 0072 0281     		strh	r2, [r0, #8]	@ movhi
  85:../drivers/fsl_wdog.c ****     base->WINL = (uint16_t)((config->windowValue) & 0xFFFFU);
 186              		.loc 1 85 0
 187 0074 A4B2     		uxth	r4, r4
 188              		.loc 1 86 0
 189 0076 0A0C     		lsrs	r2, r1, #16
  85:../drivers/fsl_wdog.c ****     base->WINL = (uint16_t)((config->windowValue) & 0xFFFFU);
 190              		.loc 1 85 0
 191 0078 4481     		strh	r4, [r0, #10]	@ movhi
  87:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 192              		.loc 1 87 0
 193 007a 89B2     		uxth	r1, r1
  86:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 194              		.loc 1 86 0
 195 007c 8280     		strh	r2, [r0, #4]	@ movhi
  88:../drivers/fsl_wdog.c ****     base->STCTRLH = value;
 196              		.loc 1 88 0
 197 007e AAB2     		uxth	r2, r5
  87:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 198              		.loc 1 87 0
 199 0080 C180     		strh	r1, [r0, #6]	@ movhi
 200              		.loc 1 88 0
 201 0082 0280     		strh	r2, [r0]	@ movhi
 202              	.LBB66:
 203              	.LBB67:
 204              	.LBB68:
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 205              		.loc 2 411 0
 206              		.syntax unified
 207              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 208 0084 83F31088 		MSR primask, r3
 209              	@ 0 "" 2
 210              		.thumb
 211              		.syntax unified
 212 0088 30BD     		pop	{r4, r5, pc}
 213              	.LBE68:
 214              	.LBE67:
 215              	.LBE66:
 216              		.cfi_endproc
 217              	.LFE157:
 219              		.section	.text.WDOG_Deinit,"ax",%progbits
 220              		.align	1
 221              		.global	WDOG_Deinit
 222              		.syntax unified
 223              		.thumb
 224              		.thumb_func
 225              		.fpu fpv4-sp-d16
 227              	WDOG_Deinit:
 228              	.LFB158:
  89:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
  90:../drivers/fsl_wdog.c **** }
  91:../drivers/fsl_wdog.c **** 
  92:../drivers/fsl_wdog.c **** void WDOG_Deinit(WDOG_Type *base)
  93:../drivers/fsl_wdog.c **** {
 229              		.loc 1 93 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              		@ link register save eliminated.
 234              	.LVL6:
 235              	.LBB69:
 236              	.LBB70:
 237              	.LBB71:
 238              	.LBB72:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 239              		.loc 2 383 0
 240              		.syntax unified
 241              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 242 0000 EFF31082 		MRS r2, primask
 243              	@ 0 "" 2
 244              		.thumb
 245              		.syntax unified
 246              	.LBE72:
 247              	.LBE71:
 248              	.LBB73:
 249              	.LBB74:
 139:../CMSIS/cmsis_gcc.h **** }
 250              		.loc 2 139 0
 251              		.syntax unified
 252              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 253 0004 72B6     		cpsid i
 254              	@ 0 "" 2
 255              	.LVL7:
 256              		.thumb
 257              		.syntax unified
 258              	.LBE74:
 259              	.LBE73:
 260              	.LBE70:
 261              	.LBE69:
 262              	.LBB75:
 263              	.LBB76:
 391:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_SECOND_WORD_OF_UNLOCK;
 264              		.loc 3 391 0
 265 0006 4CF22053 		movw	r3, #50464
 266 000a C381     		strh	r3, [r0, #14]	@ movhi
 267              		.loc 3 392 0
 268 000c 4DF62813 		movw	r3, #55592
 269 0010 C381     		strh	r3, [r0, #14]	@ movhi
 270              	.LVL8:
 271              	.LBE76:
 272              	.LBE75:
  94:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
  95:../drivers/fsl_wdog.c **** 
  96:../drivers/fsl_wdog.c ****     /* Disable the global interrupts */
  97:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
  98:../drivers/fsl_wdog.c ****     WDOG_Unlock(base);
  99:../drivers/fsl_wdog.c ****     /* Wait one bus clock cycle */
 100:../drivers/fsl_wdog.c ****     base->RSTCNT = 0U;
 273              		.loc 1 100 0
 274 0012 0023     		movs	r3, #0
 275 0014 8382     		strh	r3, [r0, #20]	@ movhi
 276              	.LVL9:
 277              	.LBB77:
 278              	.LBB78:
 273:../drivers/fsl_wdog.h **** }
 279              		.loc 3 273 0
 280 0016 0388     		ldrh	r3, [r0]
 281 0018 23F00103 		bic	r3, r3, #1
 282 001c 1B04     		lsls	r3, r3, #16
 283 001e 1B0C     		lsrs	r3, r3, #16
 284 0020 0380     		strh	r3, [r0]	@ movhi
 285              	.LVL10:
 286              	.LBE78:
 287              	.LBE77:
 288              	.LBB79:
 289              	.LBB80:
 290              	.LBB81:
 291              		.loc 2 411 0
 292              		.syntax unified
 293              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 294 0022 82F31088 		MSR primask, r2
 295              	@ 0 "" 2
 296              	.LVL11:
 297              		.thumb
 298              		.syntax unified
 299              	.LBE81:
 300              	.LBE80:
 301              	.LBE79:
 302              	.LBB82:
 303              	.LBB83:
 393:../drivers/fsl_wdog.h **** }
 394:../drivers/fsl_wdog.h **** 
 395:../drivers/fsl_wdog.h **** /*!
 396:../drivers/fsl_wdog.h ****  * @brief Refreshes the WDOG timer.
 397:../drivers/fsl_wdog.h ****  *
 398:../drivers/fsl_wdog.h ****  * This function feeds the WDOG.
 399:../drivers/fsl_wdog.h ****  * This function should be called before the WDOG timer is in timeout. Otherwise, a reset is assert
 400:../drivers/fsl_wdog.h ****  *
 401:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 402:../drivers/fsl_wdog.h ****  */
 403:../drivers/fsl_wdog.h **** void WDOG_Refresh(WDOG_Type *base);
 404:../drivers/fsl_wdog.h **** 
 405:../drivers/fsl_wdog.h **** /*!
 406:../drivers/fsl_wdog.h ****  * @brief Gets the WDOG reset count.
 407:../drivers/fsl_wdog.h ****  *
 408:../drivers/fsl_wdog.h ****  * This function gets the WDOG reset count value.
 409:../drivers/fsl_wdog.h ****  *
 410:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 411:../drivers/fsl_wdog.h ****  * @return     WDOG reset count value.
 412:../drivers/fsl_wdog.h ****  */
 413:../drivers/fsl_wdog.h **** static inline uint16_t WDOG_GetResetCount(WDOG_Type *base)
 414:../drivers/fsl_wdog.h **** {
 415:../drivers/fsl_wdog.h ****     return base->RSTCNT;
 416:../drivers/fsl_wdog.h **** }
 417:../drivers/fsl_wdog.h **** /*!
 418:../drivers/fsl_wdog.h ****  * @brief Clears the WDOG reset count.
 419:../drivers/fsl_wdog.h ****  *
 420:../drivers/fsl_wdog.h ****  * This function clears the WDOG reset count value.
 421:../drivers/fsl_wdog.h ****  *
 422:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 423:../drivers/fsl_wdog.h ****  */
 424:../drivers/fsl_wdog.h **** static inline void WDOG_ClearResetCount(WDOG_Type *base)
 425:../drivers/fsl_wdog.h **** {
 426:../drivers/fsl_wdog.h ****     base->RSTCNT |= UINT16_MAX;
 304              		.loc 3 426 0
 305 0026 838A     		ldrh	r3, [r0, #20]
 306 0028 4FF6FF73 		movw	r3, #65535
 307 002c 8382     		strh	r3, [r0, #20]	@ movhi
 308              	.LVL12:
 309 002e 7047     		bx	lr
 310              	.LBE83:
 311              	.LBE82:
 312              		.cfi_endproc
 313              	.LFE158:
 315              		.section	.text.WDOG_SetTestModeConfig,"ax",%progbits
 316              		.align	1
 317              		.global	WDOG_SetTestModeConfig
 318              		.syntax unified
 319              		.thumb
 320              		.thumb_func
 321              		.fpu fpv4-sp-d16
 323              	WDOG_SetTestModeConfig:
 324              	.LFB159:
 101:../drivers/fsl_wdog.c ****     WDOG_Disable(base);
 102:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
 103:../drivers/fsl_wdog.c ****     WDOG_ClearResetCount(base);
 104:../drivers/fsl_wdog.c **** }
 105:../drivers/fsl_wdog.c **** 
 106:../drivers/fsl_wdog.c **** void WDOG_SetTestModeConfig(WDOG_Type *base, wdog_test_config_t *config)
 107:../drivers/fsl_wdog.c **** {
 325              		.loc 1 107 0
 326              		.cfi_startproc
 327              		@ args = 0, pretend = 0, frame = 0
 328              		@ frame_needed = 0, uses_anonymous_args = 0
 329              	.LVL13:
 108:../drivers/fsl_wdog.c ****     assert(config);
 109:../drivers/fsl_wdog.c **** 
 110:../drivers/fsl_wdog.c ****     uint32_t value = 0U;
 111:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
 112:../drivers/fsl_wdog.c **** 
 113:../drivers/fsl_wdog.c ****     value = WDOG_STCTRLH_DISTESTWDOG(0U) | WDOG_STCTRLH_TESTWDOG(1U) | WDOG_STCTRLH_TESTSEL(config-
 330              		.loc 1 113 0
 331 0000 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 114:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_BYTESEL(config->testedByte) | WDOG_STCTRLH_IRQRSTEN(0U) | WDOG_STCTRLH_WDO
 332              		.loc 1 114 0
 333 0002 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 113:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_BYTESEL(config->testedByte) | WDOG_STCTRLH_IRQRSTEN(0U) | WDOG_STCTRLH_WDO
 334              		.loc 1 113 0
 335 0004 DB02     		lsls	r3, r3, #11
 336              		.loc 1 114 0
 337 0006 1203     		lsls	r2, r2, #12
 338 0008 02F44052 		and	r2, r2, #12288
 339 000c 03F40063 		and	r3, r3, #2048
 340 0010 1343     		orrs	r3, r3, r2
 341 0012 43F48263 		orr	r3, r3, #1040
 107:../drivers/fsl_wdog.c ****     assert(config);
 342              		.loc 1 107 0
 343 0016 10B5     		push	{r4, lr}
 344              		.cfi_def_cfa_offset 8
 345              		.cfi_offset 4, -8
 346              		.cfi_offset 14, -4
 347 0018 43F00103 		orr	r3, r3, #1
 348              	.LVL14:
 349              	.LBB84:
 350              	.LBB85:
 351              	.LBB86:
 352              	.LBB87:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 353              		.loc 2 383 0
 354              		.syntax unified
 355              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 356 001c EFF31084 		MRS r4, primask
 357              	@ 0 "" 2
 358              		.thumb
 359              		.syntax unified
 360              	.LBE87:
 361              	.LBE86:
 362              	.LBB88:
 363              	.LBB89:
 139:../CMSIS/cmsis_gcc.h **** }
 364              		.loc 2 139 0
 365              		.syntax unified
 366              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 367 0020 72B6     		cpsid i
 368              	@ 0 "" 2
 369              	.LVL15:
 370              		.thumb
 371              		.syntax unified
 372              	.LBE89:
 373              	.LBE88:
 374              	.LBE85:
 375              	.LBE84:
 376              	.LBB90:
 377              	.LBB91:
 391:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_SECOND_WORD_OF_UNLOCK;
 378              		.loc 3 391 0
 379 0022 4CF22052 		movw	r2, #50464
 380 0026 C281     		strh	r2, [r0, #14]	@ movhi
 392:../drivers/fsl_wdog.h **** }
 381              		.loc 3 392 0
 382 0028 4DF62812 		movw	r2, #55592
 383 002c C281     		strh	r2, [r0, #14]	@ movhi
 384              	.LVL16:
 385              	.LBE91:
 386              	.LBE90:
 115:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_ALLOWUPDATE(1U);
 116:../drivers/fsl_wdog.c **** 
 117:../drivers/fsl_wdog.c ****     /* Disable the global interrupts. Otherwise, an interrupt could effectively invalidate the unlo
 118:../drivers/fsl_wdog.c ****      * and the WCT may expire. After the configuration finishes, re-enable the global interrupts. *
 119:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
 120:../drivers/fsl_wdog.c ****     WDOG_Unlock(base);
 121:../drivers/fsl_wdog.c ****     /* Wait one bus clock cycle */
 122:../drivers/fsl_wdog.c ****     base->RSTCNT = 0U;
 387              		.loc 1 122 0
 388 002e 0022     		movs	r2, #0
 389 0030 8282     		strh	r2, [r0, #20]	@ movhi
 123:../drivers/fsl_wdog.c ****     /* Set configruation */
 124:../drivers/fsl_wdog.c ****     base->TOVALH = (uint16_t)((config->timeoutValue >> 16U) & 0xFFFFU);
 390              		.loc 1 124 0
 391 0032 4A68     		ldr	r2, [r1, #4]
 392 0034 110C     		lsrs	r1, r2, #16
 393              	.LVL17:
 125:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 394              		.loc 1 125 0
 395 0036 92B2     		uxth	r2, r2
 124:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 396              		.loc 1 124 0
 397 0038 8180     		strh	r1, [r0, #4]	@ movhi
 398              		.loc 1 125 0
 399 003a C280     		strh	r2, [r0, #6]	@ movhi
 126:../drivers/fsl_wdog.c ****     base->STCTRLH = value;
 400              		.loc 1 126 0
 401 003c 0380     		strh	r3, [r0]	@ movhi
 402              	.LBB92:
 403              	.LBB93:
 404              	.LBB94:
 405              		.loc 2 411 0
 406              		.syntax unified
 407              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 408 003e 84F31088 		MSR primask, r4
 409              	@ 0 "" 2
 410              		.thumb
 411              		.syntax unified
 412 0042 10BD     		pop	{r4, pc}
 413              	.LBE94:
 414              	.LBE93:
 415              	.LBE92:
 416              		.cfi_endproc
 417              	.LFE159:
 419              		.section	.text.WDOG_GetStatusFlags,"ax",%progbits
 420              		.align	1
 421              		.global	WDOG_GetStatusFlags
 422              		.syntax unified
 423              		.thumb
 424              		.thumb_func
 425              		.fpu fpv4-sp-d16
 427              	WDOG_GetStatusFlags:
 428              	.LFB160:
 127:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
 128:../drivers/fsl_wdog.c **** }
 129:../drivers/fsl_wdog.c **** 
 130:../drivers/fsl_wdog.c **** uint32_t WDOG_GetStatusFlags(WDOG_Type *base)
 131:../drivers/fsl_wdog.c **** {
 429              		.loc 1 131 0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 0
 432              		@ frame_needed = 0, uses_anonymous_args = 0
 433              		@ link register save eliminated.
 434              	.LVL18:
 132:../drivers/fsl_wdog.c ****     uint32_t status_flag = 0U;
 133:../drivers/fsl_wdog.c **** 
 134:../drivers/fsl_wdog.c ****     status_flag |= (base->STCTRLH & WDOG_STCTRLH_WDOGEN_MASK);
 435              		.loc 1 134 0
 436 0000 0288     		ldrh	r2, [r0]
 437              	.LVL19:
 135:../drivers/fsl_wdog.c ****     status_flag |= (base->STCTRLL & WDOG_STCTRLL_INTFLG_MASK);
 438              		.loc 1 135 0
 439 0002 4388     		ldrh	r3, [r0, #2]
 440              	.LVL20:
 441 0004 02F00100 		and	r0, r2, #1
 442              	.LVL21:
 443 0008 03F40043 		and	r3, r3, #32768
 444              	.LVL22:
 136:../drivers/fsl_wdog.c **** 
 137:../drivers/fsl_wdog.c ****     return status_flag;
 138:../drivers/fsl_wdog.c **** }
 445              		.loc 1 138 0
 446 000c 1843     		orrs	r0, r0, r3
 447 000e 7047     		bx	lr
 448              		.cfi_endproc
 449              	.LFE160:
 451              		.section	.text.WDOG_ClearStatusFlags,"ax",%progbits
 452              		.align	1
 453              		.global	WDOG_ClearStatusFlags
 454              		.syntax unified
 455              		.thumb
 456              		.thumb_func
 457              		.fpu fpv4-sp-d16
 459              	WDOG_ClearStatusFlags:
 460              	.LFB161:
 139:../drivers/fsl_wdog.c **** 
 140:../drivers/fsl_wdog.c **** void WDOG_ClearStatusFlags(WDOG_Type *base, uint32_t mask)
 141:../drivers/fsl_wdog.c **** {
 461              		.loc 1 141 0
 462              		.cfi_startproc
 463              		@ args = 0, pretend = 0, frame = 0
 464              		@ frame_needed = 0, uses_anonymous_args = 0
 465              		@ link register save eliminated.
 466              	.LVL23:
 142:../drivers/fsl_wdog.c ****     if (mask & kWDOG_TimeoutFlag)
 467              		.loc 1 142 0
 468 0000 0B04     		lsls	r3, r1, #16
 469 0002 06D5     		bpl	.L6
 143:../drivers/fsl_wdog.c ****     {
 144:../drivers/fsl_wdog.c ****         base->STCTRLL |= WDOG_STCTRLL_INTFLG_MASK;
 470              		.loc 1 144 0
 471 0004 4388     		ldrh	r3, [r0, #2]
 472 0006 6FEA4343 		mvn	r3, r3, lsl #17
 473 000a 6FEA5343 		mvn	r3, r3, lsr #17
 474 000e 9BB2     		uxth	r3, r3
 475 0010 4380     		strh	r3, [r0, #2]	@ movhi
 476              	.L6:
 477 0012 7047     		bx	lr
 478              		.cfi_endproc
 479              	.LFE161:
 481              		.section	.text.WDOG_Refresh,"ax",%progbits
 482              		.align	1
 483              		.global	WDOG_Refresh
 484              		.syntax unified
 485              		.thumb
 486              		.thumb_func
 487              		.fpu fpv4-sp-d16
 489              	WDOG_Refresh:
 490              	.LFB162:
 145:../drivers/fsl_wdog.c ****     }
 146:../drivers/fsl_wdog.c **** }
 147:../drivers/fsl_wdog.c **** 
 148:../drivers/fsl_wdog.c **** void WDOG_Refresh(WDOG_Type *base)
 149:../drivers/fsl_wdog.c **** {
 491              		.loc 1 149 0
 492              		.cfi_startproc
 493              		@ args = 0, pretend = 0, frame = 0
 494              		@ frame_needed = 0, uses_anonymous_args = 0
 495              		@ link register save eliminated.
 496              	.LVL24:
 497              	.LBB95:
 498              	.LBB96:
 499              	.LBB97:
 500              	.LBB98:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 501              		.loc 2 383 0
 502              		.syntax unified
 503              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 504 0000 EFF31083 		MRS r3, primask
 505              	@ 0 "" 2
 506              		.thumb
 507              		.syntax unified
 508              	.LBE98:
 509              	.LBE97:
 510              	.LBB99:
 511              	.LBB100:
 139:../CMSIS/cmsis_gcc.h **** }
 512              		.loc 2 139 0
 513              		.syntax unified
 514              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 515 0004 72B6     		cpsid i
 516              	@ 0 "" 2
 517              	.LVL25:
 518              		.thumb
 519              		.syntax unified
 520              	.LBE100:
 521              	.LBE99:
 522              	.LBE96:
 523              	.LBE95:
 150:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
 151:../drivers/fsl_wdog.c **** 
 152:../drivers/fsl_wdog.c ****     /* Disable the global interrupt to protect refresh sequence */
 153:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
 154:../drivers/fsl_wdog.c ****     base->REFRESH = WDOG_FIRST_WORD_OF_REFRESH;
 524              		.loc 1 154 0
 525 0006 4AF20262 		movw	r2, #42498
 526 000a 8281     		strh	r2, [r0, #12]	@ movhi
 155:../drivers/fsl_wdog.c ****     base->REFRESH = WDOG_SECOND_WORD_OF_REFRESH;
 527              		.loc 1 155 0
 528 000c 4BF28042 		movw	r2, #46208
 529 0010 8281     		strh	r2, [r0, #12]	@ movhi
 530              	.LBB101:
 531              	.LBB102:
 532              	.LBB103:
 533              		.loc 2 411 0
 534              		.syntax unified
 535              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 536 0012 83F31088 		MSR primask, r3
 537              	@ 0 "" 2
 538              		.thumb
 539              		.syntax unified
 540 0016 7047     		bx	lr
 541              	.LBE103:
 542              	.LBE102:
 543              	.LBE101:
 544              		.cfi_endproc
 545              	.LFE162:
 547              		.text
 548              	.Letext0:
 549              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 550              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 551              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 552              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 553              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 554              		.file 9 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 555              		.file 10 "../CMSIS/core_cm4.h"
 556              		.file 11 "../CMSIS/system_MK64F12.h"
 557              		.file 12 "../CMSIS/MK64F12.h"
 558              		.file 13 "../drivers/fsl_clock.h"
 559              		.file 14 "../drivers/fsl_common.h"
