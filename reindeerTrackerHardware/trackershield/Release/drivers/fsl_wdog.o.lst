   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_wdog.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.WDOG_GetDefaultConfig,"ax",%progbits
  18              		.align	1
  19              		.global	WDOG_GetDefaultConfig
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	WDOG_GetDefaultConfig:
  26              	.LFB156:
  27              		.file 1 "../drivers/fsl_wdog.c"
   1:../drivers/fsl_wdog.c **** /*
   2:../drivers/fsl_wdog.c ****  * The Clear BSD License
   3:../drivers/fsl_wdog.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_wdog.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_wdog.c ****  * All rights reserved.
   6:../drivers/fsl_wdog.c ****  *
   7:../drivers/fsl_wdog.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_wdog.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_wdog.c ****  * that the following conditions are met:
  10:../drivers/fsl_wdog.c ****  *
  11:../drivers/fsl_wdog.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_wdog.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_wdog.c ****  *
  14:../drivers/fsl_wdog.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_wdog.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_wdog.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_wdog.c ****  *
  18:../drivers/fsl_wdog.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_wdog.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_wdog.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_wdog.c ****  *
  22:../drivers/fsl_wdog.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_wdog.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_wdog.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_wdog.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_wdog.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_wdog.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_wdog.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_wdog.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_wdog.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_wdog.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_wdog.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_wdog.c ****  */
  34:../drivers/fsl_wdog.c **** 
  35:../drivers/fsl_wdog.c **** #include "fsl_wdog.h"
  36:../drivers/fsl_wdog.c **** 
  37:../drivers/fsl_wdog.c **** /*******************************************************************************
  38:../drivers/fsl_wdog.c ****  * Code
  39:../drivers/fsl_wdog.c ****  ******************************************************************************/
  40:../drivers/fsl_wdog.c **** 
  41:../drivers/fsl_wdog.c **** void WDOG_GetDefaultConfig(wdog_config_t *config)
  42:../drivers/fsl_wdog.c **** {
  28              		.loc 1 42 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  43:../drivers/fsl_wdog.c ****     assert(config);
  44:../drivers/fsl_wdog.c **** 
  45:../drivers/fsl_wdog.c ****     config->enableWdog = true;
  46:../drivers/fsl_wdog.c ****     config->clockSource = kWDOG_LpoClockSource;
  34              		.loc 1 46 0
  35 0000 0023     		movs	r3, #0
  45:../drivers/fsl_wdog.c ****     config->clockSource = kWDOG_LpoClockSource;
  36              		.loc 1 45 0
  37 0002 0122     		movs	r2, #1
  38              		.loc 1 46 0
  39 0004 4370     		strb	r3, [r0, #1]
  47:../drivers/fsl_wdog.c ****     config->prescaler = kWDOG_ClockPrescalerDivide1;
  40              		.loc 1 47 0
  41 0006 8370     		strb	r3, [r0, #2]
  48:../drivers/fsl_wdog.c **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
  49:../drivers/fsl_wdog.c ****     config->workMode.enableWait = true;
  50:../drivers/fsl_wdog.c **** #endif /* FSL_FEATURE_WDOG_HAS_WAITEN */
  51:../drivers/fsl_wdog.c ****     config->workMode.enableStop = false;
  42              		.loc 1 51 0
  43 0008 0371     		strb	r3, [r0, #4]
  52:../drivers/fsl_wdog.c ****     config->workMode.enableDebug = false;
  44              		.loc 1 52 0
  45 000a 4371     		strb	r3, [r0, #5]
  53:../drivers/fsl_wdog.c ****     config->enableUpdate = true;
  54:../drivers/fsl_wdog.c ****     config->enableInterrupt = false;
  46              		.loc 1 54 0
  47 000c C371     		strb	r3, [r0, #7]
  55:../drivers/fsl_wdog.c ****     config->enableWindowMode = false;
  48              		.loc 1 55 0
  49 000e 0372     		strb	r3, [r0, #8]
  56:../drivers/fsl_wdog.c ****     config->windowValue = 0U;
  50              		.loc 1 56 0
  51 0010 C360     		str	r3, [r0, #12]
  57:../drivers/fsl_wdog.c ****     config->timeoutValue = 0xFFFFU;
  52              		.loc 1 57 0
  53 0012 4FF6FF73 		movw	r3, #65535
  45:../drivers/fsl_wdog.c ****     config->clockSource = kWDOG_LpoClockSource;
  54              		.loc 1 45 0
  55 0016 0270     		strb	r2, [r0]
  49:../drivers/fsl_wdog.c **** #endif /* FSL_FEATURE_WDOG_HAS_WAITEN */
  56              		.loc 1 49 0
  57 0018 C270     		strb	r2, [r0, #3]
  53:../drivers/fsl_wdog.c ****     config->enableInterrupt = false;
  58              		.loc 1 53 0
  59 001a 8271     		strb	r2, [r0, #6]
  60              		.loc 1 57 0
  61 001c 0361     		str	r3, [r0, #16]
  58:../drivers/fsl_wdog.c **** }
  62              		.loc 1 58 0
  63 001e 7047     		bx	lr
  64              		.cfi_endproc
  65              	.LFE156:
  67              		.section	.text.WDOG_Init,"ax",%progbits
  68              		.align	1
  69              		.global	WDOG_Init
  70              		.syntax unified
  71              		.thumb
  72              		.thumb_func
  73              		.fpu fpv4-sp-d16
  75              	WDOG_Init:
  76              	.LFB157:
  59:../drivers/fsl_wdog.c **** 
  60:../drivers/fsl_wdog.c **** void WDOG_Init(WDOG_Type *base, const wdog_config_t *config)
  61:../drivers/fsl_wdog.c **** {
  77              		.loc 1 61 0
  78              		.cfi_startproc
  79              		@ args = 0, pretend = 0, frame = 0
  80              		@ frame_needed = 0, uses_anonymous_args = 0
  81              	.LVL1:
  62:../drivers/fsl_wdog.c ****     assert(config);
  63:../drivers/fsl_wdog.c **** 
  64:../drivers/fsl_wdog.c ****     uint32_t value = 0U;
  65:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
  66:../drivers/fsl_wdog.c **** 
  67:../drivers/fsl_wdog.c ****     value = WDOG_STCTRLH_WDOGEN(config->enableWdog) | WDOG_STCTRLH_CLKSRC(config->clockSource) |
  82              		.loc 1 67 0
  83 0000 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
  68:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  84              		.loc 1 68 0
  85 0002 CA79     		ldrb	r2, [r1, #7]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  86              		.loc 1 67 0
  87 0004 43F48043 		orr	r3, r3, #16384
  88 0008 43EA8203 		orr	r3, r3, r2, lsl #2
  89              		.loc 1 68 0
  90 000c 0A7A     		ldrb	r2, [r1, #8]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  91              		.loc 1 67 0
  92 000e 43EAC203 		orr	r3, r3, r2, lsl #3
  69:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_ALLOWUPDATE(config->enableUpdate) | WDOG_STCTRLH_DBGEN(config->workMode.en
  93              		.loc 1 69 0
  94 0012 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  95              		.loc 1 67 0
  96 0014 43EA0213 		orr	r3, r3, r2, lsl #4
  97              		.loc 1 69 0
  98 0018 4A79     		ldrb	r2, [r1, #5]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
  99              		.loc 1 67 0
 100 001a 43EA4213 		orr	r3, r3, r2, lsl #5
  70:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_STOPEN(config->workMode.enableStop) |
 101              		.loc 1 70 0
 102 001e 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 103              		.loc 1 67 0
 104 0020 43EA8213 		orr	r3, r3, r2, lsl #6
  71:../drivers/fsl_wdog.c **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
  72:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_WAITEN(config->workMode.enableWait) |
 105              		.loc 1 72 0
 106 0024 CA78     		ldrb	r2, [r1, #3]	@ zero_extendqisi2
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 107              		.loc 1 67 0
 108 0026 43EAC213 		orr	r3, r3, r2, lsl #7
 109 002a 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 110 002c 5200     		lsls	r2, r2, #1
 111 002e 02F00202 		and	r2, r2, #2
  61:../drivers/fsl_wdog.c ****     assert(config);
 112              		.loc 1 61 0
 113 0032 30B5     		push	{r4, r5, lr}
 114              		.cfi_def_cfa_offset 12
 115              		.cfi_offset 4, -12
 116              		.cfi_offset 5, -8
 117              		.cfi_offset 14, -4
  67:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_IRQRSTEN(config->enableInterrupt) | WDOG_STCTRLH_WINEN(config->enableWindo
 118              		.loc 1 67 0
 119 0034 43EA0205 		orr	r5, r3, r2
 120              	.LVL2:
 121              	.LBB58:
 122              	.LBB59:
 123              	.LBB60:
 124              	.LBB61:
 125              		.file 2 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 126              		.loc 2 383 0
 127              		.syntax unified
 128              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 129 0038 EFF31083 		MRS r3, primask
 130              	@ 0 "" 2
 131              		.thumb
 132              		.syntax unified
 133              	.LBE61:
 134              	.LBE60:
 135              	.LBB62:
 136              	.LBB63:
 139:../CMSIS/cmsis_gcc.h **** }
 137              		.loc 2 139 0
 138              		.syntax unified
 139              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 140 003c 72B6     		cpsid i
 141              	@ 0 "" 2
 142              	.LVL3:
 143              		.thumb
 144              		.syntax unified
 145              	.LBE63:
 146              	.LBE62:
 147              	.LBE59:
 148              	.LBE58:
 149              	.LBB64:
 150              	.LBB65:
 151              		.file 3 "../drivers/fsl_wdog.h"
   1:../drivers/fsl_wdog.h **** /*
   2:../drivers/fsl_wdog.h ****  * The Clear BSD License
   3:../drivers/fsl_wdog.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_wdog.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_wdog.h ****  * All rights reserved.
   6:../drivers/fsl_wdog.h ****  *
   7:../drivers/fsl_wdog.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_wdog.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_wdog.h ****  * that the following conditions are met:
  10:../drivers/fsl_wdog.h ****  *
  11:../drivers/fsl_wdog.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_wdog.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_wdog.h ****  *
  14:../drivers/fsl_wdog.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_wdog.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_wdog.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_wdog.h ****  *
  18:../drivers/fsl_wdog.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_wdog.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_wdog.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_wdog.h ****  *
  22:../drivers/fsl_wdog.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_wdog.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_wdog.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_wdog.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_wdog.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_wdog.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_wdog.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_wdog.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_wdog.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_wdog.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_wdog.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_wdog.h ****  */
  34:../drivers/fsl_wdog.h **** #ifndef _FSL_WDOG_H_
  35:../drivers/fsl_wdog.h **** #define _FSL_WDOG_H_
  36:../drivers/fsl_wdog.h **** 
  37:../drivers/fsl_wdog.h **** #include "fsl_common.h"
  38:../drivers/fsl_wdog.h **** 
  39:../drivers/fsl_wdog.h **** /*!
  40:../drivers/fsl_wdog.h ****  * @addtogroup wdog
  41:../drivers/fsl_wdog.h ****  * @{
  42:../drivers/fsl_wdog.h ****  */
  43:../drivers/fsl_wdog.h **** 
  44:../drivers/fsl_wdog.h **** 
  45:../drivers/fsl_wdog.h **** /*******************************************************************************
  46:../drivers/fsl_wdog.h ****  * Definitions
  47:../drivers/fsl_wdog.h ****  *******************************************************************************/
  48:../drivers/fsl_wdog.h **** 
  49:../drivers/fsl_wdog.h **** /*! @name Driver version */
  50:../drivers/fsl_wdog.h **** /*@{*/
  51:../drivers/fsl_wdog.h **** /*! @brief Defines WDOG driver version 2.0.0. */
  52:../drivers/fsl_wdog.h **** #define FSL_WDOG_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
  53:../drivers/fsl_wdog.h **** /*@}*/
  54:../drivers/fsl_wdog.h **** 
  55:../drivers/fsl_wdog.h **** /*! @name Unlock sequence */
  56:../drivers/fsl_wdog.h **** /*@{*/
  57:../drivers/fsl_wdog.h **** #define WDOG_FIRST_WORD_OF_UNLOCK (0xC520U)  /*!< First word of unlock sequence */
  58:../drivers/fsl_wdog.h **** #define WDOG_SECOND_WORD_OF_UNLOCK (0xD928U) /*!< Second word of unlock sequence */
  59:../drivers/fsl_wdog.h **** /*@}*/
  60:../drivers/fsl_wdog.h **** 
  61:../drivers/fsl_wdog.h **** /*! @name Refresh sequence */
  62:../drivers/fsl_wdog.h **** /*@{*/
  63:../drivers/fsl_wdog.h **** #define WDOG_FIRST_WORD_OF_REFRESH (0xA602U)  /*!< First word of refresh sequence */
  64:../drivers/fsl_wdog.h **** #define WDOG_SECOND_WORD_OF_REFRESH (0xB480U) /*!< Second word of refresh sequence */
  65:../drivers/fsl_wdog.h **** /*@}*/
  66:../drivers/fsl_wdog.h **** 
  67:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG clock source. */
  68:../drivers/fsl_wdog.h **** typedef enum _wdog_clock_source
  69:../drivers/fsl_wdog.h **** {
  70:../drivers/fsl_wdog.h ****     kWDOG_LpoClockSource = 0U,       /*!< WDOG clock sourced from LPO*/
  71:../drivers/fsl_wdog.h ****     kWDOG_AlternateClockSource = 1U, /*!< WDOG clock sourced from alternate clock source*/
  72:../drivers/fsl_wdog.h **** } wdog_clock_source_t;
  73:../drivers/fsl_wdog.h **** 
  74:../drivers/fsl_wdog.h **** /*! @brief Defines WDOG work mode. */
  75:../drivers/fsl_wdog.h **** typedef struct _wdog_work_mode
  76:../drivers/fsl_wdog.h **** {
  77:../drivers/fsl_wdog.h **** #if defined(FSL_FEATURE_WDOG_HAS_WAITEN) && FSL_FEATURE_WDOG_HAS_WAITEN
  78:../drivers/fsl_wdog.h ****     bool enableWait;  /*!< Enables or disables WDOG in wait mode  */
  79:../drivers/fsl_wdog.h **** #endif                /* FSL_FEATURE_WDOG_HAS_WAITEN */
  80:../drivers/fsl_wdog.h ****     bool enableStop;  /*!< Enables or disables WDOG in stop mode  */
  81:../drivers/fsl_wdog.h ****     bool enableDebug; /*!< Enables or disables WDOG in debug mode */
  82:../drivers/fsl_wdog.h **** } wdog_work_mode_t;
  83:../drivers/fsl_wdog.h **** 
  84:../drivers/fsl_wdog.h **** /*! @brief Describes the selection of the clock prescaler. */
  85:../drivers/fsl_wdog.h **** typedef enum _wdog_clock_prescaler
  86:../drivers/fsl_wdog.h **** {
  87:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide1 = 0x0U, /*!< Divided by 1 */
  88:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide2 = 0x1U, /*!< Divided by 2 */
  89:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide3 = 0x2U, /*!< Divided by 3 */
  90:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide4 = 0x3U, /*!< Divided by 4 */
  91:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide5 = 0x4U, /*!< Divided by 5 */
  92:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide6 = 0x5U, /*!< Divided by 6 */
  93:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide7 = 0x6U, /*!< Divided by 7 */
  94:../drivers/fsl_wdog.h ****     kWDOG_ClockPrescalerDivide8 = 0x7U, /*!< Divided by 8 */
  95:../drivers/fsl_wdog.h **** } wdog_clock_prescaler_t;
  96:../drivers/fsl_wdog.h **** 
  97:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG configuration structure. */
  98:../drivers/fsl_wdog.h **** typedef struct _wdog_config
  99:../drivers/fsl_wdog.h **** {
 100:../drivers/fsl_wdog.h ****     bool enableWdog;                  /*!< Enables or disables WDOG */
 101:../drivers/fsl_wdog.h ****     wdog_clock_source_t clockSource;  /*!< Clock source select */
 102:../drivers/fsl_wdog.h ****     wdog_clock_prescaler_t prescaler; /*!< Clock prescaler value */
 103:../drivers/fsl_wdog.h ****     wdog_work_mode_t workMode;        /*!< Configures WDOG work mode in debug stop and wait mode */
 104:../drivers/fsl_wdog.h ****     bool enableUpdate;                /*!< Update write-once register enable */
 105:../drivers/fsl_wdog.h ****     bool enableInterrupt;             /*!< Enables or disables WDOG interrupt */
 106:../drivers/fsl_wdog.h ****     bool enableWindowMode;            /*!< Enables or disables WDOG window mode */
 107:../drivers/fsl_wdog.h ****     uint32_t windowValue;             /*!< Window value */
 108:../drivers/fsl_wdog.h ****     uint32_t timeoutValue;            /*!< Timeout value */
 109:../drivers/fsl_wdog.h **** } wdog_config_t;
 110:../drivers/fsl_wdog.h **** 
 111:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG test mode. */
 112:../drivers/fsl_wdog.h **** typedef enum _wdog_test_mode
 113:../drivers/fsl_wdog.h **** {
 114:../drivers/fsl_wdog.h ****     kWDOG_QuickTest = 0U, /*!< Selects quick test */
 115:../drivers/fsl_wdog.h ****     kWDOG_ByteTest = 1U,  /*!< Selects byte test */
 116:../drivers/fsl_wdog.h **** } wdog_test_mode_t;
 117:../drivers/fsl_wdog.h **** 
 118:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG tested byte selection in byte test mode. */
 119:../drivers/fsl_wdog.h **** typedef enum _wdog_tested_byte
 120:../drivers/fsl_wdog.h **** {
 121:../drivers/fsl_wdog.h ****     kWDOG_TestByte0 = 0U, /*!< Byte 0 selected in byte test mode */
 122:../drivers/fsl_wdog.h ****     kWDOG_TestByte1 = 1U, /*!< Byte 1 selected in byte test mode */
 123:../drivers/fsl_wdog.h ****     kWDOG_TestByte2 = 2U, /*!< Byte 2 selected in byte test mode */
 124:../drivers/fsl_wdog.h ****     kWDOG_TestByte3 = 3U, /*!< Byte 3 selected in byte test mode */
 125:../drivers/fsl_wdog.h **** } wdog_tested_byte_t;
 126:../drivers/fsl_wdog.h **** 
 127:../drivers/fsl_wdog.h **** /*! @brief Describes WDOG test mode configuration structure. */
 128:../drivers/fsl_wdog.h **** typedef struct _wdog_test_config
 129:../drivers/fsl_wdog.h **** {
 130:../drivers/fsl_wdog.h ****     wdog_test_mode_t testMode;     /*!< Selects test mode */
 131:../drivers/fsl_wdog.h ****     wdog_tested_byte_t testedByte; /*!< Selects tested byte in byte test mode */
 132:../drivers/fsl_wdog.h ****     uint32_t timeoutValue;         /*!< Timeout value */
 133:../drivers/fsl_wdog.h **** } wdog_test_config_t;
 134:../drivers/fsl_wdog.h **** 
 135:../drivers/fsl_wdog.h **** /*!
 136:../drivers/fsl_wdog.h ****  * @brief WDOG interrupt configuration structure, default settings all disabled.
 137:../drivers/fsl_wdog.h ****  *
 138:../drivers/fsl_wdog.h ****  * This structure contains the settings for all of the WDOG interrupt configurations.
 139:../drivers/fsl_wdog.h ****  */
 140:../drivers/fsl_wdog.h **** enum _wdog_interrupt_enable_t
 141:../drivers/fsl_wdog.h **** {
 142:../drivers/fsl_wdog.h ****     kWDOG_InterruptEnable = WDOG_STCTRLH_IRQRSTEN_MASK, /*!< WDOG timeout generates an interrupt be
 143:../drivers/fsl_wdog.h **** };
 144:../drivers/fsl_wdog.h **** 
 145:../drivers/fsl_wdog.h **** /*!
 146:../drivers/fsl_wdog.h ****  * @brief WDOG status flags.
 147:../drivers/fsl_wdog.h ****  *
 148:../drivers/fsl_wdog.h ****  * This structure contains the WDOG status flags for use in the WDOG functions.
 149:../drivers/fsl_wdog.h ****  */
 150:../drivers/fsl_wdog.h **** enum _wdog_status_flags_t
 151:../drivers/fsl_wdog.h **** {
 152:../drivers/fsl_wdog.h ****     kWDOG_RunningFlag = WDOG_STCTRLH_WDOGEN_MASK, /*!< Running flag, set when WDOG is enabled*/
 153:../drivers/fsl_wdog.h ****     kWDOG_TimeoutFlag = WDOG_STCTRLL_INTFLG_MASK, /*!< Interrupt flag, set when an exception occurs
 154:../drivers/fsl_wdog.h **** };
 155:../drivers/fsl_wdog.h **** 
 156:../drivers/fsl_wdog.h **** /*******************************************************************************
 157:../drivers/fsl_wdog.h ****  * API
 158:../drivers/fsl_wdog.h ****  *******************************************************************************/
 159:../drivers/fsl_wdog.h **** 
 160:../drivers/fsl_wdog.h **** #if defined(__cplusplus)
 161:../drivers/fsl_wdog.h **** extern "C" {
 162:../drivers/fsl_wdog.h **** #endif /* __cplusplus */
 163:../drivers/fsl_wdog.h **** 
 164:../drivers/fsl_wdog.h **** /*!
 165:../drivers/fsl_wdog.h ****  * @name WDOG Initialization and De-initialization
 166:../drivers/fsl_wdog.h ****  * @{
 167:../drivers/fsl_wdog.h ****  */
 168:../drivers/fsl_wdog.h **** 
 169:../drivers/fsl_wdog.h **** /*!
 170:../drivers/fsl_wdog.h ****  * @brief Initializes the WDOG configuration sturcture.
 171:../drivers/fsl_wdog.h ****  *
 172:../drivers/fsl_wdog.h ****  * This function initializes the WDOG configuration structure to default values. The default
 173:../drivers/fsl_wdog.h ****  * values are as follows.
 174:../drivers/fsl_wdog.h ****  * @code
 175:../drivers/fsl_wdog.h ****  *   wdogConfig->enableWdog = true;
 176:../drivers/fsl_wdog.h ****  *   wdogConfig->clockSource = kWDOG_LpoClockSource;
 177:../drivers/fsl_wdog.h ****  *   wdogConfig->prescaler = kWDOG_ClockPrescalerDivide1;
 178:../drivers/fsl_wdog.h ****  *   wdogConfig->workMode.enableWait = true;
 179:../drivers/fsl_wdog.h ****  *   wdogConfig->workMode.enableStop = false;
 180:../drivers/fsl_wdog.h ****  *   wdogConfig->workMode.enableDebug = false;
 181:../drivers/fsl_wdog.h ****  *   wdogConfig->enableUpdate = true;
 182:../drivers/fsl_wdog.h ****  *   wdogConfig->enableInterrupt = false;
 183:../drivers/fsl_wdog.h ****  *   wdogConfig->enableWindowMode = false;
 184:../drivers/fsl_wdog.h ****  *   wdogConfig->windowValue = 0;
 185:../drivers/fsl_wdog.h ****  *   wdogConfig->timeoutValue = 0xFFFFU;
 186:../drivers/fsl_wdog.h ****  * @endcode
 187:../drivers/fsl_wdog.h ****  *
 188:../drivers/fsl_wdog.h ****  * @param config Pointer to the WDOG configuration structure.
 189:../drivers/fsl_wdog.h ****  * @see wdog_config_t
 190:../drivers/fsl_wdog.h ****  */
 191:../drivers/fsl_wdog.h **** void WDOG_GetDefaultConfig(wdog_config_t *config);
 192:../drivers/fsl_wdog.h **** 
 193:../drivers/fsl_wdog.h **** /*!
 194:../drivers/fsl_wdog.h ****  * @brief Initializes the WDOG.
 195:../drivers/fsl_wdog.h ****  *
 196:../drivers/fsl_wdog.h ****  * This function initializes the WDOG. When called, the WDOG runs according to the configuration.
 197:../drivers/fsl_wdog.h ****  * To reconfigure WDOG without forcing a reset first, enableUpdate must be set to true
 198:../drivers/fsl_wdog.h ****  * in the configuration.
 199:../drivers/fsl_wdog.h ****  *
 200:../drivers/fsl_wdog.h ****  * This is an example.
 201:../drivers/fsl_wdog.h ****  * @code
 202:../drivers/fsl_wdog.h ****  *   wdog_config_t config;
 203:../drivers/fsl_wdog.h ****  *   WDOG_GetDefaultConfig(&config);
 204:../drivers/fsl_wdog.h ****  *   config.timeoutValue = 0x7ffU;
 205:../drivers/fsl_wdog.h ****  *   config.enableUpdate = true;
 206:../drivers/fsl_wdog.h ****  *   WDOG_Init(wdog_base,&config);
 207:../drivers/fsl_wdog.h ****  * @endcode
 208:../drivers/fsl_wdog.h ****  *
 209:../drivers/fsl_wdog.h ****  * @param base   WDOG peripheral base address
 210:../drivers/fsl_wdog.h ****  * @param config The configuration of WDOG
 211:../drivers/fsl_wdog.h ****  */
 212:../drivers/fsl_wdog.h **** void WDOG_Init(WDOG_Type *base, const wdog_config_t *config);
 213:../drivers/fsl_wdog.h **** 
 214:../drivers/fsl_wdog.h **** /*!
 215:../drivers/fsl_wdog.h ****  * @brief Shuts down the WDOG.
 216:../drivers/fsl_wdog.h ****  *
 217:../drivers/fsl_wdog.h ****  * This function shuts down the WDOG.
 218:../drivers/fsl_wdog.h ****  * Ensure that the WDOG_STCTRLH.ALLOWUPDATE is 1 which indicates that the register update is enable
 219:../drivers/fsl_wdog.h ****  */
 220:../drivers/fsl_wdog.h **** void WDOG_Deinit(WDOG_Type *base);
 221:../drivers/fsl_wdog.h **** 
 222:../drivers/fsl_wdog.h **** /*!
 223:../drivers/fsl_wdog.h ****  * @brief Configures the WDOG functional test.
 224:../drivers/fsl_wdog.h ****  *
 225:../drivers/fsl_wdog.h ****  * This function is used to configure the WDOG functional test. When called, the WDOG goes into tes
 226:../drivers/fsl_wdog.h ****  * and runs according to the configuration.
 227:../drivers/fsl_wdog.h ****  * Ensure that the WDOG_STCTRLH.ALLOWUPDATE is 1 which means that the register update is enabled.
 228:../drivers/fsl_wdog.h ****  *
 229:../drivers/fsl_wdog.h ****  * This is an example.
 230:../drivers/fsl_wdog.h ****  * @code
 231:../drivers/fsl_wdog.h ****  *   wdog_test_config_t test_config;
 232:../drivers/fsl_wdog.h ****  *   test_config.testMode = kWDOG_QuickTest;
 233:../drivers/fsl_wdog.h ****  *   test_config.timeoutValue = 0xfffffu;
 234:../drivers/fsl_wdog.h ****  *   WDOG_SetTestModeConfig(wdog_base, &test_config);
 235:../drivers/fsl_wdog.h ****  * @endcode
 236:../drivers/fsl_wdog.h ****  * @param base   WDOG peripheral base address
 237:../drivers/fsl_wdog.h ****  * @param config The functional test configuration of WDOG
 238:../drivers/fsl_wdog.h ****  */
 239:../drivers/fsl_wdog.h **** void WDOG_SetTestModeConfig(WDOG_Type *base, wdog_test_config_t *config);
 240:../drivers/fsl_wdog.h **** 
 241:../drivers/fsl_wdog.h **** /* @} */
 242:../drivers/fsl_wdog.h **** 
 243:../drivers/fsl_wdog.h **** /*!
 244:../drivers/fsl_wdog.h ****  * @name WDOG Functional Operation
 245:../drivers/fsl_wdog.h ****  * @{
 246:../drivers/fsl_wdog.h ****  */
 247:../drivers/fsl_wdog.h **** 
 248:../drivers/fsl_wdog.h **** /*!
 249:../drivers/fsl_wdog.h ****  * @brief Enables the WDOG module.
 250:../drivers/fsl_wdog.h ****  *
 251:../drivers/fsl_wdog.h ****  * This function write value into WDOG_STCTRLH register to enable the WDOG, it is a write-once regi
 252:../drivers/fsl_wdog.h ****  * make sure that the WCT window is still open and this register has not been written in this WCT
 253:../drivers/fsl_wdog.h ****  * while this function is called.
 254:../drivers/fsl_wdog.h ****  *
 255:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 256:../drivers/fsl_wdog.h ****  */
 257:../drivers/fsl_wdog.h **** static inline void WDOG_Enable(WDOG_Type *base)
 258:../drivers/fsl_wdog.h **** {
 259:../drivers/fsl_wdog.h ****     base->STCTRLH |= WDOG_STCTRLH_WDOGEN_MASK;
 260:../drivers/fsl_wdog.h **** }
 261:../drivers/fsl_wdog.h **** 
 262:../drivers/fsl_wdog.h **** /*!
 263:../drivers/fsl_wdog.h ****  * @brief Disables the WDOG module.
 264:../drivers/fsl_wdog.h ****  *
 265:../drivers/fsl_wdog.h ****  * This function writes a value into the WDOG_STCTRLH register to disable the WDOG. It is a write-o
 266:../drivers/fsl_wdog.h ****  * Ensure that the WCT window is still open and that register has not been written to in this WCT
 267:../drivers/fsl_wdog.h ****  * while the function is called.
 268:../drivers/fsl_wdog.h ****  *
 269:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 270:../drivers/fsl_wdog.h ****  */
 271:../drivers/fsl_wdog.h **** static inline void WDOG_Disable(WDOG_Type *base)
 272:../drivers/fsl_wdog.h **** {
 273:../drivers/fsl_wdog.h ****     base->STCTRLH &= ~WDOG_STCTRLH_WDOGEN_MASK;
 274:../drivers/fsl_wdog.h **** }
 275:../drivers/fsl_wdog.h **** 
 276:../drivers/fsl_wdog.h **** /*!
 277:../drivers/fsl_wdog.h ****  * @brief Enables the WDOG interrupt.
 278:../drivers/fsl_wdog.h ****  *
 279:../drivers/fsl_wdog.h ****  * This function writes a value into the WDOG_STCTRLH register to enable the WDOG interrupt. It is 
 280:../drivers/fsl_wdog.h ****  * Ensure that the WCT window is still open and the register has not been written to in this WCT
 281:../drivers/fsl_wdog.h ****  * while the function is called.
 282:../drivers/fsl_wdog.h ****  *
 283:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 284:../drivers/fsl_wdog.h ****  * @param mask The interrupts to enable
 285:../drivers/fsl_wdog.h ****  *        The parameter can be combination of the following source if defined.
 286:../drivers/fsl_wdog.h ****  *        @arg kWDOG_InterruptEnable
 287:../drivers/fsl_wdog.h ****  */
 288:../drivers/fsl_wdog.h **** static inline void WDOG_EnableInterrupts(WDOG_Type *base, uint32_t mask)
 289:../drivers/fsl_wdog.h **** {
 290:../drivers/fsl_wdog.h ****     base->STCTRLH |= mask;
 291:../drivers/fsl_wdog.h **** }
 292:../drivers/fsl_wdog.h **** 
 293:../drivers/fsl_wdog.h **** /*!
 294:../drivers/fsl_wdog.h ****  * @brief Disables the WDOG interrupt.
 295:../drivers/fsl_wdog.h ****  *
 296:../drivers/fsl_wdog.h ****  * This function writes a value into the WDOG_STCTRLH register to disable the WDOG interrupt. It is
 297:../drivers/fsl_wdog.h ****  * Ensure that the WCT window is still open and the register has not been written to in this WCT
 298:../drivers/fsl_wdog.h ****  * while the function is called.
 299:../drivers/fsl_wdog.h ****  *
 300:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 301:../drivers/fsl_wdog.h ****  * @param mask The interrupts to disable
 302:../drivers/fsl_wdog.h ****  *        The parameter can be combination of the following source if defined.
 303:../drivers/fsl_wdog.h ****  *        @arg kWDOG_InterruptEnable
 304:../drivers/fsl_wdog.h ****  */
 305:../drivers/fsl_wdog.h **** static inline void WDOG_DisableInterrupts(WDOG_Type *base, uint32_t mask)
 306:../drivers/fsl_wdog.h **** {
 307:../drivers/fsl_wdog.h ****     base->STCTRLH &= ~mask;
 308:../drivers/fsl_wdog.h **** }
 309:../drivers/fsl_wdog.h **** 
 310:../drivers/fsl_wdog.h **** /*!
 311:../drivers/fsl_wdog.h ****  * @brief Gets the WDOG all status flags.
 312:../drivers/fsl_wdog.h ****  *
 313:../drivers/fsl_wdog.h ****  * This function gets all status flags.
 314:../drivers/fsl_wdog.h ****  *
 315:../drivers/fsl_wdog.h ****  * This is an example for getting the Running Flag.
 316:../drivers/fsl_wdog.h ****  * @code
 317:../drivers/fsl_wdog.h ****  *   uint32_t status;
 318:../drivers/fsl_wdog.h ****  *   status = WDOG_GetStatusFlags (wdog_base) & kWDOG_RunningFlag;
 319:../drivers/fsl_wdog.h ****  * @endcode
 320:../drivers/fsl_wdog.h ****  * @param base        WDOG peripheral base address
 321:../drivers/fsl_wdog.h ****  * @return            State of the status flag: asserted (true) or not-asserted (false).@see _wdog_
 322:../drivers/fsl_wdog.h ****  *                    - true: a related status flag has been set.
 323:../drivers/fsl_wdog.h ****  *                    - false: a related status flag is not set.
 324:../drivers/fsl_wdog.h ****  */
 325:../drivers/fsl_wdog.h **** uint32_t WDOG_GetStatusFlags(WDOG_Type *base);
 326:../drivers/fsl_wdog.h **** 
 327:../drivers/fsl_wdog.h **** /*!
 328:../drivers/fsl_wdog.h ****  * @brief Clears the WDOG flag.
 329:../drivers/fsl_wdog.h ****  *
 330:../drivers/fsl_wdog.h ****  * This function clears the WDOG status flag.
 331:../drivers/fsl_wdog.h ****  *
 332:../drivers/fsl_wdog.h ****  * This is an example for clearing the timeout (interrupt) flag.
 333:../drivers/fsl_wdog.h ****  * @code
 334:../drivers/fsl_wdog.h ****  *   WDOG_ClearStatusFlags(wdog_base,kWDOG_TimeoutFlag);
 335:../drivers/fsl_wdog.h ****  * @endcode
 336:../drivers/fsl_wdog.h ****  * @param base        WDOG peripheral base address
 337:../drivers/fsl_wdog.h ****  * @param mask        The status flags to clear.
 338:../drivers/fsl_wdog.h ****  *                    The parameter could be any combination of the following values.
 339:../drivers/fsl_wdog.h ****  *                    kWDOG_TimeoutFlag
 340:../drivers/fsl_wdog.h ****  */
 341:../drivers/fsl_wdog.h **** void WDOG_ClearStatusFlags(WDOG_Type *base, uint32_t mask);
 342:../drivers/fsl_wdog.h **** 
 343:../drivers/fsl_wdog.h **** /*!
 344:../drivers/fsl_wdog.h ****  * @brief Sets the WDOG timeout value.
 345:../drivers/fsl_wdog.h ****  *
 346:../drivers/fsl_wdog.h ****  * This function sets the timeout value.
 347:../drivers/fsl_wdog.h ****  * It should be ensured that the time-out value for the WDOG is always greater than
 348:../drivers/fsl_wdog.h ****  * 2xWCT time + 20 bus clock cycles.
 349:../drivers/fsl_wdog.h ****  * This function writes a value into WDOG_TOVALH and WDOG_TOVALL registers which are wirte-once.
 350:../drivers/fsl_wdog.h ****  * Ensure the WCT window is still open and the two registers have not been written to in this WCT
 351:../drivers/fsl_wdog.h ****  * while the function is called.
 352:../drivers/fsl_wdog.h ****  *
 353:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 354:../drivers/fsl_wdog.h ****  * @param timeoutCount WDOG timeout value; count of WDOG clock tick.
 355:../drivers/fsl_wdog.h ****  */
 356:../drivers/fsl_wdog.h **** static inline void WDOG_SetTimeoutValue(WDOG_Type *base, uint32_t timeoutCount)
 357:../drivers/fsl_wdog.h **** {
 358:../drivers/fsl_wdog.h ****     base->TOVALH = (uint16_t)((timeoutCount >> 16U) & 0xFFFFU);
 359:../drivers/fsl_wdog.h ****     base->TOVALL = (uint16_t)((timeoutCount)&0xFFFFU);
 360:../drivers/fsl_wdog.h **** }
 361:../drivers/fsl_wdog.h **** 
 362:../drivers/fsl_wdog.h **** /*!
 363:../drivers/fsl_wdog.h ****  * @brief Sets the WDOG window value.
 364:../drivers/fsl_wdog.h ****  *
 365:../drivers/fsl_wdog.h ****  * This function sets the WDOG window value.
 366:../drivers/fsl_wdog.h ****  * This function writes a value into WDOG_WINH and WDOG_WINL registers which are wirte-once.
 367:../drivers/fsl_wdog.h ****  * Ensure the WCT window is still open and the two registers have not been written to in this WCT
 368:../drivers/fsl_wdog.h ****  * while the function is called.
 369:../drivers/fsl_wdog.h ****  *
 370:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 371:../drivers/fsl_wdog.h ****  * @param windowValue WDOG window value.
 372:../drivers/fsl_wdog.h ****  */
 373:../drivers/fsl_wdog.h **** static inline void WDOG_SetWindowValue(WDOG_Type *base, uint32_t windowValue)
 374:../drivers/fsl_wdog.h **** {
 375:../drivers/fsl_wdog.h ****     base->WINH = (uint16_t)((windowValue >> 16U) & 0xFFFFU);
 376:../drivers/fsl_wdog.h ****     base->WINL = (uint16_t)((windowValue)&0xFFFFU);
 377:../drivers/fsl_wdog.h **** }
 378:../drivers/fsl_wdog.h **** 
 379:../drivers/fsl_wdog.h **** /*!
 380:../drivers/fsl_wdog.h ****  * @brief Unlocks the WDOG register written.
 381:../drivers/fsl_wdog.h ****  *
 382:../drivers/fsl_wdog.h ****  * This function unlocks the WDOG register written.
 383:../drivers/fsl_wdog.h ****  * Before starting the unlock sequence and following congfiguration, disable the global interrupts.
 384:../drivers/fsl_wdog.h ****  * Otherwise, an interrupt may invalidate the unlocking sequence and the WCT may expire.
 385:../drivers/fsl_wdog.h ****  * After the configuration finishes, re-enable the global interrupts.
 386:../drivers/fsl_wdog.h ****  *
 387:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 388:../drivers/fsl_wdog.h ****  */
 389:../drivers/fsl_wdog.h **** static inline void WDOG_Unlock(WDOG_Type *base)
 390:../drivers/fsl_wdog.h **** {
 391:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_FIRST_WORD_OF_UNLOCK;
 152              		.loc 3 391 0
 153 003e 4CF22052 		movw	r2, #50464
 154 0042 C281     		strh	r2, [r0, #14]	@ movhi
 392:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_SECOND_WORD_OF_UNLOCK;
 155              		.loc 3 392 0
 156 0044 4DF62812 		movw	r2, #55592
 157 0048 C281     		strh	r2, [r0, #14]	@ movhi
 158              	.LVL4:
 159              	.LBE65:
 160              	.LBE64:
  73:../drivers/fsl_wdog.c **** #endif /* FSL_FEATURE_WDOG_HAS_WAITEN */
  74:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_DISTESTWDOG(1U);
  75:../drivers/fsl_wdog.c **** 
  76:../drivers/fsl_wdog.c ****     /* Disable the global interrupts. Otherwise, an interrupt could effectively invalidate the unlo
  77:../drivers/fsl_wdog.c ****      * and the WCT may expire. After the configuration finishes, re-enable the global interrupts. *
  78:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
  79:../drivers/fsl_wdog.c ****     WDOG_Unlock(base);
  80:../drivers/fsl_wdog.c ****     /* Wait one bus clock cycle */
  81:../drivers/fsl_wdog.c ****     base->RSTCNT = 0U;
 161              		.loc 1 81 0
 162 004a 0022     		movs	r2, #0
 163 004c 8282     		strh	r2, [r0, #20]	@ movhi
  82:../drivers/fsl_wdog.c ****     /* Set configruation */
  83:../drivers/fsl_wdog.c ****     base->PRESC = WDOG_PRESC_PRESCVAL(config->prescaler);
 164              		.loc 1 83 0
 165 004e 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
  84:../drivers/fsl_wdog.c ****     base->WINH = (uint16_t)((config->windowValue >> 16U) & 0xFFFFU);
 166              		.loc 1 84 0
 167 0050 CC68     		ldr	r4, [r1, #12]
  85:../drivers/fsl_wdog.c ****     base->WINL = (uint16_t)((config->windowValue) & 0xFFFFU);
  86:../drivers/fsl_wdog.c ****     base->TOVALH = (uint16_t)((config->timeoutValue >> 16U) & 0xFFFFU);
 168              		.loc 1 86 0
 169 0052 0969     		ldr	r1, [r1, #16]
 170              	.LVL5:
  83:../drivers/fsl_wdog.c ****     base->WINH = (uint16_t)((config->windowValue >> 16U) & 0xFFFFU);
 171              		.loc 1 83 0
 172 0054 1202     		lsls	r2, r2, #8
 173 0056 02F4E062 		and	r2, r2, #1792
 174 005a C282     		strh	r2, [r0, #22]	@ movhi
  84:../drivers/fsl_wdog.c ****     base->WINH = (uint16_t)((config->windowValue >> 16U) & 0xFFFFU);
 175              		.loc 1 84 0
 176 005c 220C     		lsrs	r2, r4, #16
 177 005e 0281     		strh	r2, [r0, #8]	@ movhi
  85:../drivers/fsl_wdog.c ****     base->WINL = (uint16_t)((config->windowValue) & 0xFFFFU);
 178              		.loc 1 85 0
 179 0060 A4B2     		uxth	r4, r4
 180              		.loc 1 86 0
 181 0062 0A0C     		lsrs	r2, r1, #16
  85:../drivers/fsl_wdog.c ****     base->WINL = (uint16_t)((config->windowValue) & 0xFFFFU);
 182              		.loc 1 85 0
 183 0064 4481     		strh	r4, [r0, #10]	@ movhi
  87:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 184              		.loc 1 87 0
 185 0066 89B2     		uxth	r1, r1
  86:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 186              		.loc 1 86 0
 187 0068 8280     		strh	r2, [r0, #4]	@ movhi
  88:../drivers/fsl_wdog.c ****     base->STCTRLH = value;
 188              		.loc 1 88 0
 189 006a AAB2     		uxth	r2, r5
  87:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 190              		.loc 1 87 0
 191 006c C180     		strh	r1, [r0, #6]	@ movhi
 192              		.loc 1 88 0
 193 006e 0280     		strh	r2, [r0]	@ movhi
 194              	.LBB66:
 195              	.LBB67:
 196              	.LBB68:
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 197              		.loc 2 411 0
 198              		.syntax unified
 199              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 200 0070 83F31088 		MSR primask, r3
 201              	@ 0 "" 2
 202              		.thumb
 203              		.syntax unified
 204              	.LBE68:
 205              	.LBE67:
 206              	.LBE66:
  89:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
  90:../drivers/fsl_wdog.c **** }
 207              		.loc 1 90 0
 208 0074 30BD     		pop	{r4, r5, pc}
 209              		.cfi_endproc
 210              	.LFE157:
 212              		.section	.text.WDOG_Deinit,"ax",%progbits
 213              		.align	1
 214              		.global	WDOG_Deinit
 215              		.syntax unified
 216              		.thumb
 217              		.thumb_func
 218              		.fpu fpv4-sp-d16
 220              	WDOG_Deinit:
 221              	.LFB158:
  91:../drivers/fsl_wdog.c **** 
  92:../drivers/fsl_wdog.c **** void WDOG_Deinit(WDOG_Type *base)
  93:../drivers/fsl_wdog.c **** {
 222              		.loc 1 93 0
 223              		.cfi_startproc
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              		@ link register save eliminated.
 227              	.LVL6:
 228              	.LBB69:
 229              	.LBB70:
 230              	.LBB71:
 231              	.LBB72:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 232              		.loc 2 383 0
 233              		.syntax unified
 234              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 235 0000 EFF31082 		MRS r2, primask
 236              	@ 0 "" 2
 237              		.thumb
 238              		.syntax unified
 239              	.LBE72:
 240              	.LBE71:
 241              	.LBB73:
 242              	.LBB74:
 139:../CMSIS/cmsis_gcc.h **** }
 243              		.loc 2 139 0
 244              		.syntax unified
 245              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 246 0004 72B6     		cpsid i
 247              	@ 0 "" 2
 248              	.LVL7:
 249              		.thumb
 250              		.syntax unified
 251              	.LBE74:
 252              	.LBE73:
 253              	.LBE70:
 254              	.LBE69:
 255              	.LBB75:
 256              	.LBB76:
 391:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_SECOND_WORD_OF_UNLOCK;
 257              		.loc 3 391 0
 258 0006 4CF22053 		movw	r3, #50464
 259 000a C381     		strh	r3, [r0, #14]	@ movhi
 260              		.loc 3 392 0
 261 000c 4DF62813 		movw	r3, #55592
 262 0010 C381     		strh	r3, [r0, #14]	@ movhi
 263              	.LVL8:
 264              	.LBE76:
 265              	.LBE75:
  94:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
  95:../drivers/fsl_wdog.c **** 
  96:../drivers/fsl_wdog.c ****     /* Disable the global interrupts */
  97:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
  98:../drivers/fsl_wdog.c ****     WDOG_Unlock(base);
  99:../drivers/fsl_wdog.c ****     /* Wait one bus clock cycle */
 100:../drivers/fsl_wdog.c ****     base->RSTCNT = 0U;
 266              		.loc 1 100 0
 267 0012 0023     		movs	r3, #0
 268 0014 8382     		strh	r3, [r0, #20]	@ movhi
 269              	.LVL9:
 270              	.LBB77:
 271              	.LBB78:
 273:../drivers/fsl_wdog.h **** }
 272              		.loc 3 273 0
 273 0016 0388     		ldrh	r3, [r0]
 274 0018 23F00103 		bic	r3, r3, #1
 275 001c 1B04     		lsls	r3, r3, #16
 276 001e 1B0C     		lsrs	r3, r3, #16
 277 0020 0380     		strh	r3, [r0]	@ movhi
 278              	.LVL10:
 279              	.LBE78:
 280              	.LBE77:
 281              	.LBB79:
 282              	.LBB80:
 283              	.LBB81:
 284              		.loc 2 411 0
 285              		.syntax unified
 286              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 287 0022 82F31088 		MSR primask, r2
 288              	@ 0 "" 2
 289              	.LVL11:
 290              		.thumb
 291              		.syntax unified
 292              	.LBE81:
 293              	.LBE80:
 294              	.LBE79:
 295              	.LBB82:
 296              	.LBB83:
 393:../drivers/fsl_wdog.h **** }
 394:../drivers/fsl_wdog.h **** 
 395:../drivers/fsl_wdog.h **** /*!
 396:../drivers/fsl_wdog.h ****  * @brief Refreshes the WDOG timer.
 397:../drivers/fsl_wdog.h ****  *
 398:../drivers/fsl_wdog.h ****  * This function feeds the WDOG.
 399:../drivers/fsl_wdog.h ****  * This function should be called before the WDOG timer is in timeout. Otherwise, a reset is assert
 400:../drivers/fsl_wdog.h ****  *
 401:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 402:../drivers/fsl_wdog.h ****  */
 403:../drivers/fsl_wdog.h **** void WDOG_Refresh(WDOG_Type *base);
 404:../drivers/fsl_wdog.h **** 
 405:../drivers/fsl_wdog.h **** /*!
 406:../drivers/fsl_wdog.h ****  * @brief Gets the WDOG reset count.
 407:../drivers/fsl_wdog.h ****  *
 408:../drivers/fsl_wdog.h ****  * This function gets the WDOG reset count value.
 409:../drivers/fsl_wdog.h ****  *
 410:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 411:../drivers/fsl_wdog.h ****  * @return     WDOG reset count value.
 412:../drivers/fsl_wdog.h ****  */
 413:../drivers/fsl_wdog.h **** static inline uint16_t WDOG_GetResetCount(WDOG_Type *base)
 414:../drivers/fsl_wdog.h **** {
 415:../drivers/fsl_wdog.h ****     return base->RSTCNT;
 416:../drivers/fsl_wdog.h **** }
 417:../drivers/fsl_wdog.h **** /*!
 418:../drivers/fsl_wdog.h ****  * @brief Clears the WDOG reset count.
 419:../drivers/fsl_wdog.h ****  *
 420:../drivers/fsl_wdog.h ****  * This function clears the WDOG reset count value.
 421:../drivers/fsl_wdog.h ****  *
 422:../drivers/fsl_wdog.h ****  * @param base WDOG peripheral base address
 423:../drivers/fsl_wdog.h ****  */
 424:../drivers/fsl_wdog.h **** static inline void WDOG_ClearResetCount(WDOG_Type *base)
 425:../drivers/fsl_wdog.h **** {
 426:../drivers/fsl_wdog.h ****     base->RSTCNT |= UINT16_MAX;
 297              		.loc 3 426 0
 298 0026 838A     		ldrh	r3, [r0, #20]
 299 0028 4FF6FF73 		movw	r3, #65535
 300 002c 8382     		strh	r3, [r0, #20]	@ movhi
 301              	.LVL12:
 302              	.LBE83:
 303              	.LBE82:
 101:../drivers/fsl_wdog.c ****     WDOG_Disable(base);
 102:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
 103:../drivers/fsl_wdog.c ****     WDOG_ClearResetCount(base);
 104:../drivers/fsl_wdog.c **** }
 304              		.loc 1 104 0
 305 002e 7047     		bx	lr
 306              		.cfi_endproc
 307              	.LFE158:
 309              		.section	.text.WDOG_SetTestModeConfig,"ax",%progbits
 310              		.align	1
 311              		.global	WDOG_SetTestModeConfig
 312              		.syntax unified
 313              		.thumb
 314              		.thumb_func
 315              		.fpu fpv4-sp-d16
 317              	WDOG_SetTestModeConfig:
 318              	.LFB159:
 105:../drivers/fsl_wdog.c **** 
 106:../drivers/fsl_wdog.c **** void WDOG_SetTestModeConfig(WDOG_Type *base, wdog_test_config_t *config)
 107:../drivers/fsl_wdog.c **** {
 319              		.loc 1 107 0
 320              		.cfi_startproc
 321              		@ args = 0, pretend = 0, frame = 0
 322              		@ frame_needed = 0, uses_anonymous_args = 0
 323              	.LVL13:
 108:../drivers/fsl_wdog.c ****     assert(config);
 109:../drivers/fsl_wdog.c **** 
 110:../drivers/fsl_wdog.c ****     uint32_t value = 0U;
 111:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
 112:../drivers/fsl_wdog.c **** 
 113:../drivers/fsl_wdog.c ****     value = WDOG_STCTRLH_DISTESTWDOG(0U) | WDOG_STCTRLH_TESTWDOG(1U) | WDOG_STCTRLH_TESTSEL(config-
 324              		.loc 1 113 0
 325 0000 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 114:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_BYTESEL(config->testedByte) | WDOG_STCTRLH_IRQRSTEN(0U) | WDOG_STCTRLH_WDO
 326              		.loc 1 114 0
 327 0002 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 113:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_BYTESEL(config->testedByte) | WDOG_STCTRLH_IRQRSTEN(0U) | WDOG_STCTRLH_WDO
 328              		.loc 1 113 0
 329 0004 DB02     		lsls	r3, r3, #11
 330              		.loc 1 114 0
 331 0006 1203     		lsls	r2, r2, #12
 332 0008 02F44052 		and	r2, r2, #12288
 333 000c 03F40063 		and	r3, r3, #2048
 334 0010 1343     		orrs	r3, r3, r2
 335 0012 43F48263 		orr	r3, r3, #1040
 107:../drivers/fsl_wdog.c ****     assert(config);
 336              		.loc 1 107 0
 337 0016 10B5     		push	{r4, lr}
 338              		.cfi_def_cfa_offset 8
 339              		.cfi_offset 4, -8
 340              		.cfi_offset 14, -4
 341 0018 43F00103 		orr	r3, r3, #1
 342              	.LVL14:
 343              	.LBB84:
 344              	.LBB85:
 345              	.LBB86:
 346              	.LBB87:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 347              		.loc 2 383 0
 348              		.syntax unified
 349              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 350 001c EFF31084 		MRS r4, primask
 351              	@ 0 "" 2
 352              		.thumb
 353              		.syntax unified
 354              	.LBE87:
 355              	.LBE86:
 356              	.LBB88:
 357              	.LBB89:
 139:../CMSIS/cmsis_gcc.h **** }
 358              		.loc 2 139 0
 359              		.syntax unified
 360              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 361 0020 72B6     		cpsid i
 362              	@ 0 "" 2
 363              	.LVL15:
 364              		.thumb
 365              		.syntax unified
 366              	.LBE89:
 367              	.LBE88:
 368              	.LBE85:
 369              	.LBE84:
 370              	.LBB90:
 371              	.LBB91:
 391:../drivers/fsl_wdog.h ****     base->UNLOCK = WDOG_SECOND_WORD_OF_UNLOCK;
 372              		.loc 3 391 0
 373 0022 4CF22052 		movw	r2, #50464
 374 0026 C281     		strh	r2, [r0, #14]	@ movhi
 392:../drivers/fsl_wdog.h **** }
 375              		.loc 3 392 0
 376 0028 4DF62812 		movw	r2, #55592
 377 002c C281     		strh	r2, [r0, #14]	@ movhi
 378              	.LVL16:
 379              	.LBE91:
 380              	.LBE90:
 115:../drivers/fsl_wdog.c ****             WDOG_STCTRLH_ALLOWUPDATE(1U);
 116:../drivers/fsl_wdog.c **** 
 117:../drivers/fsl_wdog.c ****     /* Disable the global interrupts. Otherwise, an interrupt could effectively invalidate the unlo
 118:../drivers/fsl_wdog.c ****      * and the WCT may expire. After the configuration finishes, re-enable the global interrupts. *
 119:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
 120:../drivers/fsl_wdog.c ****     WDOG_Unlock(base);
 121:../drivers/fsl_wdog.c ****     /* Wait one bus clock cycle */
 122:../drivers/fsl_wdog.c ****     base->RSTCNT = 0U;
 381              		.loc 1 122 0
 382 002e 0022     		movs	r2, #0
 383 0030 8282     		strh	r2, [r0, #20]	@ movhi
 123:../drivers/fsl_wdog.c ****     /* Set configruation */
 124:../drivers/fsl_wdog.c ****     base->TOVALH = (uint16_t)((config->timeoutValue >> 16U) & 0xFFFFU);
 384              		.loc 1 124 0
 385 0032 4A68     		ldr	r2, [r1, #4]
 386 0034 110C     		lsrs	r1, r2, #16
 387              	.LVL17:
 125:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 388              		.loc 1 125 0
 389 0036 92B2     		uxth	r2, r2
 124:../drivers/fsl_wdog.c ****     base->TOVALL = (uint16_t)((config->timeoutValue) & 0xFFFFU);
 390              		.loc 1 124 0
 391 0038 8180     		strh	r1, [r0, #4]	@ movhi
 392              		.loc 1 125 0
 393 003a C280     		strh	r2, [r0, #6]	@ movhi
 126:../drivers/fsl_wdog.c ****     base->STCTRLH = value;
 394              		.loc 1 126 0
 395 003c 0380     		strh	r3, [r0]	@ movhi
 396              	.LBB92:
 397              	.LBB93:
 398              	.LBB94:
 399              		.loc 2 411 0
 400              		.syntax unified
 401              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 402 003e 84F31088 		MSR primask, r4
 403              	@ 0 "" 2
 404              		.thumb
 405              		.syntax unified
 406              	.LBE94:
 407              	.LBE93:
 408              	.LBE92:
 127:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
 128:../drivers/fsl_wdog.c **** }
 409              		.loc 1 128 0
 410 0042 10BD     		pop	{r4, pc}
 411              		.cfi_endproc
 412              	.LFE159:
 414              		.section	.text.WDOG_GetStatusFlags,"ax",%progbits
 415              		.align	1
 416              		.global	WDOG_GetStatusFlags
 417              		.syntax unified
 418              		.thumb
 419              		.thumb_func
 420              		.fpu fpv4-sp-d16
 422              	WDOG_GetStatusFlags:
 423              	.LFB160:
 129:../drivers/fsl_wdog.c **** 
 130:../drivers/fsl_wdog.c **** uint32_t WDOG_GetStatusFlags(WDOG_Type *base)
 131:../drivers/fsl_wdog.c **** {
 424              		.loc 1 131 0
 425              		.cfi_startproc
 426              		@ args = 0, pretend = 0, frame = 0
 427              		@ frame_needed = 0, uses_anonymous_args = 0
 428              		@ link register save eliminated.
 429              	.LVL18:
 132:../drivers/fsl_wdog.c ****     uint32_t status_flag = 0U;
 133:../drivers/fsl_wdog.c **** 
 134:../drivers/fsl_wdog.c ****     status_flag |= (base->STCTRLH & WDOG_STCTRLH_WDOGEN_MASK);
 430              		.loc 1 134 0
 431 0000 0288     		ldrh	r2, [r0]
 432              	.LVL19:
 135:../drivers/fsl_wdog.c ****     status_flag |= (base->STCTRLL & WDOG_STCTRLL_INTFLG_MASK);
 433              		.loc 1 135 0
 434 0002 4388     		ldrh	r3, [r0, #2]
 435              	.LVL20:
 436 0004 02F00100 		and	r0, r2, #1
 437              	.LVL21:
 438 0008 03F40043 		and	r3, r3, #32768
 439              	.LVL22:
 136:../drivers/fsl_wdog.c **** 
 137:../drivers/fsl_wdog.c ****     return status_flag;
 138:../drivers/fsl_wdog.c **** }
 440              		.loc 1 138 0
 441 000c 1843     		orrs	r0, r0, r3
 442 000e 7047     		bx	lr
 443              		.cfi_endproc
 444              	.LFE160:
 446              		.section	.text.WDOG_ClearStatusFlags,"ax",%progbits
 447              		.align	1
 448              		.global	WDOG_ClearStatusFlags
 449              		.syntax unified
 450              		.thumb
 451              		.thumb_func
 452              		.fpu fpv4-sp-d16
 454              	WDOG_ClearStatusFlags:
 455              	.LFB161:
 139:../drivers/fsl_wdog.c **** 
 140:../drivers/fsl_wdog.c **** void WDOG_ClearStatusFlags(WDOG_Type *base, uint32_t mask)
 141:../drivers/fsl_wdog.c **** {
 456              		.loc 1 141 0
 457              		.cfi_startproc
 458              		@ args = 0, pretend = 0, frame = 0
 459              		@ frame_needed = 0, uses_anonymous_args = 0
 460              		@ link register save eliminated.
 461              	.LVL23:
 142:../drivers/fsl_wdog.c ****     if (mask & kWDOG_TimeoutFlag)
 462              		.loc 1 142 0
 463 0000 0B04     		lsls	r3, r1, #16
 143:../drivers/fsl_wdog.c ****     {
 144:../drivers/fsl_wdog.c ****         base->STCTRLL |= WDOG_STCTRLL_INTFLG_MASK;
 464              		.loc 1 144 0
 465 0002 42BF     		ittt	mi
 466 0004 4388     		ldrhmi	r3, [r0, #2]
 467 0006 43F40043 		orrmi	r3, r3, #32768
 468 000a 4380     		strhmi	r3, [r0, #2]	@ movhi
 145:../drivers/fsl_wdog.c ****     }
 146:../drivers/fsl_wdog.c **** }
 469              		.loc 1 146 0
 470 000c 7047     		bx	lr
 471              		.cfi_endproc
 472              	.LFE161:
 474              		.section	.text.WDOG_Refresh,"ax",%progbits
 475              		.align	1
 476              		.global	WDOG_Refresh
 477              		.syntax unified
 478              		.thumb
 479              		.thumb_func
 480              		.fpu fpv4-sp-d16
 482              	WDOG_Refresh:
 483              	.LFB162:
 147:../drivers/fsl_wdog.c **** 
 148:../drivers/fsl_wdog.c **** void WDOG_Refresh(WDOG_Type *base)
 149:../drivers/fsl_wdog.c **** {
 484              		.loc 1 149 0
 485              		.cfi_startproc
 486              		@ args = 0, pretend = 0, frame = 0
 487              		@ frame_needed = 0, uses_anonymous_args = 0
 488              		@ link register save eliminated.
 489              	.LVL24:
 490              	.LBB95:
 491              	.LBB96:
 492              	.LBB97:
 493              	.LBB98:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 494              		.loc 2 383 0
 495              		.syntax unified
 496              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 497 0000 EFF31083 		MRS r3, primask
 498              	@ 0 "" 2
 499              		.thumb
 500              		.syntax unified
 501              	.LBE98:
 502              	.LBE97:
 503              	.LBB99:
 504              	.LBB100:
 139:../CMSIS/cmsis_gcc.h **** }
 505              		.loc 2 139 0
 506              		.syntax unified
 507              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 508 0004 72B6     		cpsid i
 509              	@ 0 "" 2
 510              	.LVL25:
 511              		.thumb
 512              		.syntax unified
 513              	.LBE100:
 514              	.LBE99:
 515              	.LBE96:
 516              	.LBE95:
 150:../drivers/fsl_wdog.c ****     uint32_t primaskValue = 0U;
 151:../drivers/fsl_wdog.c **** 
 152:../drivers/fsl_wdog.c ****     /* Disable the global interrupt to protect refresh sequence */
 153:../drivers/fsl_wdog.c ****     primaskValue = DisableGlobalIRQ();
 154:../drivers/fsl_wdog.c ****     base->REFRESH = WDOG_FIRST_WORD_OF_REFRESH;
 517              		.loc 1 154 0
 518 0006 4AF20262 		movw	r2, #42498
 519 000a 8281     		strh	r2, [r0, #12]	@ movhi
 155:../drivers/fsl_wdog.c ****     base->REFRESH = WDOG_SECOND_WORD_OF_REFRESH;
 520              		.loc 1 155 0
 521 000c 4BF28042 		movw	r2, #46208
 522 0010 8281     		strh	r2, [r0, #12]	@ movhi
 523              	.LBB101:
 524              	.LBB102:
 525              	.LBB103:
 526              		.loc 2 411 0
 527              		.syntax unified
 528              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 529 0012 83F31088 		MSR primask, r3
 530              	@ 0 "" 2
 531              		.thumb
 532              		.syntax unified
 533              	.LBE103:
 534              	.LBE102:
 535              	.LBE101:
 156:../drivers/fsl_wdog.c ****     EnableGlobalIRQ(primaskValue);
 157:../drivers/fsl_wdog.c **** }
 536              		.loc 1 157 0
 537 0016 7047     		bx	lr
 538              		.cfi_endproc
 539              	.LFE162:
 541              		.text
 542              	.Letext0:
 543              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 544              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 545              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 546              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 547              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 548              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 549              		.file 10 "../CMSIS/core_cm4.h"
 550              		.file 11 "../CMSIS/system_MK64F12.h"
 551              		.file 12 "../CMSIS/MK64F12.h"
 552              		.file 13 "../drivers/fsl_clock.h"
 553              		.file 14 "../drivers/fsl_common.h"
