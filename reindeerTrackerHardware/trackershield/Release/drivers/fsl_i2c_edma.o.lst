   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_i2c_edma.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.I2C_MasterTransferCallbackEDMA,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	I2C_MasterTransferCallbackEDMA:
  25              	.LFB163:
  26              		.file 1 "../drivers/fsl_i2c_edma.c"
   1:../drivers/fsl_i2c_edma.c **** /*
   2:../drivers/fsl_i2c_edma.c ****  * The Clear BSD License
   3:../drivers/fsl_i2c_edma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_i2c_edma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_i2c_edma.c ****  * All rights reserved.
   6:../drivers/fsl_i2c_edma.c ****  *
   7:../drivers/fsl_i2c_edma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_i2c_edma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_i2c_edma.c ****  * that the following conditions are met:
  10:../drivers/fsl_i2c_edma.c ****  *
  11:../drivers/fsl_i2c_edma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_i2c_edma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_i2c_edma.c ****  *
  14:../drivers/fsl_i2c_edma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_i2c_edma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_i2c_edma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_i2c_edma.c ****  *
  18:../drivers/fsl_i2c_edma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_i2c_edma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_i2c_edma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_i2c_edma.c ****  *
  22:../drivers/fsl_i2c_edma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_i2c_edma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_i2c_edma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_i2c_edma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_i2c_edma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_i2c_edma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_i2c_edma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_i2c_edma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_i2c_edma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_i2c_edma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_i2c_edma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_i2c_edma.c ****  */
  34:../drivers/fsl_i2c_edma.c **** 
  35:../drivers/fsl_i2c_edma.c **** #include "fsl_i2c_edma.h"
  36:../drivers/fsl_i2c_edma.c **** 
  37:../drivers/fsl_i2c_edma.c **** /*******************************************************************************
  38:../drivers/fsl_i2c_edma.c ****  * Definitions
  39:../drivers/fsl_i2c_edma.c ****  ******************************************************************************/
  40:../drivers/fsl_i2c_edma.c **** 
  41:../drivers/fsl_i2c_edma.c **** /*<! @breif Structure definition for i2c_master_edma_private_handle_t. The structure is private. */
  42:../drivers/fsl_i2c_edma.c **** typedef struct _i2c_master_edma_private_handle
  43:../drivers/fsl_i2c_edma.c **** {
  44:../drivers/fsl_i2c_edma.c ****     I2C_Type *base;
  45:../drivers/fsl_i2c_edma.c ****     i2c_master_edma_handle_t *handle;
  46:../drivers/fsl_i2c_edma.c **** } i2c_master_edma_private_handle_t;
  47:../drivers/fsl_i2c_edma.c **** 
  48:../drivers/fsl_i2c_edma.c **** /*! @brief i2c master DMA transfer state. */
  49:../drivers/fsl_i2c_edma.c **** enum _i2c_master_dma_transfer_states
  50:../drivers/fsl_i2c_edma.c **** {
  51:../drivers/fsl_i2c_edma.c ****     kIdleState = 0x0U,         /*!< I2C bus idle. */
  52:../drivers/fsl_i2c_edma.c ****     kTransferDataState = 0x1U, /*!< 7-bit address check state. */
  53:../drivers/fsl_i2c_edma.c **** };
  54:../drivers/fsl_i2c_edma.c **** 
  55:../drivers/fsl_i2c_edma.c **** /*! @brief Common sets of flags used by the driver. */
  56:../drivers/fsl_i2c_edma.c **** enum _i2c_flag_constants
  57:../drivers/fsl_i2c_edma.c **** {
  58:../drivers/fsl_i2c_edma.c **** /*! All flags which are cleared by the driver upon starting a transfer. */
  59:../drivers/fsl_i2c_edma.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
  60:../drivers/fsl_i2c_edma.c ****     kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StartDetectFlag | kI2C_Stop
  61:../drivers/fsl_i2c_edma.c **** #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
  62:../drivers/fsl_i2c_edma.c ****     kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StopDetectFlag,
  63:../drivers/fsl_i2c_edma.c **** #else
  64:../drivers/fsl_i2c_edma.c ****     kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag,
  65:../drivers/fsl_i2c_edma.c **** #endif
  66:../drivers/fsl_i2c_edma.c **** };
  67:../drivers/fsl_i2c_edma.c **** 
  68:../drivers/fsl_i2c_edma.c **** /*******************************************************************************
  69:../drivers/fsl_i2c_edma.c ****  * Prototypes
  70:../drivers/fsl_i2c_edma.c ****  ******************************************************************************/
  71:../drivers/fsl_i2c_edma.c **** 
  72:../drivers/fsl_i2c_edma.c **** /*!
  73:../drivers/fsl_i2c_edma.c ****  * @brief EDMA callback for I2C master EDMA driver.
  74:../drivers/fsl_i2c_edma.c ****  *
  75:../drivers/fsl_i2c_edma.c ****  * @param handle EDMA handler for I2C master EDMA driver
  76:../drivers/fsl_i2c_edma.c ****  * @param userData user param passed to the callback function
  77:../drivers/fsl_i2c_edma.c ****  */
  78:../drivers/fsl_i2c_edma.c **** static void I2C_MasterTransferCallbackEDMA(edma_handle_t *handle, void *userData, bool transferDone
  79:../drivers/fsl_i2c_edma.c **** 
  80:../drivers/fsl_i2c_edma.c **** /*!
  81:../drivers/fsl_i2c_edma.c ****  * @brief Check and clear status operation.
  82:../drivers/fsl_i2c_edma.c ****  *
  83:../drivers/fsl_i2c_edma.c ****  * @param base I2C peripheral base address.
  84:../drivers/fsl_i2c_edma.c ****  * @param status current i2c hardware status.
  85:../drivers/fsl_i2c_edma.c ****  * @retval kStatus_Success No error found.
  86:../drivers/fsl_i2c_edma.c ****  * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
  87:../drivers/fsl_i2c_edma.c ****  * @retval kStatus_I2C_Nak Received Nak error.
  88:../drivers/fsl_i2c_edma.c ****  */
  89:../drivers/fsl_i2c_edma.c **** static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status);
  90:../drivers/fsl_i2c_edma.c **** 
  91:../drivers/fsl_i2c_edma.c **** /*!
  92:../drivers/fsl_i2c_edma.c ****  * @brief EDMA config for I2C master driver.
  93:../drivers/fsl_i2c_edma.c ****  *
  94:../drivers/fsl_i2c_edma.c ****  * @param base I2C peripheral base address.
  95:../drivers/fsl_i2c_edma.c ****  * @param handle pointer to i2c_master_edma_handle_t structure which stores the transfer state
  96:../drivers/fsl_i2c_edma.c ****  */
  97:../drivers/fsl_i2c_edma.c **** static void I2C_MasterTransferEDMAConfig(I2C_Type *base, i2c_master_edma_handle_t *handle);
  98:../drivers/fsl_i2c_edma.c **** 
  99:../drivers/fsl_i2c_edma.c **** /*!
 100:../drivers/fsl_i2c_edma.c ****  * @brief Set up master transfer, send slave address and sub address(if any), wait until the
 101:../drivers/fsl_i2c_edma.c ****  * wait until address sent status return.
 102:../drivers/fsl_i2c_edma.c ****  *
 103:../drivers/fsl_i2c_edma.c ****  * @param base I2C peripheral base address.
 104:../drivers/fsl_i2c_edma.c ****  * @param handle pointer to i2c_master_edma_handle_t structure which stores the transfer state
 105:../drivers/fsl_i2c_edma.c ****  * @param xfer pointer to i2c_master_transfer_t structure
 106:../drivers/fsl_i2c_edma.c ****  */
 107:../drivers/fsl_i2c_edma.c **** static status_t I2C_InitTransferStateMachineEDMA(I2C_Type *base,
 108:../drivers/fsl_i2c_edma.c ****                                                  i2c_master_edma_handle_t *handle,
 109:../drivers/fsl_i2c_edma.c ****                                                  i2c_master_transfer_t *xfer);
 110:../drivers/fsl_i2c_edma.c **** 
 111:../drivers/fsl_i2c_edma.c **** /*!
 112:../drivers/fsl_i2c_edma.c ****  * @brief Get the I2C instance from peripheral base address.
 113:../drivers/fsl_i2c_edma.c ****  *
 114:../drivers/fsl_i2c_edma.c ****  * @param base I2C peripheral base address.
 115:../drivers/fsl_i2c_edma.c ****  * @return I2C instance.
 116:../drivers/fsl_i2c_edma.c ****  */
 117:../drivers/fsl_i2c_edma.c **** extern uint32_t I2C_GetInstance(I2C_Type *base);
 118:../drivers/fsl_i2c_edma.c **** 
 119:../drivers/fsl_i2c_edma.c **** /*******************************************************************************
 120:../drivers/fsl_i2c_edma.c ****  * Variables
 121:../drivers/fsl_i2c_edma.c ****  ******************************************************************************/
 122:../drivers/fsl_i2c_edma.c **** 
 123:../drivers/fsl_i2c_edma.c **** /*<! Private handle only used for internally. */
 124:../drivers/fsl_i2c_edma.c **** static i2c_master_edma_private_handle_t s_edmaPrivateHandle[FSL_FEATURE_SOC_I2C_COUNT];
 125:../drivers/fsl_i2c_edma.c **** 
 126:../drivers/fsl_i2c_edma.c **** /*******************************************************************************
 127:../drivers/fsl_i2c_edma.c ****  * Codes
 128:../drivers/fsl_i2c_edma.c ****  ******************************************************************************/
 129:../drivers/fsl_i2c_edma.c **** 
 130:../drivers/fsl_i2c_edma.c **** static void I2C_MasterTransferCallbackEDMA(edma_handle_t *handle, void *userData, bool transferDone
 131:../drivers/fsl_i2c_edma.c **** {
  27              		.loc 1 131 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 70B5     		push	{r4, r5, r6, lr}
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
 132:../drivers/fsl_i2c_edma.c ****     i2c_master_edma_private_handle_t *i2cPrivateHandle = (i2c_master_edma_private_handle_t *)userDa
 133:../drivers/fsl_i2c_edma.c ****     status_t result = kStatus_Success;
 134:../drivers/fsl_i2c_edma.c **** 
 135:../drivers/fsl_i2c_edma.c ****     /* Disable DMA. */
 136:../drivers/fsl_i2c_edma.c ****     I2C_EnableDMA(i2cPrivateHandle->base, false);
  38              		.loc 1 136 0
  39 0002 0868     		ldr	r0, [r1]
  40              	.LVL1:
  41              	.LBB16:
  42              	.LBB17:
  43              		.file 2 "../drivers/fsl_i2c.h"
   1:../drivers/fsl_i2c.h **** /*
   2:../drivers/fsl_i2c.h ****  * The Clear BSD License
   3:../drivers/fsl_i2c.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_i2c.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_i2c.h ****  * All rights reserved.
   6:../drivers/fsl_i2c.h ****  *
   7:../drivers/fsl_i2c.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_i2c.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_i2c.h ****  * that the following conditions are met:
  10:../drivers/fsl_i2c.h ****  *
  11:../drivers/fsl_i2c.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_i2c.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_i2c.h ****  *
  14:../drivers/fsl_i2c.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_i2c.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_i2c.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_i2c.h ****  *
  18:../drivers/fsl_i2c.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_i2c.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_i2c.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_i2c.h ****  *
  22:../drivers/fsl_i2c.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_i2c.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_i2c.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_i2c.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_i2c.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_i2c.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_i2c.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_i2c.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_i2c.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_i2c.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_i2c.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_i2c.h ****  */
  34:../drivers/fsl_i2c.h **** #ifndef _FSL_I2C_H_
  35:../drivers/fsl_i2c.h **** #define _FSL_I2C_H_
  36:../drivers/fsl_i2c.h **** 
  37:../drivers/fsl_i2c.h **** #include "fsl_common.h"
  38:../drivers/fsl_i2c.h **** 
  39:../drivers/fsl_i2c.h **** /*!
  40:../drivers/fsl_i2c.h ****  * @addtogroup i2c_driver
  41:../drivers/fsl_i2c.h ****  * @{
  42:../drivers/fsl_i2c.h ****  */
  43:../drivers/fsl_i2c.h **** 
  44:../drivers/fsl_i2c.h **** /*******************************************************************************
  45:../drivers/fsl_i2c.h ****  * Definitions
  46:../drivers/fsl_i2c.h ****  ******************************************************************************/
  47:../drivers/fsl_i2c.h **** 
  48:../drivers/fsl_i2c.h **** /*! @name Driver version */
  49:../drivers/fsl_i2c.h **** /*@{*/
  50:../drivers/fsl_i2c.h **** /*! @brief I2C driver version 2.0.5. */
  51:../drivers/fsl_i2c.h **** #define FSL_I2C_DRIVER_VERSION (MAKE_VERSION(2, 0, 5))
  52:../drivers/fsl_i2c.h **** /*@}*/
  53:../drivers/fsl_i2c.h **** 
  54:../drivers/fsl_i2c.h **** /*! @brief Timeout times for waiting flag. */
  55:../drivers/fsl_i2c.h **** #ifndef I2C_WAIT_TIMEOUT
  56:../drivers/fsl_i2c.h **** #define I2C_WAIT_TIMEOUT 0U /* Define to zero means keep waiting until the flag is assert/deassert.
  57:../drivers/fsl_i2c.h **** #endif
  58:../drivers/fsl_i2c.h **** 
  59:../drivers/fsl_i2c.h **** #if (defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT || \
  60:../drivers/fsl_i2c.h ****      defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT)
  61:../drivers/fsl_i2c.h **** #define I2C_HAS_STOP_DETECT
  62:../drivers/fsl_i2c.h **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT / FSL_FEATURE_I2C_HAS_STOP_DETECT */
  63:../drivers/fsl_i2c.h **** 
  64:../drivers/fsl_i2c.h **** /*! @brief  I2C status return codes. */
  65:../drivers/fsl_i2c.h **** enum _i2c_status
  66:../drivers/fsl_i2c.h **** {
  67:../drivers/fsl_i2c.h ****     kStatus_I2C_Busy = MAKE_STATUS(kStatusGroup_I2C, 0),            /*!< I2C is busy with current t
  68:../drivers/fsl_i2c.h ****     kStatus_I2C_Idle = MAKE_STATUS(kStatusGroup_I2C, 1),            /*!< Bus is Idle. */
  69:../drivers/fsl_i2c.h ****     kStatus_I2C_Nak = MAKE_STATUS(kStatusGroup_I2C, 2),             /*!< NAK received during transf
  70:../drivers/fsl_i2c.h ****     kStatus_I2C_ArbitrationLost = MAKE_STATUS(kStatusGroup_I2C, 3), /*!< Arbitration lost during tr
  71:../drivers/fsl_i2c.h ****     kStatus_I2C_Timeout = MAKE_STATUS(kStatusGroup_I2C, 4),         /*!< Timeout poling status flag
  72:../drivers/fsl_i2c.h ****     kStatus_I2C_Addr_Nak = MAKE_STATUS(kStatusGroup_I2C, 5),        /*!< NAK received during the ad
  73:../drivers/fsl_i2c.h **** };
  74:../drivers/fsl_i2c.h **** 
  75:../drivers/fsl_i2c.h **** /*!
  76:../drivers/fsl_i2c.h ****  * @brief I2C peripheral flags
  77:../drivers/fsl_i2c.h ****  *
  78:../drivers/fsl_i2c.h ****  * The following status register flags can be cleared:
  79:../drivers/fsl_i2c.h ****  * - #kI2C_ArbitrationLostFlag
  80:../drivers/fsl_i2c.h ****  * - #kI2C_IntPendingFlag
  81:../drivers/fsl_i2c.h ****  * - #kI2C_StartDetectFlag
  82:../drivers/fsl_i2c.h ****  * - #kI2C_StopDetectFlag
  83:../drivers/fsl_i2c.h ****  *
  84:../drivers/fsl_i2c.h ****  * @note These enumerations are meant to be OR'd together to form a bit mask.
  85:../drivers/fsl_i2c.h ****  *
  86:../drivers/fsl_i2c.h ****  */
  87:../drivers/fsl_i2c.h **** enum _i2c_flags
  88:../drivers/fsl_i2c.h **** {
  89:../drivers/fsl_i2c.h ****     kI2C_ReceiveNakFlag = I2C_S_RXAK_MASK,       /*!< I2C receive NAK flag. */
  90:../drivers/fsl_i2c.h ****     kI2C_IntPendingFlag = I2C_S_IICIF_MASK,      /*!< I2C interrupt pending flag. */
  91:../drivers/fsl_i2c.h ****     kI2C_TransferDirectionFlag = I2C_S_SRW_MASK, /*!< I2C transfer direction flag. */
  92:../drivers/fsl_i2c.h ****     kI2C_RangeAddressMatchFlag = I2C_S_RAM_MASK, /*!< I2C range address match flag. */
  93:../drivers/fsl_i2c.h ****     kI2C_ArbitrationLostFlag = I2C_S_ARBL_MASK,  /*!< I2C arbitration lost flag. */
  94:../drivers/fsl_i2c.h ****     kI2C_BusBusyFlag = I2C_S_BUSY_MASK,          /*!< I2C bus busy flag. */
  95:../drivers/fsl_i2c.h ****     kI2C_AddressMatchFlag = I2C_S_IAAS_MASK,     /*!< I2C address match flag. */
  96:../drivers/fsl_i2c.h ****     kI2C_TransferCompleteFlag = I2C_S_TCF_MASK,  /*!< I2C transfer complete flag. */
  97:../drivers/fsl_i2c.h **** #ifdef I2C_HAS_STOP_DETECT
  98:../drivers/fsl_i2c.h ****     kI2C_StopDetectFlag = I2C_FLT_STOPF_MASK << 8, /*!< I2C stop detect flag. */
  99:../drivers/fsl_i2c.h **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT / FSL_FEATURE_I2C_HAS_STOP_DETECT */
 100:../drivers/fsl_i2c.h **** 
 101:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 102:../drivers/fsl_i2c.h ****     kI2C_StartDetectFlag = I2C_FLT_STARTF_MASK << 8, /*!< I2C start detect flag. */
 103:../drivers/fsl_i2c.h **** #endif                                               /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 104:../drivers/fsl_i2c.h **** };
 105:../drivers/fsl_i2c.h **** 
 106:../drivers/fsl_i2c.h **** /*! @brief I2C feature interrupt source. */
 107:../drivers/fsl_i2c.h **** enum _i2c_interrupt_enable
 108:../drivers/fsl_i2c.h **** {
 109:../drivers/fsl_i2c.h ****     kI2C_GlobalInterruptEnable = I2C_C1_IICIE_MASK, /*!< I2C global interrupt. */
 110:../drivers/fsl_i2c.h **** 
 111:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 112:../drivers/fsl_i2c.h ****     kI2C_StopDetectInterruptEnable = I2C_FLT_STOPIE_MASK, /*!< I2C stop detect interrupt. */
 113:../drivers/fsl_i2c.h **** #endif                                                    /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
 114:../drivers/fsl_i2c.h **** 
 115:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 116:../drivers/fsl_i2c.h ****     kI2C_StartStopDetectInterruptEnable = I2C_FLT_SSIE_MASK, /*!< I2C start&stop detect interrupt. 
 117:../drivers/fsl_i2c.h **** #endif                                                       /* FSL_FEATURE_I2C_HAS_START_STOP_DETE
 118:../drivers/fsl_i2c.h **** };
 119:../drivers/fsl_i2c.h **** 
 120:../drivers/fsl_i2c.h **** /*! @brief The direction of master and slave transfers. */
 121:../drivers/fsl_i2c.h **** typedef enum _i2c_direction
 122:../drivers/fsl_i2c.h **** {
 123:../drivers/fsl_i2c.h ****     kI2C_Write = 0x0U, /*!< Master transmits to the slave. */
 124:../drivers/fsl_i2c.h ****     kI2C_Read = 0x1U,  /*!< Master receives from the slave. */
 125:../drivers/fsl_i2c.h **** } i2c_direction_t;
 126:../drivers/fsl_i2c.h **** 
 127:../drivers/fsl_i2c.h **** /*! @brief Addressing mode. */
 128:../drivers/fsl_i2c.h **** typedef enum _i2c_slave_address_mode
 129:../drivers/fsl_i2c.h **** {
 130:../drivers/fsl_i2c.h ****     kI2C_Address7bit = 0x0U, /*!< 7-bit addressing mode. */
 131:../drivers/fsl_i2c.h ****     kI2C_RangeMatch = 0X2U,  /*!< Range address match addressing mode. */
 132:../drivers/fsl_i2c.h **** } i2c_slave_address_mode_t;
 133:../drivers/fsl_i2c.h **** 
 134:../drivers/fsl_i2c.h **** /*! @brief I2C transfer control flag. */
 135:../drivers/fsl_i2c.h **** enum _i2c_master_transfer_flags
 136:../drivers/fsl_i2c.h **** {
 137:../drivers/fsl_i2c.h ****     kI2C_TransferDefaultFlag = 0x0U,       /*!< A transfer starts with a start signal, stops with a
 138:../drivers/fsl_i2c.h ****     kI2C_TransferNoStartFlag = 0x1U,       /*!< A transfer starts without a start signal, only supp
 139:../drivers/fsl_i2c.h ****                                         write+read with no start flag, do not support read only wit
 140:../drivers/fsl_i2c.h ****     kI2C_TransferRepeatedStartFlag = 0x2U, /*!< A transfer starts with a repeated start signal. */
 141:../drivers/fsl_i2c.h ****     kI2C_TransferNoStopFlag = 0x4U,        /*!< A transfer ends without a stop signal. */
 142:../drivers/fsl_i2c.h **** };
 143:../drivers/fsl_i2c.h **** 
 144:../drivers/fsl_i2c.h **** /*!
 145:../drivers/fsl_i2c.h ****  * @brief Set of events sent to the callback for nonblocking slave transfers.
 146:../drivers/fsl_i2c.h ****  *
 147:../drivers/fsl_i2c.h ****  * These event enumerations are used for two related purposes. First, a bit mask created by OR'ing 
 148:../drivers/fsl_i2c.h ****  * events is passed to I2C_SlaveTransferNonBlocking() to specify which events to enable.
 149:../drivers/fsl_i2c.h ****  * Then, when the slave callback is invoked, it is passed the current event through its @a transfer
 150:../drivers/fsl_i2c.h ****  * parameter.
 151:../drivers/fsl_i2c.h ****  *
 152:../drivers/fsl_i2c.h ****  * @note These enumerations are meant to be OR'd together to form a bit mask of events.
 153:../drivers/fsl_i2c.h ****  */
 154:../drivers/fsl_i2c.h **** typedef enum _i2c_slave_transfer_event
 155:../drivers/fsl_i2c.h **** {
 156:../drivers/fsl_i2c.h ****     kI2C_SlaveAddressMatchEvent = 0x01U, /*!< Received the slave address after a start or repeated 
 157:../drivers/fsl_i2c.h ****     kI2C_SlaveTransmitEvent = 0x02U,     /*!< A callback is requested to provide data to transmit
 158:../drivers/fsl_i2c.h ****                                                 (slave-transmitter role). */
 159:../drivers/fsl_i2c.h ****     kI2C_SlaveReceiveEvent = 0x04U,      /*!< A callback is requested to provide a buffer in which 
 160:../drivers/fsl_i2c.h ****                                                  data (slave-receiver role). */
 161:../drivers/fsl_i2c.h ****     kI2C_SlaveTransmitAckEvent = 0x08U,  /*!< A callback needs to either transmit an ACK or NACK. *
 162:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 163:../drivers/fsl_i2c.h ****     kI2C_SlaveStartEvent = 0x10U, /*!< A start/repeated start was detected. */
 164:../drivers/fsl_i2c.h **** #endif
 165:../drivers/fsl_i2c.h ****     kI2C_SlaveCompletionEvent = 0x20U,  /*!< A stop was detected or finished transfer, completing t
 166:../drivers/fsl_i2c.h ****     kI2C_SlaveGenaralcallEvent = 0x40U, /*!< Received the general call address after a start or rep
 167:../drivers/fsl_i2c.h **** 
 168:../drivers/fsl_i2c.h ****     /*! A bit mask of all available events. */
 169:../drivers/fsl_i2c.h ****     kI2C_SlaveAllEvents = kI2C_SlaveAddressMatchEvent | kI2C_SlaveTransmitEvent | kI2C_SlaveReceive
 170:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 171:../drivers/fsl_i2c.h ****                           kI2C_SlaveStartEvent |
 172:../drivers/fsl_i2c.h **** #endif
 173:../drivers/fsl_i2c.h ****                           kI2C_SlaveCompletionEvent | kI2C_SlaveGenaralcallEvent,
 174:../drivers/fsl_i2c.h **** } i2c_slave_transfer_event_t;
 175:../drivers/fsl_i2c.h **** 
 176:../drivers/fsl_i2c.h **** /*! @brief I2C master user configuration. */
 177:../drivers/fsl_i2c.h **** typedef struct _i2c_master_config
 178:../drivers/fsl_i2c.h **** {
 179:../drivers/fsl_i2c.h ****     bool enableMaster; /*!< Enables the I2C peripheral at initialization time. */
 180:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
 181:../drivers/fsl_i2c.h ****     bool enableStopHold; /*!< Controls the stop hold enable. */
 182:../drivers/fsl_i2c.h **** #endif
 183:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 184:../drivers/fsl_i2c.h ****     bool enableDoubleBuffering; /*!< Controls double buffer enable; notice that
 185:../drivers/fsl_i2c.h ****                                      enabling the double buffer disables the clock stretch. */
 186:../drivers/fsl_i2c.h **** #endif
 187:../drivers/fsl_i2c.h ****     uint32_t baudRate_Bps;     /*!< Baud rate configuration of I2C peripheral. */
 188:../drivers/fsl_i2c.h ****     uint8_t glitchFilterWidth; /*!< Controls the width of the glitch. */
 189:../drivers/fsl_i2c.h **** } i2c_master_config_t;
 190:../drivers/fsl_i2c.h **** 
 191:../drivers/fsl_i2c.h **** /*! @brief I2C slave user configuration. */
 192:../drivers/fsl_i2c.h **** typedef struct _i2c_slave_config
 193:../drivers/fsl_i2c.h **** {
 194:../drivers/fsl_i2c.h ****     bool enableSlave;       /*!< Enables the I2C peripheral at initialization time. */
 195:../drivers/fsl_i2c.h ****     bool enableGeneralCall; /*!< Enables the general call addressing mode. */
 196:../drivers/fsl_i2c.h ****     bool enableWakeUp;      /*!< Enables/disables waking up MCU from low-power mode. */
 197:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 198:../drivers/fsl_i2c.h ****     bool enableDoubleBuffering; /*!< Controls a double buffer enable; notice that
 199:../drivers/fsl_i2c.h ****                                      enabling the double buffer disables the clock stretch. */
 200:../drivers/fsl_i2c.h **** #endif
 201:../drivers/fsl_i2c.h ****     bool enableBaudRateCtl; /*!< Enables/disables independent slave baud rate on SCL in very fast I
 202:../drivers/fsl_i2c.h ****     uint16_t slaveAddress;  /*!< A slave address configuration. */
 203:../drivers/fsl_i2c.h ****     uint16_t upperAddress;  /*!< A maximum boundary slave address used in a range matching mode. */
 204:../drivers/fsl_i2c.h ****     i2c_slave_address_mode_t
 205:../drivers/fsl_i2c.h ****         addressingMode;          /*!< An addressing mode configuration of i2c_slave_address_mode_co
 206:../drivers/fsl_i2c.h ****     uint32_t sclStopHoldTime_ns; /*!< the delay from the rising edge of SCL (I2C clock) to the risi
 207:../drivers/fsl_i2c.h ****                                     data) while SCL is high (stop condition), SDA hold time and SCL
 208:../drivers/fsl_i2c.h ****                                     are also configured according to the SCL stop hold time. */
 209:../drivers/fsl_i2c.h **** } i2c_slave_config_t;
 210:../drivers/fsl_i2c.h **** 
 211:../drivers/fsl_i2c.h **** /*! @brief I2C master handle typedef. */
 212:../drivers/fsl_i2c.h **** typedef struct _i2c_master_handle i2c_master_handle_t;
 213:../drivers/fsl_i2c.h **** 
 214:../drivers/fsl_i2c.h **** /*! @brief I2C master transfer callback typedef. */
 215:../drivers/fsl_i2c.h **** typedef void (*i2c_master_transfer_callback_t)(I2C_Type *base,
 216:../drivers/fsl_i2c.h ****                                                i2c_master_handle_t *handle,
 217:../drivers/fsl_i2c.h ****                                                status_t status,
 218:../drivers/fsl_i2c.h ****                                                void *userData);
 219:../drivers/fsl_i2c.h **** 
 220:../drivers/fsl_i2c.h **** /*! @brief I2C slave handle typedef. */
 221:../drivers/fsl_i2c.h **** typedef struct _i2c_slave_handle i2c_slave_handle_t;
 222:../drivers/fsl_i2c.h **** 
 223:../drivers/fsl_i2c.h **** /*! @brief I2C master transfer structure. */
 224:../drivers/fsl_i2c.h **** typedef struct _i2c_master_transfer
 225:../drivers/fsl_i2c.h **** {
 226:../drivers/fsl_i2c.h ****     uint32_t flags;            /*!< A transfer flag which controls the transfer. */
 227:../drivers/fsl_i2c.h ****     uint8_t slaveAddress;      /*!< 7-bit slave address. */
 228:../drivers/fsl_i2c.h ****     i2c_direction_t direction; /*!< A transfer direction, read or write. */
 229:../drivers/fsl_i2c.h ****     uint32_t subaddress;       /*!< A sub address. Transferred MSB first. */
 230:../drivers/fsl_i2c.h ****     uint8_t subaddressSize;    /*!< A size of the command buffer. */
 231:../drivers/fsl_i2c.h ****     uint8_t *volatile data;    /*!< A transfer buffer. */
 232:../drivers/fsl_i2c.h ****     volatile size_t dataSize;  /*!< A transfer size. */
 233:../drivers/fsl_i2c.h **** } i2c_master_transfer_t;
 234:../drivers/fsl_i2c.h **** 
 235:../drivers/fsl_i2c.h **** /*! @brief I2C master handle structure. */
 236:../drivers/fsl_i2c.h **** struct _i2c_master_handle
 237:../drivers/fsl_i2c.h **** {
 238:../drivers/fsl_i2c.h ****     i2c_master_transfer_t transfer;                    /*!< I2C master transfer copy. */
 239:../drivers/fsl_i2c.h ****     size_t transferSize;                               /*!< Total bytes to be transferred. */
 240:../drivers/fsl_i2c.h ****     uint8_t state;                                     /*!< A transfer state maintained during tran
 241:../drivers/fsl_i2c.h ****     i2c_master_transfer_callback_t completionCallback; /*!< A callback function called when the tra
 242:../drivers/fsl_i2c.h ****     void *userData;                                    /*!< A callback parameter passed to the call
 243:../drivers/fsl_i2c.h **** };
 244:../drivers/fsl_i2c.h **** 
 245:../drivers/fsl_i2c.h **** /*! @brief I2C slave transfer structure. */
 246:../drivers/fsl_i2c.h **** typedef struct _i2c_slave_transfer
 247:../drivers/fsl_i2c.h **** {
 248:../drivers/fsl_i2c.h ****     i2c_slave_transfer_event_t event; /*!< A reason that the callback is invoked. */
 249:../drivers/fsl_i2c.h ****     uint8_t *volatile data;           /*!< A transfer buffer. */
 250:../drivers/fsl_i2c.h ****     volatile size_t dataSize;         /*!< A transfer size. */
 251:../drivers/fsl_i2c.h ****     status_t completionStatus;        /*!< Success or error code describing how the transfer comple
 252:../drivers/fsl_i2c.h ****                                          #kI2C_SlaveCompletionEvent. */
 253:../drivers/fsl_i2c.h ****     size_t transferredCount; /*!< A number of bytes actually transferred since the start or since t
 254:../drivers/fsl_i2c.h ****                                 start. */
 255:../drivers/fsl_i2c.h **** } i2c_slave_transfer_t;
 256:../drivers/fsl_i2c.h **** 
 257:../drivers/fsl_i2c.h **** /*! @brief I2C slave transfer callback typedef. */
 258:../drivers/fsl_i2c.h **** typedef void (*i2c_slave_transfer_callback_t)(I2C_Type *base, i2c_slave_transfer_t *xfer, void *use
 259:../drivers/fsl_i2c.h **** 
 260:../drivers/fsl_i2c.h **** /*! @brief I2C slave handle structure. */
 261:../drivers/fsl_i2c.h **** struct _i2c_slave_handle
 262:../drivers/fsl_i2c.h **** {
 263:../drivers/fsl_i2c.h ****     volatile bool isBusy;                   /*!< Indicates whether a transfer is busy. */
 264:../drivers/fsl_i2c.h ****     i2c_slave_transfer_t transfer;          /*!< I2C slave transfer copy. */
 265:../drivers/fsl_i2c.h ****     uint32_t eventMask;                     /*!< A mask of enabled events. */
 266:../drivers/fsl_i2c.h ****     i2c_slave_transfer_callback_t callback; /*!< A callback function called at the transfer event. 
 267:../drivers/fsl_i2c.h ****     void *userData;                         /*!< A callback parameter passed to the callback. */
 268:../drivers/fsl_i2c.h **** };
 269:../drivers/fsl_i2c.h **** 
 270:../drivers/fsl_i2c.h **** /*******************************************************************************
 271:../drivers/fsl_i2c.h ****  * API
 272:../drivers/fsl_i2c.h ****  ******************************************************************************/
 273:../drivers/fsl_i2c.h **** 
 274:../drivers/fsl_i2c.h **** #if defined(__cplusplus)
 275:../drivers/fsl_i2c.h **** extern "C" {
 276:../drivers/fsl_i2c.h **** #endif /*_cplusplus. */
 277:../drivers/fsl_i2c.h **** 
 278:../drivers/fsl_i2c.h **** /*!
 279:../drivers/fsl_i2c.h ****  * @name Initialization and deinitialization
 280:../drivers/fsl_i2c.h ****  * @{
 281:../drivers/fsl_i2c.h ****  */
 282:../drivers/fsl_i2c.h **** 
 283:../drivers/fsl_i2c.h **** /*!
 284:../drivers/fsl_i2c.h ****  * @brief Initializes the I2C peripheral. Call this API to ungate the I2C clock
 285:../drivers/fsl_i2c.h ****  * and configure the I2C with master configuration.
 286:../drivers/fsl_i2c.h ****  *
 287:../drivers/fsl_i2c.h ****  * @note This API should be called at the beginning of the application.
 288:../drivers/fsl_i2c.h ****  * Otherwise, any operation to the I2C module can cause a hard fault
 289:../drivers/fsl_i2c.h ****  * because the clock is not enabled. The configuration structure can be custom filled
 290:../drivers/fsl_i2c.h ****  * or it can be set with default values by using the I2C_MasterGetDefaultConfig().
 291:../drivers/fsl_i2c.h ****  * After calling this API, the master is ready to transfer.
 292:../drivers/fsl_i2c.h ****  * This is an example.
 293:../drivers/fsl_i2c.h ****  * @code
 294:../drivers/fsl_i2c.h ****  * i2c_master_config_t config = {
 295:../drivers/fsl_i2c.h ****  * .enableMaster = true,
 296:../drivers/fsl_i2c.h ****  * .enableStopHold = false,
 297:../drivers/fsl_i2c.h ****  * .highDrive = false,
 298:../drivers/fsl_i2c.h ****  * .baudRate_Bps = 100000,
 299:../drivers/fsl_i2c.h ****  * .glitchFilterWidth = 0
 300:../drivers/fsl_i2c.h ****  * };
 301:../drivers/fsl_i2c.h ****  * I2C_MasterInit(I2C0, &config, 12000000U);
 302:../drivers/fsl_i2c.h ****  * @endcode
 303:../drivers/fsl_i2c.h ****  *
 304:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 305:../drivers/fsl_i2c.h ****  * @param masterConfig A pointer to the master configuration structure
 306:../drivers/fsl_i2c.h ****  * @param srcClock_Hz I2C peripheral clock frequency in Hz
 307:../drivers/fsl_i2c.h ****  */
 308:../drivers/fsl_i2c.h **** void I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz);
 309:../drivers/fsl_i2c.h **** 
 310:../drivers/fsl_i2c.h **** /*!
 311:../drivers/fsl_i2c.h ****  * @brief Initializes the I2C peripheral. Call this API to ungate the I2C clock
 312:../drivers/fsl_i2c.h ****  * and initialize the I2C with the slave configuration.
 313:../drivers/fsl_i2c.h ****  *
 314:../drivers/fsl_i2c.h ****  * @note This API should be called at the beginning of the application.
 315:../drivers/fsl_i2c.h ****  * Otherwise, any operation to the I2C module can cause a hard fault
 316:../drivers/fsl_i2c.h ****  * because the clock is not enabled. The configuration structure can partly be set
 317:../drivers/fsl_i2c.h ****  * with default values by I2C_SlaveGetDefaultConfig() or it can be custom filled by the user.
 318:../drivers/fsl_i2c.h ****  * This is an example.
 319:../drivers/fsl_i2c.h ****  * @code
 320:../drivers/fsl_i2c.h ****  * i2c_slave_config_t config = {
 321:../drivers/fsl_i2c.h ****  * .enableSlave = true,
 322:../drivers/fsl_i2c.h ****  * .enableGeneralCall = false,
 323:../drivers/fsl_i2c.h ****  * .addressingMode = kI2C_Address7bit,
 324:../drivers/fsl_i2c.h ****  * .slaveAddress = 0x1DU,
 325:../drivers/fsl_i2c.h ****  * .enableWakeUp = false,
 326:../drivers/fsl_i2c.h ****  * .enablehighDrive = false,
 327:../drivers/fsl_i2c.h ****  * .enableBaudRateCtl = false,
 328:../drivers/fsl_i2c.h ****  * .sclStopHoldTime_ns = 4000
 329:../drivers/fsl_i2c.h ****  * };
 330:../drivers/fsl_i2c.h ****  * I2C_SlaveInit(I2C0, &config, 12000000U);
 331:../drivers/fsl_i2c.h ****  * @endcode
 332:../drivers/fsl_i2c.h ****  *
 333:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 334:../drivers/fsl_i2c.h ****  * @param slaveConfig A pointer to the slave configuration structure
 335:../drivers/fsl_i2c.h ****  * @param srcClock_Hz I2C peripheral clock frequency in Hz
 336:../drivers/fsl_i2c.h ****  */
 337:../drivers/fsl_i2c.h **** void I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig, uint32_t srcClock_Hz);
 338:../drivers/fsl_i2c.h **** 
 339:../drivers/fsl_i2c.h **** /*!
 340:../drivers/fsl_i2c.h ****  * @brief De-initializes the I2C master peripheral. Call this API to gate the I2C clock.
 341:../drivers/fsl_i2c.h ****  * The I2C master module can't work unless the I2C_MasterInit is called.
 342:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 343:../drivers/fsl_i2c.h ****  */
 344:../drivers/fsl_i2c.h **** void I2C_MasterDeinit(I2C_Type *base);
 345:../drivers/fsl_i2c.h **** 
 346:../drivers/fsl_i2c.h **** /*!
 347:../drivers/fsl_i2c.h ****  * @brief De-initializes the I2C slave peripheral. Calling this API gates the I2C clock.
 348:../drivers/fsl_i2c.h ****  * The I2C slave module can't work unless the I2C_SlaveInit is called to enable the clock.
 349:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 350:../drivers/fsl_i2c.h ****  */
 351:../drivers/fsl_i2c.h **** void I2C_SlaveDeinit(I2C_Type *base);
 352:../drivers/fsl_i2c.h **** 
 353:../drivers/fsl_i2c.h **** /*!
 354:../drivers/fsl_i2c.h ****  * @brief  Sets the I2C master configuration structure to default values.
 355:../drivers/fsl_i2c.h ****  *
 356:../drivers/fsl_i2c.h ****  * The purpose of this API is to get the configuration structure initialized for use in the I2C_Mas
 357:../drivers/fsl_i2c.h ****  * Use the initialized structure unchanged in the I2C_MasterConfigure() or modify
 358:../drivers/fsl_i2c.h ****  * the structure before calling the I2C_MasterConfigure().
 359:../drivers/fsl_i2c.h ****  * This is an example.
 360:../drivers/fsl_i2c.h ****  * @code
 361:../drivers/fsl_i2c.h ****  * i2c_master_config_t config;
 362:../drivers/fsl_i2c.h ****  * I2C_MasterGetDefaultConfig(&config);
 363:../drivers/fsl_i2c.h ****  * @endcode
 364:../drivers/fsl_i2c.h ****  * @param masterConfig A pointer to the master configuration structure.
 365:../drivers/fsl_i2c.h **** */
 366:../drivers/fsl_i2c.h **** void I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig);
 367:../drivers/fsl_i2c.h **** 
 368:../drivers/fsl_i2c.h **** /*!
 369:../drivers/fsl_i2c.h ****  * @brief  Sets the I2C slave configuration structure to default values.
 370:../drivers/fsl_i2c.h ****  *
 371:../drivers/fsl_i2c.h ****  * The purpose of this API is to get the configuration structure initialized for use in the I2C_Sla
 372:../drivers/fsl_i2c.h ****  * Modify fields of the structure before calling the I2C_SlaveConfigure().
 373:../drivers/fsl_i2c.h ****  * This is an example.
 374:../drivers/fsl_i2c.h ****  * @code
 375:../drivers/fsl_i2c.h ****  * i2c_slave_config_t config;
 376:../drivers/fsl_i2c.h ****  * I2C_SlaveGetDefaultConfig(&config);
 377:../drivers/fsl_i2c.h ****  * @endcode
 378:../drivers/fsl_i2c.h ****  * @param slaveConfig A pointer to the slave configuration structure.
 379:../drivers/fsl_i2c.h ****  */
 380:../drivers/fsl_i2c.h **** void I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig);
 381:../drivers/fsl_i2c.h **** 
 382:../drivers/fsl_i2c.h **** /*!
 383:../drivers/fsl_i2c.h ****  * @brief Enables or disabless the I2C peripheral operation.
 384:../drivers/fsl_i2c.h ****  *
 385:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 386:../drivers/fsl_i2c.h ****  * @param enable Pass true to enable and false to disable the module.
 387:../drivers/fsl_i2c.h ****  */
 388:../drivers/fsl_i2c.h **** static inline void I2C_Enable(I2C_Type *base, bool enable)
 389:../drivers/fsl_i2c.h **** {
 390:../drivers/fsl_i2c.h ****     if (enable)
 391:../drivers/fsl_i2c.h ****     {
 392:../drivers/fsl_i2c.h ****         base->C1 |= I2C_C1_IICEN_MASK;
 393:../drivers/fsl_i2c.h ****     }
 394:../drivers/fsl_i2c.h ****     else
 395:../drivers/fsl_i2c.h ****     {
 396:../drivers/fsl_i2c.h ****         base->C1 &= ~I2C_C1_IICEN_MASK;
 397:../drivers/fsl_i2c.h ****     }
 398:../drivers/fsl_i2c.h **** }
 399:../drivers/fsl_i2c.h **** 
 400:../drivers/fsl_i2c.h **** /* @} */
 401:../drivers/fsl_i2c.h **** 
 402:../drivers/fsl_i2c.h **** /*!
 403:../drivers/fsl_i2c.h ****  * @name Status
 404:../drivers/fsl_i2c.h ****  * @{
 405:../drivers/fsl_i2c.h ****  */
 406:../drivers/fsl_i2c.h **** 
 407:../drivers/fsl_i2c.h **** /*!
 408:../drivers/fsl_i2c.h ****  * @brief Gets the I2C status flags.
 409:../drivers/fsl_i2c.h ****  *
 410:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 411:../drivers/fsl_i2c.h ****  * @return status flag, use status flag to AND #_i2c_flags to get the related status.
 412:../drivers/fsl_i2c.h ****  */
 413:../drivers/fsl_i2c.h **** uint32_t I2C_MasterGetStatusFlags(I2C_Type *base);
 414:../drivers/fsl_i2c.h **** 
 415:../drivers/fsl_i2c.h **** /*!
 416:../drivers/fsl_i2c.h ****  * @brief Gets the I2C status flags.
 417:../drivers/fsl_i2c.h ****  *
 418:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 419:../drivers/fsl_i2c.h ****  * @return status flag, use status flag to AND #_i2c_flags to get the related status.
 420:../drivers/fsl_i2c.h ****  */
 421:../drivers/fsl_i2c.h **** static inline uint32_t I2C_SlaveGetStatusFlags(I2C_Type *base)
 422:../drivers/fsl_i2c.h **** {
 423:../drivers/fsl_i2c.h ****     return I2C_MasterGetStatusFlags(base);
 424:../drivers/fsl_i2c.h **** }
 425:../drivers/fsl_i2c.h **** 
 426:../drivers/fsl_i2c.h **** /*!
 427:../drivers/fsl_i2c.h ****  * @brief Clears the I2C status flag state.
 428:../drivers/fsl_i2c.h ****  *
 429:../drivers/fsl_i2c.h ****  * The following status register flags can be cleared kI2C_ArbitrationLostFlag and kI2C_IntPendingF
 430:../drivers/fsl_i2c.h ****  *
 431:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 432:../drivers/fsl_i2c.h ****  * @param statusMask The status flag mask, defined in type i2c_status_flag_t.
 433:../drivers/fsl_i2c.h ****  *      The parameter can be any combination of the following values:
 434:../drivers/fsl_i2c.h ****  *          @arg kI2C_StartDetectFlag (if available)
 435:../drivers/fsl_i2c.h ****  *          @arg kI2C_StopDetectFlag (if available)
 436:../drivers/fsl_i2c.h ****  *          @arg kI2C_ArbitrationLostFlag
 437:../drivers/fsl_i2c.h ****  *          @arg kI2C_IntPendingFlagFlag
 438:../drivers/fsl_i2c.h ****  */
 439:../drivers/fsl_i2c.h **** static inline void I2C_MasterClearStatusFlags(I2C_Type *base, uint32_t statusMask)
 440:../drivers/fsl_i2c.h **** {
 441:../drivers/fsl_i2c.h **** /* Must clear the STARTF / STOPF bits prior to clearing IICIF */
 442:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 443:../drivers/fsl_i2c.h ****     if (statusMask & kI2C_StartDetectFlag)
 444:../drivers/fsl_i2c.h ****     {
 445:../drivers/fsl_i2c.h ****         /* Shift the odd-ball flags back into place. */
 446:../drivers/fsl_i2c.h ****         base->FLT |= (uint8_t)(statusMask >> 8U);
 447:../drivers/fsl_i2c.h ****     }
 448:../drivers/fsl_i2c.h **** #endif
 449:../drivers/fsl_i2c.h **** 
 450:../drivers/fsl_i2c.h **** #ifdef I2C_HAS_STOP_DETECT
 451:../drivers/fsl_i2c.h ****     if (statusMask & kI2C_StopDetectFlag)
 452:../drivers/fsl_i2c.h ****     {
 453:../drivers/fsl_i2c.h ****         /* Shift the odd-ball flags back into place. */
 454:../drivers/fsl_i2c.h ****         base->FLT |= (uint8_t)(statusMask >> 8U);
 455:../drivers/fsl_i2c.h ****     }
 456:../drivers/fsl_i2c.h **** #endif
 457:../drivers/fsl_i2c.h **** 
 458:../drivers/fsl_i2c.h ****     base->S = (uint8_t)statusMask;
 459:../drivers/fsl_i2c.h **** }
 460:../drivers/fsl_i2c.h **** 
 461:../drivers/fsl_i2c.h **** /*!
 462:../drivers/fsl_i2c.h ****  * @brief Clears the I2C status flag state.
 463:../drivers/fsl_i2c.h ****  *
 464:../drivers/fsl_i2c.h ****  * The following status register flags can be cleared kI2C_ArbitrationLostFlag and kI2C_IntPendingF
 465:../drivers/fsl_i2c.h ****  *
 466:../drivers/fsl_i2c.h ****   * @param base I2C base pointer
 467:../drivers/fsl_i2c.h ****   * @param statusMask The status flag mask, defined in type i2c_status_flag_t.
 468:../drivers/fsl_i2c.h ****  *      The parameter can be any combination of the following values:
 469:../drivers/fsl_i2c.h ****  *          @arg kI2C_StartDetectFlag (if available)
 470:../drivers/fsl_i2c.h ****  *          @arg kI2C_StopDetectFlag (if available)
 471:../drivers/fsl_i2c.h ****  *          @arg kI2C_ArbitrationLostFlag
 472:../drivers/fsl_i2c.h ****  *          @arg kI2C_IntPendingFlagFlag
 473:../drivers/fsl_i2c.h ****  */
 474:../drivers/fsl_i2c.h **** static inline void I2C_SlaveClearStatusFlags(I2C_Type *base, uint32_t statusMask)
 475:../drivers/fsl_i2c.h **** {
 476:../drivers/fsl_i2c.h ****     I2C_MasterClearStatusFlags(base, statusMask);
 477:../drivers/fsl_i2c.h **** }
 478:../drivers/fsl_i2c.h **** 
 479:../drivers/fsl_i2c.h **** /* @} */
 480:../drivers/fsl_i2c.h **** 
 481:../drivers/fsl_i2c.h **** /*!
 482:../drivers/fsl_i2c.h ****  * @name Interrupts
 483:../drivers/fsl_i2c.h ****  * @{
 484:../drivers/fsl_i2c.h ****  */
 485:../drivers/fsl_i2c.h **** 
 486:../drivers/fsl_i2c.h **** /*!
 487:../drivers/fsl_i2c.h ****  * @brief Enables I2C interrupt requests.
 488:../drivers/fsl_i2c.h ****  *
 489:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 490:../drivers/fsl_i2c.h ****  * @param mask interrupt source
 491:../drivers/fsl_i2c.h ****  *     The parameter can be combination of the following source if defined:
 492:../drivers/fsl_i2c.h ****  *     @arg kI2C_GlobalInterruptEnable
 493:../drivers/fsl_i2c.h ****  *     @arg kI2C_StopDetectInterruptEnable/kI2C_StartDetectInterruptEnable
 494:../drivers/fsl_i2c.h ****  *     @arg kI2C_SdaTimeoutInterruptEnable
 495:../drivers/fsl_i2c.h ****  */
 496:../drivers/fsl_i2c.h **** void I2C_EnableInterrupts(I2C_Type *base, uint32_t mask);
 497:../drivers/fsl_i2c.h **** 
 498:../drivers/fsl_i2c.h **** /*!
 499:../drivers/fsl_i2c.h ****  * @brief Disables I2C interrupt requests.
 500:../drivers/fsl_i2c.h ****  *
 501:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 502:../drivers/fsl_i2c.h ****  * @param mask interrupt source
 503:../drivers/fsl_i2c.h ****  *     The parameter can be combination of the following source if defined:
 504:../drivers/fsl_i2c.h ****  *     @arg kI2C_GlobalInterruptEnable
 505:../drivers/fsl_i2c.h ****  *     @arg kI2C_StopDetectInterruptEnable/kI2C_StartDetectInterruptEnable
 506:../drivers/fsl_i2c.h ****  *     @arg kI2C_SdaTimeoutInterruptEnable
 507:../drivers/fsl_i2c.h ****  */
 508:../drivers/fsl_i2c.h **** void I2C_DisableInterrupts(I2C_Type *base, uint32_t mask);
 509:../drivers/fsl_i2c.h **** 
 510:../drivers/fsl_i2c.h **** /*!
 511:../drivers/fsl_i2c.h ****  * @name DMA Control
 512:../drivers/fsl_i2c.h ****  * @{
 513:../drivers/fsl_i2c.h ****  */
 514:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_DMA_SUPPORT) && FSL_FEATURE_I2C_HAS_DMA_SUPPORT
 515:../drivers/fsl_i2c.h **** /*!
 516:../drivers/fsl_i2c.h ****  * @brief Enables/disables the I2C DMA interrupt.
 517:../drivers/fsl_i2c.h ****  *
 518:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 519:../drivers/fsl_i2c.h ****  * @param enable true to enable, false to disable
 520:../drivers/fsl_i2c.h **** */
 521:../drivers/fsl_i2c.h **** static inline void I2C_EnableDMA(I2C_Type *base, bool enable)
 522:../drivers/fsl_i2c.h **** {
 523:../drivers/fsl_i2c.h ****     if (enable)
 524:../drivers/fsl_i2c.h ****     {
 525:../drivers/fsl_i2c.h ****         base->C1 |= I2C_C1_DMAEN_MASK;
 526:../drivers/fsl_i2c.h ****     }
 527:../drivers/fsl_i2c.h ****     else
 528:../drivers/fsl_i2c.h ****     {
 529:../drivers/fsl_i2c.h ****         base->C1 &= ~I2C_C1_DMAEN_MASK;
  44              		.loc 2 529 0
  45 0004 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
  46              	.LVL2:
  47 0006 03F0FE03 		and	r3, r3, #254
  48 000a 8370     		strb	r3, [r0, #2]
  49              	.LVL3:
  50              	.LBE17:
  51              	.LBE16:
 137:../drivers/fsl_i2c_edma.c **** 
 138:../drivers/fsl_i2c_edma.c ****     /* Send stop if kI2C_TransferNoStop flag is not asserted. */
 139:../drivers/fsl_i2c_edma.c ****     if (!(i2cPrivateHandle->handle->transfer.flags & kI2C_TransferNoStopFlag))
  52              		.loc 1 139 0
  53 000c 4B68     		ldr	r3, [r1, #4]
  54 000e 1A68     		ldr	r2, [r3]
  55              	.LVL4:
  56 0010 12F0040F 		tst	r2, #4
 131:../drivers/fsl_i2c_edma.c ****     i2c_master_edma_private_handle_t *i2cPrivateHandle = (i2c_master_edma_private_handle_t *)userDa
  57              		.loc 1 131 0
  58 0014 0C46     		mov	r4, r1
  59 0016 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
  60              		.loc 1 139 0
  61 0018 24D1     		bne	.L2
 140:../drivers/fsl_i2c_edma.c ****     {
 141:../drivers/fsl_i2c_edma.c ****         if (i2cPrivateHandle->handle->transfer.direction == kI2C_Read)
  62              		.loc 1 141 0
  63 001a 012A     		cmp	r2, #1
  64 001c 1CD1     		bne	.L9
 142:../drivers/fsl_i2c_edma.c ****         {
 143:../drivers/fsl_i2c_edma.c ****             /* Change to send NAK at the last byte. */
 144:../drivers/fsl_i2c_edma.c ****             i2cPrivateHandle->base->C1 |= I2C_C1_TXAK_MASK;
  65              		.loc 1 144 0
  66 001e 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
  67 0020 43F00803 		orr	r3, r3, #8
  68 0024 8370     		strb	r3, [r0, #2]
  69              	.L4:
 145:../drivers/fsl_i2c_edma.c **** 
 146:../drivers/fsl_i2c_edma.c ****             /* Wait the last data to be received. */
 147:../drivers/fsl_i2c_edma.c ****             while (!(i2cPrivateHandle->base->S & kI2C_TransferCompleteFlag))
  70              		.loc 1 147 0 discriminator 1
  71 0026 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
  72 0028 1D06     		lsls	r5, r3, #24
  73 002a FCD5     		bpl	.L4
 148:../drivers/fsl_i2c_edma.c ****             {
 149:../drivers/fsl_i2c_edma.c ****             }
 150:../drivers/fsl_i2c_edma.c **** 
 151:../drivers/fsl_i2c_edma.c ****             /* Send stop signal. */
 152:../drivers/fsl_i2c_edma.c ****             result = I2C_MasterStop(i2cPrivateHandle->base);
  74              		.loc 1 152 0
  75 002c FFF7FEFF 		bl	I2C_MasterStop
  76              	.LVL5:
 153:../drivers/fsl_i2c_edma.c **** 
 154:../drivers/fsl_i2c_edma.c ****             /* Read the last data byte. */
 155:../drivers/fsl_i2c_edma.c ****             *(i2cPrivateHandle->handle->transfer.data + i2cPrivateHandle->handle->transfer.dataSize
  77              		.loc 1 155 0
  78 0030 6268     		ldr	r2, [r4, #4]
  79 0032 1369     		ldr	r3, [r2, #16]
  80 0034 5169     		ldr	r1, [r2, #20]
 156:../drivers/fsl_i2c_edma.c ****                 i2cPrivateHandle->base->D;
  81              		.loc 1 156 0
  82 0036 2268     		ldr	r2, [r4]
 155:../drivers/fsl_i2c_edma.c ****                 i2cPrivateHandle->base->D;
  83              		.loc 1 155 0
  84 0038 0B44     		add	r3, r3, r1
  85              		.loc 1 156 0
  86 003a 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 155:../drivers/fsl_i2c_edma.c ****                 i2cPrivateHandle->base->D;
  87              		.loc 1 155 0
  88 003c 03F8012C 		strb	r2, [r3, #-1]
  89              	.LVL6:
  90              	.L5:
 157:../drivers/fsl_i2c_edma.c ****         }
 158:../drivers/fsl_i2c_edma.c ****         else
 159:../drivers/fsl_i2c_edma.c ****         {
 160:../drivers/fsl_i2c_edma.c ****             /* Wait the last data to be sent. */
 161:../drivers/fsl_i2c_edma.c ****             while (!(i2cPrivateHandle->base->S & kI2C_TransferCompleteFlag))
 162:../drivers/fsl_i2c_edma.c ****             {
 163:../drivers/fsl_i2c_edma.c ****             }
 164:../drivers/fsl_i2c_edma.c **** 
 165:../drivers/fsl_i2c_edma.c ****             /* Send stop signal. */
 166:../drivers/fsl_i2c_edma.c ****             result = I2C_MasterStop(i2cPrivateHandle->base);
 167:../drivers/fsl_i2c_edma.c ****         }
 168:../drivers/fsl_i2c_edma.c ****     }
 169:../drivers/fsl_i2c_edma.c ****     else
 170:../drivers/fsl_i2c_edma.c ****     {
 171:../drivers/fsl_i2c_edma.c ****         if (i2cPrivateHandle->handle->transfer.direction == kI2C_Read)
 172:../drivers/fsl_i2c_edma.c ****         {
 173:../drivers/fsl_i2c_edma.c ****             /* Change to send NAK at the last byte. */
 174:../drivers/fsl_i2c_edma.c ****             i2cPrivateHandle->base->C1 |= I2C_C1_TXAK_MASK;
 175:../drivers/fsl_i2c_edma.c **** 
 176:../drivers/fsl_i2c_edma.c ****             /* Wait the last data to be received. */
 177:../drivers/fsl_i2c_edma.c ****             while (!(i2cPrivateHandle->base->S & kI2C_TransferCompleteFlag))
 178:../drivers/fsl_i2c_edma.c ****             {
 179:../drivers/fsl_i2c_edma.c ****             }
 180:../drivers/fsl_i2c_edma.c **** 
 181:../drivers/fsl_i2c_edma.c ****             /* Change direction to send. */
 182:../drivers/fsl_i2c_edma.c ****             i2cPrivateHandle->base->C1 |= I2C_C1_TX_MASK;
 183:../drivers/fsl_i2c_edma.c **** 
 184:../drivers/fsl_i2c_edma.c ****             /* Read the last data byte. */
 185:../drivers/fsl_i2c_edma.c ****             *(i2cPrivateHandle->handle->transfer.data + i2cPrivateHandle->handle->transfer.dataSize
 186:../drivers/fsl_i2c_edma.c ****                 i2cPrivateHandle->base->D;
 187:../drivers/fsl_i2c_edma.c ****         }
 188:../drivers/fsl_i2c_edma.c ****     }
 189:../drivers/fsl_i2c_edma.c **** 
 190:../drivers/fsl_i2c_edma.c ****     i2cPrivateHandle->handle->state = kIdleState;
  91              		.loc 1 190 0
  92 0040 6168     		ldr	r1, [r4, #4]
 191:../drivers/fsl_i2c_edma.c **** 
 192:../drivers/fsl_i2c_edma.c ****     if (i2cPrivateHandle->handle->completionCallback)
  93              		.loc 1 192 0
  94 0042 4D6A     		ldr	r5, [r1, #36]
 190:../drivers/fsl_i2c_edma.c **** 
  95              		.loc 1 190 0
  96 0044 0023     		movs	r3, #0
  97 0046 4B77     		strb	r3, [r1, #29]
  98              		.loc 1 192 0
  99 0048 0DB3     		cbz	r5, .L1
 193:../drivers/fsl_i2c_edma.c ****     {
 194:../drivers/fsl_i2c_edma.c ****         i2cPrivateHandle->handle->completionCallback(i2cPrivateHandle->base, i2cPrivateHandle->hand
 100              		.loc 1 194 0
 101 004a 0246     		mov	r2, r0
 102 004c AC46     		mov	ip, r5
 103 004e 2068     		ldr	r0, [r4]
 104              	.LVL7:
 105 0050 8B6A     		ldr	r3, [r1, #40]
 195:../drivers/fsl_i2c_edma.c ****                                                      i2cPrivateHandle->handle->userData);
 196:../drivers/fsl_i2c_edma.c ****     }
 197:../drivers/fsl_i2c_edma.c **** }
 106              		.loc 1 197 0
 107 0052 BDE87040 		pop	{r4, r5, r6, lr}
 108              		.cfi_remember_state
 109              		.cfi_restore 14
 110              		.cfi_restore 6
 111              		.cfi_restore 5
 112              		.cfi_restore 4
 113              		.cfi_def_cfa_offset 0
 114              	.LVL8:
 194:../drivers/fsl_i2c_edma.c ****                                                      i2cPrivateHandle->handle->userData);
 115              		.loc 1 194 0
 116 0056 6047     		bx	ip	@ indirect register sibling call
 117              	.LVL9:
 118              	.L9:
 119              		.cfi_restore_state
 161:../drivers/fsl_i2c_edma.c ****             {
 120              		.loc 1 161 0 discriminator 1
 121 0058 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 122 005a 1906     		lsls	r1, r3, #24
 123 005c FCD5     		bpl	.L9
 166:../drivers/fsl_i2c_edma.c ****         }
 124              		.loc 1 166 0
 125 005e FFF7FEFF 		bl	I2C_MasterStop
 126              	.LVL10:
 127 0062 EDE7     		b	.L5
 128              	.LVL11:
 129              	.L2:
 171:../drivers/fsl_i2c_edma.c ****         {
 130              		.loc 1 171 0
 131 0064 012A     		cmp	r2, #1
 132 0066 10D1     		bne	.L8
 174:../drivers/fsl_i2c_edma.c **** 
 133              		.loc 1 174 0
 134 0068 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 135 006a 42F00802 		orr	r2, r2, #8
 136 006e 8270     		strb	r2, [r0, #2]
 137              	.L6:
 177:../drivers/fsl_i2c_edma.c ****             {
 138              		.loc 1 177 0 discriminator 1
 139 0070 C278     		ldrb	r2, [r0, #3]	@ zero_extendqisi2
 140 0072 1206     		lsls	r2, r2, #24
 141 0074 FCD5     		bpl	.L6
 182:../drivers/fsl_i2c_edma.c **** 
 142              		.loc 1 182 0
 143 0076 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 144 0078 42F01002 		orr	r2, r2, #16
 145 007c 8270     		strb	r2, [r0, #2]
 185:../drivers/fsl_i2c_edma.c ****                 i2cPrivateHandle->base->D;
 146              		.loc 1 185 0
 147 007e 1A69     		ldr	r2, [r3, #16]
 148 0080 5B69     		ldr	r3, [r3, #20]
 186:../drivers/fsl_i2c_edma.c ****         }
 149              		.loc 1 186 0
 150 0082 0179     		ldrb	r1, [r0, #4]	@ zero_extendqisi2
 151              	.LVL12:
 185:../drivers/fsl_i2c_edma.c ****                 i2cPrivateHandle->base->D;
 152              		.loc 1 185 0
 153 0084 1344     		add	r3, r3, r2
 154 0086 03F8011C 		strb	r1, [r3, #-1]
 155              	.L8:
 133:../drivers/fsl_i2c_edma.c **** 
 156              		.loc 1 133 0
 157 008a 0020     		movs	r0, #0
 158 008c D8E7     		b	.L5
 159              	.LVL13:
 160              	.L1:
 161 008e 70BD     		pop	{r4, r5, r6, pc}
 162              		.cfi_endproc
 163              	.LFE163:
 165              		.section	.text.I2C_MasterCreateEDMAHandle,"ax",%progbits
 166              		.align	1
 167              		.global	I2C_MasterCreateEDMAHandle
 168              		.syntax unified
 169              		.thumb
 170              		.thumb_func
 171              		.fpu fpv4-sp-d16
 173              	I2C_MasterCreateEDMAHandle:
 174              	.LFB167:
 198:../drivers/fsl_i2c_edma.c **** 
 199:../drivers/fsl_i2c_edma.c **** static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status)
 200:../drivers/fsl_i2c_edma.c **** {
 201:../drivers/fsl_i2c_edma.c ****     status_t result = kStatus_Success;
 202:../drivers/fsl_i2c_edma.c **** 
 203:../drivers/fsl_i2c_edma.c ****     /* Check arbitration lost. */
 204:../drivers/fsl_i2c_edma.c ****     if (status & kI2C_ArbitrationLostFlag)
 205:../drivers/fsl_i2c_edma.c ****     {
 206:../drivers/fsl_i2c_edma.c ****         /* Clear arbitration lost flag. */
 207:../drivers/fsl_i2c_edma.c ****         base->S = kI2C_ArbitrationLostFlag;
 208:../drivers/fsl_i2c_edma.c ****         result = kStatus_I2C_ArbitrationLost;
 209:../drivers/fsl_i2c_edma.c ****     }
 210:../drivers/fsl_i2c_edma.c ****     /* Check NAK */
 211:../drivers/fsl_i2c_edma.c ****     else if (status & kI2C_ReceiveNakFlag)
 212:../drivers/fsl_i2c_edma.c ****     {
 213:../drivers/fsl_i2c_edma.c ****         result = kStatus_I2C_Nak;
 214:../drivers/fsl_i2c_edma.c ****     }
 215:../drivers/fsl_i2c_edma.c ****     else
 216:../drivers/fsl_i2c_edma.c ****     {
 217:../drivers/fsl_i2c_edma.c ****     }
 218:../drivers/fsl_i2c_edma.c **** 
 219:../drivers/fsl_i2c_edma.c ****     return result;
 220:../drivers/fsl_i2c_edma.c **** }
 221:../drivers/fsl_i2c_edma.c **** 
 222:../drivers/fsl_i2c_edma.c **** static status_t I2C_InitTransferStateMachineEDMA(I2C_Type *base,
 223:../drivers/fsl_i2c_edma.c ****                                                  i2c_master_edma_handle_t *handle,
 224:../drivers/fsl_i2c_edma.c ****                                                  i2c_master_transfer_t *xfer)
 225:../drivers/fsl_i2c_edma.c **** {
 226:../drivers/fsl_i2c_edma.c ****     assert(handle);
 227:../drivers/fsl_i2c_edma.c ****     assert(xfer);
 228:../drivers/fsl_i2c_edma.c **** 
 229:../drivers/fsl_i2c_edma.c ****     status_t result = kStatus_Success;
 230:../drivers/fsl_i2c_edma.c **** 
 231:../drivers/fsl_i2c_edma.c ****     if (handle->state != kIdleState)
 232:../drivers/fsl_i2c_edma.c ****     {
 233:../drivers/fsl_i2c_edma.c ****         return kStatus_I2C_Busy;
 234:../drivers/fsl_i2c_edma.c ****     }
 235:../drivers/fsl_i2c_edma.c ****     else
 236:../drivers/fsl_i2c_edma.c ****     {
 237:../drivers/fsl_i2c_edma.c ****         i2c_direction_t direction = xfer->direction;
 238:../drivers/fsl_i2c_edma.c **** 
 239:../drivers/fsl_i2c_edma.c ****         /* Init the handle member. */
 240:../drivers/fsl_i2c_edma.c ****         handle->transfer = *xfer;
 241:../drivers/fsl_i2c_edma.c **** 
 242:../drivers/fsl_i2c_edma.c ****         /* Save total transfer size. */
 243:../drivers/fsl_i2c_edma.c ****         handle->transferSize = xfer->dataSize;
 244:../drivers/fsl_i2c_edma.c **** 
 245:../drivers/fsl_i2c_edma.c ****         handle->state = kTransferDataState;
 246:../drivers/fsl_i2c_edma.c **** 
 247:../drivers/fsl_i2c_edma.c ****         /* Clear all status before transfer. */
 248:../drivers/fsl_i2c_edma.c ****         I2C_MasterClearStatusFlags(base, kClearFlags);
 249:../drivers/fsl_i2c_edma.c **** 
 250:../drivers/fsl_i2c_edma.c ****         /* Change to send write address when it's a read operation with command. */
 251:../drivers/fsl_i2c_edma.c ****         if ((xfer->subaddressSize > 0) && (xfer->direction == kI2C_Read))
 252:../drivers/fsl_i2c_edma.c ****         {
 253:../drivers/fsl_i2c_edma.c ****             direction = kI2C_Write;
 254:../drivers/fsl_i2c_edma.c ****         }
 255:../drivers/fsl_i2c_edma.c **** 
 256:../drivers/fsl_i2c_edma.c ****         /* If repeated start is requested, send repeated start. */
 257:../drivers/fsl_i2c_edma.c ****         if (handle->transfer.flags & kI2C_TransferRepeatedStartFlag)
 258:../drivers/fsl_i2c_edma.c ****         {
 259:../drivers/fsl_i2c_edma.c ****             result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, direction);
 260:../drivers/fsl_i2c_edma.c ****         }
 261:../drivers/fsl_i2c_edma.c ****         else /* For normal transfer, send start. */
 262:../drivers/fsl_i2c_edma.c ****         {
 263:../drivers/fsl_i2c_edma.c ****             result = I2C_MasterStart(base, handle->transfer.slaveAddress, direction);
 264:../drivers/fsl_i2c_edma.c ****         }
 265:../drivers/fsl_i2c_edma.c **** 
 266:../drivers/fsl_i2c_edma.c ****         if (result)
 267:../drivers/fsl_i2c_edma.c ****         {
 268:../drivers/fsl_i2c_edma.c ****             return result;
 269:../drivers/fsl_i2c_edma.c ****         }
 270:../drivers/fsl_i2c_edma.c **** 
 271:../drivers/fsl_i2c_edma.c ****         while (!(base->S & kI2C_IntPendingFlag))
 272:../drivers/fsl_i2c_edma.c ****         {
 273:../drivers/fsl_i2c_edma.c ****         }
 274:../drivers/fsl_i2c_edma.c **** 
 275:../drivers/fsl_i2c_edma.c ****         /* Check if there's transfer error. */
 276:../drivers/fsl_i2c_edma.c ****         result = I2C_CheckAndClearError(base, base->S);
 277:../drivers/fsl_i2c_edma.c **** 
 278:../drivers/fsl_i2c_edma.c ****         /* Return if error. */
 279:../drivers/fsl_i2c_edma.c ****         if (result)
 280:../drivers/fsl_i2c_edma.c ****         {
 281:../drivers/fsl_i2c_edma.c ****             if (result == kStatus_I2C_Nak)
 282:../drivers/fsl_i2c_edma.c ****             {
 283:../drivers/fsl_i2c_edma.c ****                 result = kStatus_I2C_Addr_Nak;
 284:../drivers/fsl_i2c_edma.c **** 
 285:../drivers/fsl_i2c_edma.c ****                 if (I2C_MasterStop(base) != kStatus_Success)
 286:../drivers/fsl_i2c_edma.c ****                 {
 287:../drivers/fsl_i2c_edma.c ****                     result = kStatus_I2C_Timeout;
 288:../drivers/fsl_i2c_edma.c ****                 }
 289:../drivers/fsl_i2c_edma.c **** 
 290:../drivers/fsl_i2c_edma.c ****                 if (handle->completionCallback)
 291:../drivers/fsl_i2c_edma.c ****                 {
 292:../drivers/fsl_i2c_edma.c ****                     (handle->completionCallback)(base, handle, result, handle->userData);
 293:../drivers/fsl_i2c_edma.c ****                 }
 294:../drivers/fsl_i2c_edma.c ****             }
 295:../drivers/fsl_i2c_edma.c **** 
 296:../drivers/fsl_i2c_edma.c ****             return result;
 297:../drivers/fsl_i2c_edma.c ****         }
 298:../drivers/fsl_i2c_edma.c **** 
 299:../drivers/fsl_i2c_edma.c ****         /* Send subaddress. */
 300:../drivers/fsl_i2c_edma.c ****         if (handle->transfer.subaddressSize)
 301:../drivers/fsl_i2c_edma.c ****         {
 302:../drivers/fsl_i2c_edma.c ****             do
 303:../drivers/fsl_i2c_edma.c ****             {
 304:../drivers/fsl_i2c_edma.c ****                 /* Clear interrupt pending flag. */
 305:../drivers/fsl_i2c_edma.c ****                 base->S = kI2C_IntPendingFlag;
 306:../drivers/fsl_i2c_edma.c **** 
 307:../drivers/fsl_i2c_edma.c ****                 handle->transfer.subaddressSize--;
 308:../drivers/fsl_i2c_edma.c ****                 base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
 309:../drivers/fsl_i2c_edma.c **** 
 310:../drivers/fsl_i2c_edma.c ****                 /* Wait until data transfer complete. */
 311:../drivers/fsl_i2c_edma.c ****                 while (!(base->S & kI2C_IntPendingFlag))
 312:../drivers/fsl_i2c_edma.c ****                 {
 313:../drivers/fsl_i2c_edma.c ****                 }
 314:../drivers/fsl_i2c_edma.c **** 
 315:../drivers/fsl_i2c_edma.c ****                 /* Check if there's transfer error. */
 316:../drivers/fsl_i2c_edma.c ****                 result = I2C_CheckAndClearError(base, base->S);
 317:../drivers/fsl_i2c_edma.c **** 
 318:../drivers/fsl_i2c_edma.c ****                 if (result)
 319:../drivers/fsl_i2c_edma.c ****                 {
 320:../drivers/fsl_i2c_edma.c ****                     return result;
 321:../drivers/fsl_i2c_edma.c ****                 }
 322:../drivers/fsl_i2c_edma.c **** 
 323:../drivers/fsl_i2c_edma.c ****             } while ((handle->transfer.subaddressSize > 0) && (result == kStatus_Success));
 324:../drivers/fsl_i2c_edma.c **** 
 325:../drivers/fsl_i2c_edma.c ****             if (handle->transfer.direction == kI2C_Read)
 326:../drivers/fsl_i2c_edma.c ****             {
 327:../drivers/fsl_i2c_edma.c ****                 /* Clear pending flag. */
 328:../drivers/fsl_i2c_edma.c ****                 base->S = kI2C_IntPendingFlag;
 329:../drivers/fsl_i2c_edma.c **** 
 330:../drivers/fsl_i2c_edma.c ****                 /* Send repeated start and slave address. */
 331:../drivers/fsl_i2c_edma.c ****                 result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, kI2C_Read);
 332:../drivers/fsl_i2c_edma.c **** 
 333:../drivers/fsl_i2c_edma.c ****                 if (result)
 334:../drivers/fsl_i2c_edma.c ****                 {
 335:../drivers/fsl_i2c_edma.c ****                     return result;
 336:../drivers/fsl_i2c_edma.c ****                 }
 337:../drivers/fsl_i2c_edma.c **** 
 338:../drivers/fsl_i2c_edma.c ****                 /* Wait until data transfer complete. */
 339:../drivers/fsl_i2c_edma.c ****                 while (!(base->S & kI2C_IntPendingFlag))
 340:../drivers/fsl_i2c_edma.c ****                 {
 341:../drivers/fsl_i2c_edma.c ****                 }
 342:../drivers/fsl_i2c_edma.c **** 
 343:../drivers/fsl_i2c_edma.c ****                 /* Check if there's transfer error. */
 344:../drivers/fsl_i2c_edma.c ****                 result = I2C_CheckAndClearError(base, base->S);
 345:../drivers/fsl_i2c_edma.c **** 
 346:../drivers/fsl_i2c_edma.c ****                 if (result)
 347:../drivers/fsl_i2c_edma.c ****                 {
 348:../drivers/fsl_i2c_edma.c ****                     return result;
 349:../drivers/fsl_i2c_edma.c ****                 }
 350:../drivers/fsl_i2c_edma.c ****             }
 351:../drivers/fsl_i2c_edma.c ****         }
 352:../drivers/fsl_i2c_edma.c **** 
 353:../drivers/fsl_i2c_edma.c ****         /* Clear pending flag. */
 354:../drivers/fsl_i2c_edma.c ****         base->S = kI2C_IntPendingFlag;
 355:../drivers/fsl_i2c_edma.c ****     }
 356:../drivers/fsl_i2c_edma.c **** 
 357:../drivers/fsl_i2c_edma.c ****     return result;
 358:../drivers/fsl_i2c_edma.c **** }
 359:../drivers/fsl_i2c_edma.c **** 
 360:../drivers/fsl_i2c_edma.c **** static void I2C_MasterTransferEDMAConfig(I2C_Type *base, i2c_master_edma_handle_t *handle)
 361:../drivers/fsl_i2c_edma.c **** {
 362:../drivers/fsl_i2c_edma.c ****     edma_transfer_config_t transfer_config;
 363:../drivers/fsl_i2c_edma.c **** 
 364:../drivers/fsl_i2c_edma.c ****     if (handle->transfer.direction == kI2C_Read)
 365:../drivers/fsl_i2c_edma.c ****     {
 366:../drivers/fsl_i2c_edma.c ****         transfer_config.srcAddr = (uint32_t)I2C_GetDataRegAddr(base);
 367:../drivers/fsl_i2c_edma.c ****         transfer_config.destAddr = (uint32_t)(handle->transfer.data);
 368:../drivers/fsl_i2c_edma.c ****         transfer_config.majorLoopCounts = (handle->transfer.dataSize - 1);
 369:../drivers/fsl_i2c_edma.c ****         transfer_config.srcTransferSize = kEDMA_TransferSize1Bytes;
 370:../drivers/fsl_i2c_edma.c ****         transfer_config.srcOffset = 0;
 371:../drivers/fsl_i2c_edma.c ****         transfer_config.destTransferSize = kEDMA_TransferSize1Bytes;
 372:../drivers/fsl_i2c_edma.c ****         transfer_config.destOffset = 1;
 373:../drivers/fsl_i2c_edma.c ****         transfer_config.minorLoopBytes = 1;
 374:../drivers/fsl_i2c_edma.c ****     }
 375:../drivers/fsl_i2c_edma.c ****     else
 376:../drivers/fsl_i2c_edma.c ****     {
 377:../drivers/fsl_i2c_edma.c ****         transfer_config.srcAddr = (uint32_t)(handle->transfer.data + 1);
 378:../drivers/fsl_i2c_edma.c ****         transfer_config.destAddr = (uint32_t)I2C_GetDataRegAddr(base);
 379:../drivers/fsl_i2c_edma.c ****         transfer_config.majorLoopCounts = (handle->transfer.dataSize - 1);
 380:../drivers/fsl_i2c_edma.c ****         transfer_config.srcTransferSize = kEDMA_TransferSize1Bytes;
 381:../drivers/fsl_i2c_edma.c ****         transfer_config.srcOffset = 1;
 382:../drivers/fsl_i2c_edma.c ****         transfer_config.destTransferSize = kEDMA_TransferSize1Bytes;
 383:../drivers/fsl_i2c_edma.c ****         transfer_config.destOffset = 0;
 384:../drivers/fsl_i2c_edma.c ****         transfer_config.minorLoopBytes = 1;
 385:../drivers/fsl_i2c_edma.c ****     }
 386:../drivers/fsl_i2c_edma.c **** 
 387:../drivers/fsl_i2c_edma.c ****     /* Store the initially configured eDMA minor byte transfer count into the I2C handle */
 388:../drivers/fsl_i2c_edma.c ****     handle->nbytes = transfer_config.minorLoopBytes;
 389:../drivers/fsl_i2c_edma.c **** 
 390:../drivers/fsl_i2c_edma.c ****     EDMA_SubmitTransfer(handle->dmaHandle, &transfer_config);
 391:../drivers/fsl_i2c_edma.c ****     EDMA_StartTransfer(handle->dmaHandle);
 392:../drivers/fsl_i2c_edma.c **** }
 393:../drivers/fsl_i2c_edma.c **** 
 394:../drivers/fsl_i2c_edma.c **** void I2C_MasterCreateEDMAHandle(I2C_Type *base,
 395:../drivers/fsl_i2c_edma.c ****                                 i2c_master_edma_handle_t *handle,
 396:../drivers/fsl_i2c_edma.c ****                                 i2c_master_edma_transfer_callback_t callback,
 397:../drivers/fsl_i2c_edma.c ****                                 void *userData,
 398:../drivers/fsl_i2c_edma.c ****                                 edma_handle_t *edmaHandle)
 399:../drivers/fsl_i2c_edma.c **** {
 175              		.loc 1 399 0
 176              		.cfi_startproc
 177              		@ args = 4, pretend = 0, frame = 0
 178              		@ frame_needed = 0, uses_anonymous_args = 0
 179              	.LVL14:
 180 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 181              		.cfi_def_cfa_offset 32
 182              		.cfi_offset 3, -32
 183              		.cfi_offset 4, -28
 184              		.cfi_offset 5, -24
 185              		.cfi_offset 6, -20
 186              		.cfi_offset 7, -16
 187              		.cfi_offset 8, -12
 188              		.cfi_offset 9, -8
 189              		.cfi_offset 14, -4
 190              		.loc 1 399 0
 191 0004 089D     		ldr	r5, [sp, #32]
 192 0006 0C46     		mov	r4, r1
 193 0008 9146     		mov	r9, r2
 194 000a 9846     		mov	r8, r3
 195 000c 0746     		mov	r7, r0
 400:../drivers/fsl_i2c_edma.c ****     assert(handle);
 401:../drivers/fsl_i2c_edma.c ****     assert(edmaHandle);
 402:../drivers/fsl_i2c_edma.c **** 
 403:../drivers/fsl_i2c_edma.c ****     uint32_t instance = I2C_GetInstance(base);
 196              		.loc 1 403 0
 197 000e FFF7FEFF 		bl	I2C_GetInstance
 198              	.LVL15:
 404:../drivers/fsl_i2c_edma.c **** 
 405:../drivers/fsl_i2c_edma.c ****     /* Zero handle. */
 406:../drivers/fsl_i2c_edma.c ****     memset(handle, 0, sizeof(*handle));
 199              		.loc 1 406 0
 200 0012 2C22     		movs	r2, #44
 403:../drivers/fsl_i2c_edma.c **** 
 201              		.loc 1 403 0
 202 0014 0646     		mov	r6, r0
 203              	.LVL16:
 204              		.loc 1 406 0
 205 0016 0021     		movs	r1, #0
 206 0018 2046     		mov	r0, r4
 207              	.LVL17:
 208 001a FFF7FEFF 		bl	memset
 209              	.LVL18:
 407:../drivers/fsl_i2c_edma.c **** 
 408:../drivers/fsl_i2c_edma.c ****     /* Set the user callback and userData. */
 409:../drivers/fsl_i2c_edma.c ****     handle->completionCallback = callback;
 410:../drivers/fsl_i2c_edma.c ****     handle->userData = userData;
 411:../drivers/fsl_i2c_edma.c **** 
 412:../drivers/fsl_i2c_edma.c ****     /* Set the base for the handle. */
 413:../drivers/fsl_i2c_edma.c ****     base = base;
 414:../drivers/fsl_i2c_edma.c **** 
 415:../drivers/fsl_i2c_edma.c ****     /* Set the handle for EDMA. */
 416:../drivers/fsl_i2c_edma.c ****     handle->dmaHandle = edmaHandle;
 417:../drivers/fsl_i2c_edma.c **** 
 418:../drivers/fsl_i2c_edma.c ****     s_edmaPrivateHandle[instance].base = base;
 210              		.loc 1 418 0
 211 001e 084A     		ldr	r2, .L14
 409:../drivers/fsl_i2c_edma.c ****     handle->userData = userData;
 212              		.loc 1 409 0
 213 0020 C4F82490 		str	r9, [r4, #36]
 214              		.loc 1 418 0
 215 0024 42F83670 		str	r7, [r2, r6, lsl #3]
 419:../drivers/fsl_i2c_edma.c ****     s_edmaPrivateHandle[instance].handle = handle;
 216              		.loc 1 419 0
 217 0028 02EBC602 		add	r2, r2, r6, lsl #3
 410:../drivers/fsl_i2c_edma.c **** 
 218              		.loc 1 410 0
 219 002c C4F82880 		str	r8, [r4, #40]
 416:../drivers/fsl_i2c_edma.c **** 
 220              		.loc 1 416 0
 221 0030 2562     		str	r5, [r4, #32]
 222              		.loc 1 419 0
 223 0032 5460     		str	r4, [r2, #4]
 420:../drivers/fsl_i2c_edma.c **** 
 421:../drivers/fsl_i2c_edma.c ****     EDMA_SetCallback(edmaHandle, (edma_callback)I2C_MasterTransferCallbackEDMA, &s_edmaPrivateHandl
 224              		.loc 1 421 0
 225 0034 2846     		mov	r0, r5
 226 0036 0349     		ldr	r1, .L14+4
 422:../drivers/fsl_i2c_edma.c **** }
 227              		.loc 1 422 0
 228 0038 BDE8F843 		pop	{r3, r4, r5, r6, r7, r8, r9, lr}
 229              		.cfi_restore 14
 230              		.cfi_restore 9
 231              		.cfi_restore 8
 232              		.cfi_restore 7
 233              		.cfi_restore 6
 234              		.cfi_restore 5
 235              		.cfi_restore 4
 236              		.cfi_restore 3
 237              		.cfi_def_cfa_offset 0
 238              	.LVL19:
 421:../drivers/fsl_i2c_edma.c **** }
 239              		.loc 1 421 0
 240 003c FFF7FEBF 		b	EDMA_SetCallback
 241              	.LVL20:
 242              	.L15:
 243              		.align	2
 244              	.L14:
 245 0040 00000000 		.word	.LANCHOR0
 246 0044 00000000 		.word	I2C_MasterTransferCallbackEDMA
 247              		.cfi_endproc
 248              	.LFE167:
 250              		.section	.text.I2C_MasterTransferEDMA,"ax",%progbits
 251              		.align	1
 252              		.global	I2C_MasterTransferEDMA
 253              		.syntax unified
 254              		.thumb
 255              		.thumb_func
 256              		.fpu fpv4-sp-d16
 258              	I2C_MasterTransferEDMA:
 259              	.LFB168:
 423:../drivers/fsl_i2c_edma.c **** 
 424:../drivers/fsl_i2c_edma.c **** status_t I2C_MasterTransferEDMA(I2C_Type *base, i2c_master_edma_handle_t *handle, i2c_master_transf
 425:../drivers/fsl_i2c_edma.c **** {
 260              		.loc 1 425 0
 261              		.cfi_startproc
 262              		@ args = 0, pretend = 0, frame = 32
 263              		@ frame_needed = 0, uses_anonymous_args = 0
 264              	.LVL21:
 265 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 266              		.cfi_def_cfa_offset 20
 267              		.cfi_offset 4, -20
 268              		.cfi_offset 5, -16
 269              		.cfi_offset 6, -12
 270              		.cfi_offset 7, -8
 271              		.cfi_offset 14, -4
 272 0002 89B0     		sub	sp, sp, #36
 273              		.cfi_def_cfa_offset 56
 426:../drivers/fsl_i2c_edma.c ****     assert(handle);
 427:../drivers/fsl_i2c_edma.c ****     assert(xfer);
 428:../drivers/fsl_i2c_edma.c **** 
 429:../drivers/fsl_i2c_edma.c ****     status_t result;
 430:../drivers/fsl_i2c_edma.c ****     uint8_t tmpReg;
 431:../drivers/fsl_i2c_edma.c ****     volatile uint8_t dummy = 0;
 274              		.loc 1 431 0
 275 0004 0023     		movs	r3, #0
 276 0006 8DF80730 		strb	r3, [sp, #7]
 432:../drivers/fsl_i2c_edma.c **** 
 433:../drivers/fsl_i2c_edma.c ****     /* Add this to avoid build warning. */
 434:../drivers/fsl_i2c_edma.c ****     dummy++;
 277              		.loc 1 434 0
 278 000a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 279 000e 0133     		adds	r3, r3, #1
 280 0010 DBB2     		uxtb	r3, r3
 281 0012 8DF80730 		strb	r3, [sp, #7]
 282              	.LVL22:
 283              	.LBB41:
 284              	.LBB42:
 285              		.loc 2 529 0
 286 0016 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 287 0018 03F0FE03 		and	r3, r3, #254
 288 001c 8370     		strb	r3, [r0, #2]
 289              	.LVL23:
 290              	.LBE42:
 291              	.LBE41:
 292              	.LBB43:
 293              	.LBB44:
 231:../drivers/fsl_i2c_edma.c ****     {
 294              		.loc 1 231 0
 295 001e 4B7F     		ldrb	r3, [r1, #29]	@ zero_extendqisi2
 296              	.LBE44:
 297              	.LBE43:
 425:../drivers/fsl_i2c_edma.c ****     assert(handle);
 298              		.loc 1 425 0
 299 0020 0446     		mov	r4, r0
 300              	.LVL24:
 301 0022 0D46     		mov	r5, r1
 302 0024 9646     		mov	lr, r2
 303              	.LBB66:
 304              	.LBB61:
 231:../drivers/fsl_i2c_edma.c ****     {
 305              		.loc 1 231 0
 306 0026 002B     		cmp	r3, #0
 307 0028 40F01181 		bne	.L54
 308              	.LBB45:
 240:../drivers/fsl_i2c_edma.c **** 
 309              		.loc 1 240 0
 310 002c 1746     		mov	r7, r2
 237:../drivers/fsl_i2c_edma.c **** 
 311              		.loc 1 237 0
 312 002e 92F805C0 		ldrb	ip, [r2, #5]	@ zero_extendqisi2
 313              	.LVL25:
 240:../drivers/fsl_i2c_edma.c **** 
 314              		.loc 1 240 0
 315 0032 0E46     		mov	r6, r1
 316 0034 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 317              	.LVL26:
 318 0036 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 319 0038 97E80300 		ldm	r7, {r0, r1}
 320 003c 86E80300 		stm	r6, {r0, r1}
 243:../drivers/fsl_i2c_edma.c **** 
 321              		.loc 1 243 0
 322 0040 DEF81430 		ldr	r3, [lr, #20]
 323 0044 AB61     		str	r3, [r5, #24]
 245:../drivers/fsl_i2c_edma.c **** 
 324              		.loc 1 245 0
 325 0046 0123     		movs	r3, #1
 326 0048 6B77     		strb	r3, [r5, #29]
 327              	.LVL27:
 328              	.LBB46:
 329              	.LBB47:
 446:../drivers/fsl_i2c.h ****     }
 330              		.loc 2 446 0
 331 004a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 332 004c 43F05003 		orr	r3, r3, #80
 333 0050 A371     		strb	r3, [r4, #6]
 454:../drivers/fsl_i2c.h ****     }
 334              		.loc 2 454 0
 335 0052 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 336 0054 43F05003 		orr	r3, r3, #80
 337 0058 A371     		strb	r3, [r4, #6]
 458:../drivers/fsl_i2c.h **** }
 338              		.loc 2 458 0
 339 005a 1223     		movs	r3, #18
 340 005c E370     		strb	r3, [r4, #3]
 341              	.LVL28:
 342              	.LBE47:
 343              	.LBE46:
 251:../drivers/fsl_i2c_edma.c ****         {
 344              		.loc 1 251 0
 345 005e 9EF80C30 		ldrb	r3, [lr, #12]	@ zero_extendqisi2
 346 0062 2BB1     		cbz	r3, .L18
 347 0064 9EF80530 		ldrb	r3, [lr, #5]	@ zero_extendqisi2
 253:../drivers/fsl_i2c_edma.c ****         }
 348              		.loc 1 253 0
 349 0068 012B     		cmp	r3, #1
 350 006a 08BF     		it	eq
 351 006c 4FF0000C 		moveq	ip, #0
 352              	.LVL29:
 353              	.L18:
 257:../drivers/fsl_i2c_edma.c ****         {
 354              		.loc 1 257 0
 355 0070 2B68     		ldr	r3, [r5]
 356 0072 2979     		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 357 0074 13F0020F 		tst	r3, #2
 259:../drivers/fsl_i2c_edma.c ****         }
 358              		.loc 1 259 0
 359 0078 6246     		mov	r2, ip
 360 007a 2046     		mov	r0, r4
 257:../drivers/fsl_i2c_edma.c ****         {
 361              		.loc 1 257 0
 362 007c 11D0     		beq	.L19
 363              	.LVL30:
 259:../drivers/fsl_i2c_edma.c ****         }
 364              		.loc 1 259 0
 365 007e FFF7FEFF 		bl	I2C_MasterRepeatedStart
 366              	.LVL31:
 367              	.L79:
 263:../drivers/fsl_i2c_edma.c ****         }
 368              		.loc 1 263 0
 369 0082 0646     		mov	r6, r0
 370              	.LVL32:
 266:../drivers/fsl_i2c_edma.c ****         {
 371              		.loc 1 266 0
 372 0084 0028     		cmp	r0, #0
 373 0086 40F0C880 		bne	.L21
 374              	.L22:
 271:../drivers/fsl_i2c_edma.c ****         {
 375              		.loc 1 271 0
 376 008a E378     		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 377 008c 9B07     		lsls	r3, r3, #30
 378 008e FCD5     		bpl	.L22
 276:../drivers/fsl_i2c_edma.c **** 
 379              		.loc 1 276 0
 380 0090 E378     		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 381 0092 DBB2     		uxtb	r3, r3
 382              	.LVL33:
 383              	.LBB48:
 384              	.LBB49:
 204:../drivers/fsl_i2c_edma.c ****     {
 385              		.loc 1 204 0
 386 0094 DF06     		lsls	r7, r3, #27
 387              	.LVL34:
 388 0096 07D5     		bpl	.L23
 389              	.LVL35:
 390              	.L80:
 391              	.LBE49:
 392              	.LBE48:
 393              	.LBB51:
 394              	.LBB52:
 207:../drivers/fsl_i2c_edma.c ****         result = kStatus_I2C_ArbitrationLost;
 395              		.loc 1 207 0
 396 0098 1023     		movs	r3, #16
 397 009a E370     		strb	r3, [r4, #3]
 398              	.LVL36:
 208:../drivers/fsl_i2c_edma.c ****     }
 399              		.loc 1 208 0
 400 009c 40F24F46 		movw	r6, #1103
 401 00a0 D0E0     		b	.L48
 402              	.LVL37:
 403              	.L19:
 404              	.LBE52:
 405              	.LBE51:
 263:../drivers/fsl_i2c_edma.c ****         }
 406              		.loc 1 263 0
 407 00a2 FFF7FEFF 		bl	I2C_MasterStart
 408              	.LVL38:
 409 00a6 ECE7     		b	.L79
 410              	.LVL39:
 411              	.L23:
 412              	.LBB54:
 413              	.LBB50:
 211:../drivers/fsl_i2c_edma.c ****     {
 414              		.loc 1 211 0
 415 00a8 D807     		lsls	r0, r3, #31
 416              	.LVL40:
 417 00aa 00F1BB80 		bmi	.L25
 418              	.LVL41:
 419              	.LBE50:
 420              	.LBE54:
 300:../drivers/fsl_i2c_edma.c ****         {
 421              		.loc 1 300 0
 422 00ae 2B7B     		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 423 00b0 FBB1     		cbz	r3, .L38
 424 00b2 5A1E     		subs	r2, r3, #1
 425 00b4 D2B2     		uxtb	r2, r2
 308:../drivers/fsl_i2c_edma.c **** 
 426              		.loc 1 308 0
 427 00b6 A868     		ldr	r0, [r5, #8]
 428 00b8 D200     		lsls	r2, r2, #3
 305:../drivers/fsl_i2c_edma.c **** 
 429              		.loc 1 305 0
 430 00ba 0227     		movs	r7, #2
 431              	.L50:
 308:../drivers/fsl_i2c_edma.c **** 
 432              		.loc 1 308 0
 433 00bc 20FA02F1 		lsr	r1, r0, r2
 307:../drivers/fsl_i2c_edma.c ****                 base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
 434              		.loc 1 307 0
 435 00c0 013B     		subs	r3, r3, #1
 308:../drivers/fsl_i2c_edma.c **** 
 436              		.loc 1 308 0
 437 00c2 C9B2     		uxtb	r1, r1
 305:../drivers/fsl_i2c_edma.c **** 
 438              		.loc 1 305 0
 439 00c4 E770     		strb	r7, [r4, #3]
 307:../drivers/fsl_i2c_edma.c ****                 base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
 440              		.loc 1 307 0
 441 00c6 DBB2     		uxtb	r3, r3
 308:../drivers/fsl_i2c_edma.c **** 
 442              		.loc 1 308 0
 443 00c8 2171     		strb	r1, [r4, #4]
 444              	.L28:
 311:../drivers/fsl_i2c_edma.c ****                 {
 445              		.loc 1 311 0
 446 00ca E178     		ldrb	r1, [r4, #3]	@ zero_extendqisi2
 447 00cc 8907     		lsls	r1, r1, #30
 448 00ce FCD5     		bpl	.L28
 316:../drivers/fsl_i2c_edma.c **** 
 449              		.loc 1 316 0
 450 00d0 E178     		ldrb	r1, [r4, #3]	@ zero_extendqisi2
 451 00d2 C9B2     		uxtb	r1, r1
 452              	.LVL42:
 453              	.LBB55:
 454              	.LBB56:
 204:../drivers/fsl_i2c_edma.c ****     {
 455              		.loc 1 204 0
 456 00d4 11F0100F 		tst	r1, #16
 457 00d8 01D0     		beq	.L29
 458 00da 2B73     		strb	r3, [r5, #12]
 459 00dc DCE7     		b	.L80
 460              	.L29:
 211:../drivers/fsl_i2c_edma.c ****     {
 461              		.loc 1 211 0
 462 00de C907     		lsls	r1, r1, #31
 463              	.LVL43:
 464 00e0 00F1B380 		bmi	.L30
 465              	.LVL44:
 466 00e4 083A     		subs	r2, r2, #8
 467              	.LBE56:
 468              	.LBE55:
 323:../drivers/fsl_i2c_edma.c **** 
 469              		.loc 1 323 0
 470 00e6 002B     		cmp	r3, #0
 471 00e8 E8D1     		bne	.L50
 325:../drivers/fsl_i2c_edma.c ****             {
 472              		.loc 1 325 0
 473 00ea 6A79     		ldrb	r2, [r5, #5]	@ zero_extendqisi2
 474 00ec 2B73     		strb	r3, [r5, #12]
 475 00ee 012A     		cmp	r2, #1
 476 00f0 25D0     		beq	.L32
 477              	.L38:
 478              	.LVL45:
 354:../drivers/fsl_i2c_edma.c ****     }
 479              		.loc 1 354 0
 480 00f2 0223     		movs	r3, #2
 481 00f4 E370     		strb	r3, [r4, #3]
 482              	.LVL46:
 483              	.LBE45:
 484              	.LBE61:
 485              	.LBE66:
 435:../drivers/fsl_i2c_edma.c **** 
 436:../drivers/fsl_i2c_edma.c ****     /* Disable dma xfer. */
 437:../drivers/fsl_i2c_edma.c ****     I2C_EnableDMA(base, false);
 438:../drivers/fsl_i2c_edma.c **** 
 439:../drivers/fsl_i2c_edma.c ****     /* Send address and command buffer(if there is), until senddata phase or receive data phase. */
 440:../drivers/fsl_i2c_edma.c ****     result = I2C_InitTransferStateMachineEDMA(base, handle, xfer);
 441:../drivers/fsl_i2c_edma.c **** 
 442:../drivers/fsl_i2c_edma.c ****     if (result)
 443:../drivers/fsl_i2c_edma.c ****     {
 444:../drivers/fsl_i2c_edma.c ****         /* Send stop if received Nak. */
 445:../drivers/fsl_i2c_edma.c ****         if (result == kStatus_I2C_Nak)
 446:../drivers/fsl_i2c_edma.c ****         {
 447:../drivers/fsl_i2c_edma.c ****             if (I2C_MasterStop(base) != kStatus_Success)
 448:../drivers/fsl_i2c_edma.c ****             {
 449:../drivers/fsl_i2c_edma.c ****                 result = kStatus_I2C_Timeout;
 450:../drivers/fsl_i2c_edma.c ****             }
 451:../drivers/fsl_i2c_edma.c ****         }
 452:../drivers/fsl_i2c_edma.c **** 
 453:../drivers/fsl_i2c_edma.c ****         /* Reset the state to idle state. */
 454:../drivers/fsl_i2c_edma.c ****         handle->state = kIdleState;
 455:../drivers/fsl_i2c_edma.c **** 
 456:../drivers/fsl_i2c_edma.c ****         return result;
 457:../drivers/fsl_i2c_edma.c ****     }
 458:../drivers/fsl_i2c_edma.c **** 
 459:../drivers/fsl_i2c_edma.c ****     /* Configure dma transfer. */
 460:../drivers/fsl_i2c_edma.c ****     /* For i2c send, need to send 1 byte first to trigger the dma, for i2c read,
 461:../drivers/fsl_i2c_edma.c ****     need to send stop before reading the last byte, so the dma transfer size should
 462:../drivers/fsl_i2c_edma.c ****     be (xSize - 1). */
 463:../drivers/fsl_i2c_edma.c ****     if (handle->transfer.dataSize > 1)
 486              		.loc 1 463 0
 487 00f6 6B69     		ldr	r3, [r5, #20]
 488 00f8 012B     		cmp	r3, #1
 489 00fa 6B79     		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 490 00fc 3AD8     		bhi	.L33
 464:../drivers/fsl_i2c_edma.c ****     {
 465:../drivers/fsl_i2c_edma.c ****         I2C_MasterTransferEDMAConfig(base, handle);
 466:../drivers/fsl_i2c_edma.c ****         if (handle->transfer.direction == kI2C_Read)
 467:../drivers/fsl_i2c_edma.c ****         {
 468:../drivers/fsl_i2c_edma.c ****             /* Change direction for receive. */
 469:../drivers/fsl_i2c_edma.c ****             base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
 470:../drivers/fsl_i2c_edma.c **** 
 471:../drivers/fsl_i2c_edma.c ****             /* Read dummy to release the bus. */
 472:../drivers/fsl_i2c_edma.c ****             dummy = base->D;
 473:../drivers/fsl_i2c_edma.c **** 
 474:../drivers/fsl_i2c_edma.c ****             /* Enabe dma transfer. */
 475:../drivers/fsl_i2c_edma.c ****             I2C_EnableDMA(base, true);
 476:../drivers/fsl_i2c_edma.c ****         }
 477:../drivers/fsl_i2c_edma.c ****         else
 478:../drivers/fsl_i2c_edma.c ****         {
 479:../drivers/fsl_i2c_edma.c ****             /* Enabe dma transfer. */
 480:../drivers/fsl_i2c_edma.c ****             I2C_EnableDMA(base, true);
 481:../drivers/fsl_i2c_edma.c **** 
 482:../drivers/fsl_i2c_edma.c ****             /* Send the first data. */
 483:../drivers/fsl_i2c_edma.c ****             base->D = *handle->transfer.data;
 484:../drivers/fsl_i2c_edma.c ****         }
 485:../drivers/fsl_i2c_edma.c ****     }
 486:../drivers/fsl_i2c_edma.c ****     else /* If transfer size is 1, use polling method. */
 487:../drivers/fsl_i2c_edma.c ****     {
 488:../drivers/fsl_i2c_edma.c ****         if (handle->transfer.direction == kI2C_Read)
 491              		.loc 1 488 0
 492 00fe 012B     		cmp	r3, #1
 493 0100 40F08180 		bne	.L43
 489:../drivers/fsl_i2c_edma.c ****         {
 490:../drivers/fsl_i2c_edma.c ****             tmpReg = base->C1;
 494              		.loc 1 490 0
 495 0104 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 496              	.LVL47:
 491:../drivers/fsl_i2c_edma.c **** 
 492:../drivers/fsl_i2c_edma.c ****             /* Change direction to Rx. */
 493:../drivers/fsl_i2c_edma.c ****             tmpReg &= ~I2C_C1_TX_MASK;
 497              		.loc 1 493 0
 498 0106 03F0EF03 		and	r3, r3, #239
 499              	.LVL48:
 494:../drivers/fsl_i2c_edma.c **** 
 495:../drivers/fsl_i2c_edma.c ****             /* Configure send NAK */
 496:../drivers/fsl_i2c_edma.c ****             tmpReg |= I2C_C1_TXAK_MASK;
 500              		.loc 1 496 0
 501 010a 43F00803 		orr	r3, r3, #8
 502              	.LVL49:
 497:../drivers/fsl_i2c_edma.c **** 
 498:../drivers/fsl_i2c_edma.c ****             base->C1 = tmpReg;
 503              		.loc 1 498 0
 504 010e A370     		strb	r3, [r4, #2]
 499:../drivers/fsl_i2c_edma.c **** 
 500:../drivers/fsl_i2c_edma.c ****             /* Read dummy to release the bus. */
 501:../drivers/fsl_i2c_edma.c ****             dummy = base->D;
 505              		.loc 1 501 0
 506 0110 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 507              	.LVL50:
 508 0112 DBB2     		uxtb	r3, r3
 509 0114 8DF80730 		strb	r3, [sp, #7]
 510              	.LVL51:
 511              	.L44:
 502:../drivers/fsl_i2c_edma.c ****         }
 503:../drivers/fsl_i2c_edma.c ****         else
 504:../drivers/fsl_i2c_edma.c ****         {
 505:../drivers/fsl_i2c_edma.c ****             base->D = *handle->transfer.data;
 506:../drivers/fsl_i2c_edma.c ****         }
 507:../drivers/fsl_i2c_edma.c **** 
 508:../drivers/fsl_i2c_edma.c ****         /* Wait until data transfer complete. */
 509:../drivers/fsl_i2c_edma.c ****         while (!(base->S & kI2C_IntPendingFlag))
 512              		.loc 1 509 0 discriminator 1
 513 0118 E378     		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 514 011a 9A07     		lsls	r2, r3, #30
 515 011c FCD5     		bpl	.L44
 510:../drivers/fsl_i2c_edma.c ****         {
 511:../drivers/fsl_i2c_edma.c ****         }
 512:../drivers/fsl_i2c_edma.c **** 
 513:../drivers/fsl_i2c_edma.c ****         /* Clear pending flag. */
 514:../drivers/fsl_i2c_edma.c ****         base->S = kI2C_IntPendingFlag;
 516              		.loc 1 514 0
 517 011e 0223     		movs	r3, #2
 518 0120 E370     		strb	r3, [r4, #3]
 515:../drivers/fsl_i2c_edma.c **** 
 516:../drivers/fsl_i2c_edma.c ****         /* Send stop if kI2C_TransferNoStop flag is not asserted. */
 517:../drivers/fsl_i2c_edma.c ****         if (!(handle->transfer.flags & kI2C_TransferNoStopFlag))
 519              		.loc 1 517 0
 520 0122 2B68     		ldr	r3, [r5]
 521 0124 5B07     		lsls	r3, r3, #29
 522 0126 72D4     		bmi	.L46
 518:../drivers/fsl_i2c_edma.c ****         {
 519:../drivers/fsl_i2c_edma.c ****             result = I2C_MasterStop(base);
 523              		.loc 1 519 0
 524 0128 2046     		mov	r0, r4
 525 012a FFF7FEFF 		bl	I2C_MasterStop
 526              	.LVL52:
 527 012e 0646     		mov	r6, r0
 528              	.LVL53:
 529              	.L47:
 520:../drivers/fsl_i2c_edma.c ****         }
 521:../drivers/fsl_i2c_edma.c ****         else
 522:../drivers/fsl_i2c_edma.c ****         {
 523:../drivers/fsl_i2c_edma.c ****             /* Change direction to send. */
 524:../drivers/fsl_i2c_edma.c ****             base->C1 |= I2C_C1_TX_MASK;
 525:../drivers/fsl_i2c_edma.c ****         }
 526:../drivers/fsl_i2c_edma.c **** 
 527:../drivers/fsl_i2c_edma.c ****         /* Read the last byte of data. */
 528:../drivers/fsl_i2c_edma.c ****         if (handle->transfer.direction == kI2C_Read)
 530              		.loc 1 528 0
 531 0130 6B79     		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 532 0132 012B     		cmp	r3, #1
 529:../drivers/fsl_i2c_edma.c ****         {
 530:../drivers/fsl_i2c_edma.c ****             *handle->transfer.data = base->D;
 533              		.loc 1 530 0
 534 0134 02BF     		ittt	eq
 535 0136 2B69     		ldreq	r3, [r5, #16]
 536 0138 2279     		ldrbeq	r2, [r4, #4]	@ zero_extendqisi2
 537 013a 1A70     		strbeq	r2, [r3]
 538 013c 82E0     		b	.L48
 539              	.LVL54:
 540              	.L32:
 541              	.LBB67:
 542              	.LBB62:
 543              	.LBB58:
 328:../drivers/fsl_i2c_edma.c **** 
 544              		.loc 1 328 0
 545 013e 0223     		movs	r3, #2
 546 0140 E370     		strb	r3, [r4, #3]
 331:../drivers/fsl_i2c_edma.c **** 
 547              		.loc 1 331 0
 548 0142 2979     		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 549 0144 2046     		mov	r0, r4
 550 0146 FFF7FEFF 		bl	I2C_MasterRepeatedStart
 551              	.LVL55:
 333:../drivers/fsl_i2c_edma.c ****                 {
 552              		.loc 1 333 0
 553 014a 0028     		cmp	r0, #0
 554 014c 64D1     		bne	.L56
 555              	.L35:
 339:../drivers/fsl_i2c_edma.c ****                 {
 556              		.loc 1 339 0
 557 014e E378     		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 558 0150 9F07     		lsls	r7, r3, #30
 559 0152 FCD5     		bpl	.L35
 344:../drivers/fsl_i2c_edma.c **** 
 560              		.loc 1 344 0
 561 0154 E378     		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 562 0156 DBB2     		uxtb	r3, r3
 563              	.LVL56:
 564              	.LBB57:
 565              	.LBB53:
 204:../drivers/fsl_i2c_edma.c ****     {
 566              		.loc 1 204 0
 567 0158 D806     		lsls	r0, r3, #27
 568              	.LVL57:
 569 015a 9DD4     		bmi	.L80
 211:../drivers/fsl_i2c_edma.c ****     {
 570              		.loc 1 211 0
 571 015c D907     		lsls	r1, r3, #31
 572 015e C8D5     		bpl	.L38
 573              	.LVL58:
 574              	.L52:
 575              	.LBE53:
 576              	.LBE57:
 577              	.LBE58:
 578              	.LBE62:
 579              	.LBE67:
 447:../drivers/fsl_i2c_edma.c ****             {
 580              		.loc 1 447 0
 581 0160 2046     		mov	r0, r4
 582 0162 FFF7FEFF 		bl	I2C_MasterStop
 583              	.LVL59:
 584 0166 0028     		cmp	r0, #0
 585 0168 40F24E46 		movw	r6, #1102
 586 016c 18BF     		it	ne
 587 016e 4FF48A66 		movne	r6, #1104
 588 0172 67E0     		b	.L48
 589              	.L33:
 590              	.LVL60:
 591              	.LBB68:
 592              	.LBB69:
 364:../drivers/fsl_i2c_edma.c ****     {
 593              		.loc 1 364 0
 594 0174 012B     		cmp	r3, #1
 595 0176 04F10402 		add	r2, r4, #4
 596 017a 2AD1     		bne	.L40
 366:../drivers/fsl_i2c_edma.c ****         transfer_config.destAddr = (uint32_t)(handle->transfer.data);
 597              		.loc 1 366 0
 598 017c 0292     		str	r2, [sp, #8]
 367:../drivers/fsl_i2c_edma.c ****         transfer_config.majorLoopCounts = (handle->transfer.dataSize - 1);
 599              		.loc 1 367 0
 600 017e 2A69     		ldr	r2, [r5, #16]
 601 0180 0392     		str	r2, [sp, #12]
 368:../drivers/fsl_i2c_edma.c ****         transfer_config.srcTransferSize = kEDMA_TransferSize1Bytes;
 602              		.loc 1 368 0
 603 0182 6A69     		ldr	r2, [r5, #20]
 372:../drivers/fsl_i2c_edma.c ****         transfer_config.minorLoopBytes = 1;
 604              		.loc 1 372 0
 605 0184 ADF81430 		strh	r3, [sp, #20]	@ movhi
 368:../drivers/fsl_i2c_edma.c ****         transfer_config.srcTransferSize = kEDMA_TransferSize1Bytes;
 606              		.loc 1 368 0
 607 0188 013A     		subs	r2, r2, #1
 608 018a 0792     		str	r2, [sp, #28]
 369:../drivers/fsl_i2c_edma.c ****         transfer_config.srcOffset = 0;
 609              		.loc 1 369 0
 610 018c 0022     		movs	r2, #0
 611 018e 8DF81020 		strb	r2, [sp, #16]
 370:../drivers/fsl_i2c_edma.c ****         transfer_config.destTransferSize = kEDMA_TransferSize1Bytes;
 612              		.loc 1 370 0
 613 0192 ADF81220 		strh	r2, [sp, #18]	@ movhi
 371:../drivers/fsl_i2c_edma.c ****         transfer_config.destOffset = 1;
 614              		.loc 1 371 0
 615 0196 8DF81120 		strb	r2, [sp, #17]
 373:../drivers/fsl_i2c_edma.c ****     }
 616              		.loc 1 373 0
 617 019a 0693     		str	r3, [sp, #24]
 618              	.L41:
 388:../drivers/fsl_i2c_edma.c **** 
 619              		.loc 1 388 0
 620 019c 0123     		movs	r3, #1
 621 019e 2B77     		strb	r3, [r5, #28]
 390:../drivers/fsl_i2c_edma.c ****     EDMA_StartTransfer(handle->dmaHandle);
 622              		.loc 1 390 0
 623 01a0 02A9     		add	r1, sp, #8
 624 01a2 286A     		ldr	r0, [r5, #32]
 625 01a4 FFF7FEFF 		bl	EDMA_SubmitTransfer
 626              	.LVL61:
 391:../drivers/fsl_i2c_edma.c **** }
 627              		.loc 1 391 0
 628 01a8 286A     		ldr	r0, [r5, #32]
 629 01aa FFF7FEFF 		bl	EDMA_StartTransfer
 630              	.LVL62:
 631              	.LBE69:
 632              	.LBE68:
 466:../drivers/fsl_i2c_edma.c ****         {
 633              		.loc 1 466 0
 634 01ae 6B79     		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 635 01b0 012B     		cmp	r3, #1
 469:../drivers/fsl_i2c_edma.c **** 
 636              		.loc 1 469 0
 637 01b2 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 466:../drivers/fsl_i2c_edma.c ****         {
 638              		.loc 1 466 0
 639 01b4 20D1     		bne	.L42
 469:../drivers/fsl_i2c_edma.c **** 
 640              		.loc 1 469 0
 641 01b6 03F0E703 		and	r3, r3, #231
 642 01ba A370     		strb	r3, [r4, #2]
 472:../drivers/fsl_i2c_edma.c **** 
 643              		.loc 1 472 0
 644 01bc 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 645 01be DBB2     		uxtb	r3, r3
 646 01c0 8DF80730 		strb	r3, [sp, #7]
 647              	.LVL63:
 648              	.LBB71:
 649              	.LBB72:
 525:../drivers/fsl_i2c.h ****     }
 650              		.loc 2 525 0
 651 01c4 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 652 01c6 43F00103 		orr	r3, r3, #1
 653 01ca A370     		strb	r3, [r4, #2]
 654              	.LVL64:
 655              	.L16:
 656              	.LBE72:
 657              	.LBE71:
 531:../drivers/fsl_i2c_edma.c ****         }
 532:../drivers/fsl_i2c_edma.c **** 
 533:../drivers/fsl_i2c_edma.c ****         /* Reset the state to idle. */
 534:../drivers/fsl_i2c_edma.c ****         handle->state = kIdleState;
 535:../drivers/fsl_i2c_edma.c ****     }
 536:../drivers/fsl_i2c_edma.c **** 
 537:../drivers/fsl_i2c_edma.c ****     return result;
 538:../drivers/fsl_i2c_edma.c **** }
 658              		.loc 1 538 0
 659 01cc 3046     		mov	r0, r6
 660 01ce 09B0     		add	sp, sp, #36
 661              		.cfi_remember_state
 662              		.cfi_def_cfa_offset 20
 663              		@ sp needed
 664 01d0 F0BD     		pop	{r4, r5, r6, r7, pc}
 665              	.LVL65:
 666              	.L40:
 667              		.cfi_restore_state
 668              	.LBB73:
 669              	.LBB70:
 377:../drivers/fsl_i2c_edma.c ****         transfer_config.destAddr = (uint32_t)I2C_GetDataRegAddr(base);
 670              		.loc 1 377 0
 671 01d2 2B69     		ldr	r3, [r5, #16]
 378:../drivers/fsl_i2c_edma.c ****         transfer_config.majorLoopCounts = (handle->transfer.dataSize - 1);
 672              		.loc 1 378 0
 673 01d4 0392     		str	r2, [sp, #12]
 377:../drivers/fsl_i2c_edma.c ****         transfer_config.destAddr = (uint32_t)I2C_GetDataRegAddr(base);
 674              		.loc 1 377 0
 675 01d6 0133     		adds	r3, r3, #1
 676 01d8 0293     		str	r3, [sp, #8]
 379:../drivers/fsl_i2c_edma.c ****         transfer_config.srcTransferSize = kEDMA_TransferSize1Bytes;
 677              		.loc 1 379 0
 678 01da 6B69     		ldr	r3, [r5, #20]
 679 01dc 013B     		subs	r3, r3, #1
 381:../drivers/fsl_i2c_edma.c ****         transfer_config.destTransferSize = kEDMA_TransferSize1Bytes;
 680              		.loc 1 381 0
 681 01de 0122     		movs	r2, #1
 379:../drivers/fsl_i2c_edma.c ****         transfer_config.srcTransferSize = kEDMA_TransferSize1Bytes;
 682              		.loc 1 379 0
 683 01e0 0793     		str	r3, [sp, #28]
 380:../drivers/fsl_i2c_edma.c ****         transfer_config.srcOffset = 1;
 684              		.loc 1 380 0
 685 01e2 0023     		movs	r3, #0
 686 01e4 8DF81030 		strb	r3, [sp, #16]
 381:../drivers/fsl_i2c_edma.c ****         transfer_config.destTransferSize = kEDMA_TransferSize1Bytes;
 687              		.loc 1 381 0
 688 01e8 ADF81220 		strh	r2, [sp, #18]	@ movhi
 382:../drivers/fsl_i2c_edma.c ****         transfer_config.destOffset = 0;
 689              		.loc 1 382 0
 690 01ec 8DF81130 		strb	r3, [sp, #17]
 383:../drivers/fsl_i2c_edma.c ****         transfer_config.minorLoopBytes = 1;
 691              		.loc 1 383 0
 692 01f0 ADF81430 		strh	r3, [sp, #20]	@ movhi
 384:../drivers/fsl_i2c_edma.c ****     }
 693              		.loc 1 384 0
 694 01f4 0692     		str	r2, [sp, #24]
 695 01f6 D1E7     		b	.L41
 696              	.LVL66:
 697              	.L42:
 698              	.LBE70:
 699              	.LBE73:
 700              	.LBB74:
 701              	.LBB75:
 525:../drivers/fsl_i2c.h ****     }
 702              		.loc 2 525 0
 703 01f8 43F00103 		orr	r3, r3, #1
 704 01fc A370     		strb	r3, [r4, #2]
 705              	.LVL67:
 706              	.LBE75:
 707              	.LBE74:
 483:../drivers/fsl_i2c_edma.c ****         }
 708              		.loc 1 483 0
 709 01fe 2B69     		ldr	r3, [r5, #16]
 710 0200 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 711 0202 2371     		strb	r3, [r4, #4]
 712 0204 E2E7     		b	.L16
 713              	.L43:
 505:../drivers/fsl_i2c_edma.c ****         }
 714              		.loc 1 505 0
 715 0206 2B69     		ldr	r3, [r5, #16]
 716 0208 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 717 020a 2371     		strb	r3, [r4, #4]
 718 020c 84E7     		b	.L44
 719              	.L46:
 524:../drivers/fsl_i2c_edma.c ****         }
 720              		.loc 1 524 0
 721 020e A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 722 0210 43F01003 		orr	r3, r3, #16
 723 0214 A370     		strb	r3, [r4, #2]
 724 0216 8BE7     		b	.L47
 725              	.LVL68:
 726              	.L56:
 727              	.LBB76:
 728              	.LBB63:
 729              	.LBB59:
 333:../drivers/fsl_i2c_edma.c ****                 {
 730              		.loc 1 333 0
 731 0218 0646     		mov	r6, r0
 732              	.L21:
 733              	.LVL69:
 734              	.LBE59:
 735              	.LBE63:
 736              	.LBE76:
 445:../drivers/fsl_i2c_edma.c ****         {
 737              		.loc 1 445 0
 738 021a 40F24E43 		movw	r3, #1102
 739 021e 9E42     		cmp	r6, r3
 740 0220 9ED0     		beq	.L52
 741 0222 0FE0     		b	.L48
 742              	.LVL70:
 743              	.L25:
 744              	.LBB77:
 745              	.LBB64:
 746              	.LBB60:
 285:../drivers/fsl_i2c_edma.c ****                 {
 747              		.loc 1 285 0
 748 0224 2046     		mov	r0, r4
 749 0226 FFF7FEFF 		bl	I2C_MasterStop
 750              	.LVL71:
 290:../drivers/fsl_i2c_edma.c ****                 {
 751              		.loc 1 290 0
 752 022a 6F6A     		ldr	r7, [r5, #36]
 283:../drivers/fsl_i2c_edma.c **** 
 753              		.loc 1 283 0
 754 022c 0028     		cmp	r0, #0
 755 022e 40F25146 		movw	r6, #1105
 756 0232 18BF     		it	ne
 757 0234 4FF48A66 		movne	r6, #1104
 758              	.LVL72:
 290:../drivers/fsl_i2c_edma.c ****                 {
 759              		.loc 1 290 0
 760 0238 27B1     		cbz	r7, .L48
 292:../drivers/fsl_i2c_edma.c ****                 }
 761              		.loc 1 292 0
 762 023a AB6A     		ldr	r3, [r5, #40]
 763 023c 3246     		mov	r2, r6
 764 023e 2946     		mov	r1, r5
 765 0240 2046     		mov	r0, r4
 766 0242 B847     		blx	r7
 767              	.LVL73:
 768              	.L48:
 769              	.LBE60:
 770              	.LBE64:
 771              	.LBE77:
 534:../drivers/fsl_i2c_edma.c ****     }
 772              		.loc 1 534 0
 773 0244 0023     		movs	r3, #0
 774 0246 6B77     		strb	r3, [r5, #29]
 775 0248 C0E7     		b	.L16
 776              	.LVL74:
 777              	.L30:
 778 024a 2B73     		strb	r3, [r5, #12]
 779 024c 88E7     		b	.L52
 780              	.LVL75:
 781              	.L54:
 782              	.LBB78:
 783              	.LBB65:
 233:../drivers/fsl_i2c_edma.c ****     }
 784              		.loc 1 233 0
 785 024e 40F24C46 		movw	r6, #1100
 786              	.LVL76:
 787 0252 F7E7     		b	.L48
 788              	.LBE65:
 789              	.LBE78:
 790              		.cfi_endproc
 791              	.LFE168:
 793              		.section	.text.I2C_MasterTransferGetCountEDMA,"ax",%progbits
 794              		.align	1
 795              		.global	I2C_MasterTransferGetCountEDMA
 796              		.syntax unified
 797              		.thumb
 798              		.thumb_func
 799              		.fpu fpv4-sp-d16
 801              	I2C_MasterTransferGetCountEDMA:
 802              	.LFB169:
 539:../drivers/fsl_i2c_edma.c **** 
 540:../drivers/fsl_i2c_edma.c **** status_t I2C_MasterTransferGetCountEDMA(I2C_Type *base, i2c_master_edma_handle_t *handle, size_t *c
 541:../drivers/fsl_i2c_edma.c **** {
 803              		.loc 1 541 0
 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 0
 806              		@ frame_needed = 0, uses_anonymous_args = 0
 807              	.LVL77:
 808 0000 70B5     		push	{r4, r5, r6, lr}
 809              		.cfi_def_cfa_offset 16
 810              		.cfi_offset 4, -16
 811              		.cfi_offset 5, -12
 812              		.cfi_offset 6, -8
 813              		.cfi_offset 14, -4
 542:../drivers/fsl_i2c_edma.c ****     assert(handle->dmaHandle);
 543:../drivers/fsl_i2c_edma.c **** 
 544:../drivers/fsl_i2c_edma.c ****     if (!count)
 814              		.loc 1 544 0
 815 0002 1446     		mov	r4, r2
 816 0004 7AB1     		cbz	r2, .L84
 545:../drivers/fsl_i2c_edma.c ****     {
 546:../drivers/fsl_i2c_edma.c ****         return kStatus_InvalidArgument;
 547:../drivers/fsl_i2c_edma.c ****     }
 548:../drivers/fsl_i2c_edma.c **** 
 549:../drivers/fsl_i2c_edma.c ****     if (kIdleState != handle->state)
 817              		.loc 1 549 0
 818 0006 487F     		ldrb	r0, [r1, #29]	@ zero_extendqisi2
 819              	.LVL78:
 820 0008 8E69     		ldr	r6, [r1, #24]
 821 000a 50B1     		cbz	r0, .L83
 550:../drivers/fsl_i2c_edma.c ****     {
 551:../drivers/fsl_i2c_edma.c ****         *count = (handle->transferSize -
 552:../drivers/fsl_i2c_edma.c ****                   (uint32_t)handle->nbytes *
 553:../drivers/fsl_i2c_edma.c ****                       EDMA_GetRemainingMajorLoopCount(handle->dmaHandle->base, handle->dmaHandle->c
 822              		.loc 1 553 0
 823 000c 0B6A     		ldr	r3, [r1, #32]
 552:../drivers/fsl_i2c_edma.c ****                       EDMA_GetRemainingMajorLoopCount(handle->dmaHandle->base, handle->dmaHandle->c
 824              		.loc 1 552 0
 825 000e 0D7F     		ldrb	r5, [r1, #28]	@ zero_extendqisi2
 826              		.loc 1 553 0
 827 0010 9868     		ldr	r0, [r3, #8]
 828 0012 197C     		ldrb	r1, [r3, #16]	@ zero_extendqisi2
 829              	.LVL79:
 830 0014 FFF7FEFF 		bl	EDMA_GetRemainingMajorLoopCount
 831              	.LVL80:
 551:../drivers/fsl_i2c_edma.c ****                   (uint32_t)handle->nbytes *
 832              		.loc 1 551 0
 833 0018 00FB1560 		mls	r0, r0, r5, r6
 834 001c 2060     		str	r0, [r4]
 554:../drivers/fsl_i2c_edma.c ****     }
 555:../drivers/fsl_i2c_edma.c ****     else
 556:../drivers/fsl_i2c_edma.c ****     {
 557:../drivers/fsl_i2c_edma.c ****         *count = handle->transferSize;
 558:../drivers/fsl_i2c_edma.c ****     }
 559:../drivers/fsl_i2c_edma.c **** 
 560:../drivers/fsl_i2c_edma.c ****     return kStatus_Success;
 835              		.loc 1 560 0
 836 001e 0020     		movs	r0, #0
 837 0020 70BD     		pop	{r4, r5, r6, pc}
 838              	.LVL81:
 839              	.L83:
 557:../drivers/fsl_i2c_edma.c ****     }
 840              		.loc 1 557 0
 841 0022 1660     		str	r6, [r2]
 842 0024 70BD     		pop	{r4, r5, r6, pc}
 843              	.LVL82:
 844              	.L84:
 546:../drivers/fsl_i2c_edma.c ****     }
 845              		.loc 1 546 0
 846 0026 0420     		movs	r0, #4
 847              	.LVL83:
 561:../drivers/fsl_i2c_edma.c **** }
 848              		.loc 1 561 0
 849 0028 70BD     		pop	{r4, r5, r6, pc}
 850              		.cfi_endproc
 851              	.LFE169:
 853              		.section	.text.I2C_MasterTransferAbortEDMA,"ax",%progbits
 854              		.align	1
 855              		.global	I2C_MasterTransferAbortEDMA
 856              		.syntax unified
 857              		.thumb
 858              		.thumb_func
 859              		.fpu fpv4-sp-d16
 861              	I2C_MasterTransferAbortEDMA:
 862              	.LFB170:
 562:../drivers/fsl_i2c_edma.c **** 
 563:../drivers/fsl_i2c_edma.c **** void I2C_MasterTransferAbortEDMA(I2C_Type *base, i2c_master_edma_handle_t *handle)
 564:../drivers/fsl_i2c_edma.c **** {
 863              		.loc 1 564 0
 864              		.cfi_startproc
 865              		@ args = 0, pretend = 0, frame = 0
 866              		@ frame_needed = 0, uses_anonymous_args = 0
 867              	.LVL84:
 868 0000 38B5     		push	{r3, r4, r5, lr}
 869              		.cfi_def_cfa_offset 16
 870              		.cfi_offset 3, -16
 871              		.cfi_offset 4, -12
 872              		.cfi_offset 5, -8
 873              		.cfi_offset 14, -4
 874              		.loc 1 564 0
 875 0002 0546     		mov	r5, r0
 565:../drivers/fsl_i2c_edma.c ****     EDMA_AbortTransfer(handle->dmaHandle);
 876              		.loc 1 565 0
 877 0004 086A     		ldr	r0, [r1, #32]
 878              	.LVL85:
 564:../drivers/fsl_i2c_edma.c ****     EDMA_AbortTransfer(handle->dmaHandle);
 879              		.loc 1 564 0
 880 0006 0C46     		mov	r4, r1
 881              		.loc 1 565 0
 882 0008 FFF7FEFF 		bl	EDMA_AbortTransfer
 883              	.LVL86:
 884              	.LBB79:
 885              	.LBB80:
 886              		.loc 2 529 0
 887 000c AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 888 000e 03F0FE03 		and	r3, r3, #254
 889 0012 AB70     		strb	r3, [r5, #2]
 890              	.LVL87:
 891              	.LBE80:
 892              	.LBE79:
 566:../drivers/fsl_i2c_edma.c **** 
 567:../drivers/fsl_i2c_edma.c ****     /* Disable dma transfer. */
 568:../drivers/fsl_i2c_edma.c ****     I2C_EnableDMA(base, false);
 569:../drivers/fsl_i2c_edma.c **** 
 570:../drivers/fsl_i2c_edma.c ****     /* Reset the state to idle. */
 571:../drivers/fsl_i2c_edma.c ****     handle->state = kIdleState;
 893              		.loc 1 571 0
 894 0014 0023     		movs	r3, #0
 895 0016 6377     		strb	r3, [r4, #29]
 896 0018 38BD     		pop	{r3, r4, r5, pc}
 897              		.cfi_endproc
 898              	.LFE170:
 900              		.section	.bss.s_edmaPrivateHandle,"aw",%nobits
 901              		.align	2
 902              		.set	.LANCHOR0,. + 0
 905              	s_edmaPrivateHandle:
 906 0000 00000000 		.space	24
 906      00000000 
 906      00000000 
 906      00000000 
 906      00000000 
 907              		.text
 908              	.Letext0:
 909              		.file 3 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 910              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 911              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 912              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 913              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 914              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 915              		.file 9 "../CMSIS/core_cm4.h"
 916              		.file 10 "../CMSIS/system_MK64F12.h"
 917              		.file 11 "../CMSIS/MK64F12.h"
 918              		.file 12 "../drivers/fsl_common.h"
 919              		.file 13 "../drivers/fsl_clock.h"
 920              		.file 14 "../drivers/fsl_edma.h"
 921              		.file 15 "../drivers/fsl_i2c_edma.h"
