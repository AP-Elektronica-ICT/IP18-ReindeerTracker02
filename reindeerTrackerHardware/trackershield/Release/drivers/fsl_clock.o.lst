   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_clock.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.CLOCK_FllStableDelay,"ax",%progbits
  18              		.align	1
  19              		.global	CLOCK_FllStableDelay
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	CLOCK_FllStableDelay:
  26              	.LFB147:
  27              		.file 1 "../drivers/fsl_clock.c"
   1:../drivers/fsl_clock.c **** /*
   2:../drivers/fsl_clock.c ****  * The Clear BSD License
   3:../drivers/fsl_clock.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.c ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.c ****  * All rights reserved.
   6:../drivers/fsl_clock.c ****  *
   7:../drivers/fsl_clock.c ****  *
   8:../drivers/fsl_clock.c ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.c ****  * that the following conditions are met:
  11:../drivers/fsl_clock.c ****  *
  12:../drivers/fsl_clock.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.c ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.c ****  *
  15:../drivers/fsl_clock.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.c ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.c ****  *
  19:../drivers/fsl_clock.c ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.c ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.c ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.c ****  *
  23:../drivers/fsl_clock.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.c ****  */
  35:../drivers/fsl_clock.c **** 
  36:../drivers/fsl_clock.c **** #include "fsl_clock.h"
  37:../drivers/fsl_clock.c **** 
  38:../drivers/fsl_clock.c **** /*******************************************************************************
  39:../drivers/fsl_clock.c ****  * Definitions
  40:../drivers/fsl_clock.c ****  ******************************************************************************/
  41:../drivers/fsl_clock.c **** 
  42:../drivers/fsl_clock.c **** /* Macro definition remap workaround. */
  43:../drivers/fsl_clock.c **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
  44:../drivers/fsl_clock.c **** #define MCG_C2_EREFS0_MASK MCG_C2_EREFS_MASK
  45:../drivers/fsl_clock.c **** #endif
  46:../drivers/fsl_clock.c **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
  47:../drivers/fsl_clock.c **** #define MCG_C2_HGO0_MASK MCG_C2_HGO_MASK
  48:../drivers/fsl_clock.c **** #endif
  49:../drivers/fsl_clock.c **** #if (defined(MCG_C2_RANGE_MASK) && !(defined(MCG_C2_RANGE0_MASK)))
  50:../drivers/fsl_clock.c **** #define MCG_C2_RANGE0_MASK MCG_C2_RANGE_MASK
  51:../drivers/fsl_clock.c **** #endif
  52:../drivers/fsl_clock.c **** #if (defined(MCG_C6_CME_MASK) && !(defined(MCG_C6_CME0_MASK)))
  53:../drivers/fsl_clock.c **** #define MCG_C6_CME0_MASK MCG_C6_CME_MASK
  54:../drivers/fsl_clock.c **** #endif
  55:../drivers/fsl_clock.c **** 
  56:../drivers/fsl_clock.c **** /* PLL fixed multiplier when there is not PRDIV and VDIV. */
  57:../drivers/fsl_clock.c **** #define PLL_FIXED_MULT (375U)
  58:../drivers/fsl_clock.c **** /* Max frequency of the reference clock used for internal clock trim. */
  59:../drivers/fsl_clock.c **** #define TRIM_REF_CLK_MIN (8000000U)
  60:../drivers/fsl_clock.c **** /* Min frequency of the reference clock used for internal clock trim. */
  61:../drivers/fsl_clock.c **** #define TRIM_REF_CLK_MAX (16000000U)
  62:../drivers/fsl_clock.c **** /* Max trim value of fast internal reference clock. */
  63:../drivers/fsl_clock.c **** #define TRIM_FIRC_MAX (5000000U)
  64:../drivers/fsl_clock.c **** /* Min trim value of fast internal reference clock. */
  65:../drivers/fsl_clock.c **** #define TRIM_FIRC_MIN (3000000U)
  66:../drivers/fsl_clock.c **** /* Max trim value of fast internal reference clock. */
  67:../drivers/fsl_clock.c **** #define TRIM_SIRC_MAX (39063U)
  68:../drivers/fsl_clock.c **** /* Min trim value of fast internal reference clock. */
  69:../drivers/fsl_clock.c **** #define TRIM_SIRC_MIN (31250U)
  70:../drivers/fsl_clock.c **** 
  71:../drivers/fsl_clock.c **** #define MCG_S_IRCST_VAL ((MCG->S & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
  72:../drivers/fsl_clock.c **** #define MCG_S_CLKST_VAL ((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
  73:../drivers/fsl_clock.c **** #define MCG_S_IREFST_VAL ((MCG->S & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
  74:../drivers/fsl_clock.c **** #define MCG_S_PLLST_VAL ((MCG->S & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
  75:../drivers/fsl_clock.c **** #define MCG_C1_FRDIV_VAL ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
  76:../drivers/fsl_clock.c **** #define MCG_C2_LP_VAL ((MCG->C2 & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
  77:../drivers/fsl_clock.c **** #define MCG_C2_RANGE_VAL ((MCG->C2 & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
  78:../drivers/fsl_clock.c **** #define MCG_SC_FCRDIV_VAL ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
  79:../drivers/fsl_clock.c **** #define MCG_S2_PLLCST_VAL ((MCG->S2 & MCG_S2_PLLCST_MASK) >> MCG_S2_PLLCST_SHIFT)
  80:../drivers/fsl_clock.c **** #define MCG_C7_OSCSEL_VAL ((MCG->C7 & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
  81:../drivers/fsl_clock.c **** #define MCG_C4_DMX32_VAL ((MCG->C4 & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
  82:../drivers/fsl_clock.c **** #define MCG_C4_DRST_DRS_VAL ((MCG->C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
  83:../drivers/fsl_clock.c **** #define MCG_C7_PLL32KREFSEL_VAL ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) >> MCG_C7_PLL32KREFSEL_SHIFT)
  84:../drivers/fsl_clock.c **** #define MCG_C5_PLLREFSEL0_VAL ((MCG->C5 & MCG_C5_PLLREFSEL0_MASK) >> MCG_C5_PLLREFSEL0_SHIFT)
  85:../drivers/fsl_clock.c **** #define MCG_C11_PLLREFSEL1_VAL ((MCG->C11 & MCG_C11_PLLREFSEL1_MASK) >> MCG_C11_PLLREFSEL1_SHIFT)
  86:../drivers/fsl_clock.c **** #define MCG_C11_PRDIV1_VAL ((MCG->C11 & MCG_C11_PRDIV1_MASK) >> MCG_C11_PRDIV1_SHIFT)
  87:../drivers/fsl_clock.c **** #define MCG_C12_VDIV1_VAL ((MCG->C12 & MCG_C12_VDIV1_MASK) >> MCG_C12_VDIV1_SHIFT)
  88:../drivers/fsl_clock.c **** #define MCG_C5_PRDIV0_VAL ((MCG->C5 & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
  89:../drivers/fsl_clock.c **** #define MCG_C6_VDIV0_VAL ((MCG->C6 & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
  90:../drivers/fsl_clock.c **** 
  91:../drivers/fsl_clock.c **** #define OSC_MODE_MASK (MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK | MCG_C2_RANGE0_MASK)
  92:../drivers/fsl_clock.c **** 
  93:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV1_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_S
  94:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV2_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_S
  95:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV3_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_S
  96:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV4_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_S
  97:../drivers/fsl_clock.c **** #define SIM_SOPT1_OSC32KSEL_VAL ((SIM->SOPT1 & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHI
  98:../drivers/fsl_clock.c **** #define SIM_SOPT2_PLLFLLSEL_VAL ((SIM->SOPT2 & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHI
  99:../drivers/fsl_clock.c **** 
 100:../drivers/fsl_clock.c **** /* MCG_S_CLKST definition. */
 101:../drivers/fsl_clock.c **** enum _mcg_clkout_stat
 102:../drivers/fsl_clock.c **** {
 103:../drivers/fsl_clock.c ****     kMCG_ClkOutStatFll, /* FLL.            */
 104:../drivers/fsl_clock.c ****     kMCG_ClkOutStatInt, /* Internal clock. */
 105:../drivers/fsl_clock.c ****     kMCG_ClkOutStatExt, /* External clock. */
 106:../drivers/fsl_clock.c ****     kMCG_ClkOutStatPll  /* PLL.            */
 107:../drivers/fsl_clock.c **** };
 108:../drivers/fsl_clock.c **** 
 109:../drivers/fsl_clock.c **** /* MCG_S_PLLST definition. */
 110:../drivers/fsl_clock.c **** enum _mcg_pllst
 111:../drivers/fsl_clock.c **** {
 112:../drivers/fsl_clock.c ****     kMCG_PllstFll, /* FLL is used. */
 113:../drivers/fsl_clock.c ****     kMCG_PllstPll  /* PLL is used. */
 114:../drivers/fsl_clock.c **** };
 115:../drivers/fsl_clock.c **** 
 116:../drivers/fsl_clock.c **** /*******************************************************************************
 117:../drivers/fsl_clock.c ****  * Variables
 118:../drivers/fsl_clock.c ****  ******************************************************************************/
 119:../drivers/fsl_clock.c **** 
 120:../drivers/fsl_clock.c **** /* Slow internal reference clock frequency. */
 121:../drivers/fsl_clock.c **** static uint32_t s_slowIrcFreq = 32768U;
 122:../drivers/fsl_clock.c **** /* Fast internal reference clock frequency. */
 123:../drivers/fsl_clock.c **** static uint32_t s_fastIrcFreq = 4000000U;
 124:../drivers/fsl_clock.c **** 
 125:../drivers/fsl_clock.c **** /* External XTAL0 (OSC0) clock frequency. */
 126:../drivers/fsl_clock.c **** uint32_t g_xtal0Freq;
 127:../drivers/fsl_clock.c **** /* External XTAL32K clock frequency. */
 128:../drivers/fsl_clock.c **** uint32_t g_xtal32Freq;
 129:../drivers/fsl_clock.c **** 
 130:../drivers/fsl_clock.c **** /*******************************************************************************
 131:../drivers/fsl_clock.c ****  * Prototypes
 132:../drivers/fsl_clock.c ****  ******************************************************************************/
 133:../drivers/fsl_clock.c **** 
 134:../drivers/fsl_clock.c **** /*!
 135:../drivers/fsl_clock.c ****  * @brief Get the MCG external reference clock frequency.
 136:../drivers/fsl_clock.c ****  *
 137:../drivers/fsl_clock.c ****  * Get the current MCG external reference clock frequency in Hz. It is
 138:../drivers/fsl_clock.c ****  * the frequency select by MCG_C7[OSCSEL]. This is an internal function.
 139:../drivers/fsl_clock.c ****  *
 140:../drivers/fsl_clock.c ****  * @return MCG external reference clock frequency in Hz.
 141:../drivers/fsl_clock.c ****  */
 142:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetMcgExtClkFreq(void);
 143:../drivers/fsl_clock.c **** 
 144:../drivers/fsl_clock.c **** /*!
 145:../drivers/fsl_clock.c ****  * @brief Get the MCG FLL external reference clock frequency.
 146:../drivers/fsl_clock.c ****  *
 147:../drivers/fsl_clock.c ****  * Get the current MCG FLL external reference clock frequency in Hz. It is
 148:../drivers/fsl_clock.c ****  * the frequency after by MCG_C1[FRDIV]. This is an internal function.
 149:../drivers/fsl_clock.c ****  *
 150:../drivers/fsl_clock.c ****  * @return MCG FLL external reference clock frequency in Hz.
 151:../drivers/fsl_clock.c ****  */
 152:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllExtRefClkFreq(void);
 153:../drivers/fsl_clock.c **** 
 154:../drivers/fsl_clock.c **** /*!
 155:../drivers/fsl_clock.c ****  * @brief Get the MCG FLL reference clock frequency.
 156:../drivers/fsl_clock.c ****  *
 157:../drivers/fsl_clock.c ****  * Get the current MCG FLL reference clock frequency in Hz. It is
 158:../drivers/fsl_clock.c ****  * the frequency select by MCG_C1[IREFS]. This is an internal function.
 159:../drivers/fsl_clock.c ****  *
 160:../drivers/fsl_clock.c ****  * @return MCG FLL reference clock frequency in Hz.
 161:../drivers/fsl_clock.c ****  */
 162:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllRefClkFreq(void);
 163:../drivers/fsl_clock.c **** 
 164:../drivers/fsl_clock.c **** /*!
 165:../drivers/fsl_clock.c ****  * @brief Get the frequency of clock selected by MCG_C2[IRCS].
 166:../drivers/fsl_clock.c ****  *
 167:../drivers/fsl_clock.c ****  * This clock's two output:
 168:../drivers/fsl_clock.c ****  *  1. MCGOUTCLK when MCG_S[CLKST]=0.
 169:../drivers/fsl_clock.c ****  *  2. MCGIRCLK when MCG_C1[IRCLKEN]=1.
 170:../drivers/fsl_clock.c ****  *
 171:../drivers/fsl_clock.c ****  * @return The frequency in Hz.
 172:../drivers/fsl_clock.c ****  */
 173:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetInternalRefClkSelectFreq(void);
 174:../drivers/fsl_clock.c **** 
 175:../drivers/fsl_clock.c **** /*!
 176:../drivers/fsl_clock.c ****  * @brief Get the MCG PLL/PLL0 reference clock frequency.
 177:../drivers/fsl_clock.c ****  *
 178:../drivers/fsl_clock.c ****  * Get the current MCG PLL/PLL0 reference clock frequency in Hz.
 179:../drivers/fsl_clock.c ****  * This is an internal function.
 180:../drivers/fsl_clock.c ****  *
 181:../drivers/fsl_clock.c ****  * @return MCG PLL/PLL0 reference clock frequency in Hz.
 182:../drivers/fsl_clock.c ****  */
 183:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetPll0RefFreq(void);
 184:../drivers/fsl_clock.c **** 
 185:../drivers/fsl_clock.c **** /*!
 186:../drivers/fsl_clock.c ****  * @brief Calculate the RANGE value base on crystal frequency.
 187:../drivers/fsl_clock.c ****  *
 188:../drivers/fsl_clock.c ****  * To setup external crystal oscillator, must set the register bits RANGE
 189:../drivers/fsl_clock.c ****  * base on the crystal frequency. This function returns the RANGE base on the
 190:../drivers/fsl_clock.c ****  * input frequency. This is an internal function.
 191:../drivers/fsl_clock.c ****  *
 192:../drivers/fsl_clock.c ****  * @param freq Crystal frequency in Hz.
 193:../drivers/fsl_clock.c ****  * @return The RANGE value.
 194:../drivers/fsl_clock.c ****  */
 195:../drivers/fsl_clock.c **** static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq);
 196:../drivers/fsl_clock.c **** 
 197:../drivers/fsl_clock.c **** /*******************************************************************************
 198:../drivers/fsl_clock.c ****  * Code
 199:../drivers/fsl_clock.c ****  ******************************************************************************/
 200:../drivers/fsl_clock.c **** 
 201:../drivers/fsl_clock.c **** #ifndef MCG_USER_CONFIG_FLL_STABLE_DELAY_EN
 202:../drivers/fsl_clock.c **** /*!
 203:../drivers/fsl_clock.c ****  * @brief Delay function to wait FLL stable.
 204:../drivers/fsl_clock.c ****  *
 205:../drivers/fsl_clock.c ****  * Delay function to wait FLL stable in FEI mode or FEE mode, should wait at least
 206:../drivers/fsl_clock.c ****  * 1ms. Every time changes FLL setting, should wait this time for FLL stable.
 207:../drivers/fsl_clock.c ****  */
 208:../drivers/fsl_clock.c **** void CLOCK_FllStableDelay(void)
 209:../drivers/fsl_clock.c **** {
  28              		.loc 1 209 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33 0000 82B0     		sub	sp, sp, #8
  34              		.cfi_def_cfa_offset 8
 210:../drivers/fsl_clock.c ****     /*
 211:../drivers/fsl_clock.c ****        Should wait at least 1ms. Because in these modes, the core clock is 100MHz
 212:../drivers/fsl_clock.c ****        at most, so this function could obtain the 1ms delay.
 213:../drivers/fsl_clock.c ****      */
 214:../drivers/fsl_clock.c ****     volatile uint32_t i = 30000U;
  35              		.loc 1 214 0
  36 0002 47F23053 		movw	r3, #30000
  37 0006 0193     		str	r3, [sp, #4]
  38              	.L2:
 215:../drivers/fsl_clock.c ****     while (i--)
  39              		.loc 1 215 0
  40 0008 019B     		ldr	r3, [sp, #4]
  41 000a 5A1E     		subs	r2, r3, #1
  42 000c 0192     		str	r2, [sp, #4]
  43 000e 0BB9     		cbnz	r3, .L3
 216:../drivers/fsl_clock.c ****     {
 217:../drivers/fsl_clock.c ****         __NOP();
 218:../drivers/fsl_clock.c ****     }
 219:../drivers/fsl_clock.c **** }
  44              		.loc 1 219 0
  45 0010 02B0     		add	sp, sp, #8
  46              		.cfi_remember_state
  47              		.cfi_def_cfa_offset 0
  48              		@ sp needed
  49 0012 7047     		bx	lr
  50              	.L3:
  51              		.cfi_restore_state
 217:../drivers/fsl_clock.c ****     }
  52              		.loc 1 217 0
  53              		.syntax unified
  54              	@ 217 "../drivers/fsl_clock.c" 1
  55 0014 00BF     		nop
  56              	@ 0 "" 2
  57              		.thumb
  58              		.syntax unified
  59 0016 F7E7     		b	.L2
  60              		.cfi_endproc
  61              	.LFE147:
  63              		.section	.text.CLOCK_GetMcgExtClkFreq,"ax",%progbits
  64              		.align	1
  65              		.syntax unified
  66              		.thumb
  67              		.thumb_func
  68              		.fpu fpv4-sp-d16
  70              	CLOCK_GetMcgExtClkFreq:
  71              	.LFB148:
 220:../drivers/fsl_clock.c **** #else  /* With MCG_USER_CONFIG_FLL_STABLE_DELAY_EN defined. */
 221:../drivers/fsl_clock.c **** /* Once user defines the MCG_USER_CONFIG_FLL_STABLE_DELAY_EN to use their own delay function, he ha
 222:../drivers/fsl_clock.c ****  * create his own CLOCK_FllStableDelay() function in application code. Since the clock functions in
 223:../drivers/fsl_clock.c ****  * file would call the CLOCK_FllStableDelay() regardness how it is defined.
 224:../drivers/fsl_clock.c ****  */
 225:../drivers/fsl_clock.c **** extern void CLOCK_FllStableDelay(void);
 226:../drivers/fsl_clock.c **** #endif /* MCG_USER_CONFIG_FLL_STABLE_DELAY_EN */
 227:../drivers/fsl_clock.c **** 
 228:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetMcgExtClkFreq(void)
 229:../drivers/fsl_clock.c **** {
  72              		.loc 1 229 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76              		@ link register save eliminated.
 230:../drivers/fsl_clock.c ****     uint32_t freq;
 231:../drivers/fsl_clock.c **** 
 232:../drivers/fsl_clock.c ****     switch (MCG_C7_OSCSEL_VAL)
  77              		.loc 1 232 0
  78 0000 084B     		ldr	r3, .L11
  79 0002 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
  80 0004 03F00303 		and	r3, r3, #3
  81 0008 012B     		cmp	r3, #1
  82 000a 08D0     		beq	.L6
  83 000c 04D3     		bcc	.L7
  84 000e 022B     		cmp	r3, #2
 233:../drivers/fsl_clock.c ****     {
 234:../drivers/fsl_clock.c ****         case 0U:
 235:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
 236:../drivers/fsl_clock.c ****             assert(g_xtal0Freq);
 237:../drivers/fsl_clock.c ****             freq = g_xtal0Freq;
 238:../drivers/fsl_clock.c ****             break;
 239:../drivers/fsl_clock.c ****         case 1U:
 240:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN
 241:../drivers/fsl_clock.c ****             assert(g_xtal32Freq);
 242:../drivers/fsl_clock.c ****             freq = g_xtal32Freq;
 243:../drivers/fsl_clock.c ****             break;
 244:../drivers/fsl_clock.c ****         case 2U:
 245:../drivers/fsl_clock.c ****             freq = MCG_INTERNAL_IRC_48M;
 246:../drivers/fsl_clock.c ****             break;
 247:../drivers/fsl_clock.c ****         default:
 248:../drivers/fsl_clock.c ****             freq = 0U;
  85              		.loc 1 248 0
  86 0010 0548     		ldr	r0, .L11+4
  87 0012 18BF     		it	ne
  88 0014 0020     		movne	r0, #0
  89 0016 7047     		bx	lr
  90              	.L7:
 237:../drivers/fsl_clock.c ****             break;
  91              		.loc 1 237 0
  92 0018 044B     		ldr	r3, .L11+8
  93              	.L10:
 242:../drivers/fsl_clock.c ****             break;
  94              		.loc 1 242 0
  95 001a 1868     		ldr	r0, [r3]
  96              	.LVL0:
 249:../drivers/fsl_clock.c ****             break;
 250:../drivers/fsl_clock.c ****     }
 251:../drivers/fsl_clock.c **** 
 252:../drivers/fsl_clock.c ****     return freq;
 253:../drivers/fsl_clock.c **** }
  97              		.loc 1 253 0
  98 001c 7047     		bx	lr
  99              	.LVL1:
 100              	.L6:
 242:../drivers/fsl_clock.c ****             break;
 101              		.loc 1 242 0
 102 001e 044B     		ldr	r3, .L11+12
 103 0020 FBE7     		b	.L10
 104              	.L12:
 105 0022 00BF     		.align	2
 106              	.L11:
 107 0024 00400640 		.word	1074151424
 108 0028 006CDC02 		.word	48000000
 109 002c 00000000 		.word	g_xtal0Freq
 110 0030 00000000 		.word	g_xtal32Freq
 111              		.cfi_endproc
 112              	.LFE148:
 114              		.section	.text.CLOCK_GetFllExtRefClkFreq,"ax",%progbits
 115              		.align	1
 116              		.syntax unified
 117              		.thumb
 118              		.thumb_func
 119              		.fpu fpv4-sp-d16
 121              	CLOCK_GetFllExtRefClkFreq:
 122              	.LFB149:
 254:../drivers/fsl_clock.c **** 
 255:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllExtRefClkFreq(void)
 256:../drivers/fsl_clock.c **** {
 123              		.loc 1 256 0
 124              		.cfi_startproc
 125              		@ args = 0, pretend = 0, frame = 0
 126              		@ frame_needed = 0, uses_anonymous_args = 0
 127 0000 08B5     		push	{r3, lr}
 128              		.cfi_def_cfa_offset 8
 129              		.cfi_offset 3, -8
 130              		.cfi_offset 14, -4
 257:../drivers/fsl_clock.c ****     /* FllExtRef = McgExtRef / FllExtRefDiv */
 258:../drivers/fsl_clock.c ****     uint8_t frdiv;
 259:../drivers/fsl_clock.c ****     uint8_t range;
 260:../drivers/fsl_clock.c ****     uint8_t oscsel;
 261:../drivers/fsl_clock.c **** 
 262:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetMcgExtClkFreq();
 131              		.loc 1 262 0
 132 0002 FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 133              	.LVL2:
 263:../drivers/fsl_clock.c **** 
 264:../drivers/fsl_clock.c ****     if (!freq)
 134              		.loc 1 264 0
 135 0006 C0B1     		cbz	r0, .L13
 265:../drivers/fsl_clock.c ****     {
 266:../drivers/fsl_clock.c ****         return freq;
 267:../drivers/fsl_clock.c ****     }
 268:../drivers/fsl_clock.c **** 
 269:../drivers/fsl_clock.c ****     frdiv = MCG_C1_FRDIV_VAL;
 136              		.loc 1 269 0
 137 0008 0D4A     		ldr	r2, .L30
 138 000a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 270:../drivers/fsl_clock.c ****     freq >>= frdiv;
 271:../drivers/fsl_clock.c **** 
 272:../drivers/fsl_clock.c ****     range = MCG_C2_RANGE_VAL;
 139              		.loc 1 272 0
 140 000c 5178     		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 273:../drivers/fsl_clock.c ****     oscsel = MCG_C7_OSCSEL_VAL;
 141              		.loc 1 273 0
 142 000e 127B     		ldrb	r2, [r2, #12]	@ zero_extendqisi2
 269:../drivers/fsl_clock.c ****     freq >>= frdiv;
 143              		.loc 1 269 0
 144 0010 C3F3C203 		ubfx	r3, r3, #3, #3
 145              	.LVL3:
 274:../drivers/fsl_clock.c **** 
 275:../drivers/fsl_clock.c ****     /*
 276:../drivers/fsl_clock.c ****        When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
 277:../drivers/fsl_clock.c ****        1. MCG_C7[OSCSEL] selects IRC48M.
 278:../drivers/fsl_clock.c ****        2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
 279:../drivers/fsl_clock.c ****     */
 280:../drivers/fsl_clock.c ****     if (((0U != range) && (kMCG_OscselOsc == oscsel)) || (kMCG_OscselIrc == oscsel))
 146              		.loc 1 280 0
 147 0014 11F0300F 		tst	r1, #48
 270:../drivers/fsl_clock.c **** 
 148              		.loc 1 270 0
 149 0018 20FA03F0 		lsr	r0, r0, r3
 150              	.LVL4:
 273:../drivers/fsl_clock.c **** 
 151              		.loc 1 273 0
 152 001c 02F00302 		and	r2, r2, #3
 153              	.LVL5:
 154              		.loc 1 280 0
 155 0020 00D0     		beq	.L15
 156              		.loc 1 280 0 is_stmt 0 discriminator 1
 157 0022 0AB1     		cbz	r2, .L16
 158              	.L15:
 159              		.loc 1 280 0 discriminator 3
 160 0024 022A     		cmp	r2, #2
 161 0026 08D1     		bne	.L13
 162              	.L16:
 281:../drivers/fsl_clock.c ****     {
 282:../drivers/fsl_clock.c ****         switch (frdiv)
 163              		.loc 1 282 0 is_stmt 1
 164 0028 062B     		cmp	r3, #6
 165 002a 03D0     		beq	.L18
 166 002c 072B     		cmp	r3, #7
 167 002e 05D0     		beq	.L19
 283:../drivers/fsl_clock.c ****         {
 284:../drivers/fsl_clock.c ****             case 0:
 285:../drivers/fsl_clock.c ****             case 1:
 286:../drivers/fsl_clock.c ****             case 2:
 287:../drivers/fsl_clock.c ****             case 3:
 288:../drivers/fsl_clock.c ****             case 4:
 289:../drivers/fsl_clock.c ****             case 5:
 290:../drivers/fsl_clock.c ****                 freq >>= 5u;
 168              		.loc 1 290 0
 169 0030 4009     		lsrs	r0, r0, #5
 170              	.LVL6:
 291:../drivers/fsl_clock.c ****                 break;
 171              		.loc 1 291 0
 172 0032 08BD     		pop	{r3, pc}
 173              	.LVL7:
 174              	.L18:
 292:../drivers/fsl_clock.c ****             case 6:
 293:../drivers/fsl_clock.c ****                 /* 64*20=1280 */
 294:../drivers/fsl_clock.c ****                 freq /= 20u;
 175              		.loc 1 294 0
 176 0034 1423     		movs	r3, #20
 177              	.LVL8:
 178              	.L29:
 295:../drivers/fsl_clock.c ****                 break;
 296:../drivers/fsl_clock.c ****             case 7:
 297:../drivers/fsl_clock.c ****                 /* 128*12=1536 */
 298:../drivers/fsl_clock.c ****                 freq /= 12u;
 179              		.loc 1 298 0
 180 0036 B0FBF3F0 		udiv	r0, r0, r3
 181              	.LVL9:
 182              	.L13:
 299:../drivers/fsl_clock.c ****                 break;
 300:../drivers/fsl_clock.c ****             default:
 301:../drivers/fsl_clock.c ****                 freq = 0u;
 302:../drivers/fsl_clock.c ****                 break;
 303:../drivers/fsl_clock.c ****         }
 304:../drivers/fsl_clock.c ****     }
 305:../drivers/fsl_clock.c **** 
 306:../drivers/fsl_clock.c ****     return freq;
 307:../drivers/fsl_clock.c **** }
 183              		.loc 1 307 0
 184 003a 08BD     		pop	{r3, pc}
 185              	.LVL10:
 186              	.L19:
 298:../drivers/fsl_clock.c ****                 break;
 187              		.loc 1 298 0
 188 003c 0C23     		movs	r3, #12
 189              	.LVL11:
 190 003e FAE7     		b	.L29
 191              	.L31:
 192              		.align	2
 193              	.L30:
 194 0040 00400640 		.word	1074151424
 195              		.cfi_endproc
 196              	.LFE149:
 198              		.section	.text.CLOCK_GetInternalRefClkSelectFreq,"ax",%progbits
 199              		.align	1
 200              		.syntax unified
 201              		.thumb
 202              		.thumb_func
 203              		.fpu fpv4-sp-d16
 205              	CLOCK_GetInternalRefClkSelectFreq:
 206              	.LFB150:
 308:../drivers/fsl_clock.c **** 
 309:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
 310:../drivers/fsl_clock.c **** {
 207              		.loc 1 310 0
 208              		.cfi_startproc
 209              		@ args = 0, pretend = 0, frame = 0
 210              		@ frame_needed = 0, uses_anonymous_args = 0
 211              		@ link register save eliminated.
 311:../drivers/fsl_clock.c ****     if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
 212              		.loc 1 311 0
 213 0000 064B     		ldr	r3, .L35
 214 0002 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 215 0004 D207     		lsls	r2, r2, #31
 312:../drivers/fsl_clock.c ****     {
 313:../drivers/fsl_clock.c ****         /* Slow internal reference clock selected*/
 314:../drivers/fsl_clock.c ****         return s_slowIrcFreq;
 216              		.loc 1 314 0
 217 0006 55BF     		itete	pl
 218 0008 054B     		ldrpl	r3, .L35+4
 219              	.LBB10:
 220              	.LBB11:
 315:../drivers/fsl_clock.c ****     }
 316:../drivers/fsl_clock.c ****     else
 317:../drivers/fsl_clock.c ****     {
 318:../drivers/fsl_clock.c ****         /* Fast internal reference clock selected*/
 319:../drivers/fsl_clock.c ****         return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
 221              		.loc 1 319 0
 222 000a 064A     		ldrmi	r2, .L35+8
 223              	.LBE11:
 224              	.LBE10:
 314:../drivers/fsl_clock.c ****     }
 225              		.loc 1 314 0
 226 000c 1868     		ldrpl	r0, [r3]
 227              	.LBB13:
 228              	.LBB12:
 229              		.loc 1 319 0
 230 000e 187A     		ldrbmi	r0, [r3, #8]	@ zero_extendqisi2
 231 0010 42BF     		ittt	mi
 232 0012 C0F34203 		ubfxmi	r3, r0, #1, #3
 233 0016 1068     		ldrmi	r0, [r2]
 234 0018 D840     		lsrmi	r0, r0, r3
 235              	.LBE12:
 236              	.LBE13:
 320:../drivers/fsl_clock.c ****     }
 321:../drivers/fsl_clock.c **** }
 237              		.loc 1 321 0
 238 001a 7047     		bx	lr
 239              	.L36:
 240              		.align	2
 241              	.L35:
 242 001c 00400640 		.word	1074151424
 243 0020 00000000 		.word	.LANCHOR0
 244 0024 00000000 		.word	.LANCHOR1
 245              		.cfi_endproc
 246              	.LFE150:
 248              		.section	.text.CLOCK_GetOsc0ErClkFreq,"ax",%progbits
 249              		.align	1
 250              		.global	CLOCK_GetOsc0ErClkFreq
 251              		.syntax unified
 252              		.thumb
 253              		.thumb_func
 254              		.fpu fpv4-sp-d16
 256              	CLOCK_GetOsc0ErClkFreq:
 257              	.LFB154:
 322:../drivers/fsl_clock.c **** 
 323:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllRefClkFreq(void)
 324:../drivers/fsl_clock.c **** {
 325:../drivers/fsl_clock.c ****     /* If use external reference clock. */
 326:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 327:../drivers/fsl_clock.c ****     {
 328:../drivers/fsl_clock.c ****         return CLOCK_GetFllExtRefClkFreq();
 329:../drivers/fsl_clock.c ****     }
 330:../drivers/fsl_clock.c ****     /* If use internal reference clock. */
 331:../drivers/fsl_clock.c ****     else
 332:../drivers/fsl_clock.c ****     {
 333:../drivers/fsl_clock.c ****         return s_slowIrcFreq;
 334:../drivers/fsl_clock.c ****     }
 335:../drivers/fsl_clock.c **** }
 336:../drivers/fsl_clock.c **** 
 337:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetPll0RefFreq(void)
 338:../drivers/fsl_clock.c **** {
 339:../drivers/fsl_clock.c ****     /* MCG external reference clock. */
 340:../drivers/fsl_clock.c ****     return CLOCK_GetMcgExtClkFreq();
 341:../drivers/fsl_clock.c **** }
 342:../drivers/fsl_clock.c **** 
 343:../drivers/fsl_clock.c **** static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
 344:../drivers/fsl_clock.c **** {
 345:../drivers/fsl_clock.c ****     uint8_t range;
 346:../drivers/fsl_clock.c **** 
 347:../drivers/fsl_clock.c ****     if (freq <= 39063U)
 348:../drivers/fsl_clock.c ****     {
 349:../drivers/fsl_clock.c ****         range = 0U;
 350:../drivers/fsl_clock.c ****     }
 351:../drivers/fsl_clock.c ****     else if (freq <= 8000000U)
 352:../drivers/fsl_clock.c ****     {
 353:../drivers/fsl_clock.c ****         range = 1U;
 354:../drivers/fsl_clock.c ****     }
 355:../drivers/fsl_clock.c ****     else
 356:../drivers/fsl_clock.c ****     {
 357:../drivers/fsl_clock.c ****         range = 2U;
 358:../drivers/fsl_clock.c ****     }
 359:../drivers/fsl_clock.c **** 
 360:../drivers/fsl_clock.c ****     return range;
 361:../drivers/fsl_clock.c **** }
 362:../drivers/fsl_clock.c **** 
 363:../drivers/fsl_clock.c **** uint32_t CLOCK_GetOsc0ErClkFreq(void)
 364:../drivers/fsl_clock.c **** {
 258              		.loc 1 364 0
 259              		.cfi_startproc
 260              		@ args = 0, pretend = 0, frame = 0
 261              		@ frame_needed = 0, uses_anonymous_args = 0
 262              		@ link register save eliminated.
 365:../drivers/fsl_clock.c ****     if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
 263              		.loc 1 365 0
 264 0000 034B     		ldr	r3, .L40
 265 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 266 0004 1B06     		lsls	r3, r3, #24
 366:../drivers/fsl_clock.c ****     {
 367:../drivers/fsl_clock.c ****         /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
 368:../drivers/fsl_clock.c ****         assert(g_xtal0Freq);
 369:../drivers/fsl_clock.c ****         return g_xtal0Freq;
 267              		.loc 1 369 0
 268 0006 46BF     		itte	mi
 269 0008 024B     		ldrmi	r3, .L40+4
 270 000a 1868     		ldrmi	r0, [r3]
 370:../drivers/fsl_clock.c ****     }
 371:../drivers/fsl_clock.c ****     else
 372:../drivers/fsl_clock.c ****     {
 373:../drivers/fsl_clock.c ****         return 0U;
 271              		.loc 1 373 0
 272 000c 0020     		movpl	r0, #0
 374:../drivers/fsl_clock.c ****     }
 375:../drivers/fsl_clock.c **** }
 273              		.loc 1 375 0
 274 000e 7047     		bx	lr
 275              	.L41:
 276              		.align	2
 277              	.L40:
 278 0010 00500640 		.word	1074155520
 279 0014 00000000 		.word	g_xtal0Freq
 280              		.cfi_endproc
 281              	.LFE154:
 283              		.section	.text.CLOCK_GetEr32kClkFreq,"ax",%progbits
 284              		.align	1
 285              		.global	CLOCK_GetEr32kClkFreq
 286              		.syntax unified
 287              		.thumb
 288              		.thumb_func
 289              		.fpu fpv4-sp-d16
 291              	CLOCK_GetEr32kClkFreq:
 292              	.LFB155:
 376:../drivers/fsl_clock.c **** 
 377:../drivers/fsl_clock.c **** uint32_t CLOCK_GetEr32kClkFreq(void)
 378:../drivers/fsl_clock.c **** {
 293              		.loc 1 378 0
 294              		.cfi_startproc
 295              		@ args = 0, pretend = 0, frame = 0
 296              		@ frame_needed = 0, uses_anonymous_args = 0
 297 0000 08B5     		push	{r3, lr}
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 3, -8
 300              		.cfi_offset 14, -4
 379:../drivers/fsl_clock.c ****     uint32_t freq;
 380:../drivers/fsl_clock.c **** 
 381:../drivers/fsl_clock.c ****     switch (SIM_SOPT1_OSC32KSEL_VAL)
 301              		.loc 1 381 0
 302 0002 0C4B     		ldr	r3, .L50
 303 0004 1B68     		ldr	r3, [r3]
 304 0006 C3F38143 		ubfx	r3, r3, #18, #2
 305 000a 022B     		cmp	r3, #2
 306 000c 0BD0     		beq	.L44
 307 000e 032B     		cmp	r3, #3
 308 0010 0CD0     		beq	.L47
 309 0012 0BB1     		cbz	r3, .L46
 382:../drivers/fsl_clock.c ****     {
 383:../drivers/fsl_clock.c ****         case 0U: /* OSC 32k clock  */
 384:../drivers/fsl_clock.c ****             freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
 385:../drivers/fsl_clock.c ****             break;
 386:../drivers/fsl_clock.c ****         case 2U: /* RTC 32k clock  */
 387:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN
 388:../drivers/fsl_clock.c ****             assert(g_xtal32Freq);
 389:../drivers/fsl_clock.c ****             freq = g_xtal32Freq;
 390:../drivers/fsl_clock.c ****             break;
 391:../drivers/fsl_clock.c ****         case 3U: /* LPO clock      */
 392:../drivers/fsl_clock.c ****             freq = LPO_CLK_FREQ;
 393:../drivers/fsl_clock.c ****             break;
 394:../drivers/fsl_clock.c ****         default:
 395:../drivers/fsl_clock.c ****             freq = 0U;
 310              		.loc 1 395 0
 311 0014 0020     		movs	r0, #0
 312 0016 08BD     		pop	{r3, pc}
 313              	.L46:
 314              	.LBB16:
 315              	.LBB17:
 384:../drivers/fsl_clock.c ****             break;
 316              		.loc 1 384 0
 317 0018 FFF7FEFF 		bl	CLOCK_GetOsc0ErClkFreq
 318              	.LVL12:
 319 001c B0F5004F 		cmp	r0, #32768
 320 0020 18BF     		it	ne
 321 0022 0020     		movne	r0, #0
 322 0024 08BD     		pop	{r3, pc}
 323              	.L44:
 324              	.LBE17:
 325              	.LBE16:
 389:../drivers/fsl_clock.c ****             break;
 326              		.loc 1 389 0
 327 0026 044B     		ldr	r3, .L50+4
 328 0028 1868     		ldr	r0, [r3]
 329              	.LVL13:
 390:../drivers/fsl_clock.c ****         case 3U: /* LPO clock      */
 330              		.loc 1 390 0
 331 002a 08BD     		pop	{r3, pc}
 332              	.LVL14:
 333              	.L47:
 392:../drivers/fsl_clock.c ****             break;
 334              		.loc 1 392 0
 335 002c 4FF47A70 		mov	r0, #1000
 336              	.LVL15:
 396:../drivers/fsl_clock.c ****             break;
 397:../drivers/fsl_clock.c ****     }
 398:../drivers/fsl_clock.c ****     return freq;
 399:../drivers/fsl_clock.c **** }
 337              		.loc 1 399 0
 338 0030 08BD     		pop	{r3, pc}
 339              	.L51:
 340 0032 00BF     		.align	2
 341              	.L50:
 342 0034 00700440 		.word	1074032640
 343 0038 00000000 		.word	g_xtal32Freq
 344              		.cfi_endproc
 345              	.LFE155:
 347              		.section	.text.CLOCK_SetSimConfig,"ax",%progbits
 348              		.align	1
 349              		.global	CLOCK_SetSimConfig
 350              		.syntax unified
 351              		.thumb
 352              		.thumb_func
 353              		.fpu fpv4-sp-d16
 355              	CLOCK_SetSimConfig:
 356              	.LFB163:
 400:../drivers/fsl_clock.c **** 
 401:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPllFllSelClkFreq(void)
 402:../drivers/fsl_clock.c **** {
 403:../drivers/fsl_clock.c ****     uint32_t freq;
 404:../drivers/fsl_clock.c **** 
 405:../drivers/fsl_clock.c ****     switch (SIM_SOPT2_PLLFLLSEL_VAL)
 406:../drivers/fsl_clock.c ****     {
 407:../drivers/fsl_clock.c ****         case 0U: /* FLL. */
 408:../drivers/fsl_clock.c ****             freq = CLOCK_GetFllFreq();
 409:../drivers/fsl_clock.c ****             break;
 410:../drivers/fsl_clock.c ****         case 1U: /* PLL. */
 411:../drivers/fsl_clock.c ****             freq = CLOCK_GetPll0Freq();
 412:../drivers/fsl_clock.c ****             break;
 413:../drivers/fsl_clock.c ****         case 3U: /* MCG IRC48M. */
 414:../drivers/fsl_clock.c ****             freq = MCG_INTERNAL_IRC_48M;
 415:../drivers/fsl_clock.c ****             break;
 416:../drivers/fsl_clock.c ****         default:
 417:../drivers/fsl_clock.c ****             freq = 0U;
 418:../drivers/fsl_clock.c ****             break;
 419:../drivers/fsl_clock.c ****     }
 420:../drivers/fsl_clock.c **** 
 421:../drivers/fsl_clock.c ****     return freq;
 422:../drivers/fsl_clock.c **** }
 423:../drivers/fsl_clock.c **** 
 424:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPlatClkFreq(void)
 425:../drivers/fsl_clock.c **** {
 426:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 427:../drivers/fsl_clock.c **** }
 428:../drivers/fsl_clock.c **** 
 429:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFlashClkFreq(void)
 430:../drivers/fsl_clock.c **** {
 431:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 432:../drivers/fsl_clock.c **** }
 433:../drivers/fsl_clock.c **** 
 434:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFlexBusClkFreq(void)
 435:../drivers/fsl_clock.c **** {
 436:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
 437:../drivers/fsl_clock.c **** }
 438:../drivers/fsl_clock.c **** 
 439:../drivers/fsl_clock.c **** uint32_t CLOCK_GetBusClkFreq(void)
 440:../drivers/fsl_clock.c **** {
 441:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
 442:../drivers/fsl_clock.c **** }
 443:../drivers/fsl_clock.c **** 
 444:../drivers/fsl_clock.c **** uint32_t CLOCK_GetCoreSysClkFreq(void)
 445:../drivers/fsl_clock.c **** {
 446:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 447:../drivers/fsl_clock.c **** }
 448:../drivers/fsl_clock.c **** 
 449:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFreq(clock_name_t clockName)
 450:../drivers/fsl_clock.c **** {
 451:../drivers/fsl_clock.c ****     uint32_t freq;
 452:../drivers/fsl_clock.c **** 
 453:../drivers/fsl_clock.c ****     switch (clockName)
 454:../drivers/fsl_clock.c ****     {
 455:../drivers/fsl_clock.c ****         case kCLOCK_CoreSysClk:
 456:../drivers/fsl_clock.c ****         case kCLOCK_PlatClk:
 457:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 458:../drivers/fsl_clock.c ****             break;
 459:../drivers/fsl_clock.c ****         case kCLOCK_BusClk:
 460:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
 461:../drivers/fsl_clock.c ****             break;
 462:../drivers/fsl_clock.c ****         case kCLOCK_FlexBusClk:
 463:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
 464:../drivers/fsl_clock.c ****             break;
 465:../drivers/fsl_clock.c ****         case kCLOCK_FlashClk:
 466:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 467:../drivers/fsl_clock.c ****             break;
 468:../drivers/fsl_clock.c ****         case kCLOCK_PllFllSelClk:
 469:../drivers/fsl_clock.c ****             freq = CLOCK_GetPllFllSelClkFreq();
 470:../drivers/fsl_clock.c ****             break;
 471:../drivers/fsl_clock.c ****         case kCLOCK_Er32kClk:
 472:../drivers/fsl_clock.c ****             freq = CLOCK_GetEr32kClkFreq();
 473:../drivers/fsl_clock.c ****             break;
 474:../drivers/fsl_clock.c ****         case kCLOCK_Osc0ErClk:
 475:../drivers/fsl_clock.c ****             freq = CLOCK_GetOsc0ErClkFreq();
 476:../drivers/fsl_clock.c ****             break;
 477:../drivers/fsl_clock.c ****         case kCLOCK_McgFixedFreqClk:
 478:../drivers/fsl_clock.c ****             freq = CLOCK_GetFixedFreqClkFreq();
 479:../drivers/fsl_clock.c ****             break;
 480:../drivers/fsl_clock.c ****         case kCLOCK_McgInternalRefClk:
 481:../drivers/fsl_clock.c ****             freq = CLOCK_GetInternalRefClkFreq();
 482:../drivers/fsl_clock.c ****             break;
 483:../drivers/fsl_clock.c ****         case kCLOCK_McgFllClk:
 484:../drivers/fsl_clock.c ****             freq = CLOCK_GetFllFreq();
 485:../drivers/fsl_clock.c ****             break;
 486:../drivers/fsl_clock.c ****         case kCLOCK_McgPll0Clk:
 487:../drivers/fsl_clock.c ****             freq = CLOCK_GetPll0Freq();
 488:../drivers/fsl_clock.c ****             break;
 489:../drivers/fsl_clock.c ****         case kCLOCK_McgIrc48MClk:
 490:../drivers/fsl_clock.c ****             freq = MCG_INTERNAL_IRC_48M;
 491:../drivers/fsl_clock.c ****             break;
 492:../drivers/fsl_clock.c ****         case kCLOCK_LpoClk:
 493:../drivers/fsl_clock.c ****             freq = LPO_CLK_FREQ;
 494:../drivers/fsl_clock.c ****             break;
 495:../drivers/fsl_clock.c ****         default:
 496:../drivers/fsl_clock.c ****             freq = 0U;
 497:../drivers/fsl_clock.c ****             break;
 498:../drivers/fsl_clock.c ****     }
 499:../drivers/fsl_clock.c **** 
 500:../drivers/fsl_clock.c ****     return freq;
 501:../drivers/fsl_clock.c **** }
 502:../drivers/fsl_clock.c **** 
 503:../drivers/fsl_clock.c **** void CLOCK_SetSimConfig(sim_clock_config_t const *config)
 504:../drivers/fsl_clock.c **** {
 357              		.loc 1 504 0
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 0
 360              		@ frame_needed = 0, uses_anonymous_args = 0
 361              	.LVL16:
 505:../drivers/fsl_clock.c ****     SIM->CLKDIV1 = config->clkdiv1;
 362              		.loc 1 505 0
 363 0000 0D4A     		ldr	r2, .L53
 364 0002 4168     		ldr	r1, [r0, #4]
 365 0004 41F24403 		movw	r3, #4164
 504:../drivers/fsl_clock.c ****     SIM->CLKDIV1 = config->clkdiv1;
 366              		.loc 1 504 0
 367 0008 10B5     		push	{r4, lr}
 368              		.cfi_def_cfa_offset 8
 369              		.cfi_offset 4, -8
 370              		.cfi_offset 14, -4
 371              		.loc 1 505 0
 372 000a D150     		str	r1, [r2, r3]
 373              	.LVL17:
 374              	.LBB22:
 375              	.LBB23:
 376              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 707:../drivers/fsl_clock.h **** }
 708:../drivers/fsl_clock.h **** 
 709:../drivers/fsl_clock.h **** /*!
 710:../drivers/fsl_clock.h ****  * @brief Set ERCLK32K source.
 711:../drivers/fsl_clock.h ****  *
 712:../drivers/fsl_clock.h ****  * @param src The value to set ERCLK32K clock source.
 713:../drivers/fsl_clock.h ****  */
 714:../drivers/fsl_clock.h **** static inline void CLOCK_SetEr32kClock(uint32_t src)
 715:../drivers/fsl_clock.h **** {
 716:../drivers/fsl_clock.h ****     SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
 717:../drivers/fsl_clock.h **** }
 718:../drivers/fsl_clock.h **** 
 719:../drivers/fsl_clock.h **** /*!
 720:../drivers/fsl_clock.h ****  * @brief Set SDHC0 clock source.
 721:../drivers/fsl_clock.h ****  *
 722:../drivers/fsl_clock.h ****  * @param src The value to set SDHC0 clock source.
 723:../drivers/fsl_clock.h ****  */
 724:../drivers/fsl_clock.h **** static inline void CLOCK_SetSdhc0Clock(uint32_t src)
 725:../drivers/fsl_clock.h **** {
 726:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_SDHCSRC_MASK) | SIM_SOPT2_SDHCSRC(src));
 727:../drivers/fsl_clock.h **** }
 728:../drivers/fsl_clock.h **** 
 729:../drivers/fsl_clock.h **** /*!
 730:../drivers/fsl_clock.h ****  * @brief Set enet timestamp clock source.
 731:../drivers/fsl_clock.h ****  *
 732:../drivers/fsl_clock.h ****  * @param src The value to set enet timestamp clock source.
 733:../drivers/fsl_clock.h ****  */
 734:../drivers/fsl_clock.h **** static inline void CLOCK_SetEnetTime0Clock(uint32_t src)
 735:../drivers/fsl_clock.h **** {
 736:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_TIMESRC_MASK) | SIM_SOPT2_TIMESRC(src));
 737:../drivers/fsl_clock.h **** }
 738:../drivers/fsl_clock.h **** 
 739:../drivers/fsl_clock.h **** /*!
 740:../drivers/fsl_clock.h ****  * @brief Set RMII clock source.
 741:../drivers/fsl_clock.h ****  *
 742:../drivers/fsl_clock.h ****  * @param src The value to set RMII clock source.
 743:../drivers/fsl_clock.h ****  */
 744:../drivers/fsl_clock.h **** static inline void CLOCK_SetRmii0Clock(uint32_t src)
 745:../drivers/fsl_clock.h **** {
 746:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_RMIISRC_MASK) | SIM_SOPT2_RMIISRC(src));
 747:../drivers/fsl_clock.h **** }
 748:../drivers/fsl_clock.h **** 
 749:../drivers/fsl_clock.h **** /*!
 750:../drivers/fsl_clock.h ****  * @brief Set debug trace clock source.
 751:../drivers/fsl_clock.h ****  *
 752:../drivers/fsl_clock.h ****  * @param src The value to set debug trace clock source.
 753:../drivers/fsl_clock.h ****  */
 754:../drivers/fsl_clock.h **** static inline void CLOCK_SetTraceClock(uint32_t src)
 755:../drivers/fsl_clock.h **** {
 756:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_TRACECLKSEL_MASK) | SIM_SOPT2_TRACECLKSEL(src));
 757:../drivers/fsl_clock.h **** }
 758:../drivers/fsl_clock.h **** 
 759:../drivers/fsl_clock.h **** /*!
 760:../drivers/fsl_clock.h ****  * @brief Set PLLFLLSEL clock source.
 761:../drivers/fsl_clock.h ****  *
 762:../drivers/fsl_clock.h ****  * @param src The value to set PLLFLLSEL clock source.
 763:../drivers/fsl_clock.h ****  */
 764:../drivers/fsl_clock.h **** static inline void CLOCK_SetPllFllSelClock(uint32_t src)
 765:../drivers/fsl_clock.h **** {
 766:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_PLLFLLSEL_MASK) | SIM_SOPT2_PLLFLLSEL(src));
 377              		.loc 2 766 0
 378 000c 41F20404 		movw	r4, #4100
 379              	.LBE23:
 380              	.LBE22:
 506:../drivers/fsl_clock.c ****     CLOCK_SetPllFllSelClock(config->pllFllSel);
 381              		.loc 1 506 0
 382 0010 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 383              	.LVL18:
 384              	.LBB25:
 385              	.LBB24:
 386              		.loc 2 766 0
 387 0012 1159     		ldr	r1, [r2, r4]
 388 0014 1B04     		lsls	r3, r3, #16
 389              	.LVL19:
 390 0016 21F44031 		bic	r1, r1, #196608
 391 001a 03F44033 		and	r3, r3, #196608
 392 001e 0B43     		orrs	r3, r3, r1
 393 0020 1351     		str	r3, [r2, r4]
 394              	.LVL20:
 395              	.LBE24:
 396              	.LBE25:
 507:../drivers/fsl_clock.c ****     CLOCK_SetEr32kClock(config->er32kSrc);
 397              		.loc 1 507 0
 398 0022 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 399              	.LVL21:
 400              	.LBB26:
 401              	.LBB27:
 716:../drivers/fsl_clock.h **** }
 402              		.loc 2 716 0
 403 0024 1168     		ldr	r1, [r2]
 404 0026 9B04     		lsls	r3, r3, #18
 405              	.LVL22:
 406 0028 03F44023 		and	r3, r3, #786432
 407 002c 21F44021 		bic	r1, r1, #786432
 408 0030 0B43     		orrs	r3, r3, r1
 409 0032 1360     		str	r3, [r2]
 410              	.LVL23:
 411 0034 10BD     		pop	{r4, pc}
 412              	.L54:
 413 0036 00BF     		.align	2
 414              	.L53:
 415 0038 00700440 		.word	1074032640
 416              	.LBE27:
 417              	.LBE26:
 418              		.cfi_endproc
 419              	.LFE163:
 421              		.section	.text.CLOCK_EnableUsbfs0Clock,"ax",%progbits
 422              		.align	1
 423              		.global	CLOCK_EnableUsbfs0Clock
 424              		.syntax unified
 425              		.thumb
 426              		.thumb_func
 427              		.fpu fpv4-sp-d16
 429              	CLOCK_EnableUsbfs0Clock:
 430              	.LFB164:
 508:../drivers/fsl_clock.c **** }
 509:../drivers/fsl_clock.c **** 
 510:../drivers/fsl_clock.c **** bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq)
 511:../drivers/fsl_clock.c **** {
 431              		.loc 1 511 0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 435              	.LVL24:
 436 0000 30B5     		push	{r4, r5, lr}
 437              		.cfi_def_cfa_offset 12
 438              		.cfi_offset 4, -12
 439              		.cfi_offset 5, -8
 440              		.cfi_offset 14, -4
 441              	.LBB32:
 442              	.LBB33:
 706:../drivers/fsl_clock.h **** }
 443              		.loc 2 706 0
 444 0002 234C     		ldr	r4, .L67
 445 0004 234B     		ldr	r3, .L67+4
 446 0006 2268     		ldr	r2, [r4]
 447 0008 22F48022 		bic	r2, r2, #262144
 448 000c 2260     		str	r2, [r4]
 449              	.LVL25:
 450              	.LBE33:
 451              	.LBE32:
 512:../drivers/fsl_clock.c ****     bool ret = true;
 513:../drivers/fsl_clock.c **** 
 514:../drivers/fsl_clock.c ****     CLOCK_DisableClock(kCLOCK_Usbfs0);
 515:../drivers/fsl_clock.c **** 
 516:../drivers/fsl_clock.c ****     if (kCLOCK_UsbSrcExt == src)
 452              		.loc 1 516 0
 453 000e C8B9     		cbnz	r0, .L56
 517:../drivers/fsl_clock.c ****     {
 518:../drivers/fsl_clock.c ****         SIM->SOPT2 &= ~SIM_SOPT2_USBSRC_MASK;
 454              		.loc 1 518 0
 455 0010 41F20401 		movw	r1, #4100
 456              	.LVL26:
 457 0014 5A58     		ldr	r2, [r3, r1]
 458 0016 22F48022 		bic	r2, r2, #262144
 459 001a 5A50     		str	r2, [r3, r1]
 512:../drivers/fsl_clock.c ****     bool ret = true;
 460              		.loc 1 512 0
 461 001c 0123     		movs	r3, #1
 462              	.LVL27:
 463              	.L57:
 464              	.LBB34:
 465              	.LBB35:
 695:../drivers/fsl_clock.h **** }
 466              		.loc 2 695 0
 467 001e 2268     		ldr	r2, [r4]
 468              	.LBE35:
 469              	.LBE34:
 519:../drivers/fsl_clock.c ****     }
 520:../drivers/fsl_clock.c ****     else
 521:../drivers/fsl_clock.c ****     {
 522:../drivers/fsl_clock.c ****         switch (freq)
 523:../drivers/fsl_clock.c ****         {
 524:../drivers/fsl_clock.c ****             case 120000000U:
 525:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC(1);
 526:../drivers/fsl_clock.c ****                 break;
 527:../drivers/fsl_clock.c ****             case 96000000U:
 528:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(1) | SIM_CLKDIV2_USBFRAC(0);
 529:../drivers/fsl_clock.c ****                 break;
 530:../drivers/fsl_clock.c ****             case 72000000U:
 531:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(2) | SIM_CLKDIV2_USBFRAC(1);
 532:../drivers/fsl_clock.c ****                 break;
 533:../drivers/fsl_clock.c ****             case 48000000U:
 534:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(0) | SIM_CLKDIV2_USBFRAC(0);
 535:../drivers/fsl_clock.c ****                 break;
 536:../drivers/fsl_clock.c ****             default:
 537:../drivers/fsl_clock.c ****                 ret = false;
 538:../drivers/fsl_clock.c ****                 break;
 539:../drivers/fsl_clock.c ****         }
 540:../drivers/fsl_clock.c **** 
 541:../drivers/fsl_clock.c ****         SIM->SOPT2 = ((SIM->SOPT2 & ~(SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_USBSRC_MASK)) | (uint32_
 542:../drivers/fsl_clock.c ****     }
 543:../drivers/fsl_clock.c **** 
 544:../drivers/fsl_clock.c ****     CLOCK_EnableClock(kCLOCK_Usbfs0);
 545:../drivers/fsl_clock.c **** 
 546:../drivers/fsl_clock.c ****     if (kCLOCK_UsbSrcIrc48M == src)
 470              		.loc 1 546 0
 471 0020 B0F5E02F 		cmp	r0, #458752
 472              	.LBB37:
 473              	.LBB36:
 695:../drivers/fsl_clock.h **** }
 474              		.loc 2 695 0
 475 0024 42F48022 		orr	r2, r2, #262144
 476 0028 2260     		str	r2, [r4]
 477              	.LVL28:
 478              	.LBE36:
 479              	.LBE37:
 480              		.loc 1 546 0
 481 002a 09D1     		bne	.L64
 547:../drivers/fsl_clock.c ****     {
 548:../drivers/fsl_clock.c ****         USB0->CLK_RECOVER_IRC_EN = 0x03U;
 482              		.loc 1 548 0
 483 002c 1A4A     		ldr	r2, .L67+8
 484 002e 0321     		movs	r1, #3
 485 0030 82F84411 		strb	r1, [r2, #324]
 549:../drivers/fsl_clock.c ****         USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
 486              		.loc 1 549 0
 487 0034 92F84011 		ldrb	r1, [r2, #320]	@ zero_extendqisi2
 488 0038 41F08001 		orr	r1, r1, #128
 489 003c 82F84011 		strb	r1, [r2, #320]
 490              	.L64:
 550:../drivers/fsl_clock.c ****     }
 551:../drivers/fsl_clock.c ****     return ret;
 552:../drivers/fsl_clock.c **** }
 491              		.loc 1 552 0
 492 0040 1846     		mov	r0, r3
 493              	.LVL29:
 494 0042 30BD     		pop	{r4, r5, pc}
 495              	.LVL30:
 496              	.L56:
 522:../drivers/fsl_clock.c ****         {
 497              		.loc 1 522 0
 498 0044 154A     		ldr	r2, .L67+12
 499 0046 9142     		cmp	r1, r2
 500 0048 1ED0     		beq	.L59
 501 004a 04D8     		bhi	.L60
 502 004c 144A     		ldr	r2, .L67+16
 503 004e 9142     		cmp	r1, r2
 504 0050 1CD0     		beq	.L61
 505              	.L65:
 537:../drivers/fsl_clock.c ****                 break;
 506              		.loc 1 537 0
 507 0052 0023     		movs	r3, #0
 508 0054 0DE0     		b	.L58
 509              	.L60:
 522:../drivers/fsl_clock.c ****         {
 510              		.loc 1 522 0
 511 0056 134A     		ldr	r2, .L67+20
 512 0058 9142     		cmp	r1, r2
 513 005a 13D0     		beq	.L62
 514 005c 02F1B772 		add	r2, r2, #23986176
 515 0060 02F55852 		add	r2, r2, #13824
 516 0064 9142     		cmp	r1, r2
 517 0066 F4D1     		bne	.L65
 525:../drivers/fsl_clock.c ****                 break;
 518              		.loc 1 525 0
 519 0068 0921     		movs	r1, #9
 520              	.LVL31:
 521              	.L66:
 534:../drivers/fsl_clock.c ****                 break;
 522              		.loc 1 534 0
 523 006a 41F24802 		movw	r2, #4168
 524 006e 9950     		str	r1, [r3, r2]
 512:../drivers/fsl_clock.c **** 
 525              		.loc 1 512 0
 526 0070 0123     		movs	r3, #1
 527              	.L58:
 528              	.LVL32:
 541:../drivers/fsl_clock.c ****     }
 529              		.loc 1 541 0
 530 0072 084D     		ldr	r5, .L67+4
 531 0074 41F20401 		movw	r1, #4100
 532 0078 6A58     		ldr	r2, [r5, r1]
 533 007a 22F4E022 		bic	r2, r2, #458752
 534 007e 0243     		orrs	r2, r2, r0
 535 0080 6A50     		str	r2, [r5, r1]
 536 0082 CCE7     		b	.L57
 537              	.LVL33:
 538              	.L62:
 528:../drivers/fsl_clock.c ****                 break;
 539              		.loc 1 528 0
 540 0084 0221     		movs	r1, #2
 541              	.LVL34:
 542 0086 F0E7     		b	.L66
 543              	.LVL35:
 544              	.L59:
 531:../drivers/fsl_clock.c ****                 break;
 545              		.loc 1 531 0
 546 0088 0521     		movs	r1, #5
 547              	.LVL36:
 548 008a EEE7     		b	.L66
 549              	.LVL37:
 550              	.L61:
 534:../drivers/fsl_clock.c ****                 break;
 551              		.loc 1 534 0
 552 008c 0021     		movs	r1, #0
 553              	.LVL38:
 554 008e ECE7     		b	.L66
 555              	.L68:
 556              		.align	2
 557              	.L67:
 558 0090 34800440 		.word	1074036788
 559 0094 00700440 		.word	1074032640
 560 0098 00200740 		.word	1074208768
 561 009c 00A24A04 		.word	72000000
 562 00a0 006CDC02 		.word	48000000
 563 00a4 00D8B805 		.word	96000000
 564              		.cfi_endproc
 565              	.LFE164:
 567              		.section	.text.CLOCK_GetFllFreq,"ax",%progbits
 568              		.align	1
 569              		.global	CLOCK_GetFllFreq
 570              		.syntax unified
 571              		.thumb
 572              		.thumb_func
 573              		.fpu fpv4-sp-d16
 575              	CLOCK_GetFllFreq:
 576              	.LFB166:
 553:../drivers/fsl_clock.c **** 
 554:../drivers/fsl_clock.c **** uint32_t CLOCK_GetOutClkFreq(void)
 555:../drivers/fsl_clock.c **** {
 556:../drivers/fsl_clock.c ****     uint32_t mcgoutclk;
 557:../drivers/fsl_clock.c ****     uint32_t clkst = MCG_S_CLKST_VAL;
 558:../drivers/fsl_clock.c **** 
 559:../drivers/fsl_clock.c ****     switch (clkst)
 560:../drivers/fsl_clock.c ****     {
 561:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
 562:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetPll0Freq();
 563:../drivers/fsl_clock.c ****             break;
 564:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatFll:
 565:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetFllFreq();
 566:../drivers/fsl_clock.c ****             break;
 567:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
 568:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
 569:../drivers/fsl_clock.c ****             break;
 570:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
 571:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetMcgExtClkFreq();
 572:../drivers/fsl_clock.c ****             break;
 573:../drivers/fsl_clock.c ****         default:
 574:../drivers/fsl_clock.c ****             mcgoutclk = 0U;
 575:../drivers/fsl_clock.c ****             break;
 576:../drivers/fsl_clock.c ****     }
 577:../drivers/fsl_clock.c ****     return mcgoutclk;
 578:../drivers/fsl_clock.c **** }
 579:../drivers/fsl_clock.c **** 
 580:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFllFreq(void)
 581:../drivers/fsl_clock.c **** {
 577              		.loc 1 581 0
 578              		.cfi_startproc
 579              		@ args = 0, pretend = 0, frame = 0
 580              		@ frame_needed = 0, uses_anonymous_args = 0
 581 0000 08B5     		push	{r3, lr}
 582              		.cfi_def_cfa_offset 8
 583              		.cfi_offset 3, -8
 584              		.cfi_offset 14, -4
 582:../drivers/fsl_clock.c ****     static const uint16_t fllFactorTable[4][2] = {{640, 732}, {1280, 1464}, {1920, 2197}, {2560, 29
 583:../drivers/fsl_clock.c **** 
 584:../drivers/fsl_clock.c ****     uint8_t drs, dmx32;
 585:../drivers/fsl_clock.c ****     uint32_t freq;
 586:../drivers/fsl_clock.c **** 
 587:../drivers/fsl_clock.c ****     /* If FLL is not enabled currently, then return 0U. */
 588:../drivers/fsl_clock.c ****     if ((MCG->C2 & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
 585              		.loc 1 588 0
 586 0002 104B     		ldr	r3, .L78
 587 0004 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 588 0006 9107     		lsls	r1, r2, #30
 589 0008 01D5     		bpl	.L70
 590              	.L72:
 589:../drivers/fsl_clock.c ****     {
 590:../drivers/fsl_clock.c ****         return 0U;
 591              		.loc 1 590 0
 592 000a 0020     		movs	r0, #0
 593 000c 08BD     		pop	{r3, pc}
 594              	.L70:
 588:../drivers/fsl_clock.c ****     {
 595              		.loc 1 588 0 discriminator 1
 596 000e 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 597 0010 9206     		lsls	r2, r2, #26
 598 0012 FAD4     		bmi	.L72
 599              	.LBB42:
 600              	.LBB43:
 601              	.LBB44:
 602              	.LBB45:
 326:../drivers/fsl_clock.c ****     {
 603              		.loc 1 326 0
 604 0014 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 605 0016 DB06     		lsls	r3, r3, #27
 606 0018 10D4     		bmi	.L73
 328:../drivers/fsl_clock.c ****     }
 607              		.loc 1 328 0
 608 001a FFF7FEFF 		bl	CLOCK_GetFllExtRefClkFreq
 609              	.LVL39:
 610              	.L74:
 611              	.LBE45:
 612              	.LBE44:
 591:../drivers/fsl_clock.c ****     }
 592:../drivers/fsl_clock.c **** 
 593:../drivers/fsl_clock.c ****     /* Get FLL reference clock frequency. */
 594:../drivers/fsl_clock.c ****     freq = CLOCK_GetFllRefClkFreq();
 595:../drivers/fsl_clock.c ****     if (!freq)
 613              		.loc 1 595 0
 614 001e 0028     		cmp	r0, #0
 615 0020 F3D0     		beq	.L72
 596:../drivers/fsl_clock.c ****     {
 597:../drivers/fsl_clock.c ****         return freq;
 598:../drivers/fsl_clock.c ****     }
 599:../drivers/fsl_clock.c **** 
 600:../drivers/fsl_clock.c ****     drs = MCG_C4_DRST_DRS_VAL;
 616              		.loc 1 600 0
 617 0022 084A     		ldr	r2, .L78
 618 0024 D378     		ldrb	r3, [r2, #3]	@ zero_extendqisi2
 619              	.LVL40:
 601:../drivers/fsl_clock.c ****     dmx32 = MCG_C4_DMX32_VAL;
 620              		.loc 1 601 0
 621 0026 D278     		ldrb	r2, [r2, #3]	@ zero_extendqisi2
 622              	.LVL41:
 602:../drivers/fsl_clock.c **** 
 603:../drivers/fsl_clock.c ****     return freq * fllFactorTable[drs][dmx32];
 623              		.loc 1 603 0
 624 0028 C3F34113 		ubfx	r3, r3, #5, #2
 625              	.LVL42:
 626 002c 5B00     		lsls	r3, r3, #1
 627 002e 03EBD213 		add	r3, r3, r2, lsr #7
 628 0032 054A     		ldr	r2, .L78+4
 629              	.LVL43:
 630 0034 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 631 0038 5843     		muls	r0, r3, r0
 632              	.LBE43:
 633              	.LBE42:
 604:../drivers/fsl_clock.c **** }
 634              		.loc 1 604 0
 635 003a 08BD     		pop	{r3, pc}
 636              	.L73:
 637              	.LBB49:
 638              	.LBB48:
 639              	.LBB47:
 640              	.LBB46:
 333:../drivers/fsl_clock.c ****     }
 641              		.loc 1 333 0
 642 003c 034B     		ldr	r3, .L78+8
 643 003e 1868     		ldr	r0, [r3]
 644 0040 EDE7     		b	.L74
 645              	.L79:
 646 0042 00BF     		.align	2
 647              	.L78:
 648 0044 00400640 		.word	1074151424
 649 0048 00000000 		.word	.LANCHOR2
 650 004c 00000000 		.word	.LANCHOR0
 651              	.LBE46:
 652              	.LBE47:
 653              	.LBE48:
 654              	.LBE49:
 655              		.cfi_endproc
 656              	.LFE166:
 658              		.section	.text.CLOCK_GetInternalRefClkFreq,"ax",%progbits
 659              		.align	1
 660              		.global	CLOCK_GetInternalRefClkFreq
 661              		.syntax unified
 662              		.thumb
 663              		.thumb_func
 664              		.fpu fpv4-sp-d16
 666              	CLOCK_GetInternalRefClkFreq:
 667              	.LFB167:
 605:../drivers/fsl_clock.c **** 
 606:../drivers/fsl_clock.c **** uint32_t CLOCK_GetInternalRefClkFreq(void)
 607:../drivers/fsl_clock.c **** {
 668              		.loc 1 607 0
 669              		.cfi_startproc
 670              		@ args = 0, pretend = 0, frame = 0
 671              		@ frame_needed = 0, uses_anonymous_args = 0
 672              		@ link register save eliminated.
 608:../drivers/fsl_clock.c ****     /* If MCGIRCLK is gated. */
 609:../drivers/fsl_clock.c ****     if (!(MCG->C1 & MCG_C1_IRCLKEN_MASK))
 673              		.loc 1 609 0
 674 0000 034B     		ldr	r3, .L82
 675 0002 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 676 0004 10F00200 		ands	r0, r0, #2
 677 0008 01D0     		beq	.L81
 610:../drivers/fsl_clock.c ****     {
 611:../drivers/fsl_clock.c ****         return 0U;
 612:../drivers/fsl_clock.c ****     }
 613:../drivers/fsl_clock.c **** 
 614:../drivers/fsl_clock.c ****     return CLOCK_GetInternalRefClkSelectFreq();
 678              		.loc 1 614 0
 679 000a FFF7FEBF 		b	CLOCK_GetInternalRefClkSelectFreq
 680              	.LVL44:
 681              	.L81:
 615:../drivers/fsl_clock.c **** }
 682              		.loc 1 615 0
 683 000e 7047     		bx	lr
 684              	.L83:
 685              		.align	2
 686              	.L82:
 687 0010 00400640 		.word	1074151424
 688              		.cfi_endproc
 689              	.LFE167:
 691              		.section	.text.CLOCK_GetPll0Freq,"ax",%progbits
 692              		.align	1
 693              		.global	CLOCK_GetPll0Freq
 694              		.syntax unified
 695              		.thumb
 696              		.thumb_func
 697              		.fpu fpv4-sp-d16
 699              	CLOCK_GetPll0Freq:
 700              	.LFB169:
 616:../drivers/fsl_clock.c **** 
 617:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFixedFreqClkFreq(void)
 618:../drivers/fsl_clock.c **** {
 619:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 620:../drivers/fsl_clock.c **** 
 621:../drivers/fsl_clock.c ****     /* MCGFFCLK must be no more than MCGOUTCLK/8. */
 622:../drivers/fsl_clock.c ****     if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
 623:../drivers/fsl_clock.c ****     {
 624:../drivers/fsl_clock.c ****         return freq;
 625:../drivers/fsl_clock.c ****     }
 626:../drivers/fsl_clock.c ****     else
 627:../drivers/fsl_clock.c ****     {
 628:../drivers/fsl_clock.c ****         return 0U;
 629:../drivers/fsl_clock.c ****     }
 630:../drivers/fsl_clock.c **** }
 631:../drivers/fsl_clock.c **** 
 632:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPll0Freq(void)
 633:../drivers/fsl_clock.c **** {
 701              		.loc 1 633 0
 702              		.cfi_startproc
 703              		@ args = 0, pretend = 0, frame = 0
 704              		@ frame_needed = 0, uses_anonymous_args = 0
 705 0000 08B5     		push	{r3, lr}
 706              		.cfi_def_cfa_offset 8
 707              		.cfi_offset 3, -8
 708              		.cfi_offset 14, -4
 634:../drivers/fsl_clock.c ****     uint32_t mcgpll0clk;
 635:../drivers/fsl_clock.c **** 
 636:../drivers/fsl_clock.c ****     /* If PLL0 is not enabled, return 0. */
 637:../drivers/fsl_clock.c ****     if (!(MCG->S & MCG_S_LOCK0_MASK))
 709              		.loc 1 637 0
 710 0002 094A     		ldr	r2, .L87
 711 0004 9079     		ldrb	r0, [r2, #6]	@ zero_extendqisi2
 712 0006 10F04000 		ands	r0, r0, #64
 713 000a 0CD0     		beq	.L84
 714              	.LBB54:
 715              	.LBB55:
 716              	.LBB56:
 717              	.LBB57:
 340:../drivers/fsl_clock.c **** }
 718              		.loc 1 340 0
 719 000c FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 720              	.LVL45:
 721              	.LBE57:
 722              	.LBE56:
 638:../drivers/fsl_clock.c ****     {
 639:../drivers/fsl_clock.c ****         return 0U;
 640:../drivers/fsl_clock.c ****     }
 641:../drivers/fsl_clock.c **** 
 642:../drivers/fsl_clock.c ****     mcgpll0clk = CLOCK_GetPll0RefFreq();
 643:../drivers/fsl_clock.c **** 
 644:../drivers/fsl_clock.c ****     /*
 645:../drivers/fsl_clock.c ****      * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
 646:../drivers/fsl_clock.c ****      * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
 647:../drivers/fsl_clock.c ****      */
 648:../drivers/fsl_clock.c ****     assert(mcgpll0clk);
 649:../drivers/fsl_clock.c **** 
 650:../drivers/fsl_clock.c ****     mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
 723              		.loc 1 650 0
 724 0010 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 725 0012 03F01F03 		and	r3, r3, #31
 726 0016 0133     		adds	r3, r3, #1
 727 0018 B0FBF3F0 		udiv	r0, r0, r3
 728              	.LVL46:
 651:../drivers/fsl_clock.c ****     mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
 729              		.loc 1 651 0
 730 001c 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 731 001e 03F01F03 		and	r3, r3, #31
 732 0022 1833     		adds	r3, r3, #24
 733 0024 5843     		muls	r0, r3, r0
 734              	.LVL47:
 735              	.L84:
 736              	.LBE55:
 737              	.LBE54:
 652:../drivers/fsl_clock.c **** 
 653:../drivers/fsl_clock.c ****     return mcgpll0clk;
 654:../drivers/fsl_clock.c **** }
 738              		.loc 1 654 0
 739 0026 08BD     		pop	{r3, pc}
 740              	.L88:
 741              		.align	2
 742              	.L87:
 743 0028 00400640 		.word	1074151424
 744              		.cfi_endproc
 745              	.LFE169:
 747              		.section	.text.CLOCK_GetPllFllSelClkFreq,"ax",%progbits
 748              		.align	1
 749              		.global	CLOCK_GetPllFllSelClkFreq
 750              		.syntax unified
 751              		.thumb
 752              		.thumb_func
 753              		.fpu fpv4-sp-d16
 755              	CLOCK_GetPllFllSelClkFreq:
 756              	.LFB156:
 402:../drivers/fsl_clock.c ****     uint32_t freq;
 757              		.loc 1 402 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 0
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              		@ link register save eliminated.
 405:../drivers/fsl_clock.c ****     {
 762              		.loc 1 405 0
 763 0000 41F20403 		movw	r3, #4100
 764 0004 074A     		ldr	r2, .L97
 765 0006 D358     		ldr	r3, [r2, r3]
 766 0008 C3F30143 		ubfx	r3, r3, #16, #2
 767 000c 012B     		cmp	r3, #1
 768 000e 02D0     		beq	.L91
 769 0010 03D2     		bcs	.L96
 408:../drivers/fsl_clock.c ****             break;
 770              		.loc 1 408 0
 771 0012 FFF7FEBF 		b	CLOCK_GetFllFreq
 772              	.LVL48:
 773              	.L91:
 411:../drivers/fsl_clock.c ****             break;
 774              		.loc 1 411 0
 775 0016 FFF7FEBF 		b	CLOCK_GetPll0Freq
 776              	.LVL49:
 777              	.L96:
 405:../drivers/fsl_clock.c ****     {
 778              		.loc 1 405 0
 779 001a 032B     		cmp	r3, #3
 417:../drivers/fsl_clock.c ****             break;
 780              		.loc 1 417 0
 781 001c 0248     		ldr	r0, .L97+4
 782 001e 18BF     		it	ne
 783 0020 0020     		movne	r0, #0
 422:../drivers/fsl_clock.c **** 
 784              		.loc 1 422 0
 785 0022 7047     		bx	lr
 786              	.L98:
 787              		.align	2
 788              	.L97:
 789 0024 00700440 		.word	1074032640
 790 0028 006CDC02 		.word	48000000
 791              		.cfi_endproc
 792              	.LFE156:
 794              		.section	.text.CLOCK_GetOutClkFreq,"ax",%progbits
 795              		.align	1
 796              		.global	CLOCK_GetOutClkFreq
 797              		.syntax unified
 798              		.thumb
 799              		.thumb_func
 800              		.fpu fpv4-sp-d16
 802              	CLOCK_GetOutClkFreq:
 803              	.LFB165:
 555:../drivers/fsl_clock.c ****     uint32_t mcgoutclk;
 804              		.loc 1 555 0
 805              		.cfi_startproc
 806              		@ args = 0, pretend = 0, frame = 0
 807              		@ frame_needed = 0, uses_anonymous_args = 0
 808              		@ link register save eliminated.
 557:../drivers/fsl_clock.c **** 
 809              		.loc 1 557 0
 810 0000 084B     		ldr	r3, .L105
 811 0002 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 812              	.LVL50:
 813 0004 C3F38103 		ubfx	r3, r3, #2, #2
 814              	.LVL51:
 559:../drivers/fsl_clock.c ****     {
 815              		.loc 1 559 0
 816 0008 022B     		cmp	r3, #2
 817 000a 09D0     		beq	.L101
 818 000c 032B     		cmp	r3, #3
 819 000e 03D0     		beq	.L102
 820 0010 012B     		cmp	r3, #1
 821 0012 03D1     		bne	.L104
 568:../drivers/fsl_clock.c ****             break;
 822              		.loc 1 568 0
 823 0014 FFF7FEBF 		b	CLOCK_GetInternalRefClkSelectFreq
 824              	.LVL52:
 825              	.L102:
 562:../drivers/fsl_clock.c ****             break;
 826              		.loc 1 562 0
 827 0018 FFF7FEBF 		b	CLOCK_GetPll0Freq
 828              	.LVL53:
 829              	.L104:
 565:../drivers/fsl_clock.c ****             break;
 830              		.loc 1 565 0
 831 001c FFF7FEBF 		b	CLOCK_GetFllFreq
 832              	.LVL54:
 833              	.L101:
 571:../drivers/fsl_clock.c ****             break;
 834              		.loc 1 571 0
 835 0020 FFF7FEBF 		b	CLOCK_GetMcgExtClkFreq
 836              	.LVL55:
 837              	.L106:
 838              		.align	2
 839              	.L105:
 840 0024 00400640 		.word	1074151424
 841              		.cfi_endproc
 842              	.LFE165:
 844              		.section	.text.CLOCK_GetFlashClkFreq,"ax",%progbits
 845              		.align	1
 846              		.global	CLOCK_GetFlashClkFreq
 847              		.syntax unified
 848              		.thumb
 849              		.thumb_func
 850              		.fpu fpv4-sp-d16
 852              	CLOCK_GetFlashClkFreq:
 853              	.LFB158:
 430:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 854              		.loc 1 430 0
 855              		.cfi_startproc
 856              		@ args = 0, pretend = 0, frame = 0
 857              		@ frame_needed = 0, uses_anonymous_args = 0
 858 0000 08B5     		push	{r3, lr}
 859              		.cfi_def_cfa_offset 8
 860              		.cfi_offset 3, -8
 861              		.cfi_offset 14, -4
 431:../drivers/fsl_clock.c **** }
 862              		.loc 1 431 0
 863 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 864              	.LVL56:
 865 0006 054A     		ldr	r2, .L108
 866 0008 41F24403 		movw	r3, #4164
 867 000c D358     		ldr	r3, [r2, r3]
 868 000e C3F30343 		ubfx	r3, r3, #16, #4
 869 0012 0133     		adds	r3, r3, #1
 432:../drivers/fsl_clock.c **** 
 870              		.loc 1 432 0
 871 0014 B0FBF3F0 		udiv	r0, r0, r3
 872 0018 08BD     		pop	{r3, pc}
 873              	.L109:
 874 001a 00BF     		.align	2
 875              	.L108:
 876 001c 00700440 		.word	1074032640
 877              		.cfi_endproc
 878              	.LFE158:
 880              		.section	.text.CLOCK_GetFlexBusClkFreq,"ax",%progbits
 881              		.align	1
 882              		.global	CLOCK_GetFlexBusClkFreq
 883              		.syntax unified
 884              		.thumb
 885              		.thumb_func
 886              		.fpu fpv4-sp-d16
 888              	CLOCK_GetFlexBusClkFreq:
 889              	.LFB159:
 435:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
 890              		.loc 1 435 0
 891              		.cfi_startproc
 892              		@ args = 0, pretend = 0, frame = 0
 893              		@ frame_needed = 0, uses_anonymous_args = 0
 894 0000 08B5     		push	{r3, lr}
 895              		.cfi_def_cfa_offset 8
 896              		.cfi_offset 3, -8
 897              		.cfi_offset 14, -4
 436:../drivers/fsl_clock.c **** }
 898              		.loc 1 436 0
 899 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 900              	.LVL57:
 901 0006 054A     		ldr	r2, .L111
 902 0008 41F24403 		movw	r3, #4164
 903 000c D358     		ldr	r3, [r2, r3]
 904 000e C3F30353 		ubfx	r3, r3, #20, #4
 905 0012 0133     		adds	r3, r3, #1
 437:../drivers/fsl_clock.c **** 
 906              		.loc 1 437 0
 907 0014 B0FBF3F0 		udiv	r0, r0, r3
 908 0018 08BD     		pop	{r3, pc}
 909              	.L112:
 910 001a 00BF     		.align	2
 911              	.L111:
 912 001c 00700440 		.word	1074032640
 913              		.cfi_endproc
 914              	.LFE159:
 916              		.section	.text.CLOCK_GetBusClkFreq,"ax",%progbits
 917              		.align	1
 918              		.global	CLOCK_GetBusClkFreq
 919              		.syntax unified
 920              		.thumb
 921              		.thumb_func
 922              		.fpu fpv4-sp-d16
 924              	CLOCK_GetBusClkFreq:
 925              	.LFB160:
 440:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
 926              		.loc 1 440 0
 927              		.cfi_startproc
 928              		@ args = 0, pretend = 0, frame = 0
 929              		@ frame_needed = 0, uses_anonymous_args = 0
 930 0000 08B5     		push	{r3, lr}
 931              		.cfi_def_cfa_offset 8
 932              		.cfi_offset 3, -8
 933              		.cfi_offset 14, -4
 441:../drivers/fsl_clock.c **** }
 934              		.loc 1 441 0
 935 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 936              	.LVL58:
 937 0006 054A     		ldr	r2, .L114
 938 0008 41F24403 		movw	r3, #4164
 939 000c D358     		ldr	r3, [r2, r3]
 940 000e C3F30363 		ubfx	r3, r3, #24, #4
 941 0012 0133     		adds	r3, r3, #1
 442:../drivers/fsl_clock.c **** 
 942              		.loc 1 442 0
 943 0014 B0FBF3F0 		udiv	r0, r0, r3
 944 0018 08BD     		pop	{r3, pc}
 945              	.L115:
 946 001a 00BF     		.align	2
 947              	.L114:
 948 001c 00700440 		.word	1074032640
 949              		.cfi_endproc
 950              	.LFE160:
 952              		.section	.text.CLOCK_GetCoreSysClkFreq,"ax",%progbits
 953              		.align	1
 954              		.global	CLOCK_GetCoreSysClkFreq
 955              		.syntax unified
 956              		.thumb
 957              		.thumb_func
 958              		.fpu fpv4-sp-d16
 960              	CLOCK_GetCoreSysClkFreq:
 961              	.LFB161:
 445:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 962              		.loc 1 445 0
 963              		.cfi_startproc
 964              		@ args = 0, pretend = 0, frame = 0
 965              		@ frame_needed = 0, uses_anonymous_args = 0
 966 0000 08B5     		push	{r3, lr}
 967              		.cfi_def_cfa_offset 8
 968              		.cfi_offset 3, -8
 969              		.cfi_offset 14, -4
 446:../drivers/fsl_clock.c **** }
 970              		.loc 1 446 0
 971 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 972              	.LVL59:
 973 0006 044A     		ldr	r2, .L117
 974 0008 41F24403 		movw	r3, #4164
 975 000c D358     		ldr	r3, [r2, r3]
 976 000e 1B0F     		lsrs	r3, r3, #28
 977 0010 0133     		adds	r3, r3, #1
 447:../drivers/fsl_clock.c **** 
 978              		.loc 1 447 0
 979 0012 B0FBF3F0 		udiv	r0, r0, r3
 980 0016 08BD     		pop	{r3, pc}
 981              	.L118:
 982              		.align	2
 983              	.L117:
 984 0018 00700440 		.word	1074032640
 985              		.cfi_endproc
 986              	.LFE161:
 988              		.section	.text.CLOCK_GetPlatClkFreq,"ax",%progbits
 989              		.align	1
 990              		.global	CLOCK_GetPlatClkFreq
 991              		.syntax unified
 992              		.thumb
 993              		.thumb_func
 994              		.fpu fpv4-sp-d16
 996              	CLOCK_GetPlatClkFreq:
 997              	.LFB207:
 998              		.cfi_startproc
 999              		@ args = 0, pretend = 0, frame = 0
 1000              		@ frame_needed = 0, uses_anonymous_args = 0
 1001              		@ link register save eliminated.
 1002 0000 FFF7FEBF 		b	CLOCK_GetCoreSysClkFreq
 1003              		.cfi_endproc
 1004              	.LFE207:
 1006              		.section	.text.CLOCK_GetFixedFreqClkFreq,"ax",%progbits
 1007              		.align	1
 1008              		.global	CLOCK_GetFixedFreqClkFreq
 1009              		.syntax unified
 1010              		.thumb
 1011              		.thumb_func
 1012              		.fpu fpv4-sp-d16
 1014              	CLOCK_GetFixedFreqClkFreq:
 1015              	.LFB168:
 618:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 1016              		.loc 1 618 0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 0
 1019              		@ frame_needed = 0, uses_anonymous_args = 0
 618:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 1020              		.loc 1 618 0
 1021 0000 10B5     		push	{r4, lr}
 1022              		.cfi_def_cfa_offset 8
 1023              		.cfi_offset 4, -8
 1024              		.cfi_offset 14, -4
 1025              	.LBB60:
 1026              	.LBB61:
 326:../drivers/fsl_clock.c ****     {
 1027              		.loc 1 326 0
 1028 0002 0A4B     		ldr	r3, .L126
 1029 0004 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1030 0006 DB06     		lsls	r3, r3, #27
 1031 0008 06D4     		bmi	.L121
 328:../drivers/fsl_clock.c ****     }
 1032              		.loc 1 328 0
 1033 000a FFF7FEFF 		bl	CLOCK_GetFllExtRefClkFreq
 1034              	.LVL60:
 1035 000e 0446     		mov	r4, r0
 1036              	.L122:
 1037              	.LBE61:
 1038              	.LBE60:
 622:../drivers/fsl_clock.c ****     {
 1039              		.loc 1 622 0
 1040 0010 2CB9     		cbnz	r4, .L123
 1041              	.L125:
 628:../drivers/fsl_clock.c ****     }
 1042              		.loc 1 628 0
 1043 0012 0024     		movs	r4, #0
 1044              	.L120:
 630:../drivers/fsl_clock.c **** 
 1045              		.loc 1 630 0
 1046 0014 2046     		mov	r0, r4
 1047 0016 10BD     		pop	{r4, pc}
 1048              	.L121:
 1049              	.LBB63:
 1050              	.LBB62:
 333:../drivers/fsl_clock.c ****     }
 1051              		.loc 1 333 0
 1052 0018 054B     		ldr	r3, .L126+4
 1053 001a 1C68     		ldr	r4, [r3]
 1054 001c F8E7     		b	.L122
 1055              	.L123:
 1056              	.LBE62:
 1057              	.LBE63:
 622:../drivers/fsl_clock.c ****     {
 1058              		.loc 1 622 0 discriminator 1
 1059 001e FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1060              	.LVL61:
 1061 0022 B4EBD00F 		cmp	r4, r0, lsr #3
 1062 0026 F4D8     		bhi	.L125
 1063 0028 F4E7     		b	.L120
 1064              	.L127:
 1065 002a 00BF     		.align	2
 1066              	.L126:
 1067 002c 00400640 		.word	1074151424
 1068 0030 00000000 		.word	.LANCHOR0
 1069              		.cfi_endproc
 1070              	.LFE168:
 1072              		.section	.text.CLOCK_GetFreq,"ax",%progbits
 1073              		.align	1
 1074              		.global	CLOCK_GetFreq
 1075              		.syntax unified
 1076              		.thumb
 1077              		.thumb_func
 1078              		.fpu fpv4-sp-d16
 1080              	CLOCK_GetFreq:
 1081              	.LFB162:
 450:../drivers/fsl_clock.c ****     uint32_t freq;
 1082              		.loc 1 450 0
 1083              		.cfi_startproc
 1084              		@ args = 0, pretend = 0, frame = 0
 1085              		@ frame_needed = 0, uses_anonymous_args = 0
 1086              	.LVL62:
 1087 0000 08B5     		push	{r3, lr}
 1088              		.cfi_def_cfa_offset 8
 1089              		.cfi_offset 3, -8
 1090              		.cfi_offset 14, -4
 453:../drivers/fsl_clock.c ****     {
 1091              		.loc 1 453 0
 1092 0002 1328     		cmp	r0, #19
 1093 0004 50D8     		bhi	.L129
 1094 0006 DFE800F0 		tbb	[pc, r0]
 1095              	.L131:
 1096 000a 0D       		.byte	(.L130-.L131)/2
 1097 000b 0D       		.byte	(.L130-.L131)/2
 1098 000c 18       		.byte	(.L132-.L131)/2
 1099 000d 21       		.byte	(.L133-.L131)/2
 1100 000e 2A       		.byte	(.L134-.L131)/2
 1101 000f 4F       		.byte	(.L129-.L131)/2
 1102 0010 33       		.byte	(.L135-.L131)/2
 1103 0011 37       		.byte	(.L136-.L131)/2
 1104 0012 3B       		.byte	(.L137-.L131)/2
 1105 0013 4F       		.byte	(.L129-.L131)/2
 1106 0014 4F       		.byte	(.L129-.L131)/2
 1107 0015 3F       		.byte	(.L138-.L131)/2
 1108 0016 43       		.byte	(.L139-.L131)/2
 1109 0017 47       		.byte	(.L140-.L131)/2
 1110 0018 4B       		.byte	(.L141-.L131)/2
 1111 0019 4F       		.byte	(.L129-.L131)/2
 1112 001a 4F       		.byte	(.L129-.L131)/2
 1113 001b 4F       		.byte	(.L129-.L131)/2
 1114 001c 51       		.byte	(.L144-.L131)/2
 1115 001d 0A       		.byte	(.L143-.L131)/2
 1116              		.p2align 1
 1117              	.L143:
 493:../drivers/fsl_clock.c ****             break;
 1118              		.loc 1 493 0
 1119 001e 4FF47A70 		mov	r0, #1000
 1120              	.LVL63:
 1121 0022 08BD     		pop	{r3, pc}
 1122              	.LVL64:
 1123              	.L130:
 457:../drivers/fsl_clock.c ****             break;
 1124              		.loc 1 457 0
 1125 0024 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1126              	.LVL65:
 1127 0028 41F24403 		movw	r3, #4164
 1128 002c 204A     		ldr	r2, .L146
 1129 002e D358     		ldr	r3, [r2, r3]
 1130 0030 1B0F     		lsrs	r3, r3, #28
 1131              	.L145:
 466:../drivers/fsl_clock.c ****             break;
 1132              		.loc 1 466 0
 1133 0032 0133     		adds	r3, r3, #1
 1134 0034 B0FBF3F0 		udiv	r0, r0, r3
 1135              	.LVL66:
 467:../drivers/fsl_clock.c ****         case kCLOCK_PllFllSelClk:
 1136              		.loc 1 467 0
 1137 0038 08BD     		pop	{r3, pc}
 1138              	.LVL67:
 1139              	.L132:
 460:../drivers/fsl_clock.c ****             break;
 1140              		.loc 1 460 0
 1141 003a FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1142              	.LVL68:
 1143 003e 41F24403 		movw	r3, #4164
 1144 0042 1B4A     		ldr	r2, .L146
 1145 0044 D358     		ldr	r3, [r2, r3]
 1146 0046 C3F30363 		ubfx	r3, r3, #24, #4
 1147 004a F2E7     		b	.L145
 1148              	.LVL69:
 1149              	.L133:
 463:../drivers/fsl_clock.c ****             break;
 1150              		.loc 1 463 0
 1151 004c FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1152              	.LVL70:
 1153 0050 41F24403 		movw	r3, #4164
 1154 0054 164A     		ldr	r2, .L146
 1155 0056 D358     		ldr	r3, [r2, r3]
 1156 0058 C3F30353 		ubfx	r3, r3, #20, #4
 1157 005c E9E7     		b	.L145
 1158              	.LVL71:
 1159              	.L134:
 466:../drivers/fsl_clock.c ****             break;
 1160              		.loc 1 466 0
 1161 005e FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1162              	.LVL72:
 1163 0062 41F24403 		movw	r3, #4164
 1164 0066 124A     		ldr	r2, .L146
 1165 0068 D358     		ldr	r3, [r2, r3]
 1166 006a C3F30343 		ubfx	r3, r3, #16, #4
 1167 006e E0E7     		b	.L145
 1168              	.LVL73:
 1169              	.L135:
 501:../drivers/fsl_clock.c **** 
 1170              		.loc 1 501 0
 1171 0070 BDE80840 		pop	{r3, lr}
 1172              		.cfi_remember_state
 1173              		.cfi_restore 14
 1174              		.cfi_restore 3
 1175              		.cfi_def_cfa_offset 0
 469:../drivers/fsl_clock.c ****             break;
 1176              		.loc 1 469 0
 1177 0074 FFF7FEBF 		b	CLOCK_GetPllFllSelClkFreq
 1178              	.LVL74:
 1179              	.L136:
 1180              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1181              		.loc 1 501 0
 1182 0078 BDE80840 		pop	{r3, lr}
 1183              		.cfi_remember_state
 1184              		.cfi_restore 14
 1185              		.cfi_restore 3
 1186              		.cfi_def_cfa_offset 0
 472:../drivers/fsl_clock.c ****             break;
 1187              		.loc 1 472 0
 1188 007c FFF7FEBF 		b	CLOCK_GetEr32kClkFreq
 1189              	.LVL75:
 1190              	.L137:
 1191              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1192              		.loc 1 501 0
 1193 0080 BDE80840 		pop	{r3, lr}
 1194              		.cfi_remember_state
 1195              		.cfi_restore 14
 1196              		.cfi_restore 3
 1197              		.cfi_def_cfa_offset 0
 475:../drivers/fsl_clock.c ****             break;
 1198              		.loc 1 475 0
 1199 0084 FFF7FEBF 		b	CLOCK_GetOsc0ErClkFreq
 1200              	.LVL76:
 1201              	.L138:
 1202              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1203              		.loc 1 501 0
 1204 0088 BDE80840 		pop	{r3, lr}
 1205              		.cfi_remember_state
 1206              		.cfi_restore 14
 1207              		.cfi_restore 3
 1208              		.cfi_def_cfa_offset 0
 478:../drivers/fsl_clock.c ****             break;
 1209              		.loc 1 478 0
 1210 008c FFF7FEBF 		b	CLOCK_GetFixedFreqClkFreq
 1211              	.LVL77:
 1212              	.L139:
 1213              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1214              		.loc 1 501 0
 1215 0090 BDE80840 		pop	{r3, lr}
 1216              		.cfi_remember_state
 1217              		.cfi_restore 14
 1218              		.cfi_restore 3
 1219              		.cfi_def_cfa_offset 0
 481:../drivers/fsl_clock.c ****             break;
 1220              		.loc 1 481 0
 1221 0094 FFF7FEBF 		b	CLOCK_GetInternalRefClkFreq
 1222              	.LVL78:
 1223              	.L140:
 1224              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1225              		.loc 1 501 0
 1226 0098 BDE80840 		pop	{r3, lr}
 1227              		.cfi_remember_state
 1228              		.cfi_restore 14
 1229              		.cfi_restore 3
 1230              		.cfi_def_cfa_offset 0
 484:../drivers/fsl_clock.c ****             break;
 1231              		.loc 1 484 0
 1232 009c FFF7FEBF 		b	CLOCK_GetFllFreq
 1233              	.LVL79:
 1234              	.L141:
 1235              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1236              		.loc 1 501 0
 1237 00a0 BDE80840 		pop	{r3, lr}
 1238              		.cfi_remember_state
 1239              		.cfi_restore 14
 1240              		.cfi_restore 3
 1241              		.cfi_def_cfa_offset 0
 487:../drivers/fsl_clock.c ****             break;
 1242              		.loc 1 487 0
 1243 00a4 FFF7FEBF 		b	CLOCK_GetPll0Freq
 1244              	.LVL80:
 1245              	.L129:
 1246              		.cfi_restore_state
 496:../drivers/fsl_clock.c ****             break;
 1247              		.loc 1 496 0
 1248 00a8 0020     		movs	r0, #0
 1249              	.LVL81:
 497:../drivers/fsl_clock.c ****     }
 1250              		.loc 1 497 0
 1251 00aa 08BD     		pop	{r3, pc}
 1252              	.LVL82:
 1253              	.L144:
 490:../drivers/fsl_clock.c ****             break;
 1254              		.loc 1 490 0
 1255 00ac 0148     		ldr	r0, .L146+4
 1256              	.LVL83:
 501:../drivers/fsl_clock.c **** 
 1257              		.loc 1 501 0
 1258 00ae 08BD     		pop	{r3, pc}
 1259              	.L147:
 1260              		.align	2
 1261              	.L146:
 1262 00b0 00700440 		.word	1074032640
 1263 00b4 006CDC02 		.word	48000000
 1264              		.cfi_endproc
 1265              	.LFE162:
 1267              		.section	.text.CLOCK_SetExternalRefClkConfig,"ax",%progbits
 1268              		.align	1
 1269              		.global	CLOCK_SetExternalRefClkConfig
 1270              		.syntax unified
 1271              		.thumb
 1272              		.thumb_func
 1273              		.fpu fpv4-sp-d16
 1275              	CLOCK_SetExternalRefClkConfig:
 1276              	.LFB170:
 655:../drivers/fsl_clock.c **** 
 656:../drivers/fsl_clock.c **** status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
 657:../drivers/fsl_clock.c **** {
 1277              		.loc 1 657 0
 1278              		.cfi_startproc
 1279              		@ args = 0, pretend = 0, frame = 0
 1280              		@ frame_needed = 0, uses_anonymous_args = 0
 1281              	.LVL84:
 1282 0000 10B5     		push	{r4, lr}
 1283              		.cfi_def_cfa_offset 8
 1284              		.cfi_offset 4, -8
 1285              		.cfi_offset 14, -4
 658:../drivers/fsl_clock.c ****     bool needDelay;
 659:../drivers/fsl_clock.c ****     uint32_t i;
 660:../drivers/fsl_clock.c **** 
 661:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
 662:../drivers/fsl_clock.c ****     /* If change MCG_C7[OSCSEL] and external reference clock is system clock source, return error. 
 663:../drivers/fsl_clock.c ****     if ((MCG_C7_OSCSEL_VAL != oscsel) && (!(MCG->S & MCG_S_IREFST_MASK)))
 664:../drivers/fsl_clock.c ****     {
 665:../drivers/fsl_clock.c ****         return kStatus_MCG_SourceUsed;
 666:../drivers/fsl_clock.c ****     }
 667:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
 668:../drivers/fsl_clock.c **** 
 669:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL_VAL != oscsel)
 1286              		.loc 1 669 0
 1287 0002 0A49     		ldr	r1, .L152
 1288 0004 0A7B     		ldrb	r2, [r1, #12]	@ zero_extendqisi2
 1289              	.LVL85:
 670:../drivers/fsl_clock.c ****     {
 671:../drivers/fsl_clock.c ****         /* If change OSCSEL, need to delay, ERR009878. */
 672:../drivers/fsl_clock.c ****         needDelay = true;
 673:../drivers/fsl_clock.c ****     }
 674:../drivers/fsl_clock.c ****     else
 675:../drivers/fsl_clock.c ****     {
 676:../drivers/fsl_clock.c ****         needDelay = false;
 677:../drivers/fsl_clock.c ****     }
 678:../drivers/fsl_clock.c **** 
 679:../drivers/fsl_clock.c ****     MCG->C7 = (MCG->C7 & ~MCG_C7_OSCSEL_MASK) | MCG_C7_OSCSEL(oscsel);
 1290              		.loc 1 679 0
 1291 0006 0B7B     		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 1292 0008 00F00304 		and	r4, r0, #3
 1293 000c 03F0FC03 		and	r3, r3, #252
 1294 0010 2343     		orrs	r3, r3, r4
 1295 0012 0B73     		strb	r3, [r1, #12]
 680:../drivers/fsl_clock.c ****     if (needDelay)
 1296              		.loc 1 680 0
 1297 0014 02F00303 		and	r3, r2, #3
 1298 0018 8342     		cmp	r3, r0
 1299 001a 03D0     		beq	.L149
 1300 001c 40F2DD53 		movw	r3, #1501
 1301              	.L150:
 1302              	.LVL86:
 1303              	.LBB66:
 1304              	.LBB67:
 681:../drivers/fsl_clock.c ****     {
 682:../drivers/fsl_clock.c ****         /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
 683:../drivers/fsl_clock.c ****         i = 1500U;
 684:../drivers/fsl_clock.c ****         while (i--)
 1305              		.loc 1 684 0
 1306 0020 013B     		subs	r3, r3, #1
 1307              	.LVL87:
 1308 0022 01D1     		bne	.L151
 1309              	.LVL88:
 1310              	.L149:
 1311              	.LBE67:
 1312              	.LBE66:
 685:../drivers/fsl_clock.c ****         {
 686:../drivers/fsl_clock.c ****             __NOP();
 687:../drivers/fsl_clock.c ****         }
 688:../drivers/fsl_clock.c ****     }
 689:../drivers/fsl_clock.c **** 
 690:../drivers/fsl_clock.c ****     return kStatus_Success;
 691:../drivers/fsl_clock.c **** }
 1313              		.loc 1 691 0
 1314 0024 0020     		movs	r0, #0
 1315              	.LVL89:
 1316 0026 10BD     		pop	{r4, pc}
 1317              	.LVL90:
 1318              	.L151:
 1319              	.LBB69:
 1320              	.LBB68:
 686:../drivers/fsl_clock.c ****         }
 1321              		.loc 1 686 0
 1322              		.syntax unified
 1323              	@ 686 "../drivers/fsl_clock.c" 1
 1324 0028 00BF     		nop
 1325              	@ 0 "" 2
 1326              		.thumb
 1327              		.syntax unified
 1328 002a F9E7     		b	.L150
 1329              	.L153:
 1330              		.align	2
 1331              	.L152:
 1332 002c 00400640 		.word	1074151424
 1333              	.LBE68:
 1334              	.LBE69:
 1335              		.cfi_endproc
 1336              	.LFE170:
 1338              		.section	.text.CLOCK_SetInternalRefClkConfig,"ax",%progbits
 1339              		.align	1
 1340              		.global	CLOCK_SetInternalRefClkConfig
 1341              		.syntax unified
 1342              		.thumb
 1343              		.thumb_func
 1344              		.fpu fpv4-sp-d16
 1346              	CLOCK_SetInternalRefClkConfig:
 1347              	.LFB171:
 692:../drivers/fsl_clock.c **** 
 693:../drivers/fsl_clock.c **** status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
 694:../drivers/fsl_clock.c **** {
 1348              		.loc 1 694 0
 1349              		.cfi_startproc
 1350              		@ args = 0, pretend = 0, frame = 0
 1351              		@ frame_needed = 0, uses_anonymous_args = 0
 1352              	.LVL91:
 1353 0000 70B5     		push	{r4, r5, r6, lr}
 1354              		.cfi_def_cfa_offset 16
 1355              		.cfi_offset 4, -16
 1356              		.cfi_offset 5, -12
 1357              		.cfi_offset 6, -8
 1358              		.cfi_offset 14, -4
 695:../drivers/fsl_clock.c ****     uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
 1359              		.loc 1 695 0
 1360 0002 1E4B     		ldr	r3, .L176
 1361 0004 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 696:../drivers/fsl_clock.c ****     mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
 1362              		.loc 1 696 0
 1363 0006 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 697:../drivers/fsl_clock.c ****     uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
 1364              		.loc 1 697 0
 1365 0008 1E7A     		ldrb	r6, [r3, #8]	@ zero_extendqisi2
 698:../drivers/fsl_clock.c **** 
 699:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
 700:../drivers/fsl_clock.c ****     /* If MCGIRCLK is used as system clock source. */
 701:../drivers/fsl_clock.c ****     if (kMCG_ClkOutStatInt == mcgOutClkState)
 702:../drivers/fsl_clock.c ****     {
 703:../drivers/fsl_clock.c ****         /* If need to change MCGIRCLK source or driver, return error. */
 704:../drivers/fsl_clock.c ****         if (((kMCG_IrcFast == curIrcs) && (fcrdiv != curFcrdiv)) || (ircs != curIrcs))
 705:../drivers/fsl_clock.c ****         {
 706:../drivers/fsl_clock.c ****             return kStatus_MCG_SourceUsed;
 707:../drivers/fsl_clock.c ****         }
 708:../drivers/fsl_clock.c ****     }
 709:../drivers/fsl_clock.c **** #endif
 710:../drivers/fsl_clock.c **** 
 711:../drivers/fsl_clock.c ****     /* If need to update the FCRDIV. */
 712:../drivers/fsl_clock.c ****     if (fcrdiv != curFcrdiv)
 1366              		.loc 1 712 0
 1367 000a C6F34206 		ubfx	r6, r6, #1, #3
 1368 000e 9642     		cmp	r6, r2
 695:../drivers/fsl_clock.c ****     mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
 1369              		.loc 1 695 0
 1370 0010 C4F38104 		ubfx	r4, r4, #2, #2
 1371              	.LVL92:
 696:../drivers/fsl_clock.c ****     uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
 1372              		.loc 1 696 0
 1373 0014 EDB2     		uxtb	r5, r5
 1374              	.LVL93:
 1375              		.loc 1 712 0
 1376 0016 0AD0     		beq	.L155
 713:../drivers/fsl_clock.c ****     {
 714:../drivers/fsl_clock.c ****         /* If fast IRC is in use currently, change to slow IRC. */
 715:../drivers/fsl_clock.c ****         if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (MCG->C1 & MCG_
 1377              		.loc 1 715 0
 1378 0018 ED07     		lsls	r5, r5, #31
 1379              	.LVL94:
 1380 001a 20D4     		bmi	.L156
 1381              	.L158:
 716:../drivers/fsl_clock.c ****         {
 717:../drivers/fsl_clock.c ****             MCG->C2 = ((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(kMCG_IrcSlow)));
 718:../drivers/fsl_clock.c ****             while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
 719:../drivers/fsl_clock.c ****             {
 720:../drivers/fsl_clock.c ****             }
 721:../drivers/fsl_clock.c ****         }
 722:../drivers/fsl_clock.c ****         /* Update FCRDIV. */
 723:../drivers/fsl_clock.c ****         MCG->SC = (MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC
 1382              		.loc 1 723 0
 1383 001c 174D     		ldr	r5, .L176
 1384 001e 2B7A     		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 1385 0020 5200     		lsls	r2, r2, #1
 1386              	.LVL95:
 1387 0022 02F00E02 		and	r2, r2, #14
 1388 0026 03F0D003 		and	r3, r3, #208
 1389 002a 1A43     		orrs	r2, r2, r3
 1390 002c 2A72     		strb	r2, [r5, #8]
 1391              	.L155:
 724:../drivers/fsl_clock.c ****     }
 725:../drivers/fsl_clock.c **** 
 726:../drivers/fsl_clock.c ****     /* Set internal reference clock selection. */
 727:../drivers/fsl_clock.c ****     MCG->C2 = (MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(ircs));
 1392              		.loc 1 727 0
 1393 002e 134B     		ldr	r3, .L176
 1394 0030 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1395 0032 01F00105 		and	r5, r1, #1
 1396 0036 02F0FE02 		and	r2, r2, #254
 1397 003a 2A43     		orrs	r2, r2, r5
 1398 003c 5A70     		strb	r2, [r3, #1]
 728:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
 1399              		.loc 1 728 0
 1400 003e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1401 0040 02F0FC02 		and	r2, r2, #252
 1402 0044 0243     		orrs	r2, r2, r0
 729:../drivers/fsl_clock.c **** 
 730:../drivers/fsl_clock.c ****     /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
 731:../drivers/fsl_clock.c ****     if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
 1403              		.loc 1 731 0
 1404 0046 012C     		cmp	r4, #1
 728:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
 1405              		.loc 1 728 0
 1406 0048 1A70     		strb	r2, [r3]
 1407              		.loc 1 731 0
 1408 004a 01D0     		beq	.L169
 1409              		.loc 1 731 0 is_stmt 0 discriminator 1
 1410 004c 8207     		lsls	r2, r0, #30
 1411 004e 04D5     		bpl	.L161
 1412              	.L169:
 732:../drivers/fsl_clock.c ****     {
 733:../drivers/fsl_clock.c ****         while (MCG_S_IRCST_VAL != ircs)
 1413              		.loc 1 733 0 is_stmt 1 discriminator 1
 1414 0050 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1415 0052 02F00102 		and	r2, r2, #1
 1416 0056 8A42     		cmp	r2, r1
 1417 0058 FAD1     		bne	.L169
 1418              	.L161:
 734:../drivers/fsl_clock.c ****         {
 735:../drivers/fsl_clock.c ****         }
 736:../drivers/fsl_clock.c ****     }
 737:../drivers/fsl_clock.c **** 
 738:../drivers/fsl_clock.c ****     return kStatus_Success;
 739:../drivers/fsl_clock.c **** }
 1419              		.loc 1 739 0
 1420 005a 0020     		movs	r0, #0
 1421              	.LVL96:
 1422 005c 70BD     		pop	{r4, r5, r6, pc}
 1423              	.LVL97:
 1424              	.L156:
 715:../drivers/fsl_clock.c ****         {
 1425              		.loc 1 715 0 discriminator 1
 1426 005e 012C     		cmp	r4, #1
 1427 0060 02D0     		beq	.L157
 715:../drivers/fsl_clock.c ****         {
 1428              		.loc 1 715 0 is_stmt 0 discriminator 2
 1429 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1430 0064 9E07     		lsls	r6, r3, #30
 1431 0066 D9D5     		bpl	.L158
 1432              	.L157:
 717:../drivers/fsl_clock.c ****             while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
 1433              		.loc 1 717 0 is_stmt 1
 1434 0068 044B     		ldr	r3, .L176
 1435 006a 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
 1436 006c 05F0FE05 		and	r5, r5, #254
 1437 0070 5D70     		strb	r5, [r3, #1]
 1438              	.L159:
 718:../drivers/fsl_clock.c ****             {
 1439              		.loc 1 718 0 discriminator 1
 1440 0072 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 1441 0074 ED07     		lsls	r5, r5, #31
 1442 0076 FCD4     		bmi	.L159
 1443 0078 D0E7     		b	.L158
 1444              	.L177:
 1445 007a 00BF     		.align	2
 1446              	.L176:
 1447 007c 00400640 		.word	1074151424
 1448              		.cfi_endproc
 1449              	.LFE171:
 1451              		.section	.text.CLOCK_CalcPllDiv,"ax",%progbits
 1452              		.align	1
 1453              		.global	CLOCK_CalcPllDiv
 1454              		.syntax unified
 1455              		.thumb
 1456              		.thumb_func
 1457              		.fpu fpv4-sp-d16
 1459              	CLOCK_CalcPllDiv:
 1460              	.LFB172:
 740:../drivers/fsl_clock.c **** 
 741:../drivers/fsl_clock.c **** uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv)
 742:../drivers/fsl_clock.c **** {
 1461              		.loc 1 742 0
 1462              		.cfi_startproc
 1463              		@ args = 0, pretend = 0, frame = 0
 1464              		@ frame_needed = 0, uses_anonymous_args = 0
 1465              	.LVL98:
 1466 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1467              		.cfi_def_cfa_offset 36
 1468              		.cfi_offset 4, -36
 1469              		.cfi_offset 5, -32
 1470              		.cfi_offset 6, -28
 1471              		.cfi_offset 7, -24
 1472              		.cfi_offset 8, -20
 1473              		.cfi_offset 9, -16
 1474              		.cfi_offset 10, -12
 1475              		.cfi_offset 11, -8
 1476              		.cfi_offset 14, -4
 1477              		.loc 1 742 0
 1478 0004 0746     		mov	r7, r0
 743:../drivers/fsl_clock.c ****     uint8_t ret_prdiv;           /* PRDIV to return. */
 744:../drivers/fsl_clock.c ****     uint8_t ret_vdiv;            /* VDIV to return.  */
 745:../drivers/fsl_clock.c ****     uint8_t prdiv_min;           /* Min PRDIV value to make reference clock in allowed range. */
 746:../drivers/fsl_clock.c ****     uint8_t prdiv_max;           /* Max PRDIV value to make reference clock in allowed range. */
 747:../drivers/fsl_clock.c ****     uint8_t prdiv_cur;           /* PRDIV value for iteration.    */
 748:../drivers/fsl_clock.c ****     uint8_t vdiv_cur;            /* VDIV value for iteration.     */
 749:../drivers/fsl_clock.c ****     uint32_t ret_freq = 0U;      /* PLL output fequency to return. */
 750:../drivers/fsl_clock.c ****     uint32_t diff = 0xFFFFFFFFU; /* Difference between desireFreq and return frequency. */
 751:../drivers/fsl_clock.c ****     uint32_t ref_div;            /* Reference frequency after PRDIV. */
 752:../drivers/fsl_clock.c **** 
 753:../drivers/fsl_clock.c ****     /*
 754:../drivers/fsl_clock.c ****        Steps:
 755:../drivers/fsl_clock.c ****        1. Get allowed prdiv with such rules:
 756:../drivers/fsl_clock.c ****           1). refFreq / prdiv >= FSL_FEATURE_MCG_PLL_REF_MIN.
 757:../drivers/fsl_clock.c ****           2). refFreq / prdiv <= FSL_FEATURE_MCG_PLL_REF_MAX.
 758:../drivers/fsl_clock.c ****        2. For each allowed prdiv, there are two candidate vdiv values:
 759:../drivers/fsl_clock.c ****           1). (desireFreq / (refFreq / prdiv)).
 760:../drivers/fsl_clock.c ****           2). (desireFreq / (refFreq / prdiv)) + 1.
 761:../drivers/fsl_clock.c ****           If could get the precise desired frequency, return current prdiv and
 762:../drivers/fsl_clock.c ****           vdiv directly. Otherwise choose the one which is closer to desired
 763:../drivers/fsl_clock.c ****           frequency.
 764:../drivers/fsl_clock.c ****      */
 765:../drivers/fsl_clock.c **** 
 766:../drivers/fsl_clock.c ****     /* Reference frequency is out of range. */
 767:../drivers/fsl_clock.c ****     if ((refFreq < FSL_FEATURE_MCG_PLL_REF_MIN) ||
 1479              		.loc 1 767 0
 1480 0006 2B4C     		ldr	r4, .L193
 1481 0008 A0F5F410 		sub	r0, r0, #1998848
 1482              	.LVL99:
 1483 000c A0F59060 		sub	r0, r0, #1152
 1484 0010 A042     		cmp	r0, r4
 1485 0012 4BD8     		bhi	.L186
 768:../drivers/fsl_clock.c ****         (refFreq > (FSL_FEATURE_MCG_PLL_REF_MAX * (FSL_FEATURE_MCG_PLL_PRDIV_MAX + FSL_FEATURE_MCG_
 769:../drivers/fsl_clock.c ****     {
 770:../drivers/fsl_clock.c ****         return 0U;
 771:../drivers/fsl_clock.c ****     }
 772:../drivers/fsl_clock.c **** 
 773:../drivers/fsl_clock.c ****     /* refFreq/PRDIV must in a range. First get the allowed PRDIV range. */
 774:../drivers/fsl_clock.c ****     prdiv_max = refFreq / FSL_FEATURE_MCG_PLL_REF_MIN;
 775:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1486              		.loc 1 775 0
 1487 0014 07F5741E 		add	lr, r7, #3997696
 774:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1488              		.loc 1 774 0
 1489 0018 274D     		ldr	r5, .L193+4
 1490              		.loc 1 775 0
 1491 001a 2848     		ldr	r0, .L193+8
 774:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1492              		.loc 1 774 0
 1493 001c B7FBF5F5 		udiv	r5, r7, r5
 1494              		.loc 1 775 0
 1495 0020 0EF6FF0E 		addw	lr, lr, #2303
 774:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1496              		.loc 1 774 0
 1497 0024 EDB2     		uxtb	r5, r5
 1498              	.LVL100:
 1499              		.loc 1 775 0
 1500 0026 BEFBF0FE 		udiv	lr, lr, r0
 750:../drivers/fsl_clock.c ****     uint32_t ref_div;            /* Reference frequency after PRDIV. */
 1501              		.loc 1 750 0
 1502 002a 4FF0FF3C 		mov	ip, #-1
 1503              		.loc 1 775 0
 1504 002e 5FFA8EFE 		uxtb	lr, lr
 1505              	.LVL101:
 1506              	.L180:
 776:../drivers/fsl_clock.c **** 
 777:../drivers/fsl_clock.c ****     /* PRDIV traversal. */
 778:../drivers/fsl_clock.c ****     for (prdiv_cur = prdiv_max; prdiv_cur >= prdiv_min; prdiv_cur--)
 1507              		.loc 1 778 0 discriminator 1
 1508 0032 7545     		cmp	r5, lr
 1509 0034 0ED2     		bcs	.L184
 779:../drivers/fsl_clock.c ****     {
 780:../drivers/fsl_clock.c ****         /* Reference frequency after PRDIV. */
 781:../drivers/fsl_clock.c ****         ref_div = refFreq / prdiv_cur;
 782:../drivers/fsl_clock.c **** 
 783:../drivers/fsl_clock.c ****         vdiv_cur = desireFreq / ref_div;
 784:../drivers/fsl_clock.c **** 
 785:../drivers/fsl_clock.c ****         if ((vdiv_cur < FSL_FEATURE_MCG_PLL_VDIV_BASE - 1U) || (vdiv_cur > FSL_FEATURE_MCG_PLL_VDIV
 786:../drivers/fsl_clock.c ****         {
 787:../drivers/fsl_clock.c ****             /* No VDIV is available with this PRDIV. */
 788:../drivers/fsl_clock.c ****             continue;
 789:../drivers/fsl_clock.c ****         }
 790:../drivers/fsl_clock.c **** 
 791:../drivers/fsl_clock.c ****         ret_freq = vdiv_cur * ref_div;
 792:../drivers/fsl_clock.c **** 
 793:../drivers/fsl_clock.c ****         if (vdiv_cur >= FSL_FEATURE_MCG_PLL_VDIV_BASE)
 794:../drivers/fsl_clock.c ****         {
 795:../drivers/fsl_clock.c ****             if (ret_freq == desireFreq) /* If desire frequency is got. */
 796:../drivers/fsl_clock.c ****             {
 797:../drivers/fsl_clock.c ****                 *prdiv = prdiv_cur - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
 798:../drivers/fsl_clock.c ****                 *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 799:../drivers/fsl_clock.c ****                 return ret_freq;
 800:../drivers/fsl_clock.c ****             }
 801:../drivers/fsl_clock.c ****             /* New PRDIV/VDIV is closer. */
 802:../drivers/fsl_clock.c ****             if (diff > desireFreq - ret_freq)
 803:../drivers/fsl_clock.c ****             {
 804:../drivers/fsl_clock.c ****                 diff = desireFreq - ret_freq;
 805:../drivers/fsl_clock.c ****                 ret_prdiv = prdiv_cur;
 806:../drivers/fsl_clock.c ****                 ret_vdiv = vdiv_cur;
 807:../drivers/fsl_clock.c ****             }
 808:../drivers/fsl_clock.c ****         }
 809:../drivers/fsl_clock.c ****         vdiv_cur++;
 810:../drivers/fsl_clock.c ****         if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
 811:../drivers/fsl_clock.c ****         {
 812:../drivers/fsl_clock.c ****             ret_freq += ref_div;
 813:../drivers/fsl_clock.c ****             /* New PRDIV/VDIV is closer. */
 814:../drivers/fsl_clock.c ****             if (diff > ret_freq - desireFreq)
 815:../drivers/fsl_clock.c ****             {
 816:../drivers/fsl_clock.c ****                 diff = ret_freq - desireFreq;
 817:../drivers/fsl_clock.c ****                 ret_prdiv = prdiv_cur;
 818:../drivers/fsl_clock.c ****                 ret_vdiv = vdiv_cur;
 819:../drivers/fsl_clock.c ****             }
 820:../drivers/fsl_clock.c ****         }
 821:../drivers/fsl_clock.c ****     }
 822:../drivers/fsl_clock.c **** 
 823:../drivers/fsl_clock.c ****     if (0xFFFFFFFFU != diff)
 1510              		.loc 1 823 0
 1511 0036 BCF1FF3F 		cmp	ip, #-1
 1512 003a 37D0     		beq	.L186
 824:../drivers/fsl_clock.c ****     {
 825:../drivers/fsl_clock.c ****         /* PRDIV/VDIV found. */
 826:../drivers/fsl_clock.c ****         *prdiv = ret_prdiv - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
 827:../drivers/fsl_clock.c ****         *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 828:../drivers/fsl_clock.c ****         ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
 1513              		.loc 1 828 0
 1514 003c B7FBF9F0 		udiv	r0, r7, r9
 826:../drivers/fsl_clock.c ****         *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 1515              		.loc 1 826 0
 1516 0040 09F1FF31 		add	r1, r9, #-1
 1517              	.LVL102:
 1518 0044 1170     		strb	r1, [r2]
 827:../drivers/fsl_clock.c ****         ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
 1519              		.loc 1 827 0
 1520 0046 A8F11802 		sub	r2, r8, #24
 1521              	.LVL103:
 1522 004a 1A70     		strb	r2, [r3]
 1523              		.loc 1 828 0
 1524 004c 08FB00F0 		mul	r0, r8, r0
 1525              	.LVL104:
 829:../drivers/fsl_clock.c ****         return ret_freq;
 1526              		.loc 1 829 0
 1527 0050 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1528              	.LVL105:
 1529              	.L184:
 781:../drivers/fsl_clock.c **** 
 1530              		.loc 1 781 0
 1531 0054 B7FBF5F6 		udiv	r6, r7, r5
 1532              	.LVL106:
 783:../drivers/fsl_clock.c **** 
 1533              		.loc 1 783 0
 1534 0058 B1FBF6F4 		udiv	r4, r1, r6
 1535 005c E4B2     		uxtb	r4, r4
 1536              	.LVL107:
 785:../drivers/fsl_clock.c ****         {
 1537              		.loc 1 785 0
 1538 005e A4F11700 		sub	r0, r4, #23
 1539 0062 2028     		cmp	r0, #32
 1540 0064 05F1FF3A 		add	r10, r5, #-1
 1541 0068 1DD8     		bhi	.L181
 793:../drivers/fsl_clock.c ****         {
 1542              		.loc 1 793 0
 1543 006a 172C     		cmp	r4, #23
 791:../drivers/fsl_clock.c **** 
 1544              		.loc 1 791 0
 1545 006c 06FB04F0 		mul	r0, r6, r4
 1546              	.LVL108:
 793:../drivers/fsl_clock.c ****         {
 1547              		.loc 1 793 0
 1548 0070 0ED0     		beq	.L182
 795:../drivers/fsl_clock.c ****             {
 1549              		.loc 1 795 0
 1550 0072 8142     		cmp	r1, r0
 1551 0074 05D1     		bne	.L183
 797:../drivers/fsl_clock.c ****                 *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 1552              		.loc 1 797 0
 1553 0076 82F800A0 		strb	r10, [r2]
 798:../drivers/fsl_clock.c ****                 return ret_freq;
 1554              		.loc 1 798 0
 1555 007a 183C     		subs	r4, r4, #24
 1556              	.LVL109:
 1557 007c 1C70     		strb	r4, [r3]
 799:../drivers/fsl_clock.c ****             }
 1558              		.loc 1 799 0
 1559 007e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1560              	.LVL110:
 1561              	.L183:
 802:../drivers/fsl_clock.c ****             {
 1562              		.loc 1 802 0
 1563 0082 A1EB000B 		sub	fp, r1, r0
 1564 0086 DC45     		cmp	ip, fp
 1565 0088 82BF     		ittt	hi
 1566 008a DC46     		movhi	ip, fp
 1567              	.LVL111:
 1568 008c A046     		movhi	r8, r4
 1569 008e A946     		movhi	r9, r5
 1570              	.L182:
 1571              	.LVL112:
 809:../drivers/fsl_clock.c ****         if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
 1572              		.loc 1 809 0
 1573 0090 0134     		adds	r4, r4, #1
 1574              	.LVL113:
 1575 0092 E4B2     		uxtb	r4, r4
 1576              	.LVL114:
 810:../drivers/fsl_clock.c ****         {
 1577              		.loc 1 810 0
 1578 0094 382C     		cmp	r4, #56
 1579 0096 06D0     		beq	.L181
 1580              	.LVL115:
 814:../drivers/fsl_clock.c ****             {
 1581              		.loc 1 814 0
 1582 0098 761A     		subs	r6, r6, r1
 1583              	.LVL116:
 1584 009a 0644     		add	r6, r6, r0
 1585 009c B445     		cmp	ip, r6
 1586 009e 82BF     		ittt	hi
 1587 00a0 B446     		movhi	ip, r6
 1588              	.LVL117:
 1589 00a2 A046     		movhi	r8, r4
 1590 00a4 A946     		movhi	r9, r5
 1591              	.LVL118:
 1592              	.L181:
 778:../drivers/fsl_clock.c ****     {
 1593              		.loc 1 778 0 discriminator 2
 1594 00a6 5FFA8AF5 		uxtb	r5, r10
 1595              	.LVL119:
 1596 00aa C2E7     		b	.L180
 1597              	.LVL120:
 1598              	.L186:
 770:../drivers/fsl_clock.c ****     }
 1599              		.loc 1 770 0
 1600 00ac 0020     		movs	r0, #0
 830:../drivers/fsl_clock.c ****     }
 831:../drivers/fsl_clock.c ****     else
 832:../drivers/fsl_clock.c ****     {
 833:../drivers/fsl_clock.c ****         /* No proper PRDIV/VDIV found. */
 834:../drivers/fsl_clock.c ****         return 0U;
 835:../drivers/fsl_clock.c ****     }
 836:../drivers/fsl_clock.c **** }
 1601              		.loc 1 836 0
 1602 00ae BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1603              	.LVL121:
 1604              	.L194:
 1605 00b2 00BF     		.align	2
 1606              	.L193:
 1607 00b4 805CD705 		.word	98000000
 1608 00b8 80841E00 		.word	2000000
 1609 00bc 00093D00 		.word	4000000
 1610              		.cfi_endproc
 1611              	.LFE172:
 1613              		.section	.text.CLOCK_EnablePll0,"ax",%progbits
 1614              		.align	1
 1615              		.global	CLOCK_EnablePll0
 1616              		.syntax unified
 1617              		.thumb
 1618              		.thumb_func
 1619              		.fpu fpv4-sp-d16
 1621              	CLOCK_EnablePll0:
 1622              	.LFB173:
 837:../drivers/fsl_clock.c **** 
 838:../drivers/fsl_clock.c **** void CLOCK_EnablePll0(mcg_pll_config_t const *config)
 839:../drivers/fsl_clock.c **** {
 1623              		.loc 1 839 0
 1624              		.cfi_startproc
 1625              		@ args = 0, pretend = 0, frame = 0
 1626              		@ frame_needed = 0, uses_anonymous_args = 0
 1627              		@ link register save eliminated.
 1628              	.LVL122:
 840:../drivers/fsl_clock.c ****     assert(config);
 841:../drivers/fsl_clock.c **** 
 842:../drivers/fsl_clock.c ****     uint8_t mcg_c5 = 0U;
 843:../drivers/fsl_clock.c **** 
 844:../drivers/fsl_clock.c ****     mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
 1629              		.loc 1 844 0
 1630 0000 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 845:../drivers/fsl_clock.c ****     MCG->C5 = mcg_c5; /* Disable the PLL first. */
 1631              		.loc 1 845 0
 1632 0002 0B4B     		ldr	r3, .L199
 844:../drivers/fsl_clock.c ****     MCG->C5 = mcg_c5; /* Disable the PLL first. */
 1633              		.loc 1 844 0
 1634 0004 02F01F02 		and	r2, r2, #31
 1635              	.LVL123:
 1636              		.loc 1 845 0
 1637 0008 1A71     		strb	r2, [r3, #4]
 846:../drivers/fsl_clock.c **** 
 847:../drivers/fsl_clock.c ****     MCG->C6 = (MCG->C6 & ~MCG_C6_VDIV0_MASK) | MCG_C6_VDIV0(config->vdiv);
 1638              		.loc 1 847 0
 1639 000a 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1640 000c 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1641              	.LVL124:
 1642 000e 01F0E001 		and	r1, r1, #224
 1643 0012 02F01F02 		and	r2, r2, #31
 1644 0016 0A43     		orrs	r2, r2, r1
 1645 0018 5A71     		strb	r2, [r3, #5]
 1646              	.LVL125:
 848:../drivers/fsl_clock.c **** 
 849:../drivers/fsl_clock.c ****     /* Set enable mode. */
 850:../drivers/fsl_clock.c ****     MCG->C5 |= ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode);
 1647              		.loc 1 850 0
 1648 001a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1649 001c 42F04001 		orr	r1, r2, #64
 1650 0020 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 1651 0022 0A43     		orrs	r2, r2, r1
 1652 0024 1A71     		strb	r2, [r3, #4]
 1653              	.L196:
 851:../drivers/fsl_clock.c **** 
 852:../drivers/fsl_clock.c ****     /* Wait for PLL lock. */
 853:../drivers/fsl_clock.c ****     while (!(MCG->S & MCG_S_LOCK0_MASK))
 1654              		.loc 1 853 0 discriminator 1
 1655 0026 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1656 0028 5206     		lsls	r2, r2, #25
 1657 002a FCD5     		bpl	.L196
 854:../drivers/fsl_clock.c ****     {
 855:../drivers/fsl_clock.c ****     }
 856:../drivers/fsl_clock.c **** }
 1658              		.loc 1 856 0
 1659 002c 7047     		bx	lr
 1660              	.L200:
 1661 002e 00BF     		.align	2
 1662              	.L199:
 1663 0030 00400640 		.word	1074151424
 1664              		.cfi_endproc
 1665              	.LFE173:
 1667              		.section	.text.CLOCK_SetOsc0MonitorMode,"ax",%progbits
 1668              		.align	1
 1669              		.global	CLOCK_SetOsc0MonitorMode
 1670              		.syntax unified
 1671              		.thumb
 1672              		.thumb_func
 1673              		.fpu fpv4-sp-d16
 1675              	CLOCK_SetOsc0MonitorMode:
 1676              	.LFB174:
 857:../drivers/fsl_clock.c **** 
 858:../drivers/fsl_clock.c **** void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode)
 859:../drivers/fsl_clock.c **** {
 1677              		.loc 1 859 0
 1678              		.cfi_startproc
 1679              		@ args = 0, pretend = 0, frame = 0
 1680              		@ frame_needed = 0, uses_anonymous_args = 0
 1681              		@ link register save eliminated.
 1682              	.LVL126:
 860:../drivers/fsl_clock.c ****     /* Clear the previous flag, MCG_SC[LOCS0]. */
 861:../drivers/fsl_clock.c ****     MCG->SC &= ~MCG_SC_ATMF_MASK;
 1683              		.loc 1 861 0
 1684 0000 0C4A     		ldr	r2, .L207
 1685 0002 137A     		ldrb	r3, [r2, #8]	@ zero_extendqisi2
 1686 0004 03F0DF03 		and	r3, r3, #223
 1687 0008 1372     		strb	r3, [r2, #8]
 1688 000a 1346     		mov	r3, r2
 862:../drivers/fsl_clock.c **** 
 863:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone == mode)
 1689              		.loc 1 863 0
 1690 000c 20B9     		cbnz	r0, .L202
 864:../drivers/fsl_clock.c ****     {
 865:../drivers/fsl_clock.c ****         MCG->C6 &= ~MCG_C6_CME0_MASK;
 1691              		.loc 1 865 0
 1692 000e 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 1693 0010 03F0DF03 		and	r3, r3, #223
 1694 0014 5371     		strb	r3, [r2, #5]
 1695 0016 7047     		bx	lr
 1696              	.L202:
 866:../drivers/fsl_clock.c ****     }
 867:../drivers/fsl_clock.c ****     else
 868:../drivers/fsl_clock.c ****     {
 869:../drivers/fsl_clock.c ****         if (kMCG_MonitorInt == mode)
 870:../drivers/fsl_clock.c ****         {
 871:../drivers/fsl_clock.c ****             MCG->C2 &= ~MCG_C2_LOCRE0_MASK;
 1697              		.loc 1 871 0
 1698 0018 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 869:../drivers/fsl_clock.c ****         {
 1699              		.loc 1 869 0
 1700 001a 0128     		cmp	r0, #1
 1701              		.loc 1 871 0
 1702 001c 0CBF     		ite	eq
 1703 001e 02F07F02 		andeq	r2, r2, #127
 872:../drivers/fsl_clock.c ****         }
 873:../drivers/fsl_clock.c ****         else
 874:../drivers/fsl_clock.c ****         {
 875:../drivers/fsl_clock.c ****             MCG->C2 |= MCG_C2_LOCRE0_MASK;
 1704              		.loc 1 875 0
 1705 0022 42F08002 		orrne	r2, r2, #128
 1706 0026 5A70     		strb	r2, [r3, #1]
 876:../drivers/fsl_clock.c ****         }
 877:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_CME0_MASK;
 1707              		.loc 1 877 0
 1708 0028 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1709 002a 42F02002 		orr	r2, r2, #32
 1710 002e 5A71     		strb	r2, [r3, #5]
 1711 0030 7047     		bx	lr
 1712              	.L208:
 1713 0032 00BF     		.align	2
 1714              	.L207:
 1715 0034 00400640 		.word	1074151424
 1716              		.cfi_endproc
 1717              	.LFE174:
 1719              		.section	.text.CLOCK_SetRtcOscMonitorMode,"ax",%progbits
 1720              		.align	1
 1721              		.global	CLOCK_SetRtcOscMonitorMode
 1722              		.syntax unified
 1723              		.thumb
 1724              		.thumb_func
 1725              		.fpu fpv4-sp-d16
 1727              	CLOCK_SetRtcOscMonitorMode:
 1728              	.LFB175:
 878:../drivers/fsl_clock.c ****     }
 879:../drivers/fsl_clock.c **** }
 880:../drivers/fsl_clock.c **** 
 881:../drivers/fsl_clock.c **** void CLOCK_SetRtcOscMonitorMode(mcg_monitor_mode_t mode)
 882:../drivers/fsl_clock.c **** {
 1729              		.loc 1 882 0
 1730              		.cfi_startproc
 1731              		@ args = 0, pretend = 0, frame = 0
 1732              		@ frame_needed = 0, uses_anonymous_args = 0
 1733              		@ link register save eliminated.
 1734              	.LVL127:
 883:../drivers/fsl_clock.c ****     uint8_t mcg_c8 = MCG->C8;
 1735              		.loc 1 883 0
 1736 0000 064A     		ldr	r2, .L215
 1737 0002 537B     		ldrb	r3, [r2, #13]	@ zero_extendqisi2
 1738              	.LVL128:
 884:../drivers/fsl_clock.c **** 
 885:../drivers/fsl_clock.c ****     mcg_c8 &= ~(MCG_C8_CME1_MASK | MCG_C8_LOCRE1_MASK);
 1739              		.loc 1 885 0
 1740 0004 03F05F03 		and	r3, r3, #95
 1741              	.LVL129:
 886:../drivers/fsl_clock.c **** 
 887:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone != mode)
 1742              		.loc 1 887 0
 1743 0008 28B1     		cbz	r0, .L210
 888:../drivers/fsl_clock.c ****     {
 889:../drivers/fsl_clock.c ****         if (kMCG_MonitorReset == mode)
 1744              		.loc 1 889 0
 1745 000a 0228     		cmp	r0, #2
 890:../drivers/fsl_clock.c ****         {
 891:../drivers/fsl_clock.c ****             mcg_c8 |= MCG_C8_LOCRE1_MASK;
 1746              		.loc 1 891 0
 1747 000c 08BF     		it	eq
 1748 000e 43F08003 		orreq	r3, r3, #128
 1749              	.LVL130:
 892:../drivers/fsl_clock.c ****         }
 893:../drivers/fsl_clock.c ****         mcg_c8 |= MCG_C8_CME1_MASK;
 1750              		.loc 1 893 0
 1751 0012 43F02003 		orr	r3, r3, #32
 1752              	.LVL131:
 1753              	.L210:
 894:../drivers/fsl_clock.c ****     }
 895:../drivers/fsl_clock.c ****     MCG->C8 = mcg_c8;
 1754              		.loc 1 895 0
 1755 0016 5373     		strb	r3, [r2, #13]
 1756 0018 7047     		bx	lr
 1757              	.L216:
 1758 001a 00BF     		.align	2
 1759              	.L215:
 1760 001c 00400640 		.word	1074151424
 1761              		.cfi_endproc
 1762              	.LFE175:
 1764              		.section	.text.CLOCK_SetPll0MonitorMode,"ax",%progbits
 1765              		.align	1
 1766              		.global	CLOCK_SetPll0MonitorMode
 1767              		.syntax unified
 1768              		.thumb
 1769              		.thumb_func
 1770              		.fpu fpv4-sp-d16
 1772              	CLOCK_SetPll0MonitorMode:
 1773              	.LFB176:
 896:../drivers/fsl_clock.c **** }
 897:../drivers/fsl_clock.c **** 
 898:../drivers/fsl_clock.c **** void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode)
 899:../drivers/fsl_clock.c **** {
 1774              		.loc 1 899 0
 1775              		.cfi_startproc
 1776              		@ args = 0, pretend = 0, frame = 0
 1777              		@ frame_needed = 0, uses_anonymous_args = 0
 1778              		@ link register save eliminated.
 1779              	.LVL132:
 900:../drivers/fsl_clock.c ****     uint8_t mcg_c8;
 901:../drivers/fsl_clock.c **** 
 902:../drivers/fsl_clock.c ****     /* Clear previous flag. */
 903:../drivers/fsl_clock.c ****     MCG->S = MCG_S_LOLS0_MASK;
 1780              		.loc 1 903 0
 1781 0000 0C4B     		ldr	r3, .L222
 1782 0002 8022     		movs	r2, #128
 1783 0004 9A71     		strb	r2, [r3, #6]
 1784 0006 1A46     		mov	r2, r3
 904:../drivers/fsl_clock.c **** 
 905:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone == mode)
 1785              		.loc 1 905 0
 1786 0008 20B9     		cbnz	r0, .L218
 906:../drivers/fsl_clock.c ****     {
 907:../drivers/fsl_clock.c ****         MCG->C6 &= ~MCG_C6_LOLIE0_MASK;
 1787              		.loc 1 907 0
 1788 000a 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1789 000c 02F07F02 		and	r2, r2, #127
 1790 0010 5A71     		strb	r2, [r3, #5]
 1791 0012 7047     		bx	lr
 1792              	.L218:
 908:../drivers/fsl_clock.c ****     }
 909:../drivers/fsl_clock.c ****     else
 910:../drivers/fsl_clock.c ****     {
 911:../drivers/fsl_clock.c ****         mcg_c8 = MCG->C8;
 1793              		.loc 1 911 0
 1794 0014 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 912:../drivers/fsl_clock.c **** 
 913:../drivers/fsl_clock.c ****         mcg_c8 &= ~MCG_C8_LOCS1_MASK;
 914:../drivers/fsl_clock.c **** 
 915:../drivers/fsl_clock.c ****         if (kMCG_MonitorInt == mode)
 1795              		.loc 1 915 0
 1796 0016 0128     		cmp	r0, #1
 911:../drivers/fsl_clock.c **** 
 1797              		.loc 1 911 0
 1798 0018 DBB2     		uxtb	r3, r3
 1799              	.LVL133:
 913:../drivers/fsl_clock.c **** 
 1800              		.loc 1 913 0
 1801 001a 16BF     		itet	ne
 1802 001c 03F0FE03 		andne	r3, r3, #254
 1803              	.LVL134:
 916:../drivers/fsl_clock.c ****         {
 917:../drivers/fsl_clock.c ****             mcg_c8 &= ~MCG_C8_LOLRE_MASK;
 1804              		.loc 1 917 0
 1805 0020 03F0BE03 		andeq	r3, r3, #190
 918:../drivers/fsl_clock.c ****         }
 919:../drivers/fsl_clock.c ****         else
 920:../drivers/fsl_clock.c ****         {
 921:../drivers/fsl_clock.c ****             mcg_c8 |= MCG_C8_LOLRE_MASK;
 1806              		.loc 1 921 0
 1807 0024 43F04003 		orrne	r3, r3, #64
 1808              	.LVL135:
 922:../drivers/fsl_clock.c ****         }
 923:../drivers/fsl_clock.c ****         MCG->C8 = mcg_c8;
 1809              		.loc 1 923 0
 1810 0028 5373     		strb	r3, [r2, #13]
 924:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_LOLIE0_MASK;
 1811              		.loc 1 924 0
 1812 002a 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 1813              	.LVL136:
 1814 002c 43F08003 		orr	r3, r3, #128
 1815 0030 5371     		strb	r3, [r2, #5]
 1816              	.LVL137:
 1817 0032 7047     		bx	lr
 1818              	.L223:
 1819              		.align	2
 1820              	.L222:
 1821 0034 00400640 		.word	1074151424
 1822              		.cfi_endproc
 1823              	.LFE176:
 1825              		.section	.text.CLOCK_GetStatusFlags,"ax",%progbits
 1826              		.align	1
 1827              		.global	CLOCK_GetStatusFlags
 1828              		.syntax unified
 1829              		.thumb
 1830              		.thumb_func
 1831              		.fpu fpv4-sp-d16
 1833              	CLOCK_GetStatusFlags:
 1834              	.LFB177:
 925:../drivers/fsl_clock.c ****     }
 926:../drivers/fsl_clock.c **** }
 927:../drivers/fsl_clock.c **** 
 928:../drivers/fsl_clock.c **** uint32_t CLOCK_GetStatusFlags(void)
 929:../drivers/fsl_clock.c **** {
 1835              		.loc 1 929 0
 1836              		.cfi_startproc
 1837              		@ args = 0, pretend = 0, frame = 0
 1838              		@ frame_needed = 0, uses_anonymous_args = 0
 1839              		@ link register save eliminated.
 1840              	.LVL138:
 930:../drivers/fsl_clock.c ****     uint32_t ret = 0U;
 931:../drivers/fsl_clock.c ****     uint8_t mcg_s = MCG->S;
 1841              		.loc 1 931 0
 1842 0000 0B4A     		ldr	r2, .L238
 1843 0002 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 932:../drivers/fsl_clock.c **** 
 933:../drivers/fsl_clock.c ****     if (MCG->SC & MCG_SC_LOCS0_MASK)
 1844              		.loc 1 933 0
 1845 0004 107A     		ldrb	r0, [r2, #8]	@ zero_extendqisi2
 934:../drivers/fsl_clock.c ****     {
 935:../drivers/fsl_clock.c ****         ret |= kMCG_Osc0LostFlag;
 936:../drivers/fsl_clock.c ****     }
 937:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_OSCINIT0_MASK)
 938:../drivers/fsl_clock.c ****     {
 939:../drivers/fsl_clock.c ****         ret |= kMCG_Osc0InitFlag;
 940:../drivers/fsl_clock.c ****     }
 941:../drivers/fsl_clock.c ****     if (MCG->C8 & MCG_C8_LOCS1_MASK)
 1846              		.loc 1 941 0
 1847 0006 527B     		ldrb	r2, [r2, #13]	@ zero_extendqisi2
 931:../drivers/fsl_clock.c **** 
 1848              		.loc 1 931 0
 1849 0008 DBB2     		uxtb	r3, r3
 1850              	.LVL139:
 930:../drivers/fsl_clock.c ****     uint8_t mcg_s = MCG->S;
 1851              		.loc 1 930 0
 1852 000a 00F00100 		and	r0, r0, #1
 1853              	.LVL140:
 937:../drivers/fsl_clock.c ****     {
 1854              		.loc 1 937 0
 1855 000e 9907     		lsls	r1, r3, #30
 939:../drivers/fsl_clock.c ****     }
 1856              		.loc 1 939 0
 1857 0010 48BF     		it	mi
 1858 0012 40F00200 		orrmi	r0, r0, #2
 1859              	.LVL141:
 1860              		.loc 1 941 0
 1861 0016 D107     		lsls	r1, r2, #31
 942:../drivers/fsl_clock.c ****     {
 943:../drivers/fsl_clock.c ****         ret |= kMCG_RtcOscLostFlag;
 1862              		.loc 1 943 0
 1863 0018 48BF     		it	mi
 1864 001a 40F01000 		orrmi	r0, r0, #16
 1865              	.LVL142:
 944:../drivers/fsl_clock.c ****     }
 945:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_LOLS0_MASK)
 1866              		.loc 1 945 0
 1867 001e 1A06     		lsls	r2, r3, #24
 946:../drivers/fsl_clock.c ****     {
 947:../drivers/fsl_clock.c ****         ret |= kMCG_Pll0LostFlag;
 1868              		.loc 1 947 0
 1869 0020 48BF     		it	mi
 1870 0022 40F02000 		orrmi	r0, r0, #32
 1871              	.LVL143:
 948:../drivers/fsl_clock.c ****     }
 949:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_LOCK0_MASK)
 1872              		.loc 1 949 0
 1873 0026 5B06     		lsls	r3, r3, #25
 1874              	.LVL144:
 950:../drivers/fsl_clock.c ****     {
 951:../drivers/fsl_clock.c ****         ret |= kMCG_Pll0LockFlag;
 1875              		.loc 1 951 0
 1876 0028 48BF     		it	mi
 1877 002a 40F04000 		orrmi	r0, r0, #64
 1878              	.LVL145:
 952:../drivers/fsl_clock.c ****     }
 953:../drivers/fsl_clock.c ****     return ret;
 954:../drivers/fsl_clock.c **** }
 1879              		.loc 1 954 0
 1880 002e 7047     		bx	lr
 1881              	.L239:
 1882              		.align	2
 1883              	.L238:
 1884 0030 00400640 		.word	1074151424
 1885              		.cfi_endproc
 1886              	.LFE177:
 1888              		.section	.text.CLOCK_ClearStatusFlags,"ax",%progbits
 1889              		.align	1
 1890              		.global	CLOCK_ClearStatusFlags
 1891              		.syntax unified
 1892              		.thumb
 1893              		.thumb_func
 1894              		.fpu fpv4-sp-d16
 1896              	CLOCK_ClearStatusFlags:
 1897              	.LFB178:
 955:../drivers/fsl_clock.c **** 
 956:../drivers/fsl_clock.c **** void CLOCK_ClearStatusFlags(uint32_t mask)
 957:../drivers/fsl_clock.c **** {
 1898              		.loc 1 957 0
 1899              		.cfi_startproc
 1900              		@ args = 0, pretend = 0, frame = 0
 1901              		@ frame_needed = 0, uses_anonymous_args = 0
 1902              		@ link register save eliminated.
 1903              	.LVL146:
 958:../drivers/fsl_clock.c ****     uint8_t reg;
 959:../drivers/fsl_clock.c **** 
 960:../drivers/fsl_clock.c ****     if (mask & kMCG_Osc0LostFlag)
 1904              		.loc 1 960 0
 1905 0000 C107     		lsls	r1, r0, #31
 961:../drivers/fsl_clock.c ****     {
 962:../drivers/fsl_clock.c ****         MCG->SC &= ~MCG_SC_ATMF_MASK;
 1906              		.loc 1 962 0
 1907 0002 41BF     		itttt	mi
 1908 0004 084A     		ldrmi	r2, .L253
 1909 0006 137A     		ldrbmi	r3, [r2, #8]	@ zero_extendqisi2
 1910 0008 03F0DF03 		andmi	r3, r3, #223
 1911 000c 1372     		strbmi	r3, [r2, #8]
 963:../drivers/fsl_clock.c ****     }
 964:../drivers/fsl_clock.c ****     if (mask & kMCG_RtcOscLostFlag)
 1912              		.loc 1 964 0
 1913 000e C206     		lsls	r2, r0, #27
 965:../drivers/fsl_clock.c ****     {
 966:../drivers/fsl_clock.c ****         reg = MCG->C8;
 1914              		.loc 1 966 0
 1915 0010 41BF     		itttt	mi
 1916 0012 054A     		ldrmi	r2, .L253
 1917 0014 537B     		ldrbmi	r3, [r2, #13]	@ zero_extendqisi2
 1918 0016 DBB2     		uxtbmi	r3, r3
 1919              	.LVL147:
 967:../drivers/fsl_clock.c ****         MCG->C8 = reg;
 1920              		.loc 1 967 0
 1921 0018 5373     		strbmi	r3, [r2, #13]
 968:../drivers/fsl_clock.c ****     }
 969:../drivers/fsl_clock.c ****     if (mask & kMCG_Pll0LostFlag)
 1922              		.loc 1 969 0
 1923 001a 8306     		lsls	r3, r0, #26
 1924              	.LVL148:
 970:../drivers/fsl_clock.c ****     {
 971:../drivers/fsl_clock.c ****         MCG->S = MCG_S_LOLS0_MASK;
 1925              		.loc 1 971 0
 1926 001c 42BF     		ittt	mi
 1927 001e 024B     		ldrmi	r3, .L253
 1928 0020 8022     		movmi	r2, #128
 1929 0022 9A71     		strbmi	r2, [r3, #6]
 1930 0024 7047     		bx	lr
 1931              	.L254:
 1932 0026 00BF     		.align	2
 1933              	.L253:
 1934 0028 00400640 		.word	1074151424
 1935              		.cfi_endproc
 1936              	.LFE178:
 1938              		.section	.text.CLOCK_InitOsc0,"ax",%progbits
 1939              		.align	1
 1940              		.global	CLOCK_InitOsc0
 1941              		.syntax unified
 1942              		.thumb
 1943              		.thumb_func
 1944              		.fpu fpv4-sp-d16
 1946              	CLOCK_InitOsc0:
 1947              	.LFB179:
 972:../drivers/fsl_clock.c ****     }
 973:../drivers/fsl_clock.c **** }
 974:../drivers/fsl_clock.c **** 
 975:../drivers/fsl_clock.c **** void CLOCK_InitOsc0(osc_config_t const *config)
 976:../drivers/fsl_clock.c **** {
 1948              		.loc 1 976 0
 1949              		.cfi_startproc
 1950              		@ args = 0, pretend = 0, frame = 0
 1951              		@ frame_needed = 0, uses_anonymous_args = 0
 1952              	.LVL149:
 977:../drivers/fsl_clock.c ****     uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
 1953              		.loc 1 977 0
 1954 0000 0368     		ldr	r3, [r0]
 1955              	.LVL150:
 1956              	.LBB76:
 1957              	.LBB77:
 347:../drivers/fsl_clock.c ****     {
 1958              		.loc 1 347 0
 1959 0002 49F69702 		movw	r2, #39063
 1960 0006 9342     		cmp	r3, r2
 1961              	.LBE77:
 1962              	.LBE76:
 976:../drivers/fsl_clock.c ****     uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
 1963              		.loc 1 976 0
 1964 0008 10B5     		push	{r4, lr}
 1965              		.cfi_def_cfa_offset 8
 1966              		.cfi_offset 4, -8
 1967              		.cfi_offset 14, -4
 1968              	.LBB80:
 1969              	.LBB78:
 347:../drivers/fsl_clock.c ****     {
 1970              		.loc 1 347 0
 1971 000a 22D9     		bls	.L259
 357:../drivers/fsl_clock.c ****     }
 1972              		.loc 1 357 0
 1973 000c 124C     		ldr	r4, .L267
 1974 000e A342     		cmp	r3, r4
 1975 0010 94BF     		ite	ls
 1976 0012 0124     		movls	r4, #1
 1977 0014 0224     		movhi	r4, #2
 1978              	.L256:
 1979              	.LVL151:
 1980              	.LBE78:
 1981              	.LBE80:
 1982              	.LBB81:
 1983              	.LBB82:
 767:../drivers/fsl_clock.h **** }
 768:../drivers/fsl_clock.h **** 
 769:../drivers/fsl_clock.h **** /*!
 770:../drivers/fsl_clock.h ****  * @brief Set CLKOUT source.
 771:../drivers/fsl_clock.h ****  *
 772:../drivers/fsl_clock.h ****  * @param src The value to set CLKOUT source.
 773:../drivers/fsl_clock.h ****  */
 774:../drivers/fsl_clock.h **** static inline void CLOCK_SetClkOutClock(uint32_t src)
 775:../drivers/fsl_clock.h **** {
 776:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_CLKOUTSEL_MASK) | SIM_SOPT2_CLKOUTSEL(src));
 777:../drivers/fsl_clock.h **** }
 778:../drivers/fsl_clock.h **** 
 779:../drivers/fsl_clock.h **** /*!
 780:../drivers/fsl_clock.h ****  * @brief Set RTC_CLKOUT source.
 781:../drivers/fsl_clock.h ****  *
 782:../drivers/fsl_clock.h ****  * @param src The value to set RTC_CLKOUT source.
 783:../drivers/fsl_clock.h ****  */
 784:../drivers/fsl_clock.h **** static inline void CLOCK_SetRtcClkOutClock(uint32_t src)
 785:../drivers/fsl_clock.h **** {
 786:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_RTCCLKOUTSEL_MASK) | SIM_SOPT2_RTCCLKOUTSEL(src));
 787:../drivers/fsl_clock.h **** }
 788:../drivers/fsl_clock.h **** 
 789:../drivers/fsl_clock.h **** /*! @brief Enable USB FS clock.
 790:../drivers/fsl_clock.h ****  *
 791:../drivers/fsl_clock.h ****  * @param src  USB FS clock source.
 792:../drivers/fsl_clock.h ****  * @param freq The frequency specified by src.
 793:../drivers/fsl_clock.h ****  * @retval true The clock is set successfully.
 794:../drivers/fsl_clock.h ****  * @retval false The clock source is invalid to get proper USB FS clock.
 795:../drivers/fsl_clock.h ****  */
 796:../drivers/fsl_clock.h **** bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq);
 797:../drivers/fsl_clock.h **** 
 798:../drivers/fsl_clock.h **** /*! @brief Disable USB FS clock.
 799:../drivers/fsl_clock.h ****  *
 800:../drivers/fsl_clock.h ****  * Disable USB FS clock.
 801:../drivers/fsl_clock.h ****  */
 802:../drivers/fsl_clock.h **** static inline void CLOCK_DisableUsbfs0Clock(void)
 803:../drivers/fsl_clock.h **** {
 804:../drivers/fsl_clock.h ****     CLOCK_DisableClock(kCLOCK_Usbfs0);
 805:../drivers/fsl_clock.h **** }
 806:../drivers/fsl_clock.h **** 
 807:../drivers/fsl_clock.h **** /*!
 808:../drivers/fsl_clock.h ****  * @brief System clock divider
 809:../drivers/fsl_clock.h ****  *
 810:../drivers/fsl_clock.h ****  * Set the SIM_CLKDIV1[OUTDIV1], SIM_CLKDIV1[OUTDIV2], SIM_CLKDIV1[OUTDIV3], SIM_CLKDIV1[OUTDIV4].
 811:../drivers/fsl_clock.h ****  *
 812:../drivers/fsl_clock.h ****  * @param outdiv1 Clock 1 output divider value.
 813:../drivers/fsl_clock.h ****  *
 814:../drivers/fsl_clock.h ****  * @param outdiv2 Clock 2 output divider value.
 815:../drivers/fsl_clock.h ****  *
 816:../drivers/fsl_clock.h ****  * @param outdiv3 Clock 3 output divider value.
 817:../drivers/fsl_clock.h ****  *
 818:../drivers/fsl_clock.h ****  * @param outdiv4 Clock 4 output divider value.
 819:../drivers/fsl_clock.h ****  */
 820:../drivers/fsl_clock.h **** static inline void CLOCK_SetOutDiv(uint32_t outdiv1, uint32_t outdiv2, uint32_t outdiv3, uint32_t o
 821:../drivers/fsl_clock.h **** {
 822:../drivers/fsl_clock.h ****     SIM->CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) | SIM_CLKDIV1_OUTDIV
 823:../drivers/fsl_clock.h ****                    SIM_CLKDIV1_OUTDIV4(outdiv4);
 824:../drivers/fsl_clock.h **** }
 825:../drivers/fsl_clock.h **** 
 826:../drivers/fsl_clock.h **** /*!
 827:../drivers/fsl_clock.h ****  * @brief Gets the clock frequency for a specific clock name.
 828:../drivers/fsl_clock.h ****  *
 829:../drivers/fsl_clock.h ****  * This function checks the current clock configurations and then calculates
 830:../drivers/fsl_clock.h ****  * the clock frequency for a specific clock name defined in clock_name_t.
 831:../drivers/fsl_clock.h ****  * The MCG must be properly configured before using this function.
 832:../drivers/fsl_clock.h ****  *
 833:../drivers/fsl_clock.h ****  * @param clockName Clock names defined in clock_name_t
 834:../drivers/fsl_clock.h ****  * @return Clock frequency value in Hertz
 835:../drivers/fsl_clock.h ****  */
 836:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFreq(clock_name_t clockName);
 837:../drivers/fsl_clock.h **** 
 838:../drivers/fsl_clock.h **** /*!
 839:../drivers/fsl_clock.h ****  * @brief Get the core clock or system clock frequency.
 840:../drivers/fsl_clock.h ****  *
 841:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 842:../drivers/fsl_clock.h ****  */
 843:../drivers/fsl_clock.h **** uint32_t CLOCK_GetCoreSysClkFreq(void);
 844:../drivers/fsl_clock.h **** 
 845:../drivers/fsl_clock.h **** /*!
 846:../drivers/fsl_clock.h ****  * @brief Get the platform clock frequency.
 847:../drivers/fsl_clock.h ****  *
 848:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 849:../drivers/fsl_clock.h ****  */
 850:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPlatClkFreq(void);
 851:../drivers/fsl_clock.h **** 
 852:../drivers/fsl_clock.h **** /*!
 853:../drivers/fsl_clock.h ****  * @brief Get the bus clock frequency.
 854:../drivers/fsl_clock.h ****  *
 855:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 856:../drivers/fsl_clock.h ****  */
 857:../drivers/fsl_clock.h **** uint32_t CLOCK_GetBusClkFreq(void);
 858:../drivers/fsl_clock.h **** 
 859:../drivers/fsl_clock.h **** /*!
 860:../drivers/fsl_clock.h ****  * @brief Get the flexbus clock frequency.
 861:../drivers/fsl_clock.h ****  *
 862:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 863:../drivers/fsl_clock.h ****  */
 864:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFlexBusClkFreq(void);
 865:../drivers/fsl_clock.h **** 
 866:../drivers/fsl_clock.h **** /*!
 867:../drivers/fsl_clock.h ****  * @brief Get the flash clock frequency.
 868:../drivers/fsl_clock.h ****  *
 869:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 870:../drivers/fsl_clock.h ****  */
 871:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFlashClkFreq(void);
 872:../drivers/fsl_clock.h **** 
 873:../drivers/fsl_clock.h **** /*!
 874:../drivers/fsl_clock.h ****  * @brief Get the output clock frequency selected by SIM[PLLFLLSEL].
 875:../drivers/fsl_clock.h ****  *
 876:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 877:../drivers/fsl_clock.h ****  */
 878:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPllFllSelClkFreq(void);
 879:../drivers/fsl_clock.h **** 
 880:../drivers/fsl_clock.h **** /*!
 881:../drivers/fsl_clock.h ****  * @brief Get the external reference 32K clock frequency (ERCLK32K).
 882:../drivers/fsl_clock.h ****  *
 883:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 884:../drivers/fsl_clock.h ****  */
 885:../drivers/fsl_clock.h **** uint32_t CLOCK_GetEr32kClkFreq(void);
 886:../drivers/fsl_clock.h **** 
 887:../drivers/fsl_clock.h **** /*!
 888:../drivers/fsl_clock.h ****  * @brief Get the OSC0 external reference clock frequency (OSC0ERCLK).
 889:../drivers/fsl_clock.h ****  *
 890:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 891:../drivers/fsl_clock.h ****  */
 892:../drivers/fsl_clock.h **** uint32_t CLOCK_GetOsc0ErClkFreq(void);
 893:../drivers/fsl_clock.h **** 
 894:../drivers/fsl_clock.h **** /*!
 895:../drivers/fsl_clock.h ****  * @brief Set the clock configure in SIM module.
 896:../drivers/fsl_clock.h ****  *
 897:../drivers/fsl_clock.h ****  * This function sets system layer clock settings in SIM module.
 898:../drivers/fsl_clock.h ****  *
 899:../drivers/fsl_clock.h ****  * @param config Pointer to the configure structure.
 900:../drivers/fsl_clock.h ****  */
 901:../drivers/fsl_clock.h **** void CLOCK_SetSimConfig(sim_clock_config_t const *config);
 902:../drivers/fsl_clock.h **** 
 903:../drivers/fsl_clock.h **** /*!
 904:../drivers/fsl_clock.h ****  * @brief Set the system clock dividers in SIM to safe value.
 905:../drivers/fsl_clock.h ****  *
 906:../drivers/fsl_clock.h ****  * The system level clocks (core clock, bus clock, flexbus clock and flash clock)
 907:../drivers/fsl_clock.h ****  * must be in allowed ranges. During MCG clock mode switch, the MCG output clock
 908:../drivers/fsl_clock.h ****  * changes then the system level clocks may be out of range. This function could
 909:../drivers/fsl_clock.h ****  * be used before MCG mode change, to make sure system level clocks are in allowed
 910:../drivers/fsl_clock.h ****  * range.
 911:../drivers/fsl_clock.h ****  *
 912:../drivers/fsl_clock.h ****  * @param config Pointer to the configure structure.
 913:../drivers/fsl_clock.h ****  */
 914:../drivers/fsl_clock.h **** static inline void CLOCK_SetSimSafeDivs(void)
 915:../drivers/fsl_clock.h **** {
 916:../drivers/fsl_clock.h ****     SIM->CLKDIV1 = 0x01240000U;
 917:../drivers/fsl_clock.h **** }
 918:../drivers/fsl_clock.h **** 
 919:../drivers/fsl_clock.h **** /*! @name MCG frequency functions. */
 920:../drivers/fsl_clock.h **** /*@{*/
 921:../drivers/fsl_clock.h **** 
 922:../drivers/fsl_clock.h **** /*!
 923:../drivers/fsl_clock.h ****  * @brief Gets the MCG output clock (MCGOUTCLK) frequency.
 924:../drivers/fsl_clock.h ****  *
 925:../drivers/fsl_clock.h ****  * This function gets the MCG output clock frequency in Hz based on the current MCG
 926:../drivers/fsl_clock.h ****  * register value.
 927:../drivers/fsl_clock.h ****  *
 928:../drivers/fsl_clock.h ****  * @return The frequency of MCGOUTCLK.
 929:../drivers/fsl_clock.h ****  */
 930:../drivers/fsl_clock.h **** uint32_t CLOCK_GetOutClkFreq(void);
 931:../drivers/fsl_clock.h **** 
 932:../drivers/fsl_clock.h **** /*!
 933:../drivers/fsl_clock.h ****  * @brief Gets the MCG FLL clock (MCGFLLCLK) frequency.
 934:../drivers/fsl_clock.h ****  *
 935:../drivers/fsl_clock.h ****  * This function gets the MCG FLL clock frequency in Hz based on the current MCG
 936:../drivers/fsl_clock.h ****  * register value. The FLL is enabled in FEI/FBI/FEE/FBE mode and
 937:../drivers/fsl_clock.h ****  * disabled in low power state in other modes.
 938:../drivers/fsl_clock.h ****  *
 939:../drivers/fsl_clock.h ****  * @return The frequency of MCGFLLCLK.
 940:../drivers/fsl_clock.h ****  */
 941:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFllFreq(void);
 942:../drivers/fsl_clock.h **** 
 943:../drivers/fsl_clock.h **** /*!
 944:../drivers/fsl_clock.h ****  * @brief Gets the MCG internal reference clock (MCGIRCLK) frequency.
 945:../drivers/fsl_clock.h ****  *
 946:../drivers/fsl_clock.h ****  * This function gets the MCG internal reference clock frequency in Hz based
 947:../drivers/fsl_clock.h ****  * on the current MCG register value.
 948:../drivers/fsl_clock.h ****  *
 949:../drivers/fsl_clock.h ****  * @return The frequency of MCGIRCLK.
 950:../drivers/fsl_clock.h ****  */
 951:../drivers/fsl_clock.h **** uint32_t CLOCK_GetInternalRefClkFreq(void);
 952:../drivers/fsl_clock.h **** 
 953:../drivers/fsl_clock.h **** /*!
 954:../drivers/fsl_clock.h ****  * @brief Gets the MCG fixed frequency clock (MCGFFCLK) frequency.
 955:../drivers/fsl_clock.h ****  *
 956:../drivers/fsl_clock.h ****  * This function gets the MCG fixed frequency clock frequency in Hz based
 957:../drivers/fsl_clock.h ****  * on the current MCG register value.
 958:../drivers/fsl_clock.h ****  *
 959:../drivers/fsl_clock.h ****  * @return The frequency of MCGFFCLK.
 960:../drivers/fsl_clock.h ****  */
 961:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFixedFreqClkFreq(void);
 962:../drivers/fsl_clock.h **** 
 963:../drivers/fsl_clock.h **** /*!
 964:../drivers/fsl_clock.h ****  * @brief Gets the MCG PLL0 clock (MCGPLL0CLK) frequency.
 965:../drivers/fsl_clock.h ****  *
 966:../drivers/fsl_clock.h ****  * This function gets the MCG PLL0 clock frequency in Hz based on the current MCG
 967:../drivers/fsl_clock.h ****  * register value.
 968:../drivers/fsl_clock.h ****  *
 969:../drivers/fsl_clock.h ****  * @return The frequency of MCGPLL0CLK.
 970:../drivers/fsl_clock.h ****  */
 971:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPll0Freq(void);
 972:../drivers/fsl_clock.h **** 
 973:../drivers/fsl_clock.h **** /*@}*/
 974:../drivers/fsl_clock.h **** 
 975:../drivers/fsl_clock.h **** /*! @name MCG clock configuration. */
 976:../drivers/fsl_clock.h **** /*@{*/
 977:../drivers/fsl_clock.h **** 
 978:../drivers/fsl_clock.h **** /*!
 979:../drivers/fsl_clock.h ****  * @brief Enables or disables the MCG low power.
 980:../drivers/fsl_clock.h ****  *
 981:../drivers/fsl_clock.h ****  * Enabling the MCG low power disables the PLL and FLL in bypass modes. In other words,
 982:../drivers/fsl_clock.h ****  * in FBE and PBE modes, enabling low power sets the MCG to BLPE mode. In FBI and
 983:../drivers/fsl_clock.h ****  * PBI modes, enabling low power sets the MCG to BLPI mode.
 984:../drivers/fsl_clock.h ****  * When disabling the MCG low power, the PLL or FLL are enabled based on MCG settings.
 985:../drivers/fsl_clock.h ****  *
 986:../drivers/fsl_clock.h ****  * @param enable True to enable MCG low power, false to disable MCG low power.
 987:../drivers/fsl_clock.h ****  */
 988:../drivers/fsl_clock.h **** static inline void CLOCK_SetLowPowerEnable(bool enable)
 989:../drivers/fsl_clock.h **** {
 990:../drivers/fsl_clock.h ****     if (enable)
 991:../drivers/fsl_clock.h ****     {
 992:../drivers/fsl_clock.h ****         MCG->C2 |= MCG_C2_LP_MASK;
 993:../drivers/fsl_clock.h ****     }
 994:../drivers/fsl_clock.h ****     else
 995:../drivers/fsl_clock.h ****     {
 996:../drivers/fsl_clock.h ****         MCG->C2 &= ~MCG_C2_LP_MASK;
 997:../drivers/fsl_clock.h ****     }
 998:../drivers/fsl_clock.h **** }
 999:../drivers/fsl_clock.h **** 
1000:../drivers/fsl_clock.h **** /*!
1001:../drivers/fsl_clock.h ****  * @brief Configures the Internal Reference clock (MCGIRCLK).
1002:../drivers/fsl_clock.h ****  *
1003:../drivers/fsl_clock.h ****  * This function sets the \c MCGIRCLK base on parameters. It also selects the IRC
1004:../drivers/fsl_clock.h ****  * source. If the fast IRC is used, this function sets the fast IRC divider.
1005:../drivers/fsl_clock.h ****  * This function also sets whether the \c MCGIRCLK is enabled in stop mode.
1006:../drivers/fsl_clock.h ****  * Calling this function in FBI/PBI/BLPI modes may change the system clock. As a result,
1007:../drivers/fsl_clock.h ****  * using the function in these modes it is not allowed.
1008:../drivers/fsl_clock.h ****  *
1009:../drivers/fsl_clock.h ****  * @param enableMode MCGIRCLK enable mode, OR'ed value of @ref _mcg_irclk_enable_mode.
1010:../drivers/fsl_clock.h ****  * @param ircs       MCGIRCLK clock source, choose fast or slow.
1011:../drivers/fsl_clock.h ****  * @param fcrdiv     Fast IRC divider setting (\c FCRDIV).
1012:../drivers/fsl_clock.h ****  * @retval kStatus_MCG_SourceUsed Because the internall reference clock is used as a clock source,
1013:../drivers/fsl_clock.h ****  * the confuration should not be changed. Otherwise, a glitch occurs.
1014:../drivers/fsl_clock.h ****  * @retval kStatus_Success MCGIRCLK configuration finished successfully.
1015:../drivers/fsl_clock.h ****  */
1016:../drivers/fsl_clock.h **** status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv);
1017:../drivers/fsl_clock.h **** 
1018:../drivers/fsl_clock.h **** /*!
1019:../drivers/fsl_clock.h ****  * @brief Selects the MCG external reference clock.
1020:../drivers/fsl_clock.h ****  *
1021:../drivers/fsl_clock.h ****  * Selects the MCG external reference clock source, changes the MCG_C7[OSCSEL],
1022:../drivers/fsl_clock.h ****  * and waits for the clock source to be stable. Because the external reference
1023:../drivers/fsl_clock.h ****  * clock should not be changed in FEE/FBE/BLPE/PBE/PEE modes, do not call this function in these mo
1024:../drivers/fsl_clock.h ****  *
1025:../drivers/fsl_clock.h ****  * @param oscsel MCG external reference clock source, MCG_C7[OSCSEL].
1026:../drivers/fsl_clock.h ****  * @retval kStatus_MCG_SourceUsed Because the external reference clock is used as a clock source,
1027:../drivers/fsl_clock.h ****  * the confuration should not be changed. Otherwise, a glitch occurs.
1028:../drivers/fsl_clock.h ****  * @retval kStatus_Success External reference clock set successfully.
1029:../drivers/fsl_clock.h ****  */
1030:../drivers/fsl_clock.h **** status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel);
1031:../drivers/fsl_clock.h **** 
1032:../drivers/fsl_clock.h **** /*!
1033:../drivers/fsl_clock.h ****  * @brief Set the FLL external reference clock divider value.
1034:../drivers/fsl_clock.h ****  *
1035:../drivers/fsl_clock.h ****  * Sets the FLL external reference clock divider value, the register MCG_C1[FRDIV].
1036:../drivers/fsl_clock.h ****  *
1037:../drivers/fsl_clock.h ****  * @param frdiv The FLL external reference clock divider value, MCG_C1[FRDIV].
1038:../drivers/fsl_clock.h ****  */
1039:../drivers/fsl_clock.h **** static inline void CLOCK_SetFllExtRefDiv(uint8_t frdiv)
1040:../drivers/fsl_clock.h **** {
1041:../drivers/fsl_clock.h ****     MCG->C1 = (MCG->C1 & ~MCG_C1_FRDIV_MASK) | MCG_C1_FRDIV(frdiv);
1042:../drivers/fsl_clock.h **** }
1043:../drivers/fsl_clock.h **** 
1044:../drivers/fsl_clock.h **** /*!
1045:../drivers/fsl_clock.h ****  * @brief Enables the PLL0 in FLL mode.
1046:../drivers/fsl_clock.h ****  *
1047:../drivers/fsl_clock.h ****  * This function sets us the PLL0 in FLL mode and reconfigures
1048:../drivers/fsl_clock.h ****  * the PLL0. Ensure that the PLL reference
1049:../drivers/fsl_clock.h ****  * clock is enabled before calling this function and that the PLL0 is not used as a clock source.
1050:../drivers/fsl_clock.h ****  * The function CLOCK_CalcPllDiv gets the correct PLL
1051:../drivers/fsl_clock.h ****  * divider values.
1052:../drivers/fsl_clock.h ****  *
1053:../drivers/fsl_clock.h ****  * @param config Pointer to the configuration structure.
1054:../drivers/fsl_clock.h ****  */
1055:../drivers/fsl_clock.h **** void CLOCK_EnablePll0(mcg_pll_config_t const *config);
1056:../drivers/fsl_clock.h **** 
1057:../drivers/fsl_clock.h **** /*!
1058:../drivers/fsl_clock.h ****  * @brief Disables the PLL0 in FLL mode.
1059:../drivers/fsl_clock.h ****  *
1060:../drivers/fsl_clock.h ****  * This function disables the PLL0 in FLL mode. It should be used together with the
1061:../drivers/fsl_clock.h ****  * @ref CLOCK_EnablePll0.
1062:../drivers/fsl_clock.h ****  */
1063:../drivers/fsl_clock.h **** static inline void CLOCK_DisablePll0(void)
1064:../drivers/fsl_clock.h **** {
1065:../drivers/fsl_clock.h ****     MCG->C5 &= ~(MCG_C5_PLLCLKEN0_MASK | MCG_C5_PLLSTEN0_MASK);
1066:../drivers/fsl_clock.h **** }
1067:../drivers/fsl_clock.h **** 
1068:../drivers/fsl_clock.h **** /*!
1069:../drivers/fsl_clock.h ****  * @brief Calculates the PLL divider setting for a desired output frequency.
1070:../drivers/fsl_clock.h ****  *
1071:../drivers/fsl_clock.h ****  * This function calculates the correct reference clock divider (\c PRDIV) and
1072:../drivers/fsl_clock.h ****  * VCO divider (\c VDIV) to generate a desired PLL output frequency. It returns the
1073:../drivers/fsl_clock.h ****  * closest frequency match with the corresponding \c PRDIV/VDIV
1074:../drivers/fsl_clock.h ****  * returned from parameters. If a desired frequency is not valid, this function
1075:../drivers/fsl_clock.h ****  * returns 0.
1076:../drivers/fsl_clock.h ****  *
1077:../drivers/fsl_clock.h ****  * @param refFreq    PLL reference clock frequency.
1078:../drivers/fsl_clock.h ****  * @param desireFreq Desired PLL output frequency.
1079:../drivers/fsl_clock.h ****  * @param prdiv      PRDIV value to generate desired PLL frequency.
1080:../drivers/fsl_clock.h ****  * @param vdiv       VDIV value to generate desired PLL frequency.
1081:../drivers/fsl_clock.h ****  * @return Closest frequency match that the PLL was able generate.
1082:../drivers/fsl_clock.h ****  */
1083:../drivers/fsl_clock.h **** uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv);
1084:../drivers/fsl_clock.h **** 
1085:../drivers/fsl_clock.h **** /*@}*/
1086:../drivers/fsl_clock.h **** 
1087:../drivers/fsl_clock.h **** /*! @name MCG clock lock monitor functions. */
1088:../drivers/fsl_clock.h **** /*@{*/
1089:../drivers/fsl_clock.h **** 
1090:../drivers/fsl_clock.h **** /*!
1091:../drivers/fsl_clock.h ****  * @brief Sets the OSC0 clock monitor mode.
1092:../drivers/fsl_clock.h ****  *
1093:../drivers/fsl_clock.h ****  * This function sets the OSC0 clock monitor mode. See @ref mcg_monitor_mode_t for details.
1094:../drivers/fsl_clock.h ****  *
1095:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
1096:../drivers/fsl_clock.h ****  */
1097:../drivers/fsl_clock.h **** void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode);
1098:../drivers/fsl_clock.h **** 
1099:../drivers/fsl_clock.h **** /*!
1100:../drivers/fsl_clock.h ****  * @brief Sets the RTC OSC clock monitor mode.
1101:../drivers/fsl_clock.h ****  *
1102:../drivers/fsl_clock.h ****  * This function sets the RTC OSC clock monitor mode. See @ref mcg_monitor_mode_t for details.
1103:../drivers/fsl_clock.h ****  *
1104:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
1105:../drivers/fsl_clock.h ****  */
1106:../drivers/fsl_clock.h **** void CLOCK_SetRtcOscMonitorMode(mcg_monitor_mode_t mode);
1107:../drivers/fsl_clock.h **** 
1108:../drivers/fsl_clock.h **** /*!
1109:../drivers/fsl_clock.h ****  * @brief Sets the PLL0 clock monitor mode.
1110:../drivers/fsl_clock.h ****  *
1111:../drivers/fsl_clock.h ****  * This function sets the PLL0 clock monitor mode. See @ref mcg_monitor_mode_t for details.
1112:../drivers/fsl_clock.h ****  *
1113:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
1114:../drivers/fsl_clock.h ****  */
1115:../drivers/fsl_clock.h **** void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode);
1116:../drivers/fsl_clock.h **** 
1117:../drivers/fsl_clock.h **** /*!
1118:../drivers/fsl_clock.h ****  * @brief Gets the MCG status flags.
1119:../drivers/fsl_clock.h ****  *
1120:../drivers/fsl_clock.h ****  * This function gets the MCG clock status flags. All status flags are
1121:../drivers/fsl_clock.h ****  * returned as a logical OR of the enumeration @ref _mcg_status_flags_t. To
1122:../drivers/fsl_clock.h ****  * check a specific flag, compare the return value with the flag.
1123:../drivers/fsl_clock.h ****  *
1124:../drivers/fsl_clock.h ****  * Example:
1125:../drivers/fsl_clock.h ****  * @code
1126:../drivers/fsl_clock.h ****    // To check the clock lost lock status of OSC0 and PLL0.
1127:../drivers/fsl_clock.h ****    uint32_t mcgFlags;
1128:../drivers/fsl_clock.h **** 
1129:../drivers/fsl_clock.h ****    mcgFlags = CLOCK_GetStatusFlags();
1130:../drivers/fsl_clock.h **** 
1131:../drivers/fsl_clock.h ****    if (mcgFlags & kMCG_Osc0LostFlag)
1132:../drivers/fsl_clock.h ****    {
1133:../drivers/fsl_clock.h ****        // OSC0 clock lock lost. Do something.
1134:../drivers/fsl_clock.h ****    }
1135:../drivers/fsl_clock.h ****    if (mcgFlags & kMCG_Pll0LostFlag)
1136:../drivers/fsl_clock.h ****    {
1137:../drivers/fsl_clock.h ****        // PLL0 clock lock lost. Do something.
1138:../drivers/fsl_clock.h ****    }
1139:../drivers/fsl_clock.h ****    @endcode
1140:../drivers/fsl_clock.h ****  *
1141:../drivers/fsl_clock.h ****  * @return  Logical OR value of the @ref _mcg_status_flags_t.
1142:../drivers/fsl_clock.h ****  */
1143:../drivers/fsl_clock.h **** uint32_t CLOCK_GetStatusFlags(void);
1144:../drivers/fsl_clock.h **** 
1145:../drivers/fsl_clock.h **** /*!
1146:../drivers/fsl_clock.h ****  * @brief Clears the MCG status flags.
1147:../drivers/fsl_clock.h ****  *
1148:../drivers/fsl_clock.h ****  * This function clears the MCG clock lock lost status. The parameter is a logical
1149:../drivers/fsl_clock.h ****  * OR value of the flags to clear. See @ref _mcg_status_flags_t.
1150:../drivers/fsl_clock.h ****  *
1151:../drivers/fsl_clock.h ****  * Example:
1152:../drivers/fsl_clock.h ****  * @code
1153:../drivers/fsl_clock.h ****    // To clear the clock lost lock status flags of OSC0 and PLL0.
1154:../drivers/fsl_clock.h **** 
1155:../drivers/fsl_clock.h ****    CLOCK_ClearStatusFlags(kMCG_Osc0LostFlag | kMCG_Pll0LostFlag);
1156:../drivers/fsl_clock.h ****    @endcode
1157:../drivers/fsl_clock.h ****  *
1158:../drivers/fsl_clock.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
1159:../drivers/fsl_clock.h ****  *             enumeration @ref _mcg_status_flags_t.
1160:../drivers/fsl_clock.h ****  */
1161:../drivers/fsl_clock.h **** void CLOCK_ClearStatusFlags(uint32_t mask);
1162:../drivers/fsl_clock.h **** 
1163:../drivers/fsl_clock.h **** /*@}*/
1164:../drivers/fsl_clock.h **** 
1165:../drivers/fsl_clock.h **** /*!
1166:../drivers/fsl_clock.h ****  * @name OSC configuration
1167:../drivers/fsl_clock.h ****  * @{
1168:../drivers/fsl_clock.h ****  */
1169:../drivers/fsl_clock.h **** 
1170:../drivers/fsl_clock.h **** /*!
1171:../drivers/fsl_clock.h ****  * @brief Configures the OSC external reference clock (OSCERCLK).
1172:../drivers/fsl_clock.h ****  *
1173:../drivers/fsl_clock.h ****  * This function configures the OSC external reference clock (OSCERCLK).
1174:../drivers/fsl_clock.h ****  * This is an example to enable the OSCERCLK in normal and stop modes and also set
1175:../drivers/fsl_clock.h ****  * the output divider to 1:
1176:../drivers/fsl_clock.h ****  *
1177:../drivers/fsl_clock.h ****    @code
1178:../drivers/fsl_clock.h ****    oscer_config_t config =
1179:../drivers/fsl_clock.h ****    {
1180:../drivers/fsl_clock.h ****        .enableMode = kOSC_ErClkEnable | kOSC_ErClkEnableInStop,
1181:../drivers/fsl_clock.h ****        .erclkDiv   = 1U,
1182:../drivers/fsl_clock.h ****    };
1183:../drivers/fsl_clock.h **** 
1184:../drivers/fsl_clock.h ****    OSC_SetExtRefClkConfig(OSC, &config);
1185:../drivers/fsl_clock.h ****    @endcode
1186:../drivers/fsl_clock.h ****  *
1187:../drivers/fsl_clock.h ****  * @param base   OSC peripheral address.
1188:../drivers/fsl_clock.h ****  * @param config Pointer to the configuration structure.
1189:../drivers/fsl_clock.h ****  */
1190:../drivers/fsl_clock.h **** static inline void OSC_SetExtRefClkConfig(OSC_Type *base, oscer_config_t const *config)
1191:../drivers/fsl_clock.h **** {
1192:../drivers/fsl_clock.h ****     uint8_t reg = base->CR;
1193:../drivers/fsl_clock.h **** 
1194:../drivers/fsl_clock.h ****     reg &= ~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK);
1195:../drivers/fsl_clock.h ****     reg |= config->enableMode;
1196:../drivers/fsl_clock.h **** 
1197:../drivers/fsl_clock.h ****     base->CR = reg;
1198:../drivers/fsl_clock.h **** }
1199:../drivers/fsl_clock.h **** 
1200:../drivers/fsl_clock.h **** /*!
1201:../drivers/fsl_clock.h ****  * @brief Sets the capacitor load configuration for the oscillator.
1202:../drivers/fsl_clock.h ****  *
1203:../drivers/fsl_clock.h ****  * This function sets the specified capacitors configuration for the oscillator.
1204:../drivers/fsl_clock.h ****  * This should be done in the early system level initialization function call
1205:../drivers/fsl_clock.h ****  * based on the system configuration.
1206:../drivers/fsl_clock.h ****  *
1207:../drivers/fsl_clock.h ****  * @param base   OSC peripheral address.
1208:../drivers/fsl_clock.h ****  * @param capLoad OR'ed value for the capacitor load option, see \ref _osc_cap_load.
1209:../drivers/fsl_clock.h ****  *
1210:../drivers/fsl_clock.h ****  * Example:
1211:../drivers/fsl_clock.h ****    @code
1212:../drivers/fsl_clock.h ****    // To enable only 2 pF and 8 pF capacitor load, please use like this.
1213:../drivers/fsl_clock.h ****    OSC_SetCapLoad(OSC, kOSC_Cap2P | kOSC_Cap8P);
1214:../drivers/fsl_clock.h ****    @endcode
1215:../drivers/fsl_clock.h ****  */
1216:../drivers/fsl_clock.h **** static inline void OSC_SetCapLoad(OSC_Type *base, uint8_t capLoad)
1217:../drivers/fsl_clock.h **** {
1218:../drivers/fsl_clock.h ****     uint8_t reg = base->CR;
 1984              		.loc 2 1218 0
 1985 0016 1149     		ldr	r1, .L267+4
1219:../drivers/fsl_clock.h **** 
1220:../drivers/fsl_clock.h ****     reg &= ~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK);
1221:../drivers/fsl_clock.h ****     reg |= capLoad;
 1986              		.loc 2 1221 0
 1987 0018 0279     		ldrb	r2, [r0, #4]	@ zero_extendqisi2
1218:../drivers/fsl_clock.h **** 
 1988              		.loc 2 1218 0
 1989 001a 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1990              	.LVL152:
1220:../drivers/fsl_clock.h ****     reg |= capLoad;
 1991              		.loc 2 1220 0
 1992 001c 03F0F003 		and	r3, r3, #240
 1993              	.LVL153:
 1994              		.loc 2 1221 0
 1995 0020 1343     		orrs	r3, r3, r2
 1996              	.LVL154:
1222:../drivers/fsl_clock.h **** 
1223:../drivers/fsl_clock.h ****     base->CR = reg;
 1997              		.loc 2 1223 0
 1998 0022 0B70     		strb	r3, [r1]
 1999              	.LVL155:
 2000              	.LBE82:
 2001              	.LBE81:
 2002              	.LBB83:
 2003              	.LBB84:
1192:../drivers/fsl_clock.h **** 
 2004              		.loc 2 1192 0
 2005 0024 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 2006              	.LVL156:
1195:../drivers/fsl_clock.h **** 
 2007              		.loc 2 1195 0
 2008 0026 8279     		ldrb	r2, [r0, #6]	@ zero_extendqisi2
1194:../drivers/fsl_clock.h ****     reg |= config->enableMode;
 2009              		.loc 2 1194 0
 2010 0028 03F05F03 		and	r3, r3, #95
 2011              	.LVL157:
1195:../drivers/fsl_clock.h **** 
 2012              		.loc 2 1195 0
 2013 002c 1343     		orrs	r3, r3, r2
 2014              	.LVL158:
 2015              	.LBE84:
 2016              	.LBE83:
 978:../drivers/fsl_clock.c **** 
 979:../drivers/fsl_clock.c ****     OSC_SetCapLoad(OSC0, config->capLoad);
 980:../drivers/fsl_clock.c ****     OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
 981:../drivers/fsl_clock.c **** 
 982:../drivers/fsl_clock.c ****     MCG->C2 = ((MCG->C2 & ~OSC_MODE_MASK) | MCG_C2_RANGE(range) | (uint8_t)config->workMode);
 2017              		.loc 1 982 0
 2018 002e 0C4A     		ldr	r2, .L267+8
 2019              	.LBB86:
 2020              	.LBB85:
1197:../drivers/fsl_clock.h **** }
 2021              		.loc 2 1197 0
 2022 0030 0B70     		strb	r3, [r1]
 2023              	.LVL159:
 2024              	.LBE85:
 2025              	.LBE86:
 2026              		.loc 1 982 0
 2027 0032 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 2028 0034 4079     		ldrb	r0, [r0, #5]	@ zero_extendqisi2
 2029              	.LVL160:
 2030 0036 03F0C303 		and	r3, r3, #195
 2031 003a 0343     		orrs	r3, r3, r0
 2032 003c 43EA0413 		orr	r3, r3, r4, lsl #4
 2033 0040 5370     		strb	r3, [r2, #1]
 983:../drivers/fsl_clock.c **** 
 984:../drivers/fsl_clock.c ****     if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
 2034              		.loc 1 984 0
 2035 0042 28B1     		cbz	r0, .L255
 2036              		.loc 1 984 0 is_stmt 0 discriminator 1
 2037 0044 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 2038 0046 1906     		lsls	r1, r3, #24
 2039 0048 02D5     		bpl	.L255
 2040              	.L264:
 985:../drivers/fsl_clock.c ****     {
 986:../drivers/fsl_clock.c ****         /* Wait for stable. */
 987:../drivers/fsl_clock.c ****         while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 2041              		.loc 1 987 0 is_stmt 1 discriminator 1
 2042 004a 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 2043 004c 9B07     		lsls	r3, r3, #30
 2044 004e FCD5     		bpl	.L264
 2045              	.L255:
 2046 0050 10BD     		pop	{r4, pc}
 2047              	.LVL161:
 2048              	.L259:
 2049              	.LBB87:
 2050              	.LBB79:
 349:../drivers/fsl_clock.c ****     }
 2051              		.loc 1 349 0
 2052 0052 0024     		movs	r4, #0
 2053 0054 DFE7     		b	.L256
 2054              	.L268:
 2055 0056 00BF     		.align	2
 2056              	.L267:
 2057 0058 00127A00 		.word	8000000
 2058 005c 00500640 		.word	1074155520
 2059 0060 00400640 		.word	1074151424
 2060              	.LBE79:
 2061              	.LBE87:
 2062              		.cfi_endproc
 2063              	.LFE179:
 2065              		.section	.text.CLOCK_DeinitOsc0,"ax",%progbits
 2066              		.align	1
 2067              		.global	CLOCK_DeinitOsc0
 2068              		.syntax unified
 2069              		.thumb
 2070              		.thumb_func
 2071              		.fpu fpv4-sp-d16
 2073              	CLOCK_DeinitOsc0:
 2074              	.LFB180:
 988:../drivers/fsl_clock.c ****         {
 989:../drivers/fsl_clock.c ****         }
 990:../drivers/fsl_clock.c ****     }
 991:../drivers/fsl_clock.c **** }
 992:../drivers/fsl_clock.c **** 
 993:../drivers/fsl_clock.c **** void CLOCK_DeinitOsc0(void)
 994:../drivers/fsl_clock.c **** {
 2075              		.loc 1 994 0
 2076              		.cfi_startproc
 2077              		@ args = 0, pretend = 0, frame = 0
 2078              		@ frame_needed = 0, uses_anonymous_args = 0
 2079              		@ link register save eliminated.
 995:../drivers/fsl_clock.c ****     OSC0->CR = 0U;
 2080              		.loc 1 995 0
 2081 0000 044B     		ldr	r3, .L270
 2082 0002 0022     		movs	r2, #0
 2083 0004 1A70     		strb	r2, [r3]
 996:../drivers/fsl_clock.c ****     MCG->C2 &= ~OSC_MODE_MASK;
 2084              		.loc 1 996 0
 2085 0006 044A     		ldr	r2, .L270+4
 2086 0008 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 2087 000a 03F0C303 		and	r3, r3, #195
 2088 000e 5370     		strb	r3, [r2, #1]
 2089 0010 7047     		bx	lr
 2090              	.L271:
 2091 0012 00BF     		.align	2
 2092              	.L270:
 2093 0014 00500640 		.word	1074155520
 2094 0018 00400640 		.word	1074151424
 2095              		.cfi_endproc
 2096              	.LFE180:
 2098              		.section	.text.CLOCK_TrimInternalRefClk,"ax",%progbits
 2099              		.align	1
 2100              		.global	CLOCK_TrimInternalRefClk
 2101              		.syntax unified
 2102              		.thumb
 2103              		.thumb_func
 2104              		.fpu fpv4-sp-d16
 2106              	CLOCK_TrimInternalRefClk:
 2107              	.LFB181:
 997:../drivers/fsl_clock.c **** }
 998:../drivers/fsl_clock.c **** 
 999:../drivers/fsl_clock.c **** status_t CLOCK_TrimInternalRefClk(uint32_t extFreq, uint32_t desireFreq, uint32_t *actualFreq, mcg_
1000:../drivers/fsl_clock.c **** {
 2108              		.loc 1 1000 0
 2109              		.cfi_startproc
 2110              		@ args = 0, pretend = 0, frame = 0
 2111              		@ frame_needed = 0, uses_anonymous_args = 0
 2112              	.LVL162:
 2113 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2114              		.cfi_def_cfa_offset 20
 2115              		.cfi_offset 4, -20
 2116              		.cfi_offset 5, -16
 2117              		.cfi_offset 6, -12
 2118              		.cfi_offset 7, -8
 2119              		.cfi_offset 14, -4
 2120              		.loc 1 1000 0
 2121 0002 0646     		mov	r6, r0
1001:../drivers/fsl_clock.c ****     uint32_t multi; /* extFreq / desireFreq */
1002:../drivers/fsl_clock.c ****     uint32_t actv;  /* Auto trim value. */
1003:../drivers/fsl_clock.c ****     uint8_t mcg_sc;
1004:../drivers/fsl_clock.c **** 
1005:../drivers/fsl_clock.c ****     static const uint32_t trimRange[2][2] = {
1006:../drivers/fsl_clock.c ****         /*     Min           Max      */
1007:../drivers/fsl_clock.c ****         {TRIM_SIRC_MIN, TRIM_SIRC_MAX}, /* Slow IRC. */
1008:../drivers/fsl_clock.c ****         {TRIM_FIRC_MIN, TRIM_FIRC_MAX}  /* Fast IRC. */
1009:../drivers/fsl_clock.c ****     };
1010:../drivers/fsl_clock.c **** 
1011:../drivers/fsl_clock.c ****     if ((extFreq > TRIM_REF_CLK_MAX) || (extFreq < TRIM_REF_CLK_MIN))
 2122              		.loc 1 1011 0
 2123 0004 254C     		ldr	r4, .L284
 2124 0006 A0F5F400 		sub	r0, r0, #7995392
 2125              	.LVL163:
 2126 000a A0F59050 		sub	r0, r0, #4608
 2127 000e A042     		cmp	r0, r4
 2128 0010 3AD8     		bhi	.L278
1012:../drivers/fsl_clock.c ****     {
1013:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmBusClockInvalid;
1014:../drivers/fsl_clock.c ****     }
1015:../drivers/fsl_clock.c **** 
1016:../drivers/fsl_clock.c ****     /* Check desired frequency range. */
1017:../drivers/fsl_clock.c ****     if ((desireFreq < trimRange[atms][0]) || (desireFreq > trimRange[atms][1]))
 2129              		.loc 1 1017 0
 2130 0012 234C     		ldr	r4, .L284+4
 2131 0014 54F83300 		ldr	r0, [r4, r3, lsl #3]
 2132 0018 8842     		cmp	r0, r1
 2133 001a 38D8     		bhi	.L280
 2134              		.loc 1 1017 0 is_stmt 0 discriminator 1
 2135 001c 04EBC304 		add	r4, r4, r3, lsl #3
 2136 0020 6068     		ldr	r0, [r4, #4]
 2137 0022 8142     		cmp	r1, r0
 2138 0024 33D8     		bhi	.L280
1018:../drivers/fsl_clock.c ****     {
1019:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmDesiredFreqInvalid;
1020:../drivers/fsl_clock.c ****     }
1021:../drivers/fsl_clock.c **** 
1022:../drivers/fsl_clock.c ****     /*
1023:../drivers/fsl_clock.c ****        Make sure internal reference clock is not used to generate bus clock.
1024:../drivers/fsl_clock.c ****        Here only need to check (MCG_S_IREFST == 1).
1025:../drivers/fsl_clock.c ****      */
1026:../drivers/fsl_clock.c ****     if (MCG_S_IREFST(kMCG_FllSrcInternal) == (MCG->S & MCG_S_IREFST_MASK))
 2139              		.loc 1 1026 0 is_stmt 1
 2140 0026 1F4F     		ldr	r7, .L284+8
 2141 0028 B879     		ldrb	r0, [r7, #6]	@ zero_extendqisi2
 2142 002a C406     		lsls	r4, r0, #27
 2143 002c 32D4     		bmi	.L281
1027:../drivers/fsl_clock.c ****     {
1028:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmIrcUsed;
1029:../drivers/fsl_clock.c ****     }
1030:../drivers/fsl_clock.c **** 
1031:../drivers/fsl_clock.c ****     multi = extFreq / desireFreq;
 2144              		.loc 1 1031 0
 2145 002e B6FBF1F1 		udiv	r1, r6, r1
 2146              	.LVL164:
1032:../drivers/fsl_clock.c ****     actv = multi * 21U;
 2147              		.loc 1 1032 0
 2148 0032 1524     		movs	r4, #21
 2149 0034 4C43     		muls	r4, r1, r4
 2150              	.LVL165:
1033:../drivers/fsl_clock.c **** 
1034:../drivers/fsl_clock.c ****     if (kMCG_AtmSel4m == atms)
 2151              		.loc 1 1034 0
 2152 0036 012B     		cmp	r3, #1
1035:../drivers/fsl_clock.c ****     {
1036:../drivers/fsl_clock.c ****         actv *= 128U;
 2153              		.loc 1 1036 0
 2154 0038 08BF     		it	eq
 2155 003a E401     		lsleq	r4, r4, #7
 2156              	.LVL166:
1037:../drivers/fsl_clock.c ****     }
1038:../drivers/fsl_clock.c **** 
1039:../drivers/fsl_clock.c ****     /* Now begin to start trim. */
1040:../drivers/fsl_clock.c ****     MCG->ATCVL = (uint8_t)actv;
 2157              		.loc 1 1040 0
 2158 003c E0B2     		uxtb	r0, r4
1041:../drivers/fsl_clock.c ****     MCG->ATCVH = (uint8_t)(actv >> 8U);
 2159              		.loc 1 1041 0
 2160 003e C4F30724 		ubfx	r4, r4, #8, #8
 2161              	.LVL167:
1040:../drivers/fsl_clock.c ****     MCG->ATCVH = (uint8_t)(actv >> 8U);
 2162              		.loc 1 1040 0
 2163 0042 F872     		strb	r0, [r7, #11]
 2164              		.loc 1 1041 0
 2165 0044 BC72     		strb	r4, [r7, #10]
1042:../drivers/fsl_clock.c **** 
1043:../drivers/fsl_clock.c ****     mcg_sc = MCG->SC;
 2166              		.loc 1 1043 0
 2167 0046 387A     		ldrb	r0, [r7, #8]	@ zero_extendqisi2
 2168              	.LVL168:
1044:../drivers/fsl_clock.c ****     mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
1045:../drivers/fsl_clock.c ****     mcg_sc |= (MCG_SC_ATMF_MASK | MCG_SC_ATMS(atms));
 2169              		.loc 1 1045 0
 2170 0048 9D01     		lsls	r5, r3, #6
1044:../drivers/fsl_clock.c ****     mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
 2171              		.loc 1 1044 0
 2172 004a 00F0BE00 		and	r0, r0, #190
 2173              	.LVL169:
 2174              		.loc 1 1045 0
 2175 004e 05F04005 		and	r5, r5, #64
 2176 0052 0543     		orrs	r5, r5, r0
 2177              	.LVL170:
1046:../drivers/fsl_clock.c ****     MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
 2178              		.loc 1 1046 0
 2179 0054 45F0A000 		orr	r0, r5, #160
 2180 0058 3872     		strb	r0, [r7, #8]
1047:../drivers/fsl_clock.c **** 
1048:../drivers/fsl_clock.c ****     /* Wait for finished. */
1049:../drivers/fsl_clock.c ****     while (MCG->SC & MCG_SC_ATME_MASK)
 2181              		.loc 1 1049 0
 2182 005a 124F     		ldr	r7, .L284+8
 2183              	.LVL171:
 2184              	.L275:
 2185              		.loc 1 1049 0 is_stmt 0 discriminator 1
 2186 005c 387A     		ldrb	r0, [r7, #8]	@ zero_extendqisi2
 2187 005e 0006     		lsls	r0, r0, #24
 2188 0060 FCD4     		bmi	.L275
1050:../drivers/fsl_clock.c ****     {
1051:../drivers/fsl_clock.c ****     }
1052:../drivers/fsl_clock.c **** 
1053:../drivers/fsl_clock.c ****     /* Error occurs? */
1054:../drivers/fsl_clock.c ****     if (MCG->SC & MCG_SC_ATMF_MASK)
 2189              		.loc 1 1054 0 is_stmt 1
 2190 0062 3C7A     		ldrb	r4, [r7, #8]	@ zero_extendqisi2
 2191 0064 14F02000 		ands	r0, r4, #32
 2192 0068 05D0     		beq	.L276
1045:../drivers/fsl_clock.c ****     MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
 2193              		.loc 1 1045 0
 2194 006a 45F02005 		orr	r5, r5, #32
 2195              	.LVL172:
1055:../drivers/fsl_clock.c ****     {
1056:../drivers/fsl_clock.c ****         /* Clear the failed flag. */
1057:../drivers/fsl_clock.c ****         MCG->SC = mcg_sc;
 2196              		.loc 1 1057 0
 2197 006e 3D72     		strb	r5, [r7, #8]
1058:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmHardwareFail;
 2198              		.loc 1 1058 0
 2199 0070 40F2D570 		movw	r0, #2005
 2200 0074 F0BD     		pop	{r4, r5, r6, r7, pc}
 2201              	.LVL173:
 2202              	.L276:
1059:../drivers/fsl_clock.c ****     }
1060:../drivers/fsl_clock.c **** 
1061:../drivers/fsl_clock.c ****     *actualFreq = extFreq / multi;
1062:../drivers/fsl_clock.c **** 
1063:../drivers/fsl_clock.c ****     if (kMCG_AtmSel4m == atms)
 2203              		.loc 1 1063 0
 2204 0076 012B     		cmp	r3, #1
1064:../drivers/fsl_clock.c ****     {
1065:../drivers/fsl_clock.c ****         s_fastIrcFreq = *actualFreq;
 2205              		.loc 1 1065 0
 2206 0078 0CBF     		ite	eq
 2207 007a 0B4B     		ldreq	r3, .L284+12
 2208              	.LVL174:
1066:../drivers/fsl_clock.c ****     }
1067:../drivers/fsl_clock.c ****     else
1068:../drivers/fsl_clock.c ****     {
1069:../drivers/fsl_clock.c ****         s_slowIrcFreq = *actualFreq;
 2209              		.loc 1 1069 0
 2210 007c 0B4B     		ldrne	r3, .L284+16
1061:../drivers/fsl_clock.c **** 
 2211              		.loc 1 1061 0
 2212 007e B6FBF1F6 		udiv	r6, r6, r1
 2213              	.LVL175:
 2214 0082 1660     		str	r6, [r2]
 2215              		.loc 1 1069 0
 2216 0084 1E60     		str	r6, [r3]
 2217 0086 F0BD     		pop	{r4, r5, r6, r7, pc}
 2218              	.LVL176:
 2219              	.L278:
1013:../drivers/fsl_clock.c ****     }
 2220              		.loc 1 1013 0
 2221 0088 40F2D270 		movw	r0, #2002
 2222 008c F0BD     		pop	{r4, r5, r6, r7, pc}
 2223              	.LVL177:
 2224              	.L280:
1019:../drivers/fsl_clock.c ****     }
 2225              		.loc 1 1019 0
 2226 008e 40F2D370 		movw	r0, #2003
 2227 0092 F0BD     		pop	{r4, r5, r6, r7, pc}
 2228              	.LVL178:
 2229              	.L281:
1028:../drivers/fsl_clock.c ****     }
 2230              		.loc 1 1028 0
 2231 0094 40F2D470 		movw	r0, #2004
1070:../drivers/fsl_clock.c ****     }
1071:../drivers/fsl_clock.c **** 
1072:../drivers/fsl_clock.c ****     return kStatus_Success;
1073:../drivers/fsl_clock.c **** }
 2232              		.loc 1 1073 0
 2233 0098 F0BD     		pop	{r4, r5, r6, r7, pc}
 2234              	.LVL179:
 2235              	.L285:
 2236 009a 00BF     		.align	2
 2237              	.L284:
 2238 009c 00127A00 		.word	8000000
 2239 00a0 00000000 		.word	.LANCHOR3
 2240 00a4 00400640 		.word	1074151424
 2241 00a8 00000000 		.word	.LANCHOR1
 2242 00ac 00000000 		.word	.LANCHOR0
 2243              		.cfi_endproc
 2244              	.LFE181:
 2246              		.section	.text.CLOCK_GetMode,"ax",%progbits
 2247              		.align	1
 2248              		.global	CLOCK_GetMode
 2249              		.syntax unified
 2250              		.thumb
 2251              		.thumb_func
 2252              		.fpu fpv4-sp-d16
 2254              	CLOCK_GetMode:
 2255              	.LFB182:
1074:../drivers/fsl_clock.c **** 
1075:../drivers/fsl_clock.c **** mcg_mode_t CLOCK_GetMode(void)
1076:../drivers/fsl_clock.c **** {
 2256              		.loc 1 1076 0
 2257              		.cfi_startproc
 2258              		@ args = 0, pretend = 0, frame = 0
 2259              		@ frame_needed = 0, uses_anonymous_args = 0
 2260              		@ link register save eliminated.
 2261              	.LVL180:
1077:../drivers/fsl_clock.c ****     mcg_mode_t mode = kMCG_ModeError;
1078:../drivers/fsl_clock.c ****     uint32_t clkst = MCG_S_CLKST_VAL;
 2262              		.loc 1 1078 0
 2263 0000 1349     		ldr	r1, .L296
 2264 0002 8B79     		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 2265              	.LVL181:
1079:../drivers/fsl_clock.c ****     uint32_t irefst = MCG_S_IREFST_VAL;
 2266              		.loc 1 1079 0
 2267 0004 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
1080:../drivers/fsl_clock.c ****     uint32_t lp = MCG_C2_LP_VAL;
 2268              		.loc 1 1080 0
 2269 0006 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
1081:../drivers/fsl_clock.c ****     uint32_t pllst = MCG_S_PLLST_VAL;
 2270              		.loc 1 1081 0
 2271 0008 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
1078:../drivers/fsl_clock.c ****     uint32_t irefst = MCG_S_IREFST_VAL;
 2272              		.loc 1 1078 0
 2273 000a C3F38103 		ubfx	r3, r3, #2, #2
 2274              	.LVL182:
1082:../drivers/fsl_clock.c **** 
1083:../drivers/fsl_clock.c ****     /*------------------------------------------------------------------
1084:../drivers/fsl_clock.c ****                            Mode and Registers
1085:../drivers/fsl_clock.c ****     ____________________________________________________________________
1086:../drivers/fsl_clock.c **** 
1087:../drivers/fsl_clock.c ****       Mode   |   CLKST    |   IREFST   |   PLLST   |      LP
1088:../drivers/fsl_clock.c ****     ____________________________________________________________________
1089:../drivers/fsl_clock.c **** 
1090:../drivers/fsl_clock.c ****       FEI    |  00(FLL)   |   1(INT)   |   0(FLL)  |      X
1091:../drivers/fsl_clock.c ****     ____________________________________________________________________
1092:../drivers/fsl_clock.c **** 
1093:../drivers/fsl_clock.c ****       FEE    |  00(FLL)   |   0(EXT)   |   0(FLL)  |      X
1094:../drivers/fsl_clock.c ****     ____________________________________________________________________
1095:../drivers/fsl_clock.c **** 
1096:../drivers/fsl_clock.c ****       FBE    |  10(EXT)   |   0(EXT)   |   0(FLL)  |   0(NORMAL)
1097:../drivers/fsl_clock.c ****     ____________________________________________________________________
1098:../drivers/fsl_clock.c **** 
1099:../drivers/fsl_clock.c ****       FBI    |  01(INT)   |   1(INT)   |   0(FLL)  |   0(NORMAL)
1100:../drivers/fsl_clock.c ****     ____________________________________________________________________
1101:../drivers/fsl_clock.c **** 
1102:../drivers/fsl_clock.c ****       BLPI   |  01(INT)   |   1(INT)   |   0(FLL)  |   1(LOW POWER)
1103:../drivers/fsl_clock.c ****     ____________________________________________________________________
1104:../drivers/fsl_clock.c **** 
1105:../drivers/fsl_clock.c ****       BLPE   |  10(EXT)   |   0(EXT)   |     X     |   1(LOW POWER)
1106:../drivers/fsl_clock.c ****     ____________________________________________________________________
1107:../drivers/fsl_clock.c **** 
1108:../drivers/fsl_clock.c ****       PEE    |  11(PLL)   |   0(EXT)   |   1(PLL)  |      X
1109:../drivers/fsl_clock.c ****     ____________________________________________________________________
1110:../drivers/fsl_clock.c **** 
1111:../drivers/fsl_clock.c ****       PBE    |  10(EXT)   |   0(EXT)   |   1(PLL)  |   O(NORMAL)
1112:../drivers/fsl_clock.c ****     ____________________________________________________________________
1113:../drivers/fsl_clock.c **** 
1114:../drivers/fsl_clock.c ****       PBI    |  01(INT)   |   1(INT)   |   1(PLL)  |   0(NORMAL)
1115:../drivers/fsl_clock.c ****     ____________________________________________________________________
1116:../drivers/fsl_clock.c **** 
1117:../drivers/fsl_clock.c ****       PEI    |  11(PLL)   |   1(INT)   |   1(PLL)  |      X
1118:../drivers/fsl_clock.c ****     ____________________________________________________________________
1119:../drivers/fsl_clock.c **** 
1120:../drivers/fsl_clock.c ****     ----------------------------------------------------------------------*/
1121:../drivers/fsl_clock.c **** 
1122:../drivers/fsl_clock.c ****     switch (clkst)
 2275              		.loc 1 1122 0
 2276 000e 022B     		cmp	r3, #2
1079:../drivers/fsl_clock.c ****     uint32_t lp = MCG_C2_LP_VAL;
 2277              		.loc 1 1079 0
 2278 0010 C0B2     		uxtb	r0, r0
 2279              	.LVL183:
1080:../drivers/fsl_clock.c ****     uint32_t pllst = MCG_S_PLLST_VAL;
 2280              		.loc 1 1080 0
 2281 0012 C2F34002 		ubfx	r2, r2, #1, #1
 2282              	.LVL184:
1081:../drivers/fsl_clock.c **** 
 2283              		.loc 1 1081 0
 2284 0016 C9B2     		uxtb	r1, r1
 2285              	.LVL185:
 2286              		.loc 1 1122 0
 2287 0018 0ED0     		beq	.L288
 2288 001a 032B     		cmp	r3, #3
 2289 001c 13D0     		beq	.L291
 2290 001e 012B     		cmp	r3, #1
 2291 0020 05D0     		beq	.L290
1123:../drivers/fsl_clock.c ****     {
1124:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatFll:
1125:../drivers/fsl_clock.c ****             if (kMCG_FllSrcExternal == irefst)
 2292              		.loc 1 1125 0
 2293 0022 10F0100F 		tst	r0, #16
1126:../drivers/fsl_clock.c ****             {
1127:../drivers/fsl_clock.c ****                 mode = kMCG_ModeFEE;
1128:../drivers/fsl_clock.c ****             }
1129:../drivers/fsl_clock.c ****             else
1130:../drivers/fsl_clock.c ****             {
1131:../drivers/fsl_clock.c ****                 mode = kMCG_ModeFEI;
 2294              		.loc 1 1131 0
 2295 0026 0CBF     		ite	eq
 2296 0028 0320     		moveq	r0, #3
 2297              	.LVL186:
 2298 002a 0020     		movne	r0, #0
 2299 002c 7047     		bx	lr
 2300              	.LVL187:
 2301              	.L290:
1132:../drivers/fsl_clock.c ****             }
1133:../drivers/fsl_clock.c ****             break;
1134:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
1135:../drivers/fsl_clock.c ****             if (lp)
 2302              		.loc 1 1135 0
 2303 002e 002A     		cmp	r2, #0
1136:../drivers/fsl_clock.c ****             {
1137:../drivers/fsl_clock.c ****                 mode = kMCG_ModeBLPI;
1138:../drivers/fsl_clock.c ****             }
1139:../drivers/fsl_clock.c ****             else
1140:../drivers/fsl_clock.c ****             {
1141:../drivers/fsl_clock.c ****                 {
1142:../drivers/fsl_clock.c ****                     mode = kMCG_ModeFBI;
 2304              		.loc 1 1142 0
 2305 0030 14BF     		ite	ne
 2306 0032 0220     		movne	r0, #2
 2307              	.LVL188:
 2308 0034 0120     		moveq	r0, #1
 2309 0036 7047     		bx	lr
 2310              	.LVL189:
 2311              	.L288:
1143:../drivers/fsl_clock.c ****                 }
1144:../drivers/fsl_clock.c ****             }
1145:../drivers/fsl_clock.c ****             break;
1146:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
1147:../drivers/fsl_clock.c ****             if (lp)
 2312              		.loc 1 1147 0
 2313 0038 3AB9     		cbnz	r2, .L294
1148:../drivers/fsl_clock.c ****             {
1149:../drivers/fsl_clock.c ****                 mode = kMCG_ModeBLPE;
1150:../drivers/fsl_clock.c ****             }
1151:../drivers/fsl_clock.c ****             else
1152:../drivers/fsl_clock.c ****             {
1153:../drivers/fsl_clock.c ****                 if (kMCG_PllstPll == pllst)
 2314              		.loc 1 1153 0
 2315 003a 11F0200F 		tst	r1, #32
1154:../drivers/fsl_clock.c ****                 {
1155:../drivers/fsl_clock.c ****                     mode = kMCG_ModePBE;
1156:../drivers/fsl_clock.c ****                 }
1157:../drivers/fsl_clock.c ****                 else
1158:../drivers/fsl_clock.c ****                 {
1159:../drivers/fsl_clock.c ****                     mode = kMCG_ModeFBE;
 2316              		.loc 1 1159 0
 2317 003e 14BF     		ite	ne
 2318 0040 0620     		movne	r0, #6
 2319              	.LVL190:
 2320 0042 0420     		moveq	r0, #4
 2321 0044 7047     		bx	lr
 2322              	.LVL191:
 2323              	.L291:
1160:../drivers/fsl_clock.c ****                 }
1161:../drivers/fsl_clock.c ****             }
1162:../drivers/fsl_clock.c ****             break;
1163:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
1164:../drivers/fsl_clock.c ****         {
1165:../drivers/fsl_clock.c ****             mode = kMCG_ModePEE;
 2324              		.loc 1 1165 0
 2325 0046 0720     		movs	r0, #7
 2326              	.LVL192:
 2327 0048 7047     		bx	lr
 2328              	.LVL193:
 2329              	.L294:
1149:../drivers/fsl_clock.c ****             }
 2330              		.loc 1 1149 0
 2331 004a 0520     		movs	r0, #5
 2332              	.LVL194:
1166:../drivers/fsl_clock.c ****         }
1167:../drivers/fsl_clock.c ****         break;
1168:../drivers/fsl_clock.c ****         default:
1169:../drivers/fsl_clock.c ****             break;
1170:../drivers/fsl_clock.c ****     }
1171:../drivers/fsl_clock.c **** 
1172:../drivers/fsl_clock.c ****     return mode;
1173:../drivers/fsl_clock.c **** }
 2333              		.loc 1 1173 0
 2334 004c 7047     		bx	lr
 2335              	.L297:
 2336 004e 00BF     		.align	2
 2337              	.L296:
 2338 0050 00400640 		.word	1074151424
 2339              		.cfi_endproc
 2340              	.LFE182:
 2342              		.section	.text.CLOCK_SetFeiMode,"ax",%progbits
 2343              		.align	1
 2344              		.global	CLOCK_SetFeiMode
 2345              		.syntax unified
 2346              		.thumb
 2347              		.thumb_func
 2348              		.fpu fpv4-sp-d16
 2350              	CLOCK_SetFeiMode:
 2351              	.LFB183:
1174:../drivers/fsl_clock.c **** 
1175:../drivers/fsl_clock.c **** status_t CLOCK_SetFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1176:../drivers/fsl_clock.c **** {
 2352              		.loc 1 1176 0
 2353              		.cfi_startproc
 2354              		@ args = 0, pretend = 0, frame = 0
 2355              		@ frame_needed = 0, uses_anonymous_args = 0
 2356              	.LVL195:
 2357 0000 70B5     		push	{r4, r5, r6, lr}
 2358              		.cfi_def_cfa_offset 16
 2359              		.cfi_offset 4, -16
 2360              		.cfi_offset 5, -12
 2361              		.cfi_offset 6, -8
 2362              		.cfi_offset 14, -4
1177:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1178:../drivers/fsl_clock.c ****     bool change_drs = false;
1179:../drivers/fsl_clock.c **** 
1180:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1181:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1182:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEI == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1183:../drivers/fsl_clock.c ****     {
1184:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1185:../drivers/fsl_clock.c ****     }
1186:../drivers/fsl_clock.c **** #endif
1187:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2363              		.loc 1 1187 0
 2364 0002 164B     		ldr	r3, .L314
 2365 0004 DC78     		ldrb	r4, [r3, #3]	@ zero_extendqisi2
1188:../drivers/fsl_clock.c **** 
1189:../drivers/fsl_clock.c ****     /*
1190:../drivers/fsl_clock.c ****        Errata: ERR007993
1191:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1192:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1193:../drivers/fsl_clock.c ****        reference clock changes.
1194:../drivers/fsl_clock.c ****      */
1195:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 2366              		.loc 1 1195 0
 2367 0006 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 2368 0008 EE06     		lsls	r6, r5, #27
1196:../drivers/fsl_clock.c ****     {
1197:../drivers/fsl_clock.c ****         change_drs = true;
1198:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1199:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2369              		.loc 1 1199 0
 2370 000a 5EBF     		ittt	pl
 2371 000c DD78     		ldrbpl	r5, [r3, #3]	@ zero_extendqisi2
 2372 000e 85F02005 		eorpl	r5, r5, #32
 2373 0012 DD70     		strbpl	r5, [r3, #3]
1200:../drivers/fsl_clock.c ****     }
1201:../drivers/fsl_clock.c **** 
1202:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1203:../drivers/fsl_clock.c ****     MCG->C1 =
1204:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 2374              		.loc 1 1204 0
 2375 0014 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 2376 0016 05F03B05 		and	r5, r5, #59
 2377 001a 45F00405 		orr	r5, r5, #4
1203:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 2378              		.loc 1 1203 0
 2379 001e 1D70     		strb	r5, [r3]
1205:../drivers/fsl_clock.c ****                                                                  | MCG_C1_IREFS(kMCG_FllSrcInternal
1206:../drivers/fsl_clock.c **** 
1207:../drivers/fsl_clock.c ****     /* Wait and check status. */
1208:../drivers/fsl_clock.c ****     while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
 2380              		.loc 1 1208 0
 2381 0020 0E4B     		ldr	r3, .L314
1187:../drivers/fsl_clock.c **** 
 2382              		.loc 1 1187 0
 2383 0022 E4B2     		uxtb	r4, r4
 2384              	.LVL196:
1197:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2385              		.loc 1 1197 0
 2386 0024 54BF     		ite	pl
 2387 0026 0126     		movpl	r6, #1
1178:../drivers/fsl_clock.c **** 
 2388              		.loc 1 1178 0
 2389 0028 0026     		movmi	r6, #0
 2390              	.LVL197:
 2391              	.L300:
 2392              		.loc 1 1208 0 discriminator 1
 2393 002a 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 2394 002c ED06     		lsls	r5, r5, #27
 2395 002e FCD5     		bpl	.L300
1209:../drivers/fsl_clock.c ****     {
1210:../drivers/fsl_clock.c ****     }
1211:../drivers/fsl_clock.c **** 
1212:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1213:../drivers/fsl_clock.c ****     if (change_drs)
 2396              		.loc 1 1213 0
 2397 0030 06B1     		cbz	r6, .L301
1214:../drivers/fsl_clock.c ****     {
1215:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2398              		.loc 1 1215 0
 2399 0032 DC70     		strb	r4, [r3, #3]
 2400              	.L301:
1216:../drivers/fsl_clock.c ****     }
1217:../drivers/fsl_clock.c **** 
1218:../drivers/fsl_clock.c ****     /* In FEI mode, the MCG_C4[DMX32] is set to 0U. */
1219:../drivers/fsl_clock.c ****     MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 2401              		.loc 1 1219 0
 2402 0034 4901     		lsls	r1, r1, #5
 2403              	.LVL198:
 2404 0036 01F06001 		and	r1, r1, #96
 2405 003a 41EAC010 		orr	r0, r1, r0, lsl #7
 2406              	.LVL199:
 2407 003e 04F01F04 		and	r4, r4, #31
 2408              	.LVL200:
 2409 0042 2043     		orrs	r0, r0, r4
 2410 0044 054B     		ldr	r3, .L314
 2411 0046 C0B2     		uxtb	r0, r0
 2412 0048 D870     		strb	r0, [r3, #3]
 2413              	.L302:
1220:../drivers/fsl_clock.c **** 
1221:../drivers/fsl_clock.c ****     /* Check MCG_S[CLKST] */
1222:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
 2414              		.loc 1 1222 0 discriminator 1
 2415 004a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 2416 004c 11F00C0F 		tst	r1, #12
 2417 0050 FBD1     		bne	.L302
1223:../drivers/fsl_clock.c ****     {
1224:../drivers/fsl_clock.c ****     }
1225:../drivers/fsl_clock.c **** 
1226:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1227:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2418              		.loc 1 1227 0
 2419 0052 02B1     		cbz	r2, .L303
1228:../drivers/fsl_clock.c ****     {
1229:../drivers/fsl_clock.c ****         fllStableDelay();
 2420              		.loc 1 1229 0
 2421 0054 9047     		blx	r2
 2422              	.LVL201:
 2423              	.L303:
1230:../drivers/fsl_clock.c ****     }
1231:../drivers/fsl_clock.c **** 
1232:../drivers/fsl_clock.c ****     return kStatus_Success;
1233:../drivers/fsl_clock.c **** }
 2424              		.loc 1 1233 0
 2425 0056 0020     		movs	r0, #0
 2426 0058 70BD     		pop	{r4, r5, r6, pc}
 2427              	.LVL202:
 2428              	.L315:
 2429 005a 00BF     		.align	2
 2430              	.L314:
 2431 005c 00400640 		.word	1074151424
 2432              		.cfi_endproc
 2433              	.LFE183:
 2435              		.section	.text.CLOCK_SetFeeMode,"ax",%progbits
 2436              		.align	1
 2437              		.global	CLOCK_SetFeeMode
 2438              		.syntax unified
 2439              		.thumb
 2440              		.thumb_func
 2441              		.fpu fpv4-sp-d16
 2443              	CLOCK_SetFeeMode:
 2444              	.LFB184:
1234:../drivers/fsl_clock.c **** 
1235:../drivers/fsl_clock.c **** status_t CLOCK_SetFeeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(v
1236:../drivers/fsl_clock.c **** {
 2445              		.loc 1 1236 0
 2446              		.cfi_startproc
 2447              		@ args = 0, pretend = 0, frame = 0
 2448              		@ frame_needed = 0, uses_anonymous_args = 0
 2449              	.LVL203:
 2450 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2451              		.cfi_def_cfa_offset 24
 2452              		.cfi_offset 3, -24
 2453              		.cfi_offset 4, -20
 2454              		.cfi_offset 5, -16
 2455              		.cfi_offset 6, -12
 2456              		.cfi_offset 7, -8
 2457              		.cfi_offset 14, -4
1237:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1238:../drivers/fsl_clock.c ****     bool change_drs = false;
1239:../drivers/fsl_clock.c **** 
1240:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1241:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1242:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1243:../drivers/fsl_clock.c ****     {
1244:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1245:../drivers/fsl_clock.c ****     }
1246:../drivers/fsl_clock.c **** #endif
1247:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2458              		.loc 1 1247 0
 2459 0002 1D4C     		ldr	r4, .L341
 2460 0004 E578     		ldrb	r5, [r4, #3]	@ zero_extendqisi2
1248:../drivers/fsl_clock.c **** 
1249:../drivers/fsl_clock.c ****     /*
1250:../drivers/fsl_clock.c ****        Errata: ERR007993
1251:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1252:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1253:../drivers/fsl_clock.c ****        reference clock changes.
1254:../drivers/fsl_clock.c ****      */
1255:../drivers/fsl_clock.c ****     if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
 2461              		.loc 1 1255 0
 2462 0006 A679     		ldrb	r6, [r4, #6]	@ zero_extendqisi2
 2463 0008 C6F30016 		ubfx	r6, r6, #4, #1
1247:../drivers/fsl_clock.c **** 
 2464              		.loc 1 1247 0
 2465 000c EDB2     		uxtb	r5, r5
 2466              	.LVL204:
 2467              		.loc 1 1255 0
 2468 000e 26B1     		cbz	r6, .L317
 2469              	.LVL205:
1256:../drivers/fsl_clock.c ****     {
1257:../drivers/fsl_clock.c ****         change_drs = true;
1258:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1259:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2470              		.loc 1 1259 0
 2471 0010 E678     		ldrb	r6, [r4, #3]	@ zero_extendqisi2
 2472 0012 86F02006 		eor	r6, r6, #32
 2473 0016 E670     		strb	r6, [r4, #3]
1257:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2474              		.loc 1 1257 0
 2475 0018 0126     		movs	r6, #1
 2476              	.LVL206:
 2477              	.L317:
1260:../drivers/fsl_clock.c ****     }
1261:../drivers/fsl_clock.c **** 
1262:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1263:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
 2478              		.loc 1 1263 0
 2479 001a 2778     		ldrb	r7, [r4]	@ zero_extendqisi2
1264:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
1265:../drivers/fsl_clock.c ****                 | MCG_C1_FRDIV(frdiv)                  /* FRDIV */
 2480              		.loc 1 1265 0
 2481 001c C000     		lsls	r0, r0, #3
 2482              	.LVL207:
1263:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 2483              		.loc 1 1263 0
 2484 001e 07F00307 		and	r7, r7, #3
1266:../drivers/fsl_clock.c ****                 | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
 2485              		.loc 1 1266 0
 2486 0022 00F03800 		and	r0, r0, #56
1263:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 2487              		.loc 1 1263 0
 2488 0026 3843     		orrs	r0, r0, r7
 2489 0028 2070     		strb	r0, [r4]
1267:../drivers/fsl_clock.c **** 
1268:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1269:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
 2490              		.loc 1 1269 0
 2491 002a 207B     		ldrb	r0, [r4, #12]	@ zero_extendqisi2
 2492 002c 8707     		lsls	r7, r0, #30
 2493 002e 06D1     		bne	.L318
1270:../drivers/fsl_clock.c ****     {
1271:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 2494              		.loc 1 1271 0
 2495 0030 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 2496 0032 4007     		lsls	r0, r0, #29
 2497 0034 03D5     		bpl	.L318
1272:../drivers/fsl_clock.c ****         {
1273:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 2498              		.loc 1 1273 0 discriminator 1
 2499 0036 104C     		ldr	r4, .L341
 2500              	.L336:
 2501 0038 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 2502 003a 8707     		lsls	r7, r0, #30
 2503 003c FCD5     		bpl	.L336
 2504              	.L318:
1274:../drivers/fsl_clock.c ****             {
1275:../drivers/fsl_clock.c ****             }
1276:../drivers/fsl_clock.c ****         }
1277:../drivers/fsl_clock.c ****     }
1278:../drivers/fsl_clock.c **** 
1279:../drivers/fsl_clock.c ****     /* Wait and check status. */
1280:../drivers/fsl_clock.c ****     while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
 2505              		.loc 1 1280 0 discriminator 1
 2506 003e 0E48     		ldr	r0, .L341
 2507              	.L332:
 2508 0040 8479     		ldrb	r4, [r0, #6]	@ zero_extendqisi2
 2509 0042 E406     		lsls	r4, r4, #27
 2510 0044 FCD4     		bmi	.L332
1281:../drivers/fsl_clock.c ****     {
1282:../drivers/fsl_clock.c ****     }
1283:../drivers/fsl_clock.c **** 
1284:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1285:../drivers/fsl_clock.c ****     if (change_drs)
 2511              		.loc 1 1285 0
 2512 0046 06B1     		cbz	r6, .L320
1286:../drivers/fsl_clock.c ****     {
1287:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2513              		.loc 1 1287 0
 2514 0048 C570     		strb	r5, [r0, #3]
 2515              	.L320:
1288:../drivers/fsl_clock.c ****     }
1289:../drivers/fsl_clock.c **** 
1290:../drivers/fsl_clock.c ****     /* Set DRS and DMX32. */
1291:../drivers/fsl_clock.c ****     mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 2516              		.loc 1 1291 0
 2517 004a 5201     		lsls	r2, r2, #5
 2518              	.LVL208:
 2519 004c 02F06002 		and	r2, r2, #96
 2520 0050 42EAC111 		orr	r1, r2, r1, lsl #7
 2521              	.LVL209:
 2522 0054 05F01F05 		and	r5, r5, #31
 2523              	.LVL210:
 2524 0058 2943     		orrs	r1, r1, r5
1292:../drivers/fsl_clock.c ****     MCG->C4 = mcg_c4;
 2525              		.loc 1 1292 0
 2526 005a 074A     		ldr	r2, .L341
1291:../drivers/fsl_clock.c ****     MCG->C4 = mcg_c4;
 2527              		.loc 1 1291 0
 2528 005c C9B2     		uxtb	r1, r1
 2529              	.LVL211:
 2530              		.loc 1 1292 0
 2531 005e D170     		strb	r1, [r2, #3]
 2532              	.L321:
1293:../drivers/fsl_clock.c **** 
1294:../drivers/fsl_clock.c ****     /* Wait for DRST_DRS update. */
1295:../drivers/fsl_clock.c ****     while (MCG->C4 != mcg_c4)
 2533              		.loc 1 1295 0 discriminator 1
 2534 0060 D078     		ldrb	r0, [r2, #3]	@ zero_extendqisi2
 2535 0062 8142     		cmp	r1, r0
 2536 0064 FCD1     		bne	.L321
 2537              	.LVL212:
 2538              	.L331:
1296:../drivers/fsl_clock.c ****     {
1297:../drivers/fsl_clock.c ****     }
1298:../drivers/fsl_clock.c **** 
1299:../drivers/fsl_clock.c ****     /* Check MCG_S[CLKST] */
1300:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
 2539              		.loc 1 1300 0 discriminator 1
 2540 0066 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2541 0068 11F00C0F 		tst	r1, #12
 2542 006c FBD1     		bne	.L331
1301:../drivers/fsl_clock.c ****     {
1302:../drivers/fsl_clock.c ****     }
1303:../drivers/fsl_clock.c **** 
1304:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1305:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2543              		.loc 1 1305 0
 2544 006e 03B1     		cbz	r3, .L323
1306:../drivers/fsl_clock.c ****     {
1307:../drivers/fsl_clock.c ****         fllStableDelay();
 2545              		.loc 1 1307 0
 2546 0070 9847     		blx	r3
 2547              	.LVL213:
 2548              	.L323:
1308:../drivers/fsl_clock.c ****     }
1309:../drivers/fsl_clock.c **** 
1310:../drivers/fsl_clock.c ****     return kStatus_Success;
1311:../drivers/fsl_clock.c **** }
 2549              		.loc 1 1311 0
 2550 0072 0020     		movs	r0, #0
 2551 0074 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2552              	.LVL214:
 2553              	.L342:
 2554 0076 00BF     		.align	2
 2555              	.L341:
 2556 0078 00400640 		.word	1074151424
 2557              		.cfi_endproc
 2558              	.LFE184:
 2560              		.section	.text.CLOCK_SetFbiMode,"ax",%progbits
 2561              		.align	1
 2562              		.global	CLOCK_SetFbiMode
 2563              		.syntax unified
 2564              		.thumb
 2565              		.thumb_func
 2566              		.fpu fpv4-sp-d16
 2568              	CLOCK_SetFbiMode:
 2569              	.LFB185:
1312:../drivers/fsl_clock.c **** 
1313:../drivers/fsl_clock.c **** status_t CLOCK_SetFbiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1314:../drivers/fsl_clock.c **** {
 2570              		.loc 1 1314 0
 2571              		.cfi_startproc
 2572              		@ args = 0, pretend = 0, frame = 0
 2573              		@ frame_needed = 0, uses_anonymous_args = 0
 2574              	.LVL215:
 2575 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2576              		.cfi_def_cfa_offset 24
 2577              		.cfi_offset 3, -24
 2578              		.cfi_offset 4, -20
 2579              		.cfi_offset 5, -16
 2580              		.cfi_offset 6, -12
 2581              		.cfi_offset 7, -8
 2582              		.cfi_offset 14, -4
1315:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1316:../drivers/fsl_clock.c ****     bool change_drs = false;
1317:../drivers/fsl_clock.c **** 
1318:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1319:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1320:../drivers/fsl_clock.c **** 
1321:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1322:../drivers/fsl_clock.c ****           (kMCG_ModeBLPI == mode)))
1323:../drivers/fsl_clock.c **** 
1324:../drivers/fsl_clock.c ****     {
1325:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1326:../drivers/fsl_clock.c ****     }
1327:../drivers/fsl_clock.c **** #endif
1328:../drivers/fsl_clock.c **** 
1329:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2583              		.loc 1 1329 0
 2584 0002 184B     		ldr	r3, .L359
 2585 0004 DC78     		ldrb	r4, [r3, #3]	@ zero_extendqisi2
1330:../drivers/fsl_clock.c **** 
1331:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 2586              		.loc 1 1331 0
 2587 0006 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
 2588 0008 05F0FD05 		and	r5, r5, #253
 2589 000c 5D70     		strb	r5, [r3, #1]
1332:../drivers/fsl_clock.c **** 
1333:../drivers/fsl_clock.c ****     /*
1334:../drivers/fsl_clock.c ****        Errata: ERR007993
1335:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1336:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1337:../drivers/fsl_clock.c ****        reference clock changes.
1338:../drivers/fsl_clock.c ****      */
1339:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 2590              		.loc 1 1339 0
 2591 000e 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 2592 0010 ED06     		lsls	r5, r5, #27
1340:../drivers/fsl_clock.c ****     {
1341:../drivers/fsl_clock.c ****         change_drs = true;
1342:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1343:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2593              		.loc 1 1343 0
 2594 0012 5EBF     		ittt	pl
 2595 0014 DD78     		ldrbpl	r5, [r3, #3]	@ zero_extendqisi2
 2596 0016 85F02005 		eorpl	r5, r5, #32
 2597 001a DD70     		strbpl	r5, [r3, #3]
1344:../drivers/fsl_clock.c ****     }
1345:../drivers/fsl_clock.c **** 
1346:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1347:../drivers/fsl_clock.c ****     MCG->C1 =
1348:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 2598              		.loc 1 1348 0
 2599 001c 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 2600 001e 05F03B05 		and	r5, r5, #59
 2601 0022 45F04405 		orr	r5, r5, #68
1347:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 2602              		.loc 1 1347 0
 2603 0026 1D70     		strb	r5, [r3]
1349:../drivers/fsl_clock.c ****                                                                 | MCG_C1_IREFS(kMCG_FllSrcInternal)
1350:../drivers/fsl_clock.c **** 
1351:../drivers/fsl_clock.c ****     /* Wait and check status. */
1352:../drivers/fsl_clock.c ****     while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
 2604              		.loc 1 1352 0
 2605 0028 0E4B     		ldr	r3, .L359
1329:../drivers/fsl_clock.c **** 
 2606              		.loc 1 1329 0
 2607 002a E4B2     		uxtb	r4, r4
 2608              	.LVL216:
1341:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2609              		.loc 1 1341 0
 2610 002c 54BF     		ite	pl
 2611 002e 0126     		movpl	r6, #1
1316:../drivers/fsl_clock.c **** 
 2612              		.loc 1 1316 0
 2613 0030 0026     		movmi	r6, #0
 2614              	.LVL217:
 2615 0032 1D46     		mov	r5, r3
 2616              	.L345:
 2617              		.loc 1 1352 0 discriminator 1
 2618 0034 9F79     		ldrb	r7, [r3, #6]	@ zero_extendqisi2
 2619 0036 FF06     		lsls	r7, r7, #27
 2620 0038 FCD5     		bpl	.L345
1353:../drivers/fsl_clock.c ****     {
1354:../drivers/fsl_clock.c ****     }
1355:../drivers/fsl_clock.c **** 
1356:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1357:../drivers/fsl_clock.c ****     if (change_drs)
 2621              		.loc 1 1357 0
 2622 003a 06B1     		cbz	r6, .L347
1358:../drivers/fsl_clock.c ****     {
1359:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2623              		.loc 1 1359 0
 2624 003c DC70     		strb	r4, [r3, #3]
 2625              	.L347:
1360:../drivers/fsl_clock.c ****     }
1361:../drivers/fsl_clock.c **** 
1362:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatInt != MCG_S_CLKST_VAL)
 2626              		.loc 1 1362 0 discriminator 1
 2627 003e AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 2628 0040 C3F38103 		ubfx	r3, r3, #2, #2
 2629 0044 012B     		cmp	r3, #1
 2630 0046 FAD1     		bne	.L347
1363:../drivers/fsl_clock.c ****     {
1364:../drivers/fsl_clock.c ****     }
1365:../drivers/fsl_clock.c **** 
1366:../drivers/fsl_clock.c ****     MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 2631              		.loc 1 1366 0
 2632 0048 4901     		lsls	r1, r1, #5
 2633              	.LVL218:
 2634 004a 01F06001 		and	r1, r1, #96
 2635 004e 41EAC010 		orr	r0, r1, r0, lsl #7
 2636              	.LVL219:
 2637 0052 04F01F04 		and	r4, r4, #31
 2638              	.LVL220:
 2639 0056 2043     		orrs	r0, r0, r4
 2640 0058 C0B2     		uxtb	r0, r0
 2641 005a E870     		strb	r0, [r5, #3]
1367:../drivers/fsl_clock.c **** 
1368:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1369:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2642              		.loc 1 1369 0
 2643 005c 02B1     		cbz	r2, .L348
1370:../drivers/fsl_clock.c ****     {
1371:../drivers/fsl_clock.c ****         fllStableDelay();
 2644              		.loc 1 1371 0
 2645 005e 9047     		blx	r2
 2646              	.LVL221:
 2647              	.L348:
1372:../drivers/fsl_clock.c ****     }
1373:../drivers/fsl_clock.c **** 
1374:../drivers/fsl_clock.c ****     return kStatus_Success;
1375:../drivers/fsl_clock.c **** }
 2648              		.loc 1 1375 0
 2649 0060 0020     		movs	r0, #0
 2650 0062 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2651              	.LVL222:
 2652              	.L360:
 2653              		.align	2
 2654              	.L359:
 2655 0064 00400640 		.word	1074151424
 2656              		.cfi_endproc
 2657              	.LFE185:
 2659              		.section	.text.CLOCK_SetFbeMode,"ax",%progbits
 2660              		.align	1
 2661              		.global	CLOCK_SetFbeMode
 2662              		.syntax unified
 2663              		.thumb
 2664              		.thumb_func
 2665              		.fpu fpv4-sp-d16
 2667              	CLOCK_SetFbeMode:
 2668              	.LFB186:
1376:../drivers/fsl_clock.c **** 
1377:../drivers/fsl_clock.c **** status_t CLOCK_SetFbeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(v
1378:../drivers/fsl_clock.c **** {
 2669              		.loc 1 1378 0
 2670              		.cfi_startproc
 2671              		@ args = 0, pretend = 0, frame = 0
 2672              		@ frame_needed = 0, uses_anonymous_args = 0
 2673              	.LVL223:
 2674 0000 70B5     		push	{r4, r5, r6, lr}
 2675              		.cfi_def_cfa_offset 16
 2676              		.cfi_offset 4, -16
 2677              		.cfi_offset 5, -12
 2678              		.cfi_offset 6, -8
 2679              		.cfi_offset 14, -4
1379:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1380:../drivers/fsl_clock.c ****     bool change_drs = false;
1381:../drivers/fsl_clock.c **** 
1382:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1383:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1384:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1385:../drivers/fsl_clock.c ****           (kMCG_ModePBE == mode) || (kMCG_ModeBLPE == mode)))
1386:../drivers/fsl_clock.c ****     {
1387:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1388:../drivers/fsl_clock.c ****     }
1389:../drivers/fsl_clock.c **** #endif
1390:../drivers/fsl_clock.c **** 
1391:../drivers/fsl_clock.c ****     /* Change to FLL mode. */
1392:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 2680              		.loc 1 1392 0
 2681 0002 1E4A     		ldr	r2, .L385
 2682              	.LVL224:
 2683 0004 5179     		ldrb	r1, [r2, #5]	@ zero_extendqisi2
 2684              	.LVL225:
 2685 0006 01F0BF01 		and	r1, r1, #191
 2686 000a 5171     		strb	r1, [r2, #5]
 2687              	.L362:
1393:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2688              		.loc 1 1393 0 discriminator 1
 2689 000c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2690 000e 8D06     		lsls	r5, r1, #26
 2691 0010 FCD4     		bmi	.L362
1394:../drivers/fsl_clock.c ****     {
1395:../drivers/fsl_clock.c ****     }
1396:../drivers/fsl_clock.c **** 
1397:../drivers/fsl_clock.c ****     /* Set LP bit to enable the FLL */
1398:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 2692              		.loc 1 1398 0
 2693 0012 5178     		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 2694 0014 01F0FD01 		and	r1, r1, #253
 2695 0018 5170     		strb	r1, [r2, #1]
1399:../drivers/fsl_clock.c **** 
1400:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2696              		.loc 1 1400 0
 2697 001a D678     		ldrb	r6, [r2, #3]	@ zero_extendqisi2
1401:../drivers/fsl_clock.c **** 
1402:../drivers/fsl_clock.c ****     /*
1403:../drivers/fsl_clock.c ****        Errata: ERR007993
1404:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1405:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1406:../drivers/fsl_clock.c ****        reference clock changes.
1407:../drivers/fsl_clock.c ****      */
1408:../drivers/fsl_clock.c ****     if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
 2698              		.loc 1 1408 0
 2699 001c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2700 001e C1F30011 		ubfx	r1, r1, #4, #1
1400:../drivers/fsl_clock.c **** 
 2701              		.loc 1 1400 0
 2702 0022 F6B2     		uxtb	r6, r6
 2703              	.LVL226:
 2704              		.loc 1 1408 0
 2705 0024 41B3     		cbz	r1, .L369
 2706              	.LVL227:
1409:../drivers/fsl_clock.c ****     {
1410:../drivers/fsl_clock.c ****         change_drs = true;
1411:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1412:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2707              		.loc 1 1412 0
 2708 0026 D178     		ldrb	r1, [r2, #3]	@ zero_extendqisi2
 2709 0028 81F02001 		eor	r1, r1, #32
 2710 002c D170     		strb	r1, [r2, #3]
1410:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2711              		.loc 1 1410 0
 2712 002e 0122     		movs	r2, #1
 2713              	.LVL228:
 2714              	.L363:
1413:../drivers/fsl_clock.c ****     }
1414:../drivers/fsl_clock.c **** 
1415:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1416:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
 2715              		.loc 1 1416 0
 2716 0030 1249     		ldr	r1, .L385
 2717 0032 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
1417:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
1418:../drivers/fsl_clock.c ****                 | MCG_C1_FRDIV(frdiv)                  /* FRDIV = frdiv */
 2718              		.loc 1 1418 0
 2719 0034 C000     		lsls	r0, r0, #3
 2720              	.LVL229:
 2721 0036 00F03805 		and	r5, r0, #56
1416:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
 2722              		.loc 1 1416 0
 2723 003a 04F00300 		and	r0, r4, #3
 2724 003e 2843     		orrs	r0, r0, r5
 2725 0040 40F08000 		orr	r0, r0, #128
 2726 0044 0870     		strb	r0, [r1]
1419:../drivers/fsl_clock.c ****                 | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
1420:../drivers/fsl_clock.c **** 
1421:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1422:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
 2727              		.loc 1 1422 0
 2728 0046 087B     		ldrb	r0, [r1, #12]	@ zero_extendqisi2
 2729 0048 8407     		lsls	r4, r0, #30
 2730 004a 05D1     		bne	.L364
1423:../drivers/fsl_clock.c ****     {
1424:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 2731              		.loc 1 1424 0
 2732 004c 4878     		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 2733 004e 4007     		lsls	r0, r0, #29
 2734 0050 02D5     		bpl	.L364
 2735              	.L380:
1425:../drivers/fsl_clock.c ****         {
1426:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 2736              		.loc 1 1426 0 discriminator 1
 2737 0052 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
 2738 0054 8507     		lsls	r5, r0, #30
 2739 0056 FCD5     		bpl	.L380
 2740              	.L364:
1427:../drivers/fsl_clock.c ****             {
1428:../drivers/fsl_clock.c ****             }
1429:../drivers/fsl_clock.c ****         }
1430:../drivers/fsl_clock.c ****     }
1431:../drivers/fsl_clock.c **** 
1432:../drivers/fsl_clock.c ****     /* Wait for Reference clock Status bit to clear */
1433:../drivers/fsl_clock.c ****     while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
 2741              		.loc 1 1433 0 discriminator 1
 2742 0058 0849     		ldr	r1, .L385
 2743 005a 0846     		mov	r0, r1
 2744              	.L376:
 2745 005c 8C79     		ldrb	r4, [r1, #6]	@ zero_extendqisi2
 2746 005e E406     		lsls	r4, r4, #27
 2747 0060 FCD4     		bmi	.L376
1434:../drivers/fsl_clock.c ****     {
1435:../drivers/fsl_clock.c ****     }
1436:../drivers/fsl_clock.c **** 
1437:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1438:../drivers/fsl_clock.c ****     if (change_drs)
 2748              		.loc 1 1438 0
 2749 0062 02B1     		cbz	r2, .L367
1439:../drivers/fsl_clock.c ****     {
1440:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2750              		.loc 1 1440 0
 2751 0064 CE70     		strb	r6, [r1, #3]
 2752              	.LVL230:
 2753              	.L367:
1441:../drivers/fsl_clock.c ****     }
1442:../drivers/fsl_clock.c **** 
1443:../drivers/fsl_clock.c ****     /* Set DRST_DRS and DMX32. */
1444:../drivers/fsl_clock.c ****     mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
1445:../drivers/fsl_clock.c **** 
1446:../drivers/fsl_clock.c ****     /* Wait for clock status bits to show clock source is ext ref clk */
1447:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatExt != MCG_S_CLKST_VAL)
 2754              		.loc 1 1447 0 discriminator 1
 2755 0066 8279     		ldrb	r2, [r0, #6]	@ zero_extendqisi2
 2756 0068 C2F38102 		ubfx	r2, r2, #2, #2
 2757 006c 022A     		cmp	r2, #2
 2758 006e FAD1     		bne	.L367
1448:../drivers/fsl_clock.c ****     {
1449:../drivers/fsl_clock.c ****     }
1450:../drivers/fsl_clock.c **** 
1451:../drivers/fsl_clock.c ****     /* Wait for fll stable time. */
1452:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2759              		.loc 1 1452 0
 2760 0070 03B1     		cbz	r3, .L368
1453:../drivers/fsl_clock.c ****     {
1454:../drivers/fsl_clock.c ****         fllStableDelay();
 2761              		.loc 1 1454 0
 2762 0072 9847     		blx	r3
 2763              	.LVL231:
 2764              	.L368:
1455:../drivers/fsl_clock.c ****     }
1456:../drivers/fsl_clock.c **** 
1457:../drivers/fsl_clock.c ****     return kStatus_Success;
1458:../drivers/fsl_clock.c **** }
 2765              		.loc 1 1458 0
 2766 0074 0020     		movs	r0, #0
 2767 0076 70BD     		pop	{r4, r5, r6, pc}
 2768              	.LVL232:
 2769              	.L369:
1380:../drivers/fsl_clock.c **** 
 2770              		.loc 1 1380 0
 2771 0078 0A46     		mov	r2, r1
 2772 007a D9E7     		b	.L363
 2773              	.L386:
 2774              		.align	2
 2775              	.L385:
 2776 007c 00400640 		.word	1074151424
 2777              		.cfi_endproc
 2778              	.LFE186:
 2780              		.section	.text.CLOCK_SetBlpeMode,"ax",%progbits
 2781              		.align	1
 2782              		.global	CLOCK_SetBlpeMode
 2783              		.syntax unified
 2784              		.thumb
 2785              		.thumb_func
 2786              		.fpu fpv4-sp-d16
 2788              	CLOCK_SetBlpeMode:
 2789              	.LFB188:
1459:../drivers/fsl_clock.c **** 
1460:../drivers/fsl_clock.c **** status_t CLOCK_SetBlpiMode(void)
1461:../drivers/fsl_clock.c **** {
1462:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1463:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
1464:../drivers/fsl_clock.c ****     {
1465:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1466:../drivers/fsl_clock.c ****     }
1467:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
1468:../drivers/fsl_clock.c **** 
1469:../drivers/fsl_clock.c ****     /* Set LP. */
1470:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
1471:../drivers/fsl_clock.c **** 
1472:../drivers/fsl_clock.c ****     return kStatus_Success;
1473:../drivers/fsl_clock.c **** }
1474:../drivers/fsl_clock.c **** 
1475:../drivers/fsl_clock.c **** status_t CLOCK_SetBlpeMode(void)
1476:../drivers/fsl_clock.c **** {
 2790              		.loc 1 1476 0
 2791              		.cfi_startproc
 2792              		@ args = 0, pretend = 0, frame = 0
 2793              		@ frame_needed = 0, uses_anonymous_args = 0
 2794              		@ link register save eliminated.
1477:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1478:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
1479:../drivers/fsl_clock.c ****     {
1480:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1481:../drivers/fsl_clock.c ****     }
1482:../drivers/fsl_clock.c **** #endif
1483:../drivers/fsl_clock.c **** 
1484:../drivers/fsl_clock.c ****     /* Set LP bit to enter BLPE mode. */
1485:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 2795              		.loc 1 1485 0
 2796 0000 034A     		ldr	r2, .L388
 2797 0002 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 2798 0004 43F00203 		orr	r3, r3, #2
 2799 0008 5370     		strb	r3, [r2, #1]
1486:../drivers/fsl_clock.c **** 
1487:../drivers/fsl_clock.c ****     return kStatus_Success;
1488:../drivers/fsl_clock.c **** }
 2800              		.loc 1 1488 0
 2801 000a 0020     		movs	r0, #0
 2802 000c 7047     		bx	lr
 2803              	.L389:
 2804 000e 00BF     		.align	2
 2805              	.L388:
 2806 0010 00400640 		.word	1074151424
 2807              		.cfi_endproc
 2808              	.LFE188:
 2810              		.section	.text.CLOCK_SetBlpiMode,"ax",%progbits
 2811              		.align	1
 2812              		.global	CLOCK_SetBlpiMode
 2813              		.syntax unified
 2814              		.thumb
 2815              		.thumb_func
 2816              		.fpu fpv4-sp-d16
 2818              	CLOCK_SetBlpiMode:
 2819              	.LFB205:
 2820              		.cfi_startproc
 2821              		@ args = 0, pretend = 0, frame = 0
 2822              		@ frame_needed = 0, uses_anonymous_args = 0
 2823              		@ link register save eliminated.
 2824 0000 FFF7FEBF 		b	CLOCK_SetBlpeMode
 2825              		.cfi_endproc
 2826              	.LFE205:
 2828              		.section	.text.CLOCK_SetPbeMode,"ax",%progbits
 2829              		.align	1
 2830              		.global	CLOCK_SetPbeMode
 2831              		.syntax unified
 2832              		.thumb
 2833              		.thumb_func
 2834              		.fpu fpv4-sp-d16
 2836              	CLOCK_SetPbeMode:
 2837              	.LFB189:
1489:../drivers/fsl_clock.c **** 
1490:../drivers/fsl_clock.c **** status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
1491:../drivers/fsl_clock.c **** {
 2838              		.loc 1 1491 0
 2839              		.cfi_startproc
 2840              		@ args = 0, pretend = 0, frame = 0
 2841              		@ frame_needed = 0, uses_anonymous_args = 0
 2842              	.LVL233:
 2843              		.loc 1 1491 0
 2844 0000 38B5     		push	{r3, r4, r5, lr}
 2845              		.cfi_def_cfa_offset 16
 2846              		.cfi_offset 3, -16
 2847              		.cfi_offset 4, -12
 2848              		.cfi_offset 5, -8
 2849              		.cfi_offset 14, -4
1492:../drivers/fsl_clock.c ****     assert(config);
1493:../drivers/fsl_clock.c **** 
1494:../drivers/fsl_clock.c ****     /*
1495:../drivers/fsl_clock.c ****        This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
1496:../drivers/fsl_clock.c ****        but with this workflow, the source mode could be all modes except PEI/PBI.
1497:../drivers/fsl_clock.c ****      */
1498:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 2850              		.loc 1 1498 0
 2851 0002 124B     		ldr	r3, .L399
 2852 0004 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2853 0006 02F0FD02 		and	r2, r2, #253
 2854 000a 5A70     		strb	r2, [r3, #1]
1499:../drivers/fsl_clock.c **** 
1500:../drivers/fsl_clock.c ****     /* Change to use external clock first. */
1501:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | MCG_C1_CLKS(kMCG_ClkOutSrcExte
 2855              		.loc 1 1501 0
 2856 000c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2857 000e 02F03B02 		and	r2, r2, #59
 2858 0012 42F08002 		orr	r2, r2, #128
 2859 0016 1A70     		strb	r2, [r3]
 2860              	.L392:
1502:../drivers/fsl_clock.c **** 
1503:../drivers/fsl_clock.c ****     /* Wait for CLKST clock status bits to show clock source is ext ref clk */
1504:../drivers/fsl_clock.c ****     while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
 2861              		.loc 1 1504 0 discriminator 1
 2862 0018 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2863 001a 02F01C02 		and	r2, r2, #28
 2864 001e 082A     		cmp	r2, #8
 2865 0020 FAD1     		bne	.L392
1505:../drivers/fsl_clock.c ****            (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
1506:../drivers/fsl_clock.c ****     {
1507:../drivers/fsl_clock.c ****     }
1508:../drivers/fsl_clock.c **** 
1509:../drivers/fsl_clock.c ****     /* Disable PLL first, then configure PLL. */
1510:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 2866              		.loc 1 1510 0
 2867 0022 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
1511:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2868              		.loc 1 1511 0
 2869 0024 094C     		ldr	r4, .L399
1510:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2870              		.loc 1 1510 0
 2871 0026 02F0BF02 		and	r2, r2, #191
 2872 002a 5A71     		strb	r2, [r3, #5]
 2873 002c 2546     		mov	r5, r4
 2874              	.L393:
 2875              		.loc 1 1511 0 discriminator 1
 2876 002e A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 2877 0030 9A06     		lsls	r2, r3, #26
 2878 0032 FCD4     		bmi	.L393
1512:../drivers/fsl_clock.c ****     {
1513:../drivers/fsl_clock.c ****     }
1514:../drivers/fsl_clock.c **** 
1515:../drivers/fsl_clock.c ****     /* Configure the PLL. */
1516:../drivers/fsl_clock.c ****     {
1517:../drivers/fsl_clock.c ****         CLOCK_EnablePll0(config);
 2879              		.loc 1 1517 0
 2880 0034 0846     		mov	r0, r1
 2881              	.LVL234:
 2882 0036 FFF7FEFF 		bl	CLOCK_EnablePll0
 2883              	.LVL235:
1518:../drivers/fsl_clock.c ****     }
1519:../drivers/fsl_clock.c **** 
1520:../drivers/fsl_clock.c ****     /* Change to PLL mode. */
1521:../drivers/fsl_clock.c ****     MCG->C6 |= MCG_C6_PLLS_MASK;
 2884              		.loc 1 1521 0
 2885 003a 6379     		ldrb	r3, [r4, #5]	@ zero_extendqisi2
 2886 003c 43F04003 		orr	r3, r3, #64
 2887 0040 6371     		strb	r3, [r4, #5]
 2888              	.L394:
1522:../drivers/fsl_clock.c **** 
1523:../drivers/fsl_clock.c ****     /* Wait for PLL mode changed. */
1524:../drivers/fsl_clock.c ****     while (!(MCG->S & MCG_S_PLLST_MASK))
 2889              		.loc 1 1524 0 discriminator 1
 2890 0042 AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 2891 0044 9B06     		lsls	r3, r3, #26
 2892 0046 FCD5     		bpl	.L394
1525:../drivers/fsl_clock.c ****     {
1526:../drivers/fsl_clock.c ****     }
1527:../drivers/fsl_clock.c **** 
1528:../drivers/fsl_clock.c ****     return kStatus_Success;
1529:../drivers/fsl_clock.c **** }
 2893              		.loc 1 1529 0
 2894 0048 0020     		movs	r0, #0
 2895              	.LVL236:
 2896 004a 38BD     		pop	{r3, r4, r5, pc}
 2897              	.L400:
 2898              		.align	2
 2899              	.L399:
 2900 004c 00400640 		.word	1074151424
 2901              		.cfi_endproc
 2902              	.LFE189:
 2904              		.section	.text.CLOCK_SetPeeMode,"ax",%progbits
 2905              		.align	1
 2906              		.global	CLOCK_SetPeeMode
 2907              		.syntax unified
 2908              		.thumb
 2909              		.thumb_func
 2910              		.fpu fpv4-sp-d16
 2912              	CLOCK_SetPeeMode:
 2913              	.LFB190:
1530:../drivers/fsl_clock.c **** 
1531:../drivers/fsl_clock.c **** status_t CLOCK_SetPeeMode(void)
1532:../drivers/fsl_clock.c **** {
 2914              		.loc 1 1532 0
 2915              		.cfi_startproc
 2916              		@ args = 0, pretend = 0, frame = 0
 2917              		@ frame_needed = 0, uses_anonymous_args = 0
 2918              		@ link register save eliminated.
1533:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1534:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1535:../drivers/fsl_clock.c ****     if (kMCG_ModePBE != mode)
1536:../drivers/fsl_clock.c ****     {
1537:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1538:../drivers/fsl_clock.c ****     }
1539:../drivers/fsl_clock.c **** #endif
1540:../drivers/fsl_clock.c **** 
1541:../drivers/fsl_clock.c ****     /* Change to use PLL/FLL output clock first. */
1542:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
 2919              		.loc 1 1542 0
 2920 0000 054B     		ldr	r3, .L404
 2921 0002 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2922 0004 02F03F02 		and	r2, r2, #63
 2923 0008 1A70     		strb	r2, [r3]
 2924              	.L402:
1543:../drivers/fsl_clock.c **** 
1544:../drivers/fsl_clock.c ****     /* Wait for clock status bits to update */
1545:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
 2925              		.loc 1 1545 0 discriminator 1
 2926 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2927 000c C2F38102 		ubfx	r2, r2, #2, #2
 2928 0010 032A     		cmp	r2, #3
 2929 0012 FAD1     		bne	.L402
1546:../drivers/fsl_clock.c ****     {
1547:../drivers/fsl_clock.c ****     }
1548:../drivers/fsl_clock.c **** 
1549:../drivers/fsl_clock.c ****     return kStatus_Success;
1550:../drivers/fsl_clock.c **** }
 2930              		.loc 1 1550 0
 2931 0014 0020     		movs	r0, #0
 2932 0016 7047     		bx	lr
 2933              	.L405:
 2934              		.align	2
 2935              	.L404:
 2936 0018 00400640 		.word	1074151424
 2937              		.cfi_endproc
 2938              	.LFE190:
 2940              		.section	.text.CLOCK_ExternalModeToFbeModeQuick,"ax",%progbits
 2941              		.align	1
 2942              		.global	CLOCK_ExternalModeToFbeModeQuick
 2943              		.syntax unified
 2944              		.thumb
 2945              		.thumb_func
 2946              		.fpu fpv4-sp-d16
 2948              	CLOCK_ExternalModeToFbeModeQuick:
 2949              	.LFB191:
1551:../drivers/fsl_clock.c **** 
1552:../drivers/fsl_clock.c **** status_t CLOCK_ExternalModeToFbeModeQuick(void)
1553:../drivers/fsl_clock.c **** {
 2950              		.loc 1 1553 0
 2951              		.cfi_startproc
 2952              		@ args = 0, pretend = 0, frame = 0
 2953              		@ frame_needed = 0, uses_anonymous_args = 0
 2954              		@ link register save eliminated.
1554:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1555:../drivers/fsl_clock.c ****     if (MCG->S & MCG_S_IREFST_MASK)
1556:../drivers/fsl_clock.c ****     {
1557:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeInvalid;
1558:../drivers/fsl_clock.c ****     }
1559:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
1560:../drivers/fsl_clock.c **** 
1561:../drivers/fsl_clock.c ****     /* Disable low power */
1562:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 2955              		.loc 1 1562 0
 2956 0000 0C4B     		ldr	r3, .L411
 2957 0002 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2958 0004 02F0FD02 		and	r2, r2, #253
 2959 0008 5A70     		strb	r2, [r3, #1]
1563:../drivers/fsl_clock.c **** 
1564:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
 2960              		.loc 1 1564 0
 2961 000a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2962 000c 02F03F02 		and	r2, r2, #63
 2963 0010 42F08002 		orr	r2, r2, #128
 2964 0014 1A70     		strb	r2, [r3]
 2965              	.L407:
1565:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 2966              		.loc 1 1565 0 discriminator 1
 2967 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2968 0018 C2F38102 		ubfx	r2, r2, #2, #2
 2969 001c 022A     		cmp	r2, #2
 2970 001e FAD1     		bne	.L407
1566:../drivers/fsl_clock.c ****     {
1567:../drivers/fsl_clock.c ****     }
1568:../drivers/fsl_clock.c **** 
1569:../drivers/fsl_clock.c ****     /* Disable PLL. */
1570:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 2971              		.loc 1 1570 0
 2972 0020 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2973 0022 02F0BF02 		and	r2, r2, #191
 2974 0026 5A71     		strb	r2, [r3, #5]
1571:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2975              		.loc 1 1571 0
 2976 0028 024B     		ldr	r3, .L411
 2977              	.L408:
 2978              		.loc 1 1571 0 is_stmt 0 discriminator 1
 2979 002a 9879     		ldrb	r0, [r3, #6]	@ zero_extendqisi2
 2980 002c 10F02000 		ands	r0, r0, #32
 2981 0030 FBD1     		bne	.L408
1572:../drivers/fsl_clock.c ****     {
1573:../drivers/fsl_clock.c ****     }
1574:../drivers/fsl_clock.c **** 
1575:../drivers/fsl_clock.c ****     return kStatus_Success;
1576:../drivers/fsl_clock.c **** }
 2982              		.loc 1 1576 0 is_stmt 1
 2983 0032 7047     		bx	lr
 2984              	.L412:
 2985              		.align	2
 2986              	.L411:
 2987 0034 00400640 		.word	1074151424
 2988              		.cfi_endproc
 2989              	.LFE191:
 2991              		.section	.text.CLOCK_InternalModeToFbiModeQuick,"ax",%progbits
 2992              		.align	1
 2993              		.global	CLOCK_InternalModeToFbiModeQuick
 2994              		.syntax unified
 2995              		.thumb
 2996              		.thumb_func
 2997              		.fpu fpv4-sp-d16
 2999              	CLOCK_InternalModeToFbiModeQuick:
 3000              	.LFB192:
1577:../drivers/fsl_clock.c **** 
1578:../drivers/fsl_clock.c **** status_t CLOCK_InternalModeToFbiModeQuick(void)
1579:../drivers/fsl_clock.c **** {
 3001              		.loc 1 1579 0
 3002              		.cfi_startproc
 3003              		@ args = 0, pretend = 0, frame = 0
 3004              		@ frame_needed = 0, uses_anonymous_args = 0
 3005              		@ link register save eliminated.
1580:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1581:../drivers/fsl_clock.c ****     if (!(MCG->S & MCG_S_IREFST_MASK))
1582:../drivers/fsl_clock.c ****     {
1583:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeInvalid;
1584:../drivers/fsl_clock.c ****     }
1585:../drivers/fsl_clock.c **** #endif
1586:../drivers/fsl_clock.c **** 
1587:../drivers/fsl_clock.c ****     /* Disable low power */
1588:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 3006              		.loc 1 1588 0
 3007 0000 084B     		ldr	r3, .L416
 3008 0002 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3009 0004 02F0FD02 		and	r2, r2, #253
 3010 0008 5A70     		strb	r2, [r3, #1]
1589:../drivers/fsl_clock.c **** 
1590:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal));
 3011              		.loc 1 1590 0
 3012 000a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3013 000c 02F03F02 		and	r2, r2, #63
 3014 0010 42F04002 		orr	r2, r2, #64
 3015 0014 1A70     		strb	r2, [r3]
 3016              	.L414:
1591:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
 3017              		.loc 1 1591 0 discriminator 1
 3018 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3019 0018 C2F38102 		ubfx	r2, r2, #2, #2
 3020 001c 012A     		cmp	r2, #1
 3021 001e FAD1     		bne	.L414
1592:../drivers/fsl_clock.c ****     {
1593:../drivers/fsl_clock.c ****     }
1594:../drivers/fsl_clock.c **** 
1595:../drivers/fsl_clock.c ****     return kStatus_Success;
1596:../drivers/fsl_clock.c **** }
 3022              		.loc 1 1596 0
 3023 0020 0020     		movs	r0, #0
 3024 0022 7047     		bx	lr
 3025              	.L417:
 3026              		.align	2
 3027              	.L416:
 3028 0024 00400640 		.word	1074151424
 3029              		.cfi_endproc
 3030              	.LFE192:
 3032              		.section	.text.CLOCK_BootToFeiMode,"ax",%progbits
 3033              		.align	1
 3034              		.global	CLOCK_BootToFeiMode
 3035              		.syntax unified
 3036              		.thumb
 3037              		.thumb_func
 3038              		.fpu fpv4-sp-d16
 3040              	CLOCK_BootToFeiMode:
 3041              	.LFB193:
1597:../drivers/fsl_clock.c **** 
1598:../drivers/fsl_clock.c **** status_t CLOCK_BootToFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1599:../drivers/fsl_clock.c **** {
 3042              		.loc 1 1599 0
 3043              		.cfi_startproc
 3044              		@ args = 0, pretend = 0, frame = 0
 3045              		@ frame_needed = 0, uses_anonymous_args = 0
 3046              		@ link register save eliminated.
 3047              	.LVL237:
1600:../drivers/fsl_clock.c ****     return CLOCK_SetFeiMode(dmx32, drs, fllStableDelay);
 3048              		.loc 1 1600 0
 3049 0000 FFF7FEBF 		b	CLOCK_SetFeiMode
 3050              	.LVL238:
 3051              		.cfi_endproc
 3052              	.LFE193:
 3054              		.section	.text.CLOCK_BootToFeeMode,"ax",%progbits
 3055              		.align	1
 3056              		.global	CLOCK_BootToFeeMode
 3057              		.syntax unified
 3058              		.thumb
 3059              		.thumb_func
 3060              		.fpu fpv4-sp-d16
 3062              	CLOCK_BootToFeeMode:
 3063              	.LFB194:
1601:../drivers/fsl_clock.c **** }
1602:../drivers/fsl_clock.c **** 
1603:../drivers/fsl_clock.c **** status_t CLOCK_BootToFeeMode(
1604:../drivers/fsl_clock.c ****     mcg_oscsel_t oscsel, uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(vo
1605:../drivers/fsl_clock.c **** {
 3064              		.loc 1 1605 0
 3065              		.cfi_startproc
 3066              		@ args = 4, pretend = 0, frame = 0
 3067              		@ frame_needed = 0, uses_anonymous_args = 0
 3068              	.LVL239:
 3069 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3070              		.cfi_def_cfa_offset 24
 3071              		.cfi_offset 4, -24
 3072              		.cfi_offset 5, -20
 3073              		.cfi_offset 6, -16
 3074              		.cfi_offset 7, -12
 3075              		.cfi_offset 8, -8
 3076              		.cfi_offset 14, -4
 3077              		.loc 1 1605 0
 3078 0004 069F     		ldr	r7, [sp, #24]
 3079 0006 0C46     		mov	r4, r1
 3080 0008 1546     		mov	r5, r2
 3081 000a 1E46     		mov	r6, r3
1606:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 3082              		.loc 1 1606 0
 3083 000c FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3084              	.LVL240:
1607:../drivers/fsl_clock.c **** 
1608:../drivers/fsl_clock.c ****     return CLOCK_SetFeeMode(frdiv, dmx32, drs, fllStableDelay);
 3085              		.loc 1 1608 0
 3086 0010 3B46     		mov	r3, r7
 3087 0012 3246     		mov	r2, r6
 3088 0014 2946     		mov	r1, r5
 3089 0016 2046     		mov	r0, r4
1609:../drivers/fsl_clock.c **** }
 3090              		.loc 1 1609 0
 3091 0018 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 3092              		.cfi_restore 14
 3093              		.cfi_restore 8
 3094              		.cfi_restore 7
 3095              		.cfi_restore 6
 3096              		.cfi_restore 5
 3097              		.cfi_restore 4
 3098              		.cfi_def_cfa_offset 0
 3099              	.LVL241:
1608:../drivers/fsl_clock.c **** }
 3100              		.loc 1 1608 0
 3101 001c FFF7FEBF 		b	CLOCK_SetFeeMode
 3102              	.LVL242:
 3103              		.cfi_endproc
 3104              	.LFE194:
 3106              		.section	.text.CLOCK_BootToBlpiMode,"ax",%progbits
 3107              		.align	1
 3108              		.global	CLOCK_BootToBlpiMode
 3109              		.syntax unified
 3110              		.thumb
 3111              		.thumb_func
 3112              		.fpu fpv4-sp-d16
 3114              	CLOCK_BootToBlpiMode:
 3115              	.LFB195:
1610:../drivers/fsl_clock.c **** 
1611:../drivers/fsl_clock.c **** status_t CLOCK_BootToBlpiMode(uint8_t fcrdiv, mcg_irc_mode_t ircs, uint8_t ircEnableMode)
1612:../drivers/fsl_clock.c **** {
 3116              		.loc 1 1612 0
 3117              		.cfi_startproc
 3118              		@ args = 0, pretend = 0, frame = 0
 3119              		@ frame_needed = 0, uses_anonymous_args = 0
 3120              	.LVL243:
 3121 0000 08B5     		push	{r3, lr}
 3122              		.cfi_def_cfa_offset 8
 3123              		.cfi_offset 3, -8
 3124              		.cfi_offset 14, -4
 3125              		.loc 1 1612 0
 3126 0002 1346     		mov	r3, r2
1613:../drivers/fsl_clock.c ****     /* If reset mode is FEI mode, set MCGIRCLK and always success. */
1614:../drivers/fsl_clock.c ****     CLOCK_SetInternalRefClkConfig(ircEnableMode, ircs, fcrdiv);
 3127              		.loc 1 1614 0
 3128 0004 0246     		mov	r2, r0
 3129              	.LVL244:
 3130 0006 1846     		mov	r0, r3
 3131              	.LVL245:
 3132 0008 FFF7FEFF 		bl	CLOCK_SetInternalRefClkConfig
 3133              	.LVL246:
1615:../drivers/fsl_clock.c **** 
1616:../drivers/fsl_clock.c ****     /* If reset mode is not BLPI, first enter FBI mode. */
1617:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal);
 3134              		.loc 1 1617 0
 3135 000c 084B     		ldr	r3, .L423
 3136 000e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3137 0010 02F03F02 		and	r2, r2, #63
 3138 0014 42F04002 		orr	r2, r2, #64
 3139 0018 1A70     		strb	r2, [r3]
 3140              	.L421:
1618:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
 3141              		.loc 1 1618 0 discriminator 1
 3142 001a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3143 001c C2F38102 		ubfx	r2, r2, #2, #2
 3144 0020 012A     		cmp	r2, #1
 3145 0022 FAD1     		bne	.L421
1619:../drivers/fsl_clock.c ****     {
1620:../drivers/fsl_clock.c ****     }
1621:../drivers/fsl_clock.c **** 
1622:../drivers/fsl_clock.c ****     /* Enter BLPI mode. */
1623:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 3146              		.loc 1 1623 0
 3147 0024 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3148 0026 42F00202 		orr	r2, r2, #2
 3149 002a 5A70     		strb	r2, [r3, #1]
1624:../drivers/fsl_clock.c **** 
1625:../drivers/fsl_clock.c ****     return kStatus_Success;
1626:../drivers/fsl_clock.c **** }
 3150              		.loc 1 1626 0
 3151 002c 0020     		movs	r0, #0
 3152 002e 08BD     		pop	{r3, pc}
 3153              	.L424:
 3154              		.align	2
 3155              	.L423:
 3156 0030 00400640 		.word	1074151424
 3157              		.cfi_endproc
 3158              	.LFE195:
 3160              		.section	.text.CLOCK_BootToBlpeMode,"ax",%progbits
 3161              		.align	1
 3162              		.global	CLOCK_BootToBlpeMode
 3163              		.syntax unified
 3164              		.thumb
 3165              		.thumb_func
 3166              		.fpu fpv4-sp-d16
 3168              	CLOCK_BootToBlpeMode:
 3169              	.LFB196:
1627:../drivers/fsl_clock.c **** 
1628:../drivers/fsl_clock.c **** status_t CLOCK_BootToBlpeMode(mcg_oscsel_t oscsel)
1629:../drivers/fsl_clock.c **** {
 3170              		.loc 1 1629 0
 3171              		.cfi_startproc
 3172              		@ args = 0, pretend = 0, frame = 0
 3173              		@ frame_needed = 0, uses_anonymous_args = 0
 3174              	.LVL247:
 3175 0000 08B5     		push	{r3, lr}
 3176              		.cfi_def_cfa_offset 8
 3177              		.cfi_offset 3, -8
 3178              		.cfi_offset 14, -4
1630:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 3179              		.loc 1 1630 0
 3180 0002 FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3181              	.LVL248:
1631:../drivers/fsl_clock.c **** 
1632:../drivers/fsl_clock.c ****     /* Set to FBE mode. */
1633:../drivers/fsl_clock.c ****     MCG->C1 =
1634:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 3182              		.loc 1 1634 0
 3183 0006 0E4B     		ldr	r3, .L435
 3184 0008 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3185 000a 02F03B02 		and	r2, r2, #59
 3186 000e 42F08002 		orr	r2, r2, #128
1633:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 3187              		.loc 1 1633 0
 3188 0012 1A70     		strb	r2, [r3]
1635:../drivers/fsl_clock.c ****                                                                 | MCG_C1_IREFS(kMCG_FllSrcExternal)
1636:../drivers/fsl_clock.c **** 
1637:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1638:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
 3189              		.loc 1 1638 0
 3190 0014 1A7B     		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 3191 0016 9007     		lsls	r0, r2, #30
 3192 0018 05D1     		bne	.L426
1639:../drivers/fsl_clock.c ****     {
1640:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 3193              		.loc 1 1640 0
 3194 001a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3195 001c 5107     		lsls	r1, r2, #29
 3196 001e 02D5     		bpl	.L426
 3197              	.L432:
1641:../drivers/fsl_clock.c ****         {
1642:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 3198              		.loc 1 1642 0 discriminator 1
 3199 0020 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3200 0022 9207     		lsls	r2, r2, #30
 3201 0024 FCD5     		bpl	.L432
 3202              	.L426:
1643:../drivers/fsl_clock.c ****             {
1644:../drivers/fsl_clock.c ****             }
1645:../drivers/fsl_clock.c ****         }
1646:../drivers/fsl_clock.c ****     }
1647:../drivers/fsl_clock.c **** 
1648:../drivers/fsl_clock.c ****     /* Wait for MCG_S[CLKST] and MCG_S[IREFST]. */
1649:../drivers/fsl_clock.c ****     while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
 3203              		.loc 1 1649 0 discriminator 1
 3204 0026 064B     		ldr	r3, .L435
 3205              	.L430:
 3206 0028 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3207 002a 02F01C02 		and	r2, r2, #28
 3208 002e 082A     		cmp	r2, #8
 3209 0030 FAD1     		bne	.L430
1650:../drivers/fsl_clock.c ****            (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
1651:../drivers/fsl_clock.c ****     {
1652:../drivers/fsl_clock.c ****     }
1653:../drivers/fsl_clock.c **** 
1654:../drivers/fsl_clock.c ****     /* In FBE now, start to enter BLPE. */
1655:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 3210              		.loc 1 1655 0
 3211 0032 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3212 0034 42F00202 		orr	r2, r2, #2
 3213 0038 5A70     		strb	r2, [r3, #1]
1656:../drivers/fsl_clock.c **** 
1657:../drivers/fsl_clock.c ****     return kStatus_Success;
1658:../drivers/fsl_clock.c **** }
 3214              		.loc 1 1658 0
 3215 003a 0020     		movs	r0, #0
 3216 003c 08BD     		pop	{r3, pc}
 3217              	.L436:
 3218 003e 00BF     		.align	2
 3219              	.L435:
 3220 0040 00400640 		.word	1074151424
 3221              		.cfi_endproc
 3222              	.LFE196:
 3224              		.section	.text.CLOCK_BootToPeeMode,"ax",%progbits
 3225              		.align	1
 3226              		.global	CLOCK_BootToPeeMode
 3227              		.syntax unified
 3228              		.thumb
 3229              		.thumb_func
 3230              		.fpu fpv4-sp-d16
 3232              	CLOCK_BootToPeeMode:
 3233              	.LFB197:
1659:../drivers/fsl_clock.c **** 
1660:../drivers/fsl_clock.c **** status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t cons
1661:../drivers/fsl_clock.c **** {
 3234              		.loc 1 1661 0
 3235              		.cfi_startproc
 3236              		@ args = 0, pretend = 0, frame = 0
 3237              		@ frame_needed = 0, uses_anonymous_args = 0
 3238              	.LVL249:
 3239 0000 38B5     		push	{r3, r4, r5, lr}
 3240              		.cfi_def_cfa_offset 16
 3241              		.cfi_offset 3, -16
 3242              		.cfi_offset 4, -12
 3243              		.cfi_offset 5, -8
 3244              		.cfi_offset 14, -4
 3245              		.loc 1 1661 0
 3246 0002 1546     		mov	r5, r2
 3247 0004 0C46     		mov	r4, r1
1662:../drivers/fsl_clock.c ****     assert(config);
1663:../drivers/fsl_clock.c **** 
1664:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 3248              		.loc 1 1664 0
 3249 0006 FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3250              	.LVL250:
1665:../drivers/fsl_clock.c **** 
1666:../drivers/fsl_clock.c ****     CLOCK_SetPbeMode(pllcs, config);
 3251              		.loc 1 1666 0
 3252 000a 2946     		mov	r1, r5
 3253 000c 2046     		mov	r0, r4
 3254 000e FFF7FEFF 		bl	CLOCK_SetPbeMode
 3255              	.LVL251:
1667:../drivers/fsl_clock.c **** 
1668:../drivers/fsl_clock.c ****     /* Change to use PLL output clock. */
1669:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
 3256              		.loc 1 1669 0
 3257 0012 064B     		ldr	r3, .L440
 3258 0014 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3259 0016 02F03F02 		and	r2, r2, #63
 3260 001a 1A70     		strb	r2, [r3]
 3261              	.L438:
1670:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
 3262              		.loc 1 1670 0 discriminator 1
 3263 001c 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3264 001e C2F38102 		ubfx	r2, r2, #2, #2
 3265 0022 032A     		cmp	r2, #3
 3266 0024 FAD1     		bne	.L438
1671:../drivers/fsl_clock.c ****     {
1672:../drivers/fsl_clock.c ****     }
1673:../drivers/fsl_clock.c **** 
1674:../drivers/fsl_clock.c ****     return kStatus_Success;
1675:../drivers/fsl_clock.c **** }
 3267              		.loc 1 1675 0
 3268 0026 0020     		movs	r0, #0
 3269 0028 38BD     		pop	{r3, r4, r5, pc}
 3270              	.LVL252:
 3271              	.L441:
 3272 002a 00BF     		.align	2
 3273              	.L440:
 3274 002c 00400640 		.word	1074151424
 3275              		.cfi_endproc
 3276              	.LFE197:
 3278              		.section	.text.CLOCK_SetMcgConfig,"ax",%progbits
 3279              		.align	1
 3280              		.global	CLOCK_SetMcgConfig
 3281              		.syntax unified
 3282              		.thumb
 3283              		.thumb_func
 3284              		.fpu fpv4-sp-d16
 3286              	CLOCK_SetMcgConfig:
 3287              	.LFB198:
1676:../drivers/fsl_clock.c **** 
1677:../drivers/fsl_clock.c **** /*
1678:../drivers/fsl_clock.c ****    The transaction matrix. It defines the path for mode switch, the row is for
1679:../drivers/fsl_clock.c ****    current mode and the column is target mode.
1680:../drivers/fsl_clock.c ****    For example, switch from FEI to PEE:
1681:../drivers/fsl_clock.c ****    1. Current mode FEI, next mode is mcgModeMatrix[FEI][PEE] = FBE, so swith to FBE.
1682:../drivers/fsl_clock.c ****    2. Current mode FBE, next mode is mcgModeMatrix[FBE][PEE] = PBE, so swith to PBE.
1683:../drivers/fsl_clock.c ****    3. Current mode PBE, next mode is mcgModeMatrix[PBE][PEE] = PEE, so swith to PEE.
1684:../drivers/fsl_clock.c ****    Thus the MCG mode has changed from FEI to PEE.
1685:../drivers/fsl_clock.c ****  */
1686:../drivers/fsl_clock.c **** static const mcg_mode_t mcgModeMatrix[8][8] = {
1687:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeF
1688:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FEI */
1689:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_Mode
1690:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FBI */
1691:../drivers/fsl_clock.c ****     {kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_Mode
1692:../drivers/fsl_clock.c ****      kMCG_ModeFBI}, /* BLPI */
1693:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeF
1694:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FEE */
1695:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1696:../drivers/fsl_clock.c ****      kMCG_ModePBE}, /* FBE */
1697:../drivers/fsl_clock.c ****     {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1698:../drivers/fsl_clock.c ****      kMCG_ModePBE}, /* BLPE */
1699:../drivers/fsl_clock.c ****     {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1700:../drivers/fsl_clock.c ****      kMCG_ModePEE}, /* PBE */
1701:../drivers/fsl_clock.c ****     {kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModeP
1702:../drivers/fsl_clock.c ****      kMCG_ModePBE} /* PEE */
1703:../drivers/fsl_clock.c ****     /*    FEI           FBI           BLPI           FEE           FBE           BLPE           PBE
1704:../drivers/fsl_clock.c **** };
1705:../drivers/fsl_clock.c **** 
1706:../drivers/fsl_clock.c **** status_t CLOCK_SetMcgConfig(const mcg_config_t *config)
1707:../drivers/fsl_clock.c **** {
 3288              		.loc 1 1707 0
 3289              		.cfi_startproc
 3290              		@ args = 0, pretend = 0, frame = 0
 3291              		@ frame_needed = 0, uses_anonymous_args = 0
 3292              	.LVL253:
 3293 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3294              		.cfi_def_cfa_offset 24
 3295              		.cfi_offset 3, -24
 3296              		.cfi_offset 4, -20
 3297              		.cfi_offset 5, -16
 3298              		.cfi_offset 6, -12
 3299              		.cfi_offset 7, -8
 3300              		.cfi_offset 14, -4
1708:../drivers/fsl_clock.c ****     mcg_mode_t next_mode;
1709:../drivers/fsl_clock.c ****     status_t status = kStatus_Success;
1710:../drivers/fsl_clock.c **** 
1711:../drivers/fsl_clock.c ****     mcg_pll_clk_select_t pllcs = kMCG_PllClkSelPll0;
1712:../drivers/fsl_clock.c **** 
1713:../drivers/fsl_clock.c ****     /* If need to change external clock, MCG_C7[OSCSEL]. */
1714:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL_VAL != config->oscsel)
 3301              		.loc 1 1714 0
 3302 0002 414A     		ldr	r2, .L465
 3303 0004 C179     		ldrb	r1, [r0, #7]	@ zero_extendqisi2
 3304 0006 137B     		ldrb	r3, [r2, #12]	@ zero_extendqisi2
 3305 0008 03F00303 		and	r3, r3, #3
 3306 000c 9942     		cmp	r1, r3
1707:../drivers/fsl_clock.c ****     mcg_mode_t next_mode;
 3307              		.loc 1 1707 0
 3308 000e 0446     		mov	r4, r0
 3309              		.loc 1 1714 0
 3310 0010 0DD0     		beq	.L443
1715:../drivers/fsl_clock.c ****     {
1716:../drivers/fsl_clock.c ****         /* If external clock is in use, change to FEI first. */
1717:../drivers/fsl_clock.c ****         if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 3311              		.loc 1 1717 0
 3312 0012 9279     		ldrb	r2, [r2, #6]	@ zero_extendqisi2
 3313 0014 12F01001 		ands	r1, r2, #16
 3314 0018 06D1     		bne	.L444
1718:../drivers/fsl_clock.c ****         {
1719:../drivers/fsl_clock.c ****             CLOCK_ExternalModeToFbeModeQuick();
 3315              		.loc 1 1719 0
 3316 001a FFF7FEFF 		bl	CLOCK_ExternalModeToFbeModeQuick
 3317              	.LVL254:
1720:../drivers/fsl_clock.c ****             CLOCK_SetFeiMode(config->dmx32, config->drs, (void (*)(void))0);
 3318              		.loc 1 1720 0
 3319 001e A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3320 0020 0A46     		mov	r2, r1
 3321 0022 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3322 0024 FFF7FEFF 		bl	CLOCK_SetFeiMode
 3323              	.LVL255:
 3324              	.L444:
1721:../drivers/fsl_clock.c ****         }
1722:../drivers/fsl_clock.c **** 
1723:../drivers/fsl_clock.c ****         CLOCK_SetExternalRefClkConfig(config->oscsel);
 3325              		.loc 1 1723 0
 3326 0028 E079     		ldrb	r0, [r4, #7]	@ zero_extendqisi2
 3327 002a FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3328              	.LVL256:
 3329              	.L443:
1724:../drivers/fsl_clock.c ****     }
1725:../drivers/fsl_clock.c **** 
1726:../drivers/fsl_clock.c ****     /* Re-configure MCGIRCLK, if MCGIRCLK is used as system clock source, then change to FEI/PEI fi
1727:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL == kMCG_ClkOutStatInt)
 3330              		.loc 1 1727 0
 3331 002e 364B     		ldr	r3, .L465
 3332 0030 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3333 0032 C2F38102 		ubfx	r2, r2, #2, #2
 3334 0036 012A     		cmp	r2, #1
 3335 0038 08D1     		bne	.L445
1728:../drivers/fsl_clock.c ****     {
1729:../drivers/fsl_clock.c ****         MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 3336              		.loc 1 1729 0
 3337 003a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3338 003c 02F0FD02 		and	r2, r2, #253
 3339 0040 5A70     		strb	r2, [r3, #1]
1730:../drivers/fsl_clock.c **** 
1731:../drivers/fsl_clock.c ****         {
1732:../drivers/fsl_clock.c ****             CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
 3340              		.loc 1 1732 0
 3341 0042 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3342 0044 314A     		ldr	r2, .L465+4
 3343 0046 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3344 0048 FFF7FEFF 		bl	CLOCK_SetFeiMode
 3345              	.LVL257:
 3346              	.L445:
1733:../drivers/fsl_clock.c ****         }
1734:../drivers/fsl_clock.c ****     }
1735:../drivers/fsl_clock.c **** 
1736:../drivers/fsl_clock.c ****     /* Configure MCGIRCLK. */
1737:../drivers/fsl_clock.c ****     CLOCK_SetInternalRefClkConfig(config->irclkEnableMode, config->ircs, config->fcrdiv);
 3347              		.loc 1 1737 0
 3348 004c E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 3349 004e A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 3350 0050 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
1738:../drivers/fsl_clock.c **** 
1739:../drivers/fsl_clock.c ****     next_mode = CLOCK_GetMode();
1740:../drivers/fsl_clock.c **** 
1741:../drivers/fsl_clock.c ****     do
1742:../drivers/fsl_clock.c ****     {
1743:../drivers/fsl_clock.c ****         next_mode = mcgModeMatrix[next_mode][config->mcgMode];
 3351              		.loc 1 1743 0
 3352 0052 2F4F     		ldr	r7, .L465+8
1744:../drivers/fsl_clock.c **** 
1745:../drivers/fsl_clock.c ****         switch (next_mode)
1746:../drivers/fsl_clock.c ****         {
1747:../drivers/fsl_clock.c ****             case kMCG_ModeFEI:
1748:../drivers/fsl_clock.c ****                 status = CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
1749:../drivers/fsl_clock.c ****                 break;
1750:../drivers/fsl_clock.c ****             case kMCG_ModeFEE:
1751:../drivers/fsl_clock.c ****                 status = CLOCK_SetFeeMode(config->frdiv, config->dmx32, config->drs, CLOCK_FllStabl
1752:../drivers/fsl_clock.c ****                 break;
1753:../drivers/fsl_clock.c ****             case kMCG_ModeFBI:
1754:../drivers/fsl_clock.c ****                 status = CLOCK_SetFbiMode(config->dmx32, config->drs, (void (*)(void))0);
1755:../drivers/fsl_clock.c ****                 break;
1756:../drivers/fsl_clock.c ****             case kMCG_ModeFBE:
1757:../drivers/fsl_clock.c ****                 status = CLOCK_SetFbeMode(config->frdiv, config->dmx32, config->drs, (void (*)(void
1758:../drivers/fsl_clock.c ****                 break;
1759:../drivers/fsl_clock.c ****             case kMCG_ModeBLPI:
1760:../drivers/fsl_clock.c ****                 status = CLOCK_SetBlpiMode();
1761:../drivers/fsl_clock.c ****                 break;
1762:../drivers/fsl_clock.c ****             case kMCG_ModeBLPE:
1763:../drivers/fsl_clock.c ****                 status = CLOCK_SetBlpeMode();
1764:../drivers/fsl_clock.c ****                 break;
1765:../drivers/fsl_clock.c ****             case kMCG_ModePBE:
1766:../drivers/fsl_clock.c ****                 /* If target mode is not PBE or PEE, then only need to set CLKS = EXT here. */
1767:../drivers/fsl_clock.c ****                 if ((kMCG_ModePEE == config->mcgMode) || (kMCG_ModePBE == config->mcgMode))
1768:../drivers/fsl_clock.c ****                 {
1769:../drivers/fsl_clock.c ****                     {
1770:../drivers/fsl_clock.c ****                         status = CLOCK_SetPbeMode(pllcs, &config->pll0Config);
1771:../drivers/fsl_clock.c ****                     }
1772:../drivers/fsl_clock.c ****                 }
1773:../drivers/fsl_clock.c ****                 else
1774:../drivers/fsl_clock.c ****                 {
1775:../drivers/fsl_clock.c ****                     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal))
 3353              		.loc 1 1775 0
 3354 0054 2C4E     		ldr	r6, .L465
1737:../drivers/fsl_clock.c **** 
 3355              		.loc 1 1737 0
 3356 0056 FFF7FEFF 		bl	CLOCK_SetInternalRefClkConfig
 3357              	.LVL258:
1739:../drivers/fsl_clock.c **** 
 3358              		.loc 1 1739 0
 3359 005a FFF7FEFF 		bl	CLOCK_GetMode
 3360              	.LVL259:
 3361 005e 0546     		mov	r5, r0
 3362              	.LVL260:
 3363              	.L461:
1743:../drivers/fsl_clock.c **** 
 3364              		.loc 1 1743 0
 3365 0060 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 3366 0062 07EBC505 		add	r5, r7, r5, lsl #3
 3367              	.LVL261:
 3368 0066 ED5C     		ldrb	r5, [r5, r3]	@ zero_extendqisi2
 3369              	.LVL262:
1745:../drivers/fsl_clock.c ****         {
 3370              		.loc 1 1745 0
 3371 0068 072D     		cmp	r5, #7
 3372 006a 37D8     		bhi	.L446
 3373 006c DFE805F0 		tbb	[pc, r5]
 3374              	.L448:
 3375 0070 04       		.byte	(.L447-.L448)/2
 3376 0071 12       		.byte	(.L449-.L448)/2
 3377 0072 1F       		.byte	(.L453-.L448)/2
 3378 0073 0B       		.byte	(.L451-.L448)/2
 3379 0074 18       		.byte	(.L452-.L448)/2
 3380 0075 1F       		.byte	(.L453-.L448)/2
 3381 0076 22       		.byte	(.L454-.L448)/2
 3382 0077 43       		.byte	(.L455-.L448)/2
 3383              		.p2align 1
 3384              	.L447:
1748:../drivers/fsl_clock.c ****                 break;
 3385              		.loc 1 1748 0
 3386 0078 244A     		ldr	r2, .L465+4
 3387 007a 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3388 007c A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3389 007e FFF7FEFF 		bl	CLOCK_SetFeiMode
 3390              	.LVL263:
 3391              	.L456:
1776:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
1777:../drivers/fsl_clock.c ****                     {
1778:../drivers/fsl_clock.c ****                     }
1779:../drivers/fsl_clock.c ****                 }
1780:../drivers/fsl_clock.c ****                 break;
1781:../drivers/fsl_clock.c ****             case kMCG_ModePEE:
1782:../drivers/fsl_clock.c ****                 status = CLOCK_SetPeeMode();
1783:../drivers/fsl_clock.c ****                 break;
1784:../drivers/fsl_clock.c ****             default:
1785:../drivers/fsl_clock.c ****                 break;
1786:../drivers/fsl_clock.c ****         }
1787:../drivers/fsl_clock.c ****         if (kStatus_Success != status)
 3392              		.loc 1 1787 0
 3393 0082 58B3     		cbz	r0, .L446
 3394              	.LVL264:
 3395              	.L442:
1788:../drivers/fsl_clock.c ****         {
1789:../drivers/fsl_clock.c ****             return status;
1790:../drivers/fsl_clock.c ****         }
1791:../drivers/fsl_clock.c ****     } while (next_mode != config->mcgMode);
1792:../drivers/fsl_clock.c **** 
1793:../drivers/fsl_clock.c ****     if (config->pll0Config.enableMode & kMCG_PllEnableIndependent)
1794:../drivers/fsl_clock.c ****     {
1795:../drivers/fsl_clock.c ****         CLOCK_EnablePll0(&config->pll0Config);
1796:../drivers/fsl_clock.c ****     }
1797:../drivers/fsl_clock.c ****     else
1798:../drivers/fsl_clock.c ****     {
1799:../drivers/fsl_clock.c ****         MCG->C5 &= ~(uint32_t)kMCG_PllEnableIndependent;
1800:../drivers/fsl_clock.c ****     }
1801:../drivers/fsl_clock.c ****     return kStatus_Success;
1802:../drivers/fsl_clock.c **** }
 3396              		.loc 1 1802 0
 3397 0084 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3398              	.LVL265:
 3399              	.L451:
1751:../drivers/fsl_clock.c ****                 break;
 3400              		.loc 1 1751 0
 3401 0086 214B     		ldr	r3, .L465+4
 3402 0088 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
 3403 008a A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3404 008c 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 3405 008e FFF7FEFF 		bl	CLOCK_SetFeeMode
 3406              	.LVL266:
1752:../drivers/fsl_clock.c ****             case kMCG_ModeFBI:
 3407              		.loc 1 1752 0
 3408 0092 F6E7     		b	.L456
 3409              	.LVL267:
 3410              	.L449:
1754:../drivers/fsl_clock.c ****                 break;
 3411              		.loc 1 1754 0
 3412 0094 0022     		movs	r2, #0
 3413 0096 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3414 0098 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3415 009a FFF7FEFF 		bl	CLOCK_SetFbiMode
 3416              	.LVL268:
1755:../drivers/fsl_clock.c ****             case kMCG_ModeFBE:
 3417              		.loc 1 1755 0
 3418 009e F0E7     		b	.L456
 3419              	.LVL269:
 3420              	.L452:
1757:../drivers/fsl_clock.c ****                 break;
 3421              		.loc 1 1757 0
 3422 00a0 0023     		movs	r3, #0
 3423 00a2 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
 3424 00a4 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3425 00a6 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 3426 00a8 FFF7FEFF 		bl	CLOCK_SetFbeMode
 3427              	.LVL270:
1758:../drivers/fsl_clock.c ****             case kMCG_ModeBLPI:
 3428              		.loc 1 1758 0
 3429 00ac E9E7     		b	.L456
 3430              	.LVL271:
 3431              	.L453:
1763:../drivers/fsl_clock.c ****                 break;
 3432              		.loc 1 1763 0
 3433 00ae FFF7FEFF 		bl	CLOCK_SetBlpeMode
 3434              	.LVL272:
1764:../drivers/fsl_clock.c ****             case kMCG_ModePBE:
 3435              		.loc 1 1764 0
 3436 00b2 E6E7     		b	.L456
 3437              	.LVL273:
 3438              	.L454:
1767:../drivers/fsl_clock.c ****                 {
 3439              		.loc 1 1767 0
 3440 00b4 063B     		subs	r3, r3, #6
 3441 00b6 012B     		cmp	r3, #1
 3442 00b8 05D8     		bhi	.L457
1770:../drivers/fsl_clock.c ****                     }
 3443              		.loc 1 1770 0
 3444 00ba 04F10801 		add	r1, r4, #8
 3445 00be 0020     		movs	r0, #0
 3446 00c0 FFF7FEFF 		bl	CLOCK_SetPbeMode
 3447              	.LVL274:
 3448 00c4 DDE7     		b	.L456
 3449              	.LVL275:
 3450              	.L457:
1775:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 3451              		.loc 1 1775 0
 3452 00c6 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3453 00c8 03F03F03 		and	r3, r3, #63
 3454 00cc 43F08003 		orr	r3, r3, #128
 3455 00d0 3370     		strb	r3, [r6]
 3456              	.L458:
1776:../drivers/fsl_clock.c ****                     {
 3457              		.loc 1 1776 0 discriminator 1
 3458 00d2 B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 3459 00d4 C3F38103 		ubfx	r3, r3, #2, #2
 3460 00d8 022B     		cmp	r3, #2
 3461 00da FAD1     		bne	.L458
 3462              	.LVL276:
 3463              	.L446:
1791:../drivers/fsl_clock.c **** 
 3464              		.loc 1 1791 0
 3465 00dc 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 3466 00de AB42     		cmp	r3, r5
 3467 00e0 BED1     		bne	.L461
1793:../drivers/fsl_clock.c ****     {
 3468              		.loc 1 1793 0
 3469 00e2 207A     		ldrb	r0, [r4, #8]	@ zero_extendqisi2
 3470 00e4 10F04000 		ands	r0, r0, #64
 3471 00e8 08D0     		beq	.L462
1795:../drivers/fsl_clock.c ****     }
 3472              		.loc 1 1795 0
 3473 00ea 04F10800 		add	r0, r4, #8
 3474 00ee FFF7FEFF 		bl	CLOCK_EnablePll0
 3475              	.LVL277:
1801:../drivers/fsl_clock.c **** }
 3476              		.loc 1 1801 0
 3477 00f2 0020     		movs	r0, #0
 3478 00f4 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3479              	.LVL278:
 3480              	.L455:
1782:../drivers/fsl_clock.c ****                 break;
 3481              		.loc 1 1782 0
 3482 00f6 FFF7FEFF 		bl	CLOCK_SetPeeMode
 3483              	.LVL279:
1783:../drivers/fsl_clock.c ****             default:
 3484              		.loc 1 1783 0
 3485 00fa C2E7     		b	.L456
 3486              	.LVL280:
 3487              	.L462:
1799:../drivers/fsl_clock.c ****     }
 3488              		.loc 1 1799 0
 3489 00fc 024A     		ldr	r2, .L465
 3490 00fe 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 3491 0100 03F0BF03 		and	r3, r3, #191
 3492 0104 1371     		strb	r3, [r2, #4]
 3493 0106 BDE7     		b	.L442
 3494              	.L466:
 3495              		.align	2
 3496              	.L465:
 3497 0108 00400640 		.word	1074151424
 3498 010c 00000000 		.word	CLOCK_FllStableDelay
 3499 0110 00000000 		.word	.LANCHOR4
 3500              		.cfi_endproc
 3501              	.LFE198:
 3503              		.comm	g_xtal32Freq,4,4
 3504              		.comm	g_xtal0Freq,4,4
 3505              		.section	.data.s_fastIrcFreq,"aw",%progbits
 3506              		.align	2
 3507              		.set	.LANCHOR1,. + 0
 3510              	s_fastIrcFreq:
 3511 0000 00093D00 		.word	4000000
 3512              		.section	.data.s_slowIrcFreq,"aw",%progbits
 3513              		.align	2
 3514              		.set	.LANCHOR0,. + 0
 3517              	s_slowIrcFreq:
 3518 0000 00800000 		.word	32768
 3519              		.section	.rodata.fllFactorTable.8146,"a",%progbits
 3520              		.align	1
 3521              		.set	.LANCHOR2,. + 0
 3524              	fllFactorTable.8146:
 3525 0000 8002     		.short	640
 3526 0002 DC02     		.short	732
 3527 0004 0005     		.short	1280
 3528 0006 B805     		.short	1464
 3529 0008 8007     		.short	1920
 3530 000a 9508     		.short	2197
 3531 000c 000A     		.short	2560
 3532 000e 710B     		.short	2929
 3533              		.section	.rodata.mcgModeMatrix,"a",%progbits
 3534              		.set	.LANCHOR4,. + 0
 3537              	mcgModeMatrix:
 3538 0000 00       		.byte	0
 3539 0001 01       		.byte	1
 3540 0002 01       		.byte	1
 3541 0003 03       		.byte	3
 3542 0004 04       		.byte	4
 3543 0005 04       		.byte	4
 3544 0006 04       		.byte	4
 3545 0007 04       		.byte	4
 3546 0008 00       		.byte	0
 3547 0009 01       		.byte	1
 3548 000a 02       		.byte	2
 3549 000b 03       		.byte	3
 3550 000c 04       		.byte	4
 3551 000d 04       		.byte	4
 3552 000e 04       		.byte	4
 3553 000f 04       		.byte	4
 3554 0010 01       		.byte	1
 3555 0011 01       		.byte	1
 3556 0012 02       		.byte	2
 3557 0013 01       		.byte	1
 3558 0014 01       		.byte	1
 3559 0015 01       		.byte	1
 3560 0016 01       		.byte	1
 3561 0017 01       		.byte	1
 3562 0018 00       		.byte	0
 3563 0019 01       		.byte	1
 3564 001a 01       		.byte	1
 3565 001b 03       		.byte	3
 3566 001c 04       		.byte	4
 3567 001d 04       		.byte	4
 3568 001e 04       		.byte	4
 3569 001f 04       		.byte	4
 3570 0020 00       		.byte	0
 3571 0021 01       		.byte	1
 3572 0022 01       		.byte	1
 3573 0023 03       		.byte	3
 3574 0024 04       		.byte	4
 3575 0025 05       		.byte	5
 3576 0026 06       		.byte	6
 3577 0027 06       		.byte	6
 3578 0028 04       		.byte	4
 3579 0029 04       		.byte	4
 3580 002a 04       		.byte	4
 3581 002b 04       		.byte	4
 3582 002c 04       		.byte	4
 3583 002d 05       		.byte	5
 3584 002e 06       		.byte	6
 3585 002f 06       		.byte	6
 3586 0030 04       		.byte	4
 3587 0031 04       		.byte	4
 3588 0032 04       		.byte	4
 3589 0033 04       		.byte	4
 3590 0034 04       		.byte	4
 3591 0035 05       		.byte	5
 3592 0036 06       		.byte	6
 3593 0037 07       		.byte	7
 3594 0038 06       		.byte	6
 3595 0039 06       		.byte	6
 3596 003a 06       		.byte	6
 3597 003b 06       		.byte	6
 3598 003c 06       		.byte	6
 3599 003d 06       		.byte	6
 3600 003e 06       		.byte	6
 3601 003f 06       		.byte	6
 3602              		.section	.rodata.trimRange.8248,"a",%progbits
 3603              		.align	2
 3604              		.set	.LANCHOR3,. + 0
 3607              	trimRange.8248:
 3608 0000 127A0000 		.word	31250
 3609 0004 97980000 		.word	39063
 3610 0008 C0C62D00 		.word	3000000
 3611 000c 404B4C00 		.word	5000000
 3612              		.text
 3613              	.Letext0:
 3614              		.file 3 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 3615              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 3616              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 3617              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 3618              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 3619              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 3620              		.file 9 "../CMSIS/core_cm4.h"
 3621              		.file 10 "../CMSIS/system_MK64F12.h"
 3622              		.file 11 "../CMSIS/MK64F12.h"
 3623              		.file 12 "../drivers/fsl_common.h"
