   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_clock.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.CLOCK_FllStableDelay,"ax",%progbits
  18              		.align	1
  19              		.global	CLOCK_FllStableDelay
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	CLOCK_FllStableDelay:
  26              	.LFB147:
  27              		.file 1 "../drivers/fsl_clock.c"
   1:../drivers/fsl_clock.c **** /*
   2:../drivers/fsl_clock.c ****  * The Clear BSD License
   3:../drivers/fsl_clock.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.c ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.c ****  * All rights reserved.
   6:../drivers/fsl_clock.c ****  *
   7:../drivers/fsl_clock.c ****  *
   8:../drivers/fsl_clock.c ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.c ****  * that the following conditions are met:
  11:../drivers/fsl_clock.c ****  *
  12:../drivers/fsl_clock.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.c ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.c ****  *
  15:../drivers/fsl_clock.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.c ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.c ****  *
  19:../drivers/fsl_clock.c ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.c ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.c ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.c ****  *
  23:../drivers/fsl_clock.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.c ****  */
  35:../drivers/fsl_clock.c **** 
  36:../drivers/fsl_clock.c **** #include "fsl_clock.h"
  37:../drivers/fsl_clock.c **** 
  38:../drivers/fsl_clock.c **** /*******************************************************************************
  39:../drivers/fsl_clock.c ****  * Definitions
  40:../drivers/fsl_clock.c ****  ******************************************************************************/
  41:../drivers/fsl_clock.c **** 
  42:../drivers/fsl_clock.c **** /* Macro definition remap workaround. */
  43:../drivers/fsl_clock.c **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
  44:../drivers/fsl_clock.c **** #define MCG_C2_EREFS0_MASK MCG_C2_EREFS_MASK
  45:../drivers/fsl_clock.c **** #endif
  46:../drivers/fsl_clock.c **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
  47:../drivers/fsl_clock.c **** #define MCG_C2_HGO0_MASK MCG_C2_HGO_MASK
  48:../drivers/fsl_clock.c **** #endif
  49:../drivers/fsl_clock.c **** #if (defined(MCG_C2_RANGE_MASK) && !(defined(MCG_C2_RANGE0_MASK)))
  50:../drivers/fsl_clock.c **** #define MCG_C2_RANGE0_MASK MCG_C2_RANGE_MASK
  51:../drivers/fsl_clock.c **** #endif
  52:../drivers/fsl_clock.c **** #if (defined(MCG_C6_CME_MASK) && !(defined(MCG_C6_CME0_MASK)))
  53:../drivers/fsl_clock.c **** #define MCG_C6_CME0_MASK MCG_C6_CME_MASK
  54:../drivers/fsl_clock.c **** #endif
  55:../drivers/fsl_clock.c **** 
  56:../drivers/fsl_clock.c **** /* PLL fixed multiplier when there is not PRDIV and VDIV. */
  57:../drivers/fsl_clock.c **** #define PLL_FIXED_MULT (375U)
  58:../drivers/fsl_clock.c **** /* Max frequency of the reference clock used for internal clock trim. */
  59:../drivers/fsl_clock.c **** #define TRIM_REF_CLK_MIN (8000000U)
  60:../drivers/fsl_clock.c **** /* Min frequency of the reference clock used for internal clock trim. */
  61:../drivers/fsl_clock.c **** #define TRIM_REF_CLK_MAX (16000000U)
  62:../drivers/fsl_clock.c **** /* Max trim value of fast internal reference clock. */
  63:../drivers/fsl_clock.c **** #define TRIM_FIRC_MAX (5000000U)
  64:../drivers/fsl_clock.c **** /* Min trim value of fast internal reference clock. */
  65:../drivers/fsl_clock.c **** #define TRIM_FIRC_MIN (3000000U)
  66:../drivers/fsl_clock.c **** /* Max trim value of fast internal reference clock. */
  67:../drivers/fsl_clock.c **** #define TRIM_SIRC_MAX (39063U)
  68:../drivers/fsl_clock.c **** /* Min trim value of fast internal reference clock. */
  69:../drivers/fsl_clock.c **** #define TRIM_SIRC_MIN (31250U)
  70:../drivers/fsl_clock.c **** 
  71:../drivers/fsl_clock.c **** #define MCG_S_IRCST_VAL ((MCG->S & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
  72:../drivers/fsl_clock.c **** #define MCG_S_CLKST_VAL ((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
  73:../drivers/fsl_clock.c **** #define MCG_S_IREFST_VAL ((MCG->S & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
  74:../drivers/fsl_clock.c **** #define MCG_S_PLLST_VAL ((MCG->S & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
  75:../drivers/fsl_clock.c **** #define MCG_C1_FRDIV_VAL ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
  76:../drivers/fsl_clock.c **** #define MCG_C2_LP_VAL ((MCG->C2 & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
  77:../drivers/fsl_clock.c **** #define MCG_C2_RANGE_VAL ((MCG->C2 & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
  78:../drivers/fsl_clock.c **** #define MCG_SC_FCRDIV_VAL ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
  79:../drivers/fsl_clock.c **** #define MCG_S2_PLLCST_VAL ((MCG->S2 & MCG_S2_PLLCST_MASK) >> MCG_S2_PLLCST_SHIFT)
  80:../drivers/fsl_clock.c **** #define MCG_C7_OSCSEL_VAL ((MCG->C7 & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
  81:../drivers/fsl_clock.c **** #define MCG_C4_DMX32_VAL ((MCG->C4 & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
  82:../drivers/fsl_clock.c **** #define MCG_C4_DRST_DRS_VAL ((MCG->C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
  83:../drivers/fsl_clock.c **** #define MCG_C7_PLL32KREFSEL_VAL ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) >> MCG_C7_PLL32KREFSEL_SHIFT)
  84:../drivers/fsl_clock.c **** #define MCG_C5_PLLREFSEL0_VAL ((MCG->C5 & MCG_C5_PLLREFSEL0_MASK) >> MCG_C5_PLLREFSEL0_SHIFT)
  85:../drivers/fsl_clock.c **** #define MCG_C11_PLLREFSEL1_VAL ((MCG->C11 & MCG_C11_PLLREFSEL1_MASK) >> MCG_C11_PLLREFSEL1_SHIFT)
  86:../drivers/fsl_clock.c **** #define MCG_C11_PRDIV1_VAL ((MCG->C11 & MCG_C11_PRDIV1_MASK) >> MCG_C11_PRDIV1_SHIFT)
  87:../drivers/fsl_clock.c **** #define MCG_C12_VDIV1_VAL ((MCG->C12 & MCG_C12_VDIV1_MASK) >> MCG_C12_VDIV1_SHIFT)
  88:../drivers/fsl_clock.c **** #define MCG_C5_PRDIV0_VAL ((MCG->C5 & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
  89:../drivers/fsl_clock.c **** #define MCG_C6_VDIV0_VAL ((MCG->C6 & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
  90:../drivers/fsl_clock.c **** 
  91:../drivers/fsl_clock.c **** #define OSC_MODE_MASK (MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK | MCG_C2_RANGE0_MASK)
  92:../drivers/fsl_clock.c **** 
  93:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV1_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_S
  94:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV2_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_S
  95:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV3_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_S
  96:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV4_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_S
  97:../drivers/fsl_clock.c **** #define SIM_SOPT1_OSC32KSEL_VAL ((SIM->SOPT1 & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHI
  98:../drivers/fsl_clock.c **** #define SIM_SOPT2_PLLFLLSEL_VAL ((SIM->SOPT2 & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHI
  99:../drivers/fsl_clock.c **** 
 100:../drivers/fsl_clock.c **** /* MCG_S_CLKST definition. */
 101:../drivers/fsl_clock.c **** enum _mcg_clkout_stat
 102:../drivers/fsl_clock.c **** {
 103:../drivers/fsl_clock.c ****     kMCG_ClkOutStatFll, /* FLL.            */
 104:../drivers/fsl_clock.c ****     kMCG_ClkOutStatInt, /* Internal clock. */
 105:../drivers/fsl_clock.c ****     kMCG_ClkOutStatExt, /* External clock. */
 106:../drivers/fsl_clock.c ****     kMCG_ClkOutStatPll  /* PLL.            */
 107:../drivers/fsl_clock.c **** };
 108:../drivers/fsl_clock.c **** 
 109:../drivers/fsl_clock.c **** /* MCG_S_PLLST definition. */
 110:../drivers/fsl_clock.c **** enum _mcg_pllst
 111:../drivers/fsl_clock.c **** {
 112:../drivers/fsl_clock.c ****     kMCG_PllstFll, /* FLL is used. */
 113:../drivers/fsl_clock.c ****     kMCG_PllstPll  /* PLL is used. */
 114:../drivers/fsl_clock.c **** };
 115:../drivers/fsl_clock.c **** 
 116:../drivers/fsl_clock.c **** /*******************************************************************************
 117:../drivers/fsl_clock.c ****  * Variables
 118:../drivers/fsl_clock.c ****  ******************************************************************************/
 119:../drivers/fsl_clock.c **** 
 120:../drivers/fsl_clock.c **** /* Slow internal reference clock frequency. */
 121:../drivers/fsl_clock.c **** static uint32_t s_slowIrcFreq = 32768U;
 122:../drivers/fsl_clock.c **** /* Fast internal reference clock frequency. */
 123:../drivers/fsl_clock.c **** static uint32_t s_fastIrcFreq = 4000000U;
 124:../drivers/fsl_clock.c **** 
 125:../drivers/fsl_clock.c **** /* External XTAL0 (OSC0) clock frequency. */
 126:../drivers/fsl_clock.c **** uint32_t g_xtal0Freq;
 127:../drivers/fsl_clock.c **** /* External XTAL32K clock frequency. */
 128:../drivers/fsl_clock.c **** uint32_t g_xtal32Freq;
 129:../drivers/fsl_clock.c **** 
 130:../drivers/fsl_clock.c **** /*******************************************************************************
 131:../drivers/fsl_clock.c ****  * Prototypes
 132:../drivers/fsl_clock.c ****  ******************************************************************************/
 133:../drivers/fsl_clock.c **** 
 134:../drivers/fsl_clock.c **** /*!
 135:../drivers/fsl_clock.c ****  * @brief Get the MCG external reference clock frequency.
 136:../drivers/fsl_clock.c ****  *
 137:../drivers/fsl_clock.c ****  * Get the current MCG external reference clock frequency in Hz. It is
 138:../drivers/fsl_clock.c ****  * the frequency select by MCG_C7[OSCSEL]. This is an internal function.
 139:../drivers/fsl_clock.c ****  *
 140:../drivers/fsl_clock.c ****  * @return MCG external reference clock frequency in Hz.
 141:../drivers/fsl_clock.c ****  */
 142:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetMcgExtClkFreq(void);
 143:../drivers/fsl_clock.c **** 
 144:../drivers/fsl_clock.c **** /*!
 145:../drivers/fsl_clock.c ****  * @brief Get the MCG FLL external reference clock frequency.
 146:../drivers/fsl_clock.c ****  *
 147:../drivers/fsl_clock.c ****  * Get the current MCG FLL external reference clock frequency in Hz. It is
 148:../drivers/fsl_clock.c ****  * the frequency after by MCG_C1[FRDIV]. This is an internal function.
 149:../drivers/fsl_clock.c ****  *
 150:../drivers/fsl_clock.c ****  * @return MCG FLL external reference clock frequency in Hz.
 151:../drivers/fsl_clock.c ****  */
 152:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllExtRefClkFreq(void);
 153:../drivers/fsl_clock.c **** 
 154:../drivers/fsl_clock.c **** /*!
 155:../drivers/fsl_clock.c ****  * @brief Get the MCG FLL reference clock frequency.
 156:../drivers/fsl_clock.c ****  *
 157:../drivers/fsl_clock.c ****  * Get the current MCG FLL reference clock frequency in Hz. It is
 158:../drivers/fsl_clock.c ****  * the frequency select by MCG_C1[IREFS]. This is an internal function.
 159:../drivers/fsl_clock.c ****  *
 160:../drivers/fsl_clock.c ****  * @return MCG FLL reference clock frequency in Hz.
 161:../drivers/fsl_clock.c ****  */
 162:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllRefClkFreq(void);
 163:../drivers/fsl_clock.c **** 
 164:../drivers/fsl_clock.c **** /*!
 165:../drivers/fsl_clock.c ****  * @brief Get the frequency of clock selected by MCG_C2[IRCS].
 166:../drivers/fsl_clock.c ****  *
 167:../drivers/fsl_clock.c ****  * This clock's two output:
 168:../drivers/fsl_clock.c ****  *  1. MCGOUTCLK when MCG_S[CLKST]=0.
 169:../drivers/fsl_clock.c ****  *  2. MCGIRCLK when MCG_C1[IRCLKEN]=1.
 170:../drivers/fsl_clock.c ****  *
 171:../drivers/fsl_clock.c ****  * @return The frequency in Hz.
 172:../drivers/fsl_clock.c ****  */
 173:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetInternalRefClkSelectFreq(void);
 174:../drivers/fsl_clock.c **** 
 175:../drivers/fsl_clock.c **** /*!
 176:../drivers/fsl_clock.c ****  * @brief Get the MCG PLL/PLL0 reference clock frequency.
 177:../drivers/fsl_clock.c ****  *
 178:../drivers/fsl_clock.c ****  * Get the current MCG PLL/PLL0 reference clock frequency in Hz.
 179:../drivers/fsl_clock.c ****  * This is an internal function.
 180:../drivers/fsl_clock.c ****  *
 181:../drivers/fsl_clock.c ****  * @return MCG PLL/PLL0 reference clock frequency in Hz.
 182:../drivers/fsl_clock.c ****  */
 183:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetPll0RefFreq(void);
 184:../drivers/fsl_clock.c **** 
 185:../drivers/fsl_clock.c **** /*!
 186:../drivers/fsl_clock.c ****  * @brief Calculate the RANGE value base on crystal frequency.
 187:../drivers/fsl_clock.c ****  *
 188:../drivers/fsl_clock.c ****  * To setup external crystal oscillator, must set the register bits RANGE
 189:../drivers/fsl_clock.c ****  * base on the crystal frequency. This function returns the RANGE base on the
 190:../drivers/fsl_clock.c ****  * input frequency. This is an internal function.
 191:../drivers/fsl_clock.c ****  *
 192:../drivers/fsl_clock.c ****  * @param freq Crystal frequency in Hz.
 193:../drivers/fsl_clock.c ****  * @return The RANGE value.
 194:../drivers/fsl_clock.c ****  */
 195:../drivers/fsl_clock.c **** static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq);
 196:../drivers/fsl_clock.c **** 
 197:../drivers/fsl_clock.c **** /*******************************************************************************
 198:../drivers/fsl_clock.c ****  * Code
 199:../drivers/fsl_clock.c ****  ******************************************************************************/
 200:../drivers/fsl_clock.c **** 
 201:../drivers/fsl_clock.c **** #ifndef MCG_USER_CONFIG_FLL_STABLE_DELAY_EN
 202:../drivers/fsl_clock.c **** /*!
 203:../drivers/fsl_clock.c ****  * @brief Delay function to wait FLL stable.
 204:../drivers/fsl_clock.c ****  *
 205:../drivers/fsl_clock.c ****  * Delay function to wait FLL stable in FEI mode or FEE mode, should wait at least
 206:../drivers/fsl_clock.c ****  * 1ms. Every time changes FLL setting, should wait this time for FLL stable.
 207:../drivers/fsl_clock.c ****  */
 208:../drivers/fsl_clock.c **** void CLOCK_FllStableDelay(void)
 209:../drivers/fsl_clock.c **** {
  28              		.loc 1 209 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33 0000 82B0     		sub	sp, sp, #8
  34              		.cfi_def_cfa_offset 8
 210:../drivers/fsl_clock.c ****     /*
 211:../drivers/fsl_clock.c ****        Should wait at least 1ms. Because in these modes, the core clock is 100MHz
 212:../drivers/fsl_clock.c ****        at most, so this function could obtain the 1ms delay.
 213:../drivers/fsl_clock.c ****      */
 214:../drivers/fsl_clock.c ****     volatile uint32_t i = 30000U;
  35              		.loc 1 214 0
  36 0002 47F23053 		movw	r3, #30000
  37 0006 0193     		str	r3, [sp, #4]
  38              	.L2:
 215:../drivers/fsl_clock.c ****     while (i--)
  39              		.loc 1 215 0
  40 0008 019B     		ldr	r3, [sp, #4]
  41 000a 5A1E     		subs	r2, r3, #1
  42 000c 0192     		str	r2, [sp, #4]
  43 000e 0BB9     		cbnz	r3, .L3
 216:../drivers/fsl_clock.c ****     {
 217:../drivers/fsl_clock.c ****         __NOP();
 218:../drivers/fsl_clock.c ****     }
 219:../drivers/fsl_clock.c **** }
  44              		.loc 1 219 0
  45 0010 02B0     		add	sp, sp, #8
  46              		.cfi_remember_state
  47              		.cfi_def_cfa_offset 0
  48              		@ sp needed
  49 0012 7047     		bx	lr
  50              	.L3:
  51              		.cfi_restore_state
 217:../drivers/fsl_clock.c ****     }
  52              		.loc 1 217 0
  53              		.syntax unified
  54              	@ 217 "../drivers/fsl_clock.c" 1
  55 0014 00BF     		nop
  56              	@ 0 "" 2
  57              		.thumb
  58              		.syntax unified
  59 0016 F7E7     		b	.L2
  60              		.cfi_endproc
  61              	.LFE147:
  63              		.section	.text.CLOCK_GetMcgExtClkFreq,"ax",%progbits
  64              		.align	1
  65              		.syntax unified
  66              		.thumb
  67              		.thumb_func
  68              		.fpu fpv4-sp-d16
  70              	CLOCK_GetMcgExtClkFreq:
  71              	.LFB148:
 220:../drivers/fsl_clock.c **** #else  /* With MCG_USER_CONFIG_FLL_STABLE_DELAY_EN defined. */
 221:../drivers/fsl_clock.c **** /* Once user defines the MCG_USER_CONFIG_FLL_STABLE_DELAY_EN to use their own delay function, he ha
 222:../drivers/fsl_clock.c ****  * create his own CLOCK_FllStableDelay() function in application code. Since the clock functions in
 223:../drivers/fsl_clock.c ****  * file would call the CLOCK_FllStableDelay() regardness how it is defined.
 224:../drivers/fsl_clock.c ****  */
 225:../drivers/fsl_clock.c **** extern void CLOCK_FllStableDelay(void);
 226:../drivers/fsl_clock.c **** #endif /* MCG_USER_CONFIG_FLL_STABLE_DELAY_EN */
 227:../drivers/fsl_clock.c **** 
 228:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetMcgExtClkFreq(void)
 229:../drivers/fsl_clock.c **** {
  72              		.loc 1 229 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76              		@ link register save eliminated.
 230:../drivers/fsl_clock.c ****     uint32_t freq;
 231:../drivers/fsl_clock.c **** 
 232:../drivers/fsl_clock.c ****     switch (MCG_C7_OSCSEL_VAL)
  77              		.loc 1 232 0
  78 0000 084B     		ldr	r3, .L11
  79 0002 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
  80 0004 03F00303 		and	r3, r3, #3
  81 0008 012B     		cmp	r3, #1
  82 000a 08D0     		beq	.L6
  83 000c 04D3     		bcc	.L7
  84 000e 022B     		cmp	r3, #2
 233:../drivers/fsl_clock.c ****     {
 234:../drivers/fsl_clock.c ****         case 0U:
 235:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
 236:../drivers/fsl_clock.c ****             assert(g_xtal0Freq);
 237:../drivers/fsl_clock.c ****             freq = g_xtal0Freq;
 238:../drivers/fsl_clock.c ****             break;
 239:../drivers/fsl_clock.c ****         case 1U:
 240:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN
 241:../drivers/fsl_clock.c ****             assert(g_xtal32Freq);
 242:../drivers/fsl_clock.c ****             freq = g_xtal32Freq;
 243:../drivers/fsl_clock.c ****             break;
 244:../drivers/fsl_clock.c ****         case 2U:
 245:../drivers/fsl_clock.c ****             freq = MCG_INTERNAL_IRC_48M;
 246:../drivers/fsl_clock.c ****             break;
 247:../drivers/fsl_clock.c ****         default:
 248:../drivers/fsl_clock.c ****             freq = 0U;
  85              		.loc 1 248 0
  86 0010 0548     		ldr	r0, .L11+4
  87 0012 18BF     		it	ne
  88 0014 0020     		movne	r0, #0
  89 0016 7047     		bx	lr
  90              	.L7:
 237:../drivers/fsl_clock.c ****             break;
  91              		.loc 1 237 0
  92 0018 044B     		ldr	r3, .L11+8
  93              	.L10:
 242:../drivers/fsl_clock.c ****             break;
  94              		.loc 1 242 0
  95 001a 1868     		ldr	r0, [r3]
  96              	.LVL0:
 249:../drivers/fsl_clock.c ****             break;
 250:../drivers/fsl_clock.c ****     }
 251:../drivers/fsl_clock.c **** 
 252:../drivers/fsl_clock.c ****     return freq;
 253:../drivers/fsl_clock.c **** }
  97              		.loc 1 253 0
  98 001c 7047     		bx	lr
  99              	.LVL1:
 100              	.L6:
 242:../drivers/fsl_clock.c ****             break;
 101              		.loc 1 242 0
 102 001e 044B     		ldr	r3, .L11+12
 103 0020 FBE7     		b	.L10
 104              	.L12:
 105 0022 00BF     		.align	2
 106              	.L11:
 107 0024 00400640 		.word	1074151424
 108 0028 006CDC02 		.word	48000000
 109 002c 00000000 		.word	g_xtal0Freq
 110 0030 00000000 		.word	g_xtal32Freq
 111              		.cfi_endproc
 112              	.LFE148:
 114              		.section	.text.CLOCK_GetFllExtRefClkFreq,"ax",%progbits
 115              		.align	1
 116              		.syntax unified
 117              		.thumb
 118              		.thumb_func
 119              		.fpu fpv4-sp-d16
 121              	CLOCK_GetFllExtRefClkFreq:
 122              	.LFB149:
 254:../drivers/fsl_clock.c **** 
 255:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllExtRefClkFreq(void)
 256:../drivers/fsl_clock.c **** {
 123              		.loc 1 256 0
 124              		.cfi_startproc
 125              		@ args = 0, pretend = 0, frame = 0
 126              		@ frame_needed = 0, uses_anonymous_args = 0
 127 0000 08B5     		push	{r3, lr}
 128              		.cfi_def_cfa_offset 8
 129              		.cfi_offset 3, -8
 130              		.cfi_offset 14, -4
 257:../drivers/fsl_clock.c ****     /* FllExtRef = McgExtRef / FllExtRefDiv */
 258:../drivers/fsl_clock.c ****     uint8_t frdiv;
 259:../drivers/fsl_clock.c ****     uint8_t range;
 260:../drivers/fsl_clock.c ****     uint8_t oscsel;
 261:../drivers/fsl_clock.c **** 
 262:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetMcgExtClkFreq();
 131              		.loc 1 262 0
 132 0002 FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 133              	.LVL2:
 263:../drivers/fsl_clock.c **** 
 264:../drivers/fsl_clock.c ****     if (!freq)
 134              		.loc 1 264 0
 135 0006 A0B1     		cbz	r0, .L13
 265:../drivers/fsl_clock.c ****     {
 266:../drivers/fsl_clock.c ****         return freq;
 267:../drivers/fsl_clock.c ****     }
 268:../drivers/fsl_clock.c **** 
 269:../drivers/fsl_clock.c ****     frdiv = MCG_C1_FRDIV_VAL;
 136              		.loc 1 269 0
 137 0008 0D4A     		ldr	r2, .L30
 138 000a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 270:../drivers/fsl_clock.c ****     freq >>= frdiv;
 271:../drivers/fsl_clock.c **** 
 272:../drivers/fsl_clock.c ****     range = MCG_C2_RANGE_VAL;
 139              		.loc 1 272 0
 140 000c 5178     		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 273:../drivers/fsl_clock.c ****     oscsel = MCG_C7_OSCSEL_VAL;
 141              		.loc 1 273 0
 142 000e 127B     		ldrb	r2, [r2, #12]	@ zero_extendqisi2
 269:../drivers/fsl_clock.c ****     freq >>= frdiv;
 143              		.loc 1 269 0
 144 0010 C3F3C203 		ubfx	r3, r3, #3, #3
 145              	.LVL3:
 274:../drivers/fsl_clock.c **** 
 275:../drivers/fsl_clock.c ****     /*
 276:../drivers/fsl_clock.c ****        When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
 277:../drivers/fsl_clock.c ****        1. MCG_C7[OSCSEL] selects IRC48M.
 278:../drivers/fsl_clock.c ****        2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
 279:../drivers/fsl_clock.c ****     */
 280:../drivers/fsl_clock.c ****     if (((0U != range) && (kMCG_OscselOsc == oscsel)) || (kMCG_OscselIrc == oscsel))
 146              		.loc 1 280 0
 147 0014 11F0300F 		tst	r1, #48
 270:../drivers/fsl_clock.c **** 
 148              		.loc 1 270 0
 149 0018 20FA03F0 		lsr	r0, r0, r3
 150              	.LVL4:
 273:../drivers/fsl_clock.c **** 
 151              		.loc 1 273 0
 152 001c 02F00302 		and	r2, r2, #3
 153              	.LVL5:
 154              		.loc 1 280 0
 155 0020 00D0     		beq	.L15
 156              		.loc 1 280 0 is_stmt 0 discriminator 1
 157 0022 0AB1     		cbz	r2, .L16
 158              	.L15:
 159              		.loc 1 280 0 discriminator 3
 160 0024 022A     		cmp	r2, #2
 161 0026 04D1     		bne	.L13
 162              	.L16:
 281:../drivers/fsl_clock.c ****     {
 282:../drivers/fsl_clock.c ****         switch (frdiv)
 163              		.loc 1 282 0 is_stmt 1
 164 0028 062B     		cmp	r3, #6
 165 002a 03D0     		beq	.L18
 166 002c 072B     		cmp	r3, #7
 167 002e 05D0     		beq	.L19
 283:../drivers/fsl_clock.c ****         {
 284:../drivers/fsl_clock.c ****             case 0:
 285:../drivers/fsl_clock.c ****             case 1:
 286:../drivers/fsl_clock.c ****             case 2:
 287:../drivers/fsl_clock.c ****             case 3:
 288:../drivers/fsl_clock.c ****             case 4:
 289:../drivers/fsl_clock.c ****             case 5:
 290:../drivers/fsl_clock.c ****                 freq >>= 5u;
 168              		.loc 1 290 0
 169 0030 4009     		lsrs	r0, r0, #5
 170              	.LVL6:
 171              	.L13:
 291:../drivers/fsl_clock.c ****                 break;
 292:../drivers/fsl_clock.c ****             case 6:
 293:../drivers/fsl_clock.c ****                 /* 64*20=1280 */
 294:../drivers/fsl_clock.c ****                 freq /= 20u;
 295:../drivers/fsl_clock.c ****                 break;
 296:../drivers/fsl_clock.c ****             case 7:
 297:../drivers/fsl_clock.c ****                 /* 128*12=1536 */
 298:../drivers/fsl_clock.c ****                 freq /= 12u;
 299:../drivers/fsl_clock.c ****                 break;
 300:../drivers/fsl_clock.c ****             default:
 301:../drivers/fsl_clock.c ****                 freq = 0u;
 302:../drivers/fsl_clock.c ****                 break;
 303:../drivers/fsl_clock.c ****         }
 304:../drivers/fsl_clock.c ****     }
 305:../drivers/fsl_clock.c **** 
 306:../drivers/fsl_clock.c ****     return freq;
 307:../drivers/fsl_clock.c **** }
 172              		.loc 1 307 0
 173 0032 08BD     		pop	{r3, pc}
 174              	.LVL7:
 175              	.L18:
 294:../drivers/fsl_clock.c ****                 break;
 176              		.loc 1 294 0
 177 0034 1423     		movs	r3, #20
 178              	.LVL8:
 179              	.L29:
 298:../drivers/fsl_clock.c ****                 break;
 180              		.loc 1 298 0
 181 0036 B0FBF3F0 		udiv	r0, r0, r3
 182              	.LVL9:
 299:../drivers/fsl_clock.c ****             default:
 183              		.loc 1 299 0
 184 003a FAE7     		b	.L13
 185              	.LVL10:
 186              	.L19:
 298:../drivers/fsl_clock.c ****                 break;
 187              		.loc 1 298 0
 188 003c 0C23     		movs	r3, #12
 189              	.LVL11:
 190 003e FAE7     		b	.L29
 191              	.L31:
 192              		.align	2
 193              	.L30:
 194 0040 00400640 		.word	1074151424
 195              		.cfi_endproc
 196              	.LFE149:
 198              		.section	.text.CLOCK_GetInternalRefClkSelectFreq,"ax",%progbits
 199              		.align	1
 200              		.syntax unified
 201              		.thumb
 202              		.thumb_func
 203              		.fpu fpv4-sp-d16
 205              	CLOCK_GetInternalRefClkSelectFreq:
 206              	.LFB150:
 308:../drivers/fsl_clock.c **** 
 309:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
 310:../drivers/fsl_clock.c **** {
 207              		.loc 1 310 0
 208              		.cfi_startproc
 209              		@ args = 0, pretend = 0, frame = 0
 210              		@ frame_needed = 0, uses_anonymous_args = 0
 211              		@ link register save eliminated.
 311:../drivers/fsl_clock.c ****     if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
 212              		.loc 1 311 0
 213 0000 064B     		ldr	r3, .L35
 214 0002 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 215 0004 D207     		lsls	r2, r2, #31
 312:../drivers/fsl_clock.c ****     {
 313:../drivers/fsl_clock.c ****         /* Slow internal reference clock selected*/
 314:../drivers/fsl_clock.c ****         return s_slowIrcFreq;
 216              		.loc 1 314 0
 217 0006 55BF     		itete	pl
 218 0008 054B     		ldrpl	r3, .L35+4
 219              	.LBB10:
 220              	.LBB11:
 315:../drivers/fsl_clock.c ****     }
 316:../drivers/fsl_clock.c ****     else
 317:../drivers/fsl_clock.c ****     {
 318:../drivers/fsl_clock.c ****         /* Fast internal reference clock selected*/
 319:../drivers/fsl_clock.c ****         return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
 221              		.loc 1 319 0
 222 000a 064A     		ldrmi	r2, .L35+8
 223              	.LBE11:
 224              	.LBE10:
 314:../drivers/fsl_clock.c ****     }
 225              		.loc 1 314 0
 226 000c 1868     		ldrpl	r0, [r3]
 227              	.LBB13:
 228              	.LBB12:
 229              		.loc 1 319 0
 230 000e 187A     		ldrbmi	r0, [r3, #8]	@ zero_extendqisi2
 231 0010 42BF     		ittt	mi
 232 0012 C0F34203 		ubfxmi	r3, r0, #1, #3
 233 0016 1068     		ldrmi	r0, [r2]
 234 0018 D840     		lsrmi	r0, r0, r3
 235              	.LBE12:
 236              	.LBE13:
 320:../drivers/fsl_clock.c ****     }
 321:../drivers/fsl_clock.c **** }
 237              		.loc 1 321 0
 238 001a 7047     		bx	lr
 239              	.L36:
 240              		.align	2
 241              	.L35:
 242 001c 00400640 		.word	1074151424
 243 0020 00000000 		.word	.LANCHOR0
 244 0024 00000000 		.word	.LANCHOR1
 245              		.cfi_endproc
 246              	.LFE150:
 248              		.section	.text.CLOCK_GetOsc0ErClkFreq,"ax",%progbits
 249              		.align	1
 250              		.global	CLOCK_GetOsc0ErClkFreq
 251              		.syntax unified
 252              		.thumb
 253              		.thumb_func
 254              		.fpu fpv4-sp-d16
 256              	CLOCK_GetOsc0ErClkFreq:
 257              	.LFB154:
 322:../drivers/fsl_clock.c **** 
 323:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllRefClkFreq(void)
 324:../drivers/fsl_clock.c **** {
 325:../drivers/fsl_clock.c ****     /* If use external reference clock. */
 326:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 327:../drivers/fsl_clock.c ****     {
 328:../drivers/fsl_clock.c ****         return CLOCK_GetFllExtRefClkFreq();
 329:../drivers/fsl_clock.c ****     }
 330:../drivers/fsl_clock.c ****     /* If use internal reference clock. */
 331:../drivers/fsl_clock.c ****     else
 332:../drivers/fsl_clock.c ****     {
 333:../drivers/fsl_clock.c ****         return s_slowIrcFreq;
 334:../drivers/fsl_clock.c ****     }
 335:../drivers/fsl_clock.c **** }
 336:../drivers/fsl_clock.c **** 
 337:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetPll0RefFreq(void)
 338:../drivers/fsl_clock.c **** {
 339:../drivers/fsl_clock.c ****     /* MCG external reference clock. */
 340:../drivers/fsl_clock.c ****     return CLOCK_GetMcgExtClkFreq();
 341:../drivers/fsl_clock.c **** }
 342:../drivers/fsl_clock.c **** 
 343:../drivers/fsl_clock.c **** static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
 344:../drivers/fsl_clock.c **** {
 345:../drivers/fsl_clock.c ****     uint8_t range;
 346:../drivers/fsl_clock.c **** 
 347:../drivers/fsl_clock.c ****     if (freq <= 39063U)
 348:../drivers/fsl_clock.c ****     {
 349:../drivers/fsl_clock.c ****         range = 0U;
 350:../drivers/fsl_clock.c ****     }
 351:../drivers/fsl_clock.c ****     else if (freq <= 8000000U)
 352:../drivers/fsl_clock.c ****     {
 353:../drivers/fsl_clock.c ****         range = 1U;
 354:../drivers/fsl_clock.c ****     }
 355:../drivers/fsl_clock.c ****     else
 356:../drivers/fsl_clock.c ****     {
 357:../drivers/fsl_clock.c ****         range = 2U;
 358:../drivers/fsl_clock.c ****     }
 359:../drivers/fsl_clock.c **** 
 360:../drivers/fsl_clock.c ****     return range;
 361:../drivers/fsl_clock.c **** }
 362:../drivers/fsl_clock.c **** 
 363:../drivers/fsl_clock.c **** uint32_t CLOCK_GetOsc0ErClkFreq(void)
 364:../drivers/fsl_clock.c **** {
 258              		.loc 1 364 0
 259              		.cfi_startproc
 260              		@ args = 0, pretend = 0, frame = 0
 261              		@ frame_needed = 0, uses_anonymous_args = 0
 262              		@ link register save eliminated.
 365:../drivers/fsl_clock.c ****     if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
 263              		.loc 1 365 0
 264 0000 034B     		ldr	r3, .L40
 265 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 266 0004 1B06     		lsls	r3, r3, #24
 366:../drivers/fsl_clock.c ****     {
 367:../drivers/fsl_clock.c ****         /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
 368:../drivers/fsl_clock.c ****         assert(g_xtal0Freq);
 369:../drivers/fsl_clock.c ****         return g_xtal0Freq;
 267              		.loc 1 369 0
 268 0006 46BF     		itte	mi
 269 0008 024B     		ldrmi	r3, .L40+4
 270 000a 1868     		ldrmi	r0, [r3]
 370:../drivers/fsl_clock.c ****     }
 371:../drivers/fsl_clock.c ****     else
 372:../drivers/fsl_clock.c ****     {
 373:../drivers/fsl_clock.c ****         return 0U;
 271              		.loc 1 373 0
 272 000c 0020     		movpl	r0, #0
 374:../drivers/fsl_clock.c ****     }
 375:../drivers/fsl_clock.c **** }
 273              		.loc 1 375 0
 274 000e 7047     		bx	lr
 275              	.L41:
 276              		.align	2
 277              	.L40:
 278 0010 00500640 		.word	1074155520
 279 0014 00000000 		.word	g_xtal0Freq
 280              		.cfi_endproc
 281              	.LFE154:
 283              		.section	.text.CLOCK_GetEr32kClkFreq,"ax",%progbits
 284              		.align	1
 285              		.global	CLOCK_GetEr32kClkFreq
 286              		.syntax unified
 287              		.thumb
 288              		.thumb_func
 289              		.fpu fpv4-sp-d16
 291              	CLOCK_GetEr32kClkFreq:
 292              	.LFB155:
 376:../drivers/fsl_clock.c **** 
 377:../drivers/fsl_clock.c **** uint32_t CLOCK_GetEr32kClkFreq(void)
 378:../drivers/fsl_clock.c **** {
 293              		.loc 1 378 0
 294              		.cfi_startproc
 295              		@ args = 0, pretend = 0, frame = 0
 296              		@ frame_needed = 0, uses_anonymous_args = 0
 297 0000 08B5     		push	{r3, lr}
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 3, -8
 300              		.cfi_offset 14, -4
 379:../drivers/fsl_clock.c ****     uint32_t freq;
 380:../drivers/fsl_clock.c **** 
 381:../drivers/fsl_clock.c ****     switch (SIM_SOPT1_OSC32KSEL_VAL)
 301              		.loc 1 381 0
 302 0002 0C4B     		ldr	r3, .L50
 303 0004 1B68     		ldr	r3, [r3]
 304 0006 C3F38143 		ubfx	r3, r3, #18, #2
 305 000a 022B     		cmp	r3, #2
 306 000c 0BD0     		beq	.L44
 307 000e 032B     		cmp	r3, #3
 308 0010 0CD0     		beq	.L47
 309 0012 0BB1     		cbz	r3, .L46
 382:../drivers/fsl_clock.c ****     {
 383:../drivers/fsl_clock.c ****         case 0U: /* OSC 32k clock  */
 384:../drivers/fsl_clock.c ****             freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
 385:../drivers/fsl_clock.c ****             break;
 386:../drivers/fsl_clock.c ****         case 2U: /* RTC 32k clock  */
 387:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN
 388:../drivers/fsl_clock.c ****             assert(g_xtal32Freq);
 389:../drivers/fsl_clock.c ****             freq = g_xtal32Freq;
 390:../drivers/fsl_clock.c ****             break;
 391:../drivers/fsl_clock.c ****         case 3U: /* LPO clock      */
 392:../drivers/fsl_clock.c ****             freq = LPO_CLK_FREQ;
 393:../drivers/fsl_clock.c ****             break;
 394:../drivers/fsl_clock.c ****         default:
 395:../drivers/fsl_clock.c ****             freq = 0U;
 310              		.loc 1 395 0
 311 0014 0020     		movs	r0, #0
 312              	.L42:
 396:../drivers/fsl_clock.c ****             break;
 397:../drivers/fsl_clock.c ****     }
 398:../drivers/fsl_clock.c ****     return freq;
 399:../drivers/fsl_clock.c **** }
 313              		.loc 1 399 0
 314 0016 08BD     		pop	{r3, pc}
 315              	.L46:
 316              	.LBB16:
 317              	.LBB17:
 384:../drivers/fsl_clock.c ****             break;
 318              		.loc 1 384 0
 319 0018 FFF7FEFF 		bl	CLOCK_GetOsc0ErClkFreq
 320              	.LVL12:
 321 001c B0F5004F 		cmp	r0, #32768
 322 0020 18BF     		it	ne
 323 0022 0020     		movne	r0, #0
 324 0024 F7E7     		b	.L42
 325              	.L44:
 326              	.LBE17:
 327              	.LBE16:
 389:../drivers/fsl_clock.c ****             break;
 328              		.loc 1 389 0
 329 0026 044B     		ldr	r3, .L50+4
 330 0028 1868     		ldr	r0, [r3]
 331              	.LVL13:
 390:../drivers/fsl_clock.c ****         case 3U: /* LPO clock      */
 332              		.loc 1 390 0
 333 002a F4E7     		b	.L42
 334              	.LVL14:
 335              	.L47:
 392:../drivers/fsl_clock.c ****             break;
 336              		.loc 1 392 0
 337 002c 4FF47A70 		mov	r0, #1000
 338              	.LVL15:
 398:../drivers/fsl_clock.c **** }
 339              		.loc 1 398 0
 340 0030 F1E7     		b	.L42
 341              	.L51:
 342 0032 00BF     		.align	2
 343              	.L50:
 344 0034 00700440 		.word	1074032640
 345 0038 00000000 		.word	g_xtal32Freq
 346              		.cfi_endproc
 347              	.LFE155:
 349              		.section	.text.CLOCK_SetSimConfig,"ax",%progbits
 350              		.align	1
 351              		.global	CLOCK_SetSimConfig
 352              		.syntax unified
 353              		.thumb
 354              		.thumb_func
 355              		.fpu fpv4-sp-d16
 357              	CLOCK_SetSimConfig:
 358              	.LFB163:
 400:../drivers/fsl_clock.c **** 
 401:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPllFllSelClkFreq(void)
 402:../drivers/fsl_clock.c **** {
 403:../drivers/fsl_clock.c ****     uint32_t freq;
 404:../drivers/fsl_clock.c **** 
 405:../drivers/fsl_clock.c ****     switch (SIM_SOPT2_PLLFLLSEL_VAL)
 406:../drivers/fsl_clock.c ****     {
 407:../drivers/fsl_clock.c ****         case 0U: /* FLL. */
 408:../drivers/fsl_clock.c ****             freq = CLOCK_GetFllFreq();
 409:../drivers/fsl_clock.c ****             break;
 410:../drivers/fsl_clock.c ****         case 1U: /* PLL. */
 411:../drivers/fsl_clock.c ****             freq = CLOCK_GetPll0Freq();
 412:../drivers/fsl_clock.c ****             break;
 413:../drivers/fsl_clock.c ****         case 3U: /* MCG IRC48M. */
 414:../drivers/fsl_clock.c ****             freq = MCG_INTERNAL_IRC_48M;
 415:../drivers/fsl_clock.c ****             break;
 416:../drivers/fsl_clock.c ****         default:
 417:../drivers/fsl_clock.c ****             freq = 0U;
 418:../drivers/fsl_clock.c ****             break;
 419:../drivers/fsl_clock.c ****     }
 420:../drivers/fsl_clock.c **** 
 421:../drivers/fsl_clock.c ****     return freq;
 422:../drivers/fsl_clock.c **** }
 423:../drivers/fsl_clock.c **** 
 424:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPlatClkFreq(void)
 425:../drivers/fsl_clock.c **** {
 426:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 427:../drivers/fsl_clock.c **** }
 428:../drivers/fsl_clock.c **** 
 429:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFlashClkFreq(void)
 430:../drivers/fsl_clock.c **** {
 431:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 432:../drivers/fsl_clock.c **** }
 433:../drivers/fsl_clock.c **** 
 434:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFlexBusClkFreq(void)
 435:../drivers/fsl_clock.c **** {
 436:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
 437:../drivers/fsl_clock.c **** }
 438:../drivers/fsl_clock.c **** 
 439:../drivers/fsl_clock.c **** uint32_t CLOCK_GetBusClkFreq(void)
 440:../drivers/fsl_clock.c **** {
 441:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
 442:../drivers/fsl_clock.c **** }
 443:../drivers/fsl_clock.c **** 
 444:../drivers/fsl_clock.c **** uint32_t CLOCK_GetCoreSysClkFreq(void)
 445:../drivers/fsl_clock.c **** {
 446:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 447:../drivers/fsl_clock.c **** }
 448:../drivers/fsl_clock.c **** 
 449:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFreq(clock_name_t clockName)
 450:../drivers/fsl_clock.c **** {
 451:../drivers/fsl_clock.c ****     uint32_t freq;
 452:../drivers/fsl_clock.c **** 
 453:../drivers/fsl_clock.c ****     switch (clockName)
 454:../drivers/fsl_clock.c ****     {
 455:../drivers/fsl_clock.c ****         case kCLOCK_CoreSysClk:
 456:../drivers/fsl_clock.c ****         case kCLOCK_PlatClk:
 457:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 458:../drivers/fsl_clock.c ****             break;
 459:../drivers/fsl_clock.c ****         case kCLOCK_BusClk:
 460:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
 461:../drivers/fsl_clock.c ****             break;
 462:../drivers/fsl_clock.c ****         case kCLOCK_FlexBusClk:
 463:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
 464:../drivers/fsl_clock.c ****             break;
 465:../drivers/fsl_clock.c ****         case kCLOCK_FlashClk:
 466:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 467:../drivers/fsl_clock.c ****             break;
 468:../drivers/fsl_clock.c ****         case kCLOCK_PllFllSelClk:
 469:../drivers/fsl_clock.c ****             freq = CLOCK_GetPllFllSelClkFreq();
 470:../drivers/fsl_clock.c ****             break;
 471:../drivers/fsl_clock.c ****         case kCLOCK_Er32kClk:
 472:../drivers/fsl_clock.c ****             freq = CLOCK_GetEr32kClkFreq();
 473:../drivers/fsl_clock.c ****             break;
 474:../drivers/fsl_clock.c ****         case kCLOCK_Osc0ErClk:
 475:../drivers/fsl_clock.c ****             freq = CLOCK_GetOsc0ErClkFreq();
 476:../drivers/fsl_clock.c ****             break;
 477:../drivers/fsl_clock.c ****         case kCLOCK_McgFixedFreqClk:
 478:../drivers/fsl_clock.c ****             freq = CLOCK_GetFixedFreqClkFreq();
 479:../drivers/fsl_clock.c ****             break;
 480:../drivers/fsl_clock.c ****         case kCLOCK_McgInternalRefClk:
 481:../drivers/fsl_clock.c ****             freq = CLOCK_GetInternalRefClkFreq();
 482:../drivers/fsl_clock.c ****             break;
 483:../drivers/fsl_clock.c ****         case kCLOCK_McgFllClk:
 484:../drivers/fsl_clock.c ****             freq = CLOCK_GetFllFreq();
 485:../drivers/fsl_clock.c ****             break;
 486:../drivers/fsl_clock.c ****         case kCLOCK_McgPll0Clk:
 487:../drivers/fsl_clock.c ****             freq = CLOCK_GetPll0Freq();
 488:../drivers/fsl_clock.c ****             break;
 489:../drivers/fsl_clock.c ****         case kCLOCK_McgIrc48MClk:
 490:../drivers/fsl_clock.c ****             freq = MCG_INTERNAL_IRC_48M;
 491:../drivers/fsl_clock.c ****             break;
 492:../drivers/fsl_clock.c ****         case kCLOCK_LpoClk:
 493:../drivers/fsl_clock.c ****             freq = LPO_CLK_FREQ;
 494:../drivers/fsl_clock.c ****             break;
 495:../drivers/fsl_clock.c ****         default:
 496:../drivers/fsl_clock.c ****             freq = 0U;
 497:../drivers/fsl_clock.c ****             break;
 498:../drivers/fsl_clock.c ****     }
 499:../drivers/fsl_clock.c **** 
 500:../drivers/fsl_clock.c ****     return freq;
 501:../drivers/fsl_clock.c **** }
 502:../drivers/fsl_clock.c **** 
 503:../drivers/fsl_clock.c **** void CLOCK_SetSimConfig(sim_clock_config_t const *config)
 504:../drivers/fsl_clock.c **** {
 359              		.loc 1 504 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363              	.LVL16:
 505:../drivers/fsl_clock.c ****     SIM->CLKDIV1 = config->clkdiv1;
 364              		.loc 1 505 0
 365 0000 0D4A     		ldr	r2, .L53
 366 0002 4168     		ldr	r1, [r0, #4]
 367 0004 41F24403 		movw	r3, #4164
 504:../drivers/fsl_clock.c ****     SIM->CLKDIV1 = config->clkdiv1;
 368              		.loc 1 504 0
 369 0008 10B5     		push	{r4, lr}
 370              		.cfi_def_cfa_offset 8
 371              		.cfi_offset 4, -8
 372              		.cfi_offset 14, -4
 373              		.loc 1 505 0
 374 000a D150     		str	r1, [r2, r3]
 375              	.LVL17:
 376              	.LBB22:
 377              	.LBB23:
 378              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 707:../drivers/fsl_clock.h **** }
 708:../drivers/fsl_clock.h **** 
 709:../drivers/fsl_clock.h **** /*!
 710:../drivers/fsl_clock.h ****  * @brief Set ERCLK32K source.
 711:../drivers/fsl_clock.h ****  *
 712:../drivers/fsl_clock.h ****  * @param src The value to set ERCLK32K clock source.
 713:../drivers/fsl_clock.h ****  */
 714:../drivers/fsl_clock.h **** static inline void CLOCK_SetEr32kClock(uint32_t src)
 715:../drivers/fsl_clock.h **** {
 716:../drivers/fsl_clock.h ****     SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
 717:../drivers/fsl_clock.h **** }
 718:../drivers/fsl_clock.h **** 
 719:../drivers/fsl_clock.h **** /*!
 720:../drivers/fsl_clock.h ****  * @brief Set SDHC0 clock source.
 721:../drivers/fsl_clock.h ****  *
 722:../drivers/fsl_clock.h ****  * @param src The value to set SDHC0 clock source.
 723:../drivers/fsl_clock.h ****  */
 724:../drivers/fsl_clock.h **** static inline void CLOCK_SetSdhc0Clock(uint32_t src)
 725:../drivers/fsl_clock.h **** {
 726:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_SDHCSRC_MASK) | SIM_SOPT2_SDHCSRC(src));
 727:../drivers/fsl_clock.h **** }
 728:../drivers/fsl_clock.h **** 
 729:../drivers/fsl_clock.h **** /*!
 730:../drivers/fsl_clock.h ****  * @brief Set enet timestamp clock source.
 731:../drivers/fsl_clock.h ****  *
 732:../drivers/fsl_clock.h ****  * @param src The value to set enet timestamp clock source.
 733:../drivers/fsl_clock.h ****  */
 734:../drivers/fsl_clock.h **** static inline void CLOCK_SetEnetTime0Clock(uint32_t src)
 735:../drivers/fsl_clock.h **** {
 736:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_TIMESRC_MASK) | SIM_SOPT2_TIMESRC(src));
 737:../drivers/fsl_clock.h **** }
 738:../drivers/fsl_clock.h **** 
 739:../drivers/fsl_clock.h **** /*!
 740:../drivers/fsl_clock.h ****  * @brief Set RMII clock source.
 741:../drivers/fsl_clock.h ****  *
 742:../drivers/fsl_clock.h ****  * @param src The value to set RMII clock source.
 743:../drivers/fsl_clock.h ****  */
 744:../drivers/fsl_clock.h **** static inline void CLOCK_SetRmii0Clock(uint32_t src)
 745:../drivers/fsl_clock.h **** {
 746:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_RMIISRC_MASK) | SIM_SOPT2_RMIISRC(src));
 747:../drivers/fsl_clock.h **** }
 748:../drivers/fsl_clock.h **** 
 749:../drivers/fsl_clock.h **** /*!
 750:../drivers/fsl_clock.h ****  * @brief Set debug trace clock source.
 751:../drivers/fsl_clock.h ****  *
 752:../drivers/fsl_clock.h ****  * @param src The value to set debug trace clock source.
 753:../drivers/fsl_clock.h ****  */
 754:../drivers/fsl_clock.h **** static inline void CLOCK_SetTraceClock(uint32_t src)
 755:../drivers/fsl_clock.h **** {
 756:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_TRACECLKSEL_MASK) | SIM_SOPT2_TRACECLKSEL(src));
 757:../drivers/fsl_clock.h **** }
 758:../drivers/fsl_clock.h **** 
 759:../drivers/fsl_clock.h **** /*!
 760:../drivers/fsl_clock.h ****  * @brief Set PLLFLLSEL clock source.
 761:../drivers/fsl_clock.h ****  *
 762:../drivers/fsl_clock.h ****  * @param src The value to set PLLFLLSEL clock source.
 763:../drivers/fsl_clock.h ****  */
 764:../drivers/fsl_clock.h **** static inline void CLOCK_SetPllFllSelClock(uint32_t src)
 765:../drivers/fsl_clock.h **** {
 766:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_PLLFLLSEL_MASK) | SIM_SOPT2_PLLFLLSEL(src));
 379              		.loc 2 766 0
 380 000c 41F20404 		movw	r4, #4100
 381              	.LBE23:
 382              	.LBE22:
 506:../drivers/fsl_clock.c ****     CLOCK_SetPllFllSelClock(config->pllFllSel);
 383              		.loc 1 506 0
 384 0010 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 385              	.LVL18:
 386              	.LBB25:
 387              	.LBB24:
 388              		.loc 2 766 0
 389 0012 1159     		ldr	r1, [r2, r4]
 390 0014 1B04     		lsls	r3, r3, #16
 391              	.LVL19:
 392 0016 21F44031 		bic	r1, r1, #196608
 393 001a 03F44033 		and	r3, r3, #196608
 394 001e 0B43     		orrs	r3, r3, r1
 395 0020 1351     		str	r3, [r2, r4]
 396              	.LVL20:
 397              	.LBE24:
 398              	.LBE25:
 507:../drivers/fsl_clock.c ****     CLOCK_SetEr32kClock(config->er32kSrc);
 399              		.loc 1 507 0
 400 0022 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 401              	.LVL21:
 402              	.LBB26:
 403              	.LBB27:
 716:../drivers/fsl_clock.h **** }
 404              		.loc 2 716 0
 405 0024 1168     		ldr	r1, [r2]
 406 0026 9B04     		lsls	r3, r3, #18
 407              	.LVL22:
 408 0028 03F44023 		and	r3, r3, #786432
 409 002c 21F44021 		bic	r1, r1, #786432
 410 0030 0B43     		orrs	r3, r3, r1
 411 0032 1360     		str	r3, [r2]
 412              	.LVL23:
 413              	.LBE27:
 414              	.LBE26:
 508:../drivers/fsl_clock.c **** }
 415              		.loc 1 508 0
 416 0034 10BD     		pop	{r4, pc}
 417              	.L54:
 418 0036 00BF     		.align	2
 419              	.L53:
 420 0038 00700440 		.word	1074032640
 421              		.cfi_endproc
 422              	.LFE163:
 424              		.section	.text.CLOCK_EnableUsbfs0Clock,"ax",%progbits
 425              		.align	1
 426              		.global	CLOCK_EnableUsbfs0Clock
 427              		.syntax unified
 428              		.thumb
 429              		.thumb_func
 430              		.fpu fpv4-sp-d16
 432              	CLOCK_EnableUsbfs0Clock:
 433              	.LFB164:
 509:../drivers/fsl_clock.c **** 
 510:../drivers/fsl_clock.c **** bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq)
 511:../drivers/fsl_clock.c **** {
 434              		.loc 1 511 0
 435              		.cfi_startproc
 436              		@ args = 0, pretend = 0, frame = 0
 437              		@ frame_needed = 0, uses_anonymous_args = 0
 438              	.LVL24:
 439 0000 30B5     		push	{r4, r5, lr}
 440              		.cfi_def_cfa_offset 12
 441              		.cfi_offset 4, -12
 442              		.cfi_offset 5, -8
 443              		.cfi_offset 14, -4
 444              	.LBB32:
 445              	.LBB33:
 706:../drivers/fsl_clock.h **** }
 446              		.loc 2 706 0
 447 0002 264C     		ldr	r4, .L67
 448 0004 264B     		ldr	r3, .L67+4
 449 0006 2268     		ldr	r2, [r4]
 450 0008 22F48022 		bic	r2, r2, #262144
 451 000c 2260     		str	r2, [r4]
 452              	.LVL25:
 453              	.LBE33:
 454              	.LBE32:
 512:../drivers/fsl_clock.c ****     bool ret = true;
 513:../drivers/fsl_clock.c **** 
 514:../drivers/fsl_clock.c ****     CLOCK_DisableClock(kCLOCK_Usbfs0);
 515:../drivers/fsl_clock.c **** 
 516:../drivers/fsl_clock.c ****     if (kCLOCK_UsbSrcExt == src)
 455              		.loc 1 516 0
 456 000e C8B9     		cbnz	r0, .L56
 517:../drivers/fsl_clock.c ****     {
 518:../drivers/fsl_clock.c ****         SIM->SOPT2 &= ~SIM_SOPT2_USBSRC_MASK;
 457              		.loc 1 518 0
 458 0010 41F20401 		movw	r1, #4100
 459              	.LVL26:
 460 0014 5A58     		ldr	r2, [r3, r1]
 461 0016 22F48022 		bic	r2, r2, #262144
 462 001a 5A50     		str	r2, [r3, r1]
 512:../drivers/fsl_clock.c ****     bool ret = true;
 463              		.loc 1 512 0
 464 001c 0123     		movs	r3, #1
 465              	.LVL27:
 466              	.L57:
 467              	.LBB34:
 468              	.LBB35:
 695:../drivers/fsl_clock.h **** }
 469              		.loc 2 695 0
 470 001e 2268     		ldr	r2, [r4]
 471              	.LBE35:
 472              	.LBE34:
 519:../drivers/fsl_clock.c ****     }
 520:../drivers/fsl_clock.c ****     else
 521:../drivers/fsl_clock.c ****     {
 522:../drivers/fsl_clock.c ****         switch (freq)
 523:../drivers/fsl_clock.c ****         {
 524:../drivers/fsl_clock.c ****             case 120000000U:
 525:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC(1);
 526:../drivers/fsl_clock.c ****                 break;
 527:../drivers/fsl_clock.c ****             case 96000000U:
 528:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(1) | SIM_CLKDIV2_USBFRAC(0);
 529:../drivers/fsl_clock.c ****                 break;
 530:../drivers/fsl_clock.c ****             case 72000000U:
 531:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(2) | SIM_CLKDIV2_USBFRAC(1);
 532:../drivers/fsl_clock.c ****                 break;
 533:../drivers/fsl_clock.c ****             case 48000000U:
 534:../drivers/fsl_clock.c ****                 SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(0) | SIM_CLKDIV2_USBFRAC(0);
 535:../drivers/fsl_clock.c ****                 break;
 536:../drivers/fsl_clock.c ****             default:
 537:../drivers/fsl_clock.c ****                 ret = false;
 538:../drivers/fsl_clock.c ****                 break;
 539:../drivers/fsl_clock.c ****         }
 540:../drivers/fsl_clock.c **** 
 541:../drivers/fsl_clock.c ****         SIM->SOPT2 = ((SIM->SOPT2 & ~(SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_USBSRC_MASK)) | (uint32_
 542:../drivers/fsl_clock.c ****     }
 543:../drivers/fsl_clock.c **** 
 544:../drivers/fsl_clock.c ****     CLOCK_EnableClock(kCLOCK_Usbfs0);
 545:../drivers/fsl_clock.c **** 
 546:../drivers/fsl_clock.c ****     if (kCLOCK_UsbSrcIrc48M == src)
 473              		.loc 1 546 0
 474 0020 B0F5E02F 		cmp	r0, #458752
 475              	.LBB37:
 476              	.LBB36:
 695:../drivers/fsl_clock.h **** }
 477              		.loc 2 695 0
 478 0024 42F48022 		orr	r2, r2, #262144
 479 0028 2260     		str	r2, [r4]
 480              	.LVL28:
 481              	.LBE36:
 482              	.LBE37:
 483              		.loc 1 546 0
 484 002a 09D1     		bne	.L64
 547:../drivers/fsl_clock.c ****     {
 548:../drivers/fsl_clock.c ****         USB0->CLK_RECOVER_IRC_EN = 0x03U;
 485              		.loc 1 548 0
 486 002c 1D4A     		ldr	r2, .L67+8
 487 002e 0321     		movs	r1, #3
 488 0030 82F84411 		strb	r1, [r2, #324]
 549:../drivers/fsl_clock.c ****         USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
 489              		.loc 1 549 0
 490 0034 92F84011 		ldrb	r1, [r2, #320]	@ zero_extendqisi2
 491 0038 41F08001 		orr	r1, r1, #128
 492 003c 82F84011 		strb	r1, [r2, #320]
 493              	.L64:
 550:../drivers/fsl_clock.c ****     }
 551:../drivers/fsl_clock.c ****     return ret;
 552:../drivers/fsl_clock.c **** }
 494              		.loc 1 552 0
 495 0040 1846     		mov	r0, r3
 496              	.LVL29:
 497 0042 30BD     		pop	{r4, r5, pc}
 498              	.LVL30:
 499              	.L56:
 522:../drivers/fsl_clock.c ****         {
 500              		.loc 1 522 0
 501 0044 184A     		ldr	r2, .L67+12
 502 0046 9142     		cmp	r1, r2
 503 0048 20D0     		beq	.L59
 504 004a 04D8     		bhi	.L60
 505 004c 174A     		ldr	r2, .L67+16
 506 004e 9142     		cmp	r1, r2
 507 0050 20D0     		beq	.L61
 508              	.L65:
 537:../drivers/fsl_clock.c ****                 break;
 509              		.loc 1 537 0
 510 0052 0023     		movs	r3, #0
 511 0054 0DE0     		b	.L58
 512              	.L60:
 522:../drivers/fsl_clock.c ****         {
 513              		.loc 1 522 0
 514 0056 164A     		ldr	r2, .L67+20
 515 0058 9142     		cmp	r1, r2
 516 005a 13D0     		beq	.L62
 517 005c 02F1B772 		add	r2, r2, #23986176
 518 0060 02F55852 		add	r2, r2, #13824
 519 0064 9142     		cmp	r1, r2
 520 0066 F4D1     		bne	.L65
 525:../drivers/fsl_clock.c ****                 break;
 521              		.loc 1 525 0
 522 0068 41F24802 		movw	r2, #4168
 523 006c 0921     		movs	r1, #9
 524              	.LVL31:
 525              	.L66:
 534:../drivers/fsl_clock.c ****                 break;
 526              		.loc 1 534 0
 527 006e 9950     		str	r1, [r3, r2]
 512:../drivers/fsl_clock.c **** 
 528              		.loc 1 512 0
 529 0070 0123     		movs	r3, #1
 530              	.L58:
 531              	.LVL32:
 541:../drivers/fsl_clock.c ****     }
 532              		.loc 1 541 0
 533 0072 0B4D     		ldr	r5, .L67+4
 534 0074 41F20401 		movw	r1, #4100
 535 0078 6A58     		ldr	r2, [r5, r1]
 536 007a 22F4E022 		bic	r2, r2, #458752
 537 007e 0243     		orrs	r2, r2, r0
 538 0080 6A50     		str	r2, [r5, r1]
 539 0082 CCE7     		b	.L57
 540              	.LVL33:
 541              	.L62:
 528:../drivers/fsl_clock.c ****                 break;
 542              		.loc 1 528 0
 543 0084 41F24802 		movw	r2, #4168
 544 0088 0221     		movs	r1, #2
 545              	.LVL34:
 546 008a F0E7     		b	.L66
 547              	.LVL35:
 548              	.L59:
 531:../drivers/fsl_clock.c ****                 break;
 549              		.loc 1 531 0
 550 008c 41F24802 		movw	r2, #4168
 551 0090 0521     		movs	r1, #5
 552              	.LVL36:
 553 0092 ECE7     		b	.L66
 554              	.LVL37:
 555              	.L61:
 534:../drivers/fsl_clock.c ****                 break;
 556              		.loc 1 534 0
 557 0094 41F24802 		movw	r2, #4168
 558 0098 0021     		movs	r1, #0
 559              	.LVL38:
 560 009a E8E7     		b	.L66
 561              	.L68:
 562              		.align	2
 563              	.L67:
 564 009c 34800440 		.word	1074036788
 565 00a0 00700440 		.word	1074032640
 566 00a4 00200740 		.word	1074208768
 567 00a8 00A24A04 		.word	72000000
 568 00ac 006CDC02 		.word	48000000
 569 00b0 00D8B805 		.word	96000000
 570              		.cfi_endproc
 571              	.LFE164:
 573              		.section	.text.CLOCK_GetFllFreq,"ax",%progbits
 574              		.align	1
 575              		.global	CLOCK_GetFllFreq
 576              		.syntax unified
 577              		.thumb
 578              		.thumb_func
 579              		.fpu fpv4-sp-d16
 581              	CLOCK_GetFllFreq:
 582              	.LFB166:
 553:../drivers/fsl_clock.c **** 
 554:../drivers/fsl_clock.c **** uint32_t CLOCK_GetOutClkFreq(void)
 555:../drivers/fsl_clock.c **** {
 556:../drivers/fsl_clock.c ****     uint32_t mcgoutclk;
 557:../drivers/fsl_clock.c ****     uint32_t clkst = MCG_S_CLKST_VAL;
 558:../drivers/fsl_clock.c **** 
 559:../drivers/fsl_clock.c ****     switch (clkst)
 560:../drivers/fsl_clock.c ****     {
 561:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
 562:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetPll0Freq();
 563:../drivers/fsl_clock.c ****             break;
 564:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatFll:
 565:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetFllFreq();
 566:../drivers/fsl_clock.c ****             break;
 567:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
 568:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
 569:../drivers/fsl_clock.c ****             break;
 570:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
 571:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetMcgExtClkFreq();
 572:../drivers/fsl_clock.c ****             break;
 573:../drivers/fsl_clock.c ****         default:
 574:../drivers/fsl_clock.c ****             mcgoutclk = 0U;
 575:../drivers/fsl_clock.c ****             break;
 576:../drivers/fsl_clock.c ****     }
 577:../drivers/fsl_clock.c ****     return mcgoutclk;
 578:../drivers/fsl_clock.c **** }
 579:../drivers/fsl_clock.c **** 
 580:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFllFreq(void)
 581:../drivers/fsl_clock.c **** {
 583              		.loc 1 581 0
 584              		.cfi_startproc
 585              		@ args = 0, pretend = 0, frame = 0
 586              		@ frame_needed = 0, uses_anonymous_args = 0
 587 0000 08B5     		push	{r3, lr}
 588              		.cfi_def_cfa_offset 8
 589              		.cfi_offset 3, -8
 590              		.cfi_offset 14, -4
 582:../drivers/fsl_clock.c ****     static const uint16_t fllFactorTable[4][2] = {{640, 732}, {1280, 1464}, {1920, 2197}, {2560, 29
 583:../drivers/fsl_clock.c **** 
 584:../drivers/fsl_clock.c ****     uint8_t drs, dmx32;
 585:../drivers/fsl_clock.c ****     uint32_t freq;
 586:../drivers/fsl_clock.c **** 
 587:../drivers/fsl_clock.c ****     /* If FLL is not enabled currently, then return 0U. */
 588:../drivers/fsl_clock.c ****     if ((MCG->C2 & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
 591              		.loc 1 588 0
 592 0002 104B     		ldr	r3, .L78
 593 0004 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 594 0006 9107     		lsls	r1, r2, #30
 595 0008 01D5     		bpl	.L70
 596              	.L72:
 589:../drivers/fsl_clock.c ****     {
 590:../drivers/fsl_clock.c ****         return 0U;
 597              		.loc 1 590 0
 598 000a 0020     		movs	r0, #0
 599              	.L69:
 591:../drivers/fsl_clock.c ****     }
 592:../drivers/fsl_clock.c **** 
 593:../drivers/fsl_clock.c ****     /* Get FLL reference clock frequency. */
 594:../drivers/fsl_clock.c ****     freq = CLOCK_GetFllRefClkFreq();
 595:../drivers/fsl_clock.c ****     if (!freq)
 596:../drivers/fsl_clock.c ****     {
 597:../drivers/fsl_clock.c ****         return freq;
 598:../drivers/fsl_clock.c ****     }
 599:../drivers/fsl_clock.c **** 
 600:../drivers/fsl_clock.c ****     drs = MCG_C4_DRST_DRS_VAL;
 601:../drivers/fsl_clock.c ****     dmx32 = MCG_C4_DMX32_VAL;
 602:../drivers/fsl_clock.c **** 
 603:../drivers/fsl_clock.c ****     return freq * fllFactorTable[drs][dmx32];
 604:../drivers/fsl_clock.c **** }
 600              		.loc 1 604 0
 601 000c 08BD     		pop	{r3, pc}
 602              	.L70:
 588:../drivers/fsl_clock.c ****     {
 603              		.loc 1 588 0 discriminator 1
 604 000e 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 605 0010 9206     		lsls	r2, r2, #26
 606 0012 FAD4     		bmi	.L72
 607              	.LBB42:
 608              	.LBB43:
 609              	.LBB44:
 610              	.LBB45:
 326:../drivers/fsl_clock.c ****     {
 611              		.loc 1 326 0
 612 0014 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 613 0016 DB06     		lsls	r3, r3, #27
 614 0018 10D4     		bmi	.L73
 328:../drivers/fsl_clock.c ****     }
 615              		.loc 1 328 0
 616 001a FFF7FEFF 		bl	CLOCK_GetFllExtRefClkFreq
 617              	.LVL39:
 618              	.L74:
 619              	.LBE45:
 620              	.LBE44:
 595:../drivers/fsl_clock.c ****     {
 621              		.loc 1 595 0
 622 001e 0028     		cmp	r0, #0
 623 0020 F3D0     		beq	.L72
 600:../drivers/fsl_clock.c ****     dmx32 = MCG_C4_DMX32_VAL;
 624              		.loc 1 600 0
 625 0022 084A     		ldr	r2, .L78
 626 0024 D378     		ldrb	r3, [r2, #3]	@ zero_extendqisi2
 627              	.LVL40:
 601:../drivers/fsl_clock.c **** 
 628              		.loc 1 601 0
 629 0026 D278     		ldrb	r2, [r2, #3]	@ zero_extendqisi2
 630              	.LVL41:
 603:../drivers/fsl_clock.c **** }
 631              		.loc 1 603 0
 632 0028 C3F34113 		ubfx	r3, r3, #5, #2
 633              	.LVL42:
 634 002c 5B00     		lsls	r3, r3, #1
 635 002e 03EBD213 		add	r3, r3, r2, lsr #7
 636 0032 054A     		ldr	r2, .L78+4
 637              	.LVL43:
 638 0034 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 639 0038 5843     		muls	r0, r3, r0
 640 003a E7E7     		b	.L69
 641              	.L73:
 642              	.LBB47:
 643              	.LBB46:
 333:../drivers/fsl_clock.c ****     }
 644              		.loc 1 333 0
 645 003c 034B     		ldr	r3, .L78+8
 646 003e 1868     		ldr	r0, [r3]
 647 0040 EDE7     		b	.L74
 648              	.L79:
 649 0042 00BF     		.align	2
 650              	.L78:
 651 0044 00400640 		.word	1074151424
 652 0048 00000000 		.word	.LANCHOR2
 653 004c 00000000 		.word	.LANCHOR0
 654              	.LBE46:
 655              	.LBE47:
 656              	.LBE43:
 657              	.LBE42:
 658              		.cfi_endproc
 659              	.LFE166:
 661              		.section	.text.CLOCK_GetInternalRefClkFreq,"ax",%progbits
 662              		.align	1
 663              		.global	CLOCK_GetInternalRefClkFreq
 664              		.syntax unified
 665              		.thumb
 666              		.thumb_func
 667              		.fpu fpv4-sp-d16
 669              	CLOCK_GetInternalRefClkFreq:
 670              	.LFB167:
 605:../drivers/fsl_clock.c **** 
 606:../drivers/fsl_clock.c **** uint32_t CLOCK_GetInternalRefClkFreq(void)
 607:../drivers/fsl_clock.c **** {
 671              		.loc 1 607 0
 672              		.cfi_startproc
 673              		@ args = 0, pretend = 0, frame = 0
 674              		@ frame_needed = 0, uses_anonymous_args = 0
 675              		@ link register save eliminated.
 608:../drivers/fsl_clock.c ****     /* If MCGIRCLK is gated. */
 609:../drivers/fsl_clock.c ****     if (!(MCG->C1 & MCG_C1_IRCLKEN_MASK))
 676              		.loc 1 609 0
 677 0000 034B     		ldr	r3, .L82
 678 0002 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 679 0004 10F00200 		ands	r0, r0, #2
 680 0008 01D0     		beq	.L81
 610:../drivers/fsl_clock.c ****     {
 611:../drivers/fsl_clock.c ****         return 0U;
 612:../drivers/fsl_clock.c ****     }
 613:../drivers/fsl_clock.c **** 
 614:../drivers/fsl_clock.c ****     return CLOCK_GetInternalRefClkSelectFreq();
 681              		.loc 1 614 0
 682 000a FFF7FEBF 		b	CLOCK_GetInternalRefClkSelectFreq
 683              	.LVL44:
 684              	.L81:
 615:../drivers/fsl_clock.c **** }
 685              		.loc 1 615 0
 686 000e 7047     		bx	lr
 687              	.L83:
 688              		.align	2
 689              	.L82:
 690 0010 00400640 		.word	1074151424
 691              		.cfi_endproc
 692              	.LFE167:
 694              		.section	.text.CLOCK_GetPll0Freq,"ax",%progbits
 695              		.align	1
 696              		.global	CLOCK_GetPll0Freq
 697              		.syntax unified
 698              		.thumb
 699              		.thumb_func
 700              		.fpu fpv4-sp-d16
 702              	CLOCK_GetPll0Freq:
 703              	.LFB169:
 616:../drivers/fsl_clock.c **** 
 617:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFixedFreqClkFreq(void)
 618:../drivers/fsl_clock.c **** {
 619:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 620:../drivers/fsl_clock.c **** 
 621:../drivers/fsl_clock.c ****     /* MCGFFCLK must be no more than MCGOUTCLK/8. */
 622:../drivers/fsl_clock.c ****     if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
 623:../drivers/fsl_clock.c ****     {
 624:../drivers/fsl_clock.c ****         return freq;
 625:../drivers/fsl_clock.c ****     }
 626:../drivers/fsl_clock.c ****     else
 627:../drivers/fsl_clock.c ****     {
 628:../drivers/fsl_clock.c ****         return 0U;
 629:../drivers/fsl_clock.c ****     }
 630:../drivers/fsl_clock.c **** }
 631:../drivers/fsl_clock.c **** 
 632:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPll0Freq(void)
 633:../drivers/fsl_clock.c **** {
 704              		.loc 1 633 0
 705              		.cfi_startproc
 706              		@ args = 0, pretend = 0, frame = 0
 707              		@ frame_needed = 0, uses_anonymous_args = 0
 708 0000 08B5     		push	{r3, lr}
 709              		.cfi_def_cfa_offset 8
 710              		.cfi_offset 3, -8
 711              		.cfi_offset 14, -4
 634:../drivers/fsl_clock.c ****     uint32_t mcgpll0clk;
 635:../drivers/fsl_clock.c **** 
 636:../drivers/fsl_clock.c ****     /* If PLL0 is not enabled, return 0. */
 637:../drivers/fsl_clock.c ****     if (!(MCG->S & MCG_S_LOCK0_MASK))
 712              		.loc 1 637 0
 713 0002 094A     		ldr	r2, .L87
 714 0004 9079     		ldrb	r0, [r2, #6]	@ zero_extendqisi2
 715 0006 10F04000 		ands	r0, r0, #64
 716 000a 0CD0     		beq	.L84
 717              	.LBB52:
 718              	.LBB53:
 719              	.LBB54:
 720              	.LBB55:
 340:../drivers/fsl_clock.c **** }
 721              		.loc 1 340 0
 722 000c FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 723              	.LVL45:
 724              	.LBE55:
 725              	.LBE54:
 638:../drivers/fsl_clock.c ****     {
 639:../drivers/fsl_clock.c ****         return 0U;
 640:../drivers/fsl_clock.c ****     }
 641:../drivers/fsl_clock.c **** 
 642:../drivers/fsl_clock.c ****     mcgpll0clk = CLOCK_GetPll0RefFreq();
 643:../drivers/fsl_clock.c **** 
 644:../drivers/fsl_clock.c ****     /*
 645:../drivers/fsl_clock.c ****      * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
 646:../drivers/fsl_clock.c ****      * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
 647:../drivers/fsl_clock.c ****      */
 648:../drivers/fsl_clock.c ****     assert(mcgpll0clk);
 649:../drivers/fsl_clock.c **** 
 650:../drivers/fsl_clock.c ****     mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
 726              		.loc 1 650 0
 727 0010 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 728 0012 03F01F03 		and	r3, r3, #31
 729 0016 0133     		adds	r3, r3, #1
 730 0018 B0FBF3F0 		udiv	r0, r0, r3
 731              	.LVL46:
 651:../drivers/fsl_clock.c ****     mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
 732              		.loc 1 651 0
 733 001c 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 734 001e 03F01F03 		and	r3, r3, #31
 735 0022 1833     		adds	r3, r3, #24
 736 0024 5843     		muls	r0, r3, r0
 737              	.LVL47:
 738              	.L84:
 739              	.LBE53:
 740              	.LBE52:
 652:../drivers/fsl_clock.c **** 
 653:../drivers/fsl_clock.c ****     return mcgpll0clk;
 654:../drivers/fsl_clock.c **** }
 741              		.loc 1 654 0
 742 0026 08BD     		pop	{r3, pc}
 743              	.L88:
 744              		.align	2
 745              	.L87:
 746 0028 00400640 		.word	1074151424
 747              		.cfi_endproc
 748              	.LFE169:
 750              		.section	.text.CLOCK_GetPllFllSelClkFreq,"ax",%progbits
 751              		.align	1
 752              		.global	CLOCK_GetPllFllSelClkFreq
 753              		.syntax unified
 754              		.thumb
 755              		.thumb_func
 756              		.fpu fpv4-sp-d16
 758              	CLOCK_GetPllFllSelClkFreq:
 759              	.LFB156:
 402:../drivers/fsl_clock.c ****     uint32_t freq;
 760              		.loc 1 402 0
 761              		.cfi_startproc
 762              		@ args = 0, pretend = 0, frame = 0
 763              		@ frame_needed = 0, uses_anonymous_args = 0
 764              		@ link register save eliminated.
 405:../drivers/fsl_clock.c ****     {
 765              		.loc 1 405 0
 766 0000 084A     		ldr	r2, .L97
 767 0002 41F20403 		movw	r3, #4100
 768 0006 D358     		ldr	r3, [r2, r3]
 769 0008 C3F30143 		ubfx	r3, r3, #16, #2
 770 000c 012B     		cmp	r3, #1
 771 000e 02D0     		beq	.L91
 772 0010 03D2     		bcs	.L96
 408:../drivers/fsl_clock.c ****             break;
 773              		.loc 1 408 0
 774 0012 FFF7FEBF 		b	CLOCK_GetFllFreq
 775              	.LVL48:
 776              	.L91:
 411:../drivers/fsl_clock.c ****             break;
 777              		.loc 1 411 0
 778 0016 FFF7FEBF 		b	CLOCK_GetPll0Freq
 779              	.LVL49:
 780              	.L96:
 405:../drivers/fsl_clock.c ****     {
 781              		.loc 1 405 0
 782 001a 032B     		cmp	r3, #3
 417:../drivers/fsl_clock.c ****             break;
 783              		.loc 1 417 0
 784 001c 0248     		ldr	r0, .L97+4
 785 001e 18BF     		it	ne
 786 0020 0020     		movne	r0, #0
 422:../drivers/fsl_clock.c **** 
 787              		.loc 1 422 0
 788 0022 7047     		bx	lr
 789              	.L98:
 790              		.align	2
 791              	.L97:
 792 0024 00700440 		.word	1074032640
 793 0028 006CDC02 		.word	48000000
 794              		.cfi_endproc
 795              	.LFE156:
 797              		.section	.text.CLOCK_GetOutClkFreq,"ax",%progbits
 798              		.align	1
 799              		.global	CLOCK_GetOutClkFreq
 800              		.syntax unified
 801              		.thumb
 802              		.thumb_func
 803              		.fpu fpv4-sp-d16
 805              	CLOCK_GetOutClkFreq:
 806              	.LFB165:
 555:../drivers/fsl_clock.c ****     uint32_t mcgoutclk;
 807              		.loc 1 555 0
 808              		.cfi_startproc
 809              		@ args = 0, pretend = 0, frame = 0
 810              		@ frame_needed = 0, uses_anonymous_args = 0
 811              		@ link register save eliminated.
 557:../drivers/fsl_clock.c **** 
 812              		.loc 1 557 0
 813 0000 084B     		ldr	r3, .L105
 814 0002 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 815              	.LVL50:
 816 0004 C3F38103 		ubfx	r3, r3, #2, #2
 817              	.LVL51:
 559:../drivers/fsl_clock.c ****     {
 818              		.loc 1 559 0
 819 0008 022B     		cmp	r3, #2
 820 000a 09D0     		beq	.L101
 821 000c 032B     		cmp	r3, #3
 822 000e 03D0     		beq	.L102
 823 0010 012B     		cmp	r3, #1
 824 0012 03D1     		bne	.L104
 568:../drivers/fsl_clock.c ****             break;
 825              		.loc 1 568 0
 826 0014 FFF7FEBF 		b	CLOCK_GetInternalRefClkSelectFreq
 827              	.LVL52:
 828              	.L102:
 562:../drivers/fsl_clock.c ****             break;
 829              		.loc 1 562 0
 830 0018 FFF7FEBF 		b	CLOCK_GetPll0Freq
 831              	.LVL53:
 832              	.L104:
 565:../drivers/fsl_clock.c ****             break;
 833              		.loc 1 565 0
 834 001c FFF7FEBF 		b	CLOCK_GetFllFreq
 835              	.LVL54:
 836              	.L101:
 571:../drivers/fsl_clock.c ****             break;
 837              		.loc 1 571 0
 838 0020 FFF7FEBF 		b	CLOCK_GetMcgExtClkFreq
 839              	.LVL55:
 840              	.L106:
 841              		.align	2
 842              	.L105:
 843 0024 00400640 		.word	1074151424
 844              		.cfi_endproc
 845              	.LFE165:
 847              		.section	.text.CLOCK_GetFlashClkFreq,"ax",%progbits
 848              		.align	1
 849              		.global	CLOCK_GetFlashClkFreq
 850              		.syntax unified
 851              		.thumb
 852              		.thumb_func
 853              		.fpu fpv4-sp-d16
 855              	CLOCK_GetFlashClkFreq:
 856              	.LFB158:
 430:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 857              		.loc 1 430 0
 858              		.cfi_startproc
 859              		@ args = 0, pretend = 0, frame = 0
 860              		@ frame_needed = 0, uses_anonymous_args = 0
 861 0000 08B5     		push	{r3, lr}
 862              		.cfi_def_cfa_offset 8
 863              		.cfi_offset 3, -8
 864              		.cfi_offset 14, -4
 431:../drivers/fsl_clock.c **** }
 865              		.loc 1 431 0
 866 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 867              	.LVL56:
 868 0006 054A     		ldr	r2, .L108
 869 0008 41F24403 		movw	r3, #4164
 870 000c D358     		ldr	r3, [r2, r3]
 871 000e C3F30343 		ubfx	r3, r3, #16, #4
 872 0012 0133     		adds	r3, r3, #1
 432:../drivers/fsl_clock.c **** 
 873              		.loc 1 432 0
 874 0014 B0FBF3F0 		udiv	r0, r0, r3
 875 0018 08BD     		pop	{r3, pc}
 876              	.L109:
 877 001a 00BF     		.align	2
 878              	.L108:
 879 001c 00700440 		.word	1074032640
 880              		.cfi_endproc
 881              	.LFE158:
 883              		.section	.text.CLOCK_GetFlexBusClkFreq,"ax",%progbits
 884              		.align	1
 885              		.global	CLOCK_GetFlexBusClkFreq
 886              		.syntax unified
 887              		.thumb
 888              		.thumb_func
 889              		.fpu fpv4-sp-d16
 891              	CLOCK_GetFlexBusClkFreq:
 892              	.LFB159:
 435:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
 893              		.loc 1 435 0
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 0
 896              		@ frame_needed = 0, uses_anonymous_args = 0
 897 0000 08B5     		push	{r3, lr}
 898              		.cfi_def_cfa_offset 8
 899              		.cfi_offset 3, -8
 900              		.cfi_offset 14, -4
 436:../drivers/fsl_clock.c **** }
 901              		.loc 1 436 0
 902 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 903              	.LVL57:
 904 0006 054A     		ldr	r2, .L111
 905 0008 41F24403 		movw	r3, #4164
 906 000c D358     		ldr	r3, [r2, r3]
 907 000e C3F30353 		ubfx	r3, r3, #20, #4
 908 0012 0133     		adds	r3, r3, #1
 437:../drivers/fsl_clock.c **** 
 909              		.loc 1 437 0
 910 0014 B0FBF3F0 		udiv	r0, r0, r3
 911 0018 08BD     		pop	{r3, pc}
 912              	.L112:
 913 001a 00BF     		.align	2
 914              	.L111:
 915 001c 00700440 		.word	1074032640
 916              		.cfi_endproc
 917              	.LFE159:
 919              		.section	.text.CLOCK_GetBusClkFreq,"ax",%progbits
 920              		.align	1
 921              		.global	CLOCK_GetBusClkFreq
 922              		.syntax unified
 923              		.thumb
 924              		.thumb_func
 925              		.fpu fpv4-sp-d16
 927              	CLOCK_GetBusClkFreq:
 928              	.LFB160:
 440:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
 929              		.loc 1 440 0
 930              		.cfi_startproc
 931              		@ args = 0, pretend = 0, frame = 0
 932              		@ frame_needed = 0, uses_anonymous_args = 0
 933 0000 08B5     		push	{r3, lr}
 934              		.cfi_def_cfa_offset 8
 935              		.cfi_offset 3, -8
 936              		.cfi_offset 14, -4
 441:../drivers/fsl_clock.c **** }
 937              		.loc 1 441 0
 938 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 939              	.LVL58:
 940 0006 054A     		ldr	r2, .L114
 941 0008 41F24403 		movw	r3, #4164
 942 000c D358     		ldr	r3, [r2, r3]
 943 000e C3F30363 		ubfx	r3, r3, #24, #4
 944 0012 0133     		adds	r3, r3, #1
 442:../drivers/fsl_clock.c **** 
 945              		.loc 1 442 0
 946 0014 B0FBF3F0 		udiv	r0, r0, r3
 947 0018 08BD     		pop	{r3, pc}
 948              	.L115:
 949 001a 00BF     		.align	2
 950              	.L114:
 951 001c 00700440 		.word	1074032640
 952              		.cfi_endproc
 953              	.LFE160:
 955              		.section	.text.CLOCK_GetCoreSysClkFreq,"ax",%progbits
 956              		.align	1
 957              		.global	CLOCK_GetCoreSysClkFreq
 958              		.syntax unified
 959              		.thumb
 960              		.thumb_func
 961              		.fpu fpv4-sp-d16
 963              	CLOCK_GetCoreSysClkFreq:
 964              	.LFB161:
 445:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 965              		.loc 1 445 0
 966              		.cfi_startproc
 967              		@ args = 0, pretend = 0, frame = 0
 968              		@ frame_needed = 0, uses_anonymous_args = 0
 969 0000 08B5     		push	{r3, lr}
 970              		.cfi_def_cfa_offset 8
 971              		.cfi_offset 3, -8
 972              		.cfi_offset 14, -4
 446:../drivers/fsl_clock.c **** }
 973              		.loc 1 446 0
 974 0002 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 975              	.LVL59:
 976 0006 044A     		ldr	r2, .L117
 977 0008 41F24403 		movw	r3, #4164
 978 000c D358     		ldr	r3, [r2, r3]
 979 000e 1B0F     		lsrs	r3, r3, #28
 980 0010 0133     		adds	r3, r3, #1
 447:../drivers/fsl_clock.c **** 
 981              		.loc 1 447 0
 982 0012 B0FBF3F0 		udiv	r0, r0, r3
 983 0016 08BD     		pop	{r3, pc}
 984              	.L118:
 985              		.align	2
 986              	.L117:
 987 0018 00700440 		.word	1074032640
 988              		.cfi_endproc
 989              	.LFE161:
 991              		.section	.text.CLOCK_GetPlatClkFreq,"ax",%progbits
 992              		.align	1
 993              		.global	CLOCK_GetPlatClkFreq
 994              		.syntax unified
 995              		.thumb
 996              		.thumb_func
 997              		.fpu fpv4-sp-d16
 999              	CLOCK_GetPlatClkFreq:
 1000              	.LFB205:
 1001              		.cfi_startproc
 1002              		@ args = 0, pretend = 0, frame = 0
 1003              		@ frame_needed = 0, uses_anonymous_args = 0
 1004              		@ link register save eliminated.
 1005 0000 FFF7FEBF 		b	CLOCK_GetCoreSysClkFreq
 1006              		.cfi_endproc
 1007              	.LFE205:
 1009              		.section	.text.CLOCK_GetFixedFreqClkFreq,"ax",%progbits
 1010              		.align	1
 1011              		.global	CLOCK_GetFixedFreqClkFreq
 1012              		.syntax unified
 1013              		.thumb
 1014              		.thumb_func
 1015              		.fpu fpv4-sp-d16
 1017              	CLOCK_GetFixedFreqClkFreq:
 1018              	.LFB168:
 618:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 1019              		.loc 1 618 0
 1020              		.cfi_startproc
 1021              		@ args = 0, pretend = 0, frame = 0
 1022              		@ frame_needed = 0, uses_anonymous_args = 0
 618:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 1023              		.loc 1 618 0
 1024 0000 10B5     		push	{r4, lr}
 1025              		.cfi_def_cfa_offset 8
 1026              		.cfi_offset 4, -8
 1027              		.cfi_offset 14, -4
 1028              	.LBB58:
 1029              	.LBB59:
 326:../drivers/fsl_clock.c ****     {
 1030              		.loc 1 326 0
 1031 0002 0A4B     		ldr	r3, .L126
 1032 0004 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1033 0006 DB06     		lsls	r3, r3, #27
 1034 0008 06D4     		bmi	.L121
 328:../drivers/fsl_clock.c ****     }
 1035              		.loc 1 328 0
 1036 000a FFF7FEFF 		bl	CLOCK_GetFllExtRefClkFreq
 1037              	.LVL60:
 1038 000e 0446     		mov	r4, r0
 1039              	.L122:
 1040              	.LBE59:
 1041              	.LBE58:
 622:../drivers/fsl_clock.c ****     {
 1042              		.loc 1 622 0
 1043 0010 2CB9     		cbnz	r4, .L123
 1044              	.L125:
 628:../drivers/fsl_clock.c ****     }
 1045              		.loc 1 628 0
 1046 0012 0024     		movs	r4, #0
 1047              	.L120:
 630:../drivers/fsl_clock.c **** 
 1048              		.loc 1 630 0
 1049 0014 2046     		mov	r0, r4
 1050 0016 10BD     		pop	{r4, pc}
 1051              	.L121:
 1052              	.LBB61:
 1053              	.LBB60:
 333:../drivers/fsl_clock.c ****     }
 1054              		.loc 1 333 0
 1055 0018 054B     		ldr	r3, .L126+4
 1056 001a 1C68     		ldr	r4, [r3]
 1057 001c F8E7     		b	.L122
 1058              	.L123:
 1059              	.LBE60:
 1060              	.LBE61:
 622:../drivers/fsl_clock.c ****     {
 1061              		.loc 1 622 0 discriminator 1
 1062 001e FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1063              	.LVL61:
 1064 0022 B4EBD00F 		cmp	r4, r0, lsr #3
 1065 0026 F4D8     		bhi	.L125
 1066 0028 F4E7     		b	.L120
 1067              	.L127:
 1068 002a 00BF     		.align	2
 1069              	.L126:
 1070 002c 00400640 		.word	1074151424
 1071 0030 00000000 		.word	.LANCHOR0
 1072              		.cfi_endproc
 1073              	.LFE168:
 1075              		.section	.text.CLOCK_GetFreq,"ax",%progbits
 1076              		.align	1
 1077              		.global	CLOCK_GetFreq
 1078              		.syntax unified
 1079              		.thumb
 1080              		.thumb_func
 1081              		.fpu fpv4-sp-d16
 1083              	CLOCK_GetFreq:
 1084              	.LFB162:
 450:../drivers/fsl_clock.c ****     uint32_t freq;
 1085              		.loc 1 450 0
 1086              		.cfi_startproc
 1087              		@ args = 0, pretend = 0, frame = 0
 1088              		@ frame_needed = 0, uses_anonymous_args = 0
 1089              	.LVL62:
 1090 0000 08B5     		push	{r3, lr}
 1091              		.cfi_def_cfa_offset 8
 1092              		.cfi_offset 3, -8
 1093              		.cfi_offset 14, -4
 453:../drivers/fsl_clock.c ****     {
 1094              		.loc 1 453 0
 1095 0002 1328     		cmp	r0, #19
 1096 0004 50D8     		bhi	.L129
 1097 0006 DFE800F0 		tbb	[pc, r0]
 1098              	.L131:
 1099 000a 0D       		.byte	(.L130-.L131)/2
 1100 000b 0D       		.byte	(.L130-.L131)/2
 1101 000c 18       		.byte	(.L132-.L131)/2
 1102 000d 21       		.byte	(.L133-.L131)/2
 1103 000e 2A       		.byte	(.L134-.L131)/2
 1104 000f 4F       		.byte	(.L129-.L131)/2
 1105 0010 33       		.byte	(.L135-.L131)/2
 1106 0011 37       		.byte	(.L136-.L131)/2
 1107 0012 3B       		.byte	(.L137-.L131)/2
 1108 0013 4F       		.byte	(.L129-.L131)/2
 1109 0014 4F       		.byte	(.L129-.L131)/2
 1110 0015 3F       		.byte	(.L138-.L131)/2
 1111 0016 43       		.byte	(.L139-.L131)/2
 1112 0017 47       		.byte	(.L140-.L131)/2
 1113 0018 4B       		.byte	(.L141-.L131)/2
 1114 0019 4F       		.byte	(.L129-.L131)/2
 1115 001a 4F       		.byte	(.L129-.L131)/2
 1116 001b 4F       		.byte	(.L129-.L131)/2
 1117 001c 51       		.byte	(.L144-.L131)/2
 1118 001d 0A       		.byte	(.L143-.L131)/2
 1119              		.p2align 1
 1120              	.L143:
 493:../drivers/fsl_clock.c ****             break;
 1121              		.loc 1 493 0
 1122 001e 4FF47A70 		mov	r0, #1000
 1123              	.LVL63:
 1124              	.L128:
 501:../drivers/fsl_clock.c **** 
 1125              		.loc 1 501 0
 1126 0022 08BD     		pop	{r3, pc}
 1127              	.LVL64:
 1128              	.L130:
 457:../drivers/fsl_clock.c ****             break;
 1129              		.loc 1 457 0
 1130 0024 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1131              	.LVL65:
 1132 0028 214A     		ldr	r2, .L146
 1133 002a 41F24403 		movw	r3, #4164
 1134 002e D358     		ldr	r3, [r2, r3]
 1135 0030 1B0F     		lsrs	r3, r3, #28
 1136              	.L145:
 466:../drivers/fsl_clock.c ****             break;
 1137              		.loc 1 466 0
 1138 0032 0133     		adds	r3, r3, #1
 1139 0034 B0FBF3F0 		udiv	r0, r0, r3
 1140              	.LVL66:
 467:../drivers/fsl_clock.c ****         case kCLOCK_PllFllSelClk:
 1141              		.loc 1 467 0
 1142 0038 F3E7     		b	.L128
 1143              	.LVL67:
 1144              	.L132:
 460:../drivers/fsl_clock.c ****             break;
 1145              		.loc 1 460 0
 1146 003a FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1147              	.LVL68:
 1148 003e 1C4A     		ldr	r2, .L146
 1149 0040 41F24403 		movw	r3, #4164
 1150 0044 D358     		ldr	r3, [r2, r3]
 1151 0046 C3F30363 		ubfx	r3, r3, #24, #4
 1152 004a F2E7     		b	.L145
 1153              	.LVL69:
 1154              	.L133:
 463:../drivers/fsl_clock.c ****             break;
 1155              		.loc 1 463 0
 1156 004c FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1157              	.LVL70:
 1158 0050 174A     		ldr	r2, .L146
 1159 0052 41F24403 		movw	r3, #4164
 1160 0056 D358     		ldr	r3, [r2, r3]
 1161 0058 C3F30353 		ubfx	r3, r3, #20, #4
 1162 005c E9E7     		b	.L145
 1163              	.LVL71:
 1164              	.L134:
 466:../drivers/fsl_clock.c ****             break;
 1165              		.loc 1 466 0
 1166 005e FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1167              	.LVL72:
 1168 0062 134A     		ldr	r2, .L146
 1169 0064 41F24403 		movw	r3, #4164
 1170 0068 D358     		ldr	r3, [r2, r3]
 1171 006a C3F30343 		ubfx	r3, r3, #16, #4
 1172 006e E0E7     		b	.L145
 1173              	.LVL73:
 1174              	.L135:
 501:../drivers/fsl_clock.c **** 
 1175              		.loc 1 501 0
 1176 0070 BDE80840 		pop	{r3, lr}
 1177              		.cfi_remember_state
 1178              		.cfi_restore 14
 1179              		.cfi_restore 3
 1180              		.cfi_def_cfa_offset 0
 469:../drivers/fsl_clock.c ****             break;
 1181              		.loc 1 469 0
 1182 0074 FFF7FEBF 		b	CLOCK_GetPllFllSelClkFreq
 1183              	.LVL74:
 1184              	.L136:
 1185              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1186              		.loc 1 501 0
 1187 0078 BDE80840 		pop	{r3, lr}
 1188              		.cfi_remember_state
 1189              		.cfi_restore 14
 1190              		.cfi_restore 3
 1191              		.cfi_def_cfa_offset 0
 472:../drivers/fsl_clock.c ****             break;
 1192              		.loc 1 472 0
 1193 007c FFF7FEBF 		b	CLOCK_GetEr32kClkFreq
 1194              	.LVL75:
 1195              	.L137:
 1196              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1197              		.loc 1 501 0
 1198 0080 BDE80840 		pop	{r3, lr}
 1199              		.cfi_remember_state
 1200              		.cfi_restore 14
 1201              		.cfi_restore 3
 1202              		.cfi_def_cfa_offset 0
 475:../drivers/fsl_clock.c ****             break;
 1203              		.loc 1 475 0
 1204 0084 FFF7FEBF 		b	CLOCK_GetOsc0ErClkFreq
 1205              	.LVL76:
 1206              	.L138:
 1207              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1208              		.loc 1 501 0
 1209 0088 BDE80840 		pop	{r3, lr}
 1210              		.cfi_remember_state
 1211              		.cfi_restore 14
 1212              		.cfi_restore 3
 1213              		.cfi_def_cfa_offset 0
 478:../drivers/fsl_clock.c ****             break;
 1214              		.loc 1 478 0
 1215 008c FFF7FEBF 		b	CLOCK_GetFixedFreqClkFreq
 1216              	.LVL77:
 1217              	.L139:
 1218              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1219              		.loc 1 501 0
 1220 0090 BDE80840 		pop	{r3, lr}
 1221              		.cfi_remember_state
 1222              		.cfi_restore 14
 1223              		.cfi_restore 3
 1224              		.cfi_def_cfa_offset 0
 481:../drivers/fsl_clock.c ****             break;
 1225              		.loc 1 481 0
 1226 0094 FFF7FEBF 		b	CLOCK_GetInternalRefClkFreq
 1227              	.LVL78:
 1228              	.L140:
 1229              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1230              		.loc 1 501 0
 1231 0098 BDE80840 		pop	{r3, lr}
 1232              		.cfi_remember_state
 1233              		.cfi_restore 14
 1234              		.cfi_restore 3
 1235              		.cfi_def_cfa_offset 0
 484:../drivers/fsl_clock.c ****             break;
 1236              		.loc 1 484 0
 1237 009c FFF7FEBF 		b	CLOCK_GetFllFreq
 1238              	.LVL79:
 1239              	.L141:
 1240              		.cfi_restore_state
 501:../drivers/fsl_clock.c **** 
 1241              		.loc 1 501 0
 1242 00a0 BDE80840 		pop	{r3, lr}
 1243              		.cfi_remember_state
 1244              		.cfi_restore 14
 1245              		.cfi_restore 3
 1246              		.cfi_def_cfa_offset 0
 487:../drivers/fsl_clock.c ****             break;
 1247              		.loc 1 487 0
 1248 00a4 FFF7FEBF 		b	CLOCK_GetPll0Freq
 1249              	.LVL80:
 1250              	.L129:
 1251              		.cfi_restore_state
 496:../drivers/fsl_clock.c ****             break;
 1252              		.loc 1 496 0
 1253 00a8 0020     		movs	r0, #0
 1254              	.LVL81:
 497:../drivers/fsl_clock.c ****     }
 1255              		.loc 1 497 0
 1256 00aa BAE7     		b	.L128
 1257              	.LVL82:
 1258              	.L144:
 490:../drivers/fsl_clock.c ****             break;
 1259              		.loc 1 490 0
 1260 00ac 0148     		ldr	r0, .L146+4
 1261              	.LVL83:
 500:../drivers/fsl_clock.c **** }
 1262              		.loc 1 500 0
 1263 00ae B8E7     		b	.L128
 1264              	.L147:
 1265              		.align	2
 1266              	.L146:
 1267 00b0 00700440 		.word	1074032640
 1268 00b4 006CDC02 		.word	48000000
 1269              		.cfi_endproc
 1270              	.LFE162:
 1272              		.section	.text.CLOCK_SetExternalRefClkConfig,"ax",%progbits
 1273              		.align	1
 1274              		.global	CLOCK_SetExternalRefClkConfig
 1275              		.syntax unified
 1276              		.thumb
 1277              		.thumb_func
 1278              		.fpu fpv4-sp-d16
 1280              	CLOCK_SetExternalRefClkConfig:
 1281              	.LFB170:
 655:../drivers/fsl_clock.c **** 
 656:../drivers/fsl_clock.c **** status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
 657:../drivers/fsl_clock.c **** {
 1282              		.loc 1 657 0
 1283              		.cfi_startproc
 1284              		@ args = 0, pretend = 0, frame = 0
 1285              		@ frame_needed = 0, uses_anonymous_args = 0
 1286              	.LVL84:
 1287 0000 10B5     		push	{r4, lr}
 1288              		.cfi_def_cfa_offset 8
 1289              		.cfi_offset 4, -8
 1290              		.cfi_offset 14, -4
 658:../drivers/fsl_clock.c ****     bool needDelay;
 659:../drivers/fsl_clock.c ****     uint32_t i;
 660:../drivers/fsl_clock.c **** 
 661:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
 662:../drivers/fsl_clock.c ****     /* If change MCG_C7[OSCSEL] and external reference clock is system clock source, return error. 
 663:../drivers/fsl_clock.c ****     if ((MCG_C7_OSCSEL_VAL != oscsel) && (!(MCG->S & MCG_S_IREFST_MASK)))
 664:../drivers/fsl_clock.c ****     {
 665:../drivers/fsl_clock.c ****         return kStatus_MCG_SourceUsed;
 666:../drivers/fsl_clock.c ****     }
 667:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
 668:../drivers/fsl_clock.c **** 
 669:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL_VAL != oscsel)
 1291              		.loc 1 669 0
 1292 0002 0B49     		ldr	r1, .L154
 1293 0004 0A7B     		ldrb	r2, [r1, #12]	@ zero_extendqisi2
 1294              	.LVL85:
 670:../drivers/fsl_clock.c ****     {
 671:../drivers/fsl_clock.c ****         /* If change OSCSEL, need to delay, ERR009878. */
 672:../drivers/fsl_clock.c ****         needDelay = true;
 673:../drivers/fsl_clock.c ****     }
 674:../drivers/fsl_clock.c ****     else
 675:../drivers/fsl_clock.c ****     {
 676:../drivers/fsl_clock.c ****         needDelay = false;
 677:../drivers/fsl_clock.c ****     }
 678:../drivers/fsl_clock.c **** 
 679:../drivers/fsl_clock.c ****     MCG->C7 = (MCG->C7 & ~MCG_C7_OSCSEL_MASK) | MCG_C7_OSCSEL(oscsel);
 1295              		.loc 1 679 0
 1296 0006 0B7B     		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 1297 0008 00F00304 		and	r4, r0, #3
 1298 000c 03F0FC03 		and	r3, r3, #252
 1299 0010 2343     		orrs	r3, r3, r4
 1300 0012 0B73     		strb	r3, [r1, #12]
 680:../drivers/fsl_clock.c ****     if (needDelay)
 1301              		.loc 1 680 0
 1302 0014 02F00303 		and	r3, r2, #3
 1303 0018 8342     		cmp	r3, r0
 1304 001a 05D1     		bne	.L152
 1305              	.L153:
 681:../drivers/fsl_clock.c ****     {
 682:../drivers/fsl_clock.c ****         /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
 683:../drivers/fsl_clock.c ****         i = 1500U;
 684:../drivers/fsl_clock.c ****         while (i--)
 685:../drivers/fsl_clock.c ****         {
 686:../drivers/fsl_clock.c ****             __NOP();
 687:../drivers/fsl_clock.c ****         }
 688:../drivers/fsl_clock.c ****     }
 689:../drivers/fsl_clock.c **** 
 690:../drivers/fsl_clock.c ****     return kStatus_Success;
 691:../drivers/fsl_clock.c **** }
 1306              		.loc 1 691 0
 1307 001c 0020     		movs	r0, #0
 1308              	.LVL86:
 1309 001e 10BD     		pop	{r4, pc}
 1310              	.LVL87:
 1311              	.L150:
 1312              	.LBB64:
 1313              	.LBB65:
 686:../drivers/fsl_clock.c ****         }
 1314              		.loc 1 686 0
 1315              		.syntax unified
 1316              	@ 686 "../drivers/fsl_clock.c" 1
 1317 0020 00BF     		nop
 1318              	@ 0 "" 2
 1319              	.LVL88:
 1320              		.thumb
 1321              		.syntax unified
 1322              	.L149:
 684:../drivers/fsl_clock.c ****         {
 1323              		.loc 1 684 0
 1324 0022 013B     		subs	r3, r3, #1
 1325              	.LVL89:
 1326 0024 FCD1     		bne	.L150
 1327 0026 F9E7     		b	.L153
 1328              	.LVL90:
 1329              	.L152:
 1330              	.LBE65:
 1331              	.LBE64:
 1332 0028 40F2DD53 		movw	r3, #1501
 1333 002c F9E7     		b	.L149
 1334              	.L155:
 1335 002e 00BF     		.align	2
 1336              	.L154:
 1337 0030 00400640 		.word	1074151424
 1338              		.cfi_endproc
 1339              	.LFE170:
 1341              		.section	.text.CLOCK_SetInternalRefClkConfig,"ax",%progbits
 1342              		.align	1
 1343              		.global	CLOCK_SetInternalRefClkConfig
 1344              		.syntax unified
 1345              		.thumb
 1346              		.thumb_func
 1347              		.fpu fpv4-sp-d16
 1349              	CLOCK_SetInternalRefClkConfig:
 1350              	.LFB171:
 692:../drivers/fsl_clock.c **** 
 693:../drivers/fsl_clock.c **** status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
 694:../drivers/fsl_clock.c **** {
 1351              		.loc 1 694 0
 1352              		.cfi_startproc
 1353              		@ args = 0, pretend = 0, frame = 0
 1354              		@ frame_needed = 0, uses_anonymous_args = 0
 1355              	.LVL91:
 1356 0000 70B5     		push	{r4, r5, r6, lr}
 1357              		.cfi_def_cfa_offset 16
 1358              		.cfi_offset 4, -16
 1359              		.cfi_offset 5, -12
 1360              		.cfi_offset 6, -8
 1361              		.cfi_offset 14, -4
 695:../drivers/fsl_clock.c ****     uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
 1362              		.loc 1 695 0
 1363 0002 1D4B     		ldr	r3, .L180
 1364 0004 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 696:../drivers/fsl_clock.c ****     mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
 1365              		.loc 1 696 0
 1366 0006 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 697:../drivers/fsl_clock.c ****     uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
 1367              		.loc 1 697 0
 1368 0008 1E7A     		ldrb	r6, [r3, #8]	@ zero_extendqisi2
 698:../drivers/fsl_clock.c **** 
 699:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
 700:../drivers/fsl_clock.c ****     /* If MCGIRCLK is used as system clock source. */
 701:../drivers/fsl_clock.c ****     if (kMCG_ClkOutStatInt == mcgOutClkState)
 702:../drivers/fsl_clock.c ****     {
 703:../drivers/fsl_clock.c ****         /* If need to change MCGIRCLK source or driver, return error. */
 704:../drivers/fsl_clock.c ****         if (((kMCG_IrcFast == curIrcs) && (fcrdiv != curFcrdiv)) || (ircs != curIrcs))
 705:../drivers/fsl_clock.c ****         {
 706:../drivers/fsl_clock.c ****             return kStatus_MCG_SourceUsed;
 707:../drivers/fsl_clock.c ****         }
 708:../drivers/fsl_clock.c ****     }
 709:../drivers/fsl_clock.c **** #endif
 710:../drivers/fsl_clock.c **** 
 711:../drivers/fsl_clock.c ****     /* If need to update the FCRDIV. */
 712:../drivers/fsl_clock.c ****     if (fcrdiv != curFcrdiv)
 1369              		.loc 1 712 0
 1370 000a C6F34206 		ubfx	r6, r6, #1, #3
 1371 000e 9642     		cmp	r6, r2
 695:../drivers/fsl_clock.c ****     mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
 1372              		.loc 1 695 0
 1373 0010 C4F38104 		ubfx	r4, r4, #2, #2
 1374              	.LVL92:
 696:../drivers/fsl_clock.c ****     uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
 1375              		.loc 1 696 0
 1376 0014 EDB2     		uxtb	r5, r5
 1377              	.LVL93:
 1378              		.loc 1 712 0
 1379 0016 17D0     		beq	.L157
 713:../drivers/fsl_clock.c ****     {
 714:../drivers/fsl_clock.c ****         /* If fast IRC is in use currently, change to slow IRC. */
 715:../drivers/fsl_clock.c ****         if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (MCG->C1 & MCG_
 1380              		.loc 1 715 0
 1381 0018 ED07     		lsls	r5, r5, #31
 1382              	.LVL94:
 1383 001a 0CD5     		bpl	.L158
 1384              		.loc 1 715 0 is_stmt 0 discriminator 1
 1385 001c 012C     		cmp	r4, #1
 1386 001e 02D0     		beq	.L159
 1387              		.loc 1 715 0 discriminator 2
 1388 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1389 0022 9E07     		lsls	r6, r3, #30
 1390 0024 07D5     		bpl	.L158
 1391              	.L159:
 716:../drivers/fsl_clock.c ****         {
 717:../drivers/fsl_clock.c ****             MCG->C2 = ((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(kMCG_IrcSlow)));
 1392              		.loc 1 717 0 is_stmt 1
 1393 0026 144B     		ldr	r3, .L180
 1394 0028 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
 1395 002a 05F0FE05 		and	r5, r5, #254
 1396 002e 5D70     		strb	r5, [r3, #1]
 1397              	.L160:
 718:../drivers/fsl_clock.c ****             while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
 1398              		.loc 1 718 0 discriminator 1
 1399 0030 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 1400 0032 ED07     		lsls	r5, r5, #31
 1401 0034 FCD4     		bmi	.L160
 1402              	.L158:
 719:../drivers/fsl_clock.c ****             {
 720:../drivers/fsl_clock.c ****             }
 721:../drivers/fsl_clock.c ****         }
 722:../drivers/fsl_clock.c ****         /* Update FCRDIV. */
 723:../drivers/fsl_clock.c ****         MCG->SC = (MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC
 1403              		.loc 1 723 0
 1404 0036 104D     		ldr	r5, .L180
 1405 0038 2B7A     		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 1406 003a 5200     		lsls	r2, r2, #1
 1407              	.LVL95:
 1408 003c 02F00E02 		and	r2, r2, #14
 1409 0040 03F0D003 		and	r3, r3, #208
 1410 0044 1A43     		orrs	r2, r2, r3
 1411 0046 2A72     		strb	r2, [r5, #8]
 1412              	.L157:
 724:../drivers/fsl_clock.c ****     }
 725:../drivers/fsl_clock.c **** 
 726:../drivers/fsl_clock.c ****     /* Set internal reference clock selection. */
 727:../drivers/fsl_clock.c ****     MCG->C2 = (MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(ircs));
 1413              		.loc 1 727 0
 1414 0048 0B4B     		ldr	r3, .L180
 1415 004a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1416 004c 01F00105 		and	r5, r1, #1
 1417 0050 02F0FE02 		and	r2, r2, #254
 1418 0054 2A43     		orrs	r2, r2, r5
 1419 0056 5A70     		strb	r2, [r3, #1]
 728:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
 1420              		.loc 1 728 0
 1421 0058 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1422 005a 02F0FC02 		and	r2, r2, #252
 1423 005e 0243     		orrs	r2, r2, r0
 729:../drivers/fsl_clock.c **** 
 730:../drivers/fsl_clock.c ****     /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
 731:../drivers/fsl_clock.c ****     if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
 1424              		.loc 1 731 0
 1425 0060 012C     		cmp	r4, #1
 728:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
 1426              		.loc 1 728 0
 1427 0062 1A70     		strb	r2, [r3]
 1428              		.loc 1 731 0
 1429 0064 01D0     		beq	.L172
 1430              		.loc 1 731 0 is_stmt 0 discriminator 1
 1431 0066 8207     		lsls	r2, r0, #30
 1432 0068 04D5     		bpl	.L162
 1433              	.L172:
 732:../drivers/fsl_clock.c ****     {
 733:../drivers/fsl_clock.c ****         while (MCG_S_IRCST_VAL != ircs)
 1434              		.loc 1 733 0 is_stmt 1 discriminator 1
 1435 006a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1436 006c 02F00102 		and	r2, r2, #1
 1437 0070 8A42     		cmp	r2, r1
 1438 0072 FAD1     		bne	.L172
 1439              	.L162:
 734:../drivers/fsl_clock.c ****         {
 735:../drivers/fsl_clock.c ****         }
 736:../drivers/fsl_clock.c ****     }
 737:../drivers/fsl_clock.c **** 
 738:../drivers/fsl_clock.c ****     return kStatus_Success;
 739:../drivers/fsl_clock.c **** }
 1440              		.loc 1 739 0
 1441 0074 0020     		movs	r0, #0
 1442              	.LVL96:
 1443 0076 70BD     		pop	{r4, r5, r6, pc}
 1444              	.LVL97:
 1445              	.L181:
 1446              		.align	2
 1447              	.L180:
 1448 0078 00400640 		.word	1074151424
 1449              		.cfi_endproc
 1450              	.LFE171:
 1452              		.section	.text.CLOCK_CalcPllDiv,"ax",%progbits
 1453              		.align	1
 1454              		.global	CLOCK_CalcPllDiv
 1455              		.syntax unified
 1456              		.thumb
 1457              		.thumb_func
 1458              		.fpu fpv4-sp-d16
 1460              	CLOCK_CalcPllDiv:
 1461              	.LFB172:
 740:../drivers/fsl_clock.c **** 
 741:../drivers/fsl_clock.c **** uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv)
 742:../drivers/fsl_clock.c **** {
 1462              		.loc 1 742 0
 1463              		.cfi_startproc
 1464              		@ args = 0, pretend = 0, frame = 0
 1465              		@ frame_needed = 0, uses_anonymous_args = 0
 1466              	.LVL98:
 1467 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1468              		.cfi_def_cfa_offset 36
 1469              		.cfi_offset 4, -36
 1470              		.cfi_offset 5, -32
 1471              		.cfi_offset 6, -28
 1472              		.cfi_offset 7, -24
 1473              		.cfi_offset 8, -20
 1474              		.cfi_offset 9, -16
 1475              		.cfi_offset 10, -12
 1476              		.cfi_offset 11, -8
 1477              		.cfi_offset 14, -4
 1478              		.loc 1 742 0
 1479 0004 0746     		mov	r7, r0
 743:../drivers/fsl_clock.c ****     uint8_t ret_prdiv;           /* PRDIV to return. */
 744:../drivers/fsl_clock.c ****     uint8_t ret_vdiv;            /* VDIV to return.  */
 745:../drivers/fsl_clock.c ****     uint8_t prdiv_min;           /* Min PRDIV value to make reference clock in allowed range. */
 746:../drivers/fsl_clock.c ****     uint8_t prdiv_max;           /* Max PRDIV value to make reference clock in allowed range. */
 747:../drivers/fsl_clock.c ****     uint8_t prdiv_cur;           /* PRDIV value for iteration.    */
 748:../drivers/fsl_clock.c ****     uint8_t vdiv_cur;            /* VDIV value for iteration.     */
 749:../drivers/fsl_clock.c ****     uint32_t ret_freq = 0U;      /* PLL output fequency to return. */
 750:../drivers/fsl_clock.c ****     uint32_t diff = 0xFFFFFFFFU; /* Difference between desireFreq and return frequency. */
 751:../drivers/fsl_clock.c ****     uint32_t ref_div;            /* Reference frequency after PRDIV. */
 752:../drivers/fsl_clock.c **** 
 753:../drivers/fsl_clock.c ****     /*
 754:../drivers/fsl_clock.c ****        Steps:
 755:../drivers/fsl_clock.c ****        1. Get allowed prdiv with such rules:
 756:../drivers/fsl_clock.c ****           1). refFreq / prdiv >= FSL_FEATURE_MCG_PLL_REF_MIN.
 757:../drivers/fsl_clock.c ****           2). refFreq / prdiv <= FSL_FEATURE_MCG_PLL_REF_MAX.
 758:../drivers/fsl_clock.c ****        2. For each allowed prdiv, there are two candidate vdiv values:
 759:../drivers/fsl_clock.c ****           1). (desireFreq / (refFreq / prdiv)).
 760:../drivers/fsl_clock.c ****           2). (desireFreq / (refFreq / prdiv)) + 1.
 761:../drivers/fsl_clock.c ****           If could get the precise desired frequency, return current prdiv and
 762:../drivers/fsl_clock.c ****           vdiv directly. Otherwise choose the one which is closer to desired
 763:../drivers/fsl_clock.c ****           frequency.
 764:../drivers/fsl_clock.c ****      */
 765:../drivers/fsl_clock.c **** 
 766:../drivers/fsl_clock.c ****     /* Reference frequency is out of range. */
 767:../drivers/fsl_clock.c ****     if ((refFreq < FSL_FEATURE_MCG_PLL_REF_MIN) ||
 1480              		.loc 1 767 0
 1481 0006 2A4C     		ldr	r4, .L197
 1482 0008 A0F5F410 		sub	r0, r0, #1998848
 1483              	.LVL99:
 1484 000c A0F59060 		sub	r0, r0, #1152
 1485 0010 A042     		cmp	r0, r4
 1486 0012 4AD8     		bhi	.L190
 768:../drivers/fsl_clock.c ****         (refFreq > (FSL_FEATURE_MCG_PLL_REF_MAX * (FSL_FEATURE_MCG_PLL_PRDIV_MAX + FSL_FEATURE_MCG_
 769:../drivers/fsl_clock.c ****     {
 770:../drivers/fsl_clock.c ****         return 0U;
 771:../drivers/fsl_clock.c ****     }
 772:../drivers/fsl_clock.c **** 
 773:../drivers/fsl_clock.c ****     /* refFreq/PRDIV must in a range. First get the allowed PRDIV range. */
 774:../drivers/fsl_clock.c ****     prdiv_max = refFreq / FSL_FEATURE_MCG_PLL_REF_MIN;
 775:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1487              		.loc 1 775 0
 1488 0014 07F5741C 		add	ip, r7, #3997696
 774:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1489              		.loc 1 774 0
 1490 0018 264D     		ldr	r5, .L197+4
 1491              		.loc 1 775 0
 1492 001a 2748     		ldr	r0, .L197+8
 774:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1493              		.loc 1 774 0
 1494 001c B7FBF5F5 		udiv	r5, r7, r5
 1495              		.loc 1 775 0
 1496 0020 0CF6FF0C 		addw	ip, ip, #2303
 774:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 1497              		.loc 1 774 0
 1498 0024 EDB2     		uxtb	r5, r5
 1499              	.LVL100:
 1500              		.loc 1 775 0
 1501 0026 BCFBF0FC 		udiv	ip, ip, r0
 750:../drivers/fsl_clock.c ****     uint32_t ref_div;            /* Reference frequency after PRDIV. */
 1502              		.loc 1 750 0
 1503 002a 4FF0FF3E 		mov	lr, #-1
 1504              		.loc 1 775 0
 1505 002e 5FFA8CFC 		uxtb	ip, ip
 1506              	.LVL101:
 1507              	.L184:
 776:../drivers/fsl_clock.c **** 
 777:../drivers/fsl_clock.c ****     /* PRDIV traversal. */
 778:../drivers/fsl_clock.c ****     for (prdiv_cur = prdiv_max; prdiv_cur >= prdiv_min; prdiv_cur--)
 1508              		.loc 1 778 0 discriminator 1
 1509 0032 6545     		cmp	r5, ip
 1510 0034 0DD2     		bcs	.L188
 779:../drivers/fsl_clock.c ****     {
 780:../drivers/fsl_clock.c ****         /* Reference frequency after PRDIV. */
 781:../drivers/fsl_clock.c ****         ref_div = refFreq / prdiv_cur;
 782:../drivers/fsl_clock.c **** 
 783:../drivers/fsl_clock.c ****         vdiv_cur = desireFreq / ref_div;
 784:../drivers/fsl_clock.c **** 
 785:../drivers/fsl_clock.c ****         if ((vdiv_cur < FSL_FEATURE_MCG_PLL_VDIV_BASE - 1U) || (vdiv_cur > FSL_FEATURE_MCG_PLL_VDIV
 786:../drivers/fsl_clock.c ****         {
 787:../drivers/fsl_clock.c ****             /* No VDIV is available with this PRDIV. */
 788:../drivers/fsl_clock.c ****             continue;
 789:../drivers/fsl_clock.c ****         }
 790:../drivers/fsl_clock.c **** 
 791:../drivers/fsl_clock.c ****         ret_freq = vdiv_cur * ref_div;
 792:../drivers/fsl_clock.c **** 
 793:../drivers/fsl_clock.c ****         if (vdiv_cur >= FSL_FEATURE_MCG_PLL_VDIV_BASE)
 794:../drivers/fsl_clock.c ****         {
 795:../drivers/fsl_clock.c ****             if (ret_freq == desireFreq) /* If desire frequency is got. */
 796:../drivers/fsl_clock.c ****             {
 797:../drivers/fsl_clock.c ****                 *prdiv = prdiv_cur - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
 798:../drivers/fsl_clock.c ****                 *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 799:../drivers/fsl_clock.c ****                 return ret_freq;
 800:../drivers/fsl_clock.c ****             }
 801:../drivers/fsl_clock.c ****             /* New PRDIV/VDIV is closer. */
 802:../drivers/fsl_clock.c ****             if (diff > desireFreq - ret_freq)
 803:../drivers/fsl_clock.c ****             {
 804:../drivers/fsl_clock.c ****                 diff = desireFreq - ret_freq;
 805:../drivers/fsl_clock.c ****                 ret_prdiv = prdiv_cur;
 806:../drivers/fsl_clock.c ****                 ret_vdiv = vdiv_cur;
 807:../drivers/fsl_clock.c ****             }
 808:../drivers/fsl_clock.c ****         }
 809:../drivers/fsl_clock.c ****         vdiv_cur++;
 810:../drivers/fsl_clock.c ****         if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
 811:../drivers/fsl_clock.c ****         {
 812:../drivers/fsl_clock.c ****             ret_freq += ref_div;
 813:../drivers/fsl_clock.c ****             /* New PRDIV/VDIV is closer. */
 814:../drivers/fsl_clock.c ****             if (diff > ret_freq - desireFreq)
 815:../drivers/fsl_clock.c ****             {
 816:../drivers/fsl_clock.c ****                 diff = ret_freq - desireFreq;
 817:../drivers/fsl_clock.c ****                 ret_prdiv = prdiv_cur;
 818:../drivers/fsl_clock.c ****                 ret_vdiv = vdiv_cur;
 819:../drivers/fsl_clock.c ****             }
 820:../drivers/fsl_clock.c ****         }
 821:../drivers/fsl_clock.c ****     }
 822:../drivers/fsl_clock.c **** 
 823:../drivers/fsl_clock.c ****     if (0xFFFFFFFFU != diff)
 1511              		.loc 1 823 0
 1512 0036 BEF1FF3F 		cmp	lr, #-1
 1513 003a 36D0     		beq	.L190
 824:../drivers/fsl_clock.c ****     {
 825:../drivers/fsl_clock.c ****         /* PRDIV/VDIV found. */
 826:../drivers/fsl_clock.c ****         *prdiv = ret_prdiv - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
 827:../drivers/fsl_clock.c ****         *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 828:../drivers/fsl_clock.c ****         ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
 1514              		.loc 1 828 0
 1515 003c B7FBF9F0 		udiv	r0, r7, r9
 826:../drivers/fsl_clock.c ****         *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 1516              		.loc 1 826 0
 1517 0040 09F1FF31 		add	r1, r9, #-1
 1518              	.LVL102:
 1519 0044 1170     		strb	r1, [r2]
 827:../drivers/fsl_clock.c ****         ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
 1520              		.loc 1 827 0
 1521 0046 A8F11802 		sub	r2, r8, #24
 1522              	.LVL103:
 1523 004a 1A70     		strb	r2, [r3]
 1524              		.loc 1 828 0
 1525 004c 08FB00F0 		mul	r0, r8, r0
 1526              	.LVL104:
 829:../drivers/fsl_clock.c ****         return ret_freq;
 1527              		.loc 1 829 0
 1528 0050 14E0     		b	.L182
 1529              	.LVL105:
 1530              	.L188:
 781:../drivers/fsl_clock.c **** 
 1531              		.loc 1 781 0
 1532 0052 B7FBF5F6 		udiv	r6, r7, r5
 1533              	.LVL106:
 783:../drivers/fsl_clock.c **** 
 1534              		.loc 1 783 0
 1535 0056 B1FBF6F4 		udiv	r4, r1, r6
 1536 005a E4B2     		uxtb	r4, r4
 1537              	.LVL107:
 785:../drivers/fsl_clock.c ****         {
 1538              		.loc 1 785 0
 1539 005c A4F11700 		sub	r0, r4, #23
 1540 0060 2028     		cmp	r0, #32
 1541 0062 05F1FF3A 		add	r10, r5, #-1
 1542 0066 1DD8     		bhi	.L185
 793:../drivers/fsl_clock.c ****         {
 1543              		.loc 1 793 0
 1544 0068 172C     		cmp	r4, #23
 791:../drivers/fsl_clock.c **** 
 1545              		.loc 1 791 0
 1546 006a 06FB04F0 		mul	r0, r6, r4
 1547              	.LVL108:
 793:../drivers/fsl_clock.c ****         {
 1548              		.loc 1 793 0
 1549 006e 0ED0     		beq	.L186
 795:../drivers/fsl_clock.c ****             {
 1550              		.loc 1 795 0
 1551 0070 8142     		cmp	r1, r0
 1552 0072 05D1     		bne	.L187
 798:../drivers/fsl_clock.c ****                 return ret_freq;
 1553              		.loc 1 798 0
 1554 0074 183C     		subs	r4, r4, #24
 1555              	.LVL109:
 797:../drivers/fsl_clock.c ****                 *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 1556              		.loc 1 797 0
 1557 0076 82F800A0 		strb	r10, [r2]
 798:../drivers/fsl_clock.c ****                 return ret_freq;
 1558              		.loc 1 798 0
 1559 007a 1C70     		strb	r4, [r3]
 1560              	.LVL110:
 1561              	.L182:
 830:../drivers/fsl_clock.c ****     }
 831:../drivers/fsl_clock.c ****     else
 832:../drivers/fsl_clock.c ****     {
 833:../drivers/fsl_clock.c ****         /* No proper PRDIV/VDIV found. */
 834:../drivers/fsl_clock.c ****         return 0U;
 835:../drivers/fsl_clock.c ****     }
 836:../drivers/fsl_clock.c **** }
 1562              		.loc 1 836 0
 1563 007c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1564              	.LVL111:
 1565              	.L187:
 802:../drivers/fsl_clock.c ****             {
 1566              		.loc 1 802 0
 1567 0080 A1EB000B 		sub	fp, r1, r0
 1568 0084 F345     		cmp	fp, lr
 1569 0086 3EBF     		ittt	cc
 1570 0088 DE46     		movcc	lr, fp
 1571              	.LVL112:
 1572 008a A046     		movcc	r8, r4
 1573 008c A946     		movcc	r9, r5
 1574              	.L186:
 1575              	.LVL113:
 809:../drivers/fsl_clock.c ****         if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
 1576              		.loc 1 809 0
 1577 008e 0134     		adds	r4, r4, #1
 1578              	.LVL114:
 1579 0090 E4B2     		uxtb	r4, r4
 1580              	.LVL115:
 810:../drivers/fsl_clock.c ****         {
 1581              		.loc 1 810 0
 1582 0092 382C     		cmp	r4, #56
 1583 0094 06D0     		beq	.L185
 1584              	.LVL116:
 814:../drivers/fsl_clock.c ****             {
 1585              		.loc 1 814 0
 1586 0096 761A     		subs	r6, r6, r1
 1587              	.LVL117:
 1588 0098 0644     		add	r6, r6, r0
 1589 009a 7645     		cmp	r6, lr
 1590 009c 3EBF     		ittt	cc
 1591 009e B646     		movcc	lr, r6
 1592              	.LVL118:
 1593 00a0 A046     		movcc	r8, r4
 1594 00a2 A946     		movcc	r9, r5
 1595              	.LVL119:
 1596              	.L185:
 778:../drivers/fsl_clock.c ****     {
 1597              		.loc 1 778 0 discriminator 2
 1598 00a4 5FFA8AF5 		uxtb	r5, r10
 1599              	.LVL120:
 1600 00a8 C3E7     		b	.L184
 1601              	.LVL121:
 1602              	.L190:
 770:../drivers/fsl_clock.c ****     }
 1603              		.loc 1 770 0
 1604 00aa 0020     		movs	r0, #0
 1605 00ac E6E7     		b	.L182
 1606              	.L198:
 1607 00ae 00BF     		.align	2
 1608              	.L197:
 1609 00b0 805CD705 		.word	98000000
 1610 00b4 80841E00 		.word	2000000
 1611 00b8 00093D00 		.word	4000000
 1612              		.cfi_endproc
 1613              	.LFE172:
 1615              		.section	.text.CLOCK_EnablePll0,"ax",%progbits
 1616              		.align	1
 1617              		.global	CLOCK_EnablePll0
 1618              		.syntax unified
 1619              		.thumb
 1620              		.thumb_func
 1621              		.fpu fpv4-sp-d16
 1623              	CLOCK_EnablePll0:
 1624              	.LFB173:
 837:../drivers/fsl_clock.c **** 
 838:../drivers/fsl_clock.c **** void CLOCK_EnablePll0(mcg_pll_config_t const *config)
 839:../drivers/fsl_clock.c **** {
 1625              		.loc 1 839 0
 1626              		.cfi_startproc
 1627              		@ args = 0, pretend = 0, frame = 0
 1628              		@ frame_needed = 0, uses_anonymous_args = 0
 1629              		@ link register save eliminated.
 1630              	.LVL122:
 840:../drivers/fsl_clock.c ****     assert(config);
 841:../drivers/fsl_clock.c **** 
 842:../drivers/fsl_clock.c ****     uint8_t mcg_c5 = 0U;
 843:../drivers/fsl_clock.c **** 
 844:../drivers/fsl_clock.c ****     mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
 1631              		.loc 1 844 0
 1632 0000 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 845:../drivers/fsl_clock.c ****     MCG->C5 = mcg_c5; /* Disable the PLL first. */
 1633              		.loc 1 845 0
 1634 0002 0B4B     		ldr	r3, .L203
 844:../drivers/fsl_clock.c ****     MCG->C5 = mcg_c5; /* Disable the PLL first. */
 1635              		.loc 1 844 0
 1636 0004 02F01F02 		and	r2, r2, #31
 1637              	.LVL123:
 1638              		.loc 1 845 0
 1639 0008 1A71     		strb	r2, [r3, #4]
 846:../drivers/fsl_clock.c **** 
 847:../drivers/fsl_clock.c ****     MCG->C6 = (MCG->C6 & ~MCG_C6_VDIV0_MASK) | MCG_C6_VDIV0(config->vdiv);
 1640              		.loc 1 847 0
 1641 000a 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1642 000c 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1643              	.LVL124:
 1644 000e 01F0E001 		and	r1, r1, #224
 1645 0012 02F01F02 		and	r2, r2, #31
 1646 0016 0A43     		orrs	r2, r2, r1
 1647 0018 5A71     		strb	r2, [r3, #5]
 1648              	.LVL125:
 848:../drivers/fsl_clock.c **** 
 849:../drivers/fsl_clock.c ****     /* Set enable mode. */
 850:../drivers/fsl_clock.c ****     MCG->C5 |= ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode);
 1649              		.loc 1 850 0
 1650 001a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1651 001c 42F04001 		orr	r1, r2, #64
 1652 0020 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 1653 0022 0A43     		orrs	r2, r2, r1
 1654 0024 1A71     		strb	r2, [r3, #4]
 1655              	.L200:
 851:../drivers/fsl_clock.c **** 
 852:../drivers/fsl_clock.c ****     /* Wait for PLL lock. */
 853:../drivers/fsl_clock.c ****     while (!(MCG->S & MCG_S_LOCK0_MASK))
 1656              		.loc 1 853 0 discriminator 1
 1657 0026 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1658 0028 5206     		lsls	r2, r2, #25
 1659 002a FCD5     		bpl	.L200
 854:../drivers/fsl_clock.c ****     {
 855:../drivers/fsl_clock.c ****     }
 856:../drivers/fsl_clock.c **** }
 1660              		.loc 1 856 0
 1661 002c 7047     		bx	lr
 1662              	.L204:
 1663 002e 00BF     		.align	2
 1664              	.L203:
 1665 0030 00400640 		.word	1074151424
 1666              		.cfi_endproc
 1667              	.LFE173:
 1669              		.section	.text.CLOCK_SetOsc0MonitorMode,"ax",%progbits
 1670              		.align	1
 1671              		.global	CLOCK_SetOsc0MonitorMode
 1672              		.syntax unified
 1673              		.thumb
 1674              		.thumb_func
 1675              		.fpu fpv4-sp-d16
 1677              	CLOCK_SetOsc0MonitorMode:
 1678              	.LFB174:
 857:../drivers/fsl_clock.c **** 
 858:../drivers/fsl_clock.c **** void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode)
 859:../drivers/fsl_clock.c **** {
 1679              		.loc 1 859 0
 1680              		.cfi_startproc
 1681              		@ args = 0, pretend = 0, frame = 0
 1682              		@ frame_needed = 0, uses_anonymous_args = 0
 1683              		@ link register save eliminated.
 1684              	.LVL126:
 860:../drivers/fsl_clock.c ****     /* Clear the previous flag, MCG_SC[LOCS0]. */
 861:../drivers/fsl_clock.c ****     MCG->SC &= ~MCG_SC_ATMF_MASK;
 1685              		.loc 1 861 0
 1686 0000 0C4A     		ldr	r2, .L211
 1687 0002 137A     		ldrb	r3, [r2, #8]	@ zero_extendqisi2
 1688 0004 03F0DF03 		and	r3, r3, #223
 1689 0008 1372     		strb	r3, [r2, #8]
 1690 000a 1346     		mov	r3, r2
 862:../drivers/fsl_clock.c **** 
 863:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone == mode)
 1691              		.loc 1 863 0
 1692 000c 20B9     		cbnz	r0, .L206
 864:../drivers/fsl_clock.c ****     {
 865:../drivers/fsl_clock.c ****         MCG->C6 &= ~MCG_C6_CME0_MASK;
 1693              		.loc 1 865 0
 1694 000e 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 1695 0010 03F0DF03 		and	r3, r3, #223
 1696 0014 5371     		strb	r3, [r2, #5]
 1697 0016 7047     		bx	lr
 1698              	.L206:
 866:../drivers/fsl_clock.c ****     }
 867:../drivers/fsl_clock.c ****     else
 868:../drivers/fsl_clock.c ****     {
 869:../drivers/fsl_clock.c ****         if (kMCG_MonitorInt == mode)
 870:../drivers/fsl_clock.c ****         {
 871:../drivers/fsl_clock.c ****             MCG->C2 &= ~MCG_C2_LOCRE0_MASK;
 1699              		.loc 1 871 0
 1700 0018 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 869:../drivers/fsl_clock.c ****         {
 1701              		.loc 1 869 0
 1702 001a 0128     		cmp	r0, #1
 1703              		.loc 1 871 0
 1704 001c 0CBF     		ite	eq
 1705 001e 02F07F02 		andeq	r2, r2, #127
 872:../drivers/fsl_clock.c ****         }
 873:../drivers/fsl_clock.c ****         else
 874:../drivers/fsl_clock.c ****         {
 875:../drivers/fsl_clock.c ****             MCG->C2 |= MCG_C2_LOCRE0_MASK;
 1706              		.loc 1 875 0
 1707 0022 42F08002 		orrne	r2, r2, #128
 1708 0026 5A70     		strb	r2, [r3, #1]
 876:../drivers/fsl_clock.c ****         }
 877:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_CME0_MASK;
 1709              		.loc 1 877 0
 1710 0028 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1711 002a 42F02002 		orr	r2, r2, #32
 1712 002e 5A71     		strb	r2, [r3, #5]
 878:../drivers/fsl_clock.c ****     }
 879:../drivers/fsl_clock.c **** }
 1713              		.loc 1 879 0
 1714 0030 7047     		bx	lr
 1715              	.L212:
 1716 0032 00BF     		.align	2
 1717              	.L211:
 1718 0034 00400640 		.word	1074151424
 1719              		.cfi_endproc
 1720              	.LFE174:
 1722              		.section	.text.CLOCK_SetRtcOscMonitorMode,"ax",%progbits
 1723              		.align	1
 1724              		.global	CLOCK_SetRtcOscMonitorMode
 1725              		.syntax unified
 1726              		.thumb
 1727              		.thumb_func
 1728              		.fpu fpv4-sp-d16
 1730              	CLOCK_SetRtcOscMonitorMode:
 1731              	.LFB175:
 880:../drivers/fsl_clock.c **** 
 881:../drivers/fsl_clock.c **** void CLOCK_SetRtcOscMonitorMode(mcg_monitor_mode_t mode)
 882:../drivers/fsl_clock.c **** {
 1732              		.loc 1 882 0
 1733              		.cfi_startproc
 1734              		@ args = 0, pretend = 0, frame = 0
 1735              		@ frame_needed = 0, uses_anonymous_args = 0
 1736              		@ link register save eliminated.
 1737              	.LVL127:
 883:../drivers/fsl_clock.c ****     uint8_t mcg_c8 = MCG->C8;
 1738              		.loc 1 883 0
 1739 0000 064A     		ldr	r2, .L219
 1740 0002 537B     		ldrb	r3, [r2, #13]	@ zero_extendqisi2
 1741              	.LVL128:
 884:../drivers/fsl_clock.c **** 
 885:../drivers/fsl_clock.c ****     mcg_c8 &= ~(MCG_C8_CME1_MASK | MCG_C8_LOCRE1_MASK);
 1742              		.loc 1 885 0
 1743 0004 03F05F03 		and	r3, r3, #95
 1744              	.LVL129:
 886:../drivers/fsl_clock.c **** 
 887:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone != mode)
 1745              		.loc 1 887 0
 1746 0008 28B1     		cbz	r0, .L214
 888:../drivers/fsl_clock.c ****     {
 889:../drivers/fsl_clock.c ****         if (kMCG_MonitorReset == mode)
 1747              		.loc 1 889 0
 1748 000a 0228     		cmp	r0, #2
 890:../drivers/fsl_clock.c ****         {
 891:../drivers/fsl_clock.c ****             mcg_c8 |= MCG_C8_LOCRE1_MASK;
 1749              		.loc 1 891 0
 1750 000c 08BF     		it	eq
 1751 000e 43F08003 		orreq	r3, r3, #128
 1752              	.LVL130:
 892:../drivers/fsl_clock.c ****         }
 893:../drivers/fsl_clock.c ****         mcg_c8 |= MCG_C8_CME1_MASK;
 1753              		.loc 1 893 0
 1754 0012 43F02003 		orr	r3, r3, #32
 1755              	.LVL131:
 1756              	.L214:
 894:../drivers/fsl_clock.c ****     }
 895:../drivers/fsl_clock.c ****     MCG->C8 = mcg_c8;
 1757              		.loc 1 895 0
 1758 0016 5373     		strb	r3, [r2, #13]
 896:../drivers/fsl_clock.c **** }
 1759              		.loc 1 896 0
 1760 0018 7047     		bx	lr
 1761              	.L220:
 1762 001a 00BF     		.align	2
 1763              	.L219:
 1764 001c 00400640 		.word	1074151424
 1765              		.cfi_endproc
 1766              	.LFE175:
 1768              		.section	.text.CLOCK_SetPll0MonitorMode,"ax",%progbits
 1769              		.align	1
 1770              		.global	CLOCK_SetPll0MonitorMode
 1771              		.syntax unified
 1772              		.thumb
 1773              		.thumb_func
 1774              		.fpu fpv4-sp-d16
 1776              	CLOCK_SetPll0MonitorMode:
 1777              	.LFB176:
 897:../drivers/fsl_clock.c **** 
 898:../drivers/fsl_clock.c **** void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode)
 899:../drivers/fsl_clock.c **** {
 1778              		.loc 1 899 0
 1779              		.cfi_startproc
 1780              		@ args = 0, pretend = 0, frame = 0
 1781              		@ frame_needed = 0, uses_anonymous_args = 0
 1782              		@ link register save eliminated.
 1783              	.LVL132:
 900:../drivers/fsl_clock.c ****     uint8_t mcg_c8;
 901:../drivers/fsl_clock.c **** 
 902:../drivers/fsl_clock.c ****     /* Clear previous flag. */
 903:../drivers/fsl_clock.c ****     MCG->S = MCG_S_LOLS0_MASK;
 1784              		.loc 1 903 0
 1785 0000 0C4B     		ldr	r3, .L226
 1786 0002 8022     		movs	r2, #128
 1787 0004 9A71     		strb	r2, [r3, #6]
 1788 0006 1A46     		mov	r2, r3
 904:../drivers/fsl_clock.c **** 
 905:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone == mode)
 1789              		.loc 1 905 0
 1790 0008 20B9     		cbnz	r0, .L222
 906:../drivers/fsl_clock.c ****     {
 907:../drivers/fsl_clock.c ****         MCG->C6 &= ~MCG_C6_LOLIE0_MASK;
 1791              		.loc 1 907 0
 1792 000a 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1793 000c 02F07F02 		and	r2, r2, #127
 1794 0010 5A71     		strb	r2, [r3, #5]
 1795 0012 7047     		bx	lr
 1796              	.L222:
 908:../drivers/fsl_clock.c ****     }
 909:../drivers/fsl_clock.c ****     else
 910:../drivers/fsl_clock.c ****     {
 911:../drivers/fsl_clock.c ****         mcg_c8 = MCG->C8;
 1797              		.loc 1 911 0
 1798 0014 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 912:../drivers/fsl_clock.c **** 
 913:../drivers/fsl_clock.c ****         mcg_c8 &= ~MCG_C8_LOCS1_MASK;
 914:../drivers/fsl_clock.c **** 
 915:../drivers/fsl_clock.c ****         if (kMCG_MonitorInt == mode)
 1799              		.loc 1 915 0
 1800 0016 0128     		cmp	r0, #1
 911:../drivers/fsl_clock.c **** 
 1801              		.loc 1 911 0
 1802 0018 DBB2     		uxtb	r3, r3
 1803              	.LVL133:
 913:../drivers/fsl_clock.c **** 
 1804              		.loc 1 913 0
 1805 001a 16BF     		itet	ne
 1806 001c 03F0FE03 		andne	r3, r3, #254
 1807              	.LVL134:
 916:../drivers/fsl_clock.c ****         {
 917:../drivers/fsl_clock.c ****             mcg_c8 &= ~MCG_C8_LOLRE_MASK;
 1808              		.loc 1 917 0
 1809 0020 03F0BE03 		andeq	r3, r3, #190
 918:../drivers/fsl_clock.c ****         }
 919:../drivers/fsl_clock.c ****         else
 920:../drivers/fsl_clock.c ****         {
 921:../drivers/fsl_clock.c ****             mcg_c8 |= MCG_C8_LOLRE_MASK;
 1810              		.loc 1 921 0
 1811 0024 43F04003 		orrne	r3, r3, #64
 1812              	.LVL135:
 922:../drivers/fsl_clock.c ****         }
 923:../drivers/fsl_clock.c ****         MCG->C8 = mcg_c8;
 1813              		.loc 1 923 0
 1814 0028 5373     		strb	r3, [r2, #13]
 924:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_LOLIE0_MASK;
 1815              		.loc 1 924 0
 1816 002a 5379     		ldrb	r3, [r2, #5]	@ zero_extendqisi2
 1817              	.LVL136:
 1818 002c 43F08003 		orr	r3, r3, #128
 1819 0030 5371     		strb	r3, [r2, #5]
 1820              	.LVL137:
 925:../drivers/fsl_clock.c ****     }
 926:../drivers/fsl_clock.c **** }
 1821              		.loc 1 926 0
 1822 0032 7047     		bx	lr
 1823              	.L227:
 1824              		.align	2
 1825              	.L226:
 1826 0034 00400640 		.word	1074151424
 1827              		.cfi_endproc
 1828              	.LFE176:
 1830              		.section	.text.CLOCK_GetStatusFlags,"ax",%progbits
 1831              		.align	1
 1832              		.global	CLOCK_GetStatusFlags
 1833              		.syntax unified
 1834              		.thumb
 1835              		.thumb_func
 1836              		.fpu fpv4-sp-d16
 1838              	CLOCK_GetStatusFlags:
 1839              	.LFB177:
 927:../drivers/fsl_clock.c **** 
 928:../drivers/fsl_clock.c **** uint32_t CLOCK_GetStatusFlags(void)
 929:../drivers/fsl_clock.c **** {
 1840              		.loc 1 929 0
 1841              		.cfi_startproc
 1842              		@ args = 0, pretend = 0, frame = 0
 1843              		@ frame_needed = 0, uses_anonymous_args = 0
 1844              		@ link register save eliminated.
 1845              	.LVL138:
 930:../drivers/fsl_clock.c ****     uint32_t ret = 0U;
 931:../drivers/fsl_clock.c ****     uint8_t mcg_s = MCG->S;
 1846              		.loc 1 931 0
 1847 0000 0B4A     		ldr	r2, .L242
 1848 0002 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 932:../drivers/fsl_clock.c **** 
 933:../drivers/fsl_clock.c ****     if (MCG->SC & MCG_SC_LOCS0_MASK)
 1849              		.loc 1 933 0
 1850 0004 107A     		ldrb	r0, [r2, #8]	@ zero_extendqisi2
 934:../drivers/fsl_clock.c ****     {
 935:../drivers/fsl_clock.c ****         ret |= kMCG_Osc0LostFlag;
 936:../drivers/fsl_clock.c ****     }
 937:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_OSCINIT0_MASK)
 938:../drivers/fsl_clock.c ****     {
 939:../drivers/fsl_clock.c ****         ret |= kMCG_Osc0InitFlag;
 940:../drivers/fsl_clock.c ****     }
 941:../drivers/fsl_clock.c ****     if (MCG->C8 & MCG_C8_LOCS1_MASK)
 1851              		.loc 1 941 0
 1852 0006 527B     		ldrb	r2, [r2, #13]	@ zero_extendqisi2
 931:../drivers/fsl_clock.c **** 
 1853              		.loc 1 931 0
 1854 0008 DBB2     		uxtb	r3, r3
 1855              	.LVL139:
 930:../drivers/fsl_clock.c ****     uint8_t mcg_s = MCG->S;
 1856              		.loc 1 930 0
 1857 000a 00F00100 		and	r0, r0, #1
 1858              	.LVL140:
 937:../drivers/fsl_clock.c ****     {
 1859              		.loc 1 937 0
 1860 000e 9907     		lsls	r1, r3, #30
 939:../drivers/fsl_clock.c ****     }
 1861              		.loc 1 939 0
 1862 0010 48BF     		it	mi
 1863 0012 40F00200 		orrmi	r0, r0, #2
 1864              	.LVL141:
 1865              		.loc 1 941 0
 1866 0016 D107     		lsls	r1, r2, #31
 942:../drivers/fsl_clock.c ****     {
 943:../drivers/fsl_clock.c ****         ret |= kMCG_RtcOscLostFlag;
 1867              		.loc 1 943 0
 1868 0018 48BF     		it	mi
 1869 001a 40F01000 		orrmi	r0, r0, #16
 1870              	.LVL142:
 944:../drivers/fsl_clock.c ****     }
 945:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_LOLS0_MASK)
 1871              		.loc 1 945 0
 1872 001e 1A06     		lsls	r2, r3, #24
 946:../drivers/fsl_clock.c ****     {
 947:../drivers/fsl_clock.c ****         ret |= kMCG_Pll0LostFlag;
 1873              		.loc 1 947 0
 1874 0020 48BF     		it	mi
 1875 0022 40F02000 		orrmi	r0, r0, #32
 1876              	.LVL143:
 948:../drivers/fsl_clock.c ****     }
 949:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_LOCK0_MASK)
 1877              		.loc 1 949 0
 1878 0026 5B06     		lsls	r3, r3, #25
 1879              	.LVL144:
 950:../drivers/fsl_clock.c ****     {
 951:../drivers/fsl_clock.c ****         ret |= kMCG_Pll0LockFlag;
 1880              		.loc 1 951 0
 1881 0028 48BF     		it	mi
 1882 002a 40F04000 		orrmi	r0, r0, #64
 1883              	.LVL145:
 952:../drivers/fsl_clock.c ****     }
 953:../drivers/fsl_clock.c ****     return ret;
 954:../drivers/fsl_clock.c **** }
 1884              		.loc 1 954 0
 1885 002e 7047     		bx	lr
 1886              	.L243:
 1887              		.align	2
 1888              	.L242:
 1889 0030 00400640 		.word	1074151424
 1890              		.cfi_endproc
 1891              	.LFE177:
 1893              		.section	.text.CLOCK_ClearStatusFlags,"ax",%progbits
 1894              		.align	1
 1895              		.global	CLOCK_ClearStatusFlags
 1896              		.syntax unified
 1897              		.thumb
 1898              		.thumb_func
 1899              		.fpu fpv4-sp-d16
 1901              	CLOCK_ClearStatusFlags:
 1902              	.LFB178:
 955:../drivers/fsl_clock.c **** 
 956:../drivers/fsl_clock.c **** void CLOCK_ClearStatusFlags(uint32_t mask)
 957:../drivers/fsl_clock.c **** {
 1903              		.loc 1 957 0
 1904              		.cfi_startproc
 1905              		@ args = 0, pretend = 0, frame = 0
 1906              		@ frame_needed = 0, uses_anonymous_args = 0
 1907              		@ link register save eliminated.
 1908              	.LVL146:
 958:../drivers/fsl_clock.c ****     uint8_t reg;
 959:../drivers/fsl_clock.c **** 
 960:../drivers/fsl_clock.c ****     if (mask & kMCG_Osc0LostFlag)
 1909              		.loc 1 960 0
 1910 0000 C107     		lsls	r1, r0, #31
 961:../drivers/fsl_clock.c ****     {
 962:../drivers/fsl_clock.c ****         MCG->SC &= ~MCG_SC_ATMF_MASK;
 1911              		.loc 1 962 0
 1912 0002 41BF     		itttt	mi
 1913 0004 084A     		ldrmi	r2, .L257
 1914 0006 137A     		ldrbmi	r3, [r2, #8]	@ zero_extendqisi2
 1915 0008 03F0DF03 		andmi	r3, r3, #223
 1916 000c 1372     		strbmi	r3, [r2, #8]
 963:../drivers/fsl_clock.c ****     }
 964:../drivers/fsl_clock.c ****     if (mask & kMCG_RtcOscLostFlag)
 1917              		.loc 1 964 0
 1918 000e C206     		lsls	r2, r0, #27
 965:../drivers/fsl_clock.c ****     {
 966:../drivers/fsl_clock.c ****         reg = MCG->C8;
 1919              		.loc 1 966 0
 1920 0010 41BF     		itttt	mi
 1921 0012 054A     		ldrmi	r2, .L257
 1922 0014 537B     		ldrbmi	r3, [r2, #13]	@ zero_extendqisi2
 1923 0016 DBB2     		uxtbmi	r3, r3
 1924              	.LVL147:
 967:../drivers/fsl_clock.c ****         MCG->C8 = reg;
 1925              		.loc 1 967 0
 1926 0018 5373     		strbmi	r3, [r2, #13]
 968:../drivers/fsl_clock.c ****     }
 969:../drivers/fsl_clock.c ****     if (mask & kMCG_Pll0LostFlag)
 1927              		.loc 1 969 0
 1928 001a 8306     		lsls	r3, r0, #26
 1929              	.LVL148:
 970:../drivers/fsl_clock.c ****     {
 971:../drivers/fsl_clock.c ****         MCG->S = MCG_S_LOLS0_MASK;
 1930              		.loc 1 971 0
 1931 001c 42BF     		ittt	mi
 1932 001e 024B     		ldrmi	r3, .L257
 1933 0020 8022     		movmi	r2, #128
 1934 0022 9A71     		strbmi	r2, [r3, #6]
 972:../drivers/fsl_clock.c ****     }
 973:../drivers/fsl_clock.c **** }
 1935              		.loc 1 973 0
 1936 0024 7047     		bx	lr
 1937              	.L258:
 1938 0026 00BF     		.align	2
 1939              	.L257:
 1940 0028 00400640 		.word	1074151424
 1941              		.cfi_endproc
 1942              	.LFE178:
 1944              		.section	.text.CLOCK_InitOsc0,"ax",%progbits
 1945              		.align	1
 1946              		.global	CLOCK_InitOsc0
 1947              		.syntax unified
 1948              		.thumb
 1949              		.thumb_func
 1950              		.fpu fpv4-sp-d16
 1952              	CLOCK_InitOsc0:
 1953              	.LFB179:
 974:../drivers/fsl_clock.c **** 
 975:../drivers/fsl_clock.c **** void CLOCK_InitOsc0(osc_config_t const *config)
 976:../drivers/fsl_clock.c **** {
 1954              		.loc 1 976 0
 1955              		.cfi_startproc
 1956              		@ args = 0, pretend = 0, frame = 0
 1957              		@ frame_needed = 0, uses_anonymous_args = 0
 1958              	.LVL149:
 977:../drivers/fsl_clock.c ****     uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
 1959              		.loc 1 977 0
 1960 0000 0368     		ldr	r3, [r0]
 1961              	.LVL150:
 1962              	.LBB72:
 1963              	.LBB73:
 347:../drivers/fsl_clock.c ****     {
 1964              		.loc 1 347 0
 1965 0002 49F69702 		movw	r2, #39063
 1966 0006 9342     		cmp	r3, r2
 1967              	.LBE73:
 1968              	.LBE72:
 976:../drivers/fsl_clock.c ****     uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
 1969              		.loc 1 976 0
 1970 0008 10B5     		push	{r4, lr}
 1971              		.cfi_def_cfa_offset 8
 1972              		.cfi_offset 4, -8
 1973              		.cfi_offset 14, -4
 1974              	.LBB76:
 1975              	.LBB74:
 347:../drivers/fsl_clock.c ****     {
 1976              		.loc 1 347 0
 1977 000a 22D9     		bls	.L263
 357:../drivers/fsl_clock.c ****     }
 1978              		.loc 1 357 0
 1979 000c 124C     		ldr	r4, .L270
 1980 000e A342     		cmp	r3, r4
 1981 0010 94BF     		ite	ls
 1982 0012 0124     		movls	r4, #1
 1983 0014 0224     		movhi	r4, #2
 1984              	.L260:
 1985              	.LVL151:
 1986              	.LBE74:
 1987              	.LBE76:
 1988              	.LBB77:
 1989              	.LBB78:
 767:../drivers/fsl_clock.h **** }
 768:../drivers/fsl_clock.h **** 
 769:../drivers/fsl_clock.h **** /*!
 770:../drivers/fsl_clock.h ****  * @brief Set CLKOUT source.
 771:../drivers/fsl_clock.h ****  *
 772:../drivers/fsl_clock.h ****  * @param src The value to set CLKOUT source.
 773:../drivers/fsl_clock.h ****  */
 774:../drivers/fsl_clock.h **** static inline void CLOCK_SetClkOutClock(uint32_t src)
 775:../drivers/fsl_clock.h **** {
 776:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_CLKOUTSEL_MASK) | SIM_SOPT2_CLKOUTSEL(src));
 777:../drivers/fsl_clock.h **** }
 778:../drivers/fsl_clock.h **** 
 779:../drivers/fsl_clock.h **** /*!
 780:../drivers/fsl_clock.h ****  * @brief Set RTC_CLKOUT source.
 781:../drivers/fsl_clock.h ****  *
 782:../drivers/fsl_clock.h ****  * @param src The value to set RTC_CLKOUT source.
 783:../drivers/fsl_clock.h ****  */
 784:../drivers/fsl_clock.h **** static inline void CLOCK_SetRtcClkOutClock(uint32_t src)
 785:../drivers/fsl_clock.h **** {
 786:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_RTCCLKOUTSEL_MASK) | SIM_SOPT2_RTCCLKOUTSEL(src));
 787:../drivers/fsl_clock.h **** }
 788:../drivers/fsl_clock.h **** 
 789:../drivers/fsl_clock.h **** /*! @brief Enable USB FS clock.
 790:../drivers/fsl_clock.h ****  *
 791:../drivers/fsl_clock.h ****  * @param src  USB FS clock source.
 792:../drivers/fsl_clock.h ****  * @param freq The frequency specified by src.
 793:../drivers/fsl_clock.h ****  * @retval true The clock is set successfully.
 794:../drivers/fsl_clock.h ****  * @retval false The clock source is invalid to get proper USB FS clock.
 795:../drivers/fsl_clock.h ****  */
 796:../drivers/fsl_clock.h **** bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq);
 797:../drivers/fsl_clock.h **** 
 798:../drivers/fsl_clock.h **** /*! @brief Disable USB FS clock.
 799:../drivers/fsl_clock.h ****  *
 800:../drivers/fsl_clock.h ****  * Disable USB FS clock.
 801:../drivers/fsl_clock.h ****  */
 802:../drivers/fsl_clock.h **** static inline void CLOCK_DisableUsbfs0Clock(void)
 803:../drivers/fsl_clock.h **** {
 804:../drivers/fsl_clock.h ****     CLOCK_DisableClock(kCLOCK_Usbfs0);
 805:../drivers/fsl_clock.h **** }
 806:../drivers/fsl_clock.h **** 
 807:../drivers/fsl_clock.h **** /*!
 808:../drivers/fsl_clock.h ****  * @brief System clock divider
 809:../drivers/fsl_clock.h ****  *
 810:../drivers/fsl_clock.h ****  * Set the SIM_CLKDIV1[OUTDIV1], SIM_CLKDIV1[OUTDIV2], SIM_CLKDIV1[OUTDIV3], SIM_CLKDIV1[OUTDIV4].
 811:../drivers/fsl_clock.h ****  *
 812:../drivers/fsl_clock.h ****  * @param outdiv1 Clock 1 output divider value.
 813:../drivers/fsl_clock.h ****  *
 814:../drivers/fsl_clock.h ****  * @param outdiv2 Clock 2 output divider value.
 815:../drivers/fsl_clock.h ****  *
 816:../drivers/fsl_clock.h ****  * @param outdiv3 Clock 3 output divider value.
 817:../drivers/fsl_clock.h ****  *
 818:../drivers/fsl_clock.h ****  * @param outdiv4 Clock 4 output divider value.
 819:../drivers/fsl_clock.h ****  */
 820:../drivers/fsl_clock.h **** static inline void CLOCK_SetOutDiv(uint32_t outdiv1, uint32_t outdiv2, uint32_t outdiv3, uint32_t o
 821:../drivers/fsl_clock.h **** {
 822:../drivers/fsl_clock.h ****     SIM->CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) | SIM_CLKDIV1_OUTDIV
 823:../drivers/fsl_clock.h ****                    SIM_CLKDIV1_OUTDIV4(outdiv4);
 824:../drivers/fsl_clock.h **** }
 825:../drivers/fsl_clock.h **** 
 826:../drivers/fsl_clock.h **** /*!
 827:../drivers/fsl_clock.h ****  * @brief Gets the clock frequency for a specific clock name.
 828:../drivers/fsl_clock.h ****  *
 829:../drivers/fsl_clock.h ****  * This function checks the current clock configurations and then calculates
 830:../drivers/fsl_clock.h ****  * the clock frequency for a specific clock name defined in clock_name_t.
 831:../drivers/fsl_clock.h ****  * The MCG must be properly configured before using this function.
 832:../drivers/fsl_clock.h ****  *
 833:../drivers/fsl_clock.h ****  * @param clockName Clock names defined in clock_name_t
 834:../drivers/fsl_clock.h ****  * @return Clock frequency value in Hertz
 835:../drivers/fsl_clock.h ****  */
 836:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFreq(clock_name_t clockName);
 837:../drivers/fsl_clock.h **** 
 838:../drivers/fsl_clock.h **** /*!
 839:../drivers/fsl_clock.h ****  * @brief Get the core clock or system clock frequency.
 840:../drivers/fsl_clock.h ****  *
 841:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 842:../drivers/fsl_clock.h ****  */
 843:../drivers/fsl_clock.h **** uint32_t CLOCK_GetCoreSysClkFreq(void);
 844:../drivers/fsl_clock.h **** 
 845:../drivers/fsl_clock.h **** /*!
 846:../drivers/fsl_clock.h ****  * @brief Get the platform clock frequency.
 847:../drivers/fsl_clock.h ****  *
 848:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 849:../drivers/fsl_clock.h ****  */
 850:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPlatClkFreq(void);
 851:../drivers/fsl_clock.h **** 
 852:../drivers/fsl_clock.h **** /*!
 853:../drivers/fsl_clock.h ****  * @brief Get the bus clock frequency.
 854:../drivers/fsl_clock.h ****  *
 855:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 856:../drivers/fsl_clock.h ****  */
 857:../drivers/fsl_clock.h **** uint32_t CLOCK_GetBusClkFreq(void);
 858:../drivers/fsl_clock.h **** 
 859:../drivers/fsl_clock.h **** /*!
 860:../drivers/fsl_clock.h ****  * @brief Get the flexbus clock frequency.
 861:../drivers/fsl_clock.h ****  *
 862:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 863:../drivers/fsl_clock.h ****  */
 864:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFlexBusClkFreq(void);
 865:../drivers/fsl_clock.h **** 
 866:../drivers/fsl_clock.h **** /*!
 867:../drivers/fsl_clock.h ****  * @brief Get the flash clock frequency.
 868:../drivers/fsl_clock.h ****  *
 869:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 870:../drivers/fsl_clock.h ****  */
 871:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFlashClkFreq(void);
 872:../drivers/fsl_clock.h **** 
 873:../drivers/fsl_clock.h **** /*!
 874:../drivers/fsl_clock.h ****  * @brief Get the output clock frequency selected by SIM[PLLFLLSEL].
 875:../drivers/fsl_clock.h ****  *
 876:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 877:../drivers/fsl_clock.h ****  */
 878:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPllFllSelClkFreq(void);
 879:../drivers/fsl_clock.h **** 
 880:../drivers/fsl_clock.h **** /*!
 881:../drivers/fsl_clock.h ****  * @brief Get the external reference 32K clock frequency (ERCLK32K).
 882:../drivers/fsl_clock.h ****  *
 883:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 884:../drivers/fsl_clock.h ****  */
 885:../drivers/fsl_clock.h **** uint32_t CLOCK_GetEr32kClkFreq(void);
 886:../drivers/fsl_clock.h **** 
 887:../drivers/fsl_clock.h **** /*!
 888:../drivers/fsl_clock.h ****  * @brief Get the OSC0 external reference clock frequency (OSC0ERCLK).
 889:../drivers/fsl_clock.h ****  *
 890:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 891:../drivers/fsl_clock.h ****  */
 892:../drivers/fsl_clock.h **** uint32_t CLOCK_GetOsc0ErClkFreq(void);
 893:../drivers/fsl_clock.h **** 
 894:../drivers/fsl_clock.h **** /*!
 895:../drivers/fsl_clock.h ****  * @brief Set the clock configure in SIM module.
 896:../drivers/fsl_clock.h ****  *
 897:../drivers/fsl_clock.h ****  * This function sets system layer clock settings in SIM module.
 898:../drivers/fsl_clock.h ****  *
 899:../drivers/fsl_clock.h ****  * @param config Pointer to the configure structure.
 900:../drivers/fsl_clock.h ****  */
 901:../drivers/fsl_clock.h **** void CLOCK_SetSimConfig(sim_clock_config_t const *config);
 902:../drivers/fsl_clock.h **** 
 903:../drivers/fsl_clock.h **** /*!
 904:../drivers/fsl_clock.h ****  * @brief Set the system clock dividers in SIM to safe value.
 905:../drivers/fsl_clock.h ****  *
 906:../drivers/fsl_clock.h ****  * The system level clocks (core clock, bus clock, flexbus clock and flash clock)
 907:../drivers/fsl_clock.h ****  * must be in allowed ranges. During MCG clock mode switch, the MCG output clock
 908:../drivers/fsl_clock.h ****  * changes then the system level clocks may be out of range. This function could
 909:../drivers/fsl_clock.h ****  * be used before MCG mode change, to make sure system level clocks are in allowed
 910:../drivers/fsl_clock.h ****  * range.
 911:../drivers/fsl_clock.h ****  *
 912:../drivers/fsl_clock.h ****  * @param config Pointer to the configure structure.
 913:../drivers/fsl_clock.h ****  */
 914:../drivers/fsl_clock.h **** static inline void CLOCK_SetSimSafeDivs(void)
 915:../drivers/fsl_clock.h **** {
 916:../drivers/fsl_clock.h ****     SIM->CLKDIV1 = 0x01240000U;
 917:../drivers/fsl_clock.h **** }
 918:../drivers/fsl_clock.h **** 
 919:../drivers/fsl_clock.h **** /*! @name MCG frequency functions. */
 920:../drivers/fsl_clock.h **** /*@{*/
 921:../drivers/fsl_clock.h **** 
 922:../drivers/fsl_clock.h **** /*!
 923:../drivers/fsl_clock.h ****  * @brief Gets the MCG output clock (MCGOUTCLK) frequency.
 924:../drivers/fsl_clock.h ****  *
 925:../drivers/fsl_clock.h ****  * This function gets the MCG output clock frequency in Hz based on the current MCG
 926:../drivers/fsl_clock.h ****  * register value.
 927:../drivers/fsl_clock.h ****  *
 928:../drivers/fsl_clock.h ****  * @return The frequency of MCGOUTCLK.
 929:../drivers/fsl_clock.h ****  */
 930:../drivers/fsl_clock.h **** uint32_t CLOCK_GetOutClkFreq(void);
 931:../drivers/fsl_clock.h **** 
 932:../drivers/fsl_clock.h **** /*!
 933:../drivers/fsl_clock.h ****  * @brief Gets the MCG FLL clock (MCGFLLCLK) frequency.
 934:../drivers/fsl_clock.h ****  *
 935:../drivers/fsl_clock.h ****  * This function gets the MCG FLL clock frequency in Hz based on the current MCG
 936:../drivers/fsl_clock.h ****  * register value. The FLL is enabled in FEI/FBI/FEE/FBE mode and
 937:../drivers/fsl_clock.h ****  * disabled in low power state in other modes.
 938:../drivers/fsl_clock.h ****  *
 939:../drivers/fsl_clock.h ****  * @return The frequency of MCGFLLCLK.
 940:../drivers/fsl_clock.h ****  */
 941:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFllFreq(void);
 942:../drivers/fsl_clock.h **** 
 943:../drivers/fsl_clock.h **** /*!
 944:../drivers/fsl_clock.h ****  * @brief Gets the MCG internal reference clock (MCGIRCLK) frequency.
 945:../drivers/fsl_clock.h ****  *
 946:../drivers/fsl_clock.h ****  * This function gets the MCG internal reference clock frequency in Hz based
 947:../drivers/fsl_clock.h ****  * on the current MCG register value.
 948:../drivers/fsl_clock.h ****  *
 949:../drivers/fsl_clock.h ****  * @return The frequency of MCGIRCLK.
 950:../drivers/fsl_clock.h ****  */
 951:../drivers/fsl_clock.h **** uint32_t CLOCK_GetInternalRefClkFreq(void);
 952:../drivers/fsl_clock.h **** 
 953:../drivers/fsl_clock.h **** /*!
 954:../drivers/fsl_clock.h ****  * @brief Gets the MCG fixed frequency clock (MCGFFCLK) frequency.
 955:../drivers/fsl_clock.h ****  *
 956:../drivers/fsl_clock.h ****  * This function gets the MCG fixed frequency clock frequency in Hz based
 957:../drivers/fsl_clock.h ****  * on the current MCG register value.
 958:../drivers/fsl_clock.h ****  *
 959:../drivers/fsl_clock.h ****  * @return The frequency of MCGFFCLK.
 960:../drivers/fsl_clock.h ****  */
 961:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFixedFreqClkFreq(void);
 962:../drivers/fsl_clock.h **** 
 963:../drivers/fsl_clock.h **** /*!
 964:../drivers/fsl_clock.h ****  * @brief Gets the MCG PLL0 clock (MCGPLL0CLK) frequency.
 965:../drivers/fsl_clock.h ****  *
 966:../drivers/fsl_clock.h ****  * This function gets the MCG PLL0 clock frequency in Hz based on the current MCG
 967:../drivers/fsl_clock.h ****  * register value.
 968:../drivers/fsl_clock.h ****  *
 969:../drivers/fsl_clock.h ****  * @return The frequency of MCGPLL0CLK.
 970:../drivers/fsl_clock.h ****  */
 971:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPll0Freq(void);
 972:../drivers/fsl_clock.h **** 
 973:../drivers/fsl_clock.h **** /*@}*/
 974:../drivers/fsl_clock.h **** 
 975:../drivers/fsl_clock.h **** /*! @name MCG clock configuration. */
 976:../drivers/fsl_clock.h **** /*@{*/
 977:../drivers/fsl_clock.h **** 
 978:../drivers/fsl_clock.h **** /*!
 979:../drivers/fsl_clock.h ****  * @brief Enables or disables the MCG low power.
 980:../drivers/fsl_clock.h ****  *
 981:../drivers/fsl_clock.h ****  * Enabling the MCG low power disables the PLL and FLL in bypass modes. In other words,
 982:../drivers/fsl_clock.h ****  * in FBE and PBE modes, enabling low power sets the MCG to BLPE mode. In FBI and
 983:../drivers/fsl_clock.h ****  * PBI modes, enabling low power sets the MCG to BLPI mode.
 984:../drivers/fsl_clock.h ****  * When disabling the MCG low power, the PLL or FLL are enabled based on MCG settings.
 985:../drivers/fsl_clock.h ****  *
 986:../drivers/fsl_clock.h ****  * @param enable True to enable MCG low power, false to disable MCG low power.
 987:../drivers/fsl_clock.h ****  */
 988:../drivers/fsl_clock.h **** static inline void CLOCK_SetLowPowerEnable(bool enable)
 989:../drivers/fsl_clock.h **** {
 990:../drivers/fsl_clock.h ****     if (enable)
 991:../drivers/fsl_clock.h ****     {
 992:../drivers/fsl_clock.h ****         MCG->C2 |= MCG_C2_LP_MASK;
 993:../drivers/fsl_clock.h ****     }
 994:../drivers/fsl_clock.h ****     else
 995:../drivers/fsl_clock.h ****     {
 996:../drivers/fsl_clock.h ****         MCG->C2 &= ~MCG_C2_LP_MASK;
 997:../drivers/fsl_clock.h ****     }
 998:../drivers/fsl_clock.h **** }
 999:../drivers/fsl_clock.h **** 
1000:../drivers/fsl_clock.h **** /*!
1001:../drivers/fsl_clock.h ****  * @brief Configures the Internal Reference clock (MCGIRCLK).
1002:../drivers/fsl_clock.h ****  *
1003:../drivers/fsl_clock.h ****  * This function sets the \c MCGIRCLK base on parameters. It also selects the IRC
1004:../drivers/fsl_clock.h ****  * source. If the fast IRC is used, this function sets the fast IRC divider.
1005:../drivers/fsl_clock.h ****  * This function also sets whether the \c MCGIRCLK is enabled in stop mode.
1006:../drivers/fsl_clock.h ****  * Calling this function in FBI/PBI/BLPI modes may change the system clock. As a result,
1007:../drivers/fsl_clock.h ****  * using the function in these modes it is not allowed.
1008:../drivers/fsl_clock.h ****  *
1009:../drivers/fsl_clock.h ****  * @param enableMode MCGIRCLK enable mode, OR'ed value of @ref _mcg_irclk_enable_mode.
1010:../drivers/fsl_clock.h ****  * @param ircs       MCGIRCLK clock source, choose fast or slow.
1011:../drivers/fsl_clock.h ****  * @param fcrdiv     Fast IRC divider setting (\c FCRDIV).
1012:../drivers/fsl_clock.h ****  * @retval kStatus_MCG_SourceUsed Because the internall reference clock is used as a clock source,
1013:../drivers/fsl_clock.h ****  * the confuration should not be changed. Otherwise, a glitch occurs.
1014:../drivers/fsl_clock.h ****  * @retval kStatus_Success MCGIRCLK configuration finished successfully.
1015:../drivers/fsl_clock.h ****  */
1016:../drivers/fsl_clock.h **** status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv);
1017:../drivers/fsl_clock.h **** 
1018:../drivers/fsl_clock.h **** /*!
1019:../drivers/fsl_clock.h ****  * @brief Selects the MCG external reference clock.
1020:../drivers/fsl_clock.h ****  *
1021:../drivers/fsl_clock.h ****  * Selects the MCG external reference clock source, changes the MCG_C7[OSCSEL],
1022:../drivers/fsl_clock.h ****  * and waits for the clock source to be stable. Because the external reference
1023:../drivers/fsl_clock.h ****  * clock should not be changed in FEE/FBE/BLPE/PBE/PEE modes, do not call this function in these mo
1024:../drivers/fsl_clock.h ****  *
1025:../drivers/fsl_clock.h ****  * @param oscsel MCG external reference clock source, MCG_C7[OSCSEL].
1026:../drivers/fsl_clock.h ****  * @retval kStatus_MCG_SourceUsed Because the external reference clock is used as a clock source,
1027:../drivers/fsl_clock.h ****  * the confuration should not be changed. Otherwise, a glitch occurs.
1028:../drivers/fsl_clock.h ****  * @retval kStatus_Success External reference clock set successfully.
1029:../drivers/fsl_clock.h ****  */
1030:../drivers/fsl_clock.h **** status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel);
1031:../drivers/fsl_clock.h **** 
1032:../drivers/fsl_clock.h **** /*!
1033:../drivers/fsl_clock.h ****  * @brief Set the FLL external reference clock divider value.
1034:../drivers/fsl_clock.h ****  *
1035:../drivers/fsl_clock.h ****  * Sets the FLL external reference clock divider value, the register MCG_C1[FRDIV].
1036:../drivers/fsl_clock.h ****  *
1037:../drivers/fsl_clock.h ****  * @param frdiv The FLL external reference clock divider value, MCG_C1[FRDIV].
1038:../drivers/fsl_clock.h ****  */
1039:../drivers/fsl_clock.h **** static inline void CLOCK_SetFllExtRefDiv(uint8_t frdiv)
1040:../drivers/fsl_clock.h **** {
1041:../drivers/fsl_clock.h ****     MCG->C1 = (MCG->C1 & ~MCG_C1_FRDIV_MASK) | MCG_C1_FRDIV(frdiv);
1042:../drivers/fsl_clock.h **** }
1043:../drivers/fsl_clock.h **** 
1044:../drivers/fsl_clock.h **** /*!
1045:../drivers/fsl_clock.h ****  * @brief Enables the PLL0 in FLL mode.
1046:../drivers/fsl_clock.h ****  *
1047:../drivers/fsl_clock.h ****  * This function sets us the PLL0 in FLL mode and reconfigures
1048:../drivers/fsl_clock.h ****  * the PLL0. Ensure that the PLL reference
1049:../drivers/fsl_clock.h ****  * clock is enabled before calling this function and that the PLL0 is not used as a clock source.
1050:../drivers/fsl_clock.h ****  * The function CLOCK_CalcPllDiv gets the correct PLL
1051:../drivers/fsl_clock.h ****  * divider values.
1052:../drivers/fsl_clock.h ****  *
1053:../drivers/fsl_clock.h ****  * @param config Pointer to the configuration structure.
1054:../drivers/fsl_clock.h ****  */
1055:../drivers/fsl_clock.h **** void CLOCK_EnablePll0(mcg_pll_config_t const *config);
1056:../drivers/fsl_clock.h **** 
1057:../drivers/fsl_clock.h **** /*!
1058:../drivers/fsl_clock.h ****  * @brief Disables the PLL0 in FLL mode.
1059:../drivers/fsl_clock.h ****  *
1060:../drivers/fsl_clock.h ****  * This function disables the PLL0 in FLL mode. It should be used together with the
1061:../drivers/fsl_clock.h ****  * @ref CLOCK_EnablePll0.
1062:../drivers/fsl_clock.h ****  */
1063:../drivers/fsl_clock.h **** static inline void CLOCK_DisablePll0(void)
1064:../drivers/fsl_clock.h **** {
1065:../drivers/fsl_clock.h ****     MCG->C5 &= ~(MCG_C5_PLLCLKEN0_MASK | MCG_C5_PLLSTEN0_MASK);
1066:../drivers/fsl_clock.h **** }
1067:../drivers/fsl_clock.h **** 
1068:../drivers/fsl_clock.h **** /*!
1069:../drivers/fsl_clock.h ****  * @brief Calculates the PLL divider setting for a desired output frequency.
1070:../drivers/fsl_clock.h ****  *
1071:../drivers/fsl_clock.h ****  * This function calculates the correct reference clock divider (\c PRDIV) and
1072:../drivers/fsl_clock.h ****  * VCO divider (\c VDIV) to generate a desired PLL output frequency. It returns the
1073:../drivers/fsl_clock.h ****  * closest frequency match with the corresponding \c PRDIV/VDIV
1074:../drivers/fsl_clock.h ****  * returned from parameters. If a desired frequency is not valid, this function
1075:../drivers/fsl_clock.h ****  * returns 0.
1076:../drivers/fsl_clock.h ****  *
1077:../drivers/fsl_clock.h ****  * @param refFreq    PLL reference clock frequency.
1078:../drivers/fsl_clock.h ****  * @param desireFreq Desired PLL output frequency.
1079:../drivers/fsl_clock.h ****  * @param prdiv      PRDIV value to generate desired PLL frequency.
1080:../drivers/fsl_clock.h ****  * @param vdiv       VDIV value to generate desired PLL frequency.
1081:../drivers/fsl_clock.h ****  * @return Closest frequency match that the PLL was able generate.
1082:../drivers/fsl_clock.h ****  */
1083:../drivers/fsl_clock.h **** uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv);
1084:../drivers/fsl_clock.h **** 
1085:../drivers/fsl_clock.h **** /*@}*/
1086:../drivers/fsl_clock.h **** 
1087:../drivers/fsl_clock.h **** /*! @name MCG clock lock monitor functions. */
1088:../drivers/fsl_clock.h **** /*@{*/
1089:../drivers/fsl_clock.h **** 
1090:../drivers/fsl_clock.h **** /*!
1091:../drivers/fsl_clock.h ****  * @brief Sets the OSC0 clock monitor mode.
1092:../drivers/fsl_clock.h ****  *
1093:../drivers/fsl_clock.h ****  * This function sets the OSC0 clock monitor mode. See @ref mcg_monitor_mode_t for details.
1094:../drivers/fsl_clock.h ****  *
1095:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
1096:../drivers/fsl_clock.h ****  */
1097:../drivers/fsl_clock.h **** void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode);
1098:../drivers/fsl_clock.h **** 
1099:../drivers/fsl_clock.h **** /*!
1100:../drivers/fsl_clock.h ****  * @brief Sets the RTC OSC clock monitor mode.
1101:../drivers/fsl_clock.h ****  *
1102:../drivers/fsl_clock.h ****  * This function sets the RTC OSC clock monitor mode. See @ref mcg_monitor_mode_t for details.
1103:../drivers/fsl_clock.h ****  *
1104:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
1105:../drivers/fsl_clock.h ****  */
1106:../drivers/fsl_clock.h **** void CLOCK_SetRtcOscMonitorMode(mcg_monitor_mode_t mode);
1107:../drivers/fsl_clock.h **** 
1108:../drivers/fsl_clock.h **** /*!
1109:../drivers/fsl_clock.h ****  * @brief Sets the PLL0 clock monitor mode.
1110:../drivers/fsl_clock.h ****  *
1111:../drivers/fsl_clock.h ****  * This function sets the PLL0 clock monitor mode. See @ref mcg_monitor_mode_t for details.
1112:../drivers/fsl_clock.h ****  *
1113:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
1114:../drivers/fsl_clock.h ****  */
1115:../drivers/fsl_clock.h **** void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode);
1116:../drivers/fsl_clock.h **** 
1117:../drivers/fsl_clock.h **** /*!
1118:../drivers/fsl_clock.h ****  * @brief Gets the MCG status flags.
1119:../drivers/fsl_clock.h ****  *
1120:../drivers/fsl_clock.h ****  * This function gets the MCG clock status flags. All status flags are
1121:../drivers/fsl_clock.h ****  * returned as a logical OR of the enumeration @ref _mcg_status_flags_t. To
1122:../drivers/fsl_clock.h ****  * check a specific flag, compare the return value with the flag.
1123:../drivers/fsl_clock.h ****  *
1124:../drivers/fsl_clock.h ****  * Example:
1125:../drivers/fsl_clock.h ****  * @code
1126:../drivers/fsl_clock.h ****    // To check the clock lost lock status of OSC0 and PLL0.
1127:../drivers/fsl_clock.h ****    uint32_t mcgFlags;
1128:../drivers/fsl_clock.h **** 
1129:../drivers/fsl_clock.h ****    mcgFlags = CLOCK_GetStatusFlags();
1130:../drivers/fsl_clock.h **** 
1131:../drivers/fsl_clock.h ****    if (mcgFlags & kMCG_Osc0LostFlag)
1132:../drivers/fsl_clock.h ****    {
1133:../drivers/fsl_clock.h ****        // OSC0 clock lock lost. Do something.
1134:../drivers/fsl_clock.h ****    }
1135:../drivers/fsl_clock.h ****    if (mcgFlags & kMCG_Pll0LostFlag)
1136:../drivers/fsl_clock.h ****    {
1137:../drivers/fsl_clock.h ****        // PLL0 clock lock lost. Do something.
1138:../drivers/fsl_clock.h ****    }
1139:../drivers/fsl_clock.h ****    @endcode
1140:../drivers/fsl_clock.h ****  *
1141:../drivers/fsl_clock.h ****  * @return  Logical OR value of the @ref _mcg_status_flags_t.
1142:../drivers/fsl_clock.h ****  */
1143:../drivers/fsl_clock.h **** uint32_t CLOCK_GetStatusFlags(void);
1144:../drivers/fsl_clock.h **** 
1145:../drivers/fsl_clock.h **** /*!
1146:../drivers/fsl_clock.h ****  * @brief Clears the MCG status flags.
1147:../drivers/fsl_clock.h ****  *
1148:../drivers/fsl_clock.h ****  * This function clears the MCG clock lock lost status. The parameter is a logical
1149:../drivers/fsl_clock.h ****  * OR value of the flags to clear. See @ref _mcg_status_flags_t.
1150:../drivers/fsl_clock.h ****  *
1151:../drivers/fsl_clock.h ****  * Example:
1152:../drivers/fsl_clock.h ****  * @code
1153:../drivers/fsl_clock.h ****    // To clear the clock lost lock status flags of OSC0 and PLL0.
1154:../drivers/fsl_clock.h **** 
1155:../drivers/fsl_clock.h ****    CLOCK_ClearStatusFlags(kMCG_Osc0LostFlag | kMCG_Pll0LostFlag);
1156:../drivers/fsl_clock.h ****    @endcode
1157:../drivers/fsl_clock.h ****  *
1158:../drivers/fsl_clock.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
1159:../drivers/fsl_clock.h ****  *             enumeration @ref _mcg_status_flags_t.
1160:../drivers/fsl_clock.h ****  */
1161:../drivers/fsl_clock.h **** void CLOCK_ClearStatusFlags(uint32_t mask);
1162:../drivers/fsl_clock.h **** 
1163:../drivers/fsl_clock.h **** /*@}*/
1164:../drivers/fsl_clock.h **** 
1165:../drivers/fsl_clock.h **** /*!
1166:../drivers/fsl_clock.h ****  * @name OSC configuration
1167:../drivers/fsl_clock.h ****  * @{
1168:../drivers/fsl_clock.h ****  */
1169:../drivers/fsl_clock.h **** 
1170:../drivers/fsl_clock.h **** /*!
1171:../drivers/fsl_clock.h ****  * @brief Configures the OSC external reference clock (OSCERCLK).
1172:../drivers/fsl_clock.h ****  *
1173:../drivers/fsl_clock.h ****  * This function configures the OSC external reference clock (OSCERCLK).
1174:../drivers/fsl_clock.h ****  * This is an example to enable the OSCERCLK in normal and stop modes and also set
1175:../drivers/fsl_clock.h ****  * the output divider to 1:
1176:../drivers/fsl_clock.h ****  *
1177:../drivers/fsl_clock.h ****    @code
1178:../drivers/fsl_clock.h ****    oscer_config_t config =
1179:../drivers/fsl_clock.h ****    {
1180:../drivers/fsl_clock.h ****        .enableMode = kOSC_ErClkEnable | kOSC_ErClkEnableInStop,
1181:../drivers/fsl_clock.h ****        .erclkDiv   = 1U,
1182:../drivers/fsl_clock.h ****    };
1183:../drivers/fsl_clock.h **** 
1184:../drivers/fsl_clock.h ****    OSC_SetExtRefClkConfig(OSC, &config);
1185:../drivers/fsl_clock.h ****    @endcode
1186:../drivers/fsl_clock.h ****  *
1187:../drivers/fsl_clock.h ****  * @param base   OSC peripheral address.
1188:../drivers/fsl_clock.h ****  * @param config Pointer to the configuration structure.
1189:../drivers/fsl_clock.h ****  */
1190:../drivers/fsl_clock.h **** static inline void OSC_SetExtRefClkConfig(OSC_Type *base, oscer_config_t const *config)
1191:../drivers/fsl_clock.h **** {
1192:../drivers/fsl_clock.h ****     uint8_t reg = base->CR;
1193:../drivers/fsl_clock.h **** 
1194:../drivers/fsl_clock.h ****     reg &= ~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK);
1195:../drivers/fsl_clock.h ****     reg |= config->enableMode;
1196:../drivers/fsl_clock.h **** 
1197:../drivers/fsl_clock.h ****     base->CR = reg;
1198:../drivers/fsl_clock.h **** }
1199:../drivers/fsl_clock.h **** 
1200:../drivers/fsl_clock.h **** /*!
1201:../drivers/fsl_clock.h ****  * @brief Sets the capacitor load configuration for the oscillator.
1202:../drivers/fsl_clock.h ****  *
1203:../drivers/fsl_clock.h ****  * This function sets the specified capacitors configuration for the oscillator.
1204:../drivers/fsl_clock.h ****  * This should be done in the early system level initialization function call
1205:../drivers/fsl_clock.h ****  * based on the system configuration.
1206:../drivers/fsl_clock.h ****  *
1207:../drivers/fsl_clock.h ****  * @param base   OSC peripheral address.
1208:../drivers/fsl_clock.h ****  * @param capLoad OR'ed value for the capacitor load option, see \ref _osc_cap_load.
1209:../drivers/fsl_clock.h ****  *
1210:../drivers/fsl_clock.h ****  * Example:
1211:../drivers/fsl_clock.h ****    @code
1212:../drivers/fsl_clock.h ****    // To enable only 2 pF and 8 pF capacitor load, please use like this.
1213:../drivers/fsl_clock.h ****    OSC_SetCapLoad(OSC, kOSC_Cap2P | kOSC_Cap8P);
1214:../drivers/fsl_clock.h ****    @endcode
1215:../drivers/fsl_clock.h ****  */
1216:../drivers/fsl_clock.h **** static inline void OSC_SetCapLoad(OSC_Type *base, uint8_t capLoad)
1217:../drivers/fsl_clock.h **** {
1218:../drivers/fsl_clock.h ****     uint8_t reg = base->CR;
 1990              		.loc 2 1218 0
 1991 0016 1149     		ldr	r1, .L270+4
1219:../drivers/fsl_clock.h **** 
1220:../drivers/fsl_clock.h ****     reg &= ~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK);
1221:../drivers/fsl_clock.h ****     reg |= capLoad;
 1992              		.loc 2 1221 0
 1993 0018 0279     		ldrb	r2, [r0, #4]	@ zero_extendqisi2
1218:../drivers/fsl_clock.h **** 
 1994              		.loc 2 1218 0
 1995 001a 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1996              	.LVL152:
1220:../drivers/fsl_clock.h ****     reg |= capLoad;
 1997              		.loc 2 1220 0
 1998 001c 03F0F003 		and	r3, r3, #240
 1999              	.LVL153:
 2000              		.loc 2 1221 0
 2001 0020 1343     		orrs	r3, r3, r2
 2002              	.LVL154:
1222:../drivers/fsl_clock.h **** 
1223:../drivers/fsl_clock.h ****     base->CR = reg;
 2003              		.loc 2 1223 0
 2004 0022 0B70     		strb	r3, [r1]
 2005              	.LVL155:
 2006              	.LBE78:
 2007              	.LBE77:
 2008              	.LBB79:
 2009              	.LBB80:
1192:../drivers/fsl_clock.h **** 
 2010              		.loc 2 1192 0
 2011 0024 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 2012              	.LVL156:
1195:../drivers/fsl_clock.h **** 
 2013              		.loc 2 1195 0
 2014 0026 8279     		ldrb	r2, [r0, #6]	@ zero_extendqisi2
1194:../drivers/fsl_clock.h ****     reg |= config->enableMode;
 2015              		.loc 2 1194 0
 2016 0028 03F05F03 		and	r3, r3, #95
 2017              	.LVL157:
1195:../drivers/fsl_clock.h **** 
 2018              		.loc 2 1195 0
 2019 002c 1343     		orrs	r3, r3, r2
 2020              	.LVL158:
 2021              	.LBE80:
 2022              	.LBE79:
 978:../drivers/fsl_clock.c **** 
 979:../drivers/fsl_clock.c ****     OSC_SetCapLoad(OSC0, config->capLoad);
 980:../drivers/fsl_clock.c ****     OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
 981:../drivers/fsl_clock.c **** 
 982:../drivers/fsl_clock.c ****     MCG->C2 = ((MCG->C2 & ~OSC_MODE_MASK) | MCG_C2_RANGE(range) | (uint8_t)config->workMode);
 2023              		.loc 1 982 0
 2024 002e 0C4A     		ldr	r2, .L270+8
 2025              	.LBB82:
 2026              	.LBB81:
1197:../drivers/fsl_clock.h **** }
 2027              		.loc 2 1197 0
 2028 0030 0B70     		strb	r3, [r1]
 2029              	.LVL159:
 2030              	.LBE81:
 2031              	.LBE82:
 2032              		.loc 1 982 0
 2033 0032 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 2034 0034 4079     		ldrb	r0, [r0, #5]	@ zero_extendqisi2
 2035              	.LVL160:
 2036 0036 03F0C303 		and	r3, r3, #195
 2037 003a 0343     		orrs	r3, r3, r0
 2038 003c 43EA0413 		orr	r3, r3, r4, lsl #4
 2039 0040 5370     		strb	r3, [r2, #1]
 983:../drivers/fsl_clock.c **** 
 984:../drivers/fsl_clock.c ****     if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
 2040              		.loc 1 984 0
 2041 0042 28B1     		cbz	r0, .L259
 2042              		.loc 1 984 0 is_stmt 0 discriminator 1
 2043 0044 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 2044 0046 1906     		lsls	r1, r3, #24
 2045 0048 02D5     		bpl	.L259
 2046              	.L262:
 985:../drivers/fsl_clock.c ****     {
 986:../drivers/fsl_clock.c ****         /* Wait for stable. */
 987:../drivers/fsl_clock.c ****         while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 2047              		.loc 1 987 0 is_stmt 1 discriminator 1
 2048 004a 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 2049 004c 9B07     		lsls	r3, r3, #30
 2050 004e FCD5     		bpl	.L262
 2051              	.L259:
 988:../drivers/fsl_clock.c ****         {
 989:../drivers/fsl_clock.c ****         }
 990:../drivers/fsl_clock.c ****     }
 991:../drivers/fsl_clock.c **** }
 2052              		.loc 1 991 0
 2053 0050 10BD     		pop	{r4, pc}
 2054              	.LVL161:
 2055              	.L263:
 2056              	.LBB83:
 2057              	.LBB75:
 349:../drivers/fsl_clock.c ****     }
 2058              		.loc 1 349 0
 2059 0052 0024     		movs	r4, #0
 2060 0054 DFE7     		b	.L260
 2061              	.L271:
 2062 0056 00BF     		.align	2
 2063              	.L270:
 2064 0058 00127A00 		.word	8000000
 2065 005c 00500640 		.word	1074155520
 2066 0060 00400640 		.word	1074151424
 2067              	.LBE75:
 2068              	.LBE83:
 2069              		.cfi_endproc
 2070              	.LFE179:
 2072              		.section	.text.CLOCK_DeinitOsc0,"ax",%progbits
 2073              		.align	1
 2074              		.global	CLOCK_DeinitOsc0
 2075              		.syntax unified
 2076              		.thumb
 2077              		.thumb_func
 2078              		.fpu fpv4-sp-d16
 2080              	CLOCK_DeinitOsc0:
 2081              	.LFB180:
 992:../drivers/fsl_clock.c **** 
 993:../drivers/fsl_clock.c **** void CLOCK_DeinitOsc0(void)
 994:../drivers/fsl_clock.c **** {
 2082              		.loc 1 994 0
 2083              		.cfi_startproc
 2084              		@ args = 0, pretend = 0, frame = 0
 2085              		@ frame_needed = 0, uses_anonymous_args = 0
 2086              		@ link register save eliminated.
 995:../drivers/fsl_clock.c ****     OSC0->CR = 0U;
 2087              		.loc 1 995 0
 2088 0000 044B     		ldr	r3, .L273
 2089 0002 0022     		movs	r2, #0
 2090 0004 1A70     		strb	r2, [r3]
 996:../drivers/fsl_clock.c ****     MCG->C2 &= ~OSC_MODE_MASK;
 2091              		.loc 1 996 0
 2092 0006 044A     		ldr	r2, .L273+4
 2093 0008 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 2094 000a 03F0C303 		and	r3, r3, #195
 2095 000e 5370     		strb	r3, [r2, #1]
 997:../drivers/fsl_clock.c **** }
 2096              		.loc 1 997 0
 2097 0010 7047     		bx	lr
 2098              	.L274:
 2099 0012 00BF     		.align	2
 2100              	.L273:
 2101 0014 00500640 		.word	1074155520
 2102 0018 00400640 		.word	1074151424
 2103              		.cfi_endproc
 2104              	.LFE180:
 2106              		.section	.text.CLOCK_TrimInternalRefClk,"ax",%progbits
 2107              		.align	1
 2108              		.global	CLOCK_TrimInternalRefClk
 2109              		.syntax unified
 2110              		.thumb
 2111              		.thumb_func
 2112              		.fpu fpv4-sp-d16
 2114              	CLOCK_TrimInternalRefClk:
 2115              	.LFB181:
 998:../drivers/fsl_clock.c **** 
 999:../drivers/fsl_clock.c **** status_t CLOCK_TrimInternalRefClk(uint32_t extFreq, uint32_t desireFreq, uint32_t *actualFreq, mcg_
1000:../drivers/fsl_clock.c **** {
 2116              		.loc 1 1000 0
 2117              		.cfi_startproc
 2118              		@ args = 0, pretend = 0, frame = 0
 2119              		@ frame_needed = 0, uses_anonymous_args = 0
 2120              	.LVL162:
 2121 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2122              		.cfi_def_cfa_offset 20
 2123              		.cfi_offset 4, -20
 2124              		.cfi_offset 5, -16
 2125              		.cfi_offset 6, -12
 2126              		.cfi_offset 7, -8
 2127              		.cfi_offset 14, -4
 2128              		.loc 1 1000 0
 2129 0002 0646     		mov	r6, r0
1001:../drivers/fsl_clock.c ****     uint32_t multi; /* extFreq / desireFreq */
1002:../drivers/fsl_clock.c ****     uint32_t actv;  /* Auto trim value. */
1003:../drivers/fsl_clock.c ****     uint8_t mcg_sc;
1004:../drivers/fsl_clock.c **** 
1005:../drivers/fsl_clock.c ****     static const uint32_t trimRange[2][2] = {
1006:../drivers/fsl_clock.c ****         /*     Min           Max      */
1007:../drivers/fsl_clock.c ****         {TRIM_SIRC_MIN, TRIM_SIRC_MAX}, /* Slow IRC. */
1008:../drivers/fsl_clock.c ****         {TRIM_FIRC_MIN, TRIM_FIRC_MAX}  /* Fast IRC. */
1009:../drivers/fsl_clock.c ****     };
1010:../drivers/fsl_clock.c **** 
1011:../drivers/fsl_clock.c ****     if ((extFreq > TRIM_REF_CLK_MAX) || (extFreq < TRIM_REF_CLK_MIN))
 2130              		.loc 1 1011 0
 2131 0004 254C     		ldr	r4, .L287
 2132 0006 A0F5F400 		sub	r0, r0, #7995392
 2133              	.LVL163:
 2134 000a A0F59050 		sub	r0, r0, #4608
 2135 000e A042     		cmp	r0, r4
 2136 0010 3AD8     		bhi	.L281
1012:../drivers/fsl_clock.c ****     {
1013:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmBusClockInvalid;
1014:../drivers/fsl_clock.c ****     }
1015:../drivers/fsl_clock.c **** 
1016:../drivers/fsl_clock.c ****     /* Check desired frequency range. */
1017:../drivers/fsl_clock.c ****     if ((desireFreq < trimRange[atms][0]) || (desireFreq > trimRange[atms][1]))
 2137              		.loc 1 1017 0
 2138 0012 234C     		ldr	r4, .L287+4
 2139 0014 54F83300 		ldr	r0, [r4, r3, lsl #3]
 2140 0018 8842     		cmp	r0, r1
 2141 001a 38D8     		bhi	.L283
 2142              		.loc 1 1017 0 is_stmt 0 discriminator 1
 2143 001c 04EBC304 		add	r4, r4, r3, lsl #3
 2144 0020 6068     		ldr	r0, [r4, #4]
 2145 0022 8842     		cmp	r0, r1
 2146 0024 33D3     		bcc	.L283
1018:../drivers/fsl_clock.c ****     {
1019:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmDesiredFreqInvalid;
1020:../drivers/fsl_clock.c ****     }
1021:../drivers/fsl_clock.c **** 
1022:../drivers/fsl_clock.c ****     /*
1023:../drivers/fsl_clock.c ****        Make sure internal reference clock is not used to generate bus clock.
1024:../drivers/fsl_clock.c ****        Here only need to check (MCG_S_IREFST == 1).
1025:../drivers/fsl_clock.c ****      */
1026:../drivers/fsl_clock.c ****     if (MCG_S_IREFST(kMCG_FllSrcInternal) == (MCG->S & MCG_S_IREFST_MASK))
 2147              		.loc 1 1026 0 is_stmt 1
 2148 0026 1F4F     		ldr	r7, .L287+8
 2149 0028 B879     		ldrb	r0, [r7, #6]	@ zero_extendqisi2
 2150 002a C406     		lsls	r4, r0, #27
 2151 002c 32D4     		bmi	.L284
1027:../drivers/fsl_clock.c ****     {
1028:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmIrcUsed;
1029:../drivers/fsl_clock.c ****     }
1030:../drivers/fsl_clock.c **** 
1031:../drivers/fsl_clock.c ****     multi = extFreq / desireFreq;
 2152              		.loc 1 1031 0
 2153 002e B6FBF1F1 		udiv	r1, r6, r1
 2154              	.LVL164:
1032:../drivers/fsl_clock.c ****     actv = multi * 21U;
 2155              		.loc 1 1032 0
 2156 0032 1524     		movs	r4, #21
 2157 0034 4C43     		muls	r4, r1, r4
 2158              	.LVL165:
1033:../drivers/fsl_clock.c **** 
1034:../drivers/fsl_clock.c ****     if (kMCG_AtmSel4m == atms)
 2159              		.loc 1 1034 0
 2160 0036 012B     		cmp	r3, #1
1035:../drivers/fsl_clock.c ****     {
1036:../drivers/fsl_clock.c ****         actv *= 128U;
 2161              		.loc 1 1036 0
 2162 0038 08BF     		it	eq
 2163 003a E401     		lsleq	r4, r4, #7
 2164              	.LVL166:
1037:../drivers/fsl_clock.c ****     }
1038:../drivers/fsl_clock.c **** 
1039:../drivers/fsl_clock.c ****     /* Now begin to start trim. */
1040:../drivers/fsl_clock.c ****     MCG->ATCVL = (uint8_t)actv;
 2165              		.loc 1 1040 0
 2166 003c E0B2     		uxtb	r0, r4
1041:../drivers/fsl_clock.c ****     MCG->ATCVH = (uint8_t)(actv >> 8U);
 2167              		.loc 1 1041 0
 2168 003e C4F30724 		ubfx	r4, r4, #8, #8
 2169              	.LVL167:
1040:../drivers/fsl_clock.c ****     MCG->ATCVH = (uint8_t)(actv >> 8U);
 2170              		.loc 1 1040 0
 2171 0042 F872     		strb	r0, [r7, #11]
 2172              		.loc 1 1041 0
 2173 0044 BC72     		strb	r4, [r7, #10]
1042:../drivers/fsl_clock.c **** 
1043:../drivers/fsl_clock.c ****     mcg_sc = MCG->SC;
 2174              		.loc 1 1043 0
 2175 0046 387A     		ldrb	r0, [r7, #8]	@ zero_extendqisi2
 2176              	.LVL168:
1044:../drivers/fsl_clock.c ****     mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
1045:../drivers/fsl_clock.c ****     mcg_sc |= (MCG_SC_ATMF_MASK | MCG_SC_ATMS(atms));
 2177              		.loc 1 1045 0
 2178 0048 9D01     		lsls	r5, r3, #6
1044:../drivers/fsl_clock.c ****     mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
 2179              		.loc 1 1044 0
 2180 004a 00F0BE00 		and	r0, r0, #190
 2181              	.LVL169:
 2182              		.loc 1 1045 0
 2183 004e 05F04005 		and	r5, r5, #64
 2184 0052 0543     		orrs	r5, r5, r0
 2185              	.LVL170:
1046:../drivers/fsl_clock.c ****     MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
 2186              		.loc 1 1046 0
 2187 0054 45F0A000 		orr	r0, r5, #160
 2188 0058 3872     		strb	r0, [r7, #8]
1047:../drivers/fsl_clock.c **** 
1048:../drivers/fsl_clock.c ****     /* Wait for finished. */
1049:../drivers/fsl_clock.c ****     while (MCG->SC & MCG_SC_ATME_MASK)
 2189              		.loc 1 1049 0
 2190 005a 124F     		ldr	r7, .L287+8
 2191              	.LVL171:
 2192              	.L278:
 2193              		.loc 1 1049 0 is_stmt 0 discriminator 1
 2194 005c 387A     		ldrb	r0, [r7, #8]	@ zero_extendqisi2
 2195 005e 0006     		lsls	r0, r0, #24
 2196 0060 FCD4     		bmi	.L278
1050:../drivers/fsl_clock.c ****     {
1051:../drivers/fsl_clock.c ****     }
1052:../drivers/fsl_clock.c **** 
1053:../drivers/fsl_clock.c ****     /* Error occurs? */
1054:../drivers/fsl_clock.c ****     if (MCG->SC & MCG_SC_ATMF_MASK)
 2197              		.loc 1 1054 0 is_stmt 1
 2198 0062 3C7A     		ldrb	r4, [r7, #8]	@ zero_extendqisi2
 2199 0064 14F02000 		ands	r0, r4, #32
 2200 0068 05D0     		beq	.L279
1045:../drivers/fsl_clock.c ****     MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
 2201              		.loc 1 1045 0
 2202 006a 45F02005 		orr	r5, r5, #32
 2203              	.LVL172:
1055:../drivers/fsl_clock.c ****     {
1056:../drivers/fsl_clock.c ****         /* Clear the failed flag. */
1057:../drivers/fsl_clock.c ****         MCG->SC = mcg_sc;
 2204              		.loc 1 1057 0
 2205 006e 3D72     		strb	r5, [r7, #8]
1058:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmHardwareFail;
 2206              		.loc 1 1058 0
 2207 0070 40F2D570 		movw	r0, #2005
 2208              	.LVL173:
 2209              	.L275:
1059:../drivers/fsl_clock.c ****     }
1060:../drivers/fsl_clock.c **** 
1061:../drivers/fsl_clock.c ****     *actualFreq = extFreq / multi;
1062:../drivers/fsl_clock.c **** 
1063:../drivers/fsl_clock.c ****     if (kMCG_AtmSel4m == atms)
1064:../drivers/fsl_clock.c ****     {
1065:../drivers/fsl_clock.c ****         s_fastIrcFreq = *actualFreq;
1066:../drivers/fsl_clock.c ****     }
1067:../drivers/fsl_clock.c ****     else
1068:../drivers/fsl_clock.c ****     {
1069:../drivers/fsl_clock.c ****         s_slowIrcFreq = *actualFreq;
1070:../drivers/fsl_clock.c ****     }
1071:../drivers/fsl_clock.c **** 
1072:../drivers/fsl_clock.c ****     return kStatus_Success;
1073:../drivers/fsl_clock.c **** }
 2210              		.loc 1 1073 0
 2211 0074 F0BD     		pop	{r4, r5, r6, r7, pc}
 2212              	.LVL174:
 2213              	.L279:
1063:../drivers/fsl_clock.c ****     {
 2214              		.loc 1 1063 0
 2215 0076 012B     		cmp	r3, #1
1065:../drivers/fsl_clock.c ****     }
 2216              		.loc 1 1065 0
 2217 0078 0CBF     		ite	eq
 2218 007a 0B4B     		ldreq	r3, .L287+12
 2219              	.LVL175:
1069:../drivers/fsl_clock.c ****     }
 2220              		.loc 1 1069 0
 2221 007c 0B4B     		ldrne	r3, .L287+16
1061:../drivers/fsl_clock.c **** 
 2222              		.loc 1 1061 0
 2223 007e B6FBF1F6 		udiv	r6, r6, r1
 2224              	.LVL176:
 2225 0082 1660     		str	r6, [r2]
1069:../drivers/fsl_clock.c ****     }
 2226              		.loc 1 1069 0
 2227 0084 1E60     		str	r6, [r3]
 2228 0086 F5E7     		b	.L275
 2229              	.LVL177:
 2230              	.L281:
1013:../drivers/fsl_clock.c ****     }
 2231              		.loc 1 1013 0
 2232 0088 40F2D270 		movw	r0, #2002
 2233 008c F2E7     		b	.L275
 2234              	.L283:
1019:../drivers/fsl_clock.c ****     }
 2235              		.loc 1 1019 0
 2236 008e 40F2D370 		movw	r0, #2003
 2237 0092 EFE7     		b	.L275
 2238              	.L284:
1028:../drivers/fsl_clock.c ****     }
 2239              		.loc 1 1028 0
 2240 0094 40F2D470 		movw	r0, #2004
 2241 0098 ECE7     		b	.L275
 2242              	.L288:
 2243 009a 00BF     		.align	2
 2244              	.L287:
 2245 009c 00127A00 		.word	8000000
 2246 00a0 00000000 		.word	.LANCHOR3
 2247 00a4 00400640 		.word	1074151424
 2248 00a8 00000000 		.word	.LANCHOR1
 2249 00ac 00000000 		.word	.LANCHOR0
 2250              		.cfi_endproc
 2251              	.LFE181:
 2253              		.section	.text.CLOCK_GetMode,"ax",%progbits
 2254              		.align	1
 2255              		.global	CLOCK_GetMode
 2256              		.syntax unified
 2257              		.thumb
 2258              		.thumb_func
 2259              		.fpu fpv4-sp-d16
 2261              	CLOCK_GetMode:
 2262              	.LFB182:
1074:../drivers/fsl_clock.c **** 
1075:../drivers/fsl_clock.c **** mcg_mode_t CLOCK_GetMode(void)
1076:../drivers/fsl_clock.c **** {
 2263              		.loc 1 1076 0
 2264              		.cfi_startproc
 2265              		@ args = 0, pretend = 0, frame = 0
 2266              		@ frame_needed = 0, uses_anonymous_args = 0
 2267              		@ link register save eliminated.
 2268              	.LVL178:
1077:../drivers/fsl_clock.c ****     mcg_mode_t mode = kMCG_ModeError;
1078:../drivers/fsl_clock.c ****     uint32_t clkst = MCG_S_CLKST_VAL;
 2269              		.loc 1 1078 0
 2270 0000 1349     		ldr	r1, .L299
 2271 0002 8B79     		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 2272              	.LVL179:
1079:../drivers/fsl_clock.c ****     uint32_t irefst = MCG_S_IREFST_VAL;
 2273              		.loc 1 1079 0
 2274 0004 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
1080:../drivers/fsl_clock.c ****     uint32_t lp = MCG_C2_LP_VAL;
 2275              		.loc 1 1080 0
 2276 0006 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
1081:../drivers/fsl_clock.c ****     uint32_t pllst = MCG_S_PLLST_VAL;
 2277              		.loc 1 1081 0
 2278 0008 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
1078:../drivers/fsl_clock.c ****     uint32_t irefst = MCG_S_IREFST_VAL;
 2279              		.loc 1 1078 0
 2280 000a C3F38103 		ubfx	r3, r3, #2, #2
 2281              	.LVL180:
1082:../drivers/fsl_clock.c **** 
1083:../drivers/fsl_clock.c ****     /*------------------------------------------------------------------
1084:../drivers/fsl_clock.c ****                            Mode and Registers
1085:../drivers/fsl_clock.c ****     ____________________________________________________________________
1086:../drivers/fsl_clock.c **** 
1087:../drivers/fsl_clock.c ****       Mode   |   CLKST    |   IREFST   |   PLLST   |      LP
1088:../drivers/fsl_clock.c ****     ____________________________________________________________________
1089:../drivers/fsl_clock.c **** 
1090:../drivers/fsl_clock.c ****       FEI    |  00(FLL)   |   1(INT)   |   0(FLL)  |      X
1091:../drivers/fsl_clock.c ****     ____________________________________________________________________
1092:../drivers/fsl_clock.c **** 
1093:../drivers/fsl_clock.c ****       FEE    |  00(FLL)   |   0(EXT)   |   0(FLL)  |      X
1094:../drivers/fsl_clock.c ****     ____________________________________________________________________
1095:../drivers/fsl_clock.c **** 
1096:../drivers/fsl_clock.c ****       FBE    |  10(EXT)   |   0(EXT)   |   0(FLL)  |   0(NORMAL)
1097:../drivers/fsl_clock.c ****     ____________________________________________________________________
1098:../drivers/fsl_clock.c **** 
1099:../drivers/fsl_clock.c ****       FBI    |  01(INT)   |   1(INT)   |   0(FLL)  |   0(NORMAL)
1100:../drivers/fsl_clock.c ****     ____________________________________________________________________
1101:../drivers/fsl_clock.c **** 
1102:../drivers/fsl_clock.c ****       BLPI   |  01(INT)   |   1(INT)   |   0(FLL)  |   1(LOW POWER)
1103:../drivers/fsl_clock.c ****     ____________________________________________________________________
1104:../drivers/fsl_clock.c **** 
1105:../drivers/fsl_clock.c ****       BLPE   |  10(EXT)   |   0(EXT)   |     X     |   1(LOW POWER)
1106:../drivers/fsl_clock.c ****     ____________________________________________________________________
1107:../drivers/fsl_clock.c **** 
1108:../drivers/fsl_clock.c ****       PEE    |  11(PLL)   |   0(EXT)   |   1(PLL)  |      X
1109:../drivers/fsl_clock.c ****     ____________________________________________________________________
1110:../drivers/fsl_clock.c **** 
1111:../drivers/fsl_clock.c ****       PBE    |  10(EXT)   |   0(EXT)   |   1(PLL)  |   O(NORMAL)
1112:../drivers/fsl_clock.c ****     ____________________________________________________________________
1113:../drivers/fsl_clock.c **** 
1114:../drivers/fsl_clock.c ****       PBI    |  01(INT)   |   1(INT)   |   1(PLL)  |   0(NORMAL)
1115:../drivers/fsl_clock.c ****     ____________________________________________________________________
1116:../drivers/fsl_clock.c **** 
1117:../drivers/fsl_clock.c ****       PEI    |  11(PLL)   |   1(INT)   |   1(PLL)  |      X
1118:../drivers/fsl_clock.c ****     ____________________________________________________________________
1119:../drivers/fsl_clock.c **** 
1120:../drivers/fsl_clock.c ****     ----------------------------------------------------------------------*/
1121:../drivers/fsl_clock.c **** 
1122:../drivers/fsl_clock.c ****     switch (clkst)
 2282              		.loc 1 1122 0
 2283 000e 022B     		cmp	r3, #2
1079:../drivers/fsl_clock.c ****     uint32_t lp = MCG_C2_LP_VAL;
 2284              		.loc 1 1079 0
 2285 0010 C0B2     		uxtb	r0, r0
 2286              	.LVL181:
1080:../drivers/fsl_clock.c ****     uint32_t pllst = MCG_S_PLLST_VAL;
 2287              		.loc 1 1080 0
 2288 0012 C2F34002 		ubfx	r2, r2, #1, #1
 2289              	.LVL182:
1081:../drivers/fsl_clock.c **** 
 2290              		.loc 1 1081 0
 2291 0016 C9B2     		uxtb	r1, r1
 2292              	.LVL183:
 2293              		.loc 1 1122 0
 2294 0018 0ED0     		beq	.L291
 2295 001a 032B     		cmp	r3, #3
 2296 001c 13D0     		beq	.L294
 2297 001e 012B     		cmp	r3, #1
 2298 0020 05D0     		beq	.L293
1123:../drivers/fsl_clock.c ****     {
1124:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatFll:
1125:../drivers/fsl_clock.c ****             if (kMCG_FllSrcExternal == irefst)
 2299              		.loc 1 1125 0
 2300 0022 10F0100F 		tst	r0, #16
1126:../drivers/fsl_clock.c ****             {
1127:../drivers/fsl_clock.c ****                 mode = kMCG_ModeFEE;
1128:../drivers/fsl_clock.c ****             }
1129:../drivers/fsl_clock.c ****             else
1130:../drivers/fsl_clock.c ****             {
1131:../drivers/fsl_clock.c ****                 mode = kMCG_ModeFEI;
 2301              		.loc 1 1131 0
 2302 0026 0CBF     		ite	eq
 2303 0028 0320     		moveq	r0, #3
 2304              	.LVL184:
 2305 002a 0020     		movne	r0, #0
 2306 002c 7047     		bx	lr
 2307              	.LVL185:
 2308              	.L293:
1132:../drivers/fsl_clock.c ****             }
1133:../drivers/fsl_clock.c ****             break;
1134:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
1135:../drivers/fsl_clock.c ****             if (lp)
 2309              		.loc 1 1135 0
 2310 002e 002A     		cmp	r2, #0
1136:../drivers/fsl_clock.c ****             {
1137:../drivers/fsl_clock.c ****                 mode = kMCG_ModeBLPI;
1138:../drivers/fsl_clock.c ****             }
1139:../drivers/fsl_clock.c ****             else
1140:../drivers/fsl_clock.c ****             {
1141:../drivers/fsl_clock.c ****                 {
1142:../drivers/fsl_clock.c ****                     mode = kMCG_ModeFBI;
 2311              		.loc 1 1142 0
 2312 0030 14BF     		ite	ne
 2313 0032 0220     		movne	r0, #2
 2314              	.LVL186:
 2315 0034 0120     		moveq	r0, #1
 2316 0036 7047     		bx	lr
 2317              	.LVL187:
 2318              	.L291:
1143:../drivers/fsl_clock.c ****                 }
1144:../drivers/fsl_clock.c ****             }
1145:../drivers/fsl_clock.c ****             break;
1146:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
1147:../drivers/fsl_clock.c ****             if (lp)
 2319              		.loc 1 1147 0
 2320 0038 3AB9     		cbnz	r2, .L297
1148:../drivers/fsl_clock.c ****             {
1149:../drivers/fsl_clock.c ****                 mode = kMCG_ModeBLPE;
1150:../drivers/fsl_clock.c ****             }
1151:../drivers/fsl_clock.c ****             else
1152:../drivers/fsl_clock.c ****             {
1153:../drivers/fsl_clock.c ****                 if (kMCG_PllstPll == pllst)
 2321              		.loc 1 1153 0
 2322 003a 11F0200F 		tst	r1, #32
1154:../drivers/fsl_clock.c ****                 {
1155:../drivers/fsl_clock.c ****                     mode = kMCG_ModePBE;
1156:../drivers/fsl_clock.c ****                 }
1157:../drivers/fsl_clock.c ****                 else
1158:../drivers/fsl_clock.c ****                 {
1159:../drivers/fsl_clock.c ****                     mode = kMCG_ModeFBE;
 2323              		.loc 1 1159 0
 2324 003e 14BF     		ite	ne
 2325 0040 0620     		movne	r0, #6
 2326              	.LVL188:
 2327 0042 0420     		moveq	r0, #4
 2328 0044 7047     		bx	lr
 2329              	.LVL189:
 2330              	.L294:
1160:../drivers/fsl_clock.c ****                 }
1161:../drivers/fsl_clock.c ****             }
1162:../drivers/fsl_clock.c ****             break;
1163:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
1164:../drivers/fsl_clock.c ****         {
1165:../drivers/fsl_clock.c ****             mode = kMCG_ModePEE;
 2331              		.loc 1 1165 0
 2332 0046 0720     		movs	r0, #7
 2333              	.LVL190:
 2334 0048 7047     		bx	lr
 2335              	.LVL191:
 2336              	.L297:
1149:../drivers/fsl_clock.c ****             }
 2337              		.loc 1 1149 0
 2338 004a 0520     		movs	r0, #5
 2339              	.LVL192:
1166:../drivers/fsl_clock.c ****         }
1167:../drivers/fsl_clock.c ****         break;
1168:../drivers/fsl_clock.c ****         default:
1169:../drivers/fsl_clock.c ****             break;
1170:../drivers/fsl_clock.c ****     }
1171:../drivers/fsl_clock.c **** 
1172:../drivers/fsl_clock.c ****     return mode;
1173:../drivers/fsl_clock.c **** }
 2340              		.loc 1 1173 0
 2341 004c 7047     		bx	lr
 2342              	.L300:
 2343 004e 00BF     		.align	2
 2344              	.L299:
 2345 0050 00400640 		.word	1074151424
 2346              		.cfi_endproc
 2347              	.LFE182:
 2349              		.section	.text.CLOCK_SetFeiMode,"ax",%progbits
 2350              		.align	1
 2351              		.global	CLOCK_SetFeiMode
 2352              		.syntax unified
 2353              		.thumb
 2354              		.thumb_func
 2355              		.fpu fpv4-sp-d16
 2357              	CLOCK_SetFeiMode:
 2358              	.LFB183:
1174:../drivers/fsl_clock.c **** 
1175:../drivers/fsl_clock.c **** status_t CLOCK_SetFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1176:../drivers/fsl_clock.c **** {
 2359              		.loc 1 1176 0
 2360              		.cfi_startproc
 2361              		@ args = 0, pretend = 0, frame = 0
 2362              		@ frame_needed = 0, uses_anonymous_args = 0
 2363              	.LVL193:
 2364 0000 70B5     		push	{r4, r5, r6, lr}
 2365              		.cfi_def_cfa_offset 16
 2366              		.cfi_offset 4, -16
 2367              		.cfi_offset 5, -12
 2368              		.cfi_offset 6, -8
 2369              		.cfi_offset 14, -4
1177:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1178:../drivers/fsl_clock.c ****     bool change_drs = false;
1179:../drivers/fsl_clock.c **** 
1180:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1181:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1182:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEI == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1183:../drivers/fsl_clock.c ****     {
1184:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1185:../drivers/fsl_clock.c ****     }
1186:../drivers/fsl_clock.c **** #endif
1187:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2370              		.loc 1 1187 0
 2371 0002 164B     		ldr	r3, .L317
 2372 0004 DC78     		ldrb	r4, [r3, #3]	@ zero_extendqisi2
1188:../drivers/fsl_clock.c **** 
1189:../drivers/fsl_clock.c ****     /*
1190:../drivers/fsl_clock.c ****        Errata: ERR007993
1191:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1192:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1193:../drivers/fsl_clock.c ****        reference clock changes.
1194:../drivers/fsl_clock.c ****      */
1195:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 2373              		.loc 1 1195 0
 2374 0006 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 2375 0008 EE06     		lsls	r6, r5, #27
1196:../drivers/fsl_clock.c ****     {
1197:../drivers/fsl_clock.c ****         change_drs = true;
1198:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1199:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2376              		.loc 1 1199 0
 2377 000a 5EBF     		ittt	pl
 2378 000c DD78     		ldrbpl	r5, [r3, #3]	@ zero_extendqisi2
 2379 000e 85F02005 		eorpl	r5, r5, #32
 2380 0012 DD70     		strbpl	r5, [r3, #3]
1200:../drivers/fsl_clock.c ****     }
1201:../drivers/fsl_clock.c **** 
1202:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1203:../drivers/fsl_clock.c ****     MCG->C1 =
1204:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 2381              		.loc 1 1204 0
 2382 0014 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 2383 0016 05F03B05 		and	r5, r5, #59
 2384 001a 45F00405 		orr	r5, r5, #4
1203:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 2385              		.loc 1 1203 0
 2386 001e 1D70     		strb	r5, [r3]
1205:../drivers/fsl_clock.c ****                                                                  | MCG_C1_IREFS(kMCG_FllSrcInternal
1206:../drivers/fsl_clock.c **** 
1207:../drivers/fsl_clock.c ****     /* Wait and check status. */
1208:../drivers/fsl_clock.c ****     while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
 2387              		.loc 1 1208 0
 2388 0020 0E4B     		ldr	r3, .L317
1187:../drivers/fsl_clock.c **** 
 2389              		.loc 1 1187 0
 2390 0022 E4B2     		uxtb	r4, r4
 2391              	.LVL194:
1197:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2392              		.loc 1 1197 0
 2393 0024 54BF     		ite	pl
 2394 0026 0126     		movpl	r6, #1
1178:../drivers/fsl_clock.c **** 
 2395              		.loc 1 1178 0
 2396 0028 0026     		movmi	r6, #0
 2397              	.LVL195:
 2398              	.L303:
 2399              		.loc 1 1208 0 discriminator 1
 2400 002a 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 2401 002c ED06     		lsls	r5, r5, #27
 2402 002e FCD5     		bpl	.L303
1209:../drivers/fsl_clock.c ****     {
1210:../drivers/fsl_clock.c ****     }
1211:../drivers/fsl_clock.c **** 
1212:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1213:../drivers/fsl_clock.c ****     if (change_drs)
 2403              		.loc 1 1213 0
 2404 0030 06B1     		cbz	r6, .L304
1214:../drivers/fsl_clock.c ****     {
1215:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2405              		.loc 1 1215 0
 2406 0032 DC70     		strb	r4, [r3, #3]
 2407              	.L304:
1216:../drivers/fsl_clock.c ****     }
1217:../drivers/fsl_clock.c **** 
1218:../drivers/fsl_clock.c ****     /* In FEI mode, the MCG_C4[DMX32] is set to 0U. */
1219:../drivers/fsl_clock.c ****     MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 2408              		.loc 1 1219 0
 2409 0034 4901     		lsls	r1, r1, #5
 2410              	.LVL196:
 2411 0036 01F06001 		and	r1, r1, #96
 2412 003a 41EAC010 		orr	r0, r1, r0, lsl #7
 2413              	.LVL197:
 2414 003e 04F01F04 		and	r4, r4, #31
 2415              	.LVL198:
 2416 0042 2043     		orrs	r0, r0, r4
 2417 0044 054B     		ldr	r3, .L317
 2418 0046 C0B2     		uxtb	r0, r0
 2419 0048 D870     		strb	r0, [r3, #3]
 2420              	.L305:
1220:../drivers/fsl_clock.c **** 
1221:../drivers/fsl_clock.c ****     /* Check MCG_S[CLKST] */
1222:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
 2421              		.loc 1 1222 0 discriminator 1
 2422 004a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 2423 004c 11F00C0F 		tst	r1, #12
 2424 0050 FBD1     		bne	.L305
1223:../drivers/fsl_clock.c ****     {
1224:../drivers/fsl_clock.c ****     }
1225:../drivers/fsl_clock.c **** 
1226:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1227:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2425              		.loc 1 1227 0
 2426 0052 02B1     		cbz	r2, .L306
1228:../drivers/fsl_clock.c ****     {
1229:../drivers/fsl_clock.c ****         fllStableDelay();
 2427              		.loc 1 1229 0
 2428 0054 9047     		blx	r2
 2429              	.LVL199:
 2430              	.L306:
1230:../drivers/fsl_clock.c ****     }
1231:../drivers/fsl_clock.c **** 
1232:../drivers/fsl_clock.c ****     return kStatus_Success;
1233:../drivers/fsl_clock.c **** }
 2431              		.loc 1 1233 0
 2432 0056 0020     		movs	r0, #0
 2433 0058 70BD     		pop	{r4, r5, r6, pc}
 2434              	.LVL200:
 2435              	.L318:
 2436 005a 00BF     		.align	2
 2437              	.L317:
 2438 005c 00400640 		.word	1074151424
 2439              		.cfi_endproc
 2440              	.LFE183:
 2442              		.section	.text.CLOCK_SetFeeMode,"ax",%progbits
 2443              		.align	1
 2444              		.global	CLOCK_SetFeeMode
 2445              		.syntax unified
 2446              		.thumb
 2447              		.thumb_func
 2448              		.fpu fpv4-sp-d16
 2450              	CLOCK_SetFeeMode:
 2451              	.LFB184:
1234:../drivers/fsl_clock.c **** 
1235:../drivers/fsl_clock.c **** status_t CLOCK_SetFeeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(v
1236:../drivers/fsl_clock.c **** {
 2452              		.loc 1 1236 0
 2453              		.cfi_startproc
 2454              		@ args = 0, pretend = 0, frame = 0
 2455              		@ frame_needed = 0, uses_anonymous_args = 0
 2456              	.LVL201:
 2457 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2458              		.cfi_def_cfa_offset 24
 2459              		.cfi_offset 3, -24
 2460              		.cfi_offset 4, -20
 2461              		.cfi_offset 5, -16
 2462              		.cfi_offset 6, -12
 2463              		.cfi_offset 7, -8
 2464              		.cfi_offset 14, -4
1237:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1238:../drivers/fsl_clock.c ****     bool change_drs = false;
1239:../drivers/fsl_clock.c **** 
1240:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1241:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1242:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1243:../drivers/fsl_clock.c ****     {
1244:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1245:../drivers/fsl_clock.c ****     }
1246:../drivers/fsl_clock.c **** #endif
1247:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2465              		.loc 1 1247 0
 2466 0002 1D4C     		ldr	r4, .L342
 2467 0004 E578     		ldrb	r5, [r4, #3]	@ zero_extendqisi2
1248:../drivers/fsl_clock.c **** 
1249:../drivers/fsl_clock.c ****     /*
1250:../drivers/fsl_clock.c ****        Errata: ERR007993
1251:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1252:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1253:../drivers/fsl_clock.c ****        reference clock changes.
1254:../drivers/fsl_clock.c ****      */
1255:../drivers/fsl_clock.c ****     if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
 2468              		.loc 1 1255 0
 2469 0006 A679     		ldrb	r6, [r4, #6]	@ zero_extendqisi2
 2470 0008 C6F30016 		ubfx	r6, r6, #4, #1
1247:../drivers/fsl_clock.c **** 
 2471              		.loc 1 1247 0
 2472 000c EDB2     		uxtb	r5, r5
 2473              	.LVL202:
 2474              		.loc 1 1255 0
 2475 000e 26B1     		cbz	r6, .L320
 2476              	.LVL203:
1256:../drivers/fsl_clock.c ****     {
1257:../drivers/fsl_clock.c ****         change_drs = true;
1258:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1259:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2477              		.loc 1 1259 0
 2478 0010 E678     		ldrb	r6, [r4, #3]	@ zero_extendqisi2
 2479 0012 86F02006 		eor	r6, r6, #32
 2480 0016 E670     		strb	r6, [r4, #3]
1257:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2481              		.loc 1 1257 0
 2482 0018 0126     		movs	r6, #1
 2483              	.LVL204:
 2484              	.L320:
1260:../drivers/fsl_clock.c ****     }
1261:../drivers/fsl_clock.c **** 
1262:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1263:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
 2485              		.loc 1 1263 0
 2486 001a 2778     		ldrb	r7, [r4]	@ zero_extendqisi2
1264:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
1265:../drivers/fsl_clock.c ****                 | MCG_C1_FRDIV(frdiv)                  /* FRDIV */
 2487              		.loc 1 1265 0
 2488 001c C000     		lsls	r0, r0, #3
 2489              	.LVL205:
1263:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 2490              		.loc 1 1263 0
 2491 001e 07F00307 		and	r7, r7, #3
1266:../drivers/fsl_clock.c ****                 | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
 2492              		.loc 1 1266 0
 2493 0022 00F03800 		and	r0, r0, #56
1263:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 2494              		.loc 1 1263 0
 2495 0026 3843     		orrs	r0, r0, r7
 2496 0028 2070     		strb	r0, [r4]
1267:../drivers/fsl_clock.c **** 
1268:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1269:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
 2497              		.loc 1 1269 0
 2498 002a 207B     		ldrb	r0, [r4, #12]	@ zero_extendqisi2
 2499 002c 8707     		lsls	r7, r0, #30
 2500 002e 06D1     		bne	.L321
1270:../drivers/fsl_clock.c ****     {
1271:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 2501              		.loc 1 1271 0
 2502 0030 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 2503 0032 4007     		lsls	r0, r0, #29
 2504 0034 03D5     		bpl	.L321
1272:../drivers/fsl_clock.c ****         {
1273:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 2505              		.loc 1 1273 0
 2506 0036 104C     		ldr	r4, .L342
 2507              	.L322:
 2508              		.loc 1 1273 0 is_stmt 0 discriminator 1
 2509 0038 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 2510 003a 8707     		lsls	r7, r0, #30
 2511 003c FCD5     		bpl	.L322
 2512              	.L321:
1274:../drivers/fsl_clock.c ****             {
1275:../drivers/fsl_clock.c ****             }
1276:../drivers/fsl_clock.c ****         }
1277:../drivers/fsl_clock.c ****     }
1278:../drivers/fsl_clock.c **** 
1279:../drivers/fsl_clock.c ****     /* Wait and check status. */
1280:../drivers/fsl_clock.c ****     while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
 2513              		.loc 1 1280 0 is_stmt 1 discriminator 1
 2514 003e 0E48     		ldr	r0, .L342
 2515              	.L334:
 2516 0040 8479     		ldrb	r4, [r0, #6]	@ zero_extendqisi2
 2517 0042 E406     		lsls	r4, r4, #27
 2518 0044 FCD4     		bmi	.L334
1281:../drivers/fsl_clock.c ****     {
1282:../drivers/fsl_clock.c ****     }
1283:../drivers/fsl_clock.c **** 
1284:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1285:../drivers/fsl_clock.c ****     if (change_drs)
 2519              		.loc 1 1285 0
 2520 0046 06B1     		cbz	r6, .L323
1286:../drivers/fsl_clock.c ****     {
1287:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2521              		.loc 1 1287 0
 2522 0048 C570     		strb	r5, [r0, #3]
 2523              	.L323:
1288:../drivers/fsl_clock.c ****     }
1289:../drivers/fsl_clock.c **** 
1290:../drivers/fsl_clock.c ****     /* Set DRS and DMX32. */
1291:../drivers/fsl_clock.c ****     mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 2524              		.loc 1 1291 0
 2525 004a 5201     		lsls	r2, r2, #5
 2526              	.LVL206:
 2527 004c 02F06002 		and	r2, r2, #96
 2528 0050 42EAC111 		orr	r1, r2, r1, lsl #7
 2529              	.LVL207:
 2530 0054 05F01F05 		and	r5, r5, #31
 2531              	.LVL208:
 2532 0058 2943     		orrs	r1, r1, r5
1292:../drivers/fsl_clock.c ****     MCG->C4 = mcg_c4;
 2533              		.loc 1 1292 0
 2534 005a 074A     		ldr	r2, .L342
1291:../drivers/fsl_clock.c ****     MCG->C4 = mcg_c4;
 2535              		.loc 1 1291 0
 2536 005c C9B2     		uxtb	r1, r1
 2537              	.LVL209:
 2538              		.loc 1 1292 0
 2539 005e D170     		strb	r1, [r2, #3]
 2540              	.L324:
1293:../drivers/fsl_clock.c **** 
1294:../drivers/fsl_clock.c ****     /* Wait for DRST_DRS update. */
1295:../drivers/fsl_clock.c ****     while (MCG->C4 != mcg_c4)
 2541              		.loc 1 1295 0 discriminator 1
 2542 0060 D078     		ldrb	r0, [r2, #3]	@ zero_extendqisi2
 2543 0062 8842     		cmp	r0, r1
 2544 0064 FCD1     		bne	.L324
 2545              	.LVL210:
 2546              	.L325:
1296:../drivers/fsl_clock.c ****     {
1297:../drivers/fsl_clock.c ****     }
1298:../drivers/fsl_clock.c **** 
1299:../drivers/fsl_clock.c ****     /* Check MCG_S[CLKST] */
1300:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
 2547              		.loc 1 1300 0 discriminator 1
 2548 0066 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2549 0068 11F00C0F 		tst	r1, #12
 2550 006c FBD1     		bne	.L325
1301:../drivers/fsl_clock.c ****     {
1302:../drivers/fsl_clock.c ****     }
1303:../drivers/fsl_clock.c **** 
1304:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1305:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2551              		.loc 1 1305 0
 2552 006e 03B1     		cbz	r3, .L326
1306:../drivers/fsl_clock.c ****     {
1307:../drivers/fsl_clock.c ****         fllStableDelay();
 2553              		.loc 1 1307 0
 2554 0070 9847     		blx	r3
 2555              	.LVL211:
 2556              	.L326:
1308:../drivers/fsl_clock.c ****     }
1309:../drivers/fsl_clock.c **** 
1310:../drivers/fsl_clock.c ****     return kStatus_Success;
1311:../drivers/fsl_clock.c **** }
 2557              		.loc 1 1311 0
 2558 0072 0020     		movs	r0, #0
 2559 0074 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2560              	.LVL212:
 2561              	.L343:
 2562 0076 00BF     		.align	2
 2563              	.L342:
 2564 0078 00400640 		.word	1074151424
 2565              		.cfi_endproc
 2566              	.LFE184:
 2568              		.section	.text.CLOCK_SetFbiMode,"ax",%progbits
 2569              		.align	1
 2570              		.global	CLOCK_SetFbiMode
 2571              		.syntax unified
 2572              		.thumb
 2573              		.thumb_func
 2574              		.fpu fpv4-sp-d16
 2576              	CLOCK_SetFbiMode:
 2577              	.LFB185:
1312:../drivers/fsl_clock.c **** 
1313:../drivers/fsl_clock.c **** status_t CLOCK_SetFbiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1314:../drivers/fsl_clock.c **** {
 2578              		.loc 1 1314 0
 2579              		.cfi_startproc
 2580              		@ args = 0, pretend = 0, frame = 0
 2581              		@ frame_needed = 0, uses_anonymous_args = 0
 2582              	.LVL213:
 2583 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2584              		.cfi_def_cfa_offset 24
 2585              		.cfi_offset 3, -24
 2586              		.cfi_offset 4, -20
 2587              		.cfi_offset 5, -16
 2588              		.cfi_offset 6, -12
 2589              		.cfi_offset 7, -8
 2590              		.cfi_offset 14, -4
1315:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1316:../drivers/fsl_clock.c ****     bool change_drs = false;
1317:../drivers/fsl_clock.c **** 
1318:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1319:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1320:../drivers/fsl_clock.c **** 
1321:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1322:../drivers/fsl_clock.c ****           (kMCG_ModeBLPI == mode)))
1323:../drivers/fsl_clock.c **** 
1324:../drivers/fsl_clock.c ****     {
1325:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1326:../drivers/fsl_clock.c ****     }
1327:../drivers/fsl_clock.c **** #endif
1328:../drivers/fsl_clock.c **** 
1329:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2591              		.loc 1 1329 0
 2592 0002 184B     		ldr	r3, .L360
 2593 0004 DC78     		ldrb	r4, [r3, #3]	@ zero_extendqisi2
1330:../drivers/fsl_clock.c **** 
1331:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 2594              		.loc 1 1331 0
 2595 0006 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
 2596 0008 05F0FD05 		and	r5, r5, #253
 2597 000c 5D70     		strb	r5, [r3, #1]
1332:../drivers/fsl_clock.c **** 
1333:../drivers/fsl_clock.c ****     /*
1334:../drivers/fsl_clock.c ****        Errata: ERR007993
1335:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1336:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1337:../drivers/fsl_clock.c ****        reference clock changes.
1338:../drivers/fsl_clock.c ****      */
1339:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 2598              		.loc 1 1339 0
 2599 000e 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 2600 0010 ED06     		lsls	r5, r5, #27
1340:../drivers/fsl_clock.c ****     {
1341:../drivers/fsl_clock.c ****         change_drs = true;
1342:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1343:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2601              		.loc 1 1343 0
 2602 0012 5EBF     		ittt	pl
 2603 0014 DD78     		ldrbpl	r5, [r3, #3]	@ zero_extendqisi2
 2604 0016 85F02005 		eorpl	r5, r5, #32
 2605 001a DD70     		strbpl	r5, [r3, #3]
1344:../drivers/fsl_clock.c ****     }
1345:../drivers/fsl_clock.c **** 
1346:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1347:../drivers/fsl_clock.c ****     MCG->C1 =
1348:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 2606              		.loc 1 1348 0
 2607 001c 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 2608 001e 05F03B05 		and	r5, r5, #59
 2609 0022 45F04405 		orr	r5, r5, #68
1347:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 2610              		.loc 1 1347 0
 2611 0026 1D70     		strb	r5, [r3]
1349:../drivers/fsl_clock.c ****                                                                 | MCG_C1_IREFS(kMCG_FllSrcInternal)
1350:../drivers/fsl_clock.c **** 
1351:../drivers/fsl_clock.c ****     /* Wait and check status. */
1352:../drivers/fsl_clock.c ****     while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
 2612              		.loc 1 1352 0
 2613 0028 0E4B     		ldr	r3, .L360
1329:../drivers/fsl_clock.c **** 
 2614              		.loc 1 1329 0
 2615 002a E4B2     		uxtb	r4, r4
 2616              	.LVL214:
1341:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2617              		.loc 1 1341 0
 2618 002c 54BF     		ite	pl
 2619 002e 0126     		movpl	r6, #1
1316:../drivers/fsl_clock.c **** 
 2620              		.loc 1 1316 0
 2621 0030 0026     		movmi	r6, #0
 2622              	.LVL215:
 2623 0032 1D46     		mov	r5, r3
 2624              	.L346:
 2625              		.loc 1 1352 0 discriminator 1
 2626 0034 9F79     		ldrb	r7, [r3, #6]	@ zero_extendqisi2
 2627 0036 FF06     		lsls	r7, r7, #27
 2628 0038 FCD5     		bpl	.L346
1353:../drivers/fsl_clock.c ****     {
1354:../drivers/fsl_clock.c ****     }
1355:../drivers/fsl_clock.c **** 
1356:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1357:../drivers/fsl_clock.c ****     if (change_drs)
 2629              		.loc 1 1357 0
 2630 003a 06B1     		cbz	r6, .L348
1358:../drivers/fsl_clock.c ****     {
1359:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2631              		.loc 1 1359 0
 2632 003c DC70     		strb	r4, [r3, #3]
 2633              	.L348:
1360:../drivers/fsl_clock.c ****     }
1361:../drivers/fsl_clock.c **** 
1362:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatInt != MCG_S_CLKST_VAL)
 2634              		.loc 1 1362 0 discriminator 1
 2635 003e AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 2636 0040 C3F38103 		ubfx	r3, r3, #2, #2
 2637 0044 012B     		cmp	r3, #1
 2638 0046 FAD1     		bne	.L348
1363:../drivers/fsl_clock.c ****     {
1364:../drivers/fsl_clock.c ****     }
1365:../drivers/fsl_clock.c **** 
1366:../drivers/fsl_clock.c ****     MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 2639              		.loc 1 1366 0
 2640 0048 4901     		lsls	r1, r1, #5
 2641              	.LVL216:
 2642 004a 01F06001 		and	r1, r1, #96
 2643 004e 41EAC010 		orr	r0, r1, r0, lsl #7
 2644              	.LVL217:
 2645 0052 04F01F04 		and	r4, r4, #31
 2646              	.LVL218:
 2647 0056 2043     		orrs	r0, r0, r4
 2648 0058 C0B2     		uxtb	r0, r0
 2649 005a E870     		strb	r0, [r5, #3]
1367:../drivers/fsl_clock.c **** 
1368:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1369:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2650              		.loc 1 1369 0
 2651 005c 02B1     		cbz	r2, .L349
1370:../drivers/fsl_clock.c ****     {
1371:../drivers/fsl_clock.c ****         fllStableDelay();
 2652              		.loc 1 1371 0
 2653 005e 9047     		blx	r2
 2654              	.LVL219:
 2655              	.L349:
1372:../drivers/fsl_clock.c ****     }
1373:../drivers/fsl_clock.c **** 
1374:../drivers/fsl_clock.c ****     return kStatus_Success;
1375:../drivers/fsl_clock.c **** }
 2656              		.loc 1 1375 0
 2657 0060 0020     		movs	r0, #0
 2658 0062 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2659              	.LVL220:
 2660              	.L361:
 2661              		.align	2
 2662              	.L360:
 2663 0064 00400640 		.word	1074151424
 2664              		.cfi_endproc
 2665              	.LFE185:
 2667              		.section	.text.CLOCK_SetFbeMode,"ax",%progbits
 2668              		.align	1
 2669              		.global	CLOCK_SetFbeMode
 2670              		.syntax unified
 2671              		.thumb
 2672              		.thumb_func
 2673              		.fpu fpv4-sp-d16
 2675              	CLOCK_SetFbeMode:
 2676              	.LFB186:
1376:../drivers/fsl_clock.c **** 
1377:../drivers/fsl_clock.c **** status_t CLOCK_SetFbeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(v
1378:../drivers/fsl_clock.c **** {
 2677              		.loc 1 1378 0
 2678              		.cfi_startproc
 2679              		@ args = 0, pretend = 0, frame = 0
 2680              		@ frame_needed = 0, uses_anonymous_args = 0
 2681              	.LVL221:
 2682 0000 70B5     		push	{r4, r5, r6, lr}
 2683              		.cfi_def_cfa_offset 16
 2684              		.cfi_offset 4, -16
 2685              		.cfi_offset 5, -12
 2686              		.cfi_offset 6, -8
 2687              		.cfi_offset 14, -4
1379:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1380:../drivers/fsl_clock.c ****     bool change_drs = false;
1381:../drivers/fsl_clock.c **** 
1382:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1383:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1384:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1385:../drivers/fsl_clock.c ****           (kMCG_ModePBE == mode) || (kMCG_ModeBLPE == mode)))
1386:../drivers/fsl_clock.c ****     {
1387:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1388:../drivers/fsl_clock.c ****     }
1389:../drivers/fsl_clock.c **** #endif
1390:../drivers/fsl_clock.c **** 
1391:../drivers/fsl_clock.c ****     /* Change to FLL mode. */
1392:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 2688              		.loc 1 1392 0
 2689 0002 1E4A     		ldr	r2, .L385
 2690              	.LVL222:
 2691 0004 5179     		ldrb	r1, [r2, #5]	@ zero_extendqisi2
 2692              	.LVL223:
 2693 0006 01F0BF01 		and	r1, r1, #191
 2694 000a 5171     		strb	r1, [r2, #5]
 2695              	.L363:
1393:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2696              		.loc 1 1393 0 discriminator 1
 2697 000c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2698 000e 8D06     		lsls	r5, r1, #26
 2699 0010 FCD4     		bmi	.L363
1394:../drivers/fsl_clock.c ****     {
1395:../drivers/fsl_clock.c ****     }
1396:../drivers/fsl_clock.c **** 
1397:../drivers/fsl_clock.c ****     /* Set LP bit to enable the FLL */
1398:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 2700              		.loc 1 1398 0
 2701 0012 5178     		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 2702 0014 01F0FD01 		and	r1, r1, #253
 2703 0018 5170     		strb	r1, [r2, #1]
1399:../drivers/fsl_clock.c **** 
1400:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 2704              		.loc 1 1400 0
 2705 001a D678     		ldrb	r6, [r2, #3]	@ zero_extendqisi2
1401:../drivers/fsl_clock.c **** 
1402:../drivers/fsl_clock.c ****     /*
1403:../drivers/fsl_clock.c ****        Errata: ERR007993
1404:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1405:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1406:../drivers/fsl_clock.c ****        reference clock changes.
1407:../drivers/fsl_clock.c ****      */
1408:../drivers/fsl_clock.c ****     if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
 2706              		.loc 1 1408 0
 2707 001c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2708 001e C1F30011 		ubfx	r1, r1, #4, #1
1400:../drivers/fsl_clock.c **** 
 2709              		.loc 1 1400 0
 2710 0022 F6B2     		uxtb	r6, r6
 2711              	.LVL224:
 2712              		.loc 1 1408 0
 2713 0024 41B3     		cbz	r1, .L370
 2714              	.LVL225:
1409:../drivers/fsl_clock.c ****     {
1410:../drivers/fsl_clock.c ****         change_drs = true;
1411:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1412:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 2715              		.loc 1 1412 0
 2716 0026 D178     		ldrb	r1, [r2, #3]	@ zero_extendqisi2
 2717 0028 81F02001 		eor	r1, r1, #32
 2718 002c D170     		strb	r1, [r2, #3]
1410:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
 2719              		.loc 1 1410 0
 2720 002e 0122     		movs	r2, #1
 2721              	.LVL226:
 2722              	.L364:
1413:../drivers/fsl_clock.c ****     }
1414:../drivers/fsl_clock.c **** 
1415:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1416:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
 2723              		.loc 1 1416 0
 2724 0030 1249     		ldr	r1, .L385
 2725 0032 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
1417:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
1418:../drivers/fsl_clock.c ****                 | MCG_C1_FRDIV(frdiv)                  /* FRDIV = frdiv */
 2726              		.loc 1 1418 0
 2727 0034 C000     		lsls	r0, r0, #3
 2728              	.LVL227:
 2729 0036 00F03805 		and	r5, r0, #56
1416:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
 2730              		.loc 1 1416 0
 2731 003a 04F00300 		and	r0, r4, #3
 2732 003e 2843     		orrs	r0, r0, r5
 2733 0040 40F08000 		orr	r0, r0, #128
 2734 0044 0870     		strb	r0, [r1]
1419:../drivers/fsl_clock.c ****                 | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
1420:../drivers/fsl_clock.c **** 
1421:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1422:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
 2735              		.loc 1 1422 0
 2736 0046 087B     		ldrb	r0, [r1, #12]	@ zero_extendqisi2
 2737 0048 8407     		lsls	r4, r0, #30
 2738 004a 05D1     		bne	.L365
1423:../drivers/fsl_clock.c ****     {
1424:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 2739              		.loc 1 1424 0
 2740 004c 4878     		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 2741 004e 4007     		lsls	r0, r0, #29
 2742 0050 02D5     		bpl	.L365
 2743              	.L366:
1425:../drivers/fsl_clock.c ****         {
1426:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 2744              		.loc 1 1426 0 discriminator 1
 2745 0052 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
 2746 0054 8507     		lsls	r5, r0, #30
 2747 0056 FCD5     		bpl	.L366
 2748              	.L365:
1427:../drivers/fsl_clock.c ****             {
1428:../drivers/fsl_clock.c ****             }
1429:../drivers/fsl_clock.c ****         }
1430:../drivers/fsl_clock.c ****     }
1431:../drivers/fsl_clock.c **** 
1432:../drivers/fsl_clock.c ****     /* Wait for Reference clock Status bit to clear */
1433:../drivers/fsl_clock.c ****     while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
 2749              		.loc 1 1433 0 discriminator 1
 2750 0058 0849     		ldr	r1, .L385
 2751 005a 0846     		mov	r0, r1
 2752              	.L377:
 2753 005c 8C79     		ldrb	r4, [r1, #6]	@ zero_extendqisi2
 2754 005e E406     		lsls	r4, r4, #27
 2755 0060 FCD4     		bmi	.L377
1434:../drivers/fsl_clock.c ****     {
1435:../drivers/fsl_clock.c ****     }
1436:../drivers/fsl_clock.c **** 
1437:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1438:../drivers/fsl_clock.c ****     if (change_drs)
 2756              		.loc 1 1438 0
 2757 0062 02B1     		cbz	r2, .L368
1439:../drivers/fsl_clock.c ****     {
1440:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 2758              		.loc 1 1440 0
 2759 0064 CE70     		strb	r6, [r1, #3]
 2760              	.LVL228:
 2761              	.L368:
1441:../drivers/fsl_clock.c ****     }
1442:../drivers/fsl_clock.c **** 
1443:../drivers/fsl_clock.c ****     /* Set DRST_DRS and DMX32. */
1444:../drivers/fsl_clock.c ****     mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
1445:../drivers/fsl_clock.c **** 
1446:../drivers/fsl_clock.c ****     /* Wait for clock status bits to show clock source is ext ref clk */
1447:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatExt != MCG_S_CLKST_VAL)
 2762              		.loc 1 1447 0 discriminator 1
 2763 0066 8279     		ldrb	r2, [r0, #6]	@ zero_extendqisi2
 2764 0068 C2F38102 		ubfx	r2, r2, #2, #2
 2765 006c 022A     		cmp	r2, #2
 2766 006e FAD1     		bne	.L368
1448:../drivers/fsl_clock.c ****     {
1449:../drivers/fsl_clock.c ****     }
1450:../drivers/fsl_clock.c **** 
1451:../drivers/fsl_clock.c ****     /* Wait for fll stable time. */
1452:../drivers/fsl_clock.c ****     if (fllStableDelay)
 2767              		.loc 1 1452 0
 2768 0070 03B1     		cbz	r3, .L369
1453:../drivers/fsl_clock.c ****     {
1454:../drivers/fsl_clock.c ****         fllStableDelay();
 2769              		.loc 1 1454 0
 2770 0072 9847     		blx	r3
 2771              	.LVL229:
 2772              	.L369:
1455:../drivers/fsl_clock.c ****     }
1456:../drivers/fsl_clock.c **** 
1457:../drivers/fsl_clock.c ****     return kStatus_Success;
1458:../drivers/fsl_clock.c **** }
 2773              		.loc 1 1458 0
 2774 0074 0020     		movs	r0, #0
 2775 0076 70BD     		pop	{r4, r5, r6, pc}
 2776              	.LVL230:
 2777              	.L370:
1380:../drivers/fsl_clock.c **** 
 2778              		.loc 1 1380 0
 2779 0078 0A46     		mov	r2, r1
 2780 007a D9E7     		b	.L364
 2781              	.L386:
 2782              		.align	2
 2783              	.L385:
 2784 007c 00400640 		.word	1074151424
 2785              		.cfi_endproc
 2786              	.LFE186:
 2788              		.section	.text.CLOCK_SetBlpiMode,"ax",%progbits
 2789              		.align	1
 2790              		.global	CLOCK_SetBlpiMode
 2791              		.syntax unified
 2792              		.thumb
 2793              		.thumb_func
 2794              		.fpu fpv4-sp-d16
 2796              	CLOCK_SetBlpiMode:
 2797              	.LFB187:
1459:../drivers/fsl_clock.c **** 
1460:../drivers/fsl_clock.c **** status_t CLOCK_SetBlpiMode(void)
1461:../drivers/fsl_clock.c **** {
 2798              		.loc 1 1461 0
 2799              		.cfi_startproc
 2800              		@ args = 0, pretend = 0, frame = 0
 2801              		@ frame_needed = 0, uses_anonymous_args = 0
 2802              		@ link register save eliminated.
1462:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1463:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
1464:../drivers/fsl_clock.c ****     {
1465:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1466:../drivers/fsl_clock.c ****     }
1467:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
1468:../drivers/fsl_clock.c **** 
1469:../drivers/fsl_clock.c ****     /* Set LP. */
1470:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 2803              		.loc 1 1470 0
 2804 0000 034A     		ldr	r2, .L388
 2805 0002 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 2806 0004 43F00203 		orr	r3, r3, #2
 2807 0008 5370     		strb	r3, [r2, #1]
1471:../drivers/fsl_clock.c **** 
1472:../drivers/fsl_clock.c ****     return kStatus_Success;
1473:../drivers/fsl_clock.c **** }
 2808              		.loc 1 1473 0
 2809 000a 0020     		movs	r0, #0
 2810 000c 7047     		bx	lr
 2811              	.L389:
 2812 000e 00BF     		.align	2
 2813              	.L388:
 2814 0010 00400640 		.word	1074151424
 2815              		.cfi_endproc
 2816              	.LFE187:
 2818              		.section	.text.CLOCK_SetBlpeMode,"ax",%progbits
 2819              		.align	1
 2820              		.global	CLOCK_SetBlpeMode
 2821              		.syntax unified
 2822              		.thumb
 2823              		.thumb_func
 2824              		.fpu fpv4-sp-d16
 2826              	CLOCK_SetBlpeMode:
 2827              	.LFB207:
 2828              		.cfi_startproc
 2829              		@ args = 0, pretend = 0, frame = 0
 2830              		@ frame_needed = 0, uses_anonymous_args = 0
 2831              		@ link register save eliminated.
 2832 0000 FFF7FEBF 		b	CLOCK_SetBlpiMode
 2833              		.cfi_endproc
 2834              	.LFE207:
 2836              		.section	.text.CLOCK_SetPbeMode,"ax",%progbits
 2837              		.align	1
 2838              		.global	CLOCK_SetPbeMode
 2839              		.syntax unified
 2840              		.thumb
 2841              		.thumb_func
 2842              		.fpu fpv4-sp-d16
 2844              	CLOCK_SetPbeMode:
 2845              	.LFB189:
1474:../drivers/fsl_clock.c **** 
1475:../drivers/fsl_clock.c **** status_t CLOCK_SetBlpeMode(void)
1476:../drivers/fsl_clock.c **** {
1477:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1478:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
1479:../drivers/fsl_clock.c ****     {
1480:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1481:../drivers/fsl_clock.c ****     }
1482:../drivers/fsl_clock.c **** #endif
1483:../drivers/fsl_clock.c **** 
1484:../drivers/fsl_clock.c ****     /* Set LP bit to enter BLPE mode. */
1485:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
1486:../drivers/fsl_clock.c **** 
1487:../drivers/fsl_clock.c ****     return kStatus_Success;
1488:../drivers/fsl_clock.c **** }
1489:../drivers/fsl_clock.c **** 
1490:../drivers/fsl_clock.c **** status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
1491:../drivers/fsl_clock.c **** {
 2846              		.loc 1 1491 0
 2847              		.cfi_startproc
 2848              		@ args = 0, pretend = 0, frame = 0
 2849              		@ frame_needed = 0, uses_anonymous_args = 0
 2850              	.LVL231:
 2851              		.loc 1 1491 0
 2852 0000 38B5     		push	{r3, r4, r5, lr}
 2853              		.cfi_def_cfa_offset 16
 2854              		.cfi_offset 3, -16
 2855              		.cfi_offset 4, -12
 2856              		.cfi_offset 5, -8
 2857              		.cfi_offset 14, -4
1492:../drivers/fsl_clock.c ****     assert(config);
1493:../drivers/fsl_clock.c **** 
1494:../drivers/fsl_clock.c ****     /*
1495:../drivers/fsl_clock.c ****        This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
1496:../drivers/fsl_clock.c ****        but with this workflow, the source mode could be all modes except PEI/PBI.
1497:../drivers/fsl_clock.c ****      */
1498:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 2858              		.loc 1 1498 0
 2859 0002 124B     		ldr	r3, .L399
 2860 0004 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2861 0006 02F0FD02 		and	r2, r2, #253
 2862 000a 5A70     		strb	r2, [r3, #1]
1499:../drivers/fsl_clock.c **** 
1500:../drivers/fsl_clock.c ****     /* Change to use external clock first. */
1501:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | MCG_C1_CLKS(kMCG_ClkOutSrcExte
 2863              		.loc 1 1501 0
 2864 000c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2865 000e 02F03B02 		and	r2, r2, #59
 2866 0012 42F08002 		orr	r2, r2, #128
 2867 0016 1A70     		strb	r2, [r3]
 2868              	.L392:
1502:../drivers/fsl_clock.c **** 
1503:../drivers/fsl_clock.c ****     /* Wait for CLKST clock status bits to show clock source is ext ref clk */
1504:../drivers/fsl_clock.c ****     while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
 2869              		.loc 1 1504 0 discriminator 1
 2870 0018 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2871 001a 02F01C02 		and	r2, r2, #28
 2872 001e 082A     		cmp	r2, #8
 2873 0020 FAD1     		bne	.L392
1505:../drivers/fsl_clock.c ****            (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
1506:../drivers/fsl_clock.c ****     {
1507:../drivers/fsl_clock.c ****     }
1508:../drivers/fsl_clock.c **** 
1509:../drivers/fsl_clock.c ****     /* Disable PLL first, then configure PLL. */
1510:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 2874              		.loc 1 1510 0
 2875 0022 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
1511:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2876              		.loc 1 1511 0
 2877 0024 094C     		ldr	r4, .L399
1510:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2878              		.loc 1 1510 0
 2879 0026 02F0BF02 		and	r2, r2, #191
 2880 002a 5A71     		strb	r2, [r3, #5]
 2881 002c 2546     		mov	r5, r4
 2882              	.L393:
 2883              		.loc 1 1511 0 discriminator 1
 2884 002e A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 2885 0030 9A06     		lsls	r2, r3, #26
 2886 0032 FCD4     		bmi	.L393
1512:../drivers/fsl_clock.c ****     {
1513:../drivers/fsl_clock.c ****     }
1514:../drivers/fsl_clock.c **** 
1515:../drivers/fsl_clock.c ****     /* Configure the PLL. */
1516:../drivers/fsl_clock.c ****     {
1517:../drivers/fsl_clock.c ****         CLOCK_EnablePll0(config);
 2887              		.loc 1 1517 0
 2888 0034 0846     		mov	r0, r1
 2889              	.LVL232:
 2890 0036 FFF7FEFF 		bl	CLOCK_EnablePll0
 2891              	.LVL233:
1518:../drivers/fsl_clock.c ****     }
1519:../drivers/fsl_clock.c **** 
1520:../drivers/fsl_clock.c ****     /* Change to PLL mode. */
1521:../drivers/fsl_clock.c ****     MCG->C6 |= MCG_C6_PLLS_MASK;
 2892              		.loc 1 1521 0
 2893 003a 6379     		ldrb	r3, [r4, #5]	@ zero_extendqisi2
 2894 003c 43F04003 		orr	r3, r3, #64
 2895 0040 6371     		strb	r3, [r4, #5]
 2896              	.L394:
1522:../drivers/fsl_clock.c **** 
1523:../drivers/fsl_clock.c ****     /* Wait for PLL mode changed. */
1524:../drivers/fsl_clock.c ****     while (!(MCG->S & MCG_S_PLLST_MASK))
 2897              		.loc 1 1524 0 discriminator 1
 2898 0042 AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 2899 0044 9B06     		lsls	r3, r3, #26
 2900 0046 FCD5     		bpl	.L394
1525:../drivers/fsl_clock.c ****     {
1526:../drivers/fsl_clock.c ****     }
1527:../drivers/fsl_clock.c **** 
1528:../drivers/fsl_clock.c ****     return kStatus_Success;
1529:../drivers/fsl_clock.c **** }
 2901              		.loc 1 1529 0
 2902 0048 0020     		movs	r0, #0
 2903              	.LVL234:
 2904 004a 38BD     		pop	{r3, r4, r5, pc}
 2905              	.L400:
 2906              		.align	2
 2907              	.L399:
 2908 004c 00400640 		.word	1074151424
 2909              		.cfi_endproc
 2910              	.LFE189:
 2912              		.section	.text.CLOCK_SetPeeMode,"ax",%progbits
 2913              		.align	1
 2914              		.global	CLOCK_SetPeeMode
 2915              		.syntax unified
 2916              		.thumb
 2917              		.thumb_func
 2918              		.fpu fpv4-sp-d16
 2920              	CLOCK_SetPeeMode:
 2921              	.LFB190:
1530:../drivers/fsl_clock.c **** 
1531:../drivers/fsl_clock.c **** status_t CLOCK_SetPeeMode(void)
1532:../drivers/fsl_clock.c **** {
 2922              		.loc 1 1532 0
 2923              		.cfi_startproc
 2924              		@ args = 0, pretend = 0, frame = 0
 2925              		@ frame_needed = 0, uses_anonymous_args = 0
 2926              		@ link register save eliminated.
1533:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1534:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1535:../drivers/fsl_clock.c ****     if (kMCG_ModePBE != mode)
1536:../drivers/fsl_clock.c ****     {
1537:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1538:../drivers/fsl_clock.c ****     }
1539:../drivers/fsl_clock.c **** #endif
1540:../drivers/fsl_clock.c **** 
1541:../drivers/fsl_clock.c ****     /* Change to use PLL/FLL output clock first. */
1542:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
 2927              		.loc 1 1542 0
 2928 0000 054B     		ldr	r3, .L404
 2929 0002 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2930 0004 02F03F02 		and	r2, r2, #63
 2931 0008 1A70     		strb	r2, [r3]
 2932              	.L402:
1543:../drivers/fsl_clock.c **** 
1544:../drivers/fsl_clock.c ****     /* Wait for clock status bits to update */
1545:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
 2933              		.loc 1 1545 0 discriminator 1
 2934 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2935 000c C2F38102 		ubfx	r2, r2, #2, #2
 2936 0010 032A     		cmp	r2, #3
 2937 0012 FAD1     		bne	.L402
1546:../drivers/fsl_clock.c ****     {
1547:../drivers/fsl_clock.c ****     }
1548:../drivers/fsl_clock.c **** 
1549:../drivers/fsl_clock.c ****     return kStatus_Success;
1550:../drivers/fsl_clock.c **** }
 2938              		.loc 1 1550 0
 2939 0014 0020     		movs	r0, #0
 2940 0016 7047     		bx	lr
 2941              	.L405:
 2942              		.align	2
 2943              	.L404:
 2944 0018 00400640 		.word	1074151424
 2945              		.cfi_endproc
 2946              	.LFE190:
 2948              		.section	.text.CLOCK_ExternalModeToFbeModeQuick,"ax",%progbits
 2949              		.align	1
 2950              		.global	CLOCK_ExternalModeToFbeModeQuick
 2951              		.syntax unified
 2952              		.thumb
 2953              		.thumb_func
 2954              		.fpu fpv4-sp-d16
 2956              	CLOCK_ExternalModeToFbeModeQuick:
 2957              	.LFB191:
1551:../drivers/fsl_clock.c **** 
1552:../drivers/fsl_clock.c **** status_t CLOCK_ExternalModeToFbeModeQuick(void)
1553:../drivers/fsl_clock.c **** {
 2958              		.loc 1 1553 0
 2959              		.cfi_startproc
 2960              		@ args = 0, pretend = 0, frame = 0
 2961              		@ frame_needed = 0, uses_anonymous_args = 0
 2962              		@ link register save eliminated.
1554:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1555:../drivers/fsl_clock.c ****     if (MCG->S & MCG_S_IREFST_MASK)
1556:../drivers/fsl_clock.c ****     {
1557:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeInvalid;
1558:../drivers/fsl_clock.c ****     }
1559:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
1560:../drivers/fsl_clock.c **** 
1561:../drivers/fsl_clock.c ****     /* Disable low power */
1562:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 2963              		.loc 1 1562 0
 2964 0000 0C4B     		ldr	r3, .L411
 2965 0002 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2966 0004 02F0FD02 		and	r2, r2, #253
 2967 0008 5A70     		strb	r2, [r3, #1]
1563:../drivers/fsl_clock.c **** 
1564:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
 2968              		.loc 1 1564 0
 2969 000a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2970 000c 02F03F02 		and	r2, r2, #63
 2971 0010 42F08002 		orr	r2, r2, #128
 2972 0014 1A70     		strb	r2, [r3]
 2973              	.L407:
1565:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 2974              		.loc 1 1565 0 discriminator 1
 2975 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2976 0018 C2F38102 		ubfx	r2, r2, #2, #2
 2977 001c 022A     		cmp	r2, #2
 2978 001e FAD1     		bne	.L407
1566:../drivers/fsl_clock.c ****     {
1567:../drivers/fsl_clock.c ****     }
1568:../drivers/fsl_clock.c **** 
1569:../drivers/fsl_clock.c ****     /* Disable PLL. */
1570:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 2979              		.loc 1 1570 0
 2980 0020 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2981 0022 02F0BF02 		and	r2, r2, #191
 2982 0026 5A71     		strb	r2, [r3, #5]
1571:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 2983              		.loc 1 1571 0
 2984 0028 024B     		ldr	r3, .L411
 2985              	.L408:
 2986              		.loc 1 1571 0 is_stmt 0 discriminator 1
 2987 002a 9879     		ldrb	r0, [r3, #6]	@ zero_extendqisi2
 2988 002c 10F02000 		ands	r0, r0, #32
 2989 0030 FBD1     		bne	.L408
1572:../drivers/fsl_clock.c ****     {
1573:../drivers/fsl_clock.c ****     }
1574:../drivers/fsl_clock.c **** 
1575:../drivers/fsl_clock.c ****     return kStatus_Success;
1576:../drivers/fsl_clock.c **** }
 2990              		.loc 1 1576 0 is_stmt 1
 2991 0032 7047     		bx	lr
 2992              	.L412:
 2993              		.align	2
 2994              	.L411:
 2995 0034 00400640 		.word	1074151424
 2996              		.cfi_endproc
 2997              	.LFE191:
 2999              		.section	.text.CLOCK_InternalModeToFbiModeQuick,"ax",%progbits
 3000              		.align	1
 3001              		.global	CLOCK_InternalModeToFbiModeQuick
 3002              		.syntax unified
 3003              		.thumb
 3004              		.thumb_func
 3005              		.fpu fpv4-sp-d16
 3007              	CLOCK_InternalModeToFbiModeQuick:
 3008              	.LFB192:
1577:../drivers/fsl_clock.c **** 
1578:../drivers/fsl_clock.c **** status_t CLOCK_InternalModeToFbiModeQuick(void)
1579:../drivers/fsl_clock.c **** {
 3009              		.loc 1 1579 0
 3010              		.cfi_startproc
 3011              		@ args = 0, pretend = 0, frame = 0
 3012              		@ frame_needed = 0, uses_anonymous_args = 0
 3013              		@ link register save eliminated.
1580:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1581:../drivers/fsl_clock.c ****     if (!(MCG->S & MCG_S_IREFST_MASK))
1582:../drivers/fsl_clock.c ****     {
1583:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeInvalid;
1584:../drivers/fsl_clock.c ****     }
1585:../drivers/fsl_clock.c **** #endif
1586:../drivers/fsl_clock.c **** 
1587:../drivers/fsl_clock.c ****     /* Disable low power */
1588:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 3014              		.loc 1 1588 0
 3015 0000 084B     		ldr	r3, .L416
 3016 0002 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3017 0004 02F0FD02 		and	r2, r2, #253
 3018 0008 5A70     		strb	r2, [r3, #1]
1589:../drivers/fsl_clock.c **** 
1590:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal));
 3019              		.loc 1 1590 0
 3020 000a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3021 000c 02F03F02 		and	r2, r2, #63
 3022 0010 42F04002 		orr	r2, r2, #64
 3023 0014 1A70     		strb	r2, [r3]
 3024              	.L414:
1591:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
 3025              		.loc 1 1591 0 discriminator 1
 3026 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3027 0018 C2F38102 		ubfx	r2, r2, #2, #2
 3028 001c 012A     		cmp	r2, #1
 3029 001e FAD1     		bne	.L414
1592:../drivers/fsl_clock.c ****     {
1593:../drivers/fsl_clock.c ****     }
1594:../drivers/fsl_clock.c **** 
1595:../drivers/fsl_clock.c ****     return kStatus_Success;
1596:../drivers/fsl_clock.c **** }
 3030              		.loc 1 1596 0
 3031 0020 0020     		movs	r0, #0
 3032 0022 7047     		bx	lr
 3033              	.L417:
 3034              		.align	2
 3035              	.L416:
 3036 0024 00400640 		.word	1074151424
 3037              		.cfi_endproc
 3038              	.LFE192:
 3040              		.section	.text.CLOCK_BootToFeiMode,"ax",%progbits
 3041              		.align	1
 3042              		.global	CLOCK_BootToFeiMode
 3043              		.syntax unified
 3044              		.thumb
 3045              		.thumb_func
 3046              		.fpu fpv4-sp-d16
 3048              	CLOCK_BootToFeiMode:
 3049              	.LFB193:
1597:../drivers/fsl_clock.c **** 
1598:../drivers/fsl_clock.c **** status_t CLOCK_BootToFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1599:../drivers/fsl_clock.c **** {
 3050              		.loc 1 1599 0
 3051              		.cfi_startproc
 3052              		@ args = 0, pretend = 0, frame = 0
 3053              		@ frame_needed = 0, uses_anonymous_args = 0
 3054              		@ link register save eliminated.
 3055              	.LVL235:
1600:../drivers/fsl_clock.c ****     return CLOCK_SetFeiMode(dmx32, drs, fllStableDelay);
 3056              		.loc 1 1600 0
 3057 0000 FFF7FEBF 		b	CLOCK_SetFeiMode
 3058              	.LVL236:
 3059              		.cfi_endproc
 3060              	.LFE193:
 3062              		.section	.text.CLOCK_BootToFeeMode,"ax",%progbits
 3063              		.align	1
 3064              		.global	CLOCK_BootToFeeMode
 3065              		.syntax unified
 3066              		.thumb
 3067              		.thumb_func
 3068              		.fpu fpv4-sp-d16
 3070              	CLOCK_BootToFeeMode:
 3071              	.LFB194:
1601:../drivers/fsl_clock.c **** }
1602:../drivers/fsl_clock.c **** 
1603:../drivers/fsl_clock.c **** status_t CLOCK_BootToFeeMode(
1604:../drivers/fsl_clock.c ****     mcg_oscsel_t oscsel, uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(vo
1605:../drivers/fsl_clock.c **** {
 3072              		.loc 1 1605 0
 3073              		.cfi_startproc
 3074              		@ args = 4, pretend = 0, frame = 0
 3075              		@ frame_needed = 0, uses_anonymous_args = 0
 3076              	.LVL237:
 3077 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3078              		.cfi_def_cfa_offset 24
 3079              		.cfi_offset 4, -24
 3080              		.cfi_offset 5, -20
 3081              		.cfi_offset 6, -16
 3082              		.cfi_offset 7, -12
 3083              		.cfi_offset 8, -8
 3084              		.cfi_offset 14, -4
 3085              		.loc 1 1605 0
 3086 0004 069F     		ldr	r7, [sp, #24]
 3087 0006 0C46     		mov	r4, r1
 3088 0008 1546     		mov	r5, r2
 3089 000a 1E46     		mov	r6, r3
1606:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 3090              		.loc 1 1606 0
 3091 000c FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3092              	.LVL238:
1607:../drivers/fsl_clock.c **** 
1608:../drivers/fsl_clock.c ****     return CLOCK_SetFeeMode(frdiv, dmx32, drs, fllStableDelay);
 3093              		.loc 1 1608 0
 3094 0010 3B46     		mov	r3, r7
 3095 0012 3246     		mov	r2, r6
 3096 0014 2946     		mov	r1, r5
 3097 0016 2046     		mov	r0, r4
1609:../drivers/fsl_clock.c **** }
 3098              		.loc 1 1609 0
 3099 0018 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 3100              		.cfi_restore 14
 3101              		.cfi_restore 8
 3102              		.cfi_restore 7
 3103              		.cfi_restore 6
 3104              		.cfi_restore 5
 3105              		.cfi_restore 4
 3106              		.cfi_def_cfa_offset 0
 3107              	.LVL239:
1608:../drivers/fsl_clock.c **** }
 3108              		.loc 1 1608 0
 3109 001c FFF7FEBF 		b	CLOCK_SetFeeMode
 3110              	.LVL240:
 3111              		.cfi_endproc
 3112              	.LFE194:
 3114              		.section	.text.CLOCK_BootToBlpiMode,"ax",%progbits
 3115              		.align	1
 3116              		.global	CLOCK_BootToBlpiMode
 3117              		.syntax unified
 3118              		.thumb
 3119              		.thumb_func
 3120              		.fpu fpv4-sp-d16
 3122              	CLOCK_BootToBlpiMode:
 3123              	.LFB195:
1610:../drivers/fsl_clock.c **** 
1611:../drivers/fsl_clock.c **** status_t CLOCK_BootToBlpiMode(uint8_t fcrdiv, mcg_irc_mode_t ircs, uint8_t ircEnableMode)
1612:../drivers/fsl_clock.c **** {
 3124              		.loc 1 1612 0
 3125              		.cfi_startproc
 3126              		@ args = 0, pretend = 0, frame = 0
 3127              		@ frame_needed = 0, uses_anonymous_args = 0
 3128              	.LVL241:
 3129 0000 08B5     		push	{r3, lr}
 3130              		.cfi_def_cfa_offset 8
 3131              		.cfi_offset 3, -8
 3132              		.cfi_offset 14, -4
 3133              		.loc 1 1612 0
 3134 0002 1346     		mov	r3, r2
1613:../drivers/fsl_clock.c ****     /* If reset mode is FEI mode, set MCGIRCLK and always success. */
1614:../drivers/fsl_clock.c ****     CLOCK_SetInternalRefClkConfig(ircEnableMode, ircs, fcrdiv);
 3135              		.loc 1 1614 0
 3136 0004 0246     		mov	r2, r0
 3137              	.LVL242:
 3138 0006 1846     		mov	r0, r3
 3139              	.LVL243:
 3140 0008 FFF7FEFF 		bl	CLOCK_SetInternalRefClkConfig
 3141              	.LVL244:
1615:../drivers/fsl_clock.c **** 
1616:../drivers/fsl_clock.c ****     /* If reset mode is not BLPI, first enter FBI mode. */
1617:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal);
 3142              		.loc 1 1617 0
 3143 000c 084B     		ldr	r3, .L423
 3144 000e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3145 0010 02F03F02 		and	r2, r2, #63
 3146 0014 42F04002 		orr	r2, r2, #64
 3147 0018 1A70     		strb	r2, [r3]
 3148              	.L421:
1618:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
 3149              		.loc 1 1618 0 discriminator 1
 3150 001a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3151 001c C2F38102 		ubfx	r2, r2, #2, #2
 3152 0020 012A     		cmp	r2, #1
 3153 0022 FAD1     		bne	.L421
1619:../drivers/fsl_clock.c ****     {
1620:../drivers/fsl_clock.c ****     }
1621:../drivers/fsl_clock.c **** 
1622:../drivers/fsl_clock.c ****     /* Enter BLPI mode. */
1623:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 3154              		.loc 1 1623 0
 3155 0024 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3156 0026 42F00202 		orr	r2, r2, #2
 3157 002a 5A70     		strb	r2, [r3, #1]
1624:../drivers/fsl_clock.c **** 
1625:../drivers/fsl_clock.c ****     return kStatus_Success;
1626:../drivers/fsl_clock.c **** }
 3158              		.loc 1 1626 0
 3159 002c 0020     		movs	r0, #0
 3160 002e 08BD     		pop	{r3, pc}
 3161              	.L424:
 3162              		.align	2
 3163              	.L423:
 3164 0030 00400640 		.word	1074151424
 3165              		.cfi_endproc
 3166              	.LFE195:
 3168              		.section	.text.CLOCK_BootToBlpeMode,"ax",%progbits
 3169              		.align	1
 3170              		.global	CLOCK_BootToBlpeMode
 3171              		.syntax unified
 3172              		.thumb
 3173              		.thumb_func
 3174              		.fpu fpv4-sp-d16
 3176              	CLOCK_BootToBlpeMode:
 3177              	.LFB196:
1627:../drivers/fsl_clock.c **** 
1628:../drivers/fsl_clock.c **** status_t CLOCK_BootToBlpeMode(mcg_oscsel_t oscsel)
1629:../drivers/fsl_clock.c **** {
 3178              		.loc 1 1629 0
 3179              		.cfi_startproc
 3180              		@ args = 0, pretend = 0, frame = 0
 3181              		@ frame_needed = 0, uses_anonymous_args = 0
 3182              	.LVL245:
 3183 0000 08B5     		push	{r3, lr}
 3184              		.cfi_def_cfa_offset 8
 3185              		.cfi_offset 3, -8
 3186              		.cfi_offset 14, -4
1630:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 3187              		.loc 1 1630 0
 3188 0002 FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3189              	.LVL246:
1631:../drivers/fsl_clock.c **** 
1632:../drivers/fsl_clock.c ****     /* Set to FBE mode. */
1633:../drivers/fsl_clock.c ****     MCG->C1 =
1634:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 3190              		.loc 1 1634 0
 3191 0006 0E4B     		ldr	r3, .L434
 3192 0008 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3193 000a 02F03B02 		and	r2, r2, #59
 3194 000e 42F08002 		orr	r2, r2, #128
1633:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 3195              		.loc 1 1633 0
 3196 0012 1A70     		strb	r2, [r3]
1635:../drivers/fsl_clock.c ****                                                                 | MCG_C1_IREFS(kMCG_FllSrcExternal)
1636:../drivers/fsl_clock.c **** 
1637:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1638:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
 3197              		.loc 1 1638 0
 3198 0014 1A7B     		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 3199 0016 9007     		lsls	r0, r2, #30
 3200 0018 05D1     		bne	.L426
1639:../drivers/fsl_clock.c ****     {
1640:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 3201              		.loc 1 1640 0
 3202 001a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3203 001c 5107     		lsls	r1, r2, #29
 3204 001e 02D5     		bpl	.L426
 3205              	.L427:
1641:../drivers/fsl_clock.c ****         {
1642:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 3206              		.loc 1 1642 0 discriminator 1
 3207 0020 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3208 0022 9207     		lsls	r2, r2, #30
 3209 0024 FCD5     		bpl	.L427
 3210              	.L426:
1643:../drivers/fsl_clock.c ****             {
1644:../drivers/fsl_clock.c ****             }
1645:../drivers/fsl_clock.c ****         }
1646:../drivers/fsl_clock.c ****     }
1647:../drivers/fsl_clock.c **** 
1648:../drivers/fsl_clock.c ****     /* Wait for MCG_S[CLKST] and MCG_S[IREFST]. */
1649:../drivers/fsl_clock.c ****     while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
 3211              		.loc 1 1649 0 discriminator 1
 3212 0026 064B     		ldr	r3, .L434
 3213              	.L430:
 3214 0028 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3215 002a 02F01C02 		and	r2, r2, #28
 3216 002e 082A     		cmp	r2, #8
 3217 0030 FAD1     		bne	.L430
1650:../drivers/fsl_clock.c ****            (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
1651:../drivers/fsl_clock.c ****     {
1652:../drivers/fsl_clock.c ****     }
1653:../drivers/fsl_clock.c **** 
1654:../drivers/fsl_clock.c ****     /* In FBE now, start to enter BLPE. */
1655:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 3218              		.loc 1 1655 0
 3219 0032 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3220 0034 42F00202 		orr	r2, r2, #2
 3221 0038 5A70     		strb	r2, [r3, #1]
1656:../drivers/fsl_clock.c **** 
1657:../drivers/fsl_clock.c ****     return kStatus_Success;
1658:../drivers/fsl_clock.c **** }
 3222              		.loc 1 1658 0
 3223 003a 0020     		movs	r0, #0
 3224 003c 08BD     		pop	{r3, pc}
 3225              	.L435:
 3226 003e 00BF     		.align	2
 3227              	.L434:
 3228 0040 00400640 		.word	1074151424
 3229              		.cfi_endproc
 3230              	.LFE196:
 3232              		.section	.text.CLOCK_BootToPeeMode,"ax",%progbits
 3233              		.align	1
 3234              		.global	CLOCK_BootToPeeMode
 3235              		.syntax unified
 3236              		.thumb
 3237              		.thumb_func
 3238              		.fpu fpv4-sp-d16
 3240              	CLOCK_BootToPeeMode:
 3241              	.LFB197:
1659:../drivers/fsl_clock.c **** 
1660:../drivers/fsl_clock.c **** status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t cons
1661:../drivers/fsl_clock.c **** {
 3242              		.loc 1 1661 0
 3243              		.cfi_startproc
 3244              		@ args = 0, pretend = 0, frame = 0
 3245              		@ frame_needed = 0, uses_anonymous_args = 0
 3246              	.LVL247:
 3247 0000 38B5     		push	{r3, r4, r5, lr}
 3248              		.cfi_def_cfa_offset 16
 3249              		.cfi_offset 3, -16
 3250              		.cfi_offset 4, -12
 3251              		.cfi_offset 5, -8
 3252              		.cfi_offset 14, -4
 3253              		.loc 1 1661 0
 3254 0002 1546     		mov	r5, r2
 3255 0004 0C46     		mov	r4, r1
1662:../drivers/fsl_clock.c ****     assert(config);
1663:../drivers/fsl_clock.c **** 
1664:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 3256              		.loc 1 1664 0
 3257 0006 FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3258              	.LVL248:
1665:../drivers/fsl_clock.c **** 
1666:../drivers/fsl_clock.c ****     CLOCK_SetPbeMode(pllcs, config);
 3259              		.loc 1 1666 0
 3260 000a 2946     		mov	r1, r5
 3261 000c 2046     		mov	r0, r4
 3262 000e FFF7FEFF 		bl	CLOCK_SetPbeMode
 3263              	.LVL249:
1667:../drivers/fsl_clock.c **** 
1668:../drivers/fsl_clock.c ****     /* Change to use PLL output clock. */
1669:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
 3264              		.loc 1 1669 0
 3265 0012 064B     		ldr	r3, .L439
 3266 0014 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3267 0016 02F03F02 		and	r2, r2, #63
 3268 001a 1A70     		strb	r2, [r3]
 3269              	.L437:
1670:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
 3270              		.loc 1 1670 0 discriminator 1
 3271 001c 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3272 001e C2F38102 		ubfx	r2, r2, #2, #2
 3273 0022 032A     		cmp	r2, #3
 3274 0024 FAD1     		bne	.L437
1671:../drivers/fsl_clock.c ****     {
1672:../drivers/fsl_clock.c ****     }
1673:../drivers/fsl_clock.c **** 
1674:../drivers/fsl_clock.c ****     return kStatus_Success;
1675:../drivers/fsl_clock.c **** }
 3275              		.loc 1 1675 0
 3276 0026 0020     		movs	r0, #0
 3277 0028 38BD     		pop	{r3, r4, r5, pc}
 3278              	.LVL250:
 3279              	.L440:
 3280 002a 00BF     		.align	2
 3281              	.L439:
 3282 002c 00400640 		.word	1074151424
 3283              		.cfi_endproc
 3284              	.LFE197:
 3286              		.section	.text.CLOCK_SetMcgConfig,"ax",%progbits
 3287              		.align	1
 3288              		.global	CLOCK_SetMcgConfig
 3289              		.syntax unified
 3290              		.thumb
 3291              		.thumb_func
 3292              		.fpu fpv4-sp-d16
 3294              	CLOCK_SetMcgConfig:
 3295              	.LFB198:
1676:../drivers/fsl_clock.c **** 
1677:../drivers/fsl_clock.c **** /*
1678:../drivers/fsl_clock.c ****    The transaction matrix. It defines the path for mode switch, the row is for
1679:../drivers/fsl_clock.c ****    current mode and the column is target mode.
1680:../drivers/fsl_clock.c ****    For example, switch from FEI to PEE:
1681:../drivers/fsl_clock.c ****    1. Current mode FEI, next mode is mcgModeMatrix[FEI][PEE] = FBE, so swith to FBE.
1682:../drivers/fsl_clock.c ****    2. Current mode FBE, next mode is mcgModeMatrix[FBE][PEE] = PBE, so swith to PBE.
1683:../drivers/fsl_clock.c ****    3. Current mode PBE, next mode is mcgModeMatrix[PBE][PEE] = PEE, so swith to PEE.
1684:../drivers/fsl_clock.c ****    Thus the MCG mode has changed from FEI to PEE.
1685:../drivers/fsl_clock.c ****  */
1686:../drivers/fsl_clock.c **** static const mcg_mode_t mcgModeMatrix[8][8] = {
1687:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeF
1688:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FEI */
1689:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_Mode
1690:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FBI */
1691:../drivers/fsl_clock.c ****     {kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_Mode
1692:../drivers/fsl_clock.c ****      kMCG_ModeFBI}, /* BLPI */
1693:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeF
1694:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FEE */
1695:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1696:../drivers/fsl_clock.c ****      kMCG_ModePBE}, /* FBE */
1697:../drivers/fsl_clock.c ****     {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1698:../drivers/fsl_clock.c ****      kMCG_ModePBE}, /* BLPE */
1699:../drivers/fsl_clock.c ****     {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1700:../drivers/fsl_clock.c ****      kMCG_ModePEE}, /* PBE */
1701:../drivers/fsl_clock.c ****     {kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModeP
1702:../drivers/fsl_clock.c ****      kMCG_ModePBE} /* PEE */
1703:../drivers/fsl_clock.c ****     /*    FEI           FBI           BLPI           FEE           FBE           BLPE           PBE
1704:../drivers/fsl_clock.c **** };
1705:../drivers/fsl_clock.c **** 
1706:../drivers/fsl_clock.c **** status_t CLOCK_SetMcgConfig(const mcg_config_t *config)
1707:../drivers/fsl_clock.c **** {
 3296              		.loc 1 1707 0
 3297              		.cfi_startproc
 3298              		@ args = 0, pretend = 0, frame = 0
 3299              		@ frame_needed = 0, uses_anonymous_args = 0
 3300              	.LVL251:
 3301 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3302              		.cfi_def_cfa_offset 24
 3303              		.cfi_offset 3, -24
 3304              		.cfi_offset 4, -20
 3305              		.cfi_offset 5, -16
 3306              		.cfi_offset 6, -12
 3307              		.cfi_offset 7, -8
 3308              		.cfi_offset 14, -4
1708:../drivers/fsl_clock.c ****     mcg_mode_t next_mode;
1709:../drivers/fsl_clock.c ****     status_t status = kStatus_Success;
1710:../drivers/fsl_clock.c **** 
1711:../drivers/fsl_clock.c ****     mcg_pll_clk_select_t pllcs = kMCG_PllClkSelPll0;
1712:../drivers/fsl_clock.c **** 
1713:../drivers/fsl_clock.c ****     /* If need to change external clock, MCG_C7[OSCSEL]. */
1714:../drivers/fsl_clock.c ****     if (MCG_C7_OSCSEL_VAL != config->oscsel)
 3309              		.loc 1 1714 0
 3310 0002 414A     		ldr	r2, .L463
 3311 0004 C179     		ldrb	r1, [r0, #7]	@ zero_extendqisi2
 3312 0006 137B     		ldrb	r3, [r2, #12]	@ zero_extendqisi2
 3313 0008 03F00303 		and	r3, r3, #3
 3314 000c 9942     		cmp	r1, r3
1707:../drivers/fsl_clock.c ****     mcg_mode_t next_mode;
 3315              		.loc 1 1707 0
 3316 000e 0446     		mov	r4, r0
 3317              		.loc 1 1714 0
 3318 0010 0DD0     		beq	.L442
1715:../drivers/fsl_clock.c ****     {
1716:../drivers/fsl_clock.c ****         /* If external clock is in use, change to FEI first. */
1717:../drivers/fsl_clock.c ****         if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 3319              		.loc 1 1717 0
 3320 0012 9279     		ldrb	r2, [r2, #6]	@ zero_extendqisi2
 3321 0014 12F01001 		ands	r1, r2, #16
 3322 0018 06D1     		bne	.L443
1718:../drivers/fsl_clock.c ****         {
1719:../drivers/fsl_clock.c ****             CLOCK_ExternalModeToFbeModeQuick();
 3323              		.loc 1 1719 0
 3324 001a FFF7FEFF 		bl	CLOCK_ExternalModeToFbeModeQuick
 3325              	.LVL252:
1720:../drivers/fsl_clock.c ****             CLOCK_SetFeiMode(config->dmx32, config->drs, (void (*)(void))0);
 3326              		.loc 1 1720 0
 3327 001e A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3328 0020 0A46     		mov	r2, r1
 3329 0022 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3330 0024 FFF7FEFF 		bl	CLOCK_SetFeiMode
 3331              	.LVL253:
 3332              	.L443:
1721:../drivers/fsl_clock.c ****         }
1722:../drivers/fsl_clock.c **** 
1723:../drivers/fsl_clock.c ****         CLOCK_SetExternalRefClkConfig(config->oscsel);
 3333              		.loc 1 1723 0
 3334 0028 E079     		ldrb	r0, [r4, #7]	@ zero_extendqisi2
 3335 002a FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
 3336              	.LVL254:
 3337              	.L442:
1724:../drivers/fsl_clock.c ****     }
1725:../drivers/fsl_clock.c **** 
1726:../drivers/fsl_clock.c ****     /* Re-configure MCGIRCLK, if MCGIRCLK is used as system clock source, then change to FEI/PEI fi
1727:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL == kMCG_ClkOutStatInt)
 3338              		.loc 1 1727 0
 3339 002e 364B     		ldr	r3, .L463
 3340 0030 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3341 0032 C2F38102 		ubfx	r2, r2, #2, #2
 3342 0036 012A     		cmp	r2, #1
 3343 0038 08D1     		bne	.L444
1728:../drivers/fsl_clock.c ****     {
1729:../drivers/fsl_clock.c ****         MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 3344              		.loc 1 1729 0
 3345 003a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3346 003c 02F0FD02 		and	r2, r2, #253
 3347 0040 5A70     		strb	r2, [r3, #1]
1730:../drivers/fsl_clock.c **** 
1731:../drivers/fsl_clock.c ****         {
1732:../drivers/fsl_clock.c ****             CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
 3348              		.loc 1 1732 0
 3349 0042 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3350 0044 314A     		ldr	r2, .L463+4
 3351 0046 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3352 0048 FFF7FEFF 		bl	CLOCK_SetFeiMode
 3353              	.LVL255:
 3354              	.L444:
1733:../drivers/fsl_clock.c ****         }
1734:../drivers/fsl_clock.c ****     }
1735:../drivers/fsl_clock.c **** 
1736:../drivers/fsl_clock.c ****     /* Configure MCGIRCLK. */
1737:../drivers/fsl_clock.c ****     CLOCK_SetInternalRefClkConfig(config->irclkEnableMode, config->ircs, config->fcrdiv);
 3355              		.loc 1 1737 0
 3356 004c E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 3357 004e A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 3358 0050 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
1738:../drivers/fsl_clock.c **** 
1739:../drivers/fsl_clock.c ****     next_mode = CLOCK_GetMode();
1740:../drivers/fsl_clock.c **** 
1741:../drivers/fsl_clock.c ****     do
1742:../drivers/fsl_clock.c ****     {
1743:../drivers/fsl_clock.c ****         next_mode = mcgModeMatrix[next_mode][config->mcgMode];
 3359              		.loc 1 1743 0
 3360 0052 2F4F     		ldr	r7, .L463+8
1744:../drivers/fsl_clock.c **** 
1745:../drivers/fsl_clock.c ****         switch (next_mode)
1746:../drivers/fsl_clock.c ****         {
1747:../drivers/fsl_clock.c ****             case kMCG_ModeFEI:
1748:../drivers/fsl_clock.c ****                 status = CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
1749:../drivers/fsl_clock.c ****                 break;
1750:../drivers/fsl_clock.c ****             case kMCG_ModeFEE:
1751:../drivers/fsl_clock.c ****                 status = CLOCK_SetFeeMode(config->frdiv, config->dmx32, config->drs, CLOCK_FllStabl
1752:../drivers/fsl_clock.c ****                 break;
1753:../drivers/fsl_clock.c ****             case kMCG_ModeFBI:
1754:../drivers/fsl_clock.c ****                 status = CLOCK_SetFbiMode(config->dmx32, config->drs, (void (*)(void))0);
1755:../drivers/fsl_clock.c ****                 break;
1756:../drivers/fsl_clock.c ****             case kMCG_ModeFBE:
1757:../drivers/fsl_clock.c ****                 status = CLOCK_SetFbeMode(config->frdiv, config->dmx32, config->drs, (void (*)(void
1758:../drivers/fsl_clock.c ****                 break;
1759:../drivers/fsl_clock.c ****             case kMCG_ModeBLPI:
1760:../drivers/fsl_clock.c ****                 status = CLOCK_SetBlpiMode();
1761:../drivers/fsl_clock.c ****                 break;
1762:../drivers/fsl_clock.c ****             case kMCG_ModeBLPE:
1763:../drivers/fsl_clock.c ****                 status = CLOCK_SetBlpeMode();
1764:../drivers/fsl_clock.c ****                 break;
1765:../drivers/fsl_clock.c ****             case kMCG_ModePBE:
1766:../drivers/fsl_clock.c ****                 /* If target mode is not PBE or PEE, then only need to set CLKS = EXT here. */
1767:../drivers/fsl_clock.c ****                 if ((kMCG_ModePEE == config->mcgMode) || (kMCG_ModePBE == config->mcgMode))
1768:../drivers/fsl_clock.c ****                 {
1769:../drivers/fsl_clock.c ****                     {
1770:../drivers/fsl_clock.c ****                         status = CLOCK_SetPbeMode(pllcs, &config->pll0Config);
1771:../drivers/fsl_clock.c ****                     }
1772:../drivers/fsl_clock.c ****                 }
1773:../drivers/fsl_clock.c ****                 else
1774:../drivers/fsl_clock.c ****                 {
1775:../drivers/fsl_clock.c ****                     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal))
 3361              		.loc 1 1775 0
 3362 0054 2C4E     		ldr	r6, .L463
1737:../drivers/fsl_clock.c **** 
 3363              		.loc 1 1737 0
 3364 0056 FFF7FEFF 		bl	CLOCK_SetInternalRefClkConfig
 3365              	.LVL256:
1739:../drivers/fsl_clock.c **** 
 3366              		.loc 1 1739 0
 3367 005a FFF7FEFF 		bl	CLOCK_GetMode
 3368              	.LVL257:
 3369 005e 0546     		mov	r5, r0
 3370              	.LVL258:
 3371              	.L459:
1743:../drivers/fsl_clock.c **** 
 3372              		.loc 1 1743 0
 3373 0060 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 3374 0062 07EBC505 		add	r5, r7, r5, lsl #3
 3375              	.LVL259:
 3376 0066 ED5C     		ldrb	r5, [r5, r3]	@ zero_extendqisi2
 3377              	.LVL260:
1745:../drivers/fsl_clock.c ****         {
 3378              		.loc 1 1745 0
 3379 0068 072D     		cmp	r5, #7
 3380 006a 37D8     		bhi	.L445
 3381 006c DFE805F0 		tbb	[pc, r5]
 3382              	.L447:
 3383 0070 04       		.byte	(.L446-.L447)/2
 3384 0071 12       		.byte	(.L448-.L447)/2
 3385 0072 1F       		.byte	(.L449-.L447)/2
 3386 0073 0B       		.byte	(.L450-.L447)/2
 3387 0074 18       		.byte	(.L451-.L447)/2
 3388 0075 1F       		.byte	(.L449-.L447)/2
 3389 0076 22       		.byte	(.L452-.L447)/2
 3390 0077 43       		.byte	(.L453-.L447)/2
 3391              		.p2align 1
 3392              	.L446:
1748:../drivers/fsl_clock.c ****                 break;
 3393              		.loc 1 1748 0
 3394 0078 244A     		ldr	r2, .L463+4
 3395 007a 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3396 007c A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3397 007e FFF7FEFF 		bl	CLOCK_SetFeiMode
 3398              	.LVL261:
 3399              	.L454:
1776:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
1777:../drivers/fsl_clock.c ****                     {
1778:../drivers/fsl_clock.c ****                     }
1779:../drivers/fsl_clock.c ****                 }
1780:../drivers/fsl_clock.c ****                 break;
1781:../drivers/fsl_clock.c ****             case kMCG_ModePEE:
1782:../drivers/fsl_clock.c ****                 status = CLOCK_SetPeeMode();
1783:../drivers/fsl_clock.c ****                 break;
1784:../drivers/fsl_clock.c ****             default:
1785:../drivers/fsl_clock.c ****                 break;
1786:../drivers/fsl_clock.c ****         }
1787:../drivers/fsl_clock.c ****         if (kStatus_Success != status)
 3400              		.loc 1 1787 0
 3401 0082 58B3     		cbz	r0, .L445
 3402              	.LVL262:
 3403              	.L441:
1788:../drivers/fsl_clock.c ****         {
1789:../drivers/fsl_clock.c ****             return status;
1790:../drivers/fsl_clock.c ****         }
1791:../drivers/fsl_clock.c ****     } while (next_mode != config->mcgMode);
1792:../drivers/fsl_clock.c **** 
1793:../drivers/fsl_clock.c ****     if (config->pll0Config.enableMode & kMCG_PllEnableIndependent)
1794:../drivers/fsl_clock.c ****     {
1795:../drivers/fsl_clock.c ****         CLOCK_EnablePll0(&config->pll0Config);
1796:../drivers/fsl_clock.c ****     }
1797:../drivers/fsl_clock.c ****     else
1798:../drivers/fsl_clock.c ****     {
1799:../drivers/fsl_clock.c ****         MCG->C5 &= ~(uint32_t)kMCG_PllEnableIndependent;
1800:../drivers/fsl_clock.c ****     }
1801:../drivers/fsl_clock.c ****     return kStatus_Success;
1802:../drivers/fsl_clock.c **** }
 3404              		.loc 1 1802 0
 3405 0084 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3406              	.LVL263:
 3407              	.L450:
1751:../drivers/fsl_clock.c ****                 break;
 3408              		.loc 1 1751 0
 3409 0086 214B     		ldr	r3, .L463+4
 3410 0088 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
 3411 008a A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3412 008c 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 3413 008e FFF7FEFF 		bl	CLOCK_SetFeeMode
 3414              	.LVL264:
1752:../drivers/fsl_clock.c ****             case kMCG_ModeFBI:
 3415              		.loc 1 1752 0
 3416 0092 F6E7     		b	.L454
 3417              	.LVL265:
 3418              	.L448:
1754:../drivers/fsl_clock.c ****                 break;
 3419              		.loc 1 1754 0
 3420 0094 0022     		movs	r2, #0
 3421 0096 6179     		ldrb	r1, [r4, #5]	@ zero_extendqisi2
 3422 0098 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3423 009a FFF7FEFF 		bl	CLOCK_SetFbiMode
 3424              	.LVL266:
1755:../drivers/fsl_clock.c ****             case kMCG_ModeFBE:
 3425              		.loc 1 1755 0
 3426 009e F0E7     		b	.L454
 3427              	.LVL267:
 3428              	.L451:
1757:../drivers/fsl_clock.c ****                 break;
 3429              		.loc 1 1757 0
 3430 00a0 0023     		movs	r3, #0
 3431 00a2 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
 3432 00a4 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3433 00a6 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 3434 00a8 FFF7FEFF 		bl	CLOCK_SetFbeMode
 3435              	.LVL268:
1758:../drivers/fsl_clock.c ****             case kMCG_ModeBLPI:
 3436              		.loc 1 1758 0
 3437 00ac E9E7     		b	.L454
 3438              	.LVL269:
 3439              	.L449:
1760:../drivers/fsl_clock.c ****                 break;
 3440              		.loc 1 1760 0
 3441 00ae FFF7FEFF 		bl	CLOCK_SetBlpiMode
 3442              	.LVL270:
1761:../drivers/fsl_clock.c ****             case kMCG_ModeBLPE:
 3443              		.loc 1 1761 0
 3444 00b2 E6E7     		b	.L454
 3445              	.LVL271:
 3446              	.L452:
1767:../drivers/fsl_clock.c ****                 {
 3447              		.loc 1 1767 0
 3448 00b4 063B     		subs	r3, r3, #6
 3449 00b6 012B     		cmp	r3, #1
 3450 00b8 05D8     		bhi	.L455
1770:../drivers/fsl_clock.c ****                     }
 3451              		.loc 1 1770 0
 3452 00ba 04F10801 		add	r1, r4, #8
 3453 00be 0020     		movs	r0, #0
 3454 00c0 FFF7FEFF 		bl	CLOCK_SetPbeMode
 3455              	.LVL272:
 3456 00c4 DDE7     		b	.L454
 3457              	.LVL273:
 3458              	.L455:
1775:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 3459              		.loc 1 1775 0
 3460 00c6 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3461 00c8 03F03F03 		and	r3, r3, #63
 3462 00cc 43F08003 		orr	r3, r3, #128
 3463 00d0 3370     		strb	r3, [r6]
 3464              	.L456:
1776:../drivers/fsl_clock.c ****                     {
 3465              		.loc 1 1776 0 discriminator 1
 3466 00d2 B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 3467 00d4 C3F38103 		ubfx	r3, r3, #2, #2
 3468 00d8 022B     		cmp	r3, #2
 3469 00da FAD1     		bne	.L456
 3470              	.LVL274:
 3471              	.L445:
1791:../drivers/fsl_clock.c **** 
 3472              		.loc 1 1791 0
 3473 00dc 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 3474 00de AB42     		cmp	r3, r5
 3475 00e0 BED1     		bne	.L459
1793:../drivers/fsl_clock.c ****     {
 3476              		.loc 1 1793 0
 3477 00e2 207A     		ldrb	r0, [r4, #8]	@ zero_extendqisi2
 3478 00e4 10F04000 		ands	r0, r0, #64
 3479 00e8 08D0     		beq	.L460
1795:../drivers/fsl_clock.c ****     }
 3480              		.loc 1 1795 0
 3481 00ea 04F10800 		add	r0, r4, #8
 3482 00ee FFF7FEFF 		bl	CLOCK_EnablePll0
 3483              	.LVL275:
1801:../drivers/fsl_clock.c **** }
 3484              		.loc 1 1801 0
 3485 00f2 0020     		movs	r0, #0
 3486 00f4 C6E7     		b	.L441
 3487              	.LVL276:
 3488              	.L453:
1782:../drivers/fsl_clock.c ****                 break;
 3489              		.loc 1 1782 0
 3490 00f6 FFF7FEFF 		bl	CLOCK_SetPeeMode
 3491              	.LVL277:
1783:../drivers/fsl_clock.c ****             default:
 3492              		.loc 1 1783 0
 3493 00fa C2E7     		b	.L454
 3494              	.LVL278:
 3495              	.L460:
1799:../drivers/fsl_clock.c ****     }
 3496              		.loc 1 1799 0
 3497 00fc 024A     		ldr	r2, .L463
 3498 00fe 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 3499 0100 03F0BF03 		and	r3, r3, #191
 3500 0104 1371     		strb	r3, [r2, #4]
 3501 0106 BDE7     		b	.L441
 3502              	.L464:
 3503              		.align	2
 3504              	.L463:
 3505 0108 00400640 		.word	1074151424
 3506 010c 00000000 		.word	CLOCK_FllStableDelay
 3507 0110 00000000 		.word	.LANCHOR4
 3508              		.cfi_endproc
 3509              	.LFE198:
 3511              		.comm	g_xtal32Freq,4,4
 3512              		.comm	g_xtal0Freq,4,4
 3513              		.section	.data.s_fastIrcFreq,"aw",%progbits
 3514              		.align	2
 3515              		.set	.LANCHOR1,. + 0
 3518              	s_fastIrcFreq:
 3519 0000 00093D00 		.word	4000000
 3520              		.section	.data.s_slowIrcFreq,"aw",%progbits
 3521              		.align	2
 3522              		.set	.LANCHOR0,. + 0
 3525              	s_slowIrcFreq:
 3526 0000 00800000 		.word	32768
 3527              		.section	.rodata.fllFactorTable.8306,"a",%progbits
 3528              		.align	1
 3529              		.set	.LANCHOR2,. + 0
 3532              	fllFactorTable.8306:
 3533 0000 8002     		.short	640
 3534 0002 DC02     		.short	732
 3535 0004 0005     		.short	1280
 3536 0006 B805     		.short	1464
 3537 0008 8007     		.short	1920
 3538 000a 9508     		.short	2197
 3539 000c 000A     		.short	2560
 3540 000e 710B     		.short	2929
 3541              		.section	.rodata.mcgModeMatrix,"a",%progbits
 3542              		.set	.LANCHOR4,. + 0
 3545              	mcgModeMatrix:
 3546 0000 00       		.byte	0
 3547 0001 01       		.byte	1
 3548 0002 01       		.byte	1
 3549 0003 03       		.byte	3
 3550 0004 04       		.byte	4
 3551 0005 04       		.byte	4
 3552 0006 04       		.byte	4
 3553 0007 04       		.byte	4
 3554 0008 00       		.byte	0
 3555 0009 01       		.byte	1
 3556 000a 02       		.byte	2
 3557 000b 03       		.byte	3
 3558 000c 04       		.byte	4
 3559 000d 04       		.byte	4
 3560 000e 04       		.byte	4
 3561 000f 04       		.byte	4
 3562 0010 01       		.byte	1
 3563 0011 01       		.byte	1
 3564 0012 02       		.byte	2
 3565 0013 01       		.byte	1
 3566 0014 01       		.byte	1
 3567 0015 01       		.byte	1
 3568 0016 01       		.byte	1
 3569 0017 01       		.byte	1
 3570 0018 00       		.byte	0
 3571 0019 01       		.byte	1
 3572 001a 01       		.byte	1
 3573 001b 03       		.byte	3
 3574 001c 04       		.byte	4
 3575 001d 04       		.byte	4
 3576 001e 04       		.byte	4
 3577 001f 04       		.byte	4
 3578 0020 00       		.byte	0
 3579 0021 01       		.byte	1
 3580 0022 01       		.byte	1
 3581 0023 03       		.byte	3
 3582 0024 04       		.byte	4
 3583 0025 05       		.byte	5
 3584 0026 06       		.byte	6
 3585 0027 06       		.byte	6
 3586 0028 04       		.byte	4
 3587 0029 04       		.byte	4
 3588 002a 04       		.byte	4
 3589 002b 04       		.byte	4
 3590 002c 04       		.byte	4
 3591 002d 05       		.byte	5
 3592 002e 06       		.byte	6
 3593 002f 06       		.byte	6
 3594 0030 04       		.byte	4
 3595 0031 04       		.byte	4
 3596 0032 04       		.byte	4
 3597 0033 04       		.byte	4
 3598 0034 04       		.byte	4
 3599 0035 05       		.byte	5
 3600 0036 06       		.byte	6
 3601 0037 07       		.byte	7
 3602 0038 06       		.byte	6
 3603 0039 06       		.byte	6
 3604 003a 06       		.byte	6
 3605 003b 06       		.byte	6
 3606 003c 06       		.byte	6
 3607 003d 06       		.byte	6
 3608 003e 06       		.byte	6
 3609 003f 06       		.byte	6
 3610              		.section	.rodata.trimRange.8408,"a",%progbits
 3611              		.align	2
 3612              		.set	.LANCHOR3,. + 0
 3615              	trimRange.8408:
 3616 0000 127A0000 		.word	31250
 3617 0004 97980000 		.word	39063
 3618 0008 C0C62D00 		.word	3000000
 3619 000c 404B4C00 		.word	5000000
 3620              		.text
 3621              	.Letext0:
 3622              		.file 3 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 3623              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 3624              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 3625              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 3626              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 3627              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 3628              		.file 9 "../CMSIS/core_cm4.h"
 3629              		.file 10 "../CMSIS/system_MK64F12.h"
 3630              		.file 11 "../CMSIS/MK64F12.h"
 3631              		.file 12 "../drivers/fsl_common.h"
