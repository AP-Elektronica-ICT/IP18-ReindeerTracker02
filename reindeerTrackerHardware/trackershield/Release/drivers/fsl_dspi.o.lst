   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_dspi.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.DSPI_CommonIRQHandler,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	DSPI_CommonIRQHandler:
  25              	.LFB201:
  26              		.file 1 "../drivers/fsl_dspi.c"
   1:../drivers/fsl_dspi.c **** /*
   2:../drivers/fsl_dspi.c ****  * The Clear BSD License
   3:../drivers/fsl_dspi.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dspi.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dspi.c ****  * All rights reserved.
   6:../drivers/fsl_dspi.c ****  *
   7:../drivers/fsl_dspi.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dspi.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dspi.c ****  * that the following conditions are met:
  10:../drivers/fsl_dspi.c ****  *
  11:../drivers/fsl_dspi.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dspi.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dspi.c ****  *
  14:../drivers/fsl_dspi.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dspi.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dspi.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dspi.c ****  *
  18:../drivers/fsl_dspi.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dspi.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dspi.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_dspi.c ****  *
  22:../drivers/fsl_dspi.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dspi.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dspi.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dspi.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dspi.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dspi.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dspi.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dspi.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dspi.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dspi.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dspi.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dspi.c ****  */
  34:../drivers/fsl_dspi.c **** 
  35:../drivers/fsl_dspi.c **** #include "fsl_dspi.h"
  36:../drivers/fsl_dspi.c **** 
  37:../drivers/fsl_dspi.c **** /*******************************************************************************
  38:../drivers/fsl_dspi.c ****  * Definitions
  39:../drivers/fsl_dspi.c ****  ******************************************************************************/
  40:../drivers/fsl_dspi.c **** /*! @brief Typedef for master interrupt handler. */
  41:../drivers/fsl_dspi.c **** typedef void (*dspi_master_isr_t)(SPI_Type *base, dspi_master_handle_t *handle);
  42:../drivers/fsl_dspi.c **** 
  43:../drivers/fsl_dspi.c **** /*! @brief Typedef for slave interrupt handler. */
  44:../drivers/fsl_dspi.c **** typedef void (*dspi_slave_isr_t)(SPI_Type *base, dspi_slave_handle_t *handle);
  45:../drivers/fsl_dspi.c **** 
  46:../drivers/fsl_dspi.c **** /*******************************************************************************
  47:../drivers/fsl_dspi.c ****  * Prototypes
  48:../drivers/fsl_dspi.c ****  ******************************************************************************/
  49:../drivers/fsl_dspi.c **** /*!
  50:../drivers/fsl_dspi.c ****  * @brief Get instance number for DSPI module.
  51:../drivers/fsl_dspi.c ****  *
  52:../drivers/fsl_dspi.c ****  * @param base DSPI peripheral base address.
  53:../drivers/fsl_dspi.c ****  */
  54:../drivers/fsl_dspi.c **** uint32_t DSPI_GetInstance(SPI_Type *base);
  55:../drivers/fsl_dspi.c **** 
  56:../drivers/fsl_dspi.c **** /*!
  57:../drivers/fsl_dspi.c ****  * @brief Configures the DSPI peripheral chip select polarity.
  58:../drivers/fsl_dspi.c ****  *
  59:../drivers/fsl_dspi.c ****  * This function  takes in the desired peripheral chip select (Pcs) and it's corresponding desired 
  60:../drivers/fsl_dspi.c ****  * configures the Pcs signal to operate with the desired characteristic.
  61:../drivers/fsl_dspi.c ****  *
  62:../drivers/fsl_dspi.c ****  * @param base DSPI peripheral address.
  63:../drivers/fsl_dspi.c ****  * @param pcs The particular peripheral chip select (parameter value is of type dspi_which_pcs_t) f
  64:../drivers/fsl_dspi.c ****  *            apply the active high or active low characteristic.
  65:../drivers/fsl_dspi.c ****  * @param activeLowOrHigh The setting for either "active high, inactive low (0)"  or "active low, i
  66:../drivers/fsl_dspi.c ****  *                        type dspi_pcs_polarity_config_t.
  67:../drivers/fsl_dspi.c ****  */
  68:../drivers/fsl_dspi.c **** static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t
  69:../drivers/fsl_dspi.c **** 
  70:../drivers/fsl_dspi.c **** /*!
  71:../drivers/fsl_dspi.c ****  * @brief Master fill up the TX FIFO with data.
  72:../drivers/fsl_dspi.c ****  * This is not a public API.
  73:../drivers/fsl_dspi.c ****  */
  74:../drivers/fsl_dspi.c **** static void DSPI_MasterTransferFillUpTxFifo(SPI_Type *base, dspi_master_handle_t *handle);
  75:../drivers/fsl_dspi.c **** 
  76:../drivers/fsl_dspi.c **** /*!
  77:../drivers/fsl_dspi.c ****  * @brief Master finish up a transfer.
  78:../drivers/fsl_dspi.c ****  * It would call back if there is callback function and set the state to idle.
  79:../drivers/fsl_dspi.c ****  * This is not a public API.
  80:../drivers/fsl_dspi.c ****  */
  81:../drivers/fsl_dspi.c **** static void DSPI_MasterTransferComplete(SPI_Type *base, dspi_master_handle_t *handle);
  82:../drivers/fsl_dspi.c **** 
  83:../drivers/fsl_dspi.c **** /*!
  84:../drivers/fsl_dspi.c ****  * @brief Slave fill up the TX FIFO with data.
  85:../drivers/fsl_dspi.c ****  * This is not a public API.
  86:../drivers/fsl_dspi.c ****  */
  87:../drivers/fsl_dspi.c **** static void DSPI_SlaveTransferFillUpTxFifo(SPI_Type *base, dspi_slave_handle_t *handle);
  88:../drivers/fsl_dspi.c **** 
  89:../drivers/fsl_dspi.c **** /*!
  90:../drivers/fsl_dspi.c ****  * @brief Slave finish up a transfer.
  91:../drivers/fsl_dspi.c ****  * It would call back if there is callback function and set the state to idle.
  92:../drivers/fsl_dspi.c ****  * This is not a public API.
  93:../drivers/fsl_dspi.c ****  */
  94:../drivers/fsl_dspi.c **** static void DSPI_SlaveTransferComplete(SPI_Type *base, dspi_slave_handle_t *handle);
  95:../drivers/fsl_dspi.c **** 
  96:../drivers/fsl_dspi.c **** /*!
  97:../drivers/fsl_dspi.c ****  * @brief DSPI common interrupt handler.
  98:../drivers/fsl_dspi.c ****  *
  99:../drivers/fsl_dspi.c ****  * @param base DSPI peripheral address.
 100:../drivers/fsl_dspi.c ****  * @param handle pointer to g_dspiHandle which stores the transfer state.
 101:../drivers/fsl_dspi.c ****  */
 102:../drivers/fsl_dspi.c **** static void DSPI_CommonIRQHandler(SPI_Type *base, void *param);
 103:../drivers/fsl_dspi.c **** 
 104:../drivers/fsl_dspi.c **** /*!
 105:../drivers/fsl_dspi.c ****  * @brief Master prepare the transfer.
 106:../drivers/fsl_dspi.c ****  * Basically it set up dspi_master_handle .
 107:../drivers/fsl_dspi.c ****  * This is not a public API.
 108:../drivers/fsl_dspi.c ****  */
 109:../drivers/fsl_dspi.c **** static void DSPI_MasterTransferPrepare(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_
 110:../drivers/fsl_dspi.c **** 
 111:../drivers/fsl_dspi.c **** /*******************************************************************************
 112:../drivers/fsl_dspi.c ****  * Variables
 113:../drivers/fsl_dspi.c ****  ******************************************************************************/
 114:../drivers/fsl_dspi.c **** 
 115:../drivers/fsl_dspi.c **** /* Defines constant value arrays for the baud rate pre-scalar and scalar divider values.*/
 116:../drivers/fsl_dspi.c **** static const uint32_t s_baudratePrescaler[] = {2, 3, 5, 7};
 117:../drivers/fsl_dspi.c **** static const uint32_t s_baudrateScaler[] = {2,   4,   6,    8,    16,   32,   64,    128,
 118:../drivers/fsl_dspi.c ****                                             256, 512, 1024, 2048, 4096, 8192, 16384, 32768};
 119:../drivers/fsl_dspi.c **** 
 120:../drivers/fsl_dspi.c **** static const uint32_t s_delayPrescaler[] = {1, 3, 5, 7};
 121:../drivers/fsl_dspi.c **** static const uint32_t s_delayScaler[] = {2,   4,    8,    16,   32,   64,    128,   256,
 122:../drivers/fsl_dspi.c ****                                          512, 1024, 2048, 4096, 8192, 16384, 32768, 65536};
 123:../drivers/fsl_dspi.c **** 
 124:../drivers/fsl_dspi.c **** /*! @brief Pointers to dspi bases for each instance. */
 125:../drivers/fsl_dspi.c **** static SPI_Type *const s_dspiBases[] = SPI_BASE_PTRS;
 126:../drivers/fsl_dspi.c **** 
 127:../drivers/fsl_dspi.c **** /*! @brief Pointers to dspi IRQ number for each instance. */
 128:../drivers/fsl_dspi.c **** static IRQn_Type const s_dspiIRQ[] = SPI_IRQS;
 129:../drivers/fsl_dspi.c **** 
 130:../drivers/fsl_dspi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 131:../drivers/fsl_dspi.c **** /*! @brief Pointers to dspi clocks for each instance. */
 132:../drivers/fsl_dspi.c **** static clock_ip_name_t const s_dspiClock[] = DSPI_CLOCKS;
 133:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 134:../drivers/fsl_dspi.c **** 
 135:../drivers/fsl_dspi.c **** /*! @brief Pointers to dspi handles for each instance. */
 136:../drivers/fsl_dspi.c **** static void *g_dspiHandle[ARRAY_SIZE(s_dspiBases)];
 137:../drivers/fsl_dspi.c **** 
 138:../drivers/fsl_dspi.c **** /*! @brief Pointer to master IRQ handler for each instance. */
 139:../drivers/fsl_dspi.c **** static dspi_master_isr_t s_dspiMasterIsr;
 140:../drivers/fsl_dspi.c **** 
 141:../drivers/fsl_dspi.c **** /*! @brief Pointer to slave IRQ handler for each instance. */
 142:../drivers/fsl_dspi.c **** static dspi_slave_isr_t s_dspiSlaveIsr;
 143:../drivers/fsl_dspi.c **** 
 144:../drivers/fsl_dspi.c **** /* @brief Dummy data for each instance. This data is used when user's tx buffer is NULL*/
 145:../drivers/fsl_dspi.c **** volatile uint8_t s_dummyData[ARRAY_SIZE(s_dspiBases)] = {0};
 146:../drivers/fsl_dspi.c **** /**************************************************************************************************
 147:../drivers/fsl_dspi.c **** * Code
 148:../drivers/fsl_dspi.c **** ***************************************************************************************************
 149:../drivers/fsl_dspi.c **** uint32_t DSPI_GetInstance(SPI_Type *base)
 150:../drivers/fsl_dspi.c **** {
 151:../drivers/fsl_dspi.c ****     uint32_t instance;
 152:../drivers/fsl_dspi.c **** 
 153:../drivers/fsl_dspi.c ****     /* Find the instance index from base address mappings. */
 154:../drivers/fsl_dspi.c ****     for (instance = 0; instance < ARRAY_SIZE(s_dspiBases); instance++)
 155:../drivers/fsl_dspi.c ****     {
 156:../drivers/fsl_dspi.c ****         if (s_dspiBases[instance] == base)
 157:../drivers/fsl_dspi.c ****         {
 158:../drivers/fsl_dspi.c ****             break;
 159:../drivers/fsl_dspi.c ****         }
 160:../drivers/fsl_dspi.c ****     }
 161:../drivers/fsl_dspi.c **** 
 162:../drivers/fsl_dspi.c ****     assert(instance < ARRAY_SIZE(s_dspiBases));
 163:../drivers/fsl_dspi.c **** 
 164:../drivers/fsl_dspi.c ****     return instance;
 165:../drivers/fsl_dspi.c **** }
 166:../drivers/fsl_dspi.c **** 
 167:../drivers/fsl_dspi.c **** void DSPI_SetDummyData(SPI_Type *base, uint8_t dummyData)
 168:../drivers/fsl_dspi.c **** {
 169:../drivers/fsl_dspi.c ****     uint32_t instance = DSPI_GetInstance(base);
 170:../drivers/fsl_dspi.c ****     s_dummyData[instance] = dummyData;
 171:../drivers/fsl_dspi.c **** }
 172:../drivers/fsl_dspi.c **** 
 173:../drivers/fsl_dspi.c **** void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz
 174:../drivers/fsl_dspi.c **** {
 175:../drivers/fsl_dspi.c ****     assert(masterConfig);
 176:../drivers/fsl_dspi.c **** 
 177:../drivers/fsl_dspi.c ****     uint32_t temp;
 178:../drivers/fsl_dspi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 179:../drivers/fsl_dspi.c ****     /* enable DSPI clock */
 180:../drivers/fsl_dspi.c ****     CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
 181:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 182:../drivers/fsl_dspi.c **** 
 183:../drivers/fsl_dspi.c ****     DSPI_Enable(base, true);
 184:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 185:../drivers/fsl_dspi.c **** 
 186:../drivers/fsl_dspi.c ****     DSPI_SetMasterSlaveMode(base, kDSPI_Master);
 187:../drivers/fsl_dspi.c **** 
 188:../drivers/fsl_dspi.c ****     temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_
 189:../drivers/fsl_dspi.c ****                           SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
 190:../drivers/fsl_dspi.c **** 
 191:../drivers/fsl_dspi.c ****     base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enableContinuousSCK) |
 192:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
 193:../drivers/fsl_dspi.c ****                 SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->s
 194:../drivers/fsl_dspi.c ****                 SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
 195:../drivers/fsl_dspi.c **** 
 196:../drivers/fsl_dspi.c ****     DSPI_SetOnePcsPolarity(base, masterConfig->whichPcs, masterConfig->pcsActiveHighOrLow);
 197:../drivers/fsl_dspi.c **** 
 198:../drivers/fsl_dspi.c ****     if (0 == DSPI_MasterSetBaudRate(base, masterConfig->whichCtar, masterConfig->ctarConfig.baudRat
 199:../drivers/fsl_dspi.c ****     {
 200:../drivers/fsl_dspi.c ****         assert(false);
 201:../drivers/fsl_dspi.c ****     }
 202:../drivers/fsl_dspi.c **** 
 203:../drivers/fsl_dspi.c ****     temp = base->CTAR[masterConfig->whichCtar] &
 204:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 205:../drivers/fsl_dspi.c **** 
 206:../drivers/fsl_dspi.c ****     base->CTAR[masterConfig->whichCtar] =
 207:../drivers/fsl_dspi.c ****         temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1) | SPI_CTAR_CPOL(masterConfi
 208:../drivers/fsl_dspi.c ****         SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.dire
 209:../drivers/fsl_dspi.c **** 
 210:../drivers/fsl_dspi.c ****     DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_PcsToSck, srcClock_Hz,
 211:../drivers/fsl_dspi.c ****                              masterConfig->ctarConfig.pcsToSckDelayInNanoSec);
 212:../drivers/fsl_dspi.c ****     DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_LastSckToPcs, srcClock_Hz,
 213:../drivers/fsl_dspi.c ****                              masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec);
 214:../drivers/fsl_dspi.c ****     DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_BetweenTransfer, srcClock_Hz,
 215:../drivers/fsl_dspi.c ****                              masterConfig->ctarConfig.betweenTransferDelayInNanoSec);
 216:../drivers/fsl_dspi.c **** 
 217:../drivers/fsl_dspi.c ****     DSPI_SetDummyData(base, DSPI_DUMMY_DATA);
 218:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
 219:../drivers/fsl_dspi.c **** }
 220:../drivers/fsl_dspi.c **** 
 221:../drivers/fsl_dspi.c **** void DSPI_MasterGetDefaultConfig(dspi_master_config_t *masterConfig)
 222:../drivers/fsl_dspi.c **** {
 223:../drivers/fsl_dspi.c ****     assert(masterConfig);
 224:../drivers/fsl_dspi.c **** 
 225:../drivers/fsl_dspi.c ****     masterConfig->whichCtar = kDSPI_Ctar0;
 226:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.baudRate = 500000;
 227:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.bitsPerFrame = 8;
 228:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
 229:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
 230:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.direction = kDSPI_MsbFirst;
 231:../drivers/fsl_dspi.c **** 
 232:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.pcsToSckDelayInNanoSec = 1000;
 233:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec = 1000;
 234:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.betweenTransferDelayInNanoSec = 1000;
 235:../drivers/fsl_dspi.c **** 
 236:../drivers/fsl_dspi.c ****     masterConfig->whichPcs = kDSPI_Pcs0;
 237:../drivers/fsl_dspi.c ****     masterConfig->pcsActiveHighOrLow = kDSPI_PcsActiveLow;
 238:../drivers/fsl_dspi.c **** 
 239:../drivers/fsl_dspi.c ****     masterConfig->enableContinuousSCK = false;
 240:../drivers/fsl_dspi.c ****     masterConfig->enableRxFifoOverWrite = false;
 241:../drivers/fsl_dspi.c ****     masterConfig->enableModifiedTimingFormat = false;
 242:../drivers/fsl_dspi.c ****     masterConfig->samplePoint = kDSPI_SckToSin0Clock;
 243:../drivers/fsl_dspi.c **** }
 244:../drivers/fsl_dspi.c **** 
 245:../drivers/fsl_dspi.c **** void DSPI_SlaveInit(SPI_Type *base, const dspi_slave_config_t *slaveConfig)
 246:../drivers/fsl_dspi.c **** {
 247:../drivers/fsl_dspi.c ****     assert(slaveConfig);
 248:../drivers/fsl_dspi.c **** 
 249:../drivers/fsl_dspi.c ****     uint32_t temp = 0;
 250:../drivers/fsl_dspi.c **** 
 251:../drivers/fsl_dspi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 252:../drivers/fsl_dspi.c ****     /* enable DSPI clock */
 253:../drivers/fsl_dspi.c ****     CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
 254:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 255:../drivers/fsl_dspi.c **** 
 256:../drivers/fsl_dspi.c ****     DSPI_Enable(base, true);
 257:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 258:../drivers/fsl_dspi.c **** 
 259:../drivers/fsl_dspi.c ****     DSPI_SetMasterSlaveMode(base, kDSPI_Slave);
 260:../drivers/fsl_dspi.c **** 
 261:../drivers/fsl_dspi.c ****     temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_
 262:../drivers/fsl_dspi.c ****                           SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
 263:../drivers/fsl_dspi.c **** 
 264:../drivers/fsl_dspi.c ****     base->MCR = temp | SPI_MCR_CONT_SCKE(slaveConfig->enableContinuousSCK) |
 265:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(slaveConfig->enableModifiedTimingFormat) |
 266:../drivers/fsl_dspi.c ****                 SPI_MCR_ROOE(slaveConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(slaveConfig->sam
 267:../drivers/fsl_dspi.c ****                 SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
 268:../drivers/fsl_dspi.c **** 
 269:../drivers/fsl_dspi.c ****     DSPI_SetOnePcsPolarity(base, kDSPI_Pcs0, kDSPI_PcsActiveLow);
 270:../drivers/fsl_dspi.c **** 
 271:../drivers/fsl_dspi.c ****     temp = base->CTAR[slaveConfig->whichCtar] &
 272:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 273:../drivers/fsl_dspi.c **** 
 274:../drivers/fsl_dspi.c ****     base->CTAR[slaveConfig->whichCtar] = temp | SPI_CTAR_SLAVE_FMSZ(slaveConfig->ctarConfig.bitsPer
 275:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
 276:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
 277:../drivers/fsl_dspi.c **** 
 278:../drivers/fsl_dspi.c ****     DSPI_SetDummyData(base, DSPI_DUMMY_DATA);
 279:../drivers/fsl_dspi.c **** 
 280:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
 281:../drivers/fsl_dspi.c **** }
 282:../drivers/fsl_dspi.c **** 
 283:../drivers/fsl_dspi.c **** void DSPI_SlaveGetDefaultConfig(dspi_slave_config_t *slaveConfig)
 284:../drivers/fsl_dspi.c **** {
 285:../drivers/fsl_dspi.c ****     assert(slaveConfig);
 286:../drivers/fsl_dspi.c **** 
 287:../drivers/fsl_dspi.c ****     slaveConfig->whichCtar = kDSPI_Ctar0;
 288:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.bitsPerFrame = 8;
 289:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
 290:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
 291:../drivers/fsl_dspi.c **** 
 292:../drivers/fsl_dspi.c ****     slaveConfig->enableContinuousSCK = false;
 293:../drivers/fsl_dspi.c ****     slaveConfig->enableRxFifoOverWrite = false;
 294:../drivers/fsl_dspi.c ****     slaveConfig->enableModifiedTimingFormat = false;
 295:../drivers/fsl_dspi.c ****     slaveConfig->samplePoint = kDSPI_SckToSin0Clock;
 296:../drivers/fsl_dspi.c **** }
 297:../drivers/fsl_dspi.c **** 
 298:../drivers/fsl_dspi.c **** void DSPI_Deinit(SPI_Type *base)
 299:../drivers/fsl_dspi.c **** {
 300:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 301:../drivers/fsl_dspi.c ****     DSPI_Enable(base, false);
 302:../drivers/fsl_dspi.c **** 
 303:../drivers/fsl_dspi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 304:../drivers/fsl_dspi.c ****     /* disable DSPI clock */
 305:../drivers/fsl_dspi.c ****     CLOCK_DisableClock(s_dspiClock[DSPI_GetInstance(base)]);
 306:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 307:../drivers/fsl_dspi.c **** }
 308:../drivers/fsl_dspi.c **** 
 309:../drivers/fsl_dspi.c **** static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t
 310:../drivers/fsl_dspi.c **** {
 311:../drivers/fsl_dspi.c ****     uint32_t temp;
 312:../drivers/fsl_dspi.c **** 
 313:../drivers/fsl_dspi.c ****     temp = base->MCR;
 314:../drivers/fsl_dspi.c **** 
 315:../drivers/fsl_dspi.c ****     if (activeLowOrHigh == kDSPI_PcsActiveLow)
 316:../drivers/fsl_dspi.c ****     {
 317:../drivers/fsl_dspi.c ****         temp |= SPI_MCR_PCSIS(pcs);
 318:../drivers/fsl_dspi.c ****     }
 319:../drivers/fsl_dspi.c ****     else
 320:../drivers/fsl_dspi.c ****     {
 321:../drivers/fsl_dspi.c ****         temp &= ~SPI_MCR_PCSIS(pcs);
 322:../drivers/fsl_dspi.c ****     }
 323:../drivers/fsl_dspi.c **** 
 324:../drivers/fsl_dspi.c ****     base->MCR = temp;
 325:../drivers/fsl_dspi.c **** }
 326:../drivers/fsl_dspi.c **** 
 327:../drivers/fsl_dspi.c **** uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
 328:../drivers/fsl_dspi.c ****                                 dspi_ctar_selection_t whichCtar,
 329:../drivers/fsl_dspi.c ****                                 uint32_t baudRate_Bps,
 330:../drivers/fsl_dspi.c ****                                 uint32_t srcClock_Hz)
 331:../drivers/fsl_dspi.c **** {
 332:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0*/
 333:../drivers/fsl_dspi.c ****     if (!DSPI_IsMaster(base))
 334:../drivers/fsl_dspi.c ****     {
 335:../drivers/fsl_dspi.c ****         return 0;
 336:../drivers/fsl_dspi.c ****     }
 337:../drivers/fsl_dspi.c ****     uint32_t temp;
 338:../drivers/fsl_dspi.c ****     uint32_t prescaler, bestPrescaler;
 339:../drivers/fsl_dspi.c ****     uint32_t scaler, bestScaler;
 340:../drivers/fsl_dspi.c ****     uint32_t dbr, bestDbr;
 341:../drivers/fsl_dspi.c ****     uint32_t realBaudrate, bestBaudrate;
 342:../drivers/fsl_dspi.c ****     uint32_t diff, min_diff;
 343:../drivers/fsl_dspi.c ****     uint32_t baudrate = baudRate_Bps;
 344:../drivers/fsl_dspi.c **** 
 345:../drivers/fsl_dspi.c ****     /* find combination of prescaler and scaler resulting in baudrate closest to the requested valu
 346:../drivers/fsl_dspi.c ****     min_diff = 0xFFFFFFFFU;
 347:../drivers/fsl_dspi.c ****     bestPrescaler = 0;
 348:../drivers/fsl_dspi.c ****     bestScaler = 0;
 349:../drivers/fsl_dspi.c ****     bestDbr = 1;
 350:../drivers/fsl_dspi.c ****     bestBaudrate = 0; /* required to avoid compilation warning */
 351:../drivers/fsl_dspi.c **** 
 352:../drivers/fsl_dspi.c ****     /* In all for loops, if min_diff = 0, the exit for loop*/
 353:../drivers/fsl_dspi.c ****     for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
 354:../drivers/fsl_dspi.c ****     {
 355:../drivers/fsl_dspi.c ****         for (scaler = 0; (scaler < 16) && min_diff; scaler++)
 356:../drivers/fsl_dspi.c ****         {
 357:../drivers/fsl_dspi.c ****             for (dbr = 1; (dbr < 3) && min_diff; dbr++)
 358:../drivers/fsl_dspi.c ****             {
 359:../drivers/fsl_dspi.c ****                 realBaudrate = ((srcClock_Hz * dbr) / (s_baudratePrescaler[prescaler] * (s_baudrate
 360:../drivers/fsl_dspi.c **** 
 361:../drivers/fsl_dspi.c ****                 /* calculate the baud rate difference based on the conditional statement that state
 362:../drivers/fsl_dspi.c ****                 * baud rate must not exceed the desired baud rate.
 363:../drivers/fsl_dspi.c ****                 */
 364:../drivers/fsl_dspi.c ****                 if (baudrate >= realBaudrate)
 365:../drivers/fsl_dspi.c ****                 {
 366:../drivers/fsl_dspi.c ****                     diff = baudrate - realBaudrate;
 367:../drivers/fsl_dspi.c ****                     if (min_diff > diff)
 368:../drivers/fsl_dspi.c ****                     {
 369:../drivers/fsl_dspi.c ****                         /* a better match found */
 370:../drivers/fsl_dspi.c ****                         min_diff = diff;
 371:../drivers/fsl_dspi.c ****                         bestPrescaler = prescaler;
 372:../drivers/fsl_dspi.c ****                         bestScaler = scaler;
 373:../drivers/fsl_dspi.c ****                         bestBaudrate = realBaudrate;
 374:../drivers/fsl_dspi.c ****                         bestDbr = dbr;
 375:../drivers/fsl_dspi.c ****                     }
 376:../drivers/fsl_dspi.c ****                 }
 377:../drivers/fsl_dspi.c ****             }
 378:../drivers/fsl_dspi.c ****         }
 379:../drivers/fsl_dspi.c ****     }
 380:../drivers/fsl_dspi.c **** 
 381:../drivers/fsl_dspi.c ****     /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
 382:../drivers/fsl_dspi.c ****     temp = base->CTAR[whichCtar] & ~(SPI_CTAR_DBR_MASK | SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK);
 383:../drivers/fsl_dspi.c **** 
 384:../drivers/fsl_dspi.c ****     base->CTAR[whichCtar] = temp | ((bestDbr - 1) << SPI_CTAR_DBR_SHIFT) | (bestPrescaler << SPI_CT
 385:../drivers/fsl_dspi.c ****                             (bestScaler << SPI_CTAR_BR_SHIFT);
 386:../drivers/fsl_dspi.c **** 
 387:../drivers/fsl_dspi.c ****     /* return the actual calculated baud rate */
 388:../drivers/fsl_dspi.c ****     return bestBaudrate;
 389:../drivers/fsl_dspi.c **** }
 390:../drivers/fsl_dspi.c **** 
 391:../drivers/fsl_dspi.c **** void DSPI_MasterSetDelayScaler(
 392:../drivers/fsl_dspi.c ****     SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_dela
 393:../drivers/fsl_dspi.c **** {
 394:../drivers/fsl_dspi.c ****     /* these settings are only relevant in master mode */
 395:../drivers/fsl_dspi.c ****     if (DSPI_IsMaster(base))
 396:../drivers/fsl_dspi.c ****     {
 397:../drivers/fsl_dspi.c ****         switch (whichDelay)
 398:../drivers/fsl_dspi.c ****         {
 399:../drivers/fsl_dspi.c ****             case kDSPI_PcsToSck:
 400:../drivers/fsl_dspi.c ****                 base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CT
 401:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
 402:../drivers/fsl_dspi.c ****                 break;
 403:../drivers/fsl_dspi.c ****             case kDSPI_LastSckToPcs:
 404:../drivers/fsl_dspi.c ****                 base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR
 405:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
 406:../drivers/fsl_dspi.c ****                 break;
 407:../drivers/fsl_dspi.c ****             case kDSPI_BetweenTransfer:
 408:../drivers/fsl_dspi.c ****                 base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_
 409:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
 410:../drivers/fsl_dspi.c ****                 break;
 411:../drivers/fsl_dspi.c ****             default:
 412:../drivers/fsl_dspi.c ****                 break;
 413:../drivers/fsl_dspi.c ****         }
 414:../drivers/fsl_dspi.c ****     }
 415:../drivers/fsl_dspi.c **** }
 416:../drivers/fsl_dspi.c **** 
 417:../drivers/fsl_dspi.c **** uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
 418:../drivers/fsl_dspi.c ****                                   dspi_ctar_selection_t whichCtar,
 419:../drivers/fsl_dspi.c ****                                   dspi_delay_type_t whichDelay,
 420:../drivers/fsl_dspi.c ****                                   uint32_t srcClock_Hz,
 421:../drivers/fsl_dspi.c ****                                   uint32_t delayTimeInNanoSec)
 422:../drivers/fsl_dspi.c **** {
 423:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0 */
 424:../drivers/fsl_dspi.c ****     if (!DSPI_IsMaster(base))
 425:../drivers/fsl_dspi.c ****     {
 426:../drivers/fsl_dspi.c ****         return 0;
 427:../drivers/fsl_dspi.c ****     }
 428:../drivers/fsl_dspi.c **** 
 429:../drivers/fsl_dspi.c ****     uint32_t prescaler, bestPrescaler;
 430:../drivers/fsl_dspi.c ****     uint32_t scaler, bestScaler;
 431:../drivers/fsl_dspi.c ****     uint32_t realDelay, bestDelay;
 432:../drivers/fsl_dspi.c ****     uint32_t diff, min_diff;
 433:../drivers/fsl_dspi.c ****     uint32_t initialDelayNanoSec;
 434:../drivers/fsl_dspi.c **** 
 435:../drivers/fsl_dspi.c ****     /* find combination of prescaler and scaler resulting in the delay closest to the
 436:../drivers/fsl_dspi.c ****     * requested value
 437:../drivers/fsl_dspi.c ****     */
 438:../drivers/fsl_dspi.c ****     min_diff = 0xFFFFFFFFU;
 439:../drivers/fsl_dspi.c ****     /* Initialize prescaler and scaler to their max values to generate the max delay */
 440:../drivers/fsl_dspi.c ****     bestPrescaler = 0x3;
 441:../drivers/fsl_dspi.c ****     bestScaler = 0xF;
 442:../drivers/fsl_dspi.c ****     bestDelay = (((1000000000U * 4) / srcClock_Hz) * s_delayPrescaler[bestPrescaler] * s_delayScale
 443:../drivers/fsl_dspi.c **** 
 444:../drivers/fsl_dspi.c ****     /* First calculate the initial, default delay */
 445:../drivers/fsl_dspi.c ****     initialDelayNanoSec = 1000000000U / srcClock_Hz * 2;
 446:../drivers/fsl_dspi.c **** 
 447:../drivers/fsl_dspi.c ****     /* If the initial, default delay is already greater than the desired delay, then
 448:../drivers/fsl_dspi.c ****     * set the delays to their initial value (0) and return the delay. In other words,
 449:../drivers/fsl_dspi.c ****     * there is no way to decrease the delay value further.
 450:../drivers/fsl_dspi.c ****     */
 451:../drivers/fsl_dspi.c ****     if (initialDelayNanoSec >= delayTimeInNanoSec)
 452:../drivers/fsl_dspi.c ****     {
 453:../drivers/fsl_dspi.c ****         DSPI_MasterSetDelayScaler(base, whichCtar, 0, 0, whichDelay);
 454:../drivers/fsl_dspi.c ****         return initialDelayNanoSec;
 455:../drivers/fsl_dspi.c ****     }
 456:../drivers/fsl_dspi.c **** 
 457:../drivers/fsl_dspi.c ****     /* In all for loops, if min_diff = 0, the exit for loop */
 458:../drivers/fsl_dspi.c ****     for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
 459:../drivers/fsl_dspi.c ****     {
 460:../drivers/fsl_dspi.c ****         for (scaler = 0; (scaler < 16) && min_diff; scaler++)
 461:../drivers/fsl_dspi.c ****         {
 462:../drivers/fsl_dspi.c ****             realDelay = ((4000000000U / srcClock_Hz) * s_delayPrescaler[prescaler] * s_delayScaler[
 463:../drivers/fsl_dspi.c **** 
 464:../drivers/fsl_dspi.c ****             /* calculate the delay difference based on the conditional statement
 465:../drivers/fsl_dspi.c ****             * that states that the calculated delay must not be less then the desired delay
 466:../drivers/fsl_dspi.c ****             */
 467:../drivers/fsl_dspi.c ****             if (realDelay >= delayTimeInNanoSec)
 468:../drivers/fsl_dspi.c ****             {
 469:../drivers/fsl_dspi.c ****                 diff = realDelay - delayTimeInNanoSec;
 470:../drivers/fsl_dspi.c ****                 if (min_diff > diff)
 471:../drivers/fsl_dspi.c ****                 {
 472:../drivers/fsl_dspi.c ****                     /* a better match found */
 473:../drivers/fsl_dspi.c ****                     min_diff = diff;
 474:../drivers/fsl_dspi.c ****                     bestPrescaler = prescaler;
 475:../drivers/fsl_dspi.c ****                     bestScaler = scaler;
 476:../drivers/fsl_dspi.c ****                     bestDelay = realDelay;
 477:../drivers/fsl_dspi.c ****                 }
 478:../drivers/fsl_dspi.c ****             }
 479:../drivers/fsl_dspi.c ****         }
 480:../drivers/fsl_dspi.c ****     }
 481:../drivers/fsl_dspi.c **** 
 482:../drivers/fsl_dspi.c ****     /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
 483:../drivers/fsl_dspi.c ****     DSPI_MasterSetDelayScaler(base, whichCtar, bestPrescaler, bestScaler, whichDelay);
 484:../drivers/fsl_dspi.c **** 
 485:../drivers/fsl_dspi.c ****     /* return the actual calculated baud rate */
 486:../drivers/fsl_dspi.c ****     return bestDelay;
 487:../drivers/fsl_dspi.c **** }
 488:../drivers/fsl_dspi.c **** 
 489:../drivers/fsl_dspi.c **** void DSPI_GetDefaultDataCommandConfig(dspi_command_data_config_t *command)
 490:../drivers/fsl_dspi.c **** {
 491:../drivers/fsl_dspi.c ****     assert(command);
 492:../drivers/fsl_dspi.c **** 
 493:../drivers/fsl_dspi.c ****     command->isPcsContinuous = false;
 494:../drivers/fsl_dspi.c ****     command->whichCtar = kDSPI_Ctar0;
 495:../drivers/fsl_dspi.c ****     command->whichPcs = kDSPI_Pcs0;
 496:../drivers/fsl_dspi.c ****     command->isEndOfQueue = false;
 497:../drivers/fsl_dspi.c ****     command->clearTransferCount = false;
 498:../drivers/fsl_dspi.c **** }
 499:../drivers/fsl_dspi.c **** 
 500:../drivers/fsl_dspi.c **** void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t dat
 501:../drivers/fsl_dspi.c **** {
 502:../drivers/fsl_dspi.c ****     assert(command);
 503:../drivers/fsl_dspi.c **** 
 504:../drivers/fsl_dspi.c ****     /* First, clear Transmit Complete Flag (TCF) */
 505:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
 506:../drivers/fsl_dspi.c **** 
 507:../drivers/fsl_dspi.c ****     while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 508:../drivers/fsl_dspi.c ****     {
 509:../drivers/fsl_dspi.c ****         DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 510:../drivers/fsl_dspi.c ****     }
 511:../drivers/fsl_dspi.c **** 
 512:../drivers/fsl_dspi.c ****     base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
 513:../drivers/fsl_dspi.c ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 514:../drivers/fsl_dspi.c ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 515:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 516:../drivers/fsl_dspi.c **** 
 517:../drivers/fsl_dspi.c ****     /* Wait till TCF sets */
 518:../drivers/fsl_dspi.c ****     while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
 519:../drivers/fsl_dspi.c ****     {
 520:../drivers/fsl_dspi.c ****     }
 521:../drivers/fsl_dspi.c **** }
 522:../drivers/fsl_dspi.c **** 
 523:../drivers/fsl_dspi.c **** void DSPI_MasterWriteCommandDataBlocking(SPI_Type *base, uint32_t data)
 524:../drivers/fsl_dspi.c **** {
 525:../drivers/fsl_dspi.c ****     /* First, clear Transmit Complete Flag (TCF) */
 526:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
 527:../drivers/fsl_dspi.c **** 
 528:../drivers/fsl_dspi.c ****     while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 529:../drivers/fsl_dspi.c ****     {
 530:../drivers/fsl_dspi.c ****         DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 531:../drivers/fsl_dspi.c ****     }
 532:../drivers/fsl_dspi.c **** 
 533:../drivers/fsl_dspi.c ****     base->PUSHR = data;
 534:../drivers/fsl_dspi.c **** 
 535:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 536:../drivers/fsl_dspi.c **** 
 537:../drivers/fsl_dspi.c ****     /* Wait till TCF sets */
 538:../drivers/fsl_dspi.c ****     while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
 539:../drivers/fsl_dspi.c ****     {
 540:../drivers/fsl_dspi.c ****     }
 541:../drivers/fsl_dspi.c **** }
 542:../drivers/fsl_dspi.c **** 
 543:../drivers/fsl_dspi.c **** void DSPI_SlaveWriteDataBlocking(SPI_Type *base, uint32_t data)
 544:../drivers/fsl_dspi.c **** {
 545:../drivers/fsl_dspi.c ****     /* First, clear Transmit Complete Flag (TCF) */
 546:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
 547:../drivers/fsl_dspi.c **** 
 548:../drivers/fsl_dspi.c ****     while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 549:../drivers/fsl_dspi.c ****     {
 550:../drivers/fsl_dspi.c ****         DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 551:../drivers/fsl_dspi.c ****     }
 552:../drivers/fsl_dspi.c **** 
 553:../drivers/fsl_dspi.c ****     base->PUSHR_SLAVE = data;
 554:../drivers/fsl_dspi.c **** 
 555:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 556:../drivers/fsl_dspi.c **** 
 557:../drivers/fsl_dspi.c ****     /* Wait till TCF sets */
 558:../drivers/fsl_dspi.c ****     while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
 559:../drivers/fsl_dspi.c ****     {
 560:../drivers/fsl_dspi.c ****     }
 561:../drivers/fsl_dspi.c **** }
 562:../drivers/fsl_dspi.c **** 
 563:../drivers/fsl_dspi.c **** void DSPI_EnableInterrupts(SPI_Type *base, uint32_t mask)
 564:../drivers/fsl_dspi.c **** {
 565:../drivers/fsl_dspi.c ****     if (mask & SPI_RSER_TFFF_RE_MASK)
 566:../drivers/fsl_dspi.c ****     {
 567:../drivers/fsl_dspi.c ****         base->RSER &= ~SPI_RSER_TFFF_DIRS_MASK;
 568:../drivers/fsl_dspi.c ****     }
 569:../drivers/fsl_dspi.c ****     if (mask & SPI_RSER_RFDF_RE_MASK)
 570:../drivers/fsl_dspi.c ****     {
 571:../drivers/fsl_dspi.c ****         base->RSER &= ~SPI_RSER_RFDF_DIRS_MASK;
 572:../drivers/fsl_dspi.c ****     }
 573:../drivers/fsl_dspi.c ****     base->RSER |= mask;
 574:../drivers/fsl_dspi.c **** }
 575:../drivers/fsl_dspi.c **** 
 576:../drivers/fsl_dspi.c **** /*Transactional APIs -- Master*/
 577:../drivers/fsl_dspi.c **** 
 578:../drivers/fsl_dspi.c **** void DSPI_MasterTransferCreateHandle(SPI_Type *base,
 579:../drivers/fsl_dspi.c ****                                      dspi_master_handle_t *handle,
 580:../drivers/fsl_dspi.c ****                                      dspi_master_transfer_callback_t callback,
 581:../drivers/fsl_dspi.c ****                                      void *userData)
 582:../drivers/fsl_dspi.c **** {
 583:../drivers/fsl_dspi.c ****     assert(handle);
 584:../drivers/fsl_dspi.c **** 
 585:../drivers/fsl_dspi.c ****     /* Zero the handle. */
 586:../drivers/fsl_dspi.c ****     memset(handle, 0, sizeof(*handle));
 587:../drivers/fsl_dspi.c **** 
 588:../drivers/fsl_dspi.c ****     g_dspiHandle[DSPI_GetInstance(base)] = handle;
 589:../drivers/fsl_dspi.c **** 
 590:../drivers/fsl_dspi.c ****     handle->callback = callback;
 591:../drivers/fsl_dspi.c ****     handle->userData = userData;
 592:../drivers/fsl_dspi.c **** }
 593:../drivers/fsl_dspi.c **** 
 594:../drivers/fsl_dspi.c **** status_t DSPI_MasterTransferBlocking(SPI_Type *base, dspi_transfer_t *transfer)
 595:../drivers/fsl_dspi.c **** {
 596:../drivers/fsl_dspi.c ****     assert(transfer);
 597:../drivers/fsl_dspi.c **** 
 598:../drivers/fsl_dspi.c ****     uint16_t wordToSend = 0;
 599:../drivers/fsl_dspi.c ****     uint16_t wordReceived = 0;
 600:../drivers/fsl_dspi.c ****     uint8_t dummyData = s_dummyData[DSPI_GetInstance(base)];
 601:../drivers/fsl_dspi.c ****     uint8_t bitsPerFrame;
 602:../drivers/fsl_dspi.c **** 
 603:../drivers/fsl_dspi.c ****     uint32_t command;
 604:../drivers/fsl_dspi.c ****     uint32_t lastCommand;
 605:../drivers/fsl_dspi.c **** 
 606:../drivers/fsl_dspi.c ****     uint8_t *txData;
 607:../drivers/fsl_dspi.c ****     uint8_t *rxData;
 608:../drivers/fsl_dspi.c ****     uint32_t remainingSendByteCount;
 609:../drivers/fsl_dspi.c ****     uint32_t remainingReceiveByteCount;
 610:../drivers/fsl_dspi.c **** 
 611:../drivers/fsl_dspi.c ****     uint32_t fifoSize;
 612:../drivers/fsl_dspi.c ****     dspi_command_data_config_t commandStruct;
 613:../drivers/fsl_dspi.c **** 
 614:../drivers/fsl_dspi.c ****     /* If the transfer count is zero, then return immediately.*/
 615:../drivers/fsl_dspi.c ****     if (transfer->dataSize == 0)
 616:../drivers/fsl_dspi.c ****     {
 617:../drivers/fsl_dspi.c ****         return kStatus_InvalidArgument;
 618:../drivers/fsl_dspi.c ****     }
 619:../drivers/fsl_dspi.c **** 
 620:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 621:../drivers/fsl_dspi.c ****     DSPI_DisableInterrupts(base, kDSPI_AllInterruptEnable);
 622:../drivers/fsl_dspi.c ****     DSPI_FlushFifo(base, true, true);
 623:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
 624:../drivers/fsl_dspi.c **** 
 625:../drivers/fsl_dspi.c ****     /*Calculate the command and lastCommand*/
 626:../drivers/fsl_dspi.c ****     commandStruct.whichPcs =
 627:../drivers/fsl_dspi.c ****         (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS
 628:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 629:../drivers/fsl_dspi.c ****     commandStruct.clearTransferCount = false;
 630:../drivers/fsl_dspi.c ****     commandStruct.whichCtar =
 631:../drivers/fsl_dspi.c ****         (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR
 632:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 633:../drivers/fsl_dspi.c **** 
 634:../drivers/fsl_dspi.c ****     command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 635:../drivers/fsl_dspi.c **** 
 636:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = true;
 637:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer)
 638:../drivers/fsl_dspi.c ****     lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 639:../drivers/fsl_dspi.c **** 
 640:../drivers/fsl_dspi.c ****     /*Calculate the bitsPerFrame*/
 641:../drivers/fsl_dspi.c ****     bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHI
 642:../drivers/fsl_dspi.c **** 
 643:../drivers/fsl_dspi.c ****     txData = transfer->txData;
 644:../drivers/fsl_dspi.c ****     rxData = transfer->rxData;
 645:../drivers/fsl_dspi.c ****     remainingSendByteCount = transfer->dataSize;
 646:../drivers/fsl_dspi.c ****     remainingReceiveByteCount = transfer->dataSize;
 647:../drivers/fsl_dspi.c **** 
 648:../drivers/fsl_dspi.c ****     if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
 649:../drivers/fsl_dspi.c ****     {
 650:../drivers/fsl_dspi.c ****         fifoSize = 1;
 651:../drivers/fsl_dspi.c ****     }
 652:../drivers/fsl_dspi.c ****     else
 653:../drivers/fsl_dspi.c ****     {
 654:../drivers/fsl_dspi.c ****         fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
 655:../drivers/fsl_dspi.c ****     }
 656:../drivers/fsl_dspi.c **** 
 657:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
 658:../drivers/fsl_dspi.c **** 
 659:../drivers/fsl_dspi.c ****     if (bitsPerFrame <= 8)
 660:../drivers/fsl_dspi.c ****     {
 661:../drivers/fsl_dspi.c ****         while (remainingSendByteCount > 0)
 662:../drivers/fsl_dspi.c ****         {
 663:../drivers/fsl_dspi.c ****             if (remainingSendByteCount == 1)
 664:../drivers/fsl_dspi.c ****             {
 665:../drivers/fsl_dspi.c ****                 while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 666:../drivers/fsl_dspi.c ****                 {
 667:../drivers/fsl_dspi.c ****                     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 668:../drivers/fsl_dspi.c ****                 }
 669:../drivers/fsl_dspi.c **** 
 670:../drivers/fsl_dspi.c ****                 if (txData != NULL)
 671:../drivers/fsl_dspi.c ****                 {
 672:../drivers/fsl_dspi.c ****                     base->PUSHR = (*txData) | (lastCommand);
 673:../drivers/fsl_dspi.c ****                     txData++;
 674:../drivers/fsl_dspi.c ****                 }
 675:../drivers/fsl_dspi.c ****                 else
 676:../drivers/fsl_dspi.c ****                 {
 677:../drivers/fsl_dspi.c ****                     base->PUSHR = (lastCommand) | (dummyData);
 678:../drivers/fsl_dspi.c ****                 }
 679:../drivers/fsl_dspi.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 680:../drivers/fsl_dspi.c ****                 remainingSendByteCount--;
 681:../drivers/fsl_dspi.c **** 
 682:../drivers/fsl_dspi.c ****                 while (remainingReceiveByteCount > 0)
 683:../drivers/fsl_dspi.c ****                 {
 684:../drivers/fsl_dspi.c ****                     if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
 685:../drivers/fsl_dspi.c ****                     {
 686:../drivers/fsl_dspi.c ****                         if (rxData != NULL)
 687:../drivers/fsl_dspi.c ****                         {
 688:../drivers/fsl_dspi.c ****                             /* Read data from POPR*/
 689:../drivers/fsl_dspi.c ****                             *(rxData) = DSPI_ReadData(base);
 690:../drivers/fsl_dspi.c ****                             rxData++;
 691:../drivers/fsl_dspi.c ****                         }
 692:../drivers/fsl_dspi.c ****                         else
 693:../drivers/fsl_dspi.c ****                         {
 694:../drivers/fsl_dspi.c ****                             DSPI_ReadData(base);
 695:../drivers/fsl_dspi.c ****                         }
 696:../drivers/fsl_dspi.c ****                         remainingReceiveByteCount--;
 697:../drivers/fsl_dspi.c **** 
 698:../drivers/fsl_dspi.c ****                         DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
 699:../drivers/fsl_dspi.c ****                     }
 700:../drivers/fsl_dspi.c ****                 }
 701:../drivers/fsl_dspi.c ****             }
 702:../drivers/fsl_dspi.c ****             else
 703:../drivers/fsl_dspi.c ****             {
 704:../drivers/fsl_dspi.c ****                 /*Wait until Tx Fifo is not full*/
 705:../drivers/fsl_dspi.c ****                 while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 706:../drivers/fsl_dspi.c ****                 {
 707:../drivers/fsl_dspi.c ****                     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 708:../drivers/fsl_dspi.c ****                 }
 709:../drivers/fsl_dspi.c ****                 if (txData != NULL)
 710:../drivers/fsl_dspi.c ****                 {
 711:../drivers/fsl_dspi.c ****                     base->PUSHR = command | (uint16_t)(*txData);
 712:../drivers/fsl_dspi.c ****                     txData++;
 713:../drivers/fsl_dspi.c ****                 }
 714:../drivers/fsl_dspi.c ****                 else
 715:../drivers/fsl_dspi.c ****                 {
 716:../drivers/fsl_dspi.c ****                     base->PUSHR = command | dummyData;
 717:../drivers/fsl_dspi.c ****                 }
 718:../drivers/fsl_dspi.c ****                 remainingSendByteCount--;
 719:../drivers/fsl_dspi.c **** 
 720:../drivers/fsl_dspi.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 721:../drivers/fsl_dspi.c **** 
 722:../drivers/fsl_dspi.c ****                 while ((remainingReceiveByteCount - remainingSendByteCount) >= fifoSize)
 723:../drivers/fsl_dspi.c ****                 {
 724:../drivers/fsl_dspi.c ****                     if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
 725:../drivers/fsl_dspi.c ****                     {
 726:../drivers/fsl_dspi.c ****                         if (rxData != NULL)
 727:../drivers/fsl_dspi.c ****                         {
 728:../drivers/fsl_dspi.c ****                             *(rxData) = DSPI_ReadData(base);
 729:../drivers/fsl_dspi.c ****                             rxData++;
 730:../drivers/fsl_dspi.c ****                         }
 731:../drivers/fsl_dspi.c ****                         else
 732:../drivers/fsl_dspi.c ****                         {
 733:../drivers/fsl_dspi.c ****                             DSPI_ReadData(base);
 734:../drivers/fsl_dspi.c ****                         }
 735:../drivers/fsl_dspi.c ****                         remainingReceiveByteCount--;
 736:../drivers/fsl_dspi.c **** 
 737:../drivers/fsl_dspi.c ****                         DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
 738:../drivers/fsl_dspi.c ****                     }
 739:../drivers/fsl_dspi.c ****                 }
 740:../drivers/fsl_dspi.c ****             }
 741:../drivers/fsl_dspi.c ****         }
 742:../drivers/fsl_dspi.c ****     }
 743:../drivers/fsl_dspi.c ****     else
 744:../drivers/fsl_dspi.c ****     {
 745:../drivers/fsl_dspi.c ****         while (remainingSendByteCount > 0)
 746:../drivers/fsl_dspi.c ****         {
 747:../drivers/fsl_dspi.c ****             if (remainingSendByteCount <= 2)
 748:../drivers/fsl_dspi.c ****             {
 749:../drivers/fsl_dspi.c ****                 while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 750:../drivers/fsl_dspi.c ****                 {
 751:../drivers/fsl_dspi.c ****                     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 752:../drivers/fsl_dspi.c ****                 }
 753:../drivers/fsl_dspi.c **** 
 754:../drivers/fsl_dspi.c ****                 if (txData != NULL)
 755:../drivers/fsl_dspi.c ****                 {
 756:../drivers/fsl_dspi.c ****                     wordToSend = *(txData);
 757:../drivers/fsl_dspi.c ****                     ++txData;
 758:../drivers/fsl_dspi.c **** 
 759:../drivers/fsl_dspi.c ****                     if (remainingSendByteCount > 1)
 760:../drivers/fsl_dspi.c ****                     {
 761:../drivers/fsl_dspi.c ****                         wordToSend |= (unsigned)(*(txData)) << 8U;
 762:../drivers/fsl_dspi.c ****                         ++txData;
 763:../drivers/fsl_dspi.c ****                     }
 764:../drivers/fsl_dspi.c ****                 }
 765:../drivers/fsl_dspi.c ****                 else
 766:../drivers/fsl_dspi.c ****                 {
 767:../drivers/fsl_dspi.c ****                     wordToSend = dummyData;
 768:../drivers/fsl_dspi.c ****                 }
 769:../drivers/fsl_dspi.c **** 
 770:../drivers/fsl_dspi.c ****                 base->PUSHR = lastCommand | wordToSend;
 771:../drivers/fsl_dspi.c **** 
 772:../drivers/fsl_dspi.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 773:../drivers/fsl_dspi.c ****                 remainingSendByteCount = 0;
 774:../drivers/fsl_dspi.c **** 
 775:../drivers/fsl_dspi.c ****                 while (remainingReceiveByteCount > 0)
 776:../drivers/fsl_dspi.c ****                 {
 777:../drivers/fsl_dspi.c ****                     if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
 778:../drivers/fsl_dspi.c ****                     {
 779:../drivers/fsl_dspi.c ****                         wordReceived = DSPI_ReadData(base);
 780:../drivers/fsl_dspi.c **** 
 781:../drivers/fsl_dspi.c ****                         if (remainingReceiveByteCount != 1)
 782:../drivers/fsl_dspi.c ****                         {
 783:../drivers/fsl_dspi.c ****                             if (rxData != NULL)
 784:../drivers/fsl_dspi.c ****                             {
 785:../drivers/fsl_dspi.c ****                                 *(rxData) = wordReceived;
 786:../drivers/fsl_dspi.c ****                                 ++rxData;
 787:../drivers/fsl_dspi.c ****                                 *(rxData) = wordReceived >> 8;
 788:../drivers/fsl_dspi.c ****                                 ++rxData;
 789:../drivers/fsl_dspi.c ****                             }
 790:../drivers/fsl_dspi.c ****                             remainingReceiveByteCount -= 2;
 791:../drivers/fsl_dspi.c ****                         }
 792:../drivers/fsl_dspi.c ****                         else
 793:../drivers/fsl_dspi.c ****                         {
 794:../drivers/fsl_dspi.c ****                             if (rxData != NULL)
 795:../drivers/fsl_dspi.c ****                             {
 796:../drivers/fsl_dspi.c ****                                 *(rxData) = wordReceived;
 797:../drivers/fsl_dspi.c ****                                 ++rxData;
 798:../drivers/fsl_dspi.c ****                             }
 799:../drivers/fsl_dspi.c ****                             remainingReceiveByteCount--;
 800:../drivers/fsl_dspi.c ****                         }
 801:../drivers/fsl_dspi.c ****                         DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
 802:../drivers/fsl_dspi.c ****                     }
 803:../drivers/fsl_dspi.c ****                 }
 804:../drivers/fsl_dspi.c ****             }
 805:../drivers/fsl_dspi.c ****             else
 806:../drivers/fsl_dspi.c ****             {
 807:../drivers/fsl_dspi.c ****                 /*Wait until Tx Fifo is not full*/
 808:../drivers/fsl_dspi.c ****                 while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
 809:../drivers/fsl_dspi.c ****                 {
 810:../drivers/fsl_dspi.c ****                     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 811:../drivers/fsl_dspi.c ****                 }
 812:../drivers/fsl_dspi.c **** 
 813:../drivers/fsl_dspi.c ****                 if (txData != NULL)
 814:../drivers/fsl_dspi.c ****                 {
 815:../drivers/fsl_dspi.c ****                     wordToSend = *(txData);
 816:../drivers/fsl_dspi.c ****                     ++txData;
 817:../drivers/fsl_dspi.c ****                     wordToSend |= (unsigned)(*(txData)) << 8U;
 818:../drivers/fsl_dspi.c ****                     ++txData;
 819:../drivers/fsl_dspi.c ****                 }
 820:../drivers/fsl_dspi.c ****                 else
 821:../drivers/fsl_dspi.c ****                 {
 822:../drivers/fsl_dspi.c ****                     wordToSend = dummyData;
 823:../drivers/fsl_dspi.c ****                 }
 824:../drivers/fsl_dspi.c ****                 base->PUSHR = command | wordToSend;
 825:../drivers/fsl_dspi.c ****                 remainingSendByteCount -= 2;
 826:../drivers/fsl_dspi.c **** 
 827:../drivers/fsl_dspi.c ****                 DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 828:../drivers/fsl_dspi.c **** 
 829:../drivers/fsl_dspi.c ****                 while (((remainingReceiveByteCount - remainingSendByteCount) / 2) >= fifoSize)
 830:../drivers/fsl_dspi.c ****                 {
 831:../drivers/fsl_dspi.c ****                     if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
 832:../drivers/fsl_dspi.c ****                     {
 833:../drivers/fsl_dspi.c ****                         wordReceived = DSPI_ReadData(base);
 834:../drivers/fsl_dspi.c **** 
 835:../drivers/fsl_dspi.c ****                         if (rxData != NULL)
 836:../drivers/fsl_dspi.c ****                         {
 837:../drivers/fsl_dspi.c ****                             *rxData = wordReceived;
 838:../drivers/fsl_dspi.c ****                             ++rxData;
 839:../drivers/fsl_dspi.c ****                             *rxData = wordReceived >> 8;
 840:../drivers/fsl_dspi.c ****                             ++rxData;
 841:../drivers/fsl_dspi.c ****                         }
 842:../drivers/fsl_dspi.c ****                         remainingReceiveByteCount -= 2;
 843:../drivers/fsl_dspi.c **** 
 844:../drivers/fsl_dspi.c ****                         DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
 845:../drivers/fsl_dspi.c ****                     }
 846:../drivers/fsl_dspi.c ****                 }
 847:../drivers/fsl_dspi.c ****             }
 848:../drivers/fsl_dspi.c ****         }
 849:../drivers/fsl_dspi.c ****     }
 850:../drivers/fsl_dspi.c **** 
 851:../drivers/fsl_dspi.c ****     return kStatus_Success;
 852:../drivers/fsl_dspi.c **** }
 853:../drivers/fsl_dspi.c **** 
 854:../drivers/fsl_dspi.c **** static void DSPI_MasterTransferPrepare(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_
 855:../drivers/fsl_dspi.c **** {
 856:../drivers/fsl_dspi.c ****     assert(handle);
 857:../drivers/fsl_dspi.c ****     assert(transfer);
 858:../drivers/fsl_dspi.c **** 
 859:../drivers/fsl_dspi.c ****     dspi_command_data_config_t commandStruct;
 860:../drivers/fsl_dspi.c **** 
 861:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 862:../drivers/fsl_dspi.c ****     DSPI_FlushFifo(base, true, true);
 863:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
 864:../drivers/fsl_dspi.c **** 
 865:../drivers/fsl_dspi.c ****     commandStruct.whichPcs =
 866:../drivers/fsl_dspi.c ****         (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS
 867:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 868:../drivers/fsl_dspi.c ****     commandStruct.clearTransferCount = false;
 869:../drivers/fsl_dspi.c ****     commandStruct.whichCtar =
 870:../drivers/fsl_dspi.c ****         (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR
 871:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 872:../drivers/fsl_dspi.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 873:../drivers/fsl_dspi.c **** 
 874:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = true;
 875:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer)
 876:../drivers/fsl_dspi.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 877:../drivers/fsl_dspi.c **** 
 878:../drivers/fsl_dspi.c ****     handle->bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_
 879:../drivers/fsl_dspi.c **** 
 880:../drivers/fsl_dspi.c ****     if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
 881:../drivers/fsl_dspi.c ****     {
 882:../drivers/fsl_dspi.c ****         handle->fifoSize = 1;
 883:../drivers/fsl_dspi.c ****     }
 884:../drivers/fsl_dspi.c ****     else
 885:../drivers/fsl_dspi.c ****     {
 886:../drivers/fsl_dspi.c ****         handle->fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
 887:../drivers/fsl_dspi.c ****     }
 888:../drivers/fsl_dspi.c ****     handle->txData = transfer->txData;
 889:../drivers/fsl_dspi.c ****     handle->rxData = transfer->rxData;
 890:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = transfer->dataSize;
 891:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 892:../drivers/fsl_dspi.c ****     handle->totalByteCount = transfer->dataSize;
 893:../drivers/fsl_dspi.c **** }
 894:../drivers/fsl_dspi.c **** 
 895:../drivers/fsl_dspi.c **** status_t DSPI_MasterTransferNonBlocking(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer
 896:../drivers/fsl_dspi.c **** {
 897:../drivers/fsl_dspi.c ****     assert(handle);
 898:../drivers/fsl_dspi.c ****     assert(transfer);
 899:../drivers/fsl_dspi.c **** 
 900:../drivers/fsl_dspi.c ****     /* If the transfer count is zero, then return immediately.*/
 901:../drivers/fsl_dspi.c ****     if (transfer->dataSize == 0)
 902:../drivers/fsl_dspi.c ****     {
 903:../drivers/fsl_dspi.c ****         return kStatus_InvalidArgument;
 904:../drivers/fsl_dspi.c ****     }
 905:../drivers/fsl_dspi.c **** 
 906:../drivers/fsl_dspi.c ****     /* Check that we're not busy.*/
 907:../drivers/fsl_dspi.c ****     if (handle->state == kDSPI_Busy)
 908:../drivers/fsl_dspi.c ****     {
 909:../drivers/fsl_dspi.c ****         return kStatus_DSPI_Busy;
 910:../drivers/fsl_dspi.c ****     }
 911:../drivers/fsl_dspi.c **** 
 912:../drivers/fsl_dspi.c ****     handle->state = kDSPI_Busy;
 913:../drivers/fsl_dspi.c **** 
 914:../drivers/fsl_dspi.c ****     /* Disable the NVIC for DSPI peripheral. */
 915:../drivers/fsl_dspi.c ****     DisableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
 916:../drivers/fsl_dspi.c **** 
 917:../drivers/fsl_dspi.c ****     DSPI_MasterTransferPrepare(base, handle, transfer);
 918:../drivers/fsl_dspi.c **** 
 919:../drivers/fsl_dspi.c ****     /* RX FIFO Drain request: RFDF_RE to enable RFDF interrupt
 920:../drivers/fsl_dspi.c ****     * Since SPI is a synchronous interface, we only need to enable the RX interrupt.
 921:../drivers/fsl_dspi.c ****     * The IRQ handler will get the status of RX and TX interrupt flags.
 922:../drivers/fsl_dspi.c ****     */
 923:../drivers/fsl_dspi.c ****     s_dspiMasterIsr = DSPI_MasterTransferHandleIRQ;
 924:../drivers/fsl_dspi.c **** 
 925:../drivers/fsl_dspi.c ****     DSPI_EnableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable);
 926:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
 927:../drivers/fsl_dspi.c **** 
 928:../drivers/fsl_dspi.c ****     /* Fill up the Tx FIFO to trigger the transfer. */
 929:../drivers/fsl_dspi.c ****     DSPI_MasterTransferFillUpTxFifo(base, handle);
 930:../drivers/fsl_dspi.c **** 
 931:../drivers/fsl_dspi.c ****     /* Enable the NVIC for DSPI peripheral. */
 932:../drivers/fsl_dspi.c ****     EnableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
 933:../drivers/fsl_dspi.c **** 
 934:../drivers/fsl_dspi.c ****     return kStatus_Success;
 935:../drivers/fsl_dspi.c **** }
 936:../drivers/fsl_dspi.c **** 
 937:../drivers/fsl_dspi.c **** status_t DSPI_MasterHalfDuplexTransferBlocking(SPI_Type *base, dspi_half_duplex_transfer_t *xfer)
 938:../drivers/fsl_dspi.c **** {
 939:../drivers/fsl_dspi.c ****     assert(xfer);
 940:../drivers/fsl_dspi.c **** 
 941:../drivers/fsl_dspi.c ****     dspi_transfer_t tempXfer = {0};
 942:../drivers/fsl_dspi.c ****     status_t status;
 943:../drivers/fsl_dspi.c **** 
 944:../drivers/fsl_dspi.c ****     if (xfer->isTransmitFirst)
 945:../drivers/fsl_dspi.c ****     {
 946:../drivers/fsl_dspi.c ****         tempXfer.txData = xfer->txData;
 947:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
 948:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->txDataSize;
 949:../drivers/fsl_dspi.c ****     }
 950:../drivers/fsl_dspi.c ****     else
 951:../drivers/fsl_dspi.c ****     {
 952:../drivers/fsl_dspi.c ****         tempXfer.txData = NULL;
 953:../drivers/fsl_dspi.c ****         tempXfer.rxData = xfer->rxData;
 954:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
 955:../drivers/fsl_dspi.c ****     }
 956:../drivers/fsl_dspi.c ****     /* If the pcs pin keep assert between transmit and receive. */
 957:../drivers/fsl_dspi.c ****     if (xfer->isPcsAssertInTransfer)
 958:../drivers/fsl_dspi.c ****     {
 959:../drivers/fsl_dspi.c ****         tempXfer.configFlags = (xfer->configFlags) | kDSPI_MasterActiveAfterTransfer;
 960:../drivers/fsl_dspi.c ****     }
 961:../drivers/fsl_dspi.c ****     else
 962:../drivers/fsl_dspi.c ****     {
 963:../drivers/fsl_dspi.c ****         tempXfer.configFlags = (xfer->configFlags) & (uint32_t)(~kDSPI_MasterActiveAfterTransfer);
 964:../drivers/fsl_dspi.c ****     }
 965:../drivers/fsl_dspi.c **** 
 966:../drivers/fsl_dspi.c ****     status = DSPI_MasterTransferBlocking(base, &tempXfer);
 967:../drivers/fsl_dspi.c ****     if (status != kStatus_Success)
 968:../drivers/fsl_dspi.c ****     {
 969:../drivers/fsl_dspi.c ****         return status;
 970:../drivers/fsl_dspi.c ****     }
 971:../drivers/fsl_dspi.c **** 
 972:../drivers/fsl_dspi.c ****     if (xfer->isTransmitFirst)
 973:../drivers/fsl_dspi.c ****     {
 974:../drivers/fsl_dspi.c ****         tempXfer.txData = NULL;
 975:../drivers/fsl_dspi.c ****         tempXfer.rxData = xfer->rxData;
 976:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
 977:../drivers/fsl_dspi.c ****     }
 978:../drivers/fsl_dspi.c ****     else
 979:../drivers/fsl_dspi.c ****     {
 980:../drivers/fsl_dspi.c ****         tempXfer.txData = xfer->txData;
 981:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
 982:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->txDataSize;
 983:../drivers/fsl_dspi.c ****     }
 984:../drivers/fsl_dspi.c ****     tempXfer.configFlags = xfer->configFlags;
 985:../drivers/fsl_dspi.c **** 
 986:../drivers/fsl_dspi.c ****     /* DSPI transfer blocking. */
 987:../drivers/fsl_dspi.c ****     status = DSPI_MasterTransferBlocking(base, &tempXfer);
 988:../drivers/fsl_dspi.c **** 
 989:../drivers/fsl_dspi.c ****     return status;
 990:../drivers/fsl_dspi.c **** }
 991:../drivers/fsl_dspi.c **** 
 992:../drivers/fsl_dspi.c **** status_t DSPI_MasterHalfDuplexTransferNonBlocking(SPI_Type *base,
 993:../drivers/fsl_dspi.c ****                                                   dspi_master_handle_t *handle,
 994:../drivers/fsl_dspi.c ****                                                   dspi_half_duplex_transfer_t *xfer)
 995:../drivers/fsl_dspi.c **** {
 996:../drivers/fsl_dspi.c ****     assert(xfer);
 997:../drivers/fsl_dspi.c ****     assert(handle);
 998:../drivers/fsl_dspi.c ****     dspi_transfer_t tempXfer = {0};
 999:../drivers/fsl_dspi.c ****     status_t status;
1000:../drivers/fsl_dspi.c **** 
1001:../drivers/fsl_dspi.c ****     if (xfer->isTransmitFirst)
1002:../drivers/fsl_dspi.c ****     {
1003:../drivers/fsl_dspi.c ****         tempXfer.txData = xfer->txData;
1004:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
1005:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->txDataSize;
1006:../drivers/fsl_dspi.c ****     }
1007:../drivers/fsl_dspi.c ****     else
1008:../drivers/fsl_dspi.c ****     {
1009:../drivers/fsl_dspi.c ****         tempXfer.txData = NULL;
1010:../drivers/fsl_dspi.c ****         tempXfer.rxData = xfer->rxData;
1011:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
1012:../drivers/fsl_dspi.c ****     }
1013:../drivers/fsl_dspi.c ****     /* If the pcs pin keep assert between transmit and receive. */
1014:../drivers/fsl_dspi.c ****     if (xfer->isPcsAssertInTransfer)
1015:../drivers/fsl_dspi.c ****     {
1016:../drivers/fsl_dspi.c ****         tempXfer.configFlags = (xfer->configFlags) | kDSPI_MasterActiveAfterTransfer;
1017:../drivers/fsl_dspi.c ****     }
1018:../drivers/fsl_dspi.c ****     else
1019:../drivers/fsl_dspi.c ****     {
1020:../drivers/fsl_dspi.c ****         tempXfer.configFlags = (xfer->configFlags) & (uint32_t)(~kDSPI_MasterActiveAfterTransfer);
1021:../drivers/fsl_dspi.c ****     }
1022:../drivers/fsl_dspi.c **** 
1023:../drivers/fsl_dspi.c ****     status = DSPI_MasterTransferBlocking(base, &tempXfer);
1024:../drivers/fsl_dspi.c ****     if (status != kStatus_Success)
1025:../drivers/fsl_dspi.c ****     {
1026:../drivers/fsl_dspi.c ****         return status;
1027:../drivers/fsl_dspi.c ****     }
1028:../drivers/fsl_dspi.c **** 
1029:../drivers/fsl_dspi.c ****     if (xfer->isTransmitFirst)
1030:../drivers/fsl_dspi.c ****     {
1031:../drivers/fsl_dspi.c ****         tempXfer.txData = NULL;
1032:../drivers/fsl_dspi.c ****         tempXfer.rxData = xfer->rxData;
1033:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
1034:../drivers/fsl_dspi.c ****     }
1035:../drivers/fsl_dspi.c ****     else
1036:../drivers/fsl_dspi.c ****     {
1037:../drivers/fsl_dspi.c ****         tempXfer.txData = xfer->txData;
1038:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
1039:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->txDataSize;
1040:../drivers/fsl_dspi.c ****     }
1041:../drivers/fsl_dspi.c ****     tempXfer.configFlags = xfer->configFlags;
1042:../drivers/fsl_dspi.c **** 
1043:../drivers/fsl_dspi.c ****     status = DSPI_MasterTransferNonBlocking(base, handle, &tempXfer);
1044:../drivers/fsl_dspi.c **** 
1045:../drivers/fsl_dspi.c ****     return status;
1046:../drivers/fsl_dspi.c **** }
1047:../drivers/fsl_dspi.c **** 
1048:../drivers/fsl_dspi.c **** status_t DSPI_MasterTransferGetCount(SPI_Type *base, dspi_master_handle_t *handle, size_t *count)
1049:../drivers/fsl_dspi.c **** {
1050:../drivers/fsl_dspi.c ****     assert(handle);
1051:../drivers/fsl_dspi.c **** 
1052:../drivers/fsl_dspi.c ****     if (!count)
1053:../drivers/fsl_dspi.c ****     {
1054:../drivers/fsl_dspi.c ****         return kStatus_InvalidArgument;
1055:../drivers/fsl_dspi.c ****     }
1056:../drivers/fsl_dspi.c **** 
1057:../drivers/fsl_dspi.c ****     /* Catch when there is not an active transfer. */
1058:../drivers/fsl_dspi.c ****     if (handle->state != kDSPI_Busy)
1059:../drivers/fsl_dspi.c ****     {
1060:../drivers/fsl_dspi.c ****         *count = 0;
1061:../drivers/fsl_dspi.c ****         return kStatus_NoTransferInProgress;
1062:../drivers/fsl_dspi.c ****     }
1063:../drivers/fsl_dspi.c **** 
1064:../drivers/fsl_dspi.c ****     *count = handle->totalByteCount - handle->remainingReceiveByteCount;
1065:../drivers/fsl_dspi.c ****     return kStatus_Success;
1066:../drivers/fsl_dspi.c **** }
1067:../drivers/fsl_dspi.c **** 
1068:../drivers/fsl_dspi.c **** static void DSPI_MasterTransferComplete(SPI_Type *base, dspi_master_handle_t *handle)
1069:../drivers/fsl_dspi.c **** {
1070:../drivers/fsl_dspi.c ****     assert(handle);
1071:../drivers/fsl_dspi.c **** 
1072:../drivers/fsl_dspi.c ****     /* Disable interrupt requests*/
1073:../drivers/fsl_dspi.c ****     DSPI_DisableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable | kDSPI_TxFifoFillRequestI
1074:../drivers/fsl_dspi.c **** 
1075:../drivers/fsl_dspi.c ****     status_t status = 0;
1076:../drivers/fsl_dspi.c ****     if (handle->state == kDSPI_Error)
1077:../drivers/fsl_dspi.c ****     {
1078:../drivers/fsl_dspi.c ****         status = kStatus_DSPI_Error;
1079:../drivers/fsl_dspi.c ****     }
1080:../drivers/fsl_dspi.c ****     else
1081:../drivers/fsl_dspi.c ****     {
1082:../drivers/fsl_dspi.c ****         status = kStatus_Success;
1083:../drivers/fsl_dspi.c ****     }
1084:../drivers/fsl_dspi.c **** 
1085:../drivers/fsl_dspi.c ****     handle->state = kDSPI_Idle;
1086:../drivers/fsl_dspi.c **** 
1087:../drivers/fsl_dspi.c ****     if (handle->callback)
1088:../drivers/fsl_dspi.c ****     {
1089:../drivers/fsl_dspi.c ****         handle->callback(base, handle, status, handle->userData);
1090:../drivers/fsl_dspi.c ****     }
1091:../drivers/fsl_dspi.c **** }
1092:../drivers/fsl_dspi.c **** 
1093:../drivers/fsl_dspi.c **** static void DSPI_MasterTransferFillUpTxFifo(SPI_Type *base, dspi_master_handle_t *handle)
1094:../drivers/fsl_dspi.c **** {
1095:../drivers/fsl_dspi.c ****     assert(handle);
1096:../drivers/fsl_dspi.c **** 
1097:../drivers/fsl_dspi.c ****     uint16_t wordToSend = 0;
1098:../drivers/fsl_dspi.c ****     uint8_t dummyData = s_dummyData[DSPI_GetInstance(base)];
1099:../drivers/fsl_dspi.c **** 
1100:../drivers/fsl_dspi.c ****     /* If bits/frame is greater than one byte */
1101:../drivers/fsl_dspi.c ****     if (handle->bitsPerFrame > 8)
1102:../drivers/fsl_dspi.c ****     {
1103:../drivers/fsl_dspi.c ****         /* Fill the fifo until it is full or until the send word count is 0 or until the difference
1104:../drivers/fsl_dspi.c ****         * between the remainingReceiveByteCount and remainingSendByteCount equals the FIFO depth.
1105:../drivers/fsl_dspi.c ****         * The reason for checking the difference is to ensure we only send as much as the
1106:../drivers/fsl_dspi.c ****         * RX FIFO can receive.
1107:../drivers/fsl_dspi.c ****         * For this case where bitsPerFrame > 8, each entry in the FIFO contains 2 bytes of the
1108:../drivers/fsl_dspi.c ****         * send data, hence the difference between the remainingReceiveByteCount and
1109:../drivers/fsl_dspi.c ****         * remainingSendByteCount must be divided by 2 to convert this difference into a
1110:../drivers/fsl_dspi.c ****         * 16-bit (2 byte) value.
1111:../drivers/fsl_dspi.c ****         */
1112:../drivers/fsl_dspi.c ****         while ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag) &&
1113:../drivers/fsl_dspi.c ****                ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) / 2 < handle->
1114:../drivers/fsl_dspi.c ****         {
1115:../drivers/fsl_dspi.c ****             if (handle->remainingSendByteCount <= 2)
1116:../drivers/fsl_dspi.c ****             {
1117:../drivers/fsl_dspi.c ****                 if (handle->txData)
1118:../drivers/fsl_dspi.c ****                 {
1119:../drivers/fsl_dspi.c ****                     if (handle->remainingSendByteCount == 1)
1120:../drivers/fsl_dspi.c ****                     {
1121:../drivers/fsl_dspi.c ****                         wordToSend = *(handle->txData);
1122:../drivers/fsl_dspi.c ****                     }
1123:../drivers/fsl_dspi.c ****                     else
1124:../drivers/fsl_dspi.c ****                     {
1125:../drivers/fsl_dspi.c ****                         wordToSend = *(handle->txData);
1126:../drivers/fsl_dspi.c ****                         ++handle->txData; /* increment to next data byte */
1127:../drivers/fsl_dspi.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
1128:../drivers/fsl_dspi.c ****                     }
1129:../drivers/fsl_dspi.c ****                 }
1130:../drivers/fsl_dspi.c ****                 else
1131:../drivers/fsl_dspi.c ****                 {
1132:../drivers/fsl_dspi.c ****                     wordToSend = dummyData;
1133:../drivers/fsl_dspi.c ****                 }
1134:../drivers/fsl_dspi.c ****                 handle->remainingSendByteCount = 0;
1135:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->lastCommand | wordToSend;
1136:../drivers/fsl_dspi.c ****             }
1137:../drivers/fsl_dspi.c ****             /* For all words except the last word */
1138:../drivers/fsl_dspi.c ****             else
1139:../drivers/fsl_dspi.c ****             {
1140:../drivers/fsl_dspi.c ****                 if (handle->txData)
1141:../drivers/fsl_dspi.c ****                 {
1142:../drivers/fsl_dspi.c ****                     wordToSend = *(handle->txData);
1143:../drivers/fsl_dspi.c ****                     ++handle->txData; /* increment to next data byte */
1144:../drivers/fsl_dspi.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
1145:../drivers/fsl_dspi.c ****                     ++handle->txData; /* increment to next data byte */
1146:../drivers/fsl_dspi.c ****                 }
1147:../drivers/fsl_dspi.c ****                 else
1148:../drivers/fsl_dspi.c ****                 {
1149:../drivers/fsl_dspi.c ****                     wordToSend = dummyData;
1150:../drivers/fsl_dspi.c ****                 }
1151:../drivers/fsl_dspi.c ****                 handle->remainingSendByteCount -= 2; /* decrement remainingSendByteCount by 2 */
1152:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->command | wordToSend;
1153:../drivers/fsl_dspi.c ****             }
1154:../drivers/fsl_dspi.c **** 
1155:../drivers/fsl_dspi.c ****             /* Try to clear the TFFF; if the TX FIFO is full this will clear */
1156:../drivers/fsl_dspi.c ****             DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1157:../drivers/fsl_dspi.c **** 
1158:../drivers/fsl_dspi.c ****             /* exit loop if send count is zero, else update local variables for next loop.
1159:../drivers/fsl_dspi.c ****              * If this is the first time write to the PUSHR, write only once.
1160:../drivers/fsl_dspi.c ****              */
1161:../drivers/fsl_dspi.c ****             if ((handle->remainingSendByteCount == 0) || (handle->remainingSendByteCount == handle-
1162:../drivers/fsl_dspi.c ****             {
1163:../drivers/fsl_dspi.c ****                 break;
1164:../drivers/fsl_dspi.c ****             }
1165:../drivers/fsl_dspi.c ****         } /* End of TX FIFO fill while loop */
1166:../drivers/fsl_dspi.c ****     }
1167:../drivers/fsl_dspi.c ****     /* Optimized for bits/frame less than or equal to one byte. */
1168:../drivers/fsl_dspi.c ****     else
1169:../drivers/fsl_dspi.c ****     {
1170:../drivers/fsl_dspi.c ****         /* Fill the fifo until it is full or until the send word count is 0 or until the difference
1171:../drivers/fsl_dspi.c ****         * between the remainingReceiveByteCount and remainingSendByteCount equals the FIFO depth.
1172:../drivers/fsl_dspi.c ****         * The reason for checking the difference is to ensure we only send as much as the
1173:../drivers/fsl_dspi.c ****         * RX FIFO can receive.
1174:../drivers/fsl_dspi.c ****         */
1175:../drivers/fsl_dspi.c ****         while ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag) &&
1176:../drivers/fsl_dspi.c ****                ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) < handle->fifo
1177:../drivers/fsl_dspi.c ****         {
1178:../drivers/fsl_dspi.c ****             if (handle->txData)
1179:../drivers/fsl_dspi.c ****             {
1180:../drivers/fsl_dspi.c ****                 wordToSend = *(handle->txData);
1181:../drivers/fsl_dspi.c ****                 ++handle->txData;
1182:../drivers/fsl_dspi.c ****             }
1183:../drivers/fsl_dspi.c ****             else
1184:../drivers/fsl_dspi.c ****             {
1185:../drivers/fsl_dspi.c ****                 wordToSend = dummyData;
1186:../drivers/fsl_dspi.c ****             }
1187:../drivers/fsl_dspi.c **** 
1188:../drivers/fsl_dspi.c ****             if (handle->remainingSendByteCount == 1)
1189:../drivers/fsl_dspi.c ****             {
1190:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->lastCommand | wordToSend;
1191:../drivers/fsl_dspi.c ****             }
1192:../drivers/fsl_dspi.c ****             else
1193:../drivers/fsl_dspi.c ****             {
1194:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->command | wordToSend;
1195:../drivers/fsl_dspi.c ****             }
1196:../drivers/fsl_dspi.c **** 
1197:../drivers/fsl_dspi.c ****             /* Try to clear the TFFF; if the TX FIFO is full this will clear */
1198:../drivers/fsl_dspi.c ****             DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1199:../drivers/fsl_dspi.c **** 
1200:../drivers/fsl_dspi.c ****             --handle->remainingSendByteCount;
1201:../drivers/fsl_dspi.c **** 
1202:../drivers/fsl_dspi.c ****             /* exit loop if send count is zero, else update local variables for next loop
1203:../drivers/fsl_dspi.c ****              * If this is the first time write to the PUSHR, write only once.
1204:../drivers/fsl_dspi.c ****              */
1205:../drivers/fsl_dspi.c ****             if ((handle->remainingSendByteCount == 0) || (handle->remainingSendByteCount == handle-
1206:../drivers/fsl_dspi.c ****             {
1207:../drivers/fsl_dspi.c ****                 break;
1208:../drivers/fsl_dspi.c ****             }
1209:../drivers/fsl_dspi.c ****         }
1210:../drivers/fsl_dspi.c ****     }
1211:../drivers/fsl_dspi.c **** }
1212:../drivers/fsl_dspi.c **** 
1213:../drivers/fsl_dspi.c **** void DSPI_MasterTransferAbort(SPI_Type *base, dspi_master_handle_t *handle)
1214:../drivers/fsl_dspi.c **** {
1215:../drivers/fsl_dspi.c ****     assert(handle);
1216:../drivers/fsl_dspi.c **** 
1217:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
1218:../drivers/fsl_dspi.c **** 
1219:../drivers/fsl_dspi.c ****     /* Disable interrupt requests*/
1220:../drivers/fsl_dspi.c ****     DSPI_DisableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable | kDSPI_TxFifoFillRequestI
1221:../drivers/fsl_dspi.c **** 
1222:../drivers/fsl_dspi.c ****     handle->state = kDSPI_Idle;
1223:../drivers/fsl_dspi.c **** }
1224:../drivers/fsl_dspi.c **** 
1225:../drivers/fsl_dspi.c **** void DSPI_MasterTransferHandleIRQ(SPI_Type *base, dspi_master_handle_t *handle)
1226:../drivers/fsl_dspi.c **** {
1227:../drivers/fsl_dspi.c ****     assert(handle);
1228:../drivers/fsl_dspi.c **** 
1229:../drivers/fsl_dspi.c ****     /* RECEIVE IRQ handler: Check read buffer only if there are remaining bytes to read. */
1230:../drivers/fsl_dspi.c ****     if (handle->remainingReceiveByteCount)
1231:../drivers/fsl_dspi.c ****     {
1232:../drivers/fsl_dspi.c ****         /* Check read buffer.*/
1233:../drivers/fsl_dspi.c ****         uint16_t wordReceived; /* Maximum supported data bit length in master mode is 16-bits */
1234:../drivers/fsl_dspi.c **** 
1235:../drivers/fsl_dspi.c ****         /* If bits/frame is greater than one byte */
1236:../drivers/fsl_dspi.c ****         if (handle->bitsPerFrame > 8)
1237:../drivers/fsl_dspi.c ****         {
1238:../drivers/fsl_dspi.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
1239:../drivers/fsl_dspi.c ****             {
1240:../drivers/fsl_dspi.c ****                 wordReceived = DSPI_ReadData(base);
1241:../drivers/fsl_dspi.c ****                 /* clear the rx fifo drain request, needed for non-DMA applications as this flag
1242:../drivers/fsl_dspi.c ****                 * will remain set even if the rx fifo is empty. By manually clearing this flag, it
1243:../drivers/fsl_dspi.c ****                 * either remain clear if no more data is in the fifo, or it will set if there is
1244:../drivers/fsl_dspi.c ****                 * more data in the fifo.
1245:../drivers/fsl_dspi.c ****                 */
1246:../drivers/fsl_dspi.c ****                 DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
1247:../drivers/fsl_dspi.c **** 
1248:../drivers/fsl_dspi.c ****                 /* Store read bytes into rx buffer only if a buffer pointer was provided */
1249:../drivers/fsl_dspi.c ****                 if (handle->rxData)
1250:../drivers/fsl_dspi.c ****                 {
1251:../drivers/fsl_dspi.c ****                     /* For the last word received, if there is an extra byte due to the odd transfe
1252:../drivers/fsl_dspi.c ****                     * byte count, only save the last byte and discard the upper byte
1253:../drivers/fsl_dspi.c ****                     */
1254:../drivers/fsl_dspi.c ****                     if (handle->remainingReceiveByteCount == 1)
1255:../drivers/fsl_dspi.c ****                     {
1256:../drivers/fsl_dspi.c ****                         *handle->rxData = wordReceived; /* Write first data byte */
1257:../drivers/fsl_dspi.c ****                         --handle->remainingReceiveByteCount;
1258:../drivers/fsl_dspi.c ****                     }
1259:../drivers/fsl_dspi.c ****                     else
1260:../drivers/fsl_dspi.c ****                     {
1261:../drivers/fsl_dspi.c ****                         *handle->rxData = wordReceived;      /* Write first data byte */
1262:../drivers/fsl_dspi.c ****                         ++handle->rxData;                    /* increment to next data byte */
1263:../drivers/fsl_dspi.c ****                         *handle->rxData = wordReceived >> 8; /* Write second data byte */
1264:../drivers/fsl_dspi.c ****                         ++handle->rxData;                    /* increment to next data byte */
1265:../drivers/fsl_dspi.c ****                         handle->remainingReceiveByteCount -= 2;
1266:../drivers/fsl_dspi.c ****                     }
1267:../drivers/fsl_dspi.c ****                 }
1268:../drivers/fsl_dspi.c ****                 else
1269:../drivers/fsl_dspi.c ****                 {
1270:../drivers/fsl_dspi.c ****                     if (handle->remainingReceiveByteCount == 1)
1271:../drivers/fsl_dspi.c ****                     {
1272:../drivers/fsl_dspi.c ****                         --handle->remainingReceiveByteCount;
1273:../drivers/fsl_dspi.c ****                     }
1274:../drivers/fsl_dspi.c ****                     else
1275:../drivers/fsl_dspi.c ****                     {
1276:../drivers/fsl_dspi.c ****                         handle->remainingReceiveByteCount -= 2;
1277:../drivers/fsl_dspi.c ****                     }
1278:../drivers/fsl_dspi.c ****                 }
1279:../drivers/fsl_dspi.c ****                 if (handle->remainingReceiveByteCount == 0)
1280:../drivers/fsl_dspi.c ****                 {
1281:../drivers/fsl_dspi.c ****                     break;
1282:../drivers/fsl_dspi.c ****                 }
1283:../drivers/fsl_dspi.c ****             } /* End of RX FIFO drain while loop */
1284:../drivers/fsl_dspi.c ****         }
1285:../drivers/fsl_dspi.c ****         /* Optimized for bits/frame less than or equal to one byte. */
1286:../drivers/fsl_dspi.c ****         else
1287:../drivers/fsl_dspi.c ****         {
1288:../drivers/fsl_dspi.c ****             while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
1289:../drivers/fsl_dspi.c ****             {
1290:../drivers/fsl_dspi.c ****                 wordReceived = DSPI_ReadData(base);
1291:../drivers/fsl_dspi.c ****                 /* clear the rx fifo drain request, needed for non-DMA applications as this flag
1292:../drivers/fsl_dspi.c ****                 * will remain set even if the rx fifo is empty. By manually clearing this flag, it
1293:../drivers/fsl_dspi.c ****                 * either remain clear if no more data is in the fifo, or it will set if there is
1294:../drivers/fsl_dspi.c ****                 * more data in the fifo.
1295:../drivers/fsl_dspi.c ****                 */
1296:../drivers/fsl_dspi.c ****                 DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
1297:../drivers/fsl_dspi.c **** 
1298:../drivers/fsl_dspi.c ****                 /* Store read bytes into rx buffer only if a buffer pointer was provided */
1299:../drivers/fsl_dspi.c ****                 if (handle->rxData)
1300:../drivers/fsl_dspi.c ****                 {
1301:../drivers/fsl_dspi.c ****                     *handle->rxData = wordReceived;
1302:../drivers/fsl_dspi.c ****                     ++handle->rxData;
1303:../drivers/fsl_dspi.c ****                 }
1304:../drivers/fsl_dspi.c **** 
1305:../drivers/fsl_dspi.c ****                 --handle->remainingReceiveByteCount;
1306:../drivers/fsl_dspi.c **** 
1307:../drivers/fsl_dspi.c ****                 if (handle->remainingReceiveByteCount == 0)
1308:../drivers/fsl_dspi.c ****                 {
1309:../drivers/fsl_dspi.c ****                     break;
1310:../drivers/fsl_dspi.c ****                 }
1311:../drivers/fsl_dspi.c ****             } /* End of RX FIFO drain while loop */
1312:../drivers/fsl_dspi.c ****         }
1313:../drivers/fsl_dspi.c ****     }
1314:../drivers/fsl_dspi.c **** 
1315:../drivers/fsl_dspi.c ****     /* Check write buffer. We always have to send a word in order to keep the transfer
1316:../drivers/fsl_dspi.c ****     * moving. So if the caller didn't provide a send buffer, we just send a zero.
1317:../drivers/fsl_dspi.c ****     */
1318:../drivers/fsl_dspi.c ****     if (handle->remainingSendByteCount)
1319:../drivers/fsl_dspi.c ****     {
1320:../drivers/fsl_dspi.c ****         DSPI_MasterTransferFillUpTxFifo(base, handle);
1321:../drivers/fsl_dspi.c ****     }
1322:../drivers/fsl_dspi.c **** 
1323:../drivers/fsl_dspi.c ****     /* Check if we're done with this transfer.*/
1324:../drivers/fsl_dspi.c ****     if ((handle->remainingSendByteCount == 0) && (handle->remainingReceiveByteCount == 0))
1325:../drivers/fsl_dspi.c ****     {
1326:../drivers/fsl_dspi.c ****         /* Complete the transfer and disable the interrupts */
1327:../drivers/fsl_dspi.c ****         DSPI_MasterTransferComplete(base, handle);
1328:../drivers/fsl_dspi.c ****     }
1329:../drivers/fsl_dspi.c **** }
1330:../drivers/fsl_dspi.c **** 
1331:../drivers/fsl_dspi.c **** /*Transactional APIs -- Slave*/
1332:../drivers/fsl_dspi.c **** void DSPI_SlaveTransferCreateHandle(SPI_Type *base,
1333:../drivers/fsl_dspi.c ****                                     dspi_slave_handle_t *handle,
1334:../drivers/fsl_dspi.c ****                                     dspi_slave_transfer_callback_t callback,
1335:../drivers/fsl_dspi.c ****                                     void *userData)
1336:../drivers/fsl_dspi.c **** {
1337:../drivers/fsl_dspi.c ****     assert(handle);
1338:../drivers/fsl_dspi.c **** 
1339:../drivers/fsl_dspi.c ****     /* Zero the handle. */
1340:../drivers/fsl_dspi.c ****     memset(handle, 0, sizeof(*handle));
1341:../drivers/fsl_dspi.c **** 
1342:../drivers/fsl_dspi.c ****     g_dspiHandle[DSPI_GetInstance(base)] = handle;
1343:../drivers/fsl_dspi.c **** 
1344:../drivers/fsl_dspi.c ****     handle->callback = callback;
1345:../drivers/fsl_dspi.c ****     handle->userData = userData;
1346:../drivers/fsl_dspi.c **** }
1347:../drivers/fsl_dspi.c **** 
1348:../drivers/fsl_dspi.c **** status_t DSPI_SlaveTransferNonBlocking(SPI_Type *base, dspi_slave_handle_t *handle, dspi_transfer_t
1349:../drivers/fsl_dspi.c **** {
1350:../drivers/fsl_dspi.c ****     assert(handle);
1351:../drivers/fsl_dspi.c ****     assert(transfer);
1352:../drivers/fsl_dspi.c **** 
1353:../drivers/fsl_dspi.c ****     /* If receive length is zero */
1354:../drivers/fsl_dspi.c ****     if (transfer->dataSize == 0)
1355:../drivers/fsl_dspi.c ****     {
1356:../drivers/fsl_dspi.c ****         return kStatus_InvalidArgument;
1357:../drivers/fsl_dspi.c ****     }
1358:../drivers/fsl_dspi.c **** 
1359:../drivers/fsl_dspi.c ****     /* If both send buffer and receive buffer is null */
1360:../drivers/fsl_dspi.c ****     if ((!(transfer->txData)) && (!(transfer->rxData)))
1361:../drivers/fsl_dspi.c ****     {
1362:../drivers/fsl_dspi.c ****         return kStatus_InvalidArgument;
1363:../drivers/fsl_dspi.c ****     }
1364:../drivers/fsl_dspi.c **** 
1365:../drivers/fsl_dspi.c ****     /* Check that we're not busy.*/
1366:../drivers/fsl_dspi.c ****     if (handle->state == kDSPI_Busy)
1367:../drivers/fsl_dspi.c ****     {
1368:../drivers/fsl_dspi.c ****         return kStatus_DSPI_Busy;
1369:../drivers/fsl_dspi.c ****     }
1370:../drivers/fsl_dspi.c ****     handle->state = kDSPI_Busy;
1371:../drivers/fsl_dspi.c **** 
1372:../drivers/fsl_dspi.c ****     /* Enable the NVIC for DSPI peripheral. */
1373:../drivers/fsl_dspi.c ****     EnableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
1374:../drivers/fsl_dspi.c **** 
1375:../drivers/fsl_dspi.c ****     /* Store transfer information */
1376:../drivers/fsl_dspi.c ****     handle->txData = transfer->txData;
1377:../drivers/fsl_dspi.c ****     handle->rxData = transfer->rxData;
1378:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = transfer->dataSize;
1379:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
1380:../drivers/fsl_dspi.c ****     handle->totalByteCount = transfer->dataSize;
1381:../drivers/fsl_dspi.c **** 
1382:../drivers/fsl_dspi.c ****     handle->errorCount = 0;
1383:../drivers/fsl_dspi.c **** 
1384:../drivers/fsl_dspi.c ****     uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
1385:../drivers/fsl_dspi.c ****     handle->bitsPerFrame =
1386:../drivers/fsl_dspi.c ****         (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) +
1387:../drivers/fsl_dspi.c **** 
1388:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
1389:../drivers/fsl_dspi.c **** 
1390:../drivers/fsl_dspi.c ****     DSPI_FlushFifo(base, true, true);
1391:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
1392:../drivers/fsl_dspi.c **** 
1393:../drivers/fsl_dspi.c ****     s_dspiSlaveIsr = DSPI_SlaveTransferHandleIRQ;
1394:../drivers/fsl_dspi.c **** 
1395:../drivers/fsl_dspi.c ****     /* Enable RX FIFO drain request, the slave only use this interrupt */
1396:../drivers/fsl_dspi.c ****     DSPI_EnableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable);
1397:../drivers/fsl_dspi.c **** 
1398:../drivers/fsl_dspi.c ****     if (handle->rxData)
1399:../drivers/fsl_dspi.c ****     {
1400:../drivers/fsl_dspi.c ****         /* RX FIFO overflow request enable */
1401:../drivers/fsl_dspi.c ****         DSPI_EnableInterrupts(base, kDSPI_RxFifoOverflowInterruptEnable);
1402:../drivers/fsl_dspi.c ****     }
1403:../drivers/fsl_dspi.c ****     if (handle->txData)
1404:../drivers/fsl_dspi.c ****     {
1405:../drivers/fsl_dspi.c ****         /* TX FIFO underflow request enable */
1406:../drivers/fsl_dspi.c ****         DSPI_EnableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable);
1407:../drivers/fsl_dspi.c ****     }
1408:../drivers/fsl_dspi.c **** 
1409:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
1410:../drivers/fsl_dspi.c **** 
1411:../drivers/fsl_dspi.c ****     /* Prepare data to transmit */
1412:../drivers/fsl_dspi.c ****     DSPI_SlaveTransferFillUpTxFifo(base, handle);
1413:../drivers/fsl_dspi.c **** 
1414:../drivers/fsl_dspi.c ****     return kStatus_Success;
1415:../drivers/fsl_dspi.c **** }
1416:../drivers/fsl_dspi.c **** 
1417:../drivers/fsl_dspi.c **** status_t DSPI_SlaveTransferGetCount(SPI_Type *base, dspi_slave_handle_t *handle, size_t *count)
1418:../drivers/fsl_dspi.c **** {
1419:../drivers/fsl_dspi.c ****     assert(handle);
1420:../drivers/fsl_dspi.c **** 
1421:../drivers/fsl_dspi.c ****     if (!count)
1422:../drivers/fsl_dspi.c ****     {
1423:../drivers/fsl_dspi.c ****         return kStatus_InvalidArgument;
1424:../drivers/fsl_dspi.c ****     }
1425:../drivers/fsl_dspi.c **** 
1426:../drivers/fsl_dspi.c ****     /* Catch when there is not an active transfer. */
1427:../drivers/fsl_dspi.c ****     if (handle->state != kDSPI_Busy)
1428:../drivers/fsl_dspi.c ****     {
1429:../drivers/fsl_dspi.c ****         *count = 0;
1430:../drivers/fsl_dspi.c ****         return kStatus_NoTransferInProgress;
1431:../drivers/fsl_dspi.c ****     }
1432:../drivers/fsl_dspi.c **** 
1433:../drivers/fsl_dspi.c ****     *count = handle->totalByteCount - handle->remainingReceiveByteCount;
1434:../drivers/fsl_dspi.c ****     return kStatus_Success;
1435:../drivers/fsl_dspi.c **** }
1436:../drivers/fsl_dspi.c **** 
1437:../drivers/fsl_dspi.c **** static void DSPI_SlaveTransferFillUpTxFifo(SPI_Type *base, dspi_slave_handle_t *handle)
1438:../drivers/fsl_dspi.c **** {
1439:../drivers/fsl_dspi.c ****     assert(handle);
1440:../drivers/fsl_dspi.c **** 
1441:../drivers/fsl_dspi.c ****     uint16_t transmitData = 0;
1442:../drivers/fsl_dspi.c ****     uint8_t dummyPattern = s_dummyData[DSPI_GetInstance(base)];
1443:../drivers/fsl_dspi.c **** 
1444:../drivers/fsl_dspi.c ****     /* Service the transmitter, if transmit buffer provided, transmit the data,
1445:../drivers/fsl_dspi.c ****     * else transmit dummy pattern
1446:../drivers/fsl_dspi.c ****     */
1447:../drivers/fsl_dspi.c ****     while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
1448:../drivers/fsl_dspi.c ****     {
1449:../drivers/fsl_dspi.c ****         /* Transmit data */
1450:../drivers/fsl_dspi.c ****         if (handle->remainingSendByteCount > 0)
1451:../drivers/fsl_dspi.c ****         {
1452:../drivers/fsl_dspi.c ****             /* Have data to transmit, update the transmit data and push to FIFO */
1453:../drivers/fsl_dspi.c ****             if (handle->bitsPerFrame <= 8)
1454:../drivers/fsl_dspi.c ****             {
1455:../drivers/fsl_dspi.c ****                 /* bits/frame is 1 byte */
1456:../drivers/fsl_dspi.c ****                 if (handle->txData)
1457:../drivers/fsl_dspi.c ****                 {
1458:../drivers/fsl_dspi.c ****                     /* Update transmit data and transmit pointer */
1459:../drivers/fsl_dspi.c ****                     transmitData = *handle->txData;
1460:../drivers/fsl_dspi.c ****                     handle->txData++;
1461:../drivers/fsl_dspi.c ****                 }
1462:../drivers/fsl_dspi.c ****                 else
1463:../drivers/fsl_dspi.c ****                 {
1464:../drivers/fsl_dspi.c ****                     transmitData = dummyPattern;
1465:../drivers/fsl_dspi.c ****                 }
1466:../drivers/fsl_dspi.c **** 
1467:../drivers/fsl_dspi.c ****                 /* Decrease remaining dataSize */
1468:../drivers/fsl_dspi.c ****                 --handle->remainingSendByteCount;
1469:../drivers/fsl_dspi.c ****             }
1470:../drivers/fsl_dspi.c ****             /* bits/frame is 2 bytes */
1471:../drivers/fsl_dspi.c ****             else
1472:../drivers/fsl_dspi.c ****             {
1473:../drivers/fsl_dspi.c ****                 /* With multibytes per frame transmission, the transmit frame contains data from
1474:../drivers/fsl_dspi.c ****                 * transmit buffer until sent dataSize matches user request. Other bytes will set to
1475:../drivers/fsl_dspi.c ****                 * dummy pattern value.
1476:../drivers/fsl_dspi.c ****                 */
1477:../drivers/fsl_dspi.c ****                 if (handle->txData)
1478:../drivers/fsl_dspi.c ****                 {
1479:../drivers/fsl_dspi.c ****                     /* Update first byte of transmit data and transmit pointer */
1480:../drivers/fsl_dspi.c ****                     transmitData = *handle->txData;
1481:../drivers/fsl_dspi.c ****                     handle->txData++;
1482:../drivers/fsl_dspi.c **** 
1483:../drivers/fsl_dspi.c ****                     if (handle->remainingSendByteCount == 1)
1484:../drivers/fsl_dspi.c ****                     {
1485:../drivers/fsl_dspi.c ****                         /* Decrease remaining dataSize */
1486:../drivers/fsl_dspi.c ****                         --handle->remainingSendByteCount;
1487:../drivers/fsl_dspi.c ****                         /* Update second byte of transmit data to second byte of dummy pattern */
1488:../drivers/fsl_dspi.c ****                         transmitData = transmitData | (uint16_t)(((uint16_t)dummyPattern) << 8);
1489:../drivers/fsl_dspi.c ****                     }
1490:../drivers/fsl_dspi.c ****                     else
1491:../drivers/fsl_dspi.c ****                     {
1492:../drivers/fsl_dspi.c ****                         /* Update second byte of transmit data and transmit pointer */
1493:../drivers/fsl_dspi.c ****                         transmitData = transmitData | (uint16_t)((uint16_t)(*handle->txData) << 8);
1494:../drivers/fsl_dspi.c ****                         handle->txData++;
1495:../drivers/fsl_dspi.c ****                         handle->remainingSendByteCount -= 2;
1496:../drivers/fsl_dspi.c ****                     }
1497:../drivers/fsl_dspi.c ****                 }
1498:../drivers/fsl_dspi.c ****                 else
1499:../drivers/fsl_dspi.c ****                 {
1500:../drivers/fsl_dspi.c ****                     if (handle->remainingSendByteCount == 1)
1501:../drivers/fsl_dspi.c ****                     {
1502:../drivers/fsl_dspi.c ****                         --handle->remainingSendByteCount;
1503:../drivers/fsl_dspi.c ****                     }
1504:../drivers/fsl_dspi.c ****                     else
1505:../drivers/fsl_dspi.c ****                     {
1506:../drivers/fsl_dspi.c ****                         handle->remainingSendByteCount -= 2;
1507:../drivers/fsl_dspi.c ****                     }
1508:../drivers/fsl_dspi.c ****                     transmitData = (uint16_t)((uint16_t)(dummyPattern) << 8) | dummyPattern;
1509:../drivers/fsl_dspi.c ****                 }
1510:../drivers/fsl_dspi.c ****             }
1511:../drivers/fsl_dspi.c ****         }
1512:../drivers/fsl_dspi.c ****         else
1513:../drivers/fsl_dspi.c ****         {
1514:../drivers/fsl_dspi.c ****             break;
1515:../drivers/fsl_dspi.c ****         }
1516:../drivers/fsl_dspi.c **** 
1517:../drivers/fsl_dspi.c ****         /* Write the data to the DSPI data register */
1518:../drivers/fsl_dspi.c ****         base->PUSHR_SLAVE = transmitData;
1519:../drivers/fsl_dspi.c **** 
1520:../drivers/fsl_dspi.c ****         /* Try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
1521:../drivers/fsl_dspi.c ****         DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1522:../drivers/fsl_dspi.c ****     }
1523:../drivers/fsl_dspi.c **** }
1524:../drivers/fsl_dspi.c **** 
1525:../drivers/fsl_dspi.c **** static void DSPI_SlaveTransferComplete(SPI_Type *base, dspi_slave_handle_t *handle)
1526:../drivers/fsl_dspi.c **** {
1527:../drivers/fsl_dspi.c ****     assert(handle);
1528:../drivers/fsl_dspi.c **** 
1529:../drivers/fsl_dspi.c ****     /* Disable interrupt requests */
1530:../drivers/fsl_dspi.c ****     DSPI_DisableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable | kDSPI_TxFifoFillRequestInte
1531:../drivers/fsl_dspi.c ****                                      kDSPI_RxFifoOverflowInterruptEnable | kDSPI_RxFifoDrainRequest
1532:../drivers/fsl_dspi.c **** 
1533:../drivers/fsl_dspi.c ****     /* The transfer is complete. */
1534:../drivers/fsl_dspi.c ****     handle->txData = NULL;
1535:../drivers/fsl_dspi.c ****     handle->rxData = NULL;
1536:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = 0;
1537:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = 0;
1538:../drivers/fsl_dspi.c **** 
1539:../drivers/fsl_dspi.c ****     status_t status = 0;
1540:../drivers/fsl_dspi.c ****     if (handle->state == kDSPI_Error)
1541:../drivers/fsl_dspi.c ****     {
1542:../drivers/fsl_dspi.c ****         status = kStatus_DSPI_Error;
1543:../drivers/fsl_dspi.c ****     }
1544:../drivers/fsl_dspi.c ****     else
1545:../drivers/fsl_dspi.c ****     {
1546:../drivers/fsl_dspi.c ****         status = kStatus_Success;
1547:../drivers/fsl_dspi.c ****     }
1548:../drivers/fsl_dspi.c **** 
1549:../drivers/fsl_dspi.c ****     handle->state = kDSPI_Idle;
1550:../drivers/fsl_dspi.c **** 
1551:../drivers/fsl_dspi.c ****     if (handle->callback)
1552:../drivers/fsl_dspi.c ****     {
1553:../drivers/fsl_dspi.c ****         handle->callback(base, handle, status, handle->userData);
1554:../drivers/fsl_dspi.c ****     }
1555:../drivers/fsl_dspi.c **** }
1556:../drivers/fsl_dspi.c **** 
1557:../drivers/fsl_dspi.c **** void DSPI_SlaveTransferAbort(SPI_Type *base, dspi_slave_handle_t *handle)
1558:../drivers/fsl_dspi.c **** {
1559:../drivers/fsl_dspi.c ****     assert(handle);
1560:../drivers/fsl_dspi.c **** 
1561:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
1562:../drivers/fsl_dspi.c **** 
1563:../drivers/fsl_dspi.c ****     /* Disable interrupt requests */
1564:../drivers/fsl_dspi.c ****     DSPI_DisableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable | kDSPI_TxFifoFillRequestInte
1565:../drivers/fsl_dspi.c ****                                      kDSPI_RxFifoOverflowInterruptEnable | kDSPI_RxFifoDrainRequest
1566:../drivers/fsl_dspi.c **** 
1567:../drivers/fsl_dspi.c ****     handle->state = kDSPI_Idle;
1568:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = 0;
1569:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = 0;
1570:../drivers/fsl_dspi.c **** }
1571:../drivers/fsl_dspi.c **** 
1572:../drivers/fsl_dspi.c **** void DSPI_SlaveTransferHandleIRQ(SPI_Type *base, dspi_slave_handle_t *handle)
1573:../drivers/fsl_dspi.c **** {
1574:../drivers/fsl_dspi.c ****     assert(handle);
1575:../drivers/fsl_dspi.c **** 
1576:../drivers/fsl_dspi.c ****     uint8_t dummyPattern = s_dummyData[DSPI_GetInstance(base)];
1577:../drivers/fsl_dspi.c ****     uint32_t dataReceived;
1578:../drivers/fsl_dspi.c ****     uint32_t dataSend = 0;
1579:../drivers/fsl_dspi.c **** 
1580:../drivers/fsl_dspi.c ****     /* Because SPI protocol is synchronous, the number of bytes that that slave received from the
1581:../drivers/fsl_dspi.c ****     * master is the actual number of bytes that the slave transmitted to the master. So we only
1582:../drivers/fsl_dspi.c ****     * monitor the received dataSize to know when the transfer is complete.
1583:../drivers/fsl_dspi.c ****     */
1584:../drivers/fsl_dspi.c ****     if (handle->remainingReceiveByteCount > 0)
1585:../drivers/fsl_dspi.c ****     {
1586:../drivers/fsl_dspi.c ****         while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
1587:../drivers/fsl_dspi.c ****         {
1588:../drivers/fsl_dspi.c ****             /* Have received data in the buffer. */
1589:../drivers/fsl_dspi.c ****             dataReceived = base->POPR;
1590:../drivers/fsl_dspi.c ****             /*Clear the rx fifo drain request, needed for non-DMA applications as this flag
1591:../drivers/fsl_dspi.c ****             * will remain set even if the rx fifo is empty. By manually clearing this flag, it
1592:../drivers/fsl_dspi.c ****             * either remain clear if no more data is in the fifo, or it will set if there is
1593:../drivers/fsl_dspi.c ****             * more data in the fifo.
1594:../drivers/fsl_dspi.c ****             */
1595:../drivers/fsl_dspi.c ****             DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
1596:../drivers/fsl_dspi.c **** 
1597:../drivers/fsl_dspi.c ****             /* If bits/frame is one byte */
1598:../drivers/fsl_dspi.c ****             if (handle->bitsPerFrame <= 8)
1599:../drivers/fsl_dspi.c ****             {
1600:../drivers/fsl_dspi.c ****                 if (handle->rxData)
1601:../drivers/fsl_dspi.c ****                 {
1602:../drivers/fsl_dspi.c ****                     /* Receive buffer is not null, store data into it */
1603:../drivers/fsl_dspi.c ****                     *handle->rxData = dataReceived;
1604:../drivers/fsl_dspi.c ****                     ++handle->rxData;
1605:../drivers/fsl_dspi.c ****                 }
1606:../drivers/fsl_dspi.c ****                 /* Descrease remaining receive byte count */
1607:../drivers/fsl_dspi.c ****                 --handle->remainingReceiveByteCount;
1608:../drivers/fsl_dspi.c **** 
1609:../drivers/fsl_dspi.c ****                 if (handle->remainingSendByteCount > 0)
1610:../drivers/fsl_dspi.c ****                 {
1611:../drivers/fsl_dspi.c ****                     if (handle->txData)
1612:../drivers/fsl_dspi.c ****                     {
1613:../drivers/fsl_dspi.c ****                         dataSend = *handle->txData;
1614:../drivers/fsl_dspi.c ****                         ++handle->txData;
1615:../drivers/fsl_dspi.c ****                     }
1616:../drivers/fsl_dspi.c ****                     else
1617:../drivers/fsl_dspi.c ****                     {
1618:../drivers/fsl_dspi.c ****                         dataSend = dummyPattern;
1619:../drivers/fsl_dspi.c ****                     }
1620:../drivers/fsl_dspi.c **** 
1621:../drivers/fsl_dspi.c ****                     --handle->remainingSendByteCount;
1622:../drivers/fsl_dspi.c ****                     /* Write the data to the DSPI data register */
1623:../drivers/fsl_dspi.c ****                     base->PUSHR_SLAVE = dataSend;
1624:../drivers/fsl_dspi.c ****                 }
1625:../drivers/fsl_dspi.c ****             }
1626:../drivers/fsl_dspi.c ****             else /* If bits/frame is 2 bytes */
1627:../drivers/fsl_dspi.c ****             {
1628:../drivers/fsl_dspi.c ****                 /* With multibytes frame receiving, we only receive till the received dataSize
1629:../drivers/fsl_dspi.c ****                 * matches user request. Other bytes will be ignored.
1630:../drivers/fsl_dspi.c ****                 */
1631:../drivers/fsl_dspi.c ****                 if (handle->rxData)
1632:../drivers/fsl_dspi.c ****                 {
1633:../drivers/fsl_dspi.c ****                     /* Receive buffer is not null, store first byte into it */
1634:../drivers/fsl_dspi.c ****                     *handle->rxData = dataReceived;
1635:../drivers/fsl_dspi.c ****                     ++handle->rxData;
1636:../drivers/fsl_dspi.c **** 
1637:../drivers/fsl_dspi.c ****                     if (handle->remainingReceiveByteCount == 1)
1638:../drivers/fsl_dspi.c ****                     {
1639:../drivers/fsl_dspi.c ****                         /* Decrease remaining receive byte count */
1640:../drivers/fsl_dspi.c ****                         --handle->remainingReceiveByteCount;
1641:../drivers/fsl_dspi.c ****                     }
1642:../drivers/fsl_dspi.c ****                     else
1643:../drivers/fsl_dspi.c ****                     {
1644:../drivers/fsl_dspi.c ****                         /* Receive buffer is not null, store second byte into it */
1645:../drivers/fsl_dspi.c ****                         *handle->rxData = dataReceived >> 8;
1646:../drivers/fsl_dspi.c ****                         ++handle->rxData;
1647:../drivers/fsl_dspi.c ****                         handle->remainingReceiveByteCount -= 2;
1648:../drivers/fsl_dspi.c ****                     }
1649:../drivers/fsl_dspi.c ****                 }
1650:../drivers/fsl_dspi.c ****                 /* If no handle->rxData*/
1651:../drivers/fsl_dspi.c ****                 else
1652:../drivers/fsl_dspi.c ****                 {
1653:../drivers/fsl_dspi.c ****                     if (handle->remainingReceiveByteCount == 1)
1654:../drivers/fsl_dspi.c ****                     {
1655:../drivers/fsl_dspi.c ****                         /* Decrease remaining receive byte count */
1656:../drivers/fsl_dspi.c ****                         --handle->remainingReceiveByteCount;
1657:../drivers/fsl_dspi.c ****                     }
1658:../drivers/fsl_dspi.c ****                     else
1659:../drivers/fsl_dspi.c ****                     {
1660:../drivers/fsl_dspi.c ****                         handle->remainingReceiveByteCount -= 2;
1661:../drivers/fsl_dspi.c ****                     }
1662:../drivers/fsl_dspi.c ****                 }
1663:../drivers/fsl_dspi.c **** 
1664:../drivers/fsl_dspi.c ****                 if (handle->remainingSendByteCount > 0)
1665:../drivers/fsl_dspi.c ****                 {
1666:../drivers/fsl_dspi.c ****                     if (handle->txData)
1667:../drivers/fsl_dspi.c ****                     {
1668:../drivers/fsl_dspi.c ****                         dataSend = *handle->txData;
1669:../drivers/fsl_dspi.c ****                         ++handle->txData;
1670:../drivers/fsl_dspi.c **** 
1671:../drivers/fsl_dspi.c ****                         if (handle->remainingSendByteCount == 1)
1672:../drivers/fsl_dspi.c ****                         {
1673:../drivers/fsl_dspi.c ****                             --handle->remainingSendByteCount;
1674:../drivers/fsl_dspi.c ****                             dataSend |= (uint16_t)((uint16_t)(dummyPattern) << 8);
1675:../drivers/fsl_dspi.c ****                         }
1676:../drivers/fsl_dspi.c ****                         else
1677:../drivers/fsl_dspi.c ****                         {
1678:../drivers/fsl_dspi.c ****                             dataSend |= (uint32_t)(*handle->txData) << 8;
1679:../drivers/fsl_dspi.c ****                             ++handle->txData;
1680:../drivers/fsl_dspi.c ****                             handle->remainingSendByteCount -= 2;
1681:../drivers/fsl_dspi.c ****                         }
1682:../drivers/fsl_dspi.c ****                     }
1683:../drivers/fsl_dspi.c ****                     /* If no handle->txData*/
1684:../drivers/fsl_dspi.c ****                     else
1685:../drivers/fsl_dspi.c ****                     {
1686:../drivers/fsl_dspi.c ****                         if (handle->remainingSendByteCount == 1)
1687:../drivers/fsl_dspi.c ****                         {
1688:../drivers/fsl_dspi.c ****                             --handle->remainingSendByteCount;
1689:../drivers/fsl_dspi.c ****                         }
1690:../drivers/fsl_dspi.c ****                         else
1691:../drivers/fsl_dspi.c ****                         {
1692:../drivers/fsl_dspi.c ****                             handle->remainingSendByteCount -= 2;
1693:../drivers/fsl_dspi.c ****                         }
1694:../drivers/fsl_dspi.c ****                         dataSend = (uint16_t)((uint16_t)(dummyPattern) << 8) | dummyPattern;
1695:../drivers/fsl_dspi.c ****                     }
1696:../drivers/fsl_dspi.c ****                     /* Write the data to the DSPI data register */
1697:../drivers/fsl_dspi.c ****                     base->PUSHR_SLAVE = dataSend;
1698:../drivers/fsl_dspi.c ****                 }
1699:../drivers/fsl_dspi.c ****             }
1700:../drivers/fsl_dspi.c ****             /* Try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
1701:../drivers/fsl_dspi.c ****             DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
1702:../drivers/fsl_dspi.c **** 
1703:../drivers/fsl_dspi.c ****             if (handle->remainingReceiveByteCount == 0)
1704:../drivers/fsl_dspi.c ****             {
1705:../drivers/fsl_dspi.c ****                 break;
1706:../drivers/fsl_dspi.c ****             }
1707:../drivers/fsl_dspi.c ****         }
1708:../drivers/fsl_dspi.c ****     }
1709:../drivers/fsl_dspi.c ****     /* Check if remaining receive byte count matches user request */
1710:../drivers/fsl_dspi.c ****     if ((handle->remainingReceiveByteCount == 0) || (handle->state == kDSPI_Error))
1711:../drivers/fsl_dspi.c ****     {
1712:../drivers/fsl_dspi.c ****         /* Other cases, stop the transfer. */
1713:../drivers/fsl_dspi.c ****         DSPI_SlaveTransferComplete(base, handle);
1714:../drivers/fsl_dspi.c ****         return;
1715:../drivers/fsl_dspi.c ****     }
1716:../drivers/fsl_dspi.c **** 
1717:../drivers/fsl_dspi.c ****     /* Catch tx fifo underflow conditions, service only if tx under flow interrupt enabled */
1718:../drivers/fsl_dspi.c ****     if ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoUnderflowFlag) && (base->RSER & SPI_RSER_TFUF_RE_M
1719:../drivers/fsl_dspi.c ****     {
1720:../drivers/fsl_dspi.c ****         DSPI_ClearStatusFlags(base, kDSPI_TxFifoUnderflowFlag);
1721:../drivers/fsl_dspi.c ****         /* Change state to error and clear flag */
1722:../drivers/fsl_dspi.c ****         if (handle->txData)
1723:../drivers/fsl_dspi.c ****         {
1724:../drivers/fsl_dspi.c ****             handle->state = kDSPI_Error;
1725:../drivers/fsl_dspi.c ****         }
1726:../drivers/fsl_dspi.c ****         handle->errorCount++;
1727:../drivers/fsl_dspi.c ****     }
1728:../drivers/fsl_dspi.c ****     /* Catch rx fifo overflow conditions, service only if rx over flow interrupt enabled */
1729:../drivers/fsl_dspi.c ****     if ((DSPI_GetStatusFlags(base) & kDSPI_RxFifoOverflowFlag) && (base->RSER & SPI_RSER_RFOF_RE_MA
1730:../drivers/fsl_dspi.c ****     {
1731:../drivers/fsl_dspi.c ****         DSPI_ClearStatusFlags(base, kDSPI_RxFifoOverflowFlag);
1732:../drivers/fsl_dspi.c ****         /* Change state to error and clear flag */
1733:../drivers/fsl_dspi.c ****         if (handle->txData)
1734:../drivers/fsl_dspi.c ****         {
1735:../drivers/fsl_dspi.c ****             handle->state = kDSPI_Error;
1736:../drivers/fsl_dspi.c ****         }
1737:../drivers/fsl_dspi.c ****         handle->errorCount++;
1738:../drivers/fsl_dspi.c ****     }
1739:../drivers/fsl_dspi.c **** }
1740:../drivers/fsl_dspi.c **** 
1741:../drivers/fsl_dspi.c **** static void DSPI_CommonIRQHandler(SPI_Type *base, void *param)
1742:../drivers/fsl_dspi.c **** {
  27              		.loc 1 1742 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 08B5     		push	{r3, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 3, -8
  35              		.cfi_offset 14, -4
  36              	.LBB207:
  37              	.LBB208:
  38              		.file 2 "../drivers/fsl_dspi.h"
   1:../drivers/fsl_dspi.h **** /*
   2:../drivers/fsl_dspi.h ****  * The Clear BSD License
   3:../drivers/fsl_dspi.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dspi.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dspi.h ****  * All rights reserved.
   6:../drivers/fsl_dspi.h ****  *
   7:../drivers/fsl_dspi.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dspi.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dspi.h ****  * that the following conditions are met:
  10:../drivers/fsl_dspi.h ****  *
  11:../drivers/fsl_dspi.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dspi.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dspi.h ****  *
  14:../drivers/fsl_dspi.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dspi.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dspi.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dspi.h ****  *
  18:../drivers/fsl_dspi.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dspi.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dspi.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dspi.h ****  *
  22:../drivers/fsl_dspi.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dspi.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dspi.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dspi.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dspi.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dspi.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dspi.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dspi.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dspi.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dspi.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dspi.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dspi.h ****  */
  34:../drivers/fsl_dspi.h **** #ifndef _FSL_DSPI_H_
  35:../drivers/fsl_dspi.h **** #define _FSL_DSPI_H_
  36:../drivers/fsl_dspi.h **** 
  37:../drivers/fsl_dspi.h **** #include "fsl_common.h"
  38:../drivers/fsl_dspi.h **** 
  39:../drivers/fsl_dspi.h **** /*!
  40:../drivers/fsl_dspi.h ****  * @addtogroup dspi_driver
  41:../drivers/fsl_dspi.h ****  * @{
  42:../drivers/fsl_dspi.h ****  */
  43:../drivers/fsl_dspi.h **** 
  44:../drivers/fsl_dspi.h **** /**************************************************************************************************
  45:../drivers/fsl_dspi.h ****  * Definitions
  46:../drivers/fsl_dspi.h ****  **************************************************************************************************
  47:../drivers/fsl_dspi.h **** 
  48:../drivers/fsl_dspi.h **** /*! @name Driver version */
  49:../drivers/fsl_dspi.h **** /*@{*/
  50:../drivers/fsl_dspi.h **** /*! @brief DSPI driver version 2.2.0. */
  51:../drivers/fsl_dspi.h **** #define FSL_DSPI_DRIVER_VERSION (MAKE_VERSION(2, 2, 0))
  52:../drivers/fsl_dspi.h **** /*@}*/
  53:../drivers/fsl_dspi.h **** 
  54:../drivers/fsl_dspi.h **** #ifndef DSPI_DUMMY_DATA
  55:../drivers/fsl_dspi.h **** /*! @brief DSPI dummy data if there is no Tx data.*/
  56:../drivers/fsl_dspi.h **** #define DSPI_DUMMY_DATA (0x00U) /*!< Dummy data used for Tx if there is no txData. */
  57:../drivers/fsl_dspi.h **** #endif
  58:../drivers/fsl_dspi.h **** 
  59:../drivers/fsl_dspi.h **** /*! @brief Status for the DSPI driver.*/
  60:../drivers/fsl_dspi.h **** enum _dspi_status
  61:../drivers/fsl_dspi.h **** {
  62:../drivers/fsl_dspi.h ****     kStatus_DSPI_Busy = MAKE_STATUS(kStatusGroup_DSPI, 0),      /*!< DSPI transfer is busy.*/
  63:../drivers/fsl_dspi.h ****     kStatus_DSPI_Error = MAKE_STATUS(kStatusGroup_DSPI, 1),     /*!< DSPI driver error. */
  64:../drivers/fsl_dspi.h ****     kStatus_DSPI_Idle = MAKE_STATUS(kStatusGroup_DSPI, 2),      /*!< DSPI is idle.*/
  65:../drivers/fsl_dspi.h ****     kStatus_DSPI_OutOfRange = MAKE_STATUS(kStatusGroup_DSPI, 3) /*!< DSPI transfer out of range. */
  66:../drivers/fsl_dspi.h **** };
  67:../drivers/fsl_dspi.h **** 
  68:../drivers/fsl_dspi.h **** /*! @brief DSPI status flags in SPIx_SR register.*/
  69:../drivers/fsl_dspi.h **** enum _dspi_flags
  70:../drivers/fsl_dspi.h **** {
  71:../drivers/fsl_dspi.h ****     kDSPI_TxCompleteFlag = SPI_SR_TCF_MASK,          /*!< Transfer Complete Flag. */
  72:../drivers/fsl_dspi.h ****     kDSPI_EndOfQueueFlag = SPI_SR_EOQF_MASK,         /*!< End of Queue Flag.*/
  73:../drivers/fsl_dspi.h ****     kDSPI_TxFifoUnderflowFlag = SPI_SR_TFUF_MASK,    /*!< Transmit FIFO Underflow Flag.*/
  74:../drivers/fsl_dspi.h ****     kDSPI_TxFifoFillRequestFlag = SPI_SR_TFFF_MASK,  /*!< Transmit FIFO Fill Flag.*/
  75:../drivers/fsl_dspi.h ****     kDSPI_RxFifoOverflowFlag = SPI_SR_RFOF_MASK,     /*!< Receive FIFO Overflow Flag.*/
  76:../drivers/fsl_dspi.h ****     kDSPI_RxFifoDrainRequestFlag = SPI_SR_RFDF_MASK, /*!< Receive FIFO Drain Flag.*/
  77:../drivers/fsl_dspi.h ****     kDSPI_TxAndRxStatusFlag = SPI_SR_TXRXS_MASK,     /*!< The module is in Stopped/Running state.*/
  78:../drivers/fsl_dspi.h ****     kDSPI_AllStatusFlag = SPI_SR_TCF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK 
  79:../drivers/fsl_dspi.h ****                           SPI_SR_RFDF_MASK | SPI_SR_TXRXS_MASK /*!< All statuses above.*/
  80:../drivers/fsl_dspi.h **** };
  81:../drivers/fsl_dspi.h **** 
  82:../drivers/fsl_dspi.h **** /*! @brief DSPI interrupt source.*/
  83:../drivers/fsl_dspi.h **** enum _dspi_interrupt_enable
  84:../drivers/fsl_dspi.h **** {
  85:../drivers/fsl_dspi.h ****     kDSPI_TxCompleteInterruptEnable = SPI_RSER_TCF_RE_MASK,          /*!< TCF  interrupt enable.*/
  86:../drivers/fsl_dspi.h ****     kDSPI_EndOfQueueInterruptEnable = SPI_RSER_EOQF_RE_MASK,         /*!< EOQF interrupt enable.*/
  87:../drivers/fsl_dspi.h ****     kDSPI_TxFifoUnderflowInterruptEnable = SPI_RSER_TFUF_RE_MASK,    /*!< TFUF interrupt enable.*/
  88:../drivers/fsl_dspi.h ****     kDSPI_TxFifoFillRequestInterruptEnable = SPI_RSER_TFFF_RE_MASK,  /*!< TFFF interrupt enable, DM
  89:../drivers/fsl_dspi.h ****     kDSPI_RxFifoOverflowInterruptEnable = SPI_RSER_RFOF_RE_MASK,     /*!< RFOF interrupt enable.*/
  90:../drivers/fsl_dspi.h ****     kDSPI_RxFifoDrainRequestInterruptEnable = SPI_RSER_RFDF_RE_MASK, /*!< RFDF interrupt enable, DM
  91:../drivers/fsl_dspi.h ****     kDSPI_AllInterruptEnable = SPI_RSER_TCF_RE_MASK | SPI_RSER_EOQF_RE_MASK | SPI_RSER_TFUF_RE_MASK
  92:../drivers/fsl_dspi.h ****                                SPI_RSER_TFFF_RE_MASK | SPI_RSER_RFOF_RE_MASK | SPI_RSER_RFDF_RE_MAS
  93:../drivers/fsl_dspi.h ****     /*!< All above interrupts enable.*/
  94:../drivers/fsl_dspi.h **** };
  95:../drivers/fsl_dspi.h **** 
  96:../drivers/fsl_dspi.h **** /*! @brief DSPI DMA source.*/
  97:../drivers/fsl_dspi.h **** enum _dspi_dma_enable
  98:../drivers/fsl_dspi.h **** {
  99:../drivers/fsl_dspi.h ****     kDSPI_TxDmaEnable = (SPI_RSER_TFFF_RE_MASK | SPI_RSER_TFFF_DIRS_MASK), /*!< TFFF flag generates
 100:../drivers/fsl_dspi.h ****                                                                                 No Tx interrupt req
 101:../drivers/fsl_dspi.h ****     kDSPI_RxDmaEnable = (SPI_RSER_RFDF_RE_MASK | SPI_RSER_RFDF_DIRS_MASK)  /*!< RFDF flag generates
 102:../drivers/fsl_dspi.h ****                                                                                 No Rx interrupt req
 103:../drivers/fsl_dspi.h **** };
 104:../drivers/fsl_dspi.h **** 
 105:../drivers/fsl_dspi.h **** /*! @brief DSPI master or slave mode configuration.*/
 106:../drivers/fsl_dspi.h **** typedef enum _dspi_master_slave_mode
 107:../drivers/fsl_dspi.h **** {
 108:../drivers/fsl_dspi.h ****     kDSPI_Master = 1U, /*!< DSPI peripheral operates in master mode.*/
 109:../drivers/fsl_dspi.h ****     kDSPI_Slave = 0U   /*!< DSPI peripheral operates in slave mode.*/
 110:../drivers/fsl_dspi.h **** } dspi_master_slave_mode_t;
 111:../drivers/fsl_dspi.h **** 
 112:../drivers/fsl_dspi.h **** /*!
 113:../drivers/fsl_dspi.h ****  * @brief DSPI Sample Point: Controls when the DSPI master samples SIN in the Modified Transfer For
 114:../drivers/fsl_dspi.h ****  * valid
 115:../drivers/fsl_dspi.h ****  * only when the CPHA bit in the CTAR register is 0.
 116:../drivers/fsl_dspi.h ****  */
 117:../drivers/fsl_dspi.h **** typedef enum _dspi_master_sample_point
 118:../drivers/fsl_dspi.h **** {
 119:../drivers/fsl_dspi.h ****     kDSPI_SckToSin0Clock = 0U, /*!< 0 system clocks between SCK edge and SIN sample.*/
 120:../drivers/fsl_dspi.h ****     kDSPI_SckToSin1Clock = 1U, /*!< 1 system clock  between SCK edge and SIN sample.*/
 121:../drivers/fsl_dspi.h ****     kDSPI_SckToSin2Clock = 2U  /*!< 2 system clocks between SCK edge and SIN sample.*/
 122:../drivers/fsl_dspi.h **** } dspi_master_sample_point_t;
 123:../drivers/fsl_dspi.h **** 
 124:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) configuration (which Pcs to configure).*/
 125:../drivers/fsl_dspi.h **** typedef enum _dspi_which_pcs_config
 126:../drivers/fsl_dspi.h **** {
 127:../drivers/fsl_dspi.h ****     kDSPI_Pcs0 = 1U << 0, /*!< Pcs[0] */
 128:../drivers/fsl_dspi.h ****     kDSPI_Pcs1 = 1U << 1, /*!< Pcs[1] */
 129:../drivers/fsl_dspi.h ****     kDSPI_Pcs2 = 1U << 2, /*!< Pcs[2] */
 130:../drivers/fsl_dspi.h ****     kDSPI_Pcs3 = 1U << 3, /*!< Pcs[3] */
 131:../drivers/fsl_dspi.h ****     kDSPI_Pcs4 = 1U << 4, /*!< Pcs[4] */
 132:../drivers/fsl_dspi.h ****     kDSPI_Pcs5 = 1U << 5  /*!< Pcs[5] */
 133:../drivers/fsl_dspi.h **** } dspi_which_pcs_t;
 134:../drivers/fsl_dspi.h **** 
 135:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) Polarity configuration.*/
 136:../drivers/fsl_dspi.h **** typedef enum _dspi_pcs_polarity_config
 137:../drivers/fsl_dspi.h **** {
 138:../drivers/fsl_dspi.h ****     kDSPI_PcsActiveHigh = 0U, /*!< Pcs Active High (idles low). */
 139:../drivers/fsl_dspi.h ****     kDSPI_PcsActiveLow = 1U   /*!< Pcs Active Low (idles high). */
 140:../drivers/fsl_dspi.h **** } dspi_pcs_polarity_config_t;
 141:../drivers/fsl_dspi.h **** 
 142:../drivers/fsl_dspi.h **** /*! @brief DSPI Peripheral Chip Select (Pcs) Polarity.*/
 143:../drivers/fsl_dspi.h **** enum _dspi_pcs_polarity
 144:../drivers/fsl_dspi.h **** {
 145:../drivers/fsl_dspi.h ****     kDSPI_Pcs0ActiveLow = 1U << 0, /*!< Pcs0 Active Low (idles high). */
 146:../drivers/fsl_dspi.h ****     kDSPI_Pcs1ActiveLow = 1U << 1, /*!< Pcs1 Active Low (idles high). */
 147:../drivers/fsl_dspi.h ****     kDSPI_Pcs2ActiveLow = 1U << 2, /*!< Pcs2 Active Low (idles high). */
 148:../drivers/fsl_dspi.h ****     kDSPI_Pcs3ActiveLow = 1U << 3, /*!< Pcs3 Active Low (idles high). */
 149:../drivers/fsl_dspi.h ****     kDSPI_Pcs4ActiveLow = 1U << 4, /*!< Pcs4 Active Low (idles high). */
 150:../drivers/fsl_dspi.h ****     kDSPI_Pcs5ActiveLow = 1U << 5, /*!< Pcs5 Active Low (idles high). */
 151:../drivers/fsl_dspi.h ****     kDSPI_PcsAllActiveLow = 0xFFU  /*!< Pcs0 to Pcs5 Active Low (idles high). */
 152:../drivers/fsl_dspi.h **** };
 153:../drivers/fsl_dspi.h **** 
 154:../drivers/fsl_dspi.h **** /*! @brief DSPI clock polarity configuration for a given CTAR.*/
 155:../drivers/fsl_dspi.h **** typedef enum _dspi_clock_polarity
 156:../drivers/fsl_dspi.h **** {
 157:../drivers/fsl_dspi.h ****     kDSPI_ClockPolarityActiveHigh = 0U, /*!< CPOL=0. Active-high DSPI clock (idles low).*/
 158:../drivers/fsl_dspi.h ****     kDSPI_ClockPolarityActiveLow = 1U   /*!< CPOL=1. Active-low DSPI clock (idles high).*/
 159:../drivers/fsl_dspi.h **** } dspi_clock_polarity_t;
 160:../drivers/fsl_dspi.h **** 
 161:../drivers/fsl_dspi.h **** /*! @brief DSPI clock phase configuration for a given CTAR.*/
 162:../drivers/fsl_dspi.h **** typedef enum _dspi_clock_phase
 163:../drivers/fsl_dspi.h **** {
 164:../drivers/fsl_dspi.h ****     kDSPI_ClockPhaseFirstEdge = 0U, /*!< CPHA=0. Data is captured on the leading edge of the SCK an
 165:../drivers/fsl_dspi.h ****                                          following edge.*/
 166:../drivers/fsl_dspi.h ****     kDSPI_ClockPhaseSecondEdge = 1U /*!< CPHA=1. Data is changed on the leading edge of the SCK and
 167:../drivers/fsl_dspi.h ****                                         following edge.*/
 168:../drivers/fsl_dspi.h **** } dspi_clock_phase_t;
 169:../drivers/fsl_dspi.h **** 
 170:../drivers/fsl_dspi.h **** /*! @brief DSPI data shifter direction options for a given CTAR.*/
 171:../drivers/fsl_dspi.h **** typedef enum _dspi_shift_direction
 172:../drivers/fsl_dspi.h **** {
 173:../drivers/fsl_dspi.h ****     kDSPI_MsbFirst = 0U, /*!< Data transfers start with most significant bit.*/
 174:../drivers/fsl_dspi.h ****     kDSPI_LsbFirst = 1U  /*!< Data transfers start with least significant bit.
 175:../drivers/fsl_dspi.h ****                               Shifting out of LSB is not supported for slave */
 176:../drivers/fsl_dspi.h **** } dspi_shift_direction_t;
 177:../drivers/fsl_dspi.h **** 
 178:../drivers/fsl_dspi.h **** /*! @brief DSPI delay type selection.*/
 179:../drivers/fsl_dspi.h **** typedef enum _dspi_delay_type
 180:../drivers/fsl_dspi.h **** {
 181:../drivers/fsl_dspi.h ****     kDSPI_PcsToSck = 1U,  /*!< Pcs-to-SCK delay. */
 182:../drivers/fsl_dspi.h ****     kDSPI_LastSckToPcs,   /*!< The last SCK edge to Pcs delay. */
 183:../drivers/fsl_dspi.h ****     kDSPI_BetweenTransfer /*!< Delay between transfers. */
 184:../drivers/fsl_dspi.h **** } dspi_delay_type_t;
 185:../drivers/fsl_dspi.h **** 
 186:../drivers/fsl_dspi.h **** /*! @brief DSPI Clock and Transfer Attributes Register (CTAR) selection.*/
 187:../drivers/fsl_dspi.h **** typedef enum _dspi_ctar_selection
 188:../drivers/fsl_dspi.h **** {
 189:../drivers/fsl_dspi.h ****     kDSPI_Ctar0 = 0U, /*!< CTAR0 selection option for master or slave mode; note that CTAR0 and CTA
 190:../drivers/fsl_dspi.h ****                          same register address. */
 191:../drivers/fsl_dspi.h ****     kDSPI_Ctar1 = 1U, /*!< CTAR1 selection option for master mode only. */
 192:../drivers/fsl_dspi.h ****     kDSPI_Ctar2 = 2U, /*!< CTAR2 selection option for master mode only; note that some devices do n
 193:../drivers/fsl_dspi.h ****     kDSPI_Ctar3 = 3U, /*!< CTAR3 selection option for master mode only; note that some devices do n
 194:../drivers/fsl_dspi.h ****     kDSPI_Ctar4 = 4U, /*!< CTAR4 selection option for master mode only; note that some devices do n
 195:../drivers/fsl_dspi.h ****     kDSPI_Ctar5 = 5U, /*!< CTAR5 selection option for master mode only; note that some devices do n
 196:../drivers/fsl_dspi.h ****     kDSPI_Ctar6 = 6U, /*!< CTAR6 selection option for master mode only; note that some devices do n
 197:../drivers/fsl_dspi.h ****     kDSPI_Ctar7 = 7U  /*!< CTAR7 selection option for master mode only; note that some devices do n
 198:../drivers/fsl_dspi.h **** } dspi_ctar_selection_t;
 199:../drivers/fsl_dspi.h **** 
 200:../drivers/fsl_dspi.h **** #define DSPI_MASTER_CTAR_SHIFT (0U)   /*!< DSPI master CTAR shift macro; used internally. */
 201:../drivers/fsl_dspi.h **** #define DSPI_MASTER_CTAR_MASK (0x0FU) /*!< DSPI master CTAR mask macro; used internally. */
 202:../drivers/fsl_dspi.h **** #define DSPI_MASTER_PCS_SHIFT (4U)    /*!< DSPI master PCS shift macro; used internally. */
 203:../drivers/fsl_dspi.h **** #define DSPI_MASTER_PCS_MASK (0xF0U)  /*!< DSPI master PCS mask macro; used internally. */
 204:../drivers/fsl_dspi.h **** /*! @brief Use this enumeration for the DSPI master transfer configFlags. */
 205:../drivers/fsl_dspi.h **** enum _dspi_transfer_config_flag_for_master
 206:../drivers/fsl_dspi.h **** {
 207:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar0 = 0U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR0 setting. 
 208:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar1 = 1U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR1 setting. 
 209:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar2 = 2U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR2 setting. 
 210:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar3 = 3U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR3 setting. 
 211:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar4 = 4U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR4 setting. 
 212:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar5 = 5U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR5 setting. 
 213:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar6 = 6U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR6 setting. 
 214:../drivers/fsl_dspi.h ****     kDSPI_MasterCtar7 = 7U << DSPI_MASTER_CTAR_SHIFT, /*!< DSPI master transfer use CTAR7 setting. 
 215:../drivers/fsl_dspi.h **** 
 216:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs0 = 0U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS0 signal. */
 217:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs1 = 1U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS1 signal. */
 218:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs2 = 2U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS2 signal.*/
 219:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs3 = 3U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS3 signal. */
 220:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs4 = 4U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS4 signal. */
 221:../drivers/fsl_dspi.h ****     kDSPI_MasterPcs5 = 5U << DSPI_MASTER_PCS_SHIFT, /*!< DSPI master transfer use PCS5 signal. */
 222:../drivers/fsl_dspi.h **** 
 223:../drivers/fsl_dspi.h ****     kDSPI_MasterPcsContinuous = 1U << 20, /*!< Indicates whether the PCS signal is continuous. */
 224:../drivers/fsl_dspi.h ****     kDSPI_MasterActiveAfterTransfer =
 225:../drivers/fsl_dspi.h ****         1U << 21, /*!< Indicates whether the PCS signal is active after the last frame transfer.*/
 226:../drivers/fsl_dspi.h **** };
 227:../drivers/fsl_dspi.h **** 
 228:../drivers/fsl_dspi.h **** #define DSPI_SLAVE_CTAR_SHIFT (0U)   /*!< DSPI slave CTAR shift macro; used internally. */
 229:../drivers/fsl_dspi.h **** #define DSPI_SLAVE_CTAR_MASK (0x07U) /*!< DSPI slave CTAR mask macro; used internally. */
 230:../drivers/fsl_dspi.h **** /*! @brief Use this enumeration for the DSPI slave transfer configFlags. */
 231:../drivers/fsl_dspi.h **** enum _dspi_transfer_config_flag_for_slave
 232:../drivers/fsl_dspi.h **** {
 233:../drivers/fsl_dspi.h ****     kDSPI_SlaveCtar0 = 0U << DSPI_SLAVE_CTAR_SHIFT, /*!< DSPI slave transfer use CTAR0 setting. */
 234:../drivers/fsl_dspi.h ****                                                     /*!< DSPI slave can only use PCS0. */
 235:../drivers/fsl_dspi.h **** };
 236:../drivers/fsl_dspi.h **** 
 237:../drivers/fsl_dspi.h **** /*! @brief DSPI transfer state, which is used for DSPI transactional API state machine. */
 238:../drivers/fsl_dspi.h **** enum _dspi_transfer_state
 239:../drivers/fsl_dspi.h **** {
 240:../drivers/fsl_dspi.h ****     kDSPI_Idle = 0x0U, /*!< Nothing in the transmitter/receiver. */
 241:../drivers/fsl_dspi.h ****     kDSPI_Busy,        /*!< Transfer queue is not finished. */
 242:../drivers/fsl_dspi.h ****     kDSPI_Error        /*!< Transfer error. */
 243:../drivers/fsl_dspi.h **** };
 244:../drivers/fsl_dspi.h **** 
 245:../drivers/fsl_dspi.h **** /*! @brief DSPI master command date configuration used for the SPIx_PUSHR.*/
 246:../drivers/fsl_dspi.h **** typedef struct _dspi_command_data_config
 247:../drivers/fsl_dspi.h **** {
 248:../drivers/fsl_dspi.h ****     bool isPcsContinuous; /*!< Option to enable the continuous assertion of the chip select between
 249:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar; /*!< The desired Clock and Transfer Attributes
 250:../drivers/fsl_dspi.h ****                                           Register (CTAR) to use for CTAS.*/
 251:../drivers/fsl_dspi.h ****     dspi_which_pcs_t whichPcs;       /*!< The desired PCS signal to use for the data transfer.*/
 252:../drivers/fsl_dspi.h ****     bool isEndOfQueue;               /*!< Signals that the current transfer is the last in the queu
 253:../drivers/fsl_dspi.h ****     bool clearTransferCount;         /*!< Clears the SPI Transfer Counter (SPI_TCNT) before transmi
 254:../drivers/fsl_dspi.h **** } dspi_command_data_config_t;
 255:../drivers/fsl_dspi.h **** 
 256:../drivers/fsl_dspi.h **** /*! @brief DSPI master ctar configuration structure.*/
 257:../drivers/fsl_dspi.h **** typedef struct _dspi_master_ctar_config
 258:../drivers/fsl_dspi.h **** {
 259:../drivers/fsl_dspi.h ****     uint32_t baudRate;                /*!< Baud Rate for DSPI. */
 260:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;            /*!< Bits per frame, minimum 4, maximum 16.*/
 261:../drivers/fsl_dspi.h ****     dspi_clock_polarity_t cpol;       /*!< Clock polarity. */
 262:../drivers/fsl_dspi.h ****     dspi_clock_phase_t cpha;          /*!< Clock phase. */
 263:../drivers/fsl_dspi.h ****     dspi_shift_direction_t direction; /*!< MSB or LSB data shift direction. */
 264:../drivers/fsl_dspi.h **** 
 265:../drivers/fsl_dspi.h ****     uint32_t pcsToSckDelayInNanoSec;     /*!< PCS to SCK delay time in nanoseconds; setting to 0 se
 266:../drivers/fsl_dspi.h ****                                             delay. It also sets the boundary value if out of range.
 267:../drivers/fsl_dspi.h ****     uint32_t lastSckToPcsDelayInNanoSec; /*!< The last SCK to PCS delay time in nanoseconds; settin
 268:../drivers/fsl_dspi.h ****                                             minimum delay. It also sets the boundary value if out o
 269:../drivers/fsl_dspi.h **** 
 270:../drivers/fsl_dspi.h ****     uint32_t betweenTransferDelayInNanoSec; /*!< After the SCK delay time in nanoseconds; setting t
 271:../drivers/fsl_dspi.h ****                                              delay. It also sets the boundary value if out of range
 272:../drivers/fsl_dspi.h **** } dspi_master_ctar_config_t;
 273:../drivers/fsl_dspi.h **** 
 274:../drivers/fsl_dspi.h **** /*! @brief DSPI master configuration structure.*/
 275:../drivers/fsl_dspi.h **** typedef struct _dspi_master_config
 276:../drivers/fsl_dspi.h **** {
 277:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar;      /*!< The desired CTAR to use. */
 278:../drivers/fsl_dspi.h ****     dspi_master_ctar_config_t ctarConfig; /*!< Set the ctarConfig to the desired CTAR. */
 279:../drivers/fsl_dspi.h **** 
 280:../drivers/fsl_dspi.h ****     dspi_which_pcs_t whichPcs;                     /*!< The desired Peripheral Chip Select (pcs). *
 281:../drivers/fsl_dspi.h ****     dspi_pcs_polarity_config_t pcsActiveHighOrLow; /*!< The desired PCS active high or low. */
 282:../drivers/fsl_dspi.h **** 
 283:../drivers/fsl_dspi.h ****     bool enableContinuousSCK;   /*!< CONT_SCKE, continuous SCK enable. Note that the continuous SCK
 284:../drivers/fsl_dspi.h ****                                      supported for CPHA = 1.*/
 285:../drivers/fsl_dspi.h ****     bool enableRxFifoOverWrite; /*!< ROOE, receive FIFO overflow overwrite enable. If ROOE = 0, the
 286:../drivers/fsl_dspi.h ****                                      data is ignored and the data from the transfer that generated 
 287:../drivers/fsl_dspi.h ****                                      is also ignored. If ROOE = 1, the incoming data is shifted to 
 288:../drivers/fsl_dspi.h ****                                      shift register. */
 289:../drivers/fsl_dspi.h **** 
 290:../drivers/fsl_dspi.h ****     bool enableModifiedTimingFormat;        /*!< Enables a modified transfer format to be used if t
 291:../drivers/fsl_dspi.h ****     dspi_master_sample_point_t samplePoint; /*!< Controls when the module master samples SIN in the
 292:../drivers/fsl_dspi.h ****                                                  Format. It's valid only when CPHA=0. */
 293:../drivers/fsl_dspi.h **** } dspi_master_config_t;
 294:../drivers/fsl_dspi.h **** 
 295:../drivers/fsl_dspi.h **** /*! @brief DSPI slave ctar configuration structure.*/
 296:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_ctar_config
 297:../drivers/fsl_dspi.h **** {
 298:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;      /*!< Bits per frame, minimum 4, maximum 16.*/
 299:../drivers/fsl_dspi.h ****     dspi_clock_polarity_t cpol; /*!< Clock polarity. */
 300:../drivers/fsl_dspi.h ****     dspi_clock_phase_t cpha;    /*!< Clock phase. */
 301:../drivers/fsl_dspi.h ****                                 /*!< Slave only supports MSB and does not support LSB.*/
 302:../drivers/fsl_dspi.h **** } dspi_slave_ctar_config_t;
 303:../drivers/fsl_dspi.h **** 
 304:../drivers/fsl_dspi.h **** /*! @brief DSPI slave configuration structure.*/
 305:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_config
 306:../drivers/fsl_dspi.h **** {
 307:../drivers/fsl_dspi.h ****     dspi_ctar_selection_t whichCtar;     /*!< The desired CTAR to use. */
 308:../drivers/fsl_dspi.h ****     dspi_slave_ctar_config_t ctarConfig; /*!< Set the ctarConfig to the desired CTAR. */
 309:../drivers/fsl_dspi.h **** 
 310:../drivers/fsl_dspi.h ****     bool enableContinuousSCK;               /*!< CONT_SCKE, continuous SCK enable. Note that the co
 311:../drivers/fsl_dspi.h ****                                                  supported for CPHA = 1.*/
 312:../drivers/fsl_dspi.h ****     bool enableRxFifoOverWrite;             /*!< ROOE, receive FIFO overflow overwrite enable. If R
 313:../drivers/fsl_dspi.h ****                                                  data is ignored and the data from the transfer tha
 314:../drivers/fsl_dspi.h ****                                                  is also ignored. If ROOE = 1, the incoming data is
 315:../drivers/fsl_dspi.h ****                                                  shift register. */
 316:../drivers/fsl_dspi.h ****     bool enableModifiedTimingFormat;        /*!< Enables a modified transfer format to be used if t
 317:../drivers/fsl_dspi.h ****     dspi_master_sample_point_t samplePoint; /*!< Controls when the module master samples SIN in the
 318:../drivers/fsl_dspi.h ****                                                Format. It's valid only when CPHA=0. */
 319:../drivers/fsl_dspi.h **** } dspi_slave_config_t;
 320:../drivers/fsl_dspi.h **** 
 321:../drivers/fsl_dspi.h **** /*!
 322:../drivers/fsl_dspi.h **** * @brief Forward declaration of the _dspi_master_handle typedefs.
 323:../drivers/fsl_dspi.h **** */
 324:../drivers/fsl_dspi.h **** typedef struct _dspi_master_handle dspi_master_handle_t;
 325:../drivers/fsl_dspi.h **** 
 326:../drivers/fsl_dspi.h **** /*!
 327:../drivers/fsl_dspi.h **** * @brief Forward declaration of the _dspi_slave_handle typedefs.
 328:../drivers/fsl_dspi.h **** */
 329:../drivers/fsl_dspi.h **** typedef struct _dspi_slave_handle dspi_slave_handle_t;
 330:../drivers/fsl_dspi.h **** 
 331:../drivers/fsl_dspi.h **** /*!
 332:../drivers/fsl_dspi.h ****  * @brief Completion callback function pointer type.
 333:../drivers/fsl_dspi.h ****  *
 334:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 335:../drivers/fsl_dspi.h ****  * @param handle Pointer to the handle for the DSPI master.
 336:../drivers/fsl_dspi.h ****  * @param status Success or error code describing whether the transfer completed.
 337:../drivers/fsl_dspi.h ****  * @param userData Arbitrary pointer-dataSized value passed from the application.
 338:../drivers/fsl_dspi.h ****  */
 339:../drivers/fsl_dspi.h **** typedef void (*dspi_master_transfer_callback_t)(SPI_Type *base,
 340:../drivers/fsl_dspi.h ****                                                 dspi_master_handle_t *handle,
 341:../drivers/fsl_dspi.h ****                                                 status_t status,
 342:../drivers/fsl_dspi.h ****                                                 void *userData);
 343:../drivers/fsl_dspi.h **** /*!
 344:../drivers/fsl_dspi.h ****  * @brief Completion callback function pointer type.
 345:../drivers/fsl_dspi.h ****  *
 346:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 347:../drivers/fsl_dspi.h ****  * @param handle Pointer to the handle for the DSPI slave.
 348:../drivers/fsl_dspi.h ****  * @param status Success or error code describing whether the transfer completed.
 349:../drivers/fsl_dspi.h ****  * @param userData Arbitrary pointer-dataSized value passed from the application.
 350:../drivers/fsl_dspi.h ****  */
 351:../drivers/fsl_dspi.h **** typedef void (*dspi_slave_transfer_callback_t)(SPI_Type *base,
 352:../drivers/fsl_dspi.h ****                                                dspi_slave_handle_t *handle,
 353:../drivers/fsl_dspi.h ****                                                status_t status,
 354:../drivers/fsl_dspi.h ****                                                void *userData);
 355:../drivers/fsl_dspi.h **** 
 356:../drivers/fsl_dspi.h **** /*! @brief DSPI master/slave transfer structure.*/
 357:../drivers/fsl_dspi.h **** typedef struct _dspi_transfer
 358:../drivers/fsl_dspi.h **** {
 359:../drivers/fsl_dspi.h ****     uint8_t *txData;          /*!< Send buffer. */
 360:../drivers/fsl_dspi.h ****     uint8_t *rxData;          /*!< Receive buffer. */
 361:../drivers/fsl_dspi.h ****     volatile size_t dataSize; /*!< Transfer bytes. */
 362:../drivers/fsl_dspi.h **** 
 363:../drivers/fsl_dspi.h ****     uint32_t
 364:../drivers/fsl_dspi.h ****         configFlags; /*!< Transfer transfer configuration flags; set from _dspi_transfer_config_fla
 365:../drivers/fsl_dspi.h ****                         transfer is used for master or _dspi_transfer_config_flag_for_slave enumera
 366:../drivers/fsl_dspi.h ****                         is used for slave.*/
 367:../drivers/fsl_dspi.h **** } dspi_transfer_t;
 368:../drivers/fsl_dspi.h **** 
 369:../drivers/fsl_dspi.h **** /*! @brief DSPI half-duplex(master) transfer structure */
 370:../drivers/fsl_dspi.h **** typedef struct _dspi_half_duplex_transfer
 371:../drivers/fsl_dspi.h **** {
 372:../drivers/fsl_dspi.h ****     uint8_t *txData;            /*!< Send buffer */
 373:../drivers/fsl_dspi.h ****     uint8_t *rxData;            /*!< Receive buffer */
 374:../drivers/fsl_dspi.h ****     size_t txDataSize;          /*!< Transfer bytes for transmit */
 375:../drivers/fsl_dspi.h ****     size_t rxDataSize;          /*!< Transfer bytes */
 376:../drivers/fsl_dspi.h ****     uint32_t configFlags;       /*!< Transfer configuration flags; set from _dspi_transfer_config_f
 377:../drivers/fsl_dspi.h ****     bool isPcsAssertInTransfer; /*!< If Pcs pin keep assert between transmit and receive. true for 
 378:../drivers/fsl_dspi.h ****                                    deassert. */
 379:../drivers/fsl_dspi.h ****     bool isTransmitFirst;       /*!< True for transmit first and false for receive first. */
 380:../drivers/fsl_dspi.h **** } dspi_half_duplex_transfer_t;
 381:../drivers/fsl_dspi.h **** 
 382:../drivers/fsl_dspi.h **** /*! @brief DSPI master transfer handle structure used for transactional API. */
 383:../drivers/fsl_dspi.h **** struct _dspi_master_handle
 384:../drivers/fsl_dspi.h **** {
 385:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;         /*!< The desired number of bits per frame. */
 386:../drivers/fsl_dspi.h ****     volatile uint32_t command;     /*!< The desired data command. */
 387:../drivers/fsl_dspi.h ****     volatile uint32_t lastCommand; /*!< The desired last data command. */
 388:../drivers/fsl_dspi.h **** 
 389:../drivers/fsl_dspi.h ****     uint8_t fifoSize; /*!< FIFO dataSize. */
 390:../drivers/fsl_dspi.h **** 
 391:../drivers/fsl_dspi.h ****     volatile bool
 392:../drivers/fsl_dspi.h ****         isPcsActiveAfterTransfer;   /*!< Indicates whether the PCS signal is active after the last 
 393:../drivers/fsl_dspi.h ****     volatile bool isThereExtraByte; /*!< Indicates whether there are extra bytes.*/
 394:../drivers/fsl_dspi.h **** 
 395:../drivers/fsl_dspi.h ****     uint8_t *volatile txData;                  /*!< Send buffer. */
 396:../drivers/fsl_dspi.h ****     uint8_t *volatile rxData;                  /*!< Receive buffer. */
 397:../drivers/fsl_dspi.h ****     volatile size_t remainingSendByteCount;    /*!< A number of bytes remaining to send.*/
 398:../drivers/fsl_dspi.h ****     volatile size_t remainingReceiveByteCount; /*!< A number of bytes remaining to receive.*/
 399:../drivers/fsl_dspi.h ****     size_t totalByteCount;                     /*!< A number of transfer bytes*/
 400:../drivers/fsl_dspi.h **** 
 401:../drivers/fsl_dspi.h ****     volatile uint8_t state; /*!< DSPI transfer state, see _dspi_transfer_state.*/
 402:../drivers/fsl_dspi.h **** 
 403:../drivers/fsl_dspi.h ****     dspi_master_transfer_callback_t callback; /*!< Completion callback. */
 404:../drivers/fsl_dspi.h ****     void *userData;                           /*!< Callback user data. */
 405:../drivers/fsl_dspi.h **** };
 406:../drivers/fsl_dspi.h **** 
 407:../drivers/fsl_dspi.h **** /*! @brief DSPI slave transfer handle structure used for the transactional API. */
 408:../drivers/fsl_dspi.h **** struct _dspi_slave_handle
 409:../drivers/fsl_dspi.h **** {
 410:../drivers/fsl_dspi.h ****     uint32_t bitsPerFrame;          /*!< The desired number of bits per frame. */
 411:../drivers/fsl_dspi.h ****     volatile bool isThereExtraByte; /*!< Indicates whether there are extra bytes.*/
 412:../drivers/fsl_dspi.h **** 
 413:../drivers/fsl_dspi.h ****     uint8_t *volatile txData;                  /*!< Send buffer. */
 414:../drivers/fsl_dspi.h ****     uint8_t *volatile rxData;                  /*!< Receive buffer. */
 415:../drivers/fsl_dspi.h ****     volatile size_t remainingSendByteCount;    /*!< A number of bytes remaining to send.*/
 416:../drivers/fsl_dspi.h ****     volatile size_t remainingReceiveByteCount; /*!< A number of bytes remaining to receive.*/
 417:../drivers/fsl_dspi.h ****     size_t totalByteCount;                     /*!< A number of transfer bytes*/
 418:../drivers/fsl_dspi.h **** 
 419:../drivers/fsl_dspi.h ****     volatile uint8_t state; /*!< DSPI transfer state.*/
 420:../drivers/fsl_dspi.h **** 
 421:../drivers/fsl_dspi.h ****     volatile uint32_t errorCount; /*!< Error count for slave transfer.*/
 422:../drivers/fsl_dspi.h **** 
 423:../drivers/fsl_dspi.h ****     dspi_slave_transfer_callback_t callback; /*!< Completion callback. */
 424:../drivers/fsl_dspi.h ****     void *userData;                          /*!< Callback user data. */
 425:../drivers/fsl_dspi.h **** };
 426:../drivers/fsl_dspi.h **** 
 427:../drivers/fsl_dspi.h **** /**************************************************************************************************
 428:../drivers/fsl_dspi.h ****  * API
 429:../drivers/fsl_dspi.h ****  **************************************************************************************************
 430:../drivers/fsl_dspi.h **** #if defined(__cplusplus)
 431:../drivers/fsl_dspi.h **** extern "C" {
 432:../drivers/fsl_dspi.h **** #endif /*_cplusplus*/
 433:../drivers/fsl_dspi.h **** 
 434:../drivers/fsl_dspi.h **** /*!
 435:../drivers/fsl_dspi.h ****  * @name Initialization and deinitialization
 436:../drivers/fsl_dspi.h ****  * @{
 437:../drivers/fsl_dspi.h ****  */
 438:../drivers/fsl_dspi.h **** 
 439:../drivers/fsl_dspi.h **** /*!
 440:../drivers/fsl_dspi.h ****  * @brief Initializes the DSPI master.
 441:../drivers/fsl_dspi.h ****  *
 442:../drivers/fsl_dspi.h ****  * This function initializes the DSPI master configuration. This is an example use case.
 443:../drivers/fsl_dspi.h ****  *  @code
 444:../drivers/fsl_dspi.h ****  *   dspi_master_config_t  masterConfig;
 445:../drivers/fsl_dspi.h ****  *   masterConfig.whichCtar                                = kDSPI_Ctar0;
 446:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.baudRate                      = 500000000U;
 447:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.bitsPerFrame                  = 8;
 448:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.cpol                          = kDSPI_ClockPolarityActiveHigh;
 449:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.cpha                          = kDSPI_ClockPhaseFirstEdge;
 450:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.direction                     = kDSPI_MsbFirst;
 451:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.pcsToSckDelayInNanoSec        = 1000000000U / masterConfig.ctarConfig.
 452:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec    = 1000000000U / masterConfig.ctarConfig.
 453:../drivers/fsl_dspi.h ****  *   masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 1000000000U / masterConfig.ctarConfig.
 454:../drivers/fsl_dspi.h ****  *   masterConfig.whichPcs                                 = kDSPI_Pcs0;
 455:../drivers/fsl_dspi.h ****  *   masterConfig.pcsActiveHighOrLow                       = kDSPI_PcsActiveLow;
 456:../drivers/fsl_dspi.h ****  *   masterConfig.enableContinuousSCK                      = false;
 457:../drivers/fsl_dspi.h ****  *   masterConfig.enableRxFifoOverWrite                    = false;
 458:../drivers/fsl_dspi.h ****  *   masterConfig.enableModifiedTimingFormat               = false;
 459:../drivers/fsl_dspi.h ****  *   masterConfig.samplePoint                              = kDSPI_SckToSin0Clock;
 460:../drivers/fsl_dspi.h ****  *   DSPI_MasterInit(base, &masterConfig, srcClock_Hz);
 461:../drivers/fsl_dspi.h ****  *  @endcode
 462:../drivers/fsl_dspi.h ****  *
 463:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 464:../drivers/fsl_dspi.h ****  * @param masterConfig Pointer to the structure dspi_master_config_t.
 465:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz.
 466:../drivers/fsl_dspi.h ****  */
 467:../drivers/fsl_dspi.h **** void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz
 468:../drivers/fsl_dspi.h **** 
 469:../drivers/fsl_dspi.h **** /*!
 470:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_master_config_t structure to default values.
 471:../drivers/fsl_dspi.h ****  *
 472:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for the DSPI_MasterIni
 473:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_MasterInit() or modify the structu
 474:../drivers/fsl_dspi.h ****  * before calling the DSPI_MasterInit().
 475:../drivers/fsl_dspi.h ****  * Example:
 476:../drivers/fsl_dspi.h ****  * @code
 477:../drivers/fsl_dspi.h ****  *  dspi_master_config_t  masterConfig;
 478:../drivers/fsl_dspi.h ****  *  DSPI_MasterGetDefaultConfig(&masterConfig);
 479:../drivers/fsl_dspi.h ****  * @endcode
 480:../drivers/fsl_dspi.h ****  * @param masterConfig pointer to dspi_master_config_t structure
 481:../drivers/fsl_dspi.h ****  */
 482:../drivers/fsl_dspi.h **** void DSPI_MasterGetDefaultConfig(dspi_master_config_t *masterConfig);
 483:../drivers/fsl_dspi.h **** 
 484:../drivers/fsl_dspi.h **** /*!
 485:../drivers/fsl_dspi.h ****  * @brief DSPI slave configuration.
 486:../drivers/fsl_dspi.h ****  *
 487:../drivers/fsl_dspi.h ****  * This function initializes the DSPI slave configuration. This is an example use case.
 488:../drivers/fsl_dspi.h ****  *  @code
 489:../drivers/fsl_dspi.h ****  *   dspi_slave_config_t  slaveConfig;
 490:../drivers/fsl_dspi.h ****  *  slaveConfig->whichCtar                  = kDSPI_Ctar0;
 491:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.bitsPerFrame    = 8;
 492:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.cpol            = kDSPI_ClockPolarityActiveHigh;
 493:../drivers/fsl_dspi.h ****  *  slaveConfig->ctarConfig.cpha            = kDSPI_ClockPhaseFirstEdge;
 494:../drivers/fsl_dspi.h ****  *  slaveConfig->enableContinuousSCK        = false;
 495:../drivers/fsl_dspi.h ****  *  slaveConfig->enableRxFifoOverWrite      = false;
 496:../drivers/fsl_dspi.h ****  *  slaveConfig->enableModifiedTimingFormat = false;
 497:../drivers/fsl_dspi.h ****  *  slaveConfig->samplePoint                = kDSPI_SckToSin0Clock;
 498:../drivers/fsl_dspi.h ****  *   DSPI_SlaveInit(base, &slaveConfig);
 499:../drivers/fsl_dspi.h ****  *  @endcode
 500:../drivers/fsl_dspi.h ****  *
 501:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 502:../drivers/fsl_dspi.h ****  * @param slaveConfig Pointer to the structure dspi_master_config_t.
 503:../drivers/fsl_dspi.h ****  */
 504:../drivers/fsl_dspi.h **** void DSPI_SlaveInit(SPI_Type *base, const dspi_slave_config_t *slaveConfig);
 505:../drivers/fsl_dspi.h **** 
 506:../drivers/fsl_dspi.h **** /*!
 507:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_slave_config_t structure to a default value.
 508:../drivers/fsl_dspi.h ****  *
 509:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for the DSPI_SlaveInit
 510:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_SlaveInit() or modify the structur
 511:../drivers/fsl_dspi.h ****  * before calling the DSPI_SlaveInit().
 512:../drivers/fsl_dspi.h ****  * This is an example.
 513:../drivers/fsl_dspi.h ****  * @code
 514:../drivers/fsl_dspi.h ****  *  dspi_slave_config_t  slaveConfig;
 515:../drivers/fsl_dspi.h ****  *  DSPI_SlaveGetDefaultConfig(&slaveConfig);
 516:../drivers/fsl_dspi.h ****  * @endcode
 517:../drivers/fsl_dspi.h ****  * @param slaveConfig Pointer to the dspi_slave_config_t structure.
 518:../drivers/fsl_dspi.h ****  */
 519:../drivers/fsl_dspi.h **** void DSPI_SlaveGetDefaultConfig(dspi_slave_config_t *slaveConfig);
 520:../drivers/fsl_dspi.h **** 
 521:../drivers/fsl_dspi.h **** /*!
 522:../drivers/fsl_dspi.h ****  * @brief De-initializes the DSPI peripheral. Call this API to disable the DSPI clock.
 523:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 524:../drivers/fsl_dspi.h ****  */
 525:../drivers/fsl_dspi.h **** void DSPI_Deinit(SPI_Type *base);
 526:../drivers/fsl_dspi.h **** 
 527:../drivers/fsl_dspi.h **** /*!
 528:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI peripheral and sets the MCR MDIS to 0.
 529:../drivers/fsl_dspi.h ****  *
 530:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 531:../drivers/fsl_dspi.h ****  * @param enable Pass true to enable module, false to disable module.
 532:../drivers/fsl_dspi.h ****  */
 533:../drivers/fsl_dspi.h **** static inline void DSPI_Enable(SPI_Type *base, bool enable)
 534:../drivers/fsl_dspi.h **** {
 535:../drivers/fsl_dspi.h ****     if (enable)
 536:../drivers/fsl_dspi.h ****     {
 537:../drivers/fsl_dspi.h ****         base->MCR &= ~SPI_MCR_MDIS_MASK;
 538:../drivers/fsl_dspi.h ****     }
 539:../drivers/fsl_dspi.h ****     else
 540:../drivers/fsl_dspi.h ****     {
 541:../drivers/fsl_dspi.h ****         base->MCR |= SPI_MCR_MDIS_MASK;
 542:../drivers/fsl_dspi.h ****     }
 543:../drivers/fsl_dspi.h **** }
 544:../drivers/fsl_dspi.h **** 
 545:../drivers/fsl_dspi.h **** /*!
 546:../drivers/fsl_dspi.h ****  *@}
 547:../drivers/fsl_dspi.h **** */
 548:../drivers/fsl_dspi.h **** 
 549:../drivers/fsl_dspi.h **** /*!
 550:../drivers/fsl_dspi.h ****  * @name Status
 551:../drivers/fsl_dspi.h ****  * @{
 552:../drivers/fsl_dspi.h ****  */
 553:../drivers/fsl_dspi.h **** 
 554:../drivers/fsl_dspi.h **** /*!
 555:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI status flag state.
 556:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 557:../drivers/fsl_dspi.h ****  * @return DSPI status (in SR register).
 558:../drivers/fsl_dspi.h ****  */
 559:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_GetStatusFlags(SPI_Type *base)
 560:../drivers/fsl_dspi.h **** {
 561:../drivers/fsl_dspi.h ****     return (base->SR);
 562:../drivers/fsl_dspi.h **** }
 563:../drivers/fsl_dspi.h **** 
 564:../drivers/fsl_dspi.h **** /*!
 565:../drivers/fsl_dspi.h ****  * @brief Clears the DSPI status flag.
 566:../drivers/fsl_dspi.h ****  *
 567:../drivers/fsl_dspi.h ****  * This function  clears the desired status bit by using a write-1-to-clear. The user passes in the
 568:../drivers/fsl_dspi.h ****  * desired status bit to clear.  The list of status bits is defined in the dspi_status_and_interrup
 569:../drivers/fsl_dspi.h ****  * function uses these bit positions in its algorithm to clear the desired flag state.
 570:../drivers/fsl_dspi.h ****  * This is an example.
 571:../drivers/fsl_dspi.h ****  * @code
 572:../drivers/fsl_dspi.h ****  *  DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag|kDSPI_EndOfQueueFlag);
 573:../drivers/fsl_dspi.h ****  * @endcode
 574:../drivers/fsl_dspi.h ****  *
 575:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 576:../drivers/fsl_dspi.h ****  * @param statusFlags The status flag used from the type dspi_flags.
 577:../drivers/fsl_dspi.h ****  */
 578:../drivers/fsl_dspi.h **** static inline void DSPI_ClearStatusFlags(SPI_Type *base, uint32_t statusFlags)
 579:../drivers/fsl_dspi.h **** {
 580:../drivers/fsl_dspi.h ****     base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
 581:../drivers/fsl_dspi.h **** }
 582:../drivers/fsl_dspi.h **** 
 583:../drivers/fsl_dspi.h **** /*!
 584:../drivers/fsl_dspi.h ****  *@}
 585:../drivers/fsl_dspi.h **** */
 586:../drivers/fsl_dspi.h **** 
 587:../drivers/fsl_dspi.h **** /*!
 588:../drivers/fsl_dspi.h ****  * @name Interrupts
 589:../drivers/fsl_dspi.h ****  * @{
 590:../drivers/fsl_dspi.h ****  */
 591:../drivers/fsl_dspi.h **** 
 592:../drivers/fsl_dspi.h **** /*!
 593:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI interrupts.
 594:../drivers/fsl_dspi.h ****  *
 595:../drivers/fsl_dspi.h ****  * This function configures the various interrupt masks of the DSPI.  The parameters are a base and
 596:../drivers/fsl_dspi.h ****  * Note, for Tx Fill and Rx FIFO drain requests, enable the interrupt request and disable the DMA r
 597:../drivers/fsl_dspi.h ****  *       Do not use this API(write to RSER register) while DSPI is in running state.
 598:../drivers/fsl_dspi.h ****  *
 599:../drivers/fsl_dspi.h ****  * @code
 600:../drivers/fsl_dspi.h ****  *  DSPI_EnableInterrupts(base, kDSPI_TxCompleteInterruptEnable | kDSPI_EndOfQueueInterruptEnable )
 601:../drivers/fsl_dspi.h ****  * @endcode
 602:../drivers/fsl_dspi.h ****  *
 603:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 604:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum _dspi_interrupt_enable.
 605:../drivers/fsl_dspi.h ****  */
 606:../drivers/fsl_dspi.h **** void DSPI_EnableInterrupts(SPI_Type *base, uint32_t mask);
 607:../drivers/fsl_dspi.h **** 
 608:../drivers/fsl_dspi.h **** /*!
 609:../drivers/fsl_dspi.h ****  * @brief Disables the DSPI interrupts.
 610:../drivers/fsl_dspi.h ****  *
 611:../drivers/fsl_dspi.h ****  * @code
 612:../drivers/fsl_dspi.h ****  *  DSPI_DisableInterrupts(base, kDSPI_TxCompleteInterruptEnable | kDSPI_EndOfQueueInterruptEnable 
 613:../drivers/fsl_dspi.h ****  * @endcode
 614:../drivers/fsl_dspi.h ****  *
 615:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 616:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum _dspi_interrupt_enable.
 617:../drivers/fsl_dspi.h ****  */
 618:../drivers/fsl_dspi.h **** static inline void DSPI_DisableInterrupts(SPI_Type *base, uint32_t mask)
 619:../drivers/fsl_dspi.h **** {
 620:../drivers/fsl_dspi.h ****     base->RSER &= ~mask;
 621:../drivers/fsl_dspi.h **** }
 622:../drivers/fsl_dspi.h **** 
 623:../drivers/fsl_dspi.h **** /*!
 624:../drivers/fsl_dspi.h ****  *@}
 625:../drivers/fsl_dspi.h **** */
 626:../drivers/fsl_dspi.h **** 
 627:../drivers/fsl_dspi.h **** /*!
 628:../drivers/fsl_dspi.h ****  * @name DMA Control
 629:../drivers/fsl_dspi.h ****  * @{
 630:../drivers/fsl_dspi.h ****  */
 631:../drivers/fsl_dspi.h **** 
 632:../drivers/fsl_dspi.h **** /*!
 633:../drivers/fsl_dspi.h ****  * @brief Enables the DSPI DMA request.
 634:../drivers/fsl_dspi.h ****  *
 635:../drivers/fsl_dspi.h ****  * This function configures the Rx and Tx DMA mask of the DSPI.  The parameters are a base and a DM
 636:../drivers/fsl_dspi.h ****  * @code
 637:../drivers/fsl_dspi.h ****  *  DSPI_EnableDMA(base, kDSPI_TxDmaEnable | kDSPI_RxDmaEnable);
 638:../drivers/fsl_dspi.h ****  * @endcode
 639:../drivers/fsl_dspi.h ****  *
 640:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 641:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum dspi_dma_enable.
 642:../drivers/fsl_dspi.h ****  */
 643:../drivers/fsl_dspi.h **** static inline void DSPI_EnableDMA(SPI_Type *base, uint32_t mask)
 644:../drivers/fsl_dspi.h **** {
 645:../drivers/fsl_dspi.h ****     base->RSER |= mask;
 646:../drivers/fsl_dspi.h **** }
 647:../drivers/fsl_dspi.h **** 
 648:../drivers/fsl_dspi.h **** /*!
 649:../drivers/fsl_dspi.h ****  * @brief Disables the DSPI DMA request.
 650:../drivers/fsl_dspi.h ****  *
 651:../drivers/fsl_dspi.h ****  * This function configures the Rx and Tx DMA mask of the DSPI.  The parameters are a base and a DM
 652:../drivers/fsl_dspi.h ****  * @code
 653:../drivers/fsl_dspi.h ****  *  SPI_DisableDMA(base, kDSPI_TxDmaEnable | kDSPI_RxDmaEnable);
 654:../drivers/fsl_dspi.h ****  * @endcode
 655:../drivers/fsl_dspi.h ****  *
 656:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 657:../drivers/fsl_dspi.h ****  * @param mask The interrupt mask; use the enum dspi_dma_enable.
 658:../drivers/fsl_dspi.h ****  */
 659:../drivers/fsl_dspi.h **** static inline void DSPI_DisableDMA(SPI_Type *base, uint32_t mask)
 660:../drivers/fsl_dspi.h **** {
 661:../drivers/fsl_dspi.h ****     base->RSER &= ~mask;
 662:../drivers/fsl_dspi.h **** }
 663:../drivers/fsl_dspi.h **** 
 664:../drivers/fsl_dspi.h **** /*!
 665:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI master PUSHR data register address for the DMA operation.
 666:../drivers/fsl_dspi.h ****  *
 667:../drivers/fsl_dspi.h ****  * This function gets the DSPI master PUSHR data register address because this value is needed for 
 668:../drivers/fsl_dspi.h ****  *
 669:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 670:../drivers/fsl_dspi.h ****  * @return The DSPI master PUSHR data register address.
 671:../drivers/fsl_dspi.h ****  */
 672:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_MasterGetTxRegisterAddress(SPI_Type *base)
 673:../drivers/fsl_dspi.h **** {
 674:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->PUSHR);
 675:../drivers/fsl_dspi.h **** }
 676:../drivers/fsl_dspi.h **** 
 677:../drivers/fsl_dspi.h **** /*!
 678:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI slave PUSHR data register address for the DMA operation.
 679:../drivers/fsl_dspi.h ****  *
 680:../drivers/fsl_dspi.h ****  * This function gets the DSPI slave PUSHR data register address as this value is needed for the DM
 681:../drivers/fsl_dspi.h ****  *
 682:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 683:../drivers/fsl_dspi.h ****  * @return The DSPI slave PUSHR data register address.
 684:../drivers/fsl_dspi.h ****  */
 685:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_SlaveGetTxRegisterAddress(SPI_Type *base)
 686:../drivers/fsl_dspi.h **** {
 687:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->PUSHR_SLAVE);
 688:../drivers/fsl_dspi.h **** }
 689:../drivers/fsl_dspi.h **** 
 690:../drivers/fsl_dspi.h **** /*!
 691:../drivers/fsl_dspi.h ****  * @brief Gets the DSPI POPR data register address for the DMA operation.
 692:../drivers/fsl_dspi.h ****  *
 693:../drivers/fsl_dspi.h ****  * This function gets the DSPI POPR data register address as this value is needed for the DMA opera
 694:../drivers/fsl_dspi.h ****  *
 695:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 696:../drivers/fsl_dspi.h ****  * @return The DSPI POPR data register address.
 697:../drivers/fsl_dspi.h ****  */
 698:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_GetRxRegisterAddress(SPI_Type *base)
 699:../drivers/fsl_dspi.h **** {
 700:../drivers/fsl_dspi.h ****     return (uint32_t) & (base->POPR);
 701:../drivers/fsl_dspi.h **** }
 702:../drivers/fsl_dspi.h **** 
 703:../drivers/fsl_dspi.h **** /*!
 704:../drivers/fsl_dspi.h ****  *@}
 705:../drivers/fsl_dspi.h **** */
 706:../drivers/fsl_dspi.h **** 
 707:../drivers/fsl_dspi.h **** /*!
 708:../drivers/fsl_dspi.h ****  * @name Bus Operations
 709:../drivers/fsl_dspi.h ****  * @{
 710:../drivers/fsl_dspi.h ****  */
 711:../drivers/fsl_dspi.h **** 
 712:../drivers/fsl_dspi.h **** /*!
 713:../drivers/fsl_dspi.h ****  * @brief Configures the DSPI for master or slave.
 714:../drivers/fsl_dspi.h ****  *
 715:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 716:../drivers/fsl_dspi.h ****  * @param mode Mode setting (master or slave) of type dspi_master_slave_mode_t.
 717:../drivers/fsl_dspi.h ****  */
 718:../drivers/fsl_dspi.h **** static inline void DSPI_SetMasterSlaveMode(SPI_Type *base, dspi_master_slave_mode_t mode)
 719:../drivers/fsl_dspi.h **** {
 720:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~SPI_MCR_MSTR_MASK)) | SPI_MCR_MSTR(mode);
 721:../drivers/fsl_dspi.h **** }
 722:../drivers/fsl_dspi.h **** 
 723:../drivers/fsl_dspi.h **** /*!
 724:../drivers/fsl_dspi.h ****  * @brief Returns whether the DSPI module is in master mode.
 725:../drivers/fsl_dspi.h ****  *
 726:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 727:../drivers/fsl_dspi.h ****  * @return Returns true if the module is in master mode or false if the module is in slave mode.
 728:../drivers/fsl_dspi.h ****  */
 729:../drivers/fsl_dspi.h **** static inline bool DSPI_IsMaster(SPI_Type *base)
 730:../drivers/fsl_dspi.h **** {
 731:../drivers/fsl_dspi.h ****     return (bool)((base->MCR) & SPI_MCR_MSTR_MASK);
  39              		.loc 2 731 0
  40 0002 0368     		ldr	r3, [r0]
  41              	.LVL1:
  42              	.LBE208:
  43              	.LBE207:
1743:../drivers/fsl_dspi.c ****     if (DSPI_IsMaster(base))
  44              		.loc 1 1743 0
  45 0004 002B     		cmp	r3, #0
1744:../drivers/fsl_dspi.c ****     {
1745:../drivers/fsl_dspi.c ****         s_dspiMasterIsr(base, (dspi_master_handle_t *)param);
  46              		.loc 1 1745 0
  47 0006 B4BF     		ite	lt
  48 0008 034B     		ldrlt	r3, .L5
1746:../drivers/fsl_dspi.c ****     }
1747:../drivers/fsl_dspi.c ****     else
1748:../drivers/fsl_dspi.c ****     {
1749:../drivers/fsl_dspi.c ****         s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
  49              		.loc 1 1749 0
  50 000a 044B     		ldrge	r3, .L5+4
  51 000c 1B68     		ldr	r3, [r3]
  52 000e 9847     		blx	r3
  53              	.LVL2:
  54              	.LBB209:
  55              	.LBB210:
  56              		.file 3 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 412:../CMSIS/cmsis_gcc.h **** }
 413:../CMSIS/cmsis_gcc.h **** 
 414:../CMSIS/cmsis_gcc.h **** 
 415:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 416:../CMSIS/cmsis_gcc.h **** /**
 417:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 418:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 419:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 420:../CMSIS/cmsis_gcc.h ****  */
 421:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 422:../CMSIS/cmsis_gcc.h **** {
 423:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 424:../CMSIS/cmsis_gcc.h **** }
 425:../CMSIS/cmsis_gcc.h **** #endif
 426:../CMSIS/cmsis_gcc.h **** 
 427:../CMSIS/cmsis_gcc.h **** 
 428:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 429:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 430:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 431:../CMSIS/cmsis_gcc.h **** /**
 432:../CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 433:../CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 434:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 435:../CMSIS/cmsis_gcc.h ****  */
 436:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 437:../CMSIS/cmsis_gcc.h **** {
 438:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 439:../CMSIS/cmsis_gcc.h **** }
 440:../CMSIS/cmsis_gcc.h **** 
 441:../CMSIS/cmsis_gcc.h **** 
 442:../CMSIS/cmsis_gcc.h **** /**
 443:../CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 444:../CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 445:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 446:../CMSIS/cmsis_gcc.h ****  */
 447:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 448:../CMSIS/cmsis_gcc.h **** {
 449:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 450:../CMSIS/cmsis_gcc.h **** }
 451:../CMSIS/cmsis_gcc.h **** 
 452:../CMSIS/cmsis_gcc.h **** 
 453:../CMSIS/cmsis_gcc.h **** /**
 454:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 455:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 456:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 457:../CMSIS/cmsis_gcc.h ****  */
 458:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 459:../CMSIS/cmsis_gcc.h **** {
 460:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 461:../CMSIS/cmsis_gcc.h **** 
 462:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 463:../CMSIS/cmsis_gcc.h ****   return(result);
 464:../CMSIS/cmsis_gcc.h **** }
 465:../CMSIS/cmsis_gcc.h **** 
 466:../CMSIS/cmsis_gcc.h **** 
 467:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 468:../CMSIS/cmsis_gcc.h **** /**
 469:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 470:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 471:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 472:../CMSIS/cmsis_gcc.h ****  */
 473:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 474:../CMSIS/cmsis_gcc.h **** {
 475:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 476:../CMSIS/cmsis_gcc.h **** 
 477:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 478:../CMSIS/cmsis_gcc.h ****   return(result);
 479:../CMSIS/cmsis_gcc.h **** }
 480:../CMSIS/cmsis_gcc.h **** #endif
 481:../CMSIS/cmsis_gcc.h **** 
 482:../CMSIS/cmsis_gcc.h **** 
 483:../CMSIS/cmsis_gcc.h **** /**
 484:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 485:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 486:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 487:../CMSIS/cmsis_gcc.h ****  */
 488:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 489:../CMSIS/cmsis_gcc.h **** {
 490:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 491:../CMSIS/cmsis_gcc.h **** }
 492:../CMSIS/cmsis_gcc.h **** 
 493:../CMSIS/cmsis_gcc.h **** 
 494:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 495:../CMSIS/cmsis_gcc.h **** /**
 496:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 497:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 498:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 499:../CMSIS/cmsis_gcc.h ****  */
 500:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 501:../CMSIS/cmsis_gcc.h **** {
 502:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 503:../CMSIS/cmsis_gcc.h **** }
 504:../CMSIS/cmsis_gcc.h **** #endif
 505:../CMSIS/cmsis_gcc.h **** 
 506:../CMSIS/cmsis_gcc.h **** 
 507:../CMSIS/cmsis_gcc.h **** /**
 508:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 509:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 510:../CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 511:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 512:../CMSIS/cmsis_gcc.h ****  */
 513:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 514:../CMSIS/cmsis_gcc.h **** {
 515:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 516:../CMSIS/cmsis_gcc.h **** }
 517:../CMSIS/cmsis_gcc.h **** 
 518:../CMSIS/cmsis_gcc.h **** 
 519:../CMSIS/cmsis_gcc.h **** /**
 520:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 521:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 522:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 523:../CMSIS/cmsis_gcc.h ****  */
 524:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 525:../CMSIS/cmsis_gcc.h **** {
 526:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 527:../CMSIS/cmsis_gcc.h **** 
 528:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 529:../CMSIS/cmsis_gcc.h ****   return(result);
 530:../CMSIS/cmsis_gcc.h **** }
 531:../CMSIS/cmsis_gcc.h **** 
 532:../CMSIS/cmsis_gcc.h **** 
 533:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 534:../CMSIS/cmsis_gcc.h **** /**
 535:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 536:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 537:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 538:../CMSIS/cmsis_gcc.h ****  */
 539:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 540:../CMSIS/cmsis_gcc.h **** {
 541:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 542:../CMSIS/cmsis_gcc.h **** 
 543:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 544:../CMSIS/cmsis_gcc.h ****   return(result);
 545:../CMSIS/cmsis_gcc.h **** }
 546:../CMSIS/cmsis_gcc.h **** #endif
 547:../CMSIS/cmsis_gcc.h **** 
 548:../CMSIS/cmsis_gcc.h **** 
 549:../CMSIS/cmsis_gcc.h **** /**
 550:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 551:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 552:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 553:../CMSIS/cmsis_gcc.h ****  */
 554:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 555:../CMSIS/cmsis_gcc.h **** {
 556:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 557:../CMSIS/cmsis_gcc.h **** }
 558:../CMSIS/cmsis_gcc.h **** 
 559:../CMSIS/cmsis_gcc.h **** 
 560:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 561:../CMSIS/cmsis_gcc.h **** /**
 562:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 563:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 564:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 565:../CMSIS/cmsis_gcc.h ****  */
 566:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 567:../CMSIS/cmsis_gcc.h **** {
 568:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 569:../CMSIS/cmsis_gcc.h **** }
 570:../CMSIS/cmsis_gcc.h **** #endif
 571:../CMSIS/cmsis_gcc.h **** 
 572:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 573:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 574:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 575:../CMSIS/cmsis_gcc.h **** 
 576:../CMSIS/cmsis_gcc.h **** 
 577:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 578:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 579:../CMSIS/cmsis_gcc.h **** 
 580:../CMSIS/cmsis_gcc.h **** /**
 581:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 582:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 583:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 584:../CMSIS/cmsis_gcc.h ****  */
 585:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 586:../CMSIS/cmsis_gcc.h **** {
 587:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 588:../CMSIS/cmsis_gcc.h **** 
 589:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 590:../CMSIS/cmsis_gcc.h ****   return(result);
 591:../CMSIS/cmsis_gcc.h **** }
 592:../CMSIS/cmsis_gcc.h **** 
 593:../CMSIS/cmsis_gcc.h **** 
 594:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 595:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 596:../CMSIS/cmsis_gcc.h **** /**
 597:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 598:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 599:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 600:../CMSIS/cmsis_gcc.h ****  */
 601:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 602:../CMSIS/cmsis_gcc.h **** {
 603:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 604:../CMSIS/cmsis_gcc.h **** 
 605:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 606:../CMSIS/cmsis_gcc.h ****   return(result);
 607:../CMSIS/cmsis_gcc.h **** }
 608:../CMSIS/cmsis_gcc.h **** #endif
 609:../CMSIS/cmsis_gcc.h **** 
 610:../CMSIS/cmsis_gcc.h **** 
 611:../CMSIS/cmsis_gcc.h **** /**
 612:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 613:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 614:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 615:../CMSIS/cmsis_gcc.h ****  */
 616:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 617:../CMSIS/cmsis_gcc.h **** {
 618:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 619:../CMSIS/cmsis_gcc.h **** }
 620:../CMSIS/cmsis_gcc.h **** 
 621:../CMSIS/cmsis_gcc.h **** 
 622:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 623:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 624:../CMSIS/cmsis_gcc.h **** /**
 625:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 626:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 627:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 628:../CMSIS/cmsis_gcc.h ****  */
 629:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 630:../CMSIS/cmsis_gcc.h **** {
 631:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 632:../CMSIS/cmsis_gcc.h **** }
 633:../CMSIS/cmsis_gcc.h **** #endif
 634:../CMSIS/cmsis_gcc.h **** 
 635:../CMSIS/cmsis_gcc.h **** 
 636:../CMSIS/cmsis_gcc.h **** /**
 637:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 638:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 639:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 640:../CMSIS/cmsis_gcc.h ****  */
 641:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 642:../CMSIS/cmsis_gcc.h **** {
 643:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 644:../CMSIS/cmsis_gcc.h **** 
 645:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 646:../CMSIS/cmsis_gcc.h **** 
 647:../CMSIS/cmsis_gcc.h ****   return(result);
 648:../CMSIS/cmsis_gcc.h **** }
 649:../CMSIS/cmsis_gcc.h **** 
 650:../CMSIS/cmsis_gcc.h **** 
 651:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 652:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 653:../CMSIS/cmsis_gcc.h **** /**
 654:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 655:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 656:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 657:../CMSIS/cmsis_gcc.h ****  */
 658:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 659:../CMSIS/cmsis_gcc.h **** {
 660:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 661:../CMSIS/cmsis_gcc.h **** 
 662:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 663:../CMSIS/cmsis_gcc.h ****   return(result);
 664:../CMSIS/cmsis_gcc.h **** }
 665:../CMSIS/cmsis_gcc.h **** #endif
 666:../CMSIS/cmsis_gcc.h **** 
 667:../CMSIS/cmsis_gcc.h **** 
 668:../CMSIS/cmsis_gcc.h **** /**
 669:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 670:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 671:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 672:../CMSIS/cmsis_gcc.h ****  */
 673:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 674:../CMSIS/cmsis_gcc.h **** {
 675:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 676:../CMSIS/cmsis_gcc.h **** }
 677:../CMSIS/cmsis_gcc.h **** 
 678:../CMSIS/cmsis_gcc.h **** 
 679:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 680:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 681:../CMSIS/cmsis_gcc.h **** /**
 682:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 683:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 684:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 685:../CMSIS/cmsis_gcc.h ****  */
 686:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 687:../CMSIS/cmsis_gcc.h **** {
 688:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 689:../CMSIS/cmsis_gcc.h **** }
 690:../CMSIS/cmsis_gcc.h **** #endif
 691:../CMSIS/cmsis_gcc.h **** 
 692:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 693:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 694:../CMSIS/cmsis_gcc.h **** 
 695:../CMSIS/cmsis_gcc.h **** 
 696:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 697:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 698:../CMSIS/cmsis_gcc.h **** 
 699:../CMSIS/cmsis_gcc.h **** /**
 700:../CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 701:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 702:../CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 703:../CMSIS/cmsis_gcc.h ****  */
 704:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 705:../CMSIS/cmsis_gcc.h **** {
 706:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 707:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 708:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 709:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 710:../CMSIS/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 711:../CMSIS/cmsis_gcc.h **** #else
 712:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 713:../CMSIS/cmsis_gcc.h **** 
 714:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 715:../CMSIS/cmsis_gcc.h ****   return(result);
 716:../CMSIS/cmsis_gcc.h **** #endif
 717:../CMSIS/cmsis_gcc.h **** #else
 718:../CMSIS/cmsis_gcc.h ****   return(0U);
 719:../CMSIS/cmsis_gcc.h **** #endif
 720:../CMSIS/cmsis_gcc.h **** }
 721:../CMSIS/cmsis_gcc.h **** 
 722:../CMSIS/cmsis_gcc.h **** 
 723:../CMSIS/cmsis_gcc.h **** /**
 724:../CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 725:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 726:../CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 727:../CMSIS/cmsis_gcc.h ****  */
 728:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 729:../CMSIS/cmsis_gcc.h **** {
 730:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 731:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 732:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 733:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 734:../CMSIS/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 735:../CMSIS/cmsis_gcc.h **** #else
 736:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 737:../CMSIS/cmsis_gcc.h **** #endif
 738:../CMSIS/cmsis_gcc.h **** #else
 739:../CMSIS/cmsis_gcc.h ****   (void)fpscr;
 740:../CMSIS/cmsis_gcc.h **** #endif
 741:../CMSIS/cmsis_gcc.h **** }
 742:../CMSIS/cmsis_gcc.h **** 
 743:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 744:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 745:../CMSIS/cmsis_gcc.h **** 
 746:../CMSIS/cmsis_gcc.h **** 
 747:../CMSIS/cmsis_gcc.h **** 
 748:../CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 749:../CMSIS/cmsis_gcc.h **** 
 750:../CMSIS/cmsis_gcc.h **** 
 751:../CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 752:../CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 753:../CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 754:../CMSIS/cmsis_gcc.h ****   @{
 755:../CMSIS/cmsis_gcc.h **** */
 756:../CMSIS/cmsis_gcc.h **** 
 757:../CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 758:../CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 759:../CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 760:../CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 761:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 762:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 763:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 764:../CMSIS/cmsis_gcc.h **** #else
 765:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 766:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 767:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 768:../CMSIS/cmsis_gcc.h **** #endif
 769:../CMSIS/cmsis_gcc.h **** 
 770:../CMSIS/cmsis_gcc.h **** /**
 771:../CMSIS/cmsis_gcc.h ****   \brief   No Operation
 772:../CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 773:../CMSIS/cmsis_gcc.h ****  */
 774:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 775:../CMSIS/cmsis_gcc.h **** //{
 776:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("nop");
 777:../CMSIS/cmsis_gcc.h **** //}
 778:../CMSIS/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 779:../CMSIS/cmsis_gcc.h **** 
 780:../CMSIS/cmsis_gcc.h **** /**
 781:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Interrupt
 782:../CMSIS/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 783:../CMSIS/cmsis_gcc.h ****  */
 784:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 785:../CMSIS/cmsis_gcc.h **** //{
 786:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 787:../CMSIS/cmsis_gcc.h **** //}
 788:../CMSIS/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 789:../CMSIS/cmsis_gcc.h **** 
 790:../CMSIS/cmsis_gcc.h **** 
 791:../CMSIS/cmsis_gcc.h **** /**
 792:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Event
 793:../CMSIS/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 794:../CMSIS/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 795:../CMSIS/cmsis_gcc.h ****  */
 796:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 797:../CMSIS/cmsis_gcc.h **** //{
 798:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 799:../CMSIS/cmsis_gcc.h **** //}
 800:../CMSIS/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 801:../CMSIS/cmsis_gcc.h **** 
 802:../CMSIS/cmsis_gcc.h **** 
 803:../CMSIS/cmsis_gcc.h **** /**
 804:../CMSIS/cmsis_gcc.h ****   \brief   Send Event
 805:../CMSIS/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 806:../CMSIS/cmsis_gcc.h ****  */
 807:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 808:../CMSIS/cmsis_gcc.h **** //{
 809:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("sev");
 810:../CMSIS/cmsis_gcc.h **** //}
 811:../CMSIS/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 812:../CMSIS/cmsis_gcc.h **** 
 813:../CMSIS/cmsis_gcc.h **** 
 814:../CMSIS/cmsis_gcc.h **** /**
 815:../CMSIS/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 816:../CMSIS/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 817:../CMSIS/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 818:../CMSIS/cmsis_gcc.h ****            after the instruction has been completed.
 819:../CMSIS/cmsis_gcc.h ****  */
 820:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 821:../CMSIS/cmsis_gcc.h **** {
 822:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 823:../CMSIS/cmsis_gcc.h **** }
 824:../CMSIS/cmsis_gcc.h **** 
 825:../CMSIS/cmsis_gcc.h **** 
 826:../CMSIS/cmsis_gcc.h **** /**
 827:../CMSIS/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 828:../CMSIS/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 829:../CMSIS/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 830:../CMSIS/cmsis_gcc.h ****  */
 831:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 832:../CMSIS/cmsis_gcc.h **** {
 833:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
  57              		.loc 3 833 0
  58              		.syntax unified
  59              	@ 833 "../CMSIS/cmsis_gcc.h" 1
  60 0010 BFF34F8F 		dsb 0xF
  61              	@ 0 "" 2
  62              		.thumb
  63              		.syntax unified
  64              	.LBE210:
  65              	.LBE209:
1750:../drivers/fsl_dspi.c ****     }
1751:../drivers/fsl_dspi.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1752:../drivers/fsl_dspi.c ****   exception return operation might vector to incorrect interrupt */
1753:../drivers/fsl_dspi.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1754:../drivers/fsl_dspi.c ****     __DSB();
1755:../drivers/fsl_dspi.c **** #endif
1756:../drivers/fsl_dspi.c **** }
  66              		.loc 1 1756 0
  67 0014 08BD     		pop	{r3, pc}
  68              	.L6:
  69 0016 00BF     		.align	2
  70              	.L5:
  71 0018 00000000 		.word	.LANCHOR0
  72 001c 00000000 		.word	.LANCHOR1
  73              		.cfi_endproc
  74              	.LFE201:
  76              		.section	.text.DSPI_MasterGetFormattedCommand.constprop.4,"ax",%progbits
  77              		.align	1
  78              		.syntax unified
  79              		.thumb
  80              		.thumb_func
  81              		.fpu fpv4-sp-d16
  83              	DSPI_MasterGetFormattedCommand.constprop.4:
  84              	.LFB211:
 732:../drivers/fsl_dspi.h **** }
 733:../drivers/fsl_dspi.h **** /*!
 734:../drivers/fsl_dspi.h ****  * @brief Starts the DSPI transfers and clears HALT bit in MCR.
 735:../drivers/fsl_dspi.h ****  *
 736:../drivers/fsl_dspi.h ****  * This function sets the module to start data transfer in either master or slave mode.
 737:../drivers/fsl_dspi.h ****  *
 738:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 739:../drivers/fsl_dspi.h ****  */
 740:../drivers/fsl_dspi.h **** static inline void DSPI_StartTransfer(SPI_Type *base)
 741:../drivers/fsl_dspi.h **** {
 742:../drivers/fsl_dspi.h ****     base->MCR &= ~SPI_MCR_HALT_MASK;
 743:../drivers/fsl_dspi.h **** }
 744:../drivers/fsl_dspi.h **** /*!
 745:../drivers/fsl_dspi.h ****  * @brief Stops DSPI transfers and sets the HALT bit in MCR.
 746:../drivers/fsl_dspi.h ****  *
 747:../drivers/fsl_dspi.h ****  * This function stops data transfers in either master or slave modes.
 748:../drivers/fsl_dspi.h ****  *
 749:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 750:../drivers/fsl_dspi.h ****  */
 751:../drivers/fsl_dspi.h **** static inline void DSPI_StopTransfer(SPI_Type *base)
 752:../drivers/fsl_dspi.h **** {
 753:../drivers/fsl_dspi.h ****     base->MCR |= SPI_MCR_HALT_MASK;
 754:../drivers/fsl_dspi.h **** }
 755:../drivers/fsl_dspi.h **** 
 756:../drivers/fsl_dspi.h **** /*!
 757:../drivers/fsl_dspi.h ****  * @brief Enables or disables the DSPI FIFOs.
 758:../drivers/fsl_dspi.h ****  *
 759:../drivers/fsl_dspi.h ****  * This function  allows the caller to disable/enable the Tx and Rx FIFOs independently.
 760:../drivers/fsl_dspi.h ****  * Note that to disable, pass in a logic 0 (false) for the particular FIFO configuration.  To enabl
 761:../drivers/fsl_dspi.h ****  * pass in a logic 1 (true).
 762:../drivers/fsl_dspi.h ****  *
 763:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 764:../drivers/fsl_dspi.h ****  * @param enableTxFifo Disables (false) the TX FIFO; Otherwise, enables (true) the TX FIFO
 765:../drivers/fsl_dspi.h ****  * @param enableRxFifo Disables (false) the RX FIFO; Otherwise, enables (true) the RX FIFO
 766:../drivers/fsl_dspi.h ****  */
 767:../drivers/fsl_dspi.h **** static inline void DSPI_SetFifoEnable(SPI_Type *base, bool enableTxFifo, bool enableRxFifo)
 768:../drivers/fsl_dspi.h **** {
 769:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~(SPI_MCR_DIS_RXF_MASK | SPI_MCR_DIS_TXF_MASK))) | SPI_MCR_DIS_TXF(!e
 770:../drivers/fsl_dspi.h ****                 SPI_MCR_DIS_RXF(!enableRxFifo);
 771:../drivers/fsl_dspi.h **** }
 772:../drivers/fsl_dspi.h **** 
 773:../drivers/fsl_dspi.h **** /*!
 774:../drivers/fsl_dspi.h ****  * @brief Flushes the DSPI FIFOs.
 775:../drivers/fsl_dspi.h ****  *
 776:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 777:../drivers/fsl_dspi.h ****  * @param flushTxFifo Flushes (true) the Tx FIFO; Otherwise, does not flush (false) the Tx FIFO
 778:../drivers/fsl_dspi.h ****  * @param flushRxFifo Flushes (true) the Rx FIFO; Otherwise, does not flush (false) the Rx FIFO
 779:../drivers/fsl_dspi.h ****  */
 780:../drivers/fsl_dspi.h **** static inline void DSPI_FlushFifo(SPI_Type *base, bool flushTxFifo, bool flushRxFifo)
 781:../drivers/fsl_dspi.h **** {
 782:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) | SPI_MCR_CLR_TXF(fl
 783:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 784:../drivers/fsl_dspi.h **** }
 785:../drivers/fsl_dspi.h **** 
 786:../drivers/fsl_dspi.h **** /*!
 787:../drivers/fsl_dspi.h ****  * @brief Configures the DSPI peripheral chip select polarity simultaneously.
 788:../drivers/fsl_dspi.h ****  * For example, PCS0 and PCS1 are set to active low and other PCS is set to active high. Note that 
 789:../drivers/fsl_dspi.h ****  * PCSs is specific to the device.
 790:../drivers/fsl_dspi.h ****  * @code
 791:../drivers/fsl_dspi.h ****  *  DSPI_SetAllPcsPolarity(base, kDSPI_Pcs0ActiveLow | kDSPI_Pcs1ActiveLow);
 792:../drivers/fsl_dspi.h ****    @endcode
 793:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 794:../drivers/fsl_dspi.h ****  * @param mask The PCS polarity mask; use the enum _dspi_pcs_polarity.
 795:../drivers/fsl_dspi.h ****  */
 796:../drivers/fsl_dspi.h **** static inline void DSPI_SetAllPcsPolarity(SPI_Type *base, uint32_t mask)
 797:../drivers/fsl_dspi.h **** {
 798:../drivers/fsl_dspi.h ****     base->MCR = (base->MCR & ~SPI_MCR_PCSIS_MASK) | SPI_MCR_PCSIS(mask);
 799:../drivers/fsl_dspi.h **** }
 800:../drivers/fsl_dspi.h **** 
 801:../drivers/fsl_dspi.h **** /*!
 802:../drivers/fsl_dspi.h ****  * @brief Sets the DSPI baud rate in bits per second.
 803:../drivers/fsl_dspi.h ****  *
 804:../drivers/fsl_dspi.h ****  * This function  takes in the desired baudRate_Bps (baud rate) and calculates the nearest possible
 805:../drivers/fsl_dspi.h ****  * exceeding the desired baud rate, and returns the calculated baud rate in bits-per-second. It req
 806:../drivers/fsl_dspi.h ****  * caller also provide the frequency of the module source clock (in Hertz).
 807:../drivers/fsl_dspi.h ****  *
 808:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 809:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of the type dspi_ctar
 810:../drivers/fsl_dspi.h ****  * @param baudRate_Bps The desired baud rate in bits per second
 811:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz
 812:../drivers/fsl_dspi.h ****  * @return The actual calculated baud rate
 813:../drivers/fsl_dspi.h ****  */
 814:../drivers/fsl_dspi.h **** uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
 815:../drivers/fsl_dspi.h ****                                 dspi_ctar_selection_t whichCtar,
 816:../drivers/fsl_dspi.h ****                                 uint32_t baudRate_Bps,
 817:../drivers/fsl_dspi.h ****                                 uint32_t srcClock_Hz);
 818:../drivers/fsl_dspi.h **** 
 819:../drivers/fsl_dspi.h **** /*!
 820:../drivers/fsl_dspi.h ****  * @brief Manually configures the delay prescaler and scaler for a particular CTAR.
 821:../drivers/fsl_dspi.h ****  *
 822:../drivers/fsl_dspi.h ****  * This function configures the PCS to SCK delay pre-scalar (PcsSCK) and scalar (CSSCK), after SCK 
 823:../drivers/fsl_dspi.h ****  * (PASC) and scalar (ASC), and the delay after transfer pre-scalar (PDT) and scalar (DT).
 824:../drivers/fsl_dspi.h ****  *
 825:../drivers/fsl_dspi.h ****  * These delay names are available in the type dspi_delay_type_t.
 826:../drivers/fsl_dspi.h ****  *
 827:../drivers/fsl_dspi.h ****  * The user passes the delay to the configuration along with the prescaler and scaler value.
 828:../drivers/fsl_dspi.h ****  * This allows the user to directly set the prescaler/scaler values if pre-calculated or
 829:../drivers/fsl_dspi.h ****  * to manually increment either value.
 830:../drivers/fsl_dspi.h ****  *
 831:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 832:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of type dspi_ctar_sel
 833:../drivers/fsl_dspi.h ****  * @param prescaler The prescaler delay value (can be an integer 0, 1, 2, or 3).
 834:../drivers/fsl_dspi.h ****  * @param scaler The scaler delay value (can be any integer between 0 to 15).
 835:../drivers/fsl_dspi.h ****  * @param whichDelay The desired delay to configure; must be of type dspi_delay_type_t
 836:../drivers/fsl_dspi.h ****  */
 837:../drivers/fsl_dspi.h **** void DSPI_MasterSetDelayScaler(
 838:../drivers/fsl_dspi.h ****     SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_dela
 839:../drivers/fsl_dspi.h **** 
 840:../drivers/fsl_dspi.h **** /*!
 841:../drivers/fsl_dspi.h ****  * @brief Calculates the delay prescaler and scaler based on the desired delay input in nanoseconds
 842:../drivers/fsl_dspi.h ****  *
 843:../drivers/fsl_dspi.h ****  * This function calculates the values for the following.
 844:../drivers/fsl_dspi.h ****  * PCS to SCK delay pre-scalar (PCSSCK) and scalar (CSSCK), or
 845:../drivers/fsl_dspi.h ****  * After SCK delay pre-scalar (PASC) and scalar (ASC), or
 846:../drivers/fsl_dspi.h ****  * Delay after transfer pre-scalar (PDT) and scalar (DT).
 847:../drivers/fsl_dspi.h ****  *
 848:../drivers/fsl_dspi.h ****  * These delay names are available in the type dspi_delay_type_t.
 849:../drivers/fsl_dspi.h ****  *
 850:../drivers/fsl_dspi.h ****  * The user passes which delay to configure along with the desired delay value in nanoseconds.  The
 851:../drivers/fsl_dspi.h ****  * calculates the values needed for the prescaler and scaler. Note that returning the calculated de
 852:../drivers/fsl_dspi.h ****  * delay match may not be possible. In this case, the closest match is calculated without going bel
 853:../drivers/fsl_dspi.h ****  * delay value input.
 854:../drivers/fsl_dspi.h ****  * It is possible to input a very large delay value that exceeds the capability of the part, in whi
 855:../drivers/fsl_dspi.h ****  * supported delay is returned. The higher-level peripheral driver alerts the user of an out of ran
 856:../drivers/fsl_dspi.h ****  * input.
 857:../drivers/fsl_dspi.h ****  *
 858:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 859:../drivers/fsl_dspi.h ****  * @param whichCtar The desired Clock and Transfer Attributes Register (CTAR) of type dspi_ctar_sel
 860:../drivers/fsl_dspi.h ****  * @param whichDelay The desired delay to configure, must be of type dspi_delay_type_t
 861:../drivers/fsl_dspi.h ****  * @param srcClock_Hz Module source input clock in Hertz
 862:../drivers/fsl_dspi.h ****  * @param delayTimeInNanoSec The desired delay value in nanoseconds.
 863:../drivers/fsl_dspi.h ****  * @return The actual calculated delay value.
 864:../drivers/fsl_dspi.h ****  */
 865:../drivers/fsl_dspi.h **** uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
 866:../drivers/fsl_dspi.h ****                                   dspi_ctar_selection_t whichCtar,
 867:../drivers/fsl_dspi.h ****                                   dspi_delay_type_t whichDelay,
 868:../drivers/fsl_dspi.h ****                                   uint32_t srcClock_Hz,
 869:../drivers/fsl_dspi.h ****                                   uint32_t delayTimeInNanoSec);
 870:../drivers/fsl_dspi.h **** 
 871:../drivers/fsl_dspi.h **** /*!
 872:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer for master mode.
 873:../drivers/fsl_dspi.h ****  *
 874:../drivers/fsl_dspi.h ****  * In master mode, the 16-bit data is appended to the 16-bit command info. The command portion
 875:../drivers/fsl_dspi.h ****  * provides characteristics of the data, such as the optional continuous chip select
 876:../drivers/fsl_dspi.h ****  * operation between transfers, the desired Clock and Transfer Attributes register to use for the
 877:../drivers/fsl_dspi.h ****  * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
 878:../drivers/fsl_dspi.h ****  * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
 879:../drivers/fsl_dspi.h ****  * sending the first frame of a data packet). This is an example.
 880:../drivers/fsl_dspi.h ****  * @code
 881:../drivers/fsl_dspi.h ****  *  dspi_command_data_config_t commandConfig;
 882:../drivers/fsl_dspi.h ****  *  commandConfig.isPcsContinuous = true;
 883:../drivers/fsl_dspi.h ****  *  commandConfig.whichCtar = kDSPICtar0;
 884:../drivers/fsl_dspi.h ****  *  commandConfig.whichPcs = kDSPIPcs0;
 885:../drivers/fsl_dspi.h ****  *  commandConfig.clearTransferCount = false;
 886:../drivers/fsl_dspi.h ****  *  commandConfig.isEndOfQueue = false;
 887:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteData(base, &commandConfig, dataWord);
 888:../drivers/fsl_dspi.h ****    @endcode
 889:../drivers/fsl_dspi.h ****  *
 890:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 891:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 892:../drivers/fsl_dspi.h ****  * @param data The data word to be sent.
 893:../drivers/fsl_dspi.h ****  */
 894:../drivers/fsl_dspi.h **** static inline void DSPI_MasterWriteData(SPI_Type *base, dspi_command_data_config_t *command, uint16
 895:../drivers/fsl_dspi.h **** {
 896:../drivers/fsl_dspi.h ****     base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
 897:../drivers/fsl_dspi.h ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 898:../drivers/fsl_dspi.h ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 899:../drivers/fsl_dspi.h **** }
 900:../drivers/fsl_dspi.h **** 
 901:../drivers/fsl_dspi.h **** /*!
 902:../drivers/fsl_dspi.h ****  * @brief Sets the dspi_command_data_config_t structure to default values.
 903:../drivers/fsl_dspi.h ****  *
 904:../drivers/fsl_dspi.h ****  * The purpose of this API is to get the configuration structure initialized for use in the DSPI_Ma
 905:../drivers/fsl_dspi.h ****  * Users may use the initialized structure unchanged in the DSPI_MasterWrite_xx() or modify the str
 906:../drivers/fsl_dspi.h ****  * before calling the DSPI_MasterWrite_xx().
 907:../drivers/fsl_dspi.h ****  * This is an example.
 908:../drivers/fsl_dspi.h ****  * @code
 909:../drivers/fsl_dspi.h ****  *  dspi_command_data_config_t  command;
 910:../drivers/fsl_dspi.h ****  *  DSPI_GetDefaultDataCommandConfig(&command);
 911:../drivers/fsl_dspi.h ****  * @endcode
 912:../drivers/fsl_dspi.h ****  * @param command Pointer to the dspi_command_data_config_t structure.
 913:../drivers/fsl_dspi.h ****  */
 914:../drivers/fsl_dspi.h **** void DSPI_GetDefaultDataCommandConfig(dspi_command_data_config_t *command);
 915:../drivers/fsl_dspi.h **** 
 916:../drivers/fsl_dspi.h **** /*!
 917:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer master mode and waits till complete to return.
 918:../drivers/fsl_dspi.h ****  *
 919:../drivers/fsl_dspi.h ****  * In master mode, the 16-bit data is appended to the 16-bit command info. The command portion
 920:../drivers/fsl_dspi.h ****  * provides characteristics of the data, such as the optional continuous chip select
 921:../drivers/fsl_dspi.h ****  * operation between transfers, the desired Clock and Transfer Attributes register to use for the
 922:../drivers/fsl_dspi.h ****  * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
 923:../drivers/fsl_dspi.h ****  * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
 924:../drivers/fsl_dspi.h ****  * sending the first frame of a data packet). This is an example.
 925:../drivers/fsl_dspi.h ****  * @code
 926:../drivers/fsl_dspi.h ****  *  dspi_command_config_t commandConfig;
 927:../drivers/fsl_dspi.h ****  *  commandConfig.isPcsContinuous = true;
 928:../drivers/fsl_dspi.h ****  *  commandConfig.whichCtar = kDSPICtar0;
 929:../drivers/fsl_dspi.h ****  *  commandConfig.whichPcs = kDSPIPcs1;
 930:../drivers/fsl_dspi.h ****  *  commandConfig.clearTransferCount = false;
 931:../drivers/fsl_dspi.h ****  *  commandConfig.isEndOfQueue = false;
 932:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteDataBlocking(base, &commandConfig, dataWord);
 933:../drivers/fsl_dspi.h ****  * @endcode
 934:../drivers/fsl_dspi.h ****  *
 935:../drivers/fsl_dspi.h ****  * Note that this function does not return until after the transmit is complete. Also note that the
 936:../drivers/fsl_dspi.h ****  * enabled and running to transmit data (MCR[MDIS] & [HALT] = 0). Because the SPI is a synchronous 
 937:../drivers/fsl_dspi.h ****  * the received data is available when the transmit completes.
 938:../drivers/fsl_dspi.h ****  *
 939:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
 940:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 941:../drivers/fsl_dspi.h ****  * @param data The data word to be sent.
 942:../drivers/fsl_dspi.h ****  */
 943:../drivers/fsl_dspi.h **** void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t dat
 944:../drivers/fsl_dspi.h **** 
 945:../drivers/fsl_dspi.h **** /*!
 946:../drivers/fsl_dspi.h ****  * @brief Returns the DSPI command word formatted to the PUSHR data register bit field.
 947:../drivers/fsl_dspi.h ****  *
 948:../drivers/fsl_dspi.h ****  * This function allows the caller to pass in the data command structure and returns the command wo
 949:../drivers/fsl_dspi.h ****  * according to the DSPI PUSHR register bit field placement. The user can then "OR" the returned co
 950:../drivers/fsl_dspi.h ****  * desired data to send and use the function DSPI_HAL_WriteCommandDataMastermode or
 951:../drivers/fsl_dspi.h ****  * DSPI_HAL_WriteCommandDataMastermodeBlocking to write the entire 32-bit command data word to the 
 952:../drivers/fsl_dspi.h ****  * improve performance in cases where the command structure is constant. For example, the user call
 953:../drivers/fsl_dspi.h ****  * before starting a transfer to generate the command word. When they are ready to transmit the dat
 954:../drivers/fsl_dspi.h ****  * this formatted command word with the desired data to transmit. This process increases transmit p
 955:../drivers/fsl_dspi.h ****  * compared to calling send functions, such as DSPI_HAL_WriteDataMastermode,  which format the comm
 956:../drivers/fsl_dspi.h ****  * data word is to be sent.
 957:../drivers/fsl_dspi.h ****  *
 958:../drivers/fsl_dspi.h ****  * @param command Pointer to the command structure.
 959:../drivers/fsl_dspi.h ****  * @return The command word formatted to the PUSHR data register bit field.
 960:../drivers/fsl_dspi.h ****  */
 961:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_MasterGetFormattedCommand(dspi_command_data_config_t *command)
  85              		.loc 2 961 0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  89              		@ link register save eliminated.
  90              	.LVL3:
 962:../drivers/fsl_dspi.h **** {
 963:../drivers/fsl_dspi.h ****     /* Format the 16-bit command word according to the PUSHR data register bit field*/
 964:../drivers/fsl_dspi.h ****     return (uint32_t)(SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar)
 965:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
  91              		.loc 2 965 0
  92 0000 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
  93              		.loc 2 964 0
  94 0002 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
  95              		.loc 2 965 0
  96 0004 DB06     		lsls	r3, r3, #27
  97 0006 43EAC273 		orr	r3, r3, r2, lsl #31
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
  98              		.loc 2 964 0
  99 000a 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 100              		.loc 2 965 0
 101 000c 8078     		ldrb	r0, [r0, #2]	@ zero_extendqisi2
 102              	.LVL4:
 964:../drivers/fsl_dspi.h ****                       SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 103              		.loc 2 964 0
 104 000e 1207     		lsls	r2, r2, #28
 105 0010 02F0E042 		and	r2, r2, #1879048192
 106              		.loc 2 965 0
 107 0014 0004     		lsls	r0, r0, #16
 108 0016 1343     		orrs	r3, r3, r2
 109 0018 00F47C10 		and	r0, r0, #4128768
 966:../drivers/fsl_dspi.h ****                       SPI_PUSHR_CTCNT(command->clearTransferCount));
 967:../drivers/fsl_dspi.h **** }
 110              		.loc 2 967 0
 111 001c 1843     		orrs	r0, r0, r3
 112 001e 7047     		bx	lr
 113              		.cfi_endproc
 114              	.LFE211:
 116              		.section	.text.DSPI_GetInstance,"ax",%progbits
 117              		.align	1
 118              		.global	DSPI_GetInstance
 119              		.syntax unified
 120              		.thumb
 121              		.thumb_func
 122              		.fpu fpv4-sp-d16
 124              	DSPI_GetInstance:
 125              	.LFB167:
 150:../drivers/fsl_dspi.c ****     uint32_t instance;
 126              		.loc 1 150 0
 127              		.cfi_startproc
 128              		@ args = 0, pretend = 0, frame = 0
 129              		@ frame_needed = 0, uses_anonymous_args = 0
 130              		@ link register save eliminated.
 131              	.LVL5:
 156:../drivers/fsl_dspi.c ****         {
 132              		.loc 1 156 0
 133 0000 084B     		ldr	r3, .L13
 134 0002 9842     		cmp	r0, r3
 135 0004 0AD0     		beq	.L10
 136              	.LVL6:
 137 0006 03F58053 		add	r3, r3, #4096
 138 000a 9842     		cmp	r0, r3
 139 000c 08D0     		beq	.L11
 140              	.LVL7:
 154:../drivers/fsl_dspi.c ****     {
 141              		.loc 1 154 0
 142 000e 03F5FE23 		add	r3, r3, #520192
 143 0012 9842     		cmp	r0, r3
 144 0014 0CBF     		ite	eq
 145 0016 0220     		moveq	r0, #2
 146 0018 0320     		movne	r0, #3
 147              	.LVL8:
 148 001a 7047     		bx	lr
 149              	.LVL9:
 150              	.L10:
 151 001c 0020     		movs	r0, #0
 152              	.LVL10:
 153 001e 7047     		bx	lr
 154              	.LVL11:
 155              	.L11:
 156 0020 0120     		movs	r0, #1
 157              	.LVL12:
 165:../drivers/fsl_dspi.c **** 
 158              		.loc 1 165 0
 159 0022 7047     		bx	lr
 160              	.L14:
 161              		.align	2
 162              	.L13:
 163 0024 00C00240 		.word	1073922048
 164              		.cfi_endproc
 165              	.LFE167:
 167              		.section	.text.DSPI_MasterTransferFillUpTxFifo,"ax",%progbits
 168              		.align	1
 169              		.syntax unified
 170              		.thumb
 171              		.thumb_func
 172              		.fpu fpv4-sp-d16
 174              	DSPI_MasterTransferFillUpTxFifo:
 175              	.LFB191:
1094:../drivers/fsl_dspi.c ****     assert(handle);
 176              		.loc 1 1094 0
 177              		.cfi_startproc
 178              		@ args = 0, pretend = 0, frame = 0
 179              		@ frame_needed = 0, uses_anonymous_args = 0
 180              	.LVL13:
 181 0000 70B5     		push	{r4, r5, r6, lr}
 182              		.cfi_def_cfa_offset 16
 183              		.cfi_offset 4, -16
 184              		.cfi_offset 5, -12
 185              		.cfi_offset 6, -8
 186              		.cfi_offset 14, -4
1094:../drivers/fsl_dspi.c ****     assert(handle);
 187              		.loc 1 1094 0
 188 0002 0446     		mov	r4, r0
1098:../drivers/fsl_dspi.c **** 
 189              		.loc 1 1098 0
 190 0004 FFF7FEFF 		bl	DSPI_GetInstance
 191              	.LVL14:
 192 0008 394B     		ldr	r3, .L46
1101:../drivers/fsl_dspi.c ****     {
 193              		.loc 1 1101 0
 194 000a 0A68     		ldr	r2, [r1]
1098:../drivers/fsl_dspi.c **** 
 195              		.loc 1 1098 0
 196 000c 1B5C     		ldrb	r3, [r3, r0]	@ zero_extendqisi2
1101:../drivers/fsl_dspi.c ****     {
 197              		.loc 1 1101 0
 198 000e 082A     		cmp	r2, #8
1098:../drivers/fsl_dspi.c **** 
 199              		.loc 1 1098 0
 200 0010 DBB2     		uxtb	r3, r3
 201              	.LVL15:
1149:../drivers/fsl_dspi.c ****                 }
 202              		.loc 1 1149 0
 203 0012 9BB2     		uxth	r3, r3
 204              	.LVL16:
1101:../drivers/fsl_dspi.c ****     {
 205              		.loc 1 1101 0
 206 0014 2DD9     		bls	.L43
1134:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->lastCommand | wordToSend;
 207              		.loc 1 1134 0
 208 0016 0020     		movs	r0, #0
 209              	.LBB211:
 210              	.LBB212:
 580:../drivers/fsl_dspi.h **** }
 211              		.loc 2 580 0
 212 0018 4FF00075 		mov	r5, #33554432
 213              	.LVL17:
 214              	.L16:
 215              	.LBE212:
 216              	.LBE211:
 217              	.LBB214:
 218              	.LBB215:
 561:../drivers/fsl_dspi.h **** }
 219              		.loc 2 561 0
 220 001c E26A     		ldr	r2, [r4, #44]
 221              	.LVL18:
 222              	.LBE215:
 223              	.LBE214:
1112:../drivers/fsl_dspi.c ****                ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) / 2 < handle->
 224              		.loc 1 1112 0
 225 001e 9601     		lsls	r6, r2, #6
 226 0020 26D5     		bpl	.L15
1113:../drivers/fsl_dspi.c ****         {
 227              		.loc 1 1113 0 discriminator 1
 228 0022 CA69     		ldr	r2, [r1, #28]
 229 0024 8E69     		ldr	r6, [r1, #24]
 230 0026 921B     		subs	r2, r2, r6
 231 0028 0E7B     		ldrb	r6, [r1, #12]	@ zero_extendqisi2
1112:../drivers/fsl_dspi.c ****                ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) / 2 < handle->
 232              		.loc 1 1112 0 discriminator 1
 233 002a B6EB520F 		cmp	r6, r2, lsr #1
 234 002e 1FD9     		bls	.L15
1115:../drivers/fsl_dspi.c ****             {
 235              		.loc 1 1115 0
 236 0030 8A69     		ldr	r2, [r1, #24]
 237 0032 022A     		cmp	r2, #2
1117:../drivers/fsl_dspi.c ****                 {
 238              		.loc 1 1117 0
 239 0034 0A69     		ldr	r2, [r1, #16]
1115:../drivers/fsl_dspi.c ****             {
 240              		.loc 1 1115 0
 241 0036 45D8     		bhi	.L18
1117:../drivers/fsl_dspi.c ****                 {
 242              		.loc 1 1117 0
 243 0038 002A     		cmp	r2, #0
 244 003a 41D0     		beq	.L19
1119:../drivers/fsl_dspi.c ****                     {
 245              		.loc 1 1119 0
 246 003c 8A69     		ldr	r2, [r1, #24]
 247 003e 012A     		cmp	r2, #1
1121:../drivers/fsl_dspi.c ****                     }
 248              		.loc 1 1121 0
 249 0040 0A69     		ldr	r2, [r1, #16]
1126:../drivers/fsl_dspi.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 250              		.loc 1 1126 0
 251 0042 18BF     		it	ne
 252 0044 0E69     		ldrne	r6, [r1, #16]
1121:../drivers/fsl_dspi.c ****                     }
 253              		.loc 1 1121 0
 254 0046 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 255              	.LVL19:
1126:../drivers/fsl_dspi.c ****                         wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 256              		.loc 1 1126 0
 257 0048 1FBF     		itttt	ne
 258 004a 0136     		addne	r6, r6, #1
 259 004c 0E61     		strne	r6, [r1, #16]
1127:../drivers/fsl_dspi.c ****                     }
 260              		.loc 1 1127 0
 261 004e 0E69     		ldrne	r6, [r1, #16]
 262 0050 3678     		ldrbne	r6, [r6]	@ zero_extendqisi2
 263 0052 18BF     		it	ne
 264 0054 42EA0622 		orrne	r2, r2, r6, lsl #8
 265              	.LVL20:
 266              	.L21:
1134:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->lastCommand | wordToSend;
 267              		.loc 1 1134 0
 268 0058 8861     		str	r0, [r1, #24]
1135:../drivers/fsl_dspi.c ****             }
 269              		.loc 1 1135 0
 270 005a 8E68     		ldr	r6, [r1, #8]
 271              	.L44:
1152:../drivers/fsl_dspi.c ****             }
 272              		.loc 1 1152 0
 273 005c 3243     		orrs	r2, r2, r6
 274              	.LVL21:
 275 005e 6263     		str	r2, [r4, #52]
 276              	.LVL22:
 277              	.LBB216:
 278              	.LBB213:
 580:../drivers/fsl_dspi.h **** }
 279              		.loc 2 580 0
 280 0060 E562     		str	r5, [r4, #44]
 281              	.LVL23:
 282              	.LBE213:
 283              	.LBE216:
1161:../drivers/fsl_dspi.c ****             {
 284              		.loc 1 1161 0
 285 0062 8A69     		ldr	r2, [r1, #24]
 286 0064 22B1     		cbz	r2, .L15
1161:../drivers/fsl_dspi.c ****             {
 287              		.loc 1 1161 0 is_stmt 0 discriminator 1
 288 0066 0A6A     		ldr	r2, [r1, #32]
 289 0068 8E69     		ldr	r6, [r1, #24]
 290 006a 023A     		subs	r2, r2, #2
 291 006c 9642     		cmp	r6, r2
 292 006e D5D1     		bne	.L16
 293              	.L15:
1211:../drivers/fsl_dspi.c **** 
 294              		.loc 1 1211 0 is_stmt 1
 295 0070 70BD     		pop	{r4, r5, r6, pc}
 296              	.LVL24:
 297              	.L43:
 298              	.LBB217:
 299              	.LBB218:
 580:../drivers/fsl_dspi.h **** }
 300              		.loc 2 580 0
 301 0072 4FF00075 		mov	r5, #33554432
 302              	.LVL25:
 303              	.L17:
 304              	.LBE218:
 305              	.LBE217:
 306              	.LBB220:
 307              	.LBB221:
 561:../drivers/fsl_dspi.h **** }
 308              		.loc 2 561 0
 309 0076 E26A     		ldr	r2, [r4, #44]
 310              	.LVL26:
 311              	.LBE221:
 312              	.LBE220:
1175:../drivers/fsl_dspi.c ****                ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) < handle->fifo
 313              		.loc 1 1175 0
 314 0078 9201     		lsls	r2, r2, #6
 315 007a F9D5     		bpl	.L15
1176:../drivers/fsl_dspi.c ****         {
 316              		.loc 1 1176 0 discriminator 1
 317 007c CA69     		ldr	r2, [r1, #28]
 318 007e 8869     		ldr	r0, [r1, #24]
 319 0080 121A     		subs	r2, r2, r0
 320 0082 087B     		ldrb	r0, [r1, #12]	@ zero_extendqisi2
1175:../drivers/fsl_dspi.c ****                ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) < handle->fifo
 321              		.loc 1 1175 0 discriminator 1
 322 0084 8242     		cmp	r2, r0
 323 0086 F3D2     		bcs	.L15
1178:../drivers/fsl_dspi.c ****             {
 324              		.loc 1 1178 0
 325 0088 0A69     		ldr	r2, [r1, #16]
 326 008a 002A     		cmp	r2, #0
 327 008c 2ED0     		beq	.L28
1180:../drivers/fsl_dspi.c ****                 ++handle->txData;
 328              		.loc 1 1180 0
 329 008e 0A69     		ldr	r2, [r1, #16]
 330 0090 1078     		ldrb	r0, [r2]	@ zero_extendqisi2
 331              	.LVL27:
1181:../drivers/fsl_dspi.c ****             }
 332              		.loc 1 1181 0
 333 0092 0A69     		ldr	r2, [r1, #16]
 334 0094 0132     		adds	r2, r2, #1
 335 0096 0A61     		str	r2, [r1, #16]
 336              	.LVL28:
 337              	.L29:
1188:../drivers/fsl_dspi.c ****             {
 338              		.loc 1 1188 0
 339 0098 8A69     		ldr	r2, [r1, #24]
 340 009a 012A     		cmp	r2, #1
1190:../drivers/fsl_dspi.c ****             }
 341              		.loc 1 1190 0
 342 009c 0CBF     		ite	eq
 343 009e 8A68     		ldreq	r2, [r1, #8]
1194:../drivers/fsl_dspi.c ****             }
 344              		.loc 1 1194 0
 345 00a0 4A68     		ldrne	r2, [r1, #4]
 346 00a2 0243     		orrs	r2, r2, r0
 347 00a4 6263     		str	r2, [r4, #52]
 348              	.LVL29:
 349              	.LBB222:
 350              	.LBB219:
 580:../drivers/fsl_dspi.h **** }
 351              		.loc 2 580 0
 352 00a6 E562     		str	r5, [r4, #44]
 353              	.LVL30:
 354              	.LBE219:
 355              	.LBE222:
1200:../drivers/fsl_dspi.c **** 
 356              		.loc 1 1200 0
 357 00a8 8A69     		ldr	r2, [r1, #24]
 358 00aa 013A     		subs	r2, r2, #1
 359 00ac 8A61     		str	r2, [r1, #24]
1205:../drivers/fsl_dspi.c ****             {
 360              		.loc 1 1205 0
 361 00ae 8A69     		ldr	r2, [r1, #24]
 362 00b0 002A     		cmp	r2, #0
 363 00b2 DDD0     		beq	.L15
1205:../drivers/fsl_dspi.c ****             {
 364              		.loc 1 1205 0 is_stmt 0 discriminator 1
 365 00b4 0A6A     		ldr	r2, [r1, #32]
 366 00b6 8869     		ldr	r0, [r1, #24]
 367              	.LVL31:
 368 00b8 013A     		subs	r2, r2, #1
 369 00ba 9042     		cmp	r0, r2
 370 00bc DBD1     		bne	.L17
 371 00be D7E7     		b	.L15
 372              	.L19:
1132:../drivers/fsl_dspi.c ****                 }
 373              		.loc 1 1132 0 is_stmt 1
 374 00c0 1A46     		mov	r2, r3
 375              	.LVL32:
 376 00c2 C9E7     		b	.L21
 377              	.LVL33:
 378              	.L18:
1140:../drivers/fsl_dspi.c ****                 {
 379              		.loc 1 1140 0
 380 00c4 82B1     		cbz	r2, .L23
1142:../drivers/fsl_dspi.c ****                     ++handle->txData; /* increment to next data byte */
 381              		.loc 1 1142 0
 382 00c6 0A69     		ldr	r2, [r1, #16]
1143:../drivers/fsl_dspi.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 383              		.loc 1 1143 0
 384 00c8 0E69     		ldr	r6, [r1, #16]
1142:../drivers/fsl_dspi.c ****                     ++handle->txData; /* increment to next data byte */
 385              		.loc 1 1142 0
 386 00ca 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 387              	.LVL34:
1143:../drivers/fsl_dspi.c ****                     wordToSend |= (unsigned)(*(handle->txData)) << 8U;
 388              		.loc 1 1143 0
 389 00cc 0136     		adds	r6, r6, #1
 390 00ce 0E61     		str	r6, [r1, #16]
1144:../drivers/fsl_dspi.c ****                     ++handle->txData; /* increment to next data byte */
 391              		.loc 1 1144 0
 392 00d0 0E69     		ldr	r6, [r1, #16]
 393 00d2 3678     		ldrb	r6, [r6]	@ zero_extendqisi2
 394 00d4 42EA0622 		orr	r2, r2, r6, lsl #8
 395              	.LVL35:
1145:../drivers/fsl_dspi.c ****                 }
 396              		.loc 1 1145 0
 397 00d8 0E69     		ldr	r6, [r1, #16]
 398 00da 0136     		adds	r6, r6, #1
 399 00dc 0E61     		str	r6, [r1, #16]
 400              	.LVL36:
 401              	.L24:
1151:../drivers/fsl_dspi.c ****                 base->PUSHR = handle->command | wordToSend;
 402              		.loc 1 1151 0
 403 00de 8E69     		ldr	r6, [r1, #24]
 404 00e0 023E     		subs	r6, r6, #2
 405 00e2 8E61     		str	r6, [r1, #24]
1152:../drivers/fsl_dspi.c ****             }
 406              		.loc 1 1152 0
 407 00e4 4E68     		ldr	r6, [r1, #4]
 408 00e6 B9E7     		b	.L44
 409              	.LVL37:
 410              	.L23:
1149:../drivers/fsl_dspi.c ****                 }
 411              		.loc 1 1149 0
 412 00e8 1A46     		mov	r2, r3
 413              	.LVL38:
 414 00ea F8E7     		b	.L24
 415              	.LVL39:
 416              	.L28:
1185:../drivers/fsl_dspi.c ****             }
 417              		.loc 1 1185 0
 418 00ec 1846     		mov	r0, r3
 419              	.LVL40:
 420 00ee D3E7     		b	.L29
 421              	.L47:
 422              		.align	2
 423              	.L46:
 424 00f0 00000000 		.word	.LANCHOR2
 425              		.cfi_endproc
 426              	.LFE191:
 428              		.section	.text.DSPI_MasterTransferHandleIRQ,"ax",%progbits
 429              		.align	1
 430              		.global	DSPI_MasterTransferHandleIRQ
 431              		.syntax unified
 432              		.thumb
 433              		.thumb_func
 434              		.fpu fpv4-sp-d16
 436              	DSPI_MasterTransferHandleIRQ:
 437              	.LFB193:
1226:../drivers/fsl_dspi.c ****     assert(handle);
 438              		.loc 1 1226 0
 439              		.cfi_startproc
 440              		@ args = 0, pretend = 0, frame = 0
 441              		@ frame_needed = 0, uses_anonymous_args = 0
 442              	.LVL41:
1230:../drivers/fsl_dspi.c ****     {
 443              		.loc 1 1230 0
 444 0000 CB69     		ldr	r3, [r1, #28]
1226:../drivers/fsl_dspi.c ****     assert(handle);
 445              		.loc 1 1226 0
 446 0002 70B5     		push	{r4, r5, r6, lr}
 447              		.cfi_def_cfa_offset 16
 448              		.cfi_offset 4, -16
 449              		.cfi_offset 5, -12
 450              		.cfi_offset 6, -8
 451              		.cfi_offset 14, -4
1226:../drivers/fsl_dspi.c ****     assert(handle);
 452              		.loc 1 1226 0
 453 0004 0546     		mov	r5, r0
 454 0006 0C46     		mov	r4, r1
1230:../drivers/fsl_dspi.c ****     {
 455              		.loc 1 1230 0
 456 0008 23BB     		cbnz	r3, .L49
 457              	.LVL42:
 458              	.L58:
1318:../drivers/fsl_dspi.c ****     {
 459              		.loc 1 1318 0
 460 000a A369     		ldr	r3, [r4, #24]
 461 000c 1BB1     		cbz	r3, .L51
1320:../drivers/fsl_dspi.c ****     }
 462              		.loc 1 1320 0
 463 000e 2146     		mov	r1, r4
 464 0010 2846     		mov	r0, r5
 465 0012 FFF7FEFF 		bl	DSPI_MasterTransferFillUpTxFifo
 466              	.LVL43:
 467              	.L51:
1324:../drivers/fsl_dspi.c ****     {
 468              		.loc 1 1324 0
 469 0016 A369     		ldr	r3, [r4, #24]
 470 0018 002B     		cmp	r3, #0
 471 001a 5ED1     		bne	.L48
1324:../drivers/fsl_dspi.c ****     {
 472              		.loc 1 1324 0 is_stmt 0 discriminator 1
 473 001c E169     		ldr	r1, [r4, #28]
 474 001e 0029     		cmp	r1, #0
 475 0020 5BD1     		bne	.L48
 476              	.LVL44:
 477              	.LBB240:
 478              	.LBB241:
 479              	.LBB242:
 480              	.LBB243:
 620:../drivers/fsl_dspi.h **** }
 481              		.loc 2 620 0 is_stmt 1
 482 0022 2B6B     		ldr	r3, [r5, #48]
 483              	.LBE243:
 484              	.LBE242:
1087:../drivers/fsl_dspi.c ****     {
 485              		.loc 1 1087 0
 486 0024 A66A     		ldr	r6, [r4, #40]
 487              	.LBB245:
 488              	.LBB244:
 620:../drivers/fsl_dspi.h **** }
 489              		.loc 2 620 0
 490 0026 23F00073 		bic	r3, r3, #33554432
 491 002a 23F40033 		bic	r3, r3, #131072
 492 002e 2B63     		str	r3, [r5, #48]
 493              	.LVL45:
 494              	.LBE244:
 495              	.LBE245:
1076:../drivers/fsl_dspi.c ****     {
 496              		.loc 1 1076 0
 497 0030 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
1085:../drivers/fsl_dspi.c **** 
 498              		.loc 1 1085 0
 499 0034 84F82410 		strb	r1, [r4, #36]
1078:../drivers/fsl_dspi.c ****     }
 500              		.loc 1 1078 0
 501 0038 022B     		cmp	r3, #2
 502 003a 40F25922 		movw	r2, #601
 503 003e 18BF     		it	ne
 504 0040 0022     		movne	r2, #0
 505              	.LVL46:
1087:../drivers/fsl_dspi.c ****     {
 506              		.loc 1 1087 0
 507 0042 002E     		cmp	r6, #0
 508 0044 49D0     		beq	.L48
1089:../drivers/fsl_dspi.c ****     }
 509              		.loc 1 1089 0
 510 0046 E36A     		ldr	r3, [r4, #44]
 511 0048 2146     		mov	r1, r4
 512 004a 2846     		mov	r0, r5
 513 004c B446     		mov	ip, r6
 514              	.LBE241:
 515              	.LBE240:
1329:../drivers/fsl_dspi.c **** 
 516              		.loc 1 1329 0
 517 004e BDE87040 		pop	{r4, r5, r6, lr}
 518              		.cfi_remember_state
 519              		.cfi_restore 14
 520              		.cfi_restore 6
 521              		.cfi_restore 5
 522              		.cfi_restore 4
 523              		.cfi_def_cfa_offset 0
 524              	.LVL47:
 525              	.LBB247:
 526              	.LBB246:
1089:../drivers/fsl_dspi.c ****     }
 527              		.loc 1 1089 0
 528 0052 6047     		bx	ip	@ indirect register sibling call
 529              	.LVL48:
 530              	.L49:
 531              		.cfi_restore_state
 532              	.LBE246:
 533              	.LBE247:
 534              	.LBB248:
1236:../drivers/fsl_dspi.c ****         {
 535              		.loc 1 1236 0
 536 0054 0B68     		ldr	r3, [r1]
 537 0056 082B     		cmp	r3, #8
 538 0058 16D9     		bls	.L80
 539              	.LBB249:
 540              	.LBB250:
 580:../drivers/fsl_dspi.h **** }
 541              		.loc 2 580 0
 542 005a 4FF40031 		mov	r1, #131072
 543              	.LVL49:
 544              	.L52:
 545              	.LBE250:
 546              	.LBE249:
 547              	.LBB252:
 548              	.LBB253:
 561:../drivers/fsl_dspi.h **** }
 549              		.loc 2 561 0
 550 005e EB6A     		ldr	r3, [r5, #44]
 551              	.LVL50:
 552              	.LBE253:
 553              	.LBE252:
1238:../drivers/fsl_dspi.c ****             {
 554              		.loc 1 1238 0
 555 0060 9A03     		lsls	r2, r3, #14
 556 0062 D2D5     		bpl	.L58
 557              	.LVL51:
 558              	.LBB254:
 559              	.LBB255:
 968:../drivers/fsl_dspi.h **** 
 969:../drivers/fsl_dspi.h **** /*!
 970:../drivers/fsl_dspi.h ****  * @brief Writes a 32-bit data word (16-bit command appended with 16-bit data) into the data
 971:../drivers/fsl_dspi.h ****  *        buffer master mode and waits till complete to return.
 972:../drivers/fsl_dspi.h ****  *
 973:../drivers/fsl_dspi.h ****  * In this function, the user must append the 16-bit data to the 16-bit command information and the
 974:../drivers/fsl_dspi.h **** * 32-bit word
 975:../drivers/fsl_dspi.h ****  * as the data to send.
 976:../drivers/fsl_dspi.h ****  * The command portion provides characteristics of the data, such as the optional continuous chip s
 977:../drivers/fsl_dspi.h ****  * between transfers, the desired Clock and Transfer Attributes register to use for the associated 
 978:../drivers/fsl_dspi.h **** * desired PCS
 979:../drivers/fsl_dspi.h ****  * signal to use for the data transfer, whether the current transfer is the last in the queue, and 
 980:../drivers/fsl_dspi.h ****  * transfer count (normally needed when sending the first frame of a data packet). The user is resp
 981:../drivers/fsl_dspi.h ****  * appending this command with the data to send. This is an example:
 982:../drivers/fsl_dspi.h ****  * @code
 983:../drivers/fsl_dspi.h ****  *  dataWord = <16-bit command> | <16-bit data>;
 984:../drivers/fsl_dspi.h ****  *  DSPI_MasterWriteCommandDataBlocking(base, dataWord);
 985:../drivers/fsl_dspi.h ****  * @endcode
 986:../drivers/fsl_dspi.h ****  *
 987:../drivers/fsl_dspi.h ****  * Note that this function does not return until after the transmit is complete. Also note that the
 988:../drivers/fsl_dspi.h ****  * enabled and running to transmit data (MCR[MDIS] & [HALT] = 0).
 989:../drivers/fsl_dspi.h ****  * Because the SPI is a synchronous protocol, the received data is available when the transmit comp
 990:../drivers/fsl_dspi.h ****  *
 991:../drivers/fsl_dspi.h ****  *  For a blocking polling transfer, see methods below.
 992:../drivers/fsl_dspi.h ****  *  Option 1:
 993:../drivers/fsl_dspi.h **** *   uint32_t command_to_send = DSPI_MasterGetFormattedCommand(&command);
 994:../drivers/fsl_dspi.h **** *   uint32_t data0 = command_to_send | data_need_to_send_0;
 995:../drivers/fsl_dspi.h **** *   uint32_t data1 = command_to_send | data_need_to_send_1;
 996:../drivers/fsl_dspi.h **** *   uint32_t data2 = command_to_send | data_need_to_send_2;
 997:../drivers/fsl_dspi.h **** *
 998:../drivers/fsl_dspi.h **** *   DSPI_MasterWriteCommandDataBlocking(base,data0);
 999:../drivers/fsl_dspi.h **** *   DSPI_MasterWriteCommandDataBlocking(base,data1);
1000:../drivers/fsl_dspi.h **** *   DSPI_MasterWriteCommandDataBlocking(base,data2);
1001:../drivers/fsl_dspi.h **** *
1002:../drivers/fsl_dspi.h **** *  Option 2:
1003:../drivers/fsl_dspi.h **** *   DSPI_MasterWriteDataBlocking(base,&command,data_need_to_send_0);
1004:../drivers/fsl_dspi.h **** *   DSPI_MasterWriteDataBlocking(base,&command,data_need_to_send_1);
1005:../drivers/fsl_dspi.h **** *   DSPI_MasterWriteDataBlocking(base,&command,data_need_to_send_2);
1006:../drivers/fsl_dspi.h **** *
1007:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
1008:../drivers/fsl_dspi.h ****  * @param data The data word (command and data combined) to be sent.
1009:../drivers/fsl_dspi.h ****  */
1010:../drivers/fsl_dspi.h **** void DSPI_MasterWriteCommandDataBlocking(SPI_Type *base, uint32_t data);
1011:../drivers/fsl_dspi.h **** 
1012:../drivers/fsl_dspi.h **** /*!
1013:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer in slave mode.
1014:../drivers/fsl_dspi.h ****  *
1015:../drivers/fsl_dspi.h ****  * In slave mode, up to 16-bit words may be written.
1016:../drivers/fsl_dspi.h ****  *
1017:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
1018:../drivers/fsl_dspi.h ****  * @param data The data to send.
1019:../drivers/fsl_dspi.h ****  */
1020:../drivers/fsl_dspi.h **** static inline void DSPI_SlaveWriteData(SPI_Type *base, uint32_t data)
1021:../drivers/fsl_dspi.h **** {
1022:../drivers/fsl_dspi.h ****     base->PUSHR_SLAVE = data;
1023:../drivers/fsl_dspi.h **** }
1024:../drivers/fsl_dspi.h **** 
1025:../drivers/fsl_dspi.h **** /*!
1026:../drivers/fsl_dspi.h ****  * @brief Writes data into the data buffer in slave mode, waits till data was transmitted, and retu
1027:../drivers/fsl_dspi.h ****  *
1028:../drivers/fsl_dspi.h ****  * In slave mode, up to 16-bit words may be written. The function first clears the transmit complet
1029:../drivers/fsl_dspi.h ****  * into data register, and finally waits until the data is transmitted.
1030:../drivers/fsl_dspi.h ****  *
1031:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
1032:../drivers/fsl_dspi.h ****  * @param data The data to send.
1033:../drivers/fsl_dspi.h ****  */
1034:../drivers/fsl_dspi.h **** void DSPI_SlaveWriteDataBlocking(SPI_Type *base, uint32_t data);
1035:../drivers/fsl_dspi.h **** 
1036:../drivers/fsl_dspi.h **** /*!
1037:../drivers/fsl_dspi.h ****  * @brief Reads data from the data buffer.
1038:../drivers/fsl_dspi.h ****  *
1039:../drivers/fsl_dspi.h ****  * @param base DSPI peripheral address.
1040:../drivers/fsl_dspi.h ****  * @return The data from the read data buffer.
1041:../drivers/fsl_dspi.h ****  */
1042:../drivers/fsl_dspi.h **** static inline uint32_t DSPI_ReadData(SPI_Type *base)
1043:../drivers/fsl_dspi.h **** {
1044:../drivers/fsl_dspi.h ****     return (base->POPR);
 560              		.loc 2 1044 0
 561 0064 AB6B     		ldr	r3, [r5, #56]
 562              	.LVL52:
 563              	.LBE255:
 564              	.LBE254:
 565              	.LBB256:
 566              	.LBB251:
 580:../drivers/fsl_dspi.h **** }
 567              		.loc 2 580 0
 568 0066 E962     		str	r1, [r5, #44]
 569              	.LVL53:
 570              	.LBE251:
 571              	.LBE256:
1249:../drivers/fsl_dspi.c ****                 {
 572              		.loc 1 1249 0
 573 0068 6269     		ldr	r2, [r4, #20]
 574 006a 002A     		cmp	r2, #0
 575 006c 30D0     		beq	.L54
1254:../drivers/fsl_dspi.c ****                     {
 576              		.loc 1 1254 0
 577 006e E069     		ldr	r0, [r4, #28]
 578 0070 0128     		cmp	r0, #1
 579 0072 DAB2     		uxtb	r2, r3
 580 0074 1DD1     		bne	.L55
1256:../drivers/fsl_dspi.c ****                         --handle->remainingReceiveByteCount;
 581              		.loc 1 1256 0
 582 0076 6369     		ldr	r3, [r4, #20]
 583              	.LVL54:
 584 0078 1A70     		strb	r2, [r3]
1257:../drivers/fsl_dspi.c ****                     }
 585              		.loc 1 1257 0
 586 007a E369     		ldr	r3, [r4, #28]
 587              	.L82:
1272:../drivers/fsl_dspi.c ****                     }
 588              		.loc 1 1272 0
 589 007c 013B     		subs	r3, r3, #1
 590              	.L81:
1276:../drivers/fsl_dspi.c ****                     }
 591              		.loc 1 1276 0
 592 007e E361     		str	r3, [r4, #28]
1279:../drivers/fsl_dspi.c ****                 {
 593              		.loc 1 1279 0
 594 0080 E369     		ldr	r3, [r4, #28]
 595 0082 002B     		cmp	r3, #0
 596 0084 EBD1     		bne	.L52
 597 0086 C0E7     		b	.L58
 598              	.LVL55:
 599              	.L80:
 600              	.LBB257:
 601              	.LBB258:
 580:../drivers/fsl_dspi.h **** }
 602              		.loc 2 580 0
 603 0088 4FF40032 		mov	r2, #131072
 604              	.LVL56:
 605              	.L53:
 606              	.LBE258:
 607              	.LBE257:
 608              	.LBB260:
 609              	.LBB261:
 561:../drivers/fsl_dspi.h **** }
 610              		.loc 2 561 0
 611 008c EB6A     		ldr	r3, [r5, #44]
 612              	.LVL57:
 613              	.LBE261:
 614              	.LBE260:
1288:../drivers/fsl_dspi.c ****             {
 615              		.loc 1 1288 0
 616 008e 9B03     		lsls	r3, r3, #14
 617 0090 BBD5     		bpl	.L58
 618              	.LVL58:
 619              	.LBB262:
 620              	.LBB263:
 621              		.loc 2 1044 0
 622 0092 A96B     		ldr	r1, [r5, #56]
 623              	.LVL59:
 624              	.LBE263:
 625              	.LBE262:
 626              	.LBB264:
 627              	.LBB259:
 580:../drivers/fsl_dspi.h **** }
 628              		.loc 2 580 0
 629 0094 EA62     		str	r2, [r5, #44]
 630              	.LVL60:
 631              	.LBE259:
 632              	.LBE264:
1299:../drivers/fsl_dspi.c ****                 {
 633              		.loc 1 1299 0
 634 0096 6369     		ldr	r3, [r4, #20]
 635 0098 23B1     		cbz	r3, .L60
1301:../drivers/fsl_dspi.c ****                     ++handle->rxData;
 636              		.loc 1 1301 0
 637 009a 6369     		ldr	r3, [r4, #20]
 638 009c 1970     		strb	r1, [r3]
1302:../drivers/fsl_dspi.c ****                 }
 639              		.loc 1 1302 0
 640 009e 6369     		ldr	r3, [r4, #20]
 641 00a0 0133     		adds	r3, r3, #1
 642 00a2 6361     		str	r3, [r4, #20]
 643              	.L60:
1305:../drivers/fsl_dspi.c **** 
 644              		.loc 1 1305 0
 645 00a4 E369     		ldr	r3, [r4, #28]
 646 00a6 013B     		subs	r3, r3, #1
 647 00a8 E361     		str	r3, [r4, #28]
1307:../drivers/fsl_dspi.c ****                 {
 648              		.loc 1 1307 0
 649 00aa E369     		ldr	r3, [r4, #28]
 650 00ac 002B     		cmp	r3, #0
 651 00ae EDD1     		bne	.L53
 652 00b0 ABE7     		b	.L58
 653              	.LVL61:
 654              	.L55:
1261:../drivers/fsl_dspi.c ****                         ++handle->rxData;                    /* increment to next data byte */
 655              		.loc 1 1261 0
 656 00b2 6069     		ldr	r0, [r4, #20]
 657 00b4 0270     		strb	r2, [r0]
1262:../drivers/fsl_dspi.c ****                         *handle->rxData = wordReceived >> 8; /* Write second data byte */
 658              		.loc 1 1262 0
 659 00b6 6269     		ldr	r2, [r4, #20]
 660 00b8 0132     		adds	r2, r2, #1
 661 00ba 6261     		str	r2, [r4, #20]
1263:../drivers/fsl_dspi.c ****                         ++handle->rxData;                    /* increment to next data byte */
 662              		.loc 1 1263 0
 663 00bc 6269     		ldr	r2, [r4, #20]
 664 00be C3F30723 		ubfx	r3, r3, #8, #8
 665              	.LVL62:
 666 00c2 1370     		strb	r3, [r2]
1264:../drivers/fsl_dspi.c ****                         handle->remainingReceiveByteCount -= 2;
 667              		.loc 1 1264 0
 668 00c4 6369     		ldr	r3, [r4, #20]
 669 00c6 0133     		adds	r3, r3, #1
 670 00c8 6361     		str	r3, [r4, #20]
1265:../drivers/fsl_dspi.c ****                     }
 671              		.loc 1 1265 0
 672 00ca E369     		ldr	r3, [r4, #28]
 673              	.L57:
1276:../drivers/fsl_dspi.c ****                     }
 674              		.loc 1 1276 0
 675 00cc 023B     		subs	r3, r3, #2
 676 00ce D6E7     		b	.L81
 677              	.LVL63:
 678              	.L54:
1270:../drivers/fsl_dspi.c ****                     {
 679              		.loc 1 1270 0
 680 00d0 E369     		ldr	r3, [r4, #28]
 681              	.LVL64:
 682 00d2 012B     		cmp	r3, #1
1272:../drivers/fsl_dspi.c ****                     }
 683              		.loc 1 1272 0
 684 00d4 E369     		ldr	r3, [r4, #28]
1270:../drivers/fsl_dspi.c ****                     {
 685              		.loc 1 1270 0
 686 00d6 F9D1     		bne	.L57
 687 00d8 D0E7     		b	.L82
 688              	.L48:
 689              	.LBE248:
1329:../drivers/fsl_dspi.c **** 
 690              		.loc 1 1329 0
 691 00da 70BD     		pop	{r4, r5, r6, pc}
 692              		.cfi_endproc
 693              	.LFE193:
 695              		.section	.text.DSPI_SlaveTransferHandleIRQ,"ax",%progbits
 696              		.align	1
 697              		.global	DSPI_SlaveTransferHandleIRQ
 698              		.syntax unified
 699              		.thumb
 700              		.thumb_func
 701              		.fpu fpv4-sp-d16
 703              	DSPI_SlaveTransferHandleIRQ:
 704              	.LFB200:
1573:../drivers/fsl_dspi.c ****     assert(handle);
 705              		.loc 1 1573 0
 706              		.cfi_startproc
 707              		@ args = 0, pretend = 0, frame = 0
 708              		@ frame_needed = 0, uses_anonymous_args = 0
 709              	.LVL65:
 710 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 711              		.cfi_def_cfa_offset 24
 712              		.cfi_offset 4, -24
 713              		.cfi_offset 5, -20
 714              		.cfi_offset 6, -16
 715              		.cfi_offset 7, -12
 716              		.cfi_offset 8, -8
 717              		.cfi_offset 14, -4
1573:../drivers/fsl_dspi.c ****     assert(handle);
 718              		.loc 1 1573 0
 719 0004 0446     		mov	r4, r0
1576:../drivers/fsl_dspi.c ****     uint32_t dataReceived;
 720              		.loc 1 1576 0
 721 0006 FFF7FEFF 		bl	DSPI_GetInstance
 722              	.LVL66:
 723 000a 5D4B     		ldr	r3, .L149
 724 000c 1A5C     		ldrb	r2, [r3, r0]	@ zero_extendqisi2
1584:../drivers/fsl_dspi.c ****     {
 725              		.loc 1 1584 0
 726 000e 4B69     		ldr	r3, [r1, #20]
1576:../drivers/fsl_dspi.c ****     uint32_t dataReceived;
 727              		.loc 1 1576 0
 728 0010 D2B2     		uxtb	r2, r2
 729              	.LVL67:
1584:../drivers/fsl_dspi.c ****     {
 730              		.loc 1 1584 0
 731 0012 FBB9     		cbnz	r3, .L84
 732              	.LVL68:
 733              	.L104:
1710:../drivers/fsl_dspi.c ****     {
 734              		.loc 1 1710 0
 735 0014 4B69     		ldr	r3, [r1, #20]
 736 0016 002B     		cmp	r3, #0
 737 0018 40F08C80 		bne	.L145
 738              	.L85:
 739              	.LVL69:
 740              	.LBB283:
 741              	.LBB284:
 742              	.LBB285:
 743              	.LBB286:
 620:../drivers/fsl_dspi.h **** }
 744              		.loc 2 620 0
 745 001c 236B     		ldr	r3, [r4, #48]
 746              	.LBE286:
 747              	.LBE285:
1551:../drivers/fsl_dspi.c ****     {
 748              		.loc 1 1551 0
 749 001e 4D6A     		ldr	r5, [r1, #36]
 750              	.LBB288:
 751              	.LBB287:
 620:../drivers/fsl_dspi.h **** }
 752              		.loc 2 620 0
 753 0020 23F02063 		bic	r3, r3, #167772160
 754 0024 23F42023 		bic	r3, r3, #655360
 755 0028 2363     		str	r3, [r4, #48]
 756              	.LVL70:
 757              	.LBE287:
 758              	.LBE288:
1534:../drivers/fsl_dspi.c ****     handle->rxData = NULL;
 759              		.loc 1 1534 0
 760 002a 0023     		movs	r3, #0
 761 002c 8B60     		str	r3, [r1, #8]
1535:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = 0;
 762              		.loc 1 1535 0
 763 002e CB60     		str	r3, [r1, #12]
1536:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = 0;
 764              		.loc 1 1536 0
 765 0030 4B61     		str	r3, [r1, #20]
1537:../drivers/fsl_dspi.c **** 
 766              		.loc 1 1537 0
 767 0032 0B61     		str	r3, [r1, #16]
 768              	.LVL71:
1540:../drivers/fsl_dspi.c ****     {
 769              		.loc 1 1540 0
 770 0034 0A7F     		ldrb	r2, [r1, #28]	@ zero_extendqisi2
 771              	.LVL72:
1549:../drivers/fsl_dspi.c **** 
 772              		.loc 1 1549 0
 773 0036 0B77     		strb	r3, [r1, #28]
1542:../drivers/fsl_dspi.c ****     }
 774              		.loc 1 1542 0
 775 0038 022A     		cmp	r2, #2
 776 003a 40F25922 		movw	r2, #601
 777 003e 18BF     		it	ne
 778 0040 1A46     		movne	r2, r3
 779              	.LVL73:
1551:../drivers/fsl_dspi.c ****     {
 780              		.loc 1 1551 0
 781 0042 002D     		cmp	r5, #0
 782 0044 00F09A80 		beq	.L83
1553:../drivers/fsl_dspi.c ****     }
 783              		.loc 1 1553 0
 784 0048 2046     		mov	r0, r4
 785 004a AC46     		mov	ip, r5
 786 004c 8B6A     		ldr	r3, [r1, #40]
 787              	.LBE284:
 788              	.LBE283:
1739:../drivers/fsl_dspi.c **** 
 789              		.loc 1 1739 0
 790 004e BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 791              		.cfi_remember_state
 792              		.cfi_restore 14
 793              		.cfi_restore 8
 794              		.cfi_restore 7
 795              		.cfi_restore 6
 796              		.cfi_restore 5
 797              		.cfi_restore 4
 798              		.cfi_def_cfa_offset 0
 799              	.LVL74:
 800              	.LBB290:
 801              	.LBB289:
1553:../drivers/fsl_dspi.c ****     }
 802              		.loc 1 1553 0
 803 0052 6047     		bx	ip	@ indirect register sibling call
 804              	.LVL75:
 805              	.L84:
 806              		.cfi_restore_state
 807              	.LBE289:
 808              	.LBE290:
1694:../drivers/fsl_dspi.c ****                     }
 809              		.loc 1 1694 0
 810 0054 1002     		lsls	r0, r2, #8
 811 0056 40EA0205 		orr	r5, r0, r2
 812              	.LBB291:
 813              	.LBB292:
 580:../drivers/fsl_dspi.h **** }
 814              		.loc 2 580 0
 815 005a 4FF40036 		mov	r6, #131072
 816              	.LBE292:
 817              	.LBE291:
 818              	.LBB294:
 819              	.LBB295:
 820 005e 4FF0007C 		mov	ip, #33554432
 821              	.LVL76:
 822              	.L87:
 823              	.LBE295:
 824              	.LBE294:
 825              	.LBB297:
 826              	.LBB298:
 561:../drivers/fsl_dspi.h **** }
 827              		.loc 2 561 0
 828 0062 E36A     		ldr	r3, [r4, #44]
 829              	.LVL77:
 830              	.LBE298:
 831              	.LBE297:
1586:../drivers/fsl_dspi.c ****         {
 832              		.loc 1 1586 0
 833 0064 9F03     		lsls	r7, r3, #14
 834 0066 D5D5     		bpl	.L104
1598:../drivers/fsl_dspi.c ****             {
 835              		.loc 1 1598 0
 836 0068 0F68     		ldr	r7, [r1]
1589:../drivers/fsl_dspi.c ****             /*Clear the rx fifo drain request, needed for non-DMA applications as this flag
 837              		.loc 1 1589 0
 838 006a A36B     		ldr	r3, [r4, #56]
 839              	.LVL78:
 840              	.LBB299:
 841              	.LBB293:
 580:../drivers/fsl_dspi.h **** }
 842              		.loc 2 580 0
 843 006c E662     		str	r6, [r4, #44]
 844              	.LVL79:
 845              	.LBE293:
 846              	.LBE299:
1598:../drivers/fsl_dspi.c ****             {
 847              		.loc 1 1598 0
 848 006e 082F     		cmp	r7, #8
1600:../drivers/fsl_dspi.c ****                 {
 849              		.loc 1 1600 0
 850 0070 CF68     		ldr	r7, [r1, #12]
1598:../drivers/fsl_dspi.c ****             {
 851              		.loc 1 1598 0
 852 0072 1DD8     		bhi	.L88
1600:../drivers/fsl_dspi.c ****                 {
 853              		.loc 1 1600 0
 854 0074 27B1     		cbz	r7, .L89
1603:../drivers/fsl_dspi.c ****                     ++handle->rxData;
 855              		.loc 1 1603 0
 856 0076 CF68     		ldr	r7, [r1, #12]
 857 0078 3B70     		strb	r3, [r7]
1604:../drivers/fsl_dspi.c ****                 }
 858              		.loc 1 1604 0
 859 007a CB68     		ldr	r3, [r1, #12]
 860              	.LVL80:
 861 007c 0133     		adds	r3, r3, #1
 862 007e CB60     		str	r3, [r1, #12]
 863              	.L89:
1607:../drivers/fsl_dspi.c **** 
 864              		.loc 1 1607 0
 865 0080 4B69     		ldr	r3, [r1, #20]
 866 0082 013B     		subs	r3, r3, #1
 867 0084 4B61     		str	r3, [r1, #20]
1609:../drivers/fsl_dspi.c ****                 {
 868              		.loc 1 1609 0
 869 0086 0B69     		ldr	r3, [r1, #16]
 870 0088 53B1     		cbz	r3, .L91
1611:../drivers/fsl_dspi.c ****                     {
 871              		.loc 1 1611 0
 872 008a 8B68     		ldr	r3, [r1, #8]
 873 008c 73B1     		cbz	r3, .L92
1613:../drivers/fsl_dspi.c ****                         ++handle->txData;
 874              		.loc 1 1613 0
 875 008e 8B68     		ldr	r3, [r1, #8]
 876 0090 1F78     		ldrb	r7, [r3]	@ zero_extendqisi2
 877              	.LVL81:
1614:../drivers/fsl_dspi.c ****                     }
 878              		.loc 1 1614 0
 879 0092 8B68     		ldr	r3, [r1, #8]
 880 0094 0133     		adds	r3, r3, #1
 881 0096 8B60     		str	r3, [r1, #8]
 882              	.LVL82:
 883              	.L93:
1621:../drivers/fsl_dspi.c ****                     /* Write the data to the DSPI data register */
 884              		.loc 1 1621 0
 885 0098 0B69     		ldr	r3, [r1, #16]
 886 009a 013B     		subs	r3, r3, #1
 887 009c 0B61     		str	r3, [r1, #16]
1623:../drivers/fsl_dspi.c ****                 }
 888              		.loc 1 1623 0
 889 009e 6763     		str	r7, [r4, #52]
 890              	.LVL83:
 891              	.L91:
 892              	.LBB300:
 893              	.LBB296:
 580:../drivers/fsl_dspi.h **** }
 894              		.loc 2 580 0
 895 00a0 C4F82CC0 		str	ip, [r4, #44]
 896              	.LVL84:
 897              	.LBE296:
 898              	.LBE300:
1703:../drivers/fsl_dspi.c ****             {
 899              		.loc 1 1703 0
 900 00a4 4B69     		ldr	r3, [r1, #20]
 901 00a6 002B     		cmp	r3, #0
 902 00a8 DBD1     		bne	.L87
 903 00aa B3E7     		b	.L104
 904              	.L92:
1618:../drivers/fsl_dspi.c ****                     }
 905              		.loc 1 1618 0
 906 00ac 1746     		mov	r7, r2
 907 00ae F3E7     		b	.L93
 908              	.LVL85:
 909              	.L88:
1631:../drivers/fsl_dspi.c ****                 {
 910              		.loc 1 1631 0
 911 00b0 37B3     		cbz	r7, .L94
1634:../drivers/fsl_dspi.c ****                     ++handle->rxData;
 912              		.loc 1 1634 0
 913 00b2 CF68     		ldr	r7, [r1, #12]
 914 00b4 3B70     		strb	r3, [r7]
1635:../drivers/fsl_dspi.c **** 
 915              		.loc 1 1635 0
 916 00b6 CF68     		ldr	r7, [r1, #12]
 917 00b8 0137     		adds	r7, r7, #1
 918 00ba CF60     		str	r7, [r1, #12]
1637:../drivers/fsl_dspi.c ****                     {
 919              		.loc 1 1637 0
 920 00bc 4F69     		ldr	r7, [r1, #20]
 921 00be 012F     		cmp	r7, #1
 922 00c0 15D1     		bne	.L95
1640:../drivers/fsl_dspi.c ****                     }
 923              		.loc 1 1640 0
 924 00c2 4B69     		ldr	r3, [r1, #20]
 925              	.LVL86:
 926              	.L148:
1656:../drivers/fsl_dspi.c ****                     }
 927              		.loc 1 1656 0
 928 00c4 013B     		subs	r3, r3, #1
 929              	.L146:
1660:../drivers/fsl_dspi.c ****                     }
 930              		.loc 1 1660 0
 931 00c6 4B61     		str	r3, [r1, #20]
1664:../drivers/fsl_dspi.c ****                 {
 932              		.loc 1 1664 0
 933 00c8 0B69     		ldr	r3, [r1, #16]
 934 00ca 002B     		cmp	r3, #0
 935 00cc E8D0     		beq	.L91
1666:../drivers/fsl_dspi.c ****                     {
 936              		.loc 1 1666 0
 937 00ce 8B68     		ldr	r3, [r1, #8]
 938 00d0 33B3     		cbz	r3, .L99
1668:../drivers/fsl_dspi.c ****                         ++handle->txData;
 939              		.loc 1 1668 0
 940 00d2 8B68     		ldr	r3, [r1, #8]
1669:../drivers/fsl_dspi.c **** 
 941              		.loc 1 1669 0
 942 00d4 8F68     		ldr	r7, [r1, #8]
1668:../drivers/fsl_dspi.c ****                         ++handle->txData;
 943              		.loc 1 1668 0
 944 00d6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 945              	.LVL87:
1669:../drivers/fsl_dspi.c **** 
 946              		.loc 1 1669 0
 947 00d8 0137     		adds	r7, r7, #1
 948 00da 8F60     		str	r7, [r1, #8]
1671:../drivers/fsl_dspi.c ****                         {
 949              		.loc 1 1671 0
 950 00dc 0F69     		ldr	r7, [r1, #16]
 951 00de 012F     		cmp	r7, #1
 952 00e0 13D1     		bne	.L100
1673:../drivers/fsl_dspi.c ****                             dataSend |= (uint16_t)((uint16_t)(dummyPattern) << 8);
 953              		.loc 1 1673 0
 954 00e2 0F69     		ldr	r7, [r1, #16]
 955 00e4 013F     		subs	r7, r7, #1
 956 00e6 0F61     		str	r7, [r1, #16]
1674:../drivers/fsl_dspi.c ****                         }
 957              		.loc 1 1674 0
 958 00e8 0343     		orrs	r3, r3, r0
 959              	.LVL88:
 960              	.L101:
1697:../drivers/fsl_dspi.c ****                 }
 961              		.loc 1 1697 0
 962 00ea 6363     		str	r3, [r4, #52]
 963 00ec D8E7     		b	.L91
 964              	.LVL89:
 965              	.L95:
1645:../drivers/fsl_dspi.c ****                         ++handle->rxData;
 966              		.loc 1 1645 0
 967 00ee CF68     		ldr	r7, [r1, #12]
 968 00f0 1B0A     		lsrs	r3, r3, #8
 969              	.LVL90:
 970 00f2 3B70     		strb	r3, [r7]
1646:../drivers/fsl_dspi.c ****                         handle->remainingReceiveByteCount -= 2;
 971              		.loc 1 1646 0
 972 00f4 CB68     		ldr	r3, [r1, #12]
 973 00f6 0133     		adds	r3, r3, #1
 974 00f8 CB60     		str	r3, [r1, #12]
1647:../drivers/fsl_dspi.c ****                     }
 975              		.loc 1 1647 0
 976 00fa 4B69     		ldr	r3, [r1, #20]
 977              	.L97:
1660:../drivers/fsl_dspi.c ****                     }
 978              		.loc 1 1660 0
 979 00fc 023B     		subs	r3, r3, #2
 980 00fe E2E7     		b	.L146
 981              	.LVL91:
 982              	.L94:
1653:../drivers/fsl_dspi.c ****                     {
 983              		.loc 1 1653 0
 984 0100 4B69     		ldr	r3, [r1, #20]
 985              	.LVL92:
 986 0102 012B     		cmp	r3, #1
1656:../drivers/fsl_dspi.c ****                     }
 987              		.loc 1 1656 0
 988 0104 4B69     		ldr	r3, [r1, #20]
1653:../drivers/fsl_dspi.c ****                     {
 989              		.loc 1 1653 0
 990 0106 F9D1     		bne	.L97
 991 0108 DCE7     		b	.L148
 992              	.LVL93:
 993              	.L100:
1678:../drivers/fsl_dspi.c ****                             ++handle->txData;
 994              		.loc 1 1678 0
 995 010a 8F68     		ldr	r7, [r1, #8]
 996 010c 3F78     		ldrb	r7, [r7]	@ zero_extendqisi2
 997 010e 43EA0723 		orr	r3, r3, r7, lsl #8
 998              	.LVL94:
1679:../drivers/fsl_dspi.c ****                             handle->remainingSendByteCount -= 2;
 999              		.loc 1 1679 0
 1000 0112 8F68     		ldr	r7, [r1, #8]
 1001 0114 0137     		adds	r7, r7, #1
 1002 0116 8F60     		str	r7, [r1, #8]
1680:../drivers/fsl_dspi.c ****                         }
 1003              		.loc 1 1680 0
 1004 0118 0F69     		ldr	r7, [r1, #16]
 1005 011a 023F     		subs	r7, r7, #2
 1006 011c 0F61     		str	r7, [r1, #16]
 1007 011e E4E7     		b	.L101
 1008              	.LVL95:
 1009              	.L99:
1686:../drivers/fsl_dspi.c ****                         {
 1010              		.loc 1 1686 0
 1011 0120 0B69     		ldr	r3, [r1, #16]
 1012 0122 012B     		cmp	r3, #1
1688:../drivers/fsl_dspi.c ****                         }
 1013              		.loc 1 1688 0
 1014 0124 0B69     		ldr	r3, [r1, #16]
 1015 0126 0CBF     		ite	eq
 1016 0128 03F1FF33 		addeq	r3, r3, #-1
1692:../drivers/fsl_dspi.c ****                         }
 1017              		.loc 1 1692 0
 1018 012c 023B     		subne	r3, r3, #2
 1019 012e 0B61     		str	r3, [r1, #16]
 1020              	.LVL96:
1694:../drivers/fsl_dspi.c ****                     }
 1021              		.loc 1 1694 0
 1022 0130 2B46     		mov	r3, r5
 1023 0132 DAE7     		b	.L101
 1024              	.LVL97:
 1025              	.L145:
1710:../drivers/fsl_dspi.c ****     {
 1026              		.loc 1 1710 0 discriminator 1
 1027 0134 0B7F     		ldrb	r3, [r1, #28]	@ zero_extendqisi2
 1028 0136 022B     		cmp	r3, #2
 1029 0138 3FF470AF 		beq	.L85
 1030              	.LVL98:
 1031              	.LBB301:
 1032              	.LBB302:
 561:../drivers/fsl_dspi.h **** }
 1033              		.loc 2 561 0
 1034 013c E36A     		ldr	r3, [r4, #44]
 1035              	.LVL99:
 1036              	.LBE302:
 1037              	.LBE301:
1718:../drivers/fsl_dspi.c ****     {
 1038              		.loc 1 1718 0
 1039 013e 1D01     		lsls	r5, r3, #4
 1040 0140 0CD5     		bpl	.L110
1718:../drivers/fsl_dspi.c ****     {
 1041              		.loc 1 1718 0 is_stmt 0 discriminator 1
 1042 0142 236B     		ldr	r3, [r4, #48]
 1043 0144 1801     		lsls	r0, r3, #4
 1044 0146 09D5     		bpl	.L110
 1045              	.LVL100:
 1046              	.LBB303:
 1047              	.LBB304:
 580:../drivers/fsl_dspi.h **** }
 1048              		.loc 2 580 0 is_stmt 1
 1049 0148 4FF00063 		mov	r3, #134217728
 1050 014c E362     		str	r3, [r4, #44]
 1051              	.LVL101:
 1052              	.LBE304:
 1053              	.LBE303:
1722:../drivers/fsl_dspi.c ****         {
 1054              		.loc 1 1722 0
 1055 014e 8B68     		ldr	r3, [r1, #8]
 1056 0150 0BB1     		cbz	r3, .L111
1724:../drivers/fsl_dspi.c ****         }
 1057              		.loc 1 1724 0
 1058 0152 0223     		movs	r3, #2
 1059 0154 0B77     		strb	r3, [r1, #28]
 1060              	.L111:
1726:../drivers/fsl_dspi.c ****     }
 1061              		.loc 1 1726 0
 1062 0156 0B6A     		ldr	r3, [r1, #32]
 1063 0158 0133     		adds	r3, r3, #1
 1064 015a 0B62     		str	r3, [r1, #32]
 1065              	.L110:
 1066              	.LVL102:
 1067              	.LBB305:
 1068              	.LBB306:
 561:../drivers/fsl_dspi.h **** }
 1069              		.loc 2 561 0
 1070 015c E36A     		ldr	r3, [r4, #44]
 1071              	.LVL103:
 1072              	.LBE306:
 1073              	.LBE305:
1729:../drivers/fsl_dspi.c ****     {
 1074              		.loc 1 1729 0
 1075 015e 1A03     		lsls	r2, r3, #12
 1076              	.LVL104:
 1077 0160 0CD5     		bpl	.L83
1729:../drivers/fsl_dspi.c ****     {
 1078              		.loc 1 1729 0 is_stmt 0 discriminator 1
 1079 0162 236B     		ldr	r3, [r4, #48]
 1080 0164 1B03     		lsls	r3, r3, #12
 1081 0166 09D5     		bpl	.L83
 1082              	.LVL105:
 1083              	.LBB307:
 1084              	.LBB308:
 580:../drivers/fsl_dspi.h **** }
 1085              		.loc 2 580 0 is_stmt 1
 1086 0168 4FF40023 		mov	r3, #524288
 1087 016c E362     		str	r3, [r4, #44]
 1088              	.LVL106:
 1089              	.LBE308:
 1090              	.LBE307:
1733:../drivers/fsl_dspi.c ****         {
 1091              		.loc 1 1733 0
 1092 016e 8B68     		ldr	r3, [r1, #8]
 1093 0170 0BB1     		cbz	r3, .L113
1735:../drivers/fsl_dspi.c ****         }
 1094              		.loc 1 1735 0
 1095 0172 0223     		movs	r3, #2
 1096 0174 0B77     		strb	r3, [r1, #28]
 1097              	.L113:
1737:../drivers/fsl_dspi.c ****     }
 1098              		.loc 1 1737 0
 1099 0176 0B6A     		ldr	r3, [r1, #32]
 1100 0178 0133     		adds	r3, r3, #1
 1101 017a 0B62     		str	r3, [r1, #32]
 1102              	.L83:
1739:../drivers/fsl_dspi.c **** 
 1103              		.loc 1 1739 0
 1104 017c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1105              	.LVL107:
 1106              	.L150:
 1107              		.align	2
 1108              	.L149:
 1109 0180 00000000 		.word	.LANCHOR2
 1110              		.cfi_endproc
 1111              	.LFE200:
 1113              		.section	.text.DSPI_SetDummyData,"ax",%progbits
 1114              		.align	1
 1115              		.global	DSPI_SetDummyData
 1116              		.syntax unified
 1117              		.thumb
 1118              		.thumb_func
 1119              		.fpu fpv4-sp-d16
 1121              	DSPI_SetDummyData:
 1122              	.LFB168:
 168:../drivers/fsl_dspi.c ****     uint32_t instance = DSPI_GetInstance(base);
 1123              		.loc 1 168 0
 1124              		.cfi_startproc
 1125              		@ args = 0, pretend = 0, frame = 0
 1126              		@ frame_needed = 0, uses_anonymous_args = 0
 1127              	.LVL108:
 1128 0000 08B5     		push	{r3, lr}
 1129              		.cfi_def_cfa_offset 8
 1130              		.cfi_offset 3, -8
 1131              		.cfi_offset 14, -4
 169:../drivers/fsl_dspi.c ****     s_dummyData[instance] = dummyData;
 1132              		.loc 1 169 0
 1133 0002 FFF7FEFF 		bl	DSPI_GetInstance
 1134              	.LVL109:
 170:../drivers/fsl_dspi.c **** }
 1135              		.loc 1 170 0
 1136 0006 014B     		ldr	r3, .L152
 1137 0008 1954     		strb	r1, [r3, r0]
 171:../drivers/fsl_dspi.c **** 
 1138              		.loc 1 171 0
 1139 000a 08BD     		pop	{r3, pc}
 1140              	.L153:
 1141              		.align	2
 1142              	.L152:
 1143 000c 00000000 		.word	.LANCHOR2
 1144              		.cfi_endproc
 1145              	.LFE168:
 1147              		.section	.text.DSPI_MasterGetDefaultConfig,"ax",%progbits
 1148              		.align	1
 1149              		.global	DSPI_MasterGetDefaultConfig
 1150              		.syntax unified
 1151              		.thumb
 1152              		.thumb_func
 1153              		.fpu fpv4-sp-d16
 1155              	DSPI_MasterGetDefaultConfig:
 1156              	.LFB170:
 222:../drivers/fsl_dspi.c ****     assert(masterConfig);
 1157              		.loc 1 222 0
 1158              		.cfi_startproc
 1159              		@ args = 0, pretend = 0, frame = 0
 1160              		@ frame_needed = 0, uses_anonymous_args = 0
 1161              		@ link register save eliminated.
 1162              	.LVL110:
 227:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
 1163              		.loc 1 227 0
 1164 0000 0B49     		ldr	r1, .L155
 1165 0002 0822     		movs	r2, #8
 1166 0004 C0E90112 		strd	r1, r2, [r0, #4]
 232:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec = 1000;
 1167              		.loc 1 232 0
 1168 0008 4FF47A72 		mov	r2, #1000
 225:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.baudRate = 500000;
 1169              		.loc 1 225 0
 1170 000c 0023     		movs	r3, #0
 233:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.betweenTransferDelayInNanoSec = 1000;
 1171              		.loc 1 233 0
 1172 000e C0E90422 		strd	r2, r2, [r0, #16]
 234:../drivers/fsl_dspi.c **** 
 1173              		.loc 1 234 0
 1174 0012 8261     		str	r2, [r0, #24]
 236:../drivers/fsl_dspi.c ****     masterConfig->pcsActiveHighOrLow = kDSPI_PcsActiveLow;
 1175              		.loc 1 236 0
 1176 0014 0122     		movs	r2, #1
 225:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.baudRate = 500000;
 1177              		.loc 1 225 0
 1178 0016 0370     		strb	r3, [r0]
 228:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
 1179              		.loc 1 228 0
 1180 0018 0373     		strb	r3, [r0, #12]
 229:../drivers/fsl_dspi.c ****     masterConfig->ctarConfig.direction = kDSPI_MsbFirst;
 1181              		.loc 1 229 0
 1182 001a 4373     		strb	r3, [r0, #13]
 230:../drivers/fsl_dspi.c **** 
 1183              		.loc 1 230 0
 1184 001c 8373     		strb	r3, [r0, #14]
 236:../drivers/fsl_dspi.c ****     masterConfig->pcsActiveHighOrLow = kDSPI_PcsActiveLow;
 1185              		.loc 1 236 0
 1186 001e 0277     		strb	r2, [r0, #28]
 237:../drivers/fsl_dspi.c **** 
 1187              		.loc 1 237 0
 1188 0020 4277     		strb	r2, [r0, #29]
 239:../drivers/fsl_dspi.c ****     masterConfig->enableRxFifoOverWrite = false;
 1189              		.loc 1 239 0
 1190 0022 8377     		strb	r3, [r0, #30]
 240:../drivers/fsl_dspi.c ****     masterConfig->enableModifiedTimingFormat = false;
 1191              		.loc 1 240 0
 1192 0024 C377     		strb	r3, [r0, #31]
 241:../drivers/fsl_dspi.c ****     masterConfig->samplePoint = kDSPI_SckToSin0Clock;
 1193              		.loc 1 241 0
 1194 0026 80F82030 		strb	r3, [r0, #32]
 242:../drivers/fsl_dspi.c **** }
 1195              		.loc 1 242 0
 1196 002a 80F82130 		strb	r3, [r0, #33]
 243:../drivers/fsl_dspi.c **** 
 1197              		.loc 1 243 0
 1198 002e 7047     		bx	lr
 1199              	.L156:
 1200              		.align	2
 1201              	.L155:
 1202 0030 20A10700 		.word	500000
 1203              		.cfi_endproc
 1204              	.LFE170:
 1206              		.section	.text.DSPI_SlaveInit,"ax",%progbits
 1207              		.align	1
 1208              		.global	DSPI_SlaveInit
 1209              		.syntax unified
 1210              		.thumb
 1211              		.thumb_func
 1212              		.fpu fpv4-sp-d16
 1214              	DSPI_SlaveInit:
 1215              	.LFB171:
 246:../drivers/fsl_dspi.c ****     assert(slaveConfig);
 1216              		.loc 1 246 0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 0
 1219              		@ frame_needed = 0, uses_anonymous_args = 0
 1220              	.LVL111:
 1221 0000 38B5     		push	{r3, r4, r5, lr}
 1222              		.cfi_def_cfa_offset 16
 1223              		.cfi_offset 3, -16
 1224              		.cfi_offset 4, -12
 1225              		.cfi_offset 5, -8
 1226              		.cfi_offset 14, -4
 246:../drivers/fsl_dspi.c ****     assert(slaveConfig);
 1227              		.loc 1 246 0
 1228 0002 0246     		mov	r2, r0
 253:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 1229              		.loc 1 253 0
 1230 0004 FFF7FEFF 		bl	DSPI_GetInstance
 1231              	.LVL112:
 1232 0008 274B     		ldr	r3, .L158
 1233 000a 53F82040 		ldr	r4, [r3, r0, lsl #2]
 1234              	.LVL113:
 1235              	.LBB321:
 1236              	.LBB322:
 1237              		.file 4 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 1238              		.loc 4 694 0
 1239 000e 230C     		lsrs	r3, r4, #16
 1240 0010 03F18043 		add	r3, r3, #1073741824
 1241 0014 03F58E23 		add	r3, r3, #290816
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 1242              		.loc 4 695 0
 1243 0018 A4B2     		uxth	r4, r4
 1244              	.LVL114:
 1245 001a 1D68     		ldr	r5, [r3]
 1246 001c 0120     		movs	r0, #1
 1247              	.LVL115:
 1248 001e A040     		lsls	r0, r0, r4
 1249 0020 2843     		orrs	r0, r0, r5
 1250 0022 1860     		str	r0, [r3]
 1251              	.LVL116:
 1252              	.LBE322:
 1253              	.LBE321:
 1254              	.LBB323:
 1255              	.LBB324:
 537:../drivers/fsl_dspi.h ****     }
 1256              		.loc 2 537 0
 1257 0024 1368     		ldr	r3, [r2]
 1258              	.LBE324:
 1259              	.LBE323:
 264:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(slaveConfig->enableModifiedTimingFormat) |
 1260              		.loc 1 264 0
 1261 0026 0C7B     		ldrb	r4, [r1, #12]	@ zero_extendqisi2
 265:../drivers/fsl_dspi.c ****                 SPI_MCR_ROOE(slaveConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(slaveConfig->sam
 1262              		.loc 1 265 0
 1263 0028 887B     		ldrb	r0, [r1, #14]	@ zero_extendqisi2
 1264              	.LBB326:
 1265              	.LBB325:
 537:../drivers/fsl_dspi.h ****     }
 1266              		.loc 2 537 0
 1267 002a 23F48043 		bic	r3, r3, #16384
 1268 002e 1360     		str	r3, [r2]
 1269              	.LVL117:
 1270              	.LBE325:
 1271              	.LBE326:
 1272              	.LBB327:
 1273              	.LBB328:
 753:../drivers/fsl_dspi.h **** }
 1274              		.loc 2 753 0
 1275 0030 1368     		ldr	r3, [r2]
 1276 0032 43F00103 		orr	r3, r3, #1
 1277 0036 1360     		str	r3, [r2]
 1278              	.LVL118:
 1279              	.LBE328:
 1280              	.LBE327:
 1281              	.LBB329:
 1282              	.LBB330:
 720:../drivers/fsl_dspi.h **** }
 1283              		.loc 2 720 0
 1284 0038 1368     		ldr	r3, [r2]
 1285 003a 23F00043 		bic	r3, r3, #-2147483648
 1286 003e 1360     		str	r3, [r2]
 1287              	.LVL119:
 1288              	.LBE330:
 1289              	.LBE329:
 261:../drivers/fsl_dspi.c ****                           SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
 1290              		.loc 1 261 0
 1291 0040 1368     		ldr	r3, [r2]
 1292              	.LVL120:
 1293 0042 23F08A43 		bic	r3, r3, #1157627904
 1294              	.LVL121:
 1295 0046 23F44C53 		bic	r3, r3, #13056
 264:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(slaveConfig->enableModifiedTimingFormat) |
 1296              		.loc 1 264 0
 1297 004a 43EA8473 		orr	r3, r3, r4, lsl #30
 1298 004e 43EA8063 		orr	r3, r3, r0, lsl #26
 266:../drivers/fsl_dspi.c ****                 SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
 1299              		.loc 1 266 0
 1300 0052 487B     		ldrb	r0, [r1, #13]	@ zero_extendqisi2
 265:../drivers/fsl_dspi.c ****                 SPI_MCR_ROOE(slaveConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(slaveConfig->sam
 1301              		.loc 1 265 0
 1302 0054 43EA0063 		orr	r3, r3, r0, lsl #24
 266:../drivers/fsl_dspi.c ****                 SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
 1303              		.loc 1 266 0
 1304 0058 C87B     		ldrb	r0, [r1, #15]	@ zero_extendqisi2
 1305 005a 0002     		lsls	r0, r0, #8
 1306 005c 00F44070 		and	r0, r0, #768
 267:../drivers/fsl_dspi.c **** 
 1307              		.loc 1 267 0
 1308 0060 0343     		orrs	r3, r3, r0
 264:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(slaveConfig->enableModifiedTimingFormat) |
 1309              		.loc 1 264 0
 1310 0062 1360     		str	r3, [r2]
 1311              	.LVL122:
 1312              	.LBB331:
 1313              	.LBB332:
 313:../drivers/fsl_dspi.c **** 
 1314              		.loc 1 313 0
 1315 0064 1368     		ldr	r3, [r2]
 1316              	.LVL123:
 1317 0066 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 317:../drivers/fsl_dspi.c ****     }
 1318              		.loc 1 317 0
 1319 0068 43F48033 		orr	r3, r3, #65536
 1320              	.LVL124:
 1321 006c 02EB8000 		add	r0, r2, r0, lsl #2
 324:../drivers/fsl_dspi.c **** }
 1322              		.loc 1 324 0
 1323 0070 1360     		str	r3, [r2]
 1324              	.LVL125:
 1325              	.LBE332:
 1326              	.LBE331:
 275:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
 1327              		.loc 1 275 0
 1328 0072 0B7A     		ldrb	r3, [r1, #8]	@ zero_extendqisi2
 271:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 1329              		.loc 1 271 0
 1330 0074 C468     		ldr	r4, [r0, #12]
 1331              	.LVL126:
 275:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
 1332              		.loc 1 275 0
 1333 0076 9B06     		lsls	r3, r3, #26
 271:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 1334              		.loc 1 271 0
 1335 0078 24F0FE44 		bic	r4, r4, #2130706432
 1336              	.LVL127:
 275:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
 1337              		.loc 1 275 0
 1338 007c 03F08063 		and	r3, r3, #67108864
 274:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
 1339              		.loc 1 274 0
 1340 0080 2343     		orrs	r3, r3, r4
 1341 0082 4C68     		ldr	r4, [r1, #4]
 1342              	.LVL128:
 276:../drivers/fsl_dspi.c **** 
 1343              		.loc 1 276 0
 1344 0084 497A     		ldrb	r1, [r1, #9]	@ zero_extendqisi2
 1345              	.LVL129:
 274:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
 1346              		.loc 1 274 0
 1347 0086 013C     		subs	r4, r4, #1
 276:../drivers/fsl_dspi.c **** 
 1348              		.loc 1 276 0
 1349 0088 4906     		lsls	r1, r1, #25
 1350 008a 01F00071 		and	r1, r1, #33554432
 274:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
 1351              		.loc 1 274 0
 1352 008e 43EAC463 		orr	r3, r3, r4, lsl #27
 275:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
 1353              		.loc 1 275 0
 1354 0092 0B43     		orrs	r3, r3, r1
 274:../drivers/fsl_dspi.c ****                                          SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
 1355              		.loc 1 274 0
 1356 0094 C360     		str	r3, [r0, #12]
 278:../drivers/fsl_dspi.c **** 
 1357              		.loc 1 278 0
 1358 0096 0021     		movs	r1, #0
 1359 0098 1046     		mov	r0, r2
 1360 009a FFF7FEFF 		bl	DSPI_SetDummyData
 1361              	.LVL130:
 1362              	.LBB333:
 1363              	.LBB334:
 742:../drivers/fsl_dspi.h **** }
 1364              		.loc 2 742 0
 1365 009e 1368     		ldr	r3, [r2]
 1366 00a0 23F00103 		bic	r3, r3, #1
 1367 00a4 1360     		str	r3, [r2]
 1368              	.LVL131:
 1369              	.LBE334:
 1370              	.LBE333:
 281:../drivers/fsl_dspi.c **** 
 1371              		.loc 1 281 0
 1372 00a6 38BD     		pop	{r3, r4, r5, pc}
 1373              	.L159:
 1374              		.align	2
 1375              	.L158:
 1376 00a8 00000000 		.word	.LANCHOR3
 1377              		.cfi_endproc
 1378              	.LFE171:
 1380              		.section	.text.DSPI_SlaveGetDefaultConfig,"ax",%progbits
 1381              		.align	1
 1382              		.global	DSPI_SlaveGetDefaultConfig
 1383              		.syntax unified
 1384              		.thumb
 1385              		.thumb_func
 1386              		.fpu fpv4-sp-d16
 1388              	DSPI_SlaveGetDefaultConfig:
 1389              	.LFB172:
 284:../drivers/fsl_dspi.c ****     assert(slaveConfig);
 1390              		.loc 1 284 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 0
 1393              		@ frame_needed = 0, uses_anonymous_args = 0
 1394              		@ link register save eliminated.
 1395              	.LVL132:
 287:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.bitsPerFrame = 8;
 1396              		.loc 1 287 0
 1397 0000 0023     		movs	r3, #0
 288:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
 1398              		.loc 1 288 0
 1399 0002 0822     		movs	r2, #8
 287:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.bitsPerFrame = 8;
 1400              		.loc 1 287 0
 1401 0004 0370     		strb	r3, [r0]
 288:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
 1402              		.loc 1 288 0
 1403 0006 4260     		str	r2, [r0, #4]
 289:../drivers/fsl_dspi.c ****     slaveConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
 1404              		.loc 1 289 0
 1405 0008 0372     		strb	r3, [r0, #8]
 290:../drivers/fsl_dspi.c **** 
 1406              		.loc 1 290 0
 1407 000a 4372     		strb	r3, [r0, #9]
 292:../drivers/fsl_dspi.c ****     slaveConfig->enableRxFifoOverWrite = false;
 1408              		.loc 1 292 0
 1409 000c 0373     		strb	r3, [r0, #12]
 293:../drivers/fsl_dspi.c ****     slaveConfig->enableModifiedTimingFormat = false;
 1410              		.loc 1 293 0
 1411 000e 4373     		strb	r3, [r0, #13]
 294:../drivers/fsl_dspi.c ****     slaveConfig->samplePoint = kDSPI_SckToSin0Clock;
 1412              		.loc 1 294 0
 1413 0010 8373     		strb	r3, [r0, #14]
 295:../drivers/fsl_dspi.c **** }
 1414              		.loc 1 295 0
 1415 0012 C373     		strb	r3, [r0, #15]
 296:../drivers/fsl_dspi.c **** 
 1416              		.loc 1 296 0
 1417 0014 7047     		bx	lr
 1418              		.cfi_endproc
 1419              	.LFE172:
 1421              		.section	.text.DSPI_Deinit,"ax",%progbits
 1422              		.align	1
 1423              		.global	DSPI_Deinit
 1424              		.syntax unified
 1425              		.thumb
 1426              		.thumb_func
 1427              		.fpu fpv4-sp-d16
 1429              	DSPI_Deinit:
 1430              	.LFB173:
 299:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 1431              		.loc 1 299 0
 1432              		.cfi_startproc
 1433              		@ args = 0, pretend = 0, frame = 0
 1434              		@ frame_needed = 0, uses_anonymous_args = 0
 1435              	.LVL133:
 1436              	.LBB341:
 1437              	.LBB342:
 753:../drivers/fsl_dspi.h **** }
 1438              		.loc 2 753 0
 1439 0000 0268     		ldr	r2, [r0]
 1440 0002 42F00102 		orr	r2, r2, #1
 1441              	.LBE342:
 1442              	.LBE341:
 299:../drivers/fsl_dspi.c ****     DSPI_StopTransfer(base);
 1443              		.loc 1 299 0
 1444 0006 08B5     		push	{r3, lr}
 1445              		.cfi_def_cfa_offset 8
 1446              		.cfi_offset 3, -8
 1447              		.cfi_offset 14, -4
 1448              	.LBB344:
 1449              	.LBB343:
 753:../drivers/fsl_dspi.h **** }
 1450              		.loc 2 753 0
 1451 0008 0260     		str	r2, [r0]
 1452              	.LVL134:
 1453              	.LBE343:
 1454              	.LBE344:
 1455              	.LBB345:
 1456              	.LBB346:
 541:../drivers/fsl_dspi.h ****     }
 1457              		.loc 2 541 0
 1458 000a 0268     		ldr	r2, [r0]
 1459 000c 42F48042 		orr	r2, r2, #16384
 1460 0010 0260     		str	r2, [r0]
 1461              	.LVL135:
 1462              	.LBE346:
 1463              	.LBE345:
 305:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 1464              		.loc 1 305 0
 1465 0012 FFF7FEFF 		bl	DSPI_GetInstance
 1466              	.LVL136:
 1467 0016 084B     		ldr	r3, .L162
 1468 0018 53F82020 		ldr	r2, [r3, r0, lsl #2]
 1469              	.LVL137:
 1470              	.LBB347:
 1471              	.LBB348:
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 1472              		.loc 4 705 0
 1473 001c 130C     		lsrs	r3, r2, #16
 1474 001e 03F18043 		add	r3, r3, #1073741824
 1475 0022 03F58E23 		add	r3, r3, #290816
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 1476              		.loc 4 706 0
 1477 0026 92B2     		uxth	r2, r2
 1478              	.LVL138:
 1479 0028 1968     		ldr	r1, [r3]
 1480 002a 0120     		movs	r0, #1
 1481              	.LVL139:
 1482 002c 00FA02F2 		lsl	r2, r0, r2
 1483 0030 21EA0202 		bic	r2, r1, r2
 1484 0034 1A60     		str	r2, [r3]
 1485              	.LBE348:
 1486              	.LBE347:
 307:../drivers/fsl_dspi.c **** 
 1487              		.loc 1 307 0
 1488 0036 08BD     		pop	{r3, pc}
 1489              	.L163:
 1490              		.align	2
 1491              	.L162:
 1492 0038 00000000 		.word	.LANCHOR3
 1493              		.cfi_endproc
 1494              	.LFE173:
 1496              		.section	.text.DSPI_MasterSetBaudRate,"ax",%progbits
 1497              		.align	1
 1498              		.global	DSPI_MasterSetBaudRate
 1499              		.syntax unified
 1500              		.thumb
 1501              		.thumb_func
 1502              		.fpu fpv4-sp-d16
 1504              	DSPI_MasterSetBaudRate:
 1505              	.LFB175:
 331:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0*/
 1506              		.loc 1 331 0
 1507              		.cfi_startproc
 1508              		@ args = 0, pretend = 0, frame = 16
 1509              		@ frame_needed = 0, uses_anonymous_args = 0
 1510              	.LVL140:
 1511 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1512              		.cfi_def_cfa_offset 36
 1513              		.cfi_offset 4, -36
 1514              		.cfi_offset 5, -32
 1515              		.cfi_offset 6, -28
 1516              		.cfi_offset 7, -24
 1517              		.cfi_offset 8, -20
 1518              		.cfi_offset 9, -16
 1519              		.cfi_offset 10, -12
 1520              		.cfi_offset 11, -8
 1521              		.cfi_offset 14, -4
 1522 0004 85B0     		sub	sp, sp, #20
 1523              		.cfi_def_cfa_offset 56
 331:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0*/
 1524              		.loc 1 331 0
 1525 0006 0391     		str	r1, [sp, #12]
 1526              	.LBB355:
 1527              	.LBB356:
 731:../drivers/fsl_dspi.h **** }
 1528              		.loc 2 731 0
 1529 0008 0168     		ldr	r1, [r0]
 1530              	.LVL141:
 1531              	.LBE356:
 1532              	.LBE355:
 333:../drivers/fsl_dspi.c ****     {
 1533              		.loc 1 333 0
 1534 000a 0029     		cmp	r1, #0
 1535 000c 46DA     		bge	.L174
 1536              	.LBB357:
 1537              	.LBB358:
 353:../drivers/fsl_dspi.c ****     {
 1538              		.loc 1 353 0
 1539 000e 0025     		movs	r5, #0
 359:../drivers/fsl_dspi.c **** 
 1540              		.loc 1 359 0
 1541 0010 5900     		lsls	r1, r3, #1
 1542 0012 DFF8C0A0 		ldr	r10, .L186+8
 1543 0016 0191     		str	r1, [sp, #4]
 350:../drivers/fsl_dspi.c **** 
 1544              		.loc 1 350 0
 1545 0018 2C46     		mov	r4, r5
 349:../drivers/fsl_dspi.c ****     bestBaudrate = 0; /* required to avoid compilation warning */
 1546              		.loc 1 349 0
 1547 001a 4FF0010C 		mov	ip, #1
 348:../drivers/fsl_dspi.c ****     bestDbr = 1;
 1548              		.loc 1 348 0
 1549 001e A946     		mov	r9, r5
 347:../drivers/fsl_dspi.c ****     bestScaler = 0;
 1550              		.loc 1 347 0
 1551 0020 A846     		mov	r8, r5
 346:../drivers/fsl_dspi.c ****     bestPrescaler = 0;
 1552              		.loc 1 346 0
 1553 0022 4FF0FF31 		mov	r1, #-1
 1554              	.L171:
 1555              	.LVL142:
 359:../drivers/fsl_dspi.c **** 
 1556              		.loc 1 359 0
 1557 0026 DAF80060 		ldr	r6, [r10]
 1558 002a 0296     		str	r6, [sp, #8]
 1559 002c A646     		mov	lr, r4
 1560 002e 0F46     		mov	r7, r1
 1561 0030 0026     		movs	r6, #0
 1562 0032 37E0     		b	.L169
 1563              	.LVL143:
 1564              	.L176:
 357:../drivers/fsl_dspi.c ****             {
 1565              		.loc 1 357 0
 1566 0034 A646     		mov	lr, r4
 1567 0036 B146     		mov	r9, r6
 1568 0038 0F46     		mov	r7, r1
 1569 003a A846     		mov	r8, r5
 1570 003c 4FF0010C 		mov	ip, #1
 1571              	.LVL144:
 1572              	.L172:
 359:../drivers/fsl_dspi.c **** 
 1573              		.loc 1 359 0
 1574 0040 0199     		ldr	r1, [sp, #4]
 1575 0042 B1FBFBF1 		udiv	r1, r1, fp
 1576              	.LVL145:
 364:../drivers/fsl_dspi.c ****                 {
 1577              		.loc 1 364 0
 1578 0046 8A42     		cmp	r2, r1
 1579 0048 08D3     		bcc	.L167
 366:../drivers/fsl_dspi.c ****                     if (min_diff > diff)
 1580              		.loc 1 366 0
 1581 004a 541A     		subs	r4, r2, r1
 1582              	.LVL146:
 367:../drivers/fsl_dspi.c ****                     {
 1583              		.loc 1 367 0
 1584 004c BC42     		cmp	r4, r7
 1585 004e 05D2     		bcs	.L167
 1586 0050 2746     		mov	r7, r4
 1587              	.LVL147:
 1588 0052 8E46     		mov	lr, r1
 1589              	.LVL148:
 1590 0054 B146     		mov	r9, r6
 1591 0056 A846     		mov	r8, r5
 357:../drivers/fsl_dspi.c ****             {
 1592              		.loc 1 357 0
 1593 0058 4FF0020C 		mov	ip, #2
 1594              	.LVL149:
 1595              	.L167:
 1596 005c 7446     		mov	r4, lr
 1597 005e 3946     		mov	r1, r7
 1598              	.LVL150:
 1599              	.L173:
 355:../drivers/fsl_dspi.c ****         {
 1600              		.loc 1 355 0
 1601 0060 0136     		adds	r6, r6, #1
 1602              	.LVL151:
 1603 0062 102E     		cmp	r6, #16
 1604 0064 00D0     		beq	.L168
 1605 0066 D9B9     		cbnz	r1, .L175
 1606              	.L168:
 353:../drivers/fsl_dspi.c ****     {
 1607              		.loc 1 353 0
 1608 0068 0135     		adds	r5, r5, #1
 1609              	.LVL152:
 1610 006a 042D     		cmp	r5, #4
 1611 006c 03D0     		beq	.L170
 1612 006e 0AF1040A 		add	r10, r10, #4
 1613 0072 0029     		cmp	r1, #0
 1614 0074 D7D1     		bne	.L171
 1615              	.L170:
 1616 0076 039B     		ldr	r3, [sp, #12]
 1617              	.LVL153:
 1618 0078 00EB8300 		add	r0, r0, r3, lsl #2
 1619              	.LVL154:
 382:../drivers/fsl_dspi.c **** 
 1620              		.loc 1 382 0
 1621 007c 134B     		ldr	r3, .L186
 1622 007e C268     		ldr	r2, [r0, #12]
 1623              	.LVL155:
 1624 0080 1340     		ands	r3, r3, r2
 1625              	.LVL156:
 384:../drivers/fsl_dspi.c ****                             (bestScaler << SPI_CTAR_BR_SHIFT);
 1626              		.loc 1 384 0
 1627 0082 43EA0903 		orr	r3, r3, r9
 1628              	.LVL157:
 1629 0086 43EA0848 		orr	r8, r3, r8, lsl #16
 1630 008a 0CF1FF3C 		add	ip, ip, #-1
 1631 008e 48EACC73 		orr	r3, r8, ip, lsl #31
 1632 0092 C360     		str	r3, [r0, #12]
 1633              	.LVL158:
 1634              	.L164:
 1635              	.LBE358:
 1636              	.LBE357:
 389:../drivers/fsl_dspi.c **** 
 1637              		.loc 1 389 0
 1638 0094 2046     		mov	r0, r4
 1639 0096 05B0     		add	sp, sp, #20
 1640              		.cfi_remember_state
 1641              		.cfi_def_cfa_offset 36
 1642              		@ sp needed
 1643 0098 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1644              	.LVL159:
 1645              	.L174:
 1646              		.cfi_restore_state
 335:../drivers/fsl_dspi.c ****     }
 1647              		.loc 1 335 0
 1648 009c 0024     		movs	r4, #0
 1649 009e F9E7     		b	.L164
 1650              	.LVL160:
 1651              	.L175:
 1652              	.LBB360:
 1653              	.LBB359:
 355:../drivers/fsl_dspi.c ****         {
 1654              		.loc 1 355 0
 1655 00a0 A646     		mov	lr, r4
 1656 00a2 0F46     		mov	r7, r1
 1657              	.LVL161:
 1658              	.L169:
 359:../drivers/fsl_dspi.c **** 
 1659              		.loc 1 359 0
 1660 00a4 0A49     		ldr	r1, .L186+4
 1661 00a6 029C     		ldr	r4, [sp, #8]
 1662 00a8 51F82610 		ldr	r1, [r1, r6, lsl #2]
 1663 00ac 01FB04FB 		mul	fp, r1, r4
 1664              	.LVL162:
 1665 00b0 B3FBFBF4 		udiv	r4, r3, fp
 1666              	.LVL163:
 364:../drivers/fsl_dspi.c ****                 {
 1667              		.loc 1 364 0
 1668 00b4 A242     		cmp	r2, r4
 1669 00b6 C3D3     		bcc	.L172
 1670              	.LVL164:
 366:../drivers/fsl_dspi.c ****                     if (min_diff > diff)
 1671              		.loc 1 366 0
 1672 00b8 111B     		subs	r1, r2, r4
 1673              	.LVL165:
 367:../drivers/fsl_dspi.c ****                     {
 1674              		.loc 1 367 0
 1675 00ba B942     		cmp	r1, r7
 1676 00bc C0D2     		bcs	.L172
 1677              	.LVL166:
 357:../drivers/fsl_dspi.c ****             {
 1678              		.loc 1 357 0
 1679 00be 0029     		cmp	r1, #0
 1680 00c0 B8D1     		bne	.L176
 1681 00c2 B146     		mov	r9, r6
 1682 00c4 A846     		mov	r8, r5
 1683 00c6 4FF0010C 		mov	ip, #1
 1684 00ca C9E7     		b	.L173
 1685              	.L187:
 1686              		.align	2
 1687              	.L186:
 1688 00cc F0FFFC7F 		.word	2147287024
 1689 00d0 00000000 		.word	.LANCHOR4
 1690 00d4 00000000 		.word	.LANCHOR5
 1691              	.LBE359:
 1692              	.LBE360:
 1693              		.cfi_endproc
 1694              	.LFE175:
 1696              		.section	.text.DSPI_MasterSetDelayScaler,"ax",%progbits
 1697              		.align	1
 1698              		.global	DSPI_MasterSetDelayScaler
 1699              		.syntax unified
 1700              		.thumb
 1701              		.thumb_func
 1702              		.fpu fpv4-sp-d16
 1704              	DSPI_MasterSetDelayScaler:
 1705              	.LFB176:
 393:../drivers/fsl_dspi.c ****     /* these settings are only relevant in master mode */
 1706              		.loc 1 393 0
 1707              		.cfi_startproc
 1708              		@ args = 4, pretend = 0, frame = 0
 1709              		@ frame_needed = 0, uses_anonymous_args = 0
 1710              	.LVL167:
 1711 0000 30B5     		push	{r4, r5, lr}
 1712              		.cfi_def_cfa_offset 12
 1713              		.cfi_offset 4, -12
 1714              		.cfi_offset 5, -8
 1715              		.cfi_offset 14, -4
 1716              	.LBB367:
 1717              	.LBB368:
 731:../drivers/fsl_dspi.h **** }
 1718              		.loc 2 731 0
 1719 0002 0568     		ldr	r5, [r0]
 1720              	.LVL168:
 1721              	.LBE368:
 1722              	.LBE367:
 393:../drivers/fsl_dspi.c ****     /* these settings are only relevant in master mode */
 1723              		.loc 1 393 0
 1724 0004 9DF80C40 		ldrb	r4, [sp, #12]	@ zero_extendqisi2
 395:../drivers/fsl_dspi.c ****     {
 1725              		.loc 1 395 0
 1726 0008 002D     		cmp	r5, #0
 1727 000a 14DA     		bge	.L188
 397:../drivers/fsl_dspi.c ****         {
 1728              		.loc 1 397 0
 1729 000c 022C     		cmp	r4, #2
 1730 000e 13D0     		beq	.L190
 1731 0010 032C     		cmp	r4, #3
 1732 0012 20D0     		beq	.L191
 1733 0014 012C     		cmp	r4, #1
 1734 0016 0ED1     		bne	.L188
 1735              	.LVL169:
 1736 0018 00EB8100 		add	r0, r0, r1, lsl #2
 1737              	.LVL170:
 1738              	.LBB369:
 1739              	.LBB370:
 401:../drivers/fsl_dspi.c ****                 break;
 1740              		.loc 1 401 0
 1741 001c 9205     		lsls	r2, r2, #22
 1742              	.LVL171:
 400:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
 1743              		.loc 1 400 0
 1744 001e C168     		ldr	r1, [r0, #12]
 1745              	.LVL172:
 401:../drivers/fsl_dspi.c ****                 break;
 1746              		.loc 1 401 0
 1747 0020 1B03     		lsls	r3, r3, #12
 1748              	.LVL173:
 1749 0022 9BB2     		uxth	r3, r3
 1750 0024 02F44002 		and	r2, r2, #12582912
 1751 0028 1A43     		orrs	r2, r2, r3
 400:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
 1752              		.loc 1 400 0
 1753 002a 21F44003 		bic	r3, r1, #12582912
 1754 002e 23F47043 		bic	r3, r3, #61440
 1755              	.LVL174:
 1756              	.L193:
 1757              	.LBE370:
 1758              	.LBE369:
 409:../drivers/fsl_dspi.c ****                 break;
 1759              		.loc 1 409 0
 1760 0032 1A43     		orrs	r2, r2, r3
 408:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
 1761              		.loc 1 408 0
 1762 0034 C260     		str	r2, [r0, #12]
 1763              	.L188:
 415:../drivers/fsl_dspi.c **** 
 1764              		.loc 1 415 0
 1765 0036 30BD     		pop	{r4, r5, pc}
 1766              	.LVL175:
 1767              	.L190:
 1768 0038 00EB8100 		add	r0, r0, r1, lsl #2
 1769              	.LVL176:
 405:../drivers/fsl_dspi.c ****                 break;
 1770              		.loc 1 405 0
 1771 003c 1205     		lsls	r2, r2, #20
 1772              	.LVL177:
 404:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
 1773              		.loc 1 404 0
 1774 003e C168     		ldr	r1, [r0, #12]
 1775              	.LVL178:
 405:../drivers/fsl_dspi.c ****                 break;
 1776              		.loc 1 405 0
 1777 0040 1B02     		lsls	r3, r3, #8
 1778              	.LVL179:
 1779 0042 03F47063 		and	r3, r3, #3840
 1780 0046 02F44012 		and	r2, r2, #3145728
 1781 004a 1A43     		orrs	r2, r2, r3
 404:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
 1782              		.loc 1 404 0
 1783 004c 21F44013 		bic	r3, r1, #3145728
 1784 0050 23F47063 		bic	r3, r3, #3840
 1785 0054 EDE7     		b	.L193
 1786              	.LVL180:
 1787              	.L191:
 1788 0056 00EB8100 		add	r0, r0, r1, lsl #2
 1789              	.LVL181:
 409:../drivers/fsl_dspi.c ****                 break;
 1790              		.loc 1 409 0
 1791 005a 9204     		lsls	r2, r2, #18
 1792              	.LVL182:
 408:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
 1793              		.loc 1 408 0
 1794 005c C168     		ldr	r1, [r0, #12]
 1795              	.LVL183:
 409:../drivers/fsl_dspi.c ****                 break;
 1796              		.loc 1 409 0
 1797 005e 1B01     		lsls	r3, r3, #4
 1798              	.LVL184:
 1799 0060 DBB2     		uxtb	r3, r3
 1800 0062 02F44022 		and	r2, r2, #786432
 1801 0066 1A43     		orrs	r2, r2, r3
 408:../drivers/fsl_dspi.c ****                                         SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
 1802              		.loc 1 408 0
 1803 0068 21F44023 		bic	r3, r1, #786432
 1804 006c 23F0F003 		bic	r3, r3, #240
 1805 0070 DFE7     		b	.L193
 1806              		.cfi_endproc
 1807              	.LFE176:
 1809              		.section	.text.DSPI_MasterSetDelayTimes,"ax",%progbits
 1810              		.align	1
 1811              		.global	DSPI_MasterSetDelayTimes
 1812              		.syntax unified
 1813              		.thumb
 1814              		.thumb_func
 1815              		.fpu fpv4-sp-d16
 1817              	DSPI_MasterSetDelayTimes:
 1818              	.LFB177:
 422:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0 */
 1819              		.loc 1 422 0
 1820              		.cfi_startproc
 1821              		@ args = 4, pretend = 0, frame = 8
 1822              		@ frame_needed = 0, uses_anonymous_args = 0
 1823              	.LVL185:
 1824 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1825              		.cfi_def_cfa_offset 36
 1826              		.cfi_offset 4, -36
 1827              		.cfi_offset 5, -32
 1828              		.cfi_offset 6, -28
 1829              		.cfi_offset 7, -24
 1830              		.cfi_offset 8, -20
 1831              		.cfi_offset 9, -16
 1832              		.cfi_offset 10, -12
 1833              		.cfi_offset 11, -8
 1834              		.cfi_offset 14, -4
 1835              	.LBB377:
 1836              	.LBB378:
 731:../drivers/fsl_dspi.h **** }
 1837              		.loc 2 731 0
 1838 0004 0468     		ldr	r4, [r0]
 1839              	.LVL186:
 1840              	.LBE378:
 1841              	.LBE377:
 424:../drivers/fsl_dspi.c ****     {
 1842              		.loc 1 424 0
 1843 0006 002C     		cmp	r4, #0
 422:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0 */
 1844              		.loc 1 422 0
 1845 0008 85B0     		sub	sp, sp, #20
 1846              		.cfi_def_cfa_offset 56
 422:../drivers/fsl_dspi.c ****     /* for master mode configuration, if slave mode detected, return 0 */
 1847              		.loc 1 422 0
 1848 000a 0746     		mov	r7, r0
 1849 000c 8C46     		mov	ip, r1
 424:../drivers/fsl_dspi.c ****     {
 1850              		.loc 1 424 0
 1851 000e 0FDA     		bge	.L202
 1852              	.LVL187:
 1853              	.LBB379:
 1854              	.LBB380:
 451:../drivers/fsl_dspi.c ****     {
 1855              		.loc 1 451 0
 1856 0010 0E9D     		ldr	r5, [sp, #56]
 445:../drivers/fsl_dspi.c **** 
 1857              		.loc 1 445 0
 1858 0012 264C     		ldr	r4, .L213
 1859 0014 B4FBF3F4 		udiv	r4, r4, r3
 1860 0018 6400     		lsls	r4, r4, #1
 1861              	.LVL188:
 451:../drivers/fsl_dspi.c ****     {
 1862              		.loc 1 451 0
 1863 001a A542     		cmp	r5, r4
 1864 001c 0AD8     		bhi	.L196
 453:../drivers/fsl_dspi.c ****         return initialDelayNanoSec;
 1865              		.loc 1 453 0
 1866 001e 0023     		movs	r3, #0
 1867              	.LVL189:
 1868 0020 0092     		str	r2, [sp]
 1869 0022 1A46     		mov	r2, r3
 1870              	.LVL190:
 1871              	.L212:
 483:../drivers/fsl_dspi.c **** 
 1872              		.loc 1 483 0
 1873 0024 FFF7FEFF 		bl	DSPI_MasterSetDelayScaler
 1874              	.LVL191:
 1875              	.L194:
 1876              	.LBE380:
 1877              	.LBE379:
 487:../drivers/fsl_dspi.c **** 
 1878              		.loc 1 487 0
 1879 0028 2046     		mov	r0, r4
 1880 002a 05B0     		add	sp, sp, #20
 1881              		.cfi_remember_state
 1882              		.cfi_def_cfa_offset 36
 1883              		@ sp needed
 1884 002c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1885              	.LVL192:
 1886              	.L202:
 1887              		.cfi_restore_state
 426:../drivers/fsl_dspi.c ****     }
 1888              		.loc 1 426 0
 1889 0030 0024     		movs	r4, #0
 1890 0032 F9E7     		b	.L194
 1891              	.LVL193:
 1892              	.L196:
 1893              	.LBB382:
 1894              	.LBB381:
 442:../drivers/fsl_dspi.c **** 
 1895              		.loc 1 442 0
 1896 0034 4FF4E024 		mov	r4, #458752
 1897              	.LVL194:
 1898 0038 1D4D     		ldr	r5, .L213+4
 1899              	.LVL195:
 462:../drivers/fsl_dspi.c **** 
 1900              		.loc 1 462 0
 1901 003a DFF87880 		ldr	r8, .L213+8
 442:../drivers/fsl_dspi.c **** 
 1902              		.loc 1 442 0
 1903 003e B5FBF3F5 		udiv	r5, r5, r3
 462:../drivers/fsl_dspi.c **** 
 1904              		.loc 1 462 0
 1905 0042 DFF87490 		ldr	r9, .L213+12
 442:../drivers/fsl_dspi.c **** 
 1906              		.loc 1 442 0
 1907 0046 6C43     		muls	r4, r5, r4
 441:../drivers/fsl_dspi.c ****     bestDelay = (((1000000000U * 4) / srcClock_Hz) * s_delayPrescaler[bestPrescaler] * s_delayScale
 1908              		.loc 1 441 0
 1909 0048 0F23     		movs	r3, #15
 1910              	.LVL196:
 442:../drivers/fsl_dspi.c **** 
 1911              		.loc 1 442 0
 1912 004a A408     		lsrs	r4, r4, #2
 458:../drivers/fsl_dspi.c ****     {
 1913              		.loc 1 458 0
 1914 004c 0020     		movs	r0, #0
 1915              	.LVL197:
 441:../drivers/fsl_dspi.c ****     bestDelay = (((1000000000U * 4) / srcClock_Hz) * s_delayPrescaler[bestPrescaler] * s_delayScale
 1916              		.loc 1 441 0
 1917 004e 0293     		str	r3, [sp, #8]
 440:../drivers/fsl_dspi.c ****     bestScaler = 0xF;
 1918              		.loc 1 440 0
 1919 0050 4FF0030E 		mov	lr, #3
 438:../drivers/fsl_dspi.c ****     /* Initialize prescaler and scaler to their max values to generate the max delay */
 1920              		.loc 1 438 0
 1921 0054 4FF0FF36 		mov	r6, #-1
 1922              	.LVL198:
 1923              	.L201:
 462:../drivers/fsl_dspi.c **** 
 1924              		.loc 1 462 0
 1925 0058 58F82010 		ldr	r1, [r8, r0, lsl #2]
 1926 005c 01FB05F3 		mul	r3, r1, r5
 1927 0060 0393     		str	r3, [sp, #12]
 1928 0062 4FF0000A 		mov	r10, #0
 1929              	.LVL199:
 1930              	.L199:
 1931 0066 039B     		ldr	r3, [sp, #12]
 1932 0068 59F82A10 		ldr	r1, [r9, r10, lsl #2]
 1933 006c 5943     		muls	r1, r3, r1
 467:../drivers/fsl_dspi.c ****             {
 1934              		.loc 1 467 0
 1935 006e 0E9B     		ldr	r3, [sp, #56]
 462:../drivers/fsl_dspi.c **** 
 1936              		.loc 1 462 0
 1937 0070 8908     		lsrs	r1, r1, #2
 1938              	.LVL200:
 467:../drivers/fsl_dspi.c ****             {
 1939              		.loc 1 467 0
 1940 0072 8B42     		cmp	r3, r1
 1941 0074 08D8     		bhi	.L197
 469:../drivers/fsl_dspi.c ****                 if (min_diff > diff)
 1942              		.loc 1 469 0
 1943 0076 A1EB030B 		sub	fp, r1, r3
 1944              	.LVL201:
 470:../drivers/fsl_dspi.c ****                 {
 1945              		.loc 1 470 0
 1946 007a B345     		cmp	fp, r6
 1947 007c 3FBF     		itttt	cc
 1948 007e 5E46     		movcc	r6, fp
 1949              	.LVL202:
 1950 0080 0C46     		movcc	r4, r1
 1951 0082 CDF808A0 		strcc	r10, [sp, #8]
 1952 0086 8646     		movcc	lr, r0
 1953              	.LVL203:
 1954              	.L197:
 460:../drivers/fsl_dspi.c ****         {
 1955              		.loc 1 460 0
 1956 0088 0AF1010A 		add	r10, r10, #1
 1957              	.LVL204:
 1958 008c BAF1100F 		cmp	r10, #16
 1959 0090 01D0     		beq	.L198
 1960 0092 002E     		cmp	r6, #0
 1961 0094 E7D1     		bne	.L199
 1962              	.L198:
 458:../drivers/fsl_dspi.c ****     {
 1963              		.loc 1 458 0
 1964 0096 0130     		adds	r0, r0, #1
 1965              	.LVL205:
 1966 0098 0428     		cmp	r0, #4
 1967 009a 01D0     		beq	.L200
 1968 009c 002E     		cmp	r6, #0
 1969 009e DBD1     		bne	.L201
 1970              	.L200:
 483:../drivers/fsl_dspi.c **** 
 1971              		.loc 1 483 0
 1972 00a0 0092     		str	r2, [sp]
 1973 00a2 029B     		ldr	r3, [sp, #8]
 1974 00a4 7246     		mov	r2, lr
 1975              	.LVL206:
 1976 00a6 6146     		mov	r1, ip
 1977              	.LVL207:
 1978 00a8 3846     		mov	r0, r7
 1979              	.LVL208:
 1980 00aa BBE7     		b	.L212
 1981              	.L214:
 1982              		.align	2
 1983              	.L213:
 1984 00ac 00CA9A3B 		.word	1000000000
 1985 00b0 00286BEE 		.word	-294967296
 1986 00b4 00000000 		.word	.LANCHOR7
 1987 00b8 00000000 		.word	.LANCHOR6
 1988              	.LBE381:
 1989              	.LBE382:
 1990              		.cfi_endproc
 1991              	.LFE177:
 1993              		.section	.text.DSPI_MasterInit,"ax",%progbits
 1994              		.align	1
 1995              		.global	DSPI_MasterInit
 1996              		.syntax unified
 1997              		.thumb
 1998              		.thumb_func
 1999              		.fpu fpv4-sp-d16
 2001              	DSPI_MasterInit:
 2002              	.LFB169:
 174:../drivers/fsl_dspi.c ****     assert(masterConfig);
 2003              		.loc 1 174 0
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 0
 2006              		@ frame_needed = 0, uses_anonymous_args = 0
 2007              	.LVL209:
 2008 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 2009              		.cfi_def_cfa_offset 24
 2010              		.cfi_offset 4, -16
 2011              		.cfi_offset 5, -12
 2012              		.cfi_offset 6, -8
 2013              		.cfi_offset 14, -4
 174:../drivers/fsl_dspi.c ****     assert(masterConfig);
 2014              		.loc 1 174 0
 2015 0002 0D46     		mov	r5, r1
 2016 0004 0446     		mov	r4, r0
 2017 0006 1646     		mov	r6, r2
 180:../drivers/fsl_dspi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 2018              		.loc 1 180 0
 2019 0008 FFF7FEFF 		bl	DSPI_GetInstance
 2020              	.LVL210:
 2021 000c 3F4B     		ldr	r3, .L218
 2022 000e 53F82010 		ldr	r1, [r3, r0, lsl #2]
 2023              	.LVL211:
 2024              	.LBB395:
 2025              	.LBB396:
 694:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 2026              		.loc 4 694 0
 2027 0012 0B0C     		lsrs	r3, r1, #16
 2028 0014 03F18043 		add	r3, r3, #1073741824
 2029 0018 03F58E23 		add	r3, r3, #290816
 695:../drivers/fsl_clock.h **** }
 2030              		.loc 4 695 0
 2031 001c 89B2     		uxth	r1, r1
 2032              	.LVL212:
 2033 001e 1868     		ldr	r0, [r3]
 2034              	.LVL213:
 2035 0020 0122     		movs	r2, #1
 2036              	.LVL214:
 2037 0022 8A40     		lsls	r2, r2, r1
 2038 0024 0243     		orrs	r2, r2, r0
 2039 0026 1A60     		str	r2, [r3]
 2040              	.LVL215:
 2041              	.LBE396:
 2042              	.LBE395:
 2043              	.LBB397:
 2044              	.LBB398:
 537:../drivers/fsl_dspi.h ****     }
 2045              		.loc 2 537 0
 2046 0028 2368     		ldr	r3, [r4]
 2047              	.LBE398:
 2048              	.LBE397:
 191:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
 2049              		.loc 1 191 0
 2050 002a A97F     		ldrb	r1, [r5, #30]	@ zero_extendqisi2
 192:../drivers/fsl_dspi.c ****                 SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->s
 2051              		.loc 1 192 0
 2052 002c 95F82020 		ldrb	r2, [r5, #32]	@ zero_extendqisi2
 2053              	.LBB400:
 2054              	.LBB399:
 537:../drivers/fsl_dspi.h ****     }
 2055              		.loc 2 537 0
 2056 0030 23F48043 		bic	r3, r3, #16384
 2057 0034 2360     		str	r3, [r4]
 2058              	.LVL216:
 2059              	.LBE399:
 2060              	.LBE400:
 2061              	.LBB401:
 2062              	.LBB402:
 753:../drivers/fsl_dspi.h **** }
 2063              		.loc 2 753 0
 2064 0036 2368     		ldr	r3, [r4]
 2065 0038 43F00103 		orr	r3, r3, #1
 2066 003c 2360     		str	r3, [r4]
 2067              	.LVL217:
 2068              	.LBE402:
 2069              	.LBE401:
 2070              	.LBB403:
 2071              	.LBB404:
 720:../drivers/fsl_dspi.h **** }
 2072              		.loc 2 720 0
 2073 003e 2368     		ldr	r3, [r4]
 2074 0040 43F00043 		orr	r3, r3, #-2147483648
 2075 0044 2360     		str	r3, [r4]
 2076              	.LVL218:
 2077              	.LBE404:
 2078              	.LBE403:
 188:../drivers/fsl_dspi.c ****                           SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
 2079              		.loc 1 188 0
 2080 0046 2368     		ldr	r3, [r4]
 2081              	.LVL219:
 2082 0048 23F08A43 		bic	r3, r3, #1157627904
 2083              	.LVL220:
 2084 004c 23F44C53 		bic	r3, r3, #13056
 191:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
 2085              		.loc 1 191 0
 2086 0050 43EA8173 		orr	r3, r3, r1, lsl #30
 2087 0054 43EA8263 		orr	r3, r3, r2, lsl #26
 193:../drivers/fsl_dspi.c ****                 SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
 2088              		.loc 1 193 0
 2089 0058 EA7F     		ldrb	r2, [r5, #31]	@ zero_extendqisi2
 2090              	.LBB405:
 2091              	.LBB406:
 315:../drivers/fsl_dspi.c ****     {
 2092              		.loc 1 315 0
 2093 005a 697F     		ldrb	r1, [r5, #29]	@ zero_extendqisi2
 2094              	.LBE406:
 2095              	.LBE405:
 192:../drivers/fsl_dspi.c ****                 SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->s
 2096              		.loc 1 192 0
 2097 005c 43EA0263 		orr	r3, r3, r2, lsl #24
 193:../drivers/fsl_dspi.c ****                 SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
 2098              		.loc 1 193 0
 2099 0060 95F82120 		ldrb	r2, [r5, #33]	@ zero_extendqisi2
 2100 0064 1202     		lsls	r2, r2, #8
 2101 0066 02F44072 		and	r2, r2, #768
 194:../drivers/fsl_dspi.c **** 
 2102              		.loc 1 194 0
 2103 006a 1343     		orrs	r3, r3, r2
 191:../drivers/fsl_dspi.c ****                 SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
 2104              		.loc 1 191 0
 2105 006c 2360     		str	r3, [r4]
 2106              	.LVL221:
 2107 006e 2B7F     		ldrb	r3, [r5, #28]	@ zero_extendqisi2
 2108              	.LBB408:
 2109              	.LBB407:
 313:../drivers/fsl_dspi.c **** 
 2110              		.loc 1 313 0
 2111 0070 2268     		ldr	r2, [r4]
 2112              	.LVL222:
 2113 0072 1B04     		lsls	r3, r3, #16
 315:../drivers/fsl_dspi.c ****     {
 2114              		.loc 1 315 0
 2115 0074 0129     		cmp	r1, #1
 2116 0076 03F47C13 		and	r3, r3, #4128768
 317:../drivers/fsl_dspi.c ****     }
 2117              		.loc 1 317 0
 2118 007a 0CBF     		ite	eq
 2119 007c 1343     		orreq	r3, r3, r2
 2120              	.LVL223:
 321:../drivers/fsl_dspi.c ****     }
 2121              		.loc 1 321 0
 2122 007e 22EA0303 		bicne	r3, r2, r3
 2123              	.LVL224:
 324:../drivers/fsl_dspi.c **** }
 2124              		.loc 1 324 0
 2125 0082 2360     		str	r3, [r4]
 2126              	.LVL225:
 2127              	.LBE407:
 2128              	.LBE408:
 198:../drivers/fsl_dspi.c ****     {
 2129              		.loc 1 198 0
 2130 0084 6A68     		ldr	r2, [r5, #4]
 2131 0086 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 2132 0088 3346     		mov	r3, r6
 2133 008a 2046     		mov	r0, r4
 2134 008c FFF7FEFF 		bl	DSPI_MasterSetBaudRate
 2135              	.LVL226:
 203:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 2136              		.loc 1 203 0
 2137 0090 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 207:../drivers/fsl_dspi.c ****         SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.dire
 2138              		.loc 1 207 0
 2139 0092 AB68     		ldr	r3, [r5, #8]
 2140 0094 04EB8100 		add	r0, r4, r1, lsl #2
 2141 0098 013B     		subs	r3, r3, #1
 203:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 2142              		.loc 1 203 0
 2143 009a C268     		ldr	r2, [r0, #12]
 2144              	.LVL227:
 207:../drivers/fsl_dspi.c ****         SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.dire
 2145              		.loc 1 207 0
 2146 009c DB06     		lsls	r3, r3, #27
 203:../drivers/fsl_dspi.c ****            ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
 2147              		.loc 1 203 0
 2148 009e 22F0FE42 		bic	r2, r2, #2130706432
 2149              	.LVL228:
 207:../drivers/fsl_dspi.c ****         SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.dire
 2150              		.loc 1 207 0
 2151 00a2 03F0F043 		and	r3, r3, #2013265920
 2152 00a6 1343     		orrs	r3, r3, r2
 2153 00a8 2A7B     		ldrb	r2, [r5, #12]	@ zero_extendqisi2
 2154              	.LVL229:
 2155 00aa 9206     		lsls	r2, r2, #26
 2156 00ac 02F08062 		and	r2, r2, #67108864
 2157 00b0 1343     		orrs	r3, r3, r2
 208:../drivers/fsl_dspi.c **** 
 2158              		.loc 1 208 0
 2159 00b2 6A7B     		ldrb	r2, [r5, #13]	@ zero_extendqisi2
 2160 00b4 5206     		lsls	r2, r2, #25
 2161 00b6 02F00072 		and	r2, r2, #33554432
 207:../drivers/fsl_dspi.c ****         SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.dire
 2162              		.loc 1 207 0
 2163 00ba 1343     		orrs	r3, r3, r2
 208:../drivers/fsl_dspi.c **** 
 2164              		.loc 1 208 0
 2165 00bc AA7B     		ldrb	r2, [r5, #14]	@ zero_extendqisi2
 2166 00be 1206     		lsls	r2, r2, #24
 2167 00c0 02F08072 		and	r2, r2, #16777216
 2168 00c4 1343     		orrs	r3, r3, r2
 206:../drivers/fsl_dspi.c ****         temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1) | SPI_CTAR_CPOL(masterConfi
 2169              		.loc 1 206 0
 2170 00c6 C360     		str	r3, [r0, #12]
 210:../drivers/fsl_dspi.c ****                              masterConfig->ctarConfig.pcsToSckDelayInNanoSec);
 2171              		.loc 1 210 0
 2172 00c8 2B69     		ldr	r3, [r5, #16]
 2173 00ca 0093     		str	r3, [sp]
 2174 00cc 0122     		movs	r2, #1
 2175 00ce 3346     		mov	r3, r6
 2176 00d0 2046     		mov	r0, r4
 2177 00d2 FFF7FEFF 		bl	DSPI_MasterSetDelayTimes
 2178              	.LVL230:
 212:../drivers/fsl_dspi.c ****                              masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec);
 2179              		.loc 1 212 0
 2180 00d6 6B69     		ldr	r3, [r5, #20]
 2181 00d8 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 2182 00da 0093     		str	r3, [sp]
 2183 00dc 0222     		movs	r2, #2
 2184 00de 3346     		mov	r3, r6
 2185 00e0 2046     		mov	r0, r4
 2186 00e2 FFF7FEFF 		bl	DSPI_MasterSetDelayTimes
 2187              	.LVL231:
 214:../drivers/fsl_dspi.c ****                              masterConfig->ctarConfig.betweenTransferDelayInNanoSec);
 2188              		.loc 1 214 0
 2189 00e6 AB69     		ldr	r3, [r5, #24]
 2190 00e8 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 2191 00ea 0093     		str	r3, [sp]
 2192 00ec 0322     		movs	r2, #3
 2193 00ee 3346     		mov	r3, r6
 2194 00f0 2046     		mov	r0, r4
 2195 00f2 FFF7FEFF 		bl	DSPI_MasterSetDelayTimes
 2196              	.LVL232:
 217:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
 2197              		.loc 1 217 0
 2198 00f6 0021     		movs	r1, #0
 2199 00f8 2046     		mov	r0, r4
 2200 00fa FFF7FEFF 		bl	DSPI_SetDummyData
 2201              	.LVL233:
 2202              	.LBB409:
 2203              	.LBB410:
 742:../drivers/fsl_dspi.h **** }
 2204              		.loc 2 742 0
 2205 00fe 2368     		ldr	r3, [r4]
 2206 0100 23F00103 		bic	r3, r3, #1
 2207 0104 2360     		str	r3, [r4]
 2208              	.LVL234:
 2209              	.LBE410:
 2210              	.LBE409:
 219:../drivers/fsl_dspi.c **** 
 2211              		.loc 1 219 0
 2212 0106 02B0     		add	sp, sp, #8
 2213              		.cfi_def_cfa_offset 16
 2214              		@ sp needed
 2215 0108 70BD     		pop	{r4, r5, r6, pc}
 2216              	.LVL235:
 2217              	.L219:
 2218 010a 00BF     		.align	2
 2219              	.L218:
 2220 010c 00000000 		.word	.LANCHOR3
 2221              		.cfi_endproc
 2222              	.LFE169:
 2224              		.section	.text.DSPI_GetDefaultDataCommandConfig,"ax",%progbits
 2225              		.align	1
 2226              		.global	DSPI_GetDefaultDataCommandConfig
 2227              		.syntax unified
 2228              		.thumb
 2229              		.thumb_func
 2230              		.fpu fpv4-sp-d16
 2232              	DSPI_GetDefaultDataCommandConfig:
 2233              	.LFB178:
 490:../drivers/fsl_dspi.c ****     assert(command);
 2234              		.loc 1 490 0
 2235              		.cfi_startproc
 2236              		@ args = 0, pretend = 0, frame = 0
 2237              		@ frame_needed = 0, uses_anonymous_args = 0
 2238              		@ link register save eliminated.
 2239              	.LVL236:
 493:../drivers/fsl_dspi.c ****     command->whichCtar = kDSPI_Ctar0;
 2240              		.loc 1 493 0
 2241 0000 0023     		movs	r3, #0
 495:../drivers/fsl_dspi.c ****     command->isEndOfQueue = false;
 2242              		.loc 1 495 0
 2243 0002 0122     		movs	r2, #1
 493:../drivers/fsl_dspi.c ****     command->whichCtar = kDSPI_Ctar0;
 2244              		.loc 1 493 0
 2245 0004 0370     		strb	r3, [r0]
 494:../drivers/fsl_dspi.c ****     command->whichPcs = kDSPI_Pcs0;
 2246              		.loc 1 494 0
 2247 0006 4370     		strb	r3, [r0, #1]
 495:../drivers/fsl_dspi.c ****     command->isEndOfQueue = false;
 2248              		.loc 1 495 0
 2249 0008 8270     		strb	r2, [r0, #2]
 496:../drivers/fsl_dspi.c ****     command->clearTransferCount = false;
 2250              		.loc 1 496 0
 2251 000a C370     		strb	r3, [r0, #3]
 497:../drivers/fsl_dspi.c **** }
 2252              		.loc 1 497 0
 2253 000c 0371     		strb	r3, [r0, #4]
 498:../drivers/fsl_dspi.c **** 
 2254              		.loc 1 498 0
 2255 000e 7047     		bx	lr
 2256              		.cfi_endproc
 2257              	.LFE178:
 2259              		.section	.text.DSPI_MasterWriteDataBlocking,"ax",%progbits
 2260              		.align	1
 2261              		.global	DSPI_MasterWriteDataBlocking
 2262              		.syntax unified
 2263              		.thumb
 2264              		.thumb_func
 2265              		.fpu fpv4-sp-d16
 2267              	DSPI_MasterWriteDataBlocking:
 2268              	.LFB179:
 501:../drivers/fsl_dspi.c ****     assert(command);
 2269              		.loc 1 501 0
 2270              		.cfi_startproc
 2271              		@ args = 0, pretend = 0, frame = 0
 2272              		@ frame_needed = 0, uses_anonymous_args = 0
 2273              	.LVL237:
 2274              	.LBB411:
 2275              	.LBB412:
 580:../drivers/fsl_dspi.h **** }
 2276              		.loc 2 580 0
 2277 0000 4FF00043 		mov	r3, #-2147483648
 2278              	.LBE412:
 2279              	.LBE411:
 501:../drivers/fsl_dspi.c ****     assert(command);
 2280              		.loc 1 501 0
 2281 0004 10B5     		push	{r4, lr}
 2282              		.cfi_def_cfa_offset 8
 2283              		.cfi_offset 4, -8
 2284              		.cfi_offset 14, -4
 2285              	.LBB414:
 2286              	.LBB413:
 580:../drivers/fsl_dspi.h **** }
 2287              		.loc 2 580 0
 2288 0006 C362     		str	r3, [r0, #44]
 2289              	.LBE413:
 2290              	.LBE414:
 2291              	.LBB415:
 2292              	.LBB416:
 2293 0008 4FF00074 		mov	r4, #33554432
 2294              	.L222:
 2295              	.LVL238:
 2296              	.LBE416:
 2297              	.LBE415:
 2298              	.LBB418:
 2299              	.LBB419:
 561:../drivers/fsl_dspi.h **** }
 2300              		.loc 2 561 0
 2301 000c C36A     		ldr	r3, [r0, #44]
 2302              	.LVL239:
 2303              	.LBE419:
 2304              	.LBE418:
 507:../drivers/fsl_dspi.c ****     {
 2305              		.loc 1 507 0
 2306 000e 9B01     		lsls	r3, r3, #6
 2307 0010 1AD5     		bpl	.L223
 513:../drivers/fsl_dspi.c ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 2308              		.loc 1 513 0
 2309 0012 CB78     		ldrb	r3, [r1, #3]	@ zero_extendqisi2
 512:../drivers/fsl_dspi.c ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 2310              		.loc 1 512 0
 2311 0014 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
 513:../drivers/fsl_dspi.c ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 2312              		.loc 1 513 0
 2313 0016 DB06     		lsls	r3, r3, #27
 514:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 2314              		.loc 1 514 0
 2315 0018 43EAC473 		orr	r3, r3, r4, lsl #31
 2316 001c 1343     		orrs	r3, r3, r2
 2317 001e 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
 2318              	.LVL240:
 2319 0020 43EA8263 		orr	r3, r3, r2, lsl #26
 512:../drivers/fsl_dspi.c ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 2320              		.loc 1 512 0
 2321 0024 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 2322 0026 1207     		lsls	r2, r2, #28
 2323 0028 02F0E042 		and	r2, r2, #1879048192
 514:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 2324              		.loc 1 514 0
 2325 002c 1343     		orrs	r3, r3, r2
 513:../drivers/fsl_dspi.c ****                   SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
 2326              		.loc 1 513 0
 2327 002e 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 2328 0030 1204     		lsls	r2, r2, #16
 2329 0032 02F47C12 		and	r2, r2, #4128768
 514:../drivers/fsl_dspi.c ****     DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
 2330              		.loc 1 514 0
 2331 0036 1343     		orrs	r3, r3, r2
 512:../drivers/fsl_dspi.c ****                   SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
 2332              		.loc 1 512 0
 2333 0038 4363     		str	r3, [r0, #52]
 2334              	.LVL241:
 2335              	.LBB420:
 2336              	.LBB421:
 580:../drivers/fsl_dspi.h **** }
 2337              		.loc 2 580 0
 2338 003a 4FF00073 		mov	r3, #33554432
 2339 003e C362     		str	r3, [r0, #44]
 2340              	.L224:
 2341              	.LVL242:
 2342              	.LBE421:
 2343              	.LBE420:
 2344              	.LBB422:
 2345              	.LBB423:
 561:../drivers/fsl_dspi.h **** }
 2346              		.loc 2 561 0 discriminator 1
 2347 0040 C36A     		ldr	r3, [r0, #44]
 2348              	.LVL243:
 2349              	.LBE423:
 2350              	.LBE422:
 518:../drivers/fsl_dspi.c ****     {
 2351              		.loc 1 518 0 discriminator 1
 2352 0042 002B     		cmp	r3, #0
 2353 0044 FCDA     		bge	.L224
 521:../drivers/fsl_dspi.c **** 
 2354              		.loc 1 521 0
 2355 0046 10BD     		pop	{r4, pc}
 2356              	.LVL244:
 2357              	.L223:
 2358              	.LBB424:
 2359              	.LBB417:
 580:../drivers/fsl_dspi.h **** }
 2360              		.loc 2 580 0
 2361 0048 C462     		str	r4, [r0, #44]
 2362 004a DFE7     		b	.L222
 2363              	.LBE417:
 2364              	.LBE424:
 2365              		.cfi_endproc
 2366              	.LFE179:
 2368              		.section	.text.DSPI_MasterWriteCommandDataBlocking,"ax",%progbits
 2369              		.align	1
 2370              		.global	DSPI_MasterWriteCommandDataBlocking
 2371              		.syntax unified
 2372              		.thumb
 2373              		.thumb_func
 2374              		.fpu fpv4-sp-d16
 2376              	DSPI_MasterWriteCommandDataBlocking:
 2377              	.LFB180:
 524:../drivers/fsl_dspi.c ****     /* First, clear Transmit Complete Flag (TCF) */
 2378              		.loc 1 524 0
 2379              		.cfi_startproc
 2380              		@ args = 0, pretend = 0, frame = 0
 2381              		@ frame_needed = 0, uses_anonymous_args = 0
 2382              		@ link register save eliminated.
 2383              	.LVL245:
 2384              	.LBB425:
 2385              	.LBB426:
 580:../drivers/fsl_dspi.h **** }
 2386              		.loc 2 580 0
 2387 0000 4FF00043 		mov	r3, #-2147483648
 2388 0004 C362     		str	r3, [r0, #44]
 2389 0006 4FF00073 		mov	r3, #33554432
 2390              	.L227:
 2391              	.LVL246:
 2392              	.LBE426:
 2393              	.LBE425:
 2394              	.LBB427:
 2395              	.LBB428:
 561:../drivers/fsl_dspi.h **** }
 2396              		.loc 2 561 0
 2397 000a C26A     		ldr	r2, [r0, #44]
 2398              	.LVL247:
 2399              	.LBE428:
 2400              	.LBE427:
 528:../drivers/fsl_dspi.c ****     {
 2401              		.loc 1 528 0
 2402 000c 9201     		lsls	r2, r2, #6
 2403 000e 05D5     		bpl	.L228
 533:../drivers/fsl_dspi.c **** 
 2404              		.loc 1 533 0
 2405 0010 4163     		str	r1, [r0, #52]
 2406              	.LVL248:
 2407              	.LBB429:
 2408              	.LBB430:
 580:../drivers/fsl_dspi.h **** }
 2409              		.loc 2 580 0
 2410 0012 C362     		str	r3, [r0, #44]
 2411              	.L229:
 2412              	.LVL249:
 2413              	.LBE430:
 2414              	.LBE429:
 2415              	.LBB431:
 2416              	.LBB432:
 561:../drivers/fsl_dspi.h **** }
 2417              		.loc 2 561 0 discriminator 1
 2418 0014 C36A     		ldr	r3, [r0, #44]
 2419              	.LVL250:
 2420              	.LBE432:
 2421              	.LBE431:
 538:../drivers/fsl_dspi.c ****     {
 2422              		.loc 1 538 0 discriminator 1
 2423 0016 002B     		cmp	r3, #0
 2424 0018 FCDA     		bge	.L229
 541:../drivers/fsl_dspi.c **** 
 2425              		.loc 1 541 0
 2426 001a 7047     		bx	lr
 2427              	.LVL251:
 2428              	.L228:
 2429              	.LBB433:
 2430              	.LBB434:
 580:../drivers/fsl_dspi.h **** }
 2431              		.loc 2 580 0
 2432 001c C362     		str	r3, [r0, #44]
 2433 001e F4E7     		b	.L227
 2434              	.LBE434:
 2435              	.LBE433:
 2436              		.cfi_endproc
 2437              	.LFE180:
 2439              		.section	.text.DSPI_SlaveWriteDataBlocking,"ax",%progbits
 2440              		.align	1
 2441              		.global	DSPI_SlaveWriteDataBlocking
 2442              		.syntax unified
 2443              		.thumb
 2444              		.thumb_func
 2445              		.fpu fpv4-sp-d16
 2447              	DSPI_SlaveWriteDataBlocking:
 2448              	.LFB210:
 2449              		.cfi_startproc
 2450              		@ args = 0, pretend = 0, frame = 0
 2451              		@ frame_needed = 0, uses_anonymous_args = 0
 2452              		@ link register save eliminated.
 2453 0000 FFF7FEBF 		b	DSPI_MasterWriteCommandDataBlocking
 2454              		.cfi_endproc
 2455              	.LFE210:
 2457              		.section	.text.DSPI_EnableInterrupts,"ax",%progbits
 2458              		.align	1
 2459              		.global	DSPI_EnableInterrupts
 2460              		.syntax unified
 2461              		.thumb
 2462              		.thumb_func
 2463              		.fpu fpv4-sp-d16
 2465              	DSPI_EnableInterrupts:
 2466              	.LFB182:
 564:../drivers/fsl_dspi.c ****     if (mask & SPI_RSER_TFFF_RE_MASK)
 2467              		.loc 1 564 0
 2468              		.cfi_startproc
 2469              		@ args = 0, pretend = 0, frame = 0
 2470              		@ frame_needed = 0, uses_anonymous_args = 0
 2471              		@ link register save eliminated.
 2472              	.LVL252:
 565:../drivers/fsl_dspi.c ****     {
 2473              		.loc 1 565 0
 2474 0000 8A01     		lsls	r2, r1, #6
 567:../drivers/fsl_dspi.c ****     }
 2475              		.loc 1 567 0
 2476 0002 42BF     		ittt	mi
 2477 0004 036B     		ldrmi	r3, [r0, #48]
 2478 0006 23F08073 		bicmi	r3, r3, #16777216
 2479 000a 0363     		strmi	r3, [r0, #48]
 569:../drivers/fsl_dspi.c ****     {
 2480              		.loc 1 569 0
 2481 000c 8B03     		lsls	r3, r1, #14
 571:../drivers/fsl_dspi.c ****     }
 2482              		.loc 1 571 0
 2483 000e 42BF     		ittt	mi
 2484 0010 036B     		ldrmi	r3, [r0, #48]
 2485 0012 23F48033 		bicmi	r3, r3, #65536
 2486 0016 0363     		strmi	r3, [r0, #48]
 573:../drivers/fsl_dspi.c **** }
 2487              		.loc 1 573 0
 2488 0018 036B     		ldr	r3, [r0, #48]
 2489 001a 1943     		orrs	r1, r1, r3
 2490              	.LVL253:
 2491 001c 0163     		str	r1, [r0, #48]
 574:../drivers/fsl_dspi.c **** 
 2492              		.loc 1 574 0
 2493 001e 7047     		bx	lr
 2494              		.cfi_endproc
 2495              	.LFE182:
 2497              		.section	.text.DSPI_MasterTransferCreateHandle,"ax",%progbits
 2498              		.align	1
 2499              		.global	DSPI_MasterTransferCreateHandle
 2500              		.syntax unified
 2501              		.thumb
 2502              		.thumb_func
 2503              		.fpu fpv4-sp-d16
 2505              	DSPI_MasterTransferCreateHandle:
 2506              	.LFB183:
 582:../drivers/fsl_dspi.c ****     assert(handle);
 2507              		.loc 1 582 0
 2508              		.cfi_startproc
 2509              		@ args = 0, pretend = 0, frame = 0
 2510              		@ frame_needed = 0, uses_anonymous_args = 0
 2511              	.LVL254:
 2512 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2513              		.cfi_def_cfa_offset 24
 2514              		.cfi_offset 3, -24
 2515              		.cfi_offset 4, -20
 2516              		.cfi_offset 5, -16
 2517              		.cfi_offset 6, -12
 2518              		.cfi_offset 7, -8
 2519              		.cfi_offset 14, -4
 582:../drivers/fsl_dspi.c ****     assert(handle);
 2520              		.loc 1 582 0
 2521 0002 0C46     		mov	r4, r1
 2522 0004 0746     		mov	r7, r0
 2523 0006 1646     		mov	r6, r2
 586:../drivers/fsl_dspi.c **** 
 2524              		.loc 1 586 0
 2525 0008 0021     		movs	r1, #0
 2526              	.LVL255:
 2527 000a 2822     		movs	r2, #40
 2528              	.LVL256:
 2529 000c 2046     		mov	r0, r4
 2530              	.LVL257:
 582:../drivers/fsl_dspi.c ****     assert(handle);
 2531              		.loc 1 582 0
 2532 000e 1D46     		mov	r5, r3
 586:../drivers/fsl_dspi.c **** 
 2533              		.loc 1 586 0
 2534 0010 FFF7FEFF 		bl	memset
 2535              	.LVL258:
 588:../drivers/fsl_dspi.c **** 
 2536              		.loc 1 588 0
 2537 0014 3846     		mov	r0, r7
 2538 0016 FFF7FEFF 		bl	DSPI_GetInstance
 2539              	.LVL259:
 2540 001a 034B     		ldr	r3, .L242
 591:../drivers/fsl_dspi.c **** }
 2541              		.loc 1 591 0
 2542 001c C4E90A65 		strd	r6, r5, [r4, #40]
 588:../drivers/fsl_dspi.c **** 
 2543              		.loc 1 588 0
 2544 0020 43F82040 		str	r4, [r3, r0, lsl #2]
 592:../drivers/fsl_dspi.c **** 
 2545              		.loc 1 592 0
 2546 0024 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2547              	.LVL260:
 2548              	.L243:
 2549 0026 00BF     		.align	2
 2550              	.L242:
 2551 0028 00000000 		.word	.LANCHOR8
 2552              		.cfi_endproc
 2553              	.LFE183:
 2555              		.section	.text.DSPI_MasterTransferBlocking,"ax",%progbits
 2556              		.align	1
 2557              		.global	DSPI_MasterTransferBlocking
 2558              		.syntax unified
 2559              		.thumb
 2560              		.thumb_func
 2561              		.fpu fpv4-sp-d16
 2563              	DSPI_MasterTransferBlocking:
 2564              	.LFB184:
 595:../drivers/fsl_dspi.c ****     assert(transfer);
 2565              		.loc 1 595 0
 2566              		.cfi_startproc
 2567              		@ args = 0, pretend = 0, frame = 8
 2568              		@ frame_needed = 0, uses_anonymous_args = 0
 2569              	.LVL261:
 2570 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2571              		.cfi_def_cfa_offset 48
 2572              		.cfi_offset 4, -36
 2573              		.cfi_offset 5, -32
 2574              		.cfi_offset 6, -28
 2575              		.cfi_offset 7, -24
 2576              		.cfi_offset 8, -20
 2577              		.cfi_offset 9, -16
 2578              		.cfi_offset 10, -12
 2579              		.cfi_offset 11, -8
 2580              		.cfi_offset 14, -4
 595:../drivers/fsl_dspi.c ****     assert(transfer);
 2581              		.loc 1 595 0
 2582 0004 0446     		mov	r4, r0
 2583 0006 0F46     		mov	r7, r1
 600:../drivers/fsl_dspi.c ****     uint8_t bitsPerFrame;
 2584              		.loc 1 600 0
 2585 0008 FFF7FEFF 		bl	DSPI_GetInstance
 2586              	.LVL262:
 2587 000c 954B     		ldr	r3, .L316
 2588 000e 1E5C     		ldrb	r6, [r3, r0]	@ zero_extendqisi2
 615:../drivers/fsl_dspi.c ****     {
 2589              		.loc 1 615 0
 2590 0010 8B68     		ldr	r3, [r1, #8]
 600:../drivers/fsl_dspi.c ****     uint8_t bitsPerFrame;
 2591              		.loc 1 600 0
 2592 0012 F6B2     		uxtb	r6, r6
 2593              	.LVL263:
 615:../drivers/fsl_dspi.c ****     {
 2594              		.loc 1 615 0
 2595 0014 002B     		cmp	r3, #0
 2596 0016 00F02381 		beq	.L291
 2597              	.LVL264:
 2598              	.LBB435:
 2599              	.LBB436:
 753:../drivers/fsl_dspi.h **** }
 2600              		.loc 2 753 0
 2601 001a 2368     		ldr	r3, [r4]
 2602              	.LBE436:
 2603              	.LBE435:
 627:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 2604              		.loc 1 627 0
 2605 001c D1F80C90 		ldr	r9, [r1, #12]
 2606              	.LBB438:
 2607              	.LBB437:
 753:../drivers/fsl_dspi.h **** }
 2608              		.loc 2 753 0
 2609 0020 43F00103 		orr	r3, r3, #1
 2610 0024 2360     		str	r3, [r4]
 2611              	.LVL265:
 2612              	.LBE437:
 2613              	.LBE438:
 2614              	.LBB439:
 2615              	.LBB440:
 620:../drivers/fsl_dspi.h **** }
 2616              		.loc 2 620 0
 2617 0026 236B     		ldr	r3, [r4, #48]
 2618 0028 23F01A43 		bic	r3, r3, #-1711276032
 2619 002c 23F42023 		bic	r3, r3, #655360
 2620 0030 2363     		str	r3, [r4, #48]
 2621              	.LVL266:
 2622              	.LBE440:
 2623              	.LBE439:
 2624              	.LBB441:
 2625              	.LBB442:
 782:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 2626              		.loc 2 782 0
 2627 0032 2368     		ldr	r3, [r4]
 2628 0034 43F44063 		orr	r3, r3, #3072
 2629 0038 2360     		str	r3, [r4]
 2630              	.LVL267:
 2631              	.LBE442:
 2632              	.LBE441:
 2633              	.LBB443:
 2634              	.LBB444:
 580:../drivers/fsl_dspi.h **** }
 2635              		.loc 2 580 0
 2636 003a 8B4B     		ldr	r3, .L316+4
 2637 003c E362     		str	r3, [r4, #44]
 2638              	.LVL268:
 2639              	.LBE444:
 2640              	.LBE443:
 627:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 2641              		.loc 1 627 0
 2642 003e 0121     		movs	r1, #1
 2643              	.LVL269:
 2644 0040 C9F30313 		ubfx	r3, r9, #4, #4
 2645 0044 01FA03F3 		lsl	r3, r1, r3
 632:../drivers/fsl_dspi.c **** 
 2646              		.loc 1 632 0
 2647 0048 0DF1080A 		add	r10, sp, #8
 627:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 2648              		.loc 1 627 0
 2649 004c 8DF80230 		strb	r3, [sp, #2]
 628:../drivers/fsl_dspi.c ****     commandStruct.clearTransferCount = false;
 2650              		.loc 1 628 0
 2651 0050 0023     		movs	r3, #0
 2652 0052 8DF80330 		strb	r3, [sp, #3]
 629:../drivers/fsl_dspi.c ****     commandStruct.whichCtar =
 2653              		.loc 1 629 0
 2654 0056 8DF80430 		strb	r3, [sp, #4]
 632:../drivers/fsl_dspi.c **** 
 2655              		.loc 1 632 0
 2656 005a C9F30053 		ubfx	r3, r9, #20, #1
 2657 005e 0AF8083D 		strb	r3, [r10, #-8]!
 631:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 2658              		.loc 1 631 0
 2659 0062 09F00F05 		and	r5, r9, #15
 634:../drivers/fsl_dspi.c **** 
 2660              		.loc 1 634 0
 2661 0066 5046     		mov	r0, r10
 630:../drivers/fsl_dspi.c ****         (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR
 2662              		.loc 1 630 0
 2663 0068 8DF80150 		strb	r5, [sp, #1]
 634:../drivers/fsl_dspi.c **** 
 2664              		.loc 1 634 0
 2665 006c FFF7FEFF 		bl	DSPI_MasterGetFormattedCommand.constprop.4
 2666              	.LVL270:
 637:../drivers/fsl_dspi.c ****     lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 2667              		.loc 1 637 0
 2668 0070 C9F34059 		ubfx	r9, r9, #21, #1
 634:../drivers/fsl_dspi.c **** 
 2669              		.loc 1 634 0
 2670 0074 8046     		mov	r8, r0
 2671              	.LVL271:
 638:../drivers/fsl_dspi.c **** 
 2672              		.loc 1 638 0
 2673 0076 5046     		mov	r0, r10
 2674              	.LVL272:
 636:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer)
 2675              		.loc 1 636 0
 2676 0078 8DF80310 		strb	r1, [sp, #3]
 637:../drivers/fsl_dspi.c ****     lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 2677              		.loc 1 637 0
 2678 007c 8DF80090 		strb	r9, [sp]
 641:../drivers/fsl_dspi.c **** 
 2679              		.loc 1 641 0
 2680 0080 0235     		adds	r5, r5, #2
 638:../drivers/fsl_dspi.c **** 
 2681              		.loc 1 638 0
 2682 0082 FFF7FEFF 		bl	DSPI_MasterGetFormattedCommand.constprop.4
 2683              	.LVL273:
 641:../drivers/fsl_dspi.c **** 
 2684              		.loc 1 641 0
 2685 0086 04EB8505 		add	r5, r4, r5, lsl #2
 638:../drivers/fsl_dspi.c **** 
 2686              		.loc 1 638 0
 2687 008a 8646     		mov	lr, r0
 2688              	.LVL274:
 644:../drivers/fsl_dspi.c ****     remainingSendByteCount = transfer->dataSize;
 2689              		.loc 1 644 0
 2690 008c D7E90023 		ldrd	r2, r3, [r7]
 641:../drivers/fsl_dspi.c **** 
 2691              		.loc 1 641 0
 2692 0090 6868     		ldr	r0, [r5, #4]
 2693              	.LVL275:
 645:../drivers/fsl_dspi.c ****     remainingReceiveByteCount = transfer->dataSize;
 2694              		.loc 1 645 0
 2695 0092 BD68     		ldr	r5, [r7, #8]
 646:../drivers/fsl_dspi.c **** 
 2696              		.loc 1 646 0
 2697 0094 BF68     		ldr	r7, [r7, #8]
 2698              	.LVL276:
 648:../drivers/fsl_dspi.c ****     {
 2699              		.loc 1 648 0
 2700 0096 D4F800C0 		ldr	ip, [r4]
 641:../drivers/fsl_dspi.c **** 
 2701              		.loc 1 641 0
 2702 009a C0F3C360 		ubfx	r0, r0, #27, #4
 648:../drivers/fsl_dspi.c ****     {
 2703              		.loc 1 648 0
 2704 009e 1CF4805F 		tst	ip, #4096
 641:../drivers/fsl_dspi.c **** 
 2705              		.loc 1 641 0
 2706 00a2 00F10100 		add	r0, r0, #1
 2707              	.LVL277:
 648:../drivers/fsl_dspi.c ****     {
 2708              		.loc 1 648 0
 2709 00a6 12D1     		bne	.L246
 648:../drivers/fsl_dspi.c ****     {
 2710              		.loc 1 648 0 is_stmt 0 discriminator 1
 2711 00a8 D4F800C0 		ldr	ip, [r4]
 2712 00ac 1CF4005F 		tst	ip, #8192
 2713 00b0 0DD1     		bne	.L246
 654:../drivers/fsl_dspi.c ****     }
 2714              		.loc 1 654 0 is_stmt 1
 2715 00b2 DFF8BCC1 		ldr	ip, .L316+12
 2716 00b6 6445     		cmp	r4, ip
 2717 00b8 1ED0     		beq	.L294
 654:../drivers/fsl_dspi.c ****     }
 2718              		.loc 1 654 0 is_stmt 0 discriminator 1
 2719 00ba 0CF5805C 		add	ip, ip, #4096
 2720 00be 6445     		cmp	r4, ip
 2721 00c0 05D0     		beq	.L246
 654:../drivers/fsl_dspi.c ****     }
 2722              		.loc 1 654 0 discriminator 3
 2723 00c2 6A49     		ldr	r1, .L316+8
 2724 00c4 8C42     		cmp	r4, r1
 2725 00c6 14BF     		ite	ne
 2726 00c8 4FF0FF31 		movne	r1, #-1
 2727 00cc 0121     		moveq	r1, #1
 2728              	.L246:
 2729              	.LVL278:
 2730              	.LBB445:
 2731              	.LBB446:
 742:../drivers/fsl_dspi.h **** }
 2732              		.loc 2 742 0 is_stmt 1
 2733 00ce D4F800C0 		ldr	ip, [r4]
 2734              	.LBE446:
 2735              	.LBE445:
 659:../drivers/fsl_dspi.c ****     {
 2736              		.loc 1 659 0
 2737 00d2 0828     		cmp	r0, #8
 2738              	.LBB448:
 2739              	.LBB447:
 742:../drivers/fsl_dspi.h **** }
 2740              		.loc 2 742 0
 2741 00d4 2CF0010C 		bic	ip, ip, #1
 2742 00d8 C4F800C0 		str	ip, [r4]
 2743              	.LVL279:
 2744              	.LBE447:
 2745              	.LBE448:
 659:../drivers/fsl_dspi.c ****     {
 2746              		.loc 1 659 0
 2747 00dc 0ED8     		bhi	.L315
 716:../drivers/fsl_dspi.c ****                 }
 2748              		.loc 1 716 0
 2749 00de 46EA080A 		orr	r10, r6, r8
 2750              	.LBB449:
 2751              	.LBB450:
 580:../drivers/fsl_dspi.h **** }
 2752              		.loc 2 580 0
 2753 00e2 4FF0007C 		mov	ip, #33554432
 2754              	.LBE450:
 2755              	.LBE449:
 2756              	.LBB452:
 2757              	.LBB453:
 2758 00e6 4FF40039 		mov	r9, #131072
 2759              	.LBE453:
 2760              	.LBE452:
 677:../drivers/fsl_dspi.c ****                 }
 2761              		.loc 1 677 0
 2762 00ea 46EA0E06 		orr	r6, r6, lr
 2763              	.LVL280:
 2764              	.L247:
 661:../drivers/fsl_dspi.c ****         {
 2765              		.loc 1 661 0
 2766 00ee BDBB     		cbnz	r5, .L268
 2767              	.LVL281:
 2768              	.L290:
 851:../drivers/fsl_dspi.c **** }
 2769              		.loc 1 851 0
 2770 00f0 0020     		movs	r0, #0
 2771              	.LVL282:
 2772              	.L244:
 852:../drivers/fsl_dspi.c **** 
 2773              		.loc 1 852 0
 2774 00f2 03B0     		add	sp, sp, #12
 2775              		.cfi_remember_state
 2776              		.cfi_def_cfa_offset 36
 2777              		@ sp needed
 2778 00f4 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2779              	.LVL283:
 2780              	.L294:
 2781              		.cfi_restore_state
 654:../drivers/fsl_dspi.c ****     }
 2782              		.loc 1 654 0
 2783 00f8 0421     		movs	r1, #4
 2784 00fa E8E7     		b	.L246
 2785              	.LVL284:
 2786              	.L315:
 2787              	.LBB455:
 2788              	.LBB456:
 580:../drivers/fsl_dspi.h **** }
 2789              		.loc 2 580 0
 2790 00fc 4FF00070 		mov	r0, #33554432
 2791              	.LVL285:
 2792              	.LBE456:
 2793              	.LBE455:
 2794              	.LBB458:
 2795              	.LBB459:
 2796 0100 4FF40039 		mov	r9, #131072
 2797              	.LBE459:
 2798              	.LBE458:
 767:../drivers/fsl_dspi.c ****                 }
 2799              		.loc 1 767 0
 2800 0104 B6B2     		uxth	r6, r6
 2801              	.LVL286:
 2802              	.L248:
 745:../drivers/fsl_dspi.c ****         {
 2803              		.loc 1 745 0
 2804 0106 002D     		cmp	r5, #0
 2805 0108 F2D0     		beq	.L290
 747:../drivers/fsl_dspi.c ****             {
 2806              		.loc 1 747 0
 2807 010a 022D     		cmp	r5, #2
 2808 010c 6ED9     		bls	.L269
 2809              	.L270:
 2810              	.LVL287:
 2811              	.LBB461:
 2812              	.LBB462:
 561:../drivers/fsl_dspi.h **** }
 2813              		.loc 2 561 0
 2814 010e D4F82CC0 		ldr	ip, [r4, #44]
 2815              	.LVL288:
 2816              	.LBE462:
 2817              	.LBE461:
 808:../drivers/fsl_dspi.c ****                 {
 2818              		.loc 1 808 0
 2819 0112 1CF0007F 		tst	ip, #33554432
 2820 0116 00F09F80 		beq	.L282
 813:../drivers/fsl_dspi.c ****                 {
 2821              		.loc 1 813 0
 2822 011a 002A     		cmp	r2, #0
 2823 011c 00F09E80 		beq	.L283
 2824              	.LVL289:
 817:../drivers/fsl_dspi.c ****                     ++txData;
 2825              		.loc 1 817 0
 2826 0120 32F802CB 		ldrh	ip, [r2], #2	@ unaligned
 2827              	.LVL290:
 2828              	.L284:
 824:../drivers/fsl_dspi.c ****                 remainingSendByteCount -= 2;
 2829              		.loc 1 824 0
 2830 0124 4CEA080C 		orr	ip, ip, r8
 2831              	.LVL291:
 2832 0128 C4F834C0 		str	ip, [r4, #52]
 829:../drivers/fsl_dspi.c ****                 {
 2833              		.loc 1 829 0
 2834 012c C5F1020A 		rsb	r10, r5, #2
 825:../drivers/fsl_dspi.c **** 
 2835              		.loc 1 825 0
 2836 0130 A5F1020C 		sub	ip, r5, #2
 2837              	.LVL292:
 2838              	.LBB463:
 2839              	.LBB464:
 580:../drivers/fsl_dspi.h **** }
 2840              		.loc 2 580 0
 2841 0134 E062     		str	r0, [r4, #44]
 2842              	.L285:
 2843              	.LBE464:
 2844              	.LBE463:
 829:../drivers/fsl_dspi.c ****                 {
 2845              		.loc 1 829 0
 2846 0136 0AEB0705 		add	r5, r10, r7
 2847 013a 6D08     		lsrs	r5, r5, #1
 2848              	.LVL293:
 2849              	.L286:
 2850 013c 8D42     		cmp	r5, r1
 2851 013e 6DD3     		bcc	.L281
 2852              	.LVL294:
 2853              	.LBB465:
 2854              	.LBB466:
 561:../drivers/fsl_dspi.h **** }
 2855              		.loc 2 561 0
 2856 0140 D4F82CB0 		ldr	fp, [r4, #44]
 2857              	.LVL295:
 2858              	.LBE466:
 2859              	.LBE465:
 831:../drivers/fsl_dspi.c ****                     {
 2860              		.loc 1 831 0
 2861 0144 1BF4003F 		tst	fp, #131072
 2862 0148 F8D0     		beq	.L286
 2863              	.LVL296:
 2864              	.LBB467:
 2865              	.LBB468:
 2866              		.loc 2 1044 0
 2867 014a A56B     		ldr	r5, [r4, #56]
 2868              	.LVL297:
 2869              	.LBE468:
 2870              	.LBE467:
 835:../drivers/fsl_dspi.c ****                         {
 2871              		.loc 1 835 0
 2872 014c 23B1     		cbz	r3, .L287
 837:../drivers/fsl_dspi.c ****                             ++rxData;
 2873              		.loc 1 837 0
 2874 014e 1D70     		strb	r5, [r3]
 2875              	.LVL298:
 839:../drivers/fsl_dspi.c ****                             ++rxData;
 2876              		.loc 1 839 0
 2877 0150 C5F30725 		ubfx	r5, r5, #8, #8
 2878              	.LVL299:
 2879 0154 5D70     		strb	r5, [r3, #1]
 840:../drivers/fsl_dspi.c ****                         }
 2880              		.loc 1 840 0
 2881 0156 0233     		adds	r3, r3, #2
 2882              	.LVL300:
 2883              	.L287:
 842:../drivers/fsl_dspi.c **** 
 2884              		.loc 1 842 0
 2885 0158 023F     		subs	r7, r7, #2
 2886              	.LVL301:
 2887              	.LBB469:
 2888              	.LBB470:
 580:../drivers/fsl_dspi.h **** }
 2889              		.loc 2 580 0
 2890 015a C4F82C90 		str	r9, [r4, #44]
 2891 015e EAE7     		b	.L285
 2892              	.LVL302:
 2893              	.L268:
 2894              	.LBE470:
 2895              	.LBE469:
 663:../drivers/fsl_dspi.c ****             {
 2896              		.loc 1 663 0
 2897 0160 012D     		cmp	r5, #1
 2898 0162 21D1     		bne	.L250
 2899              	.L249:
 2900              	.LVL303:
 2901              	.LBB471:
 2902              	.LBB472:
 561:../drivers/fsl_dspi.h **** }
 2903              		.loc 2 561 0
 2904 0164 E06A     		ldr	r0, [r4, #44]
 2905              	.LVL304:
 2906              	.LBE472:
 2907              	.LBE471:
 665:../drivers/fsl_dspi.c ****                 {
 2908              		.loc 1 665 0
 2909 0166 8001     		lsls	r0, r0, #6
 2910 0168 0CD5     		bpl	.L251
 670:../drivers/fsl_dspi.c ****                 {
 2911              		.loc 1 670 0
 2912 016a 72B1     		cbz	r2, .L252
 672:../drivers/fsl_dspi.c ****                     txData++;
 2913              		.loc 1 672 0
 2914 016c 12F8010B 		ldrb	r0, [r2], #1	@ zero_extendqisi2
 2915              	.LVL305:
 2916 0170 40EA0E00 		orr	r0, r0, lr
 2917 0174 6063     		str	r0, [r4, #52]
 2918              	.LVL306:
 2919              	.L253:
 2920              	.LBB473:
 2921              	.LBB474:
 580:../drivers/fsl_dspi.h **** }
 2922              		.loc 2 580 0
 2923 0176 C4F82CC0 		str	ip, [r4, #44]
 2924              	.LVL307:
 2925              	.LBE474:
 2926              	.LBE473:
 682:../drivers/fsl_dspi.c ****                 {
 2927              		.loc 1 682 0
 2928 017a 3846     		mov	r0, r7
 2929              	.LVL308:
 2930              	.L255:
 2931 017c 38B9     		cbnz	r0, .L258
 2932 017e 0746     		mov	r7, r0
 2933              	.LVL309:
 2934              	.L259:
 2935 0180 0546     		mov	r5, r0
 2936 0182 B4E7     		b	.L247
 2937              	.LVL310:
 2938              	.L251:
 2939              	.LBB475:
 2940              	.LBB476:
 580:../drivers/fsl_dspi.h **** }
 2941              		.loc 2 580 0
 2942 0184 C4F82CC0 		str	ip, [r4, #44]
 2943 0188 ECE7     		b	.L249
 2944              	.LVL311:
 2945              	.L252:
 2946              	.LBE476:
 2947              	.LBE475:
 677:../drivers/fsl_dspi.c ****                 }
 2948              		.loc 1 677 0
 2949 018a 6663     		str	r6, [r4, #52]
 2950 018c F3E7     		b	.L253
 2951              	.LVL312:
 2952              	.L258:
 2953              	.LBB477:
 2954              	.LBB478:
 561:../drivers/fsl_dspi.h **** }
 2955              		.loc 2 561 0
 2956 018e E56A     		ldr	r5, [r4, #44]
 2957              	.LVL313:
 2958              	.LBE478:
 2959              	.LBE477:
 684:../drivers/fsl_dspi.c ****                     {
 2960              		.loc 1 684 0
 2961 0190 AD03     		lsls	r5, r5, #14
 2962 0192 F3D5     		bpl	.L255
 2963              	.LBB479:
 2964              	.LBB480:
 2965              		.loc 2 1044 0
 2966 0194 A56B     		ldr	r5, [r4, #56]
 2967              	.LBE480:
 2968              	.LBE479:
 686:../drivers/fsl_dspi.c ****                         {
 2969              		.loc 1 686 0
 2970 0196 0BB1     		cbz	r3, .L257
 2971              	.LVL314:
 689:../drivers/fsl_dspi.c ****                             rxData++;
 2972              		.loc 1 689 0
 2973 0198 03F8015B 		strb	r5, [r3], #1
 2974              	.LVL315:
 2975              	.L257:
 696:../drivers/fsl_dspi.c **** 
 2976              		.loc 1 696 0
 2977 019c 0138     		subs	r0, r0, #1
 2978              	.LVL316:
 2979              	.LBB481:
 2980              	.LBB482:
 580:../drivers/fsl_dspi.h **** }
 2981              		.loc 2 580 0
 2982 019e C4F82C90 		str	r9, [r4, #44]
 2983 01a2 EBE7     		b	.L255
 2984              	.LVL317:
 2985              	.L260:
 2986              	.LBE482:
 2987              	.LBE481:
 2988              	.LBB483:
 2989              	.LBB451:
 2990 01a4 C4F82CC0 		str	ip, [r4, #44]
 2991              	.LVL318:
 2992              	.L250:
 2993              	.LBE451:
 2994              	.LBE483:
 2995              	.LBB484:
 2996              	.LBB485:
 561:../drivers/fsl_dspi.h **** }
 2997              		.loc 2 561 0
 2998 01a8 E06A     		ldr	r0, [r4, #44]
 2999              	.LVL319:
 3000              	.LBE485:
 3001              	.LBE484:
 705:../drivers/fsl_dspi.c ****                 {
 3002              		.loc 1 705 0
 3003 01aa 8001     		lsls	r0, r0, #6
 3004 01ac FAD5     		bpl	.L260
 709:../drivers/fsl_dspi.c ****                 {
 3005              		.loc 1 709 0
 3006 01ae CAB1     		cbz	r2, .L261
 711:../drivers/fsl_dspi.c ****                     txData++;
 3007              		.loc 1 711 0
 3008 01b0 12F8010B 		ldrb	r0, [r2], #1	@ zero_extendqisi2
 3009              	.LVL320:
 3010 01b4 40EA0800 		orr	r0, r0, r8
 3011 01b8 6063     		str	r0, [r4, #52]
 3012              	.LVL321:
 3013              	.L262:
 3014 01ba 0137     		adds	r7, r7, #1
 3015              	.LVL322:
 718:../drivers/fsl_dspi.c **** 
 3016              		.loc 1 718 0
 3017 01bc 681E     		subs	r0, r5, #1
 3018              	.LVL323:
 3019              	.LBB486:
 3020              	.LBB487:
 580:../drivers/fsl_dspi.h **** }
 3021              		.loc 2 580 0
 3022 01be C4F82CC0 		str	ip, [r4, #44]
 3023 01c2 7D1B     		subs	r5, r7, r5
 3024              	.LVL324:
 3025              	.L263:
 3026 01c4 2F18     		adds	r7, r5, r0
 3027              	.LVL325:
 3028              	.L264:
 3029              	.LBE487:
 3030              	.LBE486:
 722:../drivers/fsl_dspi.c ****                 {
 3031              		.loc 1 722 0
 3032 01c6 8D42     		cmp	r5, r1
 3033 01c8 DAD3     		bcc	.L259
 3034              	.LVL326:
 3035              	.LBB488:
 3036              	.LBB489:
 561:../drivers/fsl_dspi.h **** }
 3037              		.loc 2 561 0
 3038 01ca D4F82CB0 		ldr	fp, [r4, #44]
 3039              	.LVL327:
 3040              	.LBE489:
 3041              	.LBE488:
 724:../drivers/fsl_dspi.c ****                     {
 3042              		.loc 1 724 0
 3043 01ce 1BF4003F 		tst	fp, #131072
 3044 01d2 F8D0     		beq	.L264
 3045              	.LBB490:
 3046              	.LBB491:
 3047              		.loc 2 1044 0
 3048 01d4 A76B     		ldr	r7, [r4, #56]
 3049              	.LBE491:
 3050              	.LBE490:
 726:../drivers/fsl_dspi.c ****                         {
 3051              		.loc 1 726 0
 3052 01d6 0BB1     		cbz	r3, .L266
 3053              	.LVL328:
 728:../drivers/fsl_dspi.c ****                             rxData++;
 3054              		.loc 1 728 0
 3055 01d8 03F8017B 		strb	r7, [r3], #1
 3056              	.LVL329:
 3057              	.L266:
 3058              	.LBB492:
 3059              	.LBB454:
 580:../drivers/fsl_dspi.h **** }
 3060              		.loc 2 580 0
 3061 01dc C4F82C90 		str	r9, [r4, #44]
 3062 01e0 013D     		subs	r5, r5, #1
 3063 01e2 EFE7     		b	.L263
 3064              	.LVL330:
 3065              	.L261:
 3066              	.LBE454:
 3067              	.LBE492:
 716:../drivers/fsl_dspi.c ****                 }
 3068              		.loc 1 716 0
 3069 01e4 C4F834A0 		str	r10, [r4, #52]
 3070 01e8 E7E7     		b	.L262
 3071              	.LVL331:
 3072              	.L271:
 3073              	.LBB493:
 3074              	.LBB457:
 580:../drivers/fsl_dspi.h **** }
 3075              		.loc 2 580 0
 3076 01ea E062     		str	r0, [r4, #44]
 3077              	.LVL332:
 3078              	.L269:
 3079              	.LBE457:
 3080              	.LBE493:
 3081              	.LBB494:
 3082              	.LBB495:
 561:../drivers/fsl_dspi.h **** }
 3083              		.loc 2 561 0
 3084 01ec D4F82CC0 		ldr	ip, [r4, #44]
 3085              	.LVL333:
 3086              	.LBE495:
 3087              	.LBE494:
 749:../drivers/fsl_dspi.c ****                 {
 3088              		.loc 1 749 0
 3089 01f0 1CF0007F 		tst	ip, #33554432
 3090 01f4 F9D0     		beq	.L271
 754:../drivers/fsl_dspi.c ****                 {
 3091              		.loc 1 754 0
 3092 01f6 9AB1     		cbz	r2, .L272
 756:../drivers/fsl_dspi.c ****                     ++txData;
 3093              		.loc 1 756 0
 3094 01f8 92F800C0 		ldrb	ip, [r2]	@ zero_extendqisi2
 3095              	.LVL334:
 759:../drivers/fsl_dspi.c ****                     {
 3096              		.loc 1 759 0
 3097 01fc 022D     		cmp	r5, #2
 761:../drivers/fsl_dspi.c ****                         ++txData;
 3098              		.loc 1 761 0
 3099 01fe 0EBF     		itee	eq
 3100 0200 32F8025B 		ldrheq	r5, [r2], #2	@ unaligned
 3101              	.LVL335:
 756:../drivers/fsl_dspi.c ****                     ++txData;
 3102              		.loc 1 756 0
 3103 0204 1FFA8CF5 		uxthne	r5, ip
 757:../drivers/fsl_dspi.c **** 
 3104              		.loc 1 757 0
 3105 0208 0132     		addne	r2, r2, #1
 3106              	.LVL336:
 3107              	.L274:
 770:../drivers/fsl_dspi.c **** 
 3108              		.loc 1 770 0
 3109 020a 45EA0E05 		orr	r5, r5, lr
 3110              	.LVL337:
 3111 020e 6563     		str	r5, [r4, #52]
 3112              	.LVL338:
 775:../drivers/fsl_dspi.c ****                 {
 3113              		.loc 1 775 0
 3114 0210 BC46     		mov	ip, r7
 3115              	.LBB496:
 3116              	.LBB497:
 580:../drivers/fsl_dspi.h **** }
 3117              		.loc 2 580 0
 3118 0212 E062     		str	r0, [r4, #44]
 3119              	.LVL339:
 3120              	.L276:
 3121              	.LBE497:
 3122              	.LBE496:
 775:../drivers/fsl_dspi.c ****                 {
 3123              		.loc 1 775 0
 3124 0214 BCF1000F 		cmp	ip, #0
 3125 0218 04D1     		bne	.L280
 3126 021a 6746     		mov	r7, ip
 3127              	.LVL340:
 3128              	.L281:
 3129 021c 6546     		mov	r5, ip
 3130 021e 72E7     		b	.L248
 3131              	.LVL341:
 3132              	.L272:
 767:../drivers/fsl_dspi.c ****                 }
 3133              		.loc 1 767 0
 3134 0220 3546     		mov	r5, r6
 3135              	.LVL342:
 3136 0222 F2E7     		b	.L274
 3137              	.LVL343:
 3138              	.L280:
 3139              	.LBB498:
 3140              	.LBB499:
 561:../drivers/fsl_dspi.h **** }
 3141              		.loc 2 561 0
 3142 0224 E56A     		ldr	r5, [r4, #44]
 3143              	.LVL344:
 3144              	.LBE499:
 3145              	.LBE498:
 777:../drivers/fsl_dspi.c ****                     {
 3146              		.loc 1 777 0
 3147 0226 AD03     		lsls	r5, r5, #14
 3148 0228 F4D5     		bpl	.L276
 3149              	.LVL345:
 781:../drivers/fsl_dspi.c ****                         {
 3150              		.loc 1 781 0
 3151 022a BCF1010F 		cmp	ip, #1
 3152              	.LBB500:
 3153              	.LBB501:
 3154              		.loc 2 1044 0
 3155 022e A56B     		ldr	r5, [r4, #56]
 3156              	.LVL346:
 3157              	.LBE501:
 3158              	.LBE500:
 781:../drivers/fsl_dspi.c ****                         {
 3159              		.loc 1 781 0
 3160 0230 0AD0     		beq	.L277
 783:../drivers/fsl_dspi.c ****                             {
 3161              		.loc 1 783 0
 3162 0232 23B1     		cbz	r3, .L278
 785:../drivers/fsl_dspi.c ****                                 ++rxData;
 3163              		.loc 1 785 0
 3164 0234 1D70     		strb	r5, [r3]
 3165              	.LVL347:
 787:../drivers/fsl_dspi.c ****                                 ++rxData;
 3166              		.loc 1 787 0
 3167 0236 C5F30725 		ubfx	r5, r5, #8, #8
 3168              	.LVL348:
 3169 023a 5D70     		strb	r5, [r3, #1]
 788:../drivers/fsl_dspi.c ****                             }
 3170              		.loc 1 788 0
 3171 023c 0233     		adds	r3, r3, #2
 3172              	.LVL349:
 3173              	.L278:
 790:../drivers/fsl_dspi.c ****                         }
 3174              		.loc 1 790 0
 3175 023e ACF1020C 		sub	ip, ip, #2
 3176              	.LVL350:
 3177              	.L279:
 3178              	.LBB502:
 3179              	.LBB460:
 580:../drivers/fsl_dspi.h **** }
 3180              		.loc 2 580 0
 3181 0242 C4F82C90 		str	r9, [r4, #44]
 3182 0246 E5E7     		b	.L276
 3183              	.LVL351:
 3184              	.L277:
 3185              	.LBE460:
 3186              	.LBE502:
 794:../drivers/fsl_dspi.c ****                             {
 3187              		.loc 1 794 0
 3188 0248 23B1     		cbz	r3, .L297
 796:../drivers/fsl_dspi.c ****                                 ++rxData;
 3189              		.loc 1 796 0
 3190 024a 03F8015B 		strb	r5, [r3], #1
 3191              	.LVL352:
 799:../drivers/fsl_dspi.c ****                         }
 3192              		.loc 1 799 0
 3193 024e 4FF0000C 		mov	ip, #0
 3194              	.LVL353:
 3195 0252 F6E7     		b	.L279
 3196              	.LVL354:
 3197              	.L297:
 3198 0254 9C46     		mov	ip, r3
 3199              	.LVL355:
 3200 0256 F4E7     		b	.L279
 3201              	.LVL356:
 3202              	.L282:
 3203              	.LBB503:
 3204              	.LBB504:
 580:../drivers/fsl_dspi.h **** }
 3205              		.loc 2 580 0
 3206 0258 E062     		str	r0, [r4, #44]
 3207 025a 58E7     		b	.L270
 3208              	.LVL357:
 3209              	.L283:
 3210              	.LBE504:
 3211              	.LBE503:
 822:../drivers/fsl_dspi.c ****                 }
 3212              		.loc 1 822 0
 3213 025c B446     		mov	ip, r6
 3214              	.LVL358:
 3215 025e 61E7     		b	.L284
 3216              	.LVL359:
 3217              	.L291:
 617:../drivers/fsl_dspi.c ****     }
 3218              		.loc 1 617 0
 3219 0260 0420     		movs	r0, #4
 3220 0262 46E7     		b	.L244
 3221              	.L317:
 3222              		.align	2
 3223              	.L316:
 3224 0264 00000000 		.word	.LANCHOR2
 3225 0268 00000ADA 		.word	-636878848
 3226 026c 00C00A40 		.word	1074446336
 3227 0270 00C00240 		.word	1073922048
 3228              		.cfi_endproc
 3229              	.LFE184:
 3231              		.section	.text.DSPI_MasterTransferNonBlocking,"ax",%progbits
 3232              		.align	1
 3233              		.global	DSPI_MasterTransferNonBlocking
 3234              		.syntax unified
 3235              		.thumb
 3236              		.thumb_func
 3237              		.fpu fpv4-sp-d16
 3239              	DSPI_MasterTransferNonBlocking:
 3240              	.LFB186:
 896:../drivers/fsl_dspi.c ****     assert(handle);
 3241              		.loc 1 896 0
 3242              		.cfi_startproc
 3243              		@ args = 0, pretend = 0, frame = 8
 3244              		@ frame_needed = 0, uses_anonymous_args = 0
 3245              	.LVL360:
 901:../drivers/fsl_dspi.c ****     {
 3246              		.loc 1 901 0
 3247 0000 9368     		ldr	r3, [r2, #8]
 896:../drivers/fsl_dspi.c ****     assert(handle);
 3248              		.loc 1 896 0
 3249 0002 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, r10, lr}
 3250              		.cfi_def_cfa_offset 40
 3251              		.cfi_offset 4, -32
 3252              		.cfi_offset 5, -28
 3253              		.cfi_offset 6, -24
 3254              		.cfi_offset 7, -20
 3255              		.cfi_offset 8, -16
 3256              		.cfi_offset 9, -12
 3257              		.cfi_offset 10, -8
 3258              		.cfi_offset 14, -4
 896:../drivers/fsl_dspi.c ****     assert(handle);
 3259              		.loc 1 896 0
 3260 0006 0446     		mov	r4, r0
 3261 0008 0D46     		mov	r5, r1
 3262 000a 1746     		mov	r7, r2
 901:../drivers/fsl_dspi.c ****     {
 3263              		.loc 1 901 0
 3264 000c 002B     		cmp	r3, #0
 3265 000e 00F09280 		beq	.L325
 907:../drivers/fsl_dspi.c ****     {
 3266              		.loc 1 907 0
 3267 0012 91F82430 		ldrb	r3, [r1, #36]	@ zero_extendqisi2
 3268 0016 012B     		cmp	r3, #1
 3269 0018 00F09180 		beq	.L326
 3270              	.LVL361:
 3271              	.LBB529:
 3272              	.LBB530:
 912:../drivers/fsl_dspi.c **** 
 3273              		.loc 1 912 0
 3274 001c 0122     		movs	r2, #1
 3275              	.LVL362:
 3276 001e 81F82420 		strb	r2, [r1, #36]
 915:../drivers/fsl_dspi.c **** 
 3277              		.loc 1 915 0
 3278 0022 FFF7FEFF 		bl	DSPI_GetInstance
 3279              	.LVL363:
 3280 0026 474B     		ldr	r3, .L331
 3281 0028 1E56     		ldrsb	r6, [r3, r0]
 3282              	.LVL364:
 3283              	.LBB531:
 3284              	.LBB532:
 3285              	.LBB533:
 3286              		.file 5 "../CMSIS/core_cm4.h"
   1:../CMSIS/core_cm4.h **** /**************************************************************************//**
   2:../CMSIS/core_cm4.h ****  * @file     core_cm4.h
   3:../CMSIS/core_cm4.h ****  * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm4.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm4.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm4.h ****  ******************************************************************************/
   7:../CMSIS/core_cm4.h **** /*
   8:../CMSIS/core_cm4.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm4.h ****  *
  10:../CMSIS/core_cm4.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm4.h ****  *
  12:../CMSIS/core_cm4.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm4.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm4.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm4.h ****  *
  16:../CMSIS/core_cm4.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm4.h ****  *
  18:../CMSIS/core_cm4.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm4.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm4.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm4.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm4.h ****  * limitations under the License.
  23:../CMSIS/core_cm4.h ****  */
  24:../CMSIS/core_cm4.h **** 
  25:../CMSIS/core_cm4.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm4.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm4.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm4.h **** #endif
  30:../CMSIS/core_cm4.h **** 
  31:../CMSIS/core_cm4.h **** #ifndef __CORE_CM4_H_GENERIC
  32:../CMSIS/core_cm4.h **** #define __CORE_CM4_H_GENERIC
  33:../CMSIS/core_cm4.h **** 
  34:../CMSIS/core_cm4.h **** #include <stdint.h>
  35:../CMSIS/core_cm4.h **** 
  36:../CMSIS/core_cm4.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm4.h ****  extern "C" {
  38:../CMSIS/core_cm4.h **** #endif
  39:../CMSIS/core_cm4.h **** 
  40:../CMSIS/core_cm4.h **** /**
  41:../CMSIS/core_cm4.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm4.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm4.h **** 
  44:../CMSIS/core_cm4.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm4.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm4.h **** 
  47:../CMSIS/core_cm4.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm4.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm4.h **** 
  50:../CMSIS/core_cm4.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm4.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm4.h ****  */
  53:../CMSIS/core_cm4.h **** 
  54:../CMSIS/core_cm4.h **** 
  55:../CMSIS/core_cm4.h **** /*******************************************************************************
  56:../CMSIS/core_cm4.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm4.h ****  ******************************************************************************/
  58:../CMSIS/core_cm4.h **** /**
  59:../CMSIS/core_cm4.h ****   \ingroup Cortex_M4
  60:../CMSIS/core_cm4.h ****   @{
  61:../CMSIS/core_cm4.h ****  */
  62:../CMSIS/core_cm4.h **** 
  63:../CMSIS/core_cm4.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm4.h ****  
  65:../CMSIS/core_cm4.h **** /* CMSIS CM4 definitions */
  66:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm4.h ****                                     __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:../CMSIS/core_cm4.h **** 
  71:../CMSIS/core_cm4.h **** #define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
  72:../CMSIS/core_cm4.h **** 
  73:../CMSIS/core_cm4.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm4.h ****     For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and fun
  75:../CMSIS/core_cm4.h **** */
  76:../CMSIS/core_cm4.h **** #if defined ( __CC_ARM )
  77:../CMSIS/core_cm4.h ****   #if defined __TARGET_FPU_VFP
  78:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  79:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
  80:../CMSIS/core_cm4.h ****     #else
  81:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
  82:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
  83:../CMSIS/core_cm4.h ****     #endif
  84:../CMSIS/core_cm4.h ****   #else
  85:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
  86:../CMSIS/core_cm4.h ****   #endif
  87:../CMSIS/core_cm4.h **** 
  88:../CMSIS/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  89:../CMSIS/core_cm4.h ****   #if defined __ARM_PCS_VFP
  90:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  91:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
  92:../CMSIS/core_cm4.h ****     #else
  93:../CMSIS/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
  94:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
  95:../CMSIS/core_cm4.h ****     #endif
  96:../CMSIS/core_cm4.h ****   #else
  97:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
  98:../CMSIS/core_cm4.h ****   #endif
  99:../CMSIS/core_cm4.h **** 
 100:../CMSIS/core_cm4.h **** #elif defined ( __GNUC__ )
 101:../CMSIS/core_cm4.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 102:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 103:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 104:../CMSIS/core_cm4.h ****     #else
 105:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 106:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 107:../CMSIS/core_cm4.h ****     #endif
 108:../CMSIS/core_cm4.h ****   #else
 109:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 110:../CMSIS/core_cm4.h ****   #endif
 111:../CMSIS/core_cm4.h **** 
 112:../CMSIS/core_cm4.h **** #elif defined ( __ICCARM__ )
 113:../CMSIS/core_cm4.h ****   #if defined __ARMVFP__
 114:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 115:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 116:../CMSIS/core_cm4.h ****     #else
 117:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 118:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 119:../CMSIS/core_cm4.h ****     #endif
 120:../CMSIS/core_cm4.h ****   #else
 121:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 122:../CMSIS/core_cm4.h ****   #endif
 123:../CMSIS/core_cm4.h **** 
 124:../CMSIS/core_cm4.h **** #elif defined ( __TI_ARM__ )
 125:../CMSIS/core_cm4.h ****   #if defined __TI_VFP_SUPPORT__
 126:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 127:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 128:../CMSIS/core_cm4.h ****     #else
 129:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 130:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 131:../CMSIS/core_cm4.h ****     #endif
 132:../CMSIS/core_cm4.h ****   #else
 133:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 134:../CMSIS/core_cm4.h ****   #endif
 135:../CMSIS/core_cm4.h **** 
 136:../CMSIS/core_cm4.h **** #elif defined ( __TASKING__ )
 137:../CMSIS/core_cm4.h ****   #if defined __FPU_VFP__
 138:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 139:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 140:../CMSIS/core_cm4.h ****     #else
 141:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 142:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 143:../CMSIS/core_cm4.h ****     #endif
 144:../CMSIS/core_cm4.h ****   #else
 145:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 146:../CMSIS/core_cm4.h ****   #endif
 147:../CMSIS/core_cm4.h **** 
 148:../CMSIS/core_cm4.h **** #elif defined ( __CSMC__ )
 149:../CMSIS/core_cm4.h ****   #if ( __CSMC__ & 0x400U)
 150:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 151:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 152:../CMSIS/core_cm4.h ****     #else
 153:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 154:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 155:../CMSIS/core_cm4.h ****     #endif
 156:../CMSIS/core_cm4.h ****   #else
 157:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 158:../CMSIS/core_cm4.h ****   #endif
 159:../CMSIS/core_cm4.h **** 
 160:../CMSIS/core_cm4.h **** #endif
 161:../CMSIS/core_cm4.h **** 
 162:../CMSIS/core_cm4.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 163:../CMSIS/core_cm4.h **** 
 164:../CMSIS/core_cm4.h **** 
 165:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 166:../CMSIS/core_cm4.h **** }
 167:../CMSIS/core_cm4.h **** #endif
 168:../CMSIS/core_cm4.h **** 
 169:../CMSIS/core_cm4.h **** #endif /* __CORE_CM4_H_GENERIC */
 170:../CMSIS/core_cm4.h **** 
 171:../CMSIS/core_cm4.h **** #ifndef __CMSIS_GENERIC
 172:../CMSIS/core_cm4.h **** 
 173:../CMSIS/core_cm4.h **** #ifndef __CORE_CM4_H_DEPENDANT
 174:../CMSIS/core_cm4.h **** #define __CORE_CM4_H_DEPENDANT
 175:../CMSIS/core_cm4.h **** 
 176:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 177:../CMSIS/core_cm4.h ****  extern "C" {
 178:../CMSIS/core_cm4.h **** #endif
 179:../CMSIS/core_cm4.h **** 
 180:../CMSIS/core_cm4.h **** /* check device defines and use defaults */
 181:../CMSIS/core_cm4.h **** #if defined __CHECK_DEVICE_DEFINES
 182:../CMSIS/core_cm4.h ****   #ifndef __CM4_REV
 183:../CMSIS/core_cm4.h ****     #define __CM4_REV               0x0000U
 184:../CMSIS/core_cm4.h ****     #warning "__CM4_REV not defined in device header file; using default!"
 185:../CMSIS/core_cm4.h ****   #endif
 186:../CMSIS/core_cm4.h **** 
 187:../CMSIS/core_cm4.h ****   #ifndef __FPU_PRESENT
 188:../CMSIS/core_cm4.h ****     #define __FPU_PRESENT             0U
 189:../CMSIS/core_cm4.h ****     #warning "__FPU_PRESENT not defined in device header file; using default!"
 190:../CMSIS/core_cm4.h ****   #endif
 191:../CMSIS/core_cm4.h **** 
 192:../CMSIS/core_cm4.h ****   #ifndef __MPU_PRESENT
 193:../CMSIS/core_cm4.h ****     #define __MPU_PRESENT             0U
 194:../CMSIS/core_cm4.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 195:../CMSIS/core_cm4.h ****   #endif
 196:../CMSIS/core_cm4.h **** 
 197:../CMSIS/core_cm4.h ****   #ifndef __NVIC_PRIO_BITS
 198:../CMSIS/core_cm4.h ****     #define __NVIC_PRIO_BITS          3U
 199:../CMSIS/core_cm4.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 200:../CMSIS/core_cm4.h ****   #endif
 201:../CMSIS/core_cm4.h **** 
 202:../CMSIS/core_cm4.h ****   #ifndef __Vendor_SysTickConfig
 203:../CMSIS/core_cm4.h ****     #define __Vendor_SysTickConfig    0U
 204:../CMSIS/core_cm4.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 205:../CMSIS/core_cm4.h ****   #endif
 206:../CMSIS/core_cm4.h **** #endif
 207:../CMSIS/core_cm4.h **** 
 208:../CMSIS/core_cm4.h **** /* IO definitions (access restrictions to peripheral registers) */
 209:../CMSIS/core_cm4.h **** /**
 210:../CMSIS/core_cm4.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 211:../CMSIS/core_cm4.h **** 
 212:../CMSIS/core_cm4.h ****     <strong>IO Type Qualifiers</strong> are used
 213:../CMSIS/core_cm4.h ****     \li to specify the access to peripheral variables.
 214:../CMSIS/core_cm4.h ****     \li for automatic generation of peripheral register debug information.
 215:../CMSIS/core_cm4.h **** */
 216:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 217:../CMSIS/core_cm4.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 218:../CMSIS/core_cm4.h **** #else
 219:../CMSIS/core_cm4.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 220:../CMSIS/core_cm4.h **** #endif
 221:../CMSIS/core_cm4.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 222:../CMSIS/core_cm4.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 223:../CMSIS/core_cm4.h **** 
 224:../CMSIS/core_cm4.h **** /* following defines should be used for structure members */
 225:../CMSIS/core_cm4.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 226:../CMSIS/core_cm4.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 227:../CMSIS/core_cm4.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 228:../CMSIS/core_cm4.h **** 
 229:../CMSIS/core_cm4.h **** /*@} end of group Cortex_M4 */
 230:../CMSIS/core_cm4.h **** 
 231:../CMSIS/core_cm4.h **** 
 232:../CMSIS/core_cm4.h **** 
 233:../CMSIS/core_cm4.h **** /*******************************************************************************
 234:../CMSIS/core_cm4.h ****  *                 Register Abstraction
 235:../CMSIS/core_cm4.h ****   Core Register contain:
 236:../CMSIS/core_cm4.h ****   - Core Register
 237:../CMSIS/core_cm4.h ****   - Core NVIC Register
 238:../CMSIS/core_cm4.h ****   - Core SCB Register
 239:../CMSIS/core_cm4.h ****   - Core SysTick Register
 240:../CMSIS/core_cm4.h ****   - Core Debug Register
 241:../CMSIS/core_cm4.h ****   - Core MPU Register
 242:../CMSIS/core_cm4.h ****   - Core FPU Register
 243:../CMSIS/core_cm4.h ****  ******************************************************************************/
 244:../CMSIS/core_cm4.h **** /**
 245:../CMSIS/core_cm4.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 246:../CMSIS/core_cm4.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 247:../CMSIS/core_cm4.h **** */
 248:../CMSIS/core_cm4.h **** 
 249:../CMSIS/core_cm4.h **** /**
 250:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
 251:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 252:../CMSIS/core_cm4.h ****   \brief      Core Register type definitions.
 253:../CMSIS/core_cm4.h ****   @{
 254:../CMSIS/core_cm4.h ****  */
 255:../CMSIS/core_cm4.h **** 
 256:../CMSIS/core_cm4.h **** /**
 257:../CMSIS/core_cm4.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 258:../CMSIS/core_cm4.h ****  */
 259:../CMSIS/core_cm4.h **** typedef union
 260:../CMSIS/core_cm4.h **** {
 261:../CMSIS/core_cm4.h ****   struct
 262:../CMSIS/core_cm4.h ****   {
 263:../CMSIS/core_cm4.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
 264:../CMSIS/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 265:../CMSIS/core_cm4.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
 266:../CMSIS/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 267:../CMSIS/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 268:../CMSIS/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 269:../CMSIS/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 270:../CMSIS/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 271:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 272:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 273:../CMSIS/core_cm4.h **** } APSR_Type;
 274:../CMSIS/core_cm4.h **** 
 275:../CMSIS/core_cm4.h **** /* APSR Register Definitions */
 276:../CMSIS/core_cm4.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 277:../CMSIS/core_cm4.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 278:../CMSIS/core_cm4.h **** 
 279:../CMSIS/core_cm4.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 280:../CMSIS/core_cm4.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 281:../CMSIS/core_cm4.h **** 
 282:../CMSIS/core_cm4.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 283:../CMSIS/core_cm4.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 284:../CMSIS/core_cm4.h **** 
 285:../CMSIS/core_cm4.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 286:../CMSIS/core_cm4.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 287:../CMSIS/core_cm4.h **** 
 288:../CMSIS/core_cm4.h **** #define APSR_Q_Pos                         27U                                            /*!< APSR
 289:../CMSIS/core_cm4.h **** #define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR
 290:../CMSIS/core_cm4.h **** 
 291:../CMSIS/core_cm4.h **** #define APSR_GE_Pos                        16U                                            /*!< APSR
 292:../CMSIS/core_cm4.h **** #define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR
 293:../CMSIS/core_cm4.h **** 
 294:../CMSIS/core_cm4.h **** 
 295:../CMSIS/core_cm4.h **** /**
 296:../CMSIS/core_cm4.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 297:../CMSIS/core_cm4.h ****  */
 298:../CMSIS/core_cm4.h **** typedef union
 299:../CMSIS/core_cm4.h **** {
 300:../CMSIS/core_cm4.h ****   struct
 301:../CMSIS/core_cm4.h ****   {
 302:../CMSIS/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 303:../CMSIS/core_cm4.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 304:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm4.h **** } IPSR_Type;
 307:../CMSIS/core_cm4.h **** 
 308:../CMSIS/core_cm4.h **** /* IPSR Register Definitions */
 309:../CMSIS/core_cm4.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 310:../CMSIS/core_cm4.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 311:../CMSIS/core_cm4.h **** 
 312:../CMSIS/core_cm4.h **** 
 313:../CMSIS/core_cm4.h **** /**
 314:../CMSIS/core_cm4.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 315:../CMSIS/core_cm4.h ****  */
 316:../CMSIS/core_cm4.h **** typedef union
 317:../CMSIS/core_cm4.h **** {
 318:../CMSIS/core_cm4.h ****   struct
 319:../CMSIS/core_cm4.h ****   {
 320:../CMSIS/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 321:../CMSIS/core_cm4.h ****     uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
 322:../CMSIS/core_cm4.h ****     uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
 323:../CMSIS/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 324:../CMSIS/core_cm4.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
 325:../CMSIS/core_cm4.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit */
 326:../CMSIS/core_cm4.h ****     uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
 327:../CMSIS/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 328:../CMSIS/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 329:../CMSIS/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 330:../CMSIS/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 331:../CMSIS/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 332:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 333:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 334:../CMSIS/core_cm4.h **** } xPSR_Type;
 335:../CMSIS/core_cm4.h **** 
 336:../CMSIS/core_cm4.h **** /* xPSR Register Definitions */
 337:../CMSIS/core_cm4.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 338:../CMSIS/core_cm4.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 339:../CMSIS/core_cm4.h **** 
 340:../CMSIS/core_cm4.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 341:../CMSIS/core_cm4.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 342:../CMSIS/core_cm4.h **** 
 343:../CMSIS/core_cm4.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 344:../CMSIS/core_cm4.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 345:../CMSIS/core_cm4.h **** 
 346:../CMSIS/core_cm4.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 347:../CMSIS/core_cm4.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 348:../CMSIS/core_cm4.h **** 
 349:../CMSIS/core_cm4.h **** #define xPSR_Q_Pos                         27U                                            /*!< xPSR
 350:../CMSIS/core_cm4.h **** #define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR
 351:../CMSIS/core_cm4.h **** 
 352:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR
 353:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR
 354:../CMSIS/core_cm4.h **** 
 355:../CMSIS/core_cm4.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 356:../CMSIS/core_cm4.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 357:../CMSIS/core_cm4.h **** 
 358:../CMSIS/core_cm4.h **** #define xPSR_GE_Pos                        16U                                            /*!< xPSR
 359:../CMSIS/core_cm4.h **** #define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR
 360:../CMSIS/core_cm4.h **** 
 361:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR
 362:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR
 363:../CMSIS/core_cm4.h **** 
 364:../CMSIS/core_cm4.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 365:../CMSIS/core_cm4.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 366:../CMSIS/core_cm4.h **** 
 367:../CMSIS/core_cm4.h **** 
 368:../CMSIS/core_cm4.h **** /**
 369:../CMSIS/core_cm4.h ****   \brief  Union type to access the Control Registers (CONTROL).
 370:../CMSIS/core_cm4.h ****  */
 371:../CMSIS/core_cm4.h **** typedef union
 372:../CMSIS/core_cm4.h **** {
 373:../CMSIS/core_cm4.h ****   struct
 374:../CMSIS/core_cm4.h ****   {
 375:../CMSIS/core_cm4.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 376:../CMSIS/core_cm4.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 377:../CMSIS/core_cm4.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
 378:../CMSIS/core_cm4.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
 379:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 380:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 381:../CMSIS/core_cm4.h **** } CONTROL_Type;
 382:../CMSIS/core_cm4.h **** 
 383:../CMSIS/core_cm4.h **** /* CONTROL Register Definitions */
 384:../CMSIS/core_cm4.h **** #define CONTROL_FPCA_Pos                    2U                                            /*!< CONT
 385:../CMSIS/core_cm4.h **** #define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONT
 386:../CMSIS/core_cm4.h **** 
 387:../CMSIS/core_cm4.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 388:../CMSIS/core_cm4.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 389:../CMSIS/core_cm4.h **** 
 390:../CMSIS/core_cm4.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 391:../CMSIS/core_cm4.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 392:../CMSIS/core_cm4.h **** 
 393:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_CORE */
 394:../CMSIS/core_cm4.h **** 
 395:../CMSIS/core_cm4.h **** 
 396:../CMSIS/core_cm4.h **** /**
 397:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
 398:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 399:../CMSIS/core_cm4.h ****   \brief      Type definitions for the NVIC Registers
 400:../CMSIS/core_cm4.h ****   @{
 401:../CMSIS/core_cm4.h ****  */
 402:../CMSIS/core_cm4.h **** 
 403:../CMSIS/core_cm4.h **** /**
 404:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 405:../CMSIS/core_cm4.h ****  */
 406:../CMSIS/core_cm4.h **** typedef struct
 407:../CMSIS/core_cm4.h **** {
 408:../CMSIS/core_cm4.h ****   __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 409:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[24U];
 410:../CMSIS/core_cm4.h ****   __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 411:../CMSIS/core_cm4.h ****         uint32_t RSERVED1[24U];
 412:../CMSIS/core_cm4.h ****   __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 413:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[24U];
 414:../CMSIS/core_cm4.h ****   __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 415:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[24U];
 416:../CMSIS/core_cm4.h ****   __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
 417:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[56U];
 418:../CMSIS/core_cm4.h ****   __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 419:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[644U];
 420:../CMSIS/core_cm4.h ****   __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 421:../CMSIS/core_cm4.h **** }  NVIC_Type;
 422:../CMSIS/core_cm4.h **** 
 423:../CMSIS/core_cm4.h **** /* Software Triggered Interrupt Register Definitions */
 424:../CMSIS/core_cm4.h **** #define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: I
 425:../CMSIS/core_cm4.h **** #define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: I
 426:../CMSIS/core_cm4.h **** 
 427:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_NVIC */
 428:../CMSIS/core_cm4.h **** 
 429:../CMSIS/core_cm4.h **** 
 430:../CMSIS/core_cm4.h **** /**
 431:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 432:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 433:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Control Block Registers
 434:../CMSIS/core_cm4.h ****   @{
 435:../CMSIS/core_cm4.h ****  */
 436:../CMSIS/core_cm4.h **** 
 437:../CMSIS/core_cm4.h **** /**
 438:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Control Block (SCB).
 439:../CMSIS/core_cm4.h ****  */
 440:../CMSIS/core_cm4.h **** typedef struct
 441:../CMSIS/core_cm4.h **** {
 442:../CMSIS/core_cm4.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 443:../CMSIS/core_cm4.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 444:../CMSIS/core_cm4.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 445:../CMSIS/core_cm4.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 446:../CMSIS/core_cm4.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 447:../CMSIS/core_cm4.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 448:../CMSIS/core_cm4.h ****   __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 449:../CMSIS/core_cm4.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 450:../CMSIS/core_cm4.h ****   __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 451:../CMSIS/core_cm4.h ****   __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
 452:../CMSIS/core_cm4.h ****   __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
 453:../CMSIS/core_cm4.h ****   __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register
 454:../CMSIS/core_cm4.h ****   __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
 455:../CMSIS/core_cm4.h ****   __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 456:../CMSIS/core_cm4.h ****   __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
 457:../CMSIS/core_cm4.h ****   __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
 458:../CMSIS/core_cm4.h ****   __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
 459:../CMSIS/core_cm4.h ****   __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
 460:../CMSIS/core_cm4.h ****   __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Regis
 461:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[5U];
 462:../CMSIS/core_cm4.h ****   __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Regis
 463:../CMSIS/core_cm4.h **** } SCB_Type;
 464:../CMSIS/core_cm4.h **** 
 465:../CMSIS/core_cm4.h **** /* SCB CPUID Register Definitions */
 466:../CMSIS/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 467:../CMSIS/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 468:../CMSIS/core_cm4.h **** 
 469:../CMSIS/core_cm4.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 470:../CMSIS/core_cm4.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 471:../CMSIS/core_cm4.h **** 
 472:../CMSIS/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 473:../CMSIS/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 474:../CMSIS/core_cm4.h **** 
 475:../CMSIS/core_cm4.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 476:../CMSIS/core_cm4.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 477:../CMSIS/core_cm4.h **** 
 478:../CMSIS/core_cm4.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 479:../CMSIS/core_cm4.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 480:../CMSIS/core_cm4.h **** 
 481:../CMSIS/core_cm4.h **** /* SCB Interrupt Control State Register Definitions */
 482:../CMSIS/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 483:../CMSIS/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 484:../CMSIS/core_cm4.h **** 
 485:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 486:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 487:../CMSIS/core_cm4.h **** 
 488:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 489:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 490:../CMSIS/core_cm4.h **** 
 491:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 492:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 493:../CMSIS/core_cm4.h **** 
 494:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 495:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 496:../CMSIS/core_cm4.h **** 
 497:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 498:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 499:../CMSIS/core_cm4.h **** 
 500:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 501:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 502:../CMSIS/core_cm4.h **** 
 503:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 504:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 505:../CMSIS/core_cm4.h **** 
 506:../CMSIS/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB 
 507:../CMSIS/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 508:../CMSIS/core_cm4.h **** 
 509:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 510:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 511:../CMSIS/core_cm4.h **** 
 512:../CMSIS/core_cm4.h **** /* SCB Vector Table Offset Register Definitions */
 513:../CMSIS/core_cm4.h **** #define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB 
 514:../CMSIS/core_cm4.h **** #define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB 
 515:../CMSIS/core_cm4.h **** 
 516:../CMSIS/core_cm4.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 517:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 518:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 519:../CMSIS/core_cm4.h **** 
 520:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 521:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 522:../CMSIS/core_cm4.h **** 
 523:../CMSIS/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 524:../CMSIS/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 525:../CMSIS/core_cm4.h **** 
 526:../CMSIS/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB 
 527:../CMSIS/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 528:../CMSIS/core_cm4.h **** 
 529:../CMSIS/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 530:../CMSIS/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 531:../CMSIS/core_cm4.h **** 
 532:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 533:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 534:../CMSIS/core_cm4.h **** 
 535:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB 
 536:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB 
 537:../CMSIS/core_cm4.h **** 
 538:../CMSIS/core_cm4.h **** /* SCB System Control Register Definitions */
 539:../CMSIS/core_cm4.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 540:../CMSIS/core_cm4.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 541:../CMSIS/core_cm4.h **** 
 542:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 543:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 544:../CMSIS/core_cm4.h **** 
 545:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 546:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 547:../CMSIS/core_cm4.h **** 
 548:../CMSIS/core_cm4.h **** /* SCB Configuration Control Register Definitions */
 549:../CMSIS/core_cm4.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 550:../CMSIS/core_cm4.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 551:../CMSIS/core_cm4.h **** 
 552:../CMSIS/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB 
 553:../CMSIS/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 554:../CMSIS/core_cm4.h **** 
 555:../CMSIS/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB 
 556:../CMSIS/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 557:../CMSIS/core_cm4.h **** 
 558:../CMSIS/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 559:../CMSIS/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 560:../CMSIS/core_cm4.h **** 
 561:../CMSIS/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB 
 562:../CMSIS/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 563:../CMSIS/core_cm4.h **** 
 564:../CMSIS/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB 
 565:../CMSIS/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB 
 566:../CMSIS/core_cm4.h **** 
 567:../CMSIS/core_cm4.h **** /* SCB System Handler Control and State Register Definitions */
 568:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB 
 569:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 570:../CMSIS/core_cm4.h **** 
 571:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB 
 572:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 573:../CMSIS/core_cm4.h **** 
 574:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB 
 575:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 576:../CMSIS/core_cm4.h **** 
 577:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 578:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 579:../CMSIS/core_cm4.h **** 
 580:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB 
 581:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 582:../CMSIS/core_cm4.h **** 
 583:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB 
 584:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 585:../CMSIS/core_cm4.h **** 
 586:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB 
 587:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 588:../CMSIS/core_cm4.h **** 
 589:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB 
 590:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 591:../CMSIS/core_cm4.h **** 
 592:../CMSIS/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB 
 593:../CMSIS/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
 594:../CMSIS/core_cm4.h **** 
 595:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB 
 596:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 597:../CMSIS/core_cm4.h **** 
 598:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB 
 599:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 600:../CMSIS/core_cm4.h **** 
 601:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB 
 602:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 603:../CMSIS/core_cm4.h **** 
 604:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB 
 605:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 606:../CMSIS/core_cm4.h **** 
 607:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB 
 608:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB 
 609:../CMSIS/core_cm4.h **** 
 610:../CMSIS/core_cm4.h **** /* SCB Configurable Fault Status Register Definitions */
 611:../CMSIS/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB 
 612:../CMSIS/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 613:../CMSIS/core_cm4.h **** 
 614:../CMSIS/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB 
 615:../CMSIS/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 616:../CMSIS/core_cm4.h **** 
 617:../CMSIS/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB 
 618:../CMSIS/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB 
 619:../CMSIS/core_cm4.h **** 
 620:../CMSIS/core_cm4.h **** /* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
 621:../CMSIS/core_cm4.h **** #define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB 
 622:../CMSIS/core_cm4.h **** #define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB 
 623:../CMSIS/core_cm4.h **** 
 624:../CMSIS/core_cm4.h **** #define SCB_CFSR_MLSPERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 5U)               /*!< SCB 
 625:../CMSIS/core_cm4.h **** #define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB 
 626:../CMSIS/core_cm4.h **** 
 627:../CMSIS/core_cm4.h **** #define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB 
 628:../CMSIS/core_cm4.h **** #define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB 
 629:../CMSIS/core_cm4.h **** 
 630:../CMSIS/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB 
 631:../CMSIS/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB 
 632:../CMSIS/core_cm4.h **** 
 633:../CMSIS/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB 
 634:../CMSIS/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB 
 635:../CMSIS/core_cm4.h **** 
 636:../CMSIS/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB 
 637:../CMSIS/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB 
 638:../CMSIS/core_cm4.h **** 
 639:../CMSIS/core_cm4.h **** /* BusFault Status Register (part of SCB Configurable Fault Status Register) */
 640:../CMSIS/core_cm4.h **** #define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB 
 641:../CMSIS/core_cm4.h **** #define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB 
 642:../CMSIS/core_cm4.h **** 
 643:../CMSIS/core_cm4.h **** #define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB 
 644:../CMSIS/core_cm4.h **** #define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB 
 645:../CMSIS/core_cm4.h **** 
 646:../CMSIS/core_cm4.h **** #define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB 
 647:../CMSIS/core_cm4.h **** #define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB 
 648:../CMSIS/core_cm4.h **** 
 649:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB 
 650:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB 
 651:../CMSIS/core_cm4.h **** 
 652:../CMSIS/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB 
 653:../CMSIS/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB 
 654:../CMSIS/core_cm4.h **** 
 655:../CMSIS/core_cm4.h **** #define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB 
 656:../CMSIS/core_cm4.h **** #define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB 
 657:../CMSIS/core_cm4.h **** 
 658:../CMSIS/core_cm4.h **** #define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB 
 659:../CMSIS/core_cm4.h **** #define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB 
 660:../CMSIS/core_cm4.h **** 
 661:../CMSIS/core_cm4.h **** /* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
 662:../CMSIS/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB 
 663:../CMSIS/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB 
 664:../CMSIS/core_cm4.h **** 
 665:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB 
 666:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB 
 667:../CMSIS/core_cm4.h **** 
 668:../CMSIS/core_cm4.h **** #define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB 
 669:../CMSIS/core_cm4.h **** #define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB 
 670:../CMSIS/core_cm4.h **** 
 671:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB 
 672:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB 
 673:../CMSIS/core_cm4.h **** 
 674:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB 
 675:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB 
 676:../CMSIS/core_cm4.h **** 
 677:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB 
 678:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB 
 679:../CMSIS/core_cm4.h **** 
 680:../CMSIS/core_cm4.h **** /* SCB Hard Fault Status Register Definitions */
 681:../CMSIS/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB 
 682:../CMSIS/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 683:../CMSIS/core_cm4.h **** 
 684:../CMSIS/core_cm4.h **** #define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB 
 685:../CMSIS/core_cm4.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 686:../CMSIS/core_cm4.h **** 
 687:../CMSIS/core_cm4.h **** #define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB 
 688:../CMSIS/core_cm4.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 689:../CMSIS/core_cm4.h **** 
 690:../CMSIS/core_cm4.h **** /* SCB Debug Fault Status Register Definitions */
 691:../CMSIS/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB 
 692:../CMSIS/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 693:../CMSIS/core_cm4.h **** 
 694:../CMSIS/core_cm4.h **** #define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB 
 695:../CMSIS/core_cm4.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 696:../CMSIS/core_cm4.h **** 
 697:../CMSIS/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB 
 698:../CMSIS/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 699:../CMSIS/core_cm4.h **** 
 700:../CMSIS/core_cm4.h **** #define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB 
 701:../CMSIS/core_cm4.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 702:../CMSIS/core_cm4.h **** 
 703:../CMSIS/core_cm4.h **** #define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB 
 704:../CMSIS/core_cm4.h **** #define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB 
 705:../CMSIS/core_cm4.h **** 
 706:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SCB */
 707:../CMSIS/core_cm4.h **** 
 708:../CMSIS/core_cm4.h **** 
 709:../CMSIS/core_cm4.h **** /**
 710:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 711:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
 712:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Control and ID Register not in the SCB
 713:../CMSIS/core_cm4.h ****   @{
 714:../CMSIS/core_cm4.h ****  */
 715:../CMSIS/core_cm4.h **** 
 716:../CMSIS/core_cm4.h **** /**
 717:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Control and ID Register not in the SCB.
 718:../CMSIS/core_cm4.h ****  */
 719:../CMSIS/core_cm4.h **** typedef struct
 720:../CMSIS/core_cm4.h **** {
 721:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
 722:../CMSIS/core_cm4.h ****   __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Regist
 723:../CMSIS/core_cm4.h ****   __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
 724:../CMSIS/core_cm4.h **** } SCnSCB_Type;
 725:../CMSIS/core_cm4.h **** 
 726:../CMSIS/core_cm4.h **** /* Interrupt Controller Type Register Definitions */
 727:../CMSIS/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: I
 728:../CMSIS/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: I
 729:../CMSIS/core_cm4.h **** 
 730:../CMSIS/core_cm4.h **** /* Auxiliary Control Register Definitions */
 731:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: 
 732:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: 
 733:../CMSIS/core_cm4.h **** 
 734:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: 
 735:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: 
 736:../CMSIS/core_cm4.h **** 
 737:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: 
 738:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: 
 739:../CMSIS/core_cm4.h **** 
 740:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: 
 741:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: 
 742:../CMSIS/core_cm4.h **** 
 743:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: 
 744:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: 
 745:../CMSIS/core_cm4.h **** 
 746:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SCnotSCB */
 747:../CMSIS/core_cm4.h **** 
 748:../CMSIS/core_cm4.h **** 
 749:../CMSIS/core_cm4.h **** /**
 750:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 751:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 752:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Timer Registers.
 753:../CMSIS/core_cm4.h ****   @{
 754:../CMSIS/core_cm4.h ****  */
 755:../CMSIS/core_cm4.h **** 
 756:../CMSIS/core_cm4.h **** /**
 757:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Timer (SysTick).
 758:../CMSIS/core_cm4.h ****  */
 759:../CMSIS/core_cm4.h **** typedef struct
 760:../CMSIS/core_cm4.h **** {
 761:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 762:../CMSIS/core_cm4.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 763:../CMSIS/core_cm4.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 764:../CMSIS/core_cm4.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 765:../CMSIS/core_cm4.h **** } SysTick_Type;
 766:../CMSIS/core_cm4.h **** 
 767:../CMSIS/core_cm4.h **** /* SysTick Control / Status Register Definitions */
 768:../CMSIS/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 769:../CMSIS/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 770:../CMSIS/core_cm4.h **** 
 771:../CMSIS/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 772:../CMSIS/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 773:../CMSIS/core_cm4.h **** 
 774:../CMSIS/core_cm4.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 775:../CMSIS/core_cm4.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 776:../CMSIS/core_cm4.h **** 
 777:../CMSIS/core_cm4.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 778:../CMSIS/core_cm4.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 779:../CMSIS/core_cm4.h **** 
 780:../CMSIS/core_cm4.h **** /* SysTick Reload Register Definitions */
 781:../CMSIS/core_cm4.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 782:../CMSIS/core_cm4.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 783:../CMSIS/core_cm4.h **** 
 784:../CMSIS/core_cm4.h **** /* SysTick Current Register Definitions */
 785:../CMSIS/core_cm4.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 786:../CMSIS/core_cm4.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 787:../CMSIS/core_cm4.h **** 
 788:../CMSIS/core_cm4.h **** /* SysTick Calibration Register Definitions */
 789:../CMSIS/core_cm4.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 790:../CMSIS/core_cm4.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 791:../CMSIS/core_cm4.h **** 
 792:../CMSIS/core_cm4.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 793:../CMSIS/core_cm4.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 794:../CMSIS/core_cm4.h **** 
 795:../CMSIS/core_cm4.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 796:../CMSIS/core_cm4.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 797:../CMSIS/core_cm4.h **** 
 798:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SysTick */
 799:../CMSIS/core_cm4.h **** 
 800:../CMSIS/core_cm4.h **** 
 801:../CMSIS/core_cm4.h **** /**
 802:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 803:../CMSIS/core_cm4.h ****   \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
 804:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
 805:../CMSIS/core_cm4.h ****   @{
 806:../CMSIS/core_cm4.h ****  */
 807:../CMSIS/core_cm4.h **** 
 808:../CMSIS/core_cm4.h **** /**
 809:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 810:../CMSIS/core_cm4.h ****  */
 811:../CMSIS/core_cm4.h **** typedef struct
 812:../CMSIS/core_cm4.h **** {
 813:../CMSIS/core_cm4.h ****   __OM  union
 814:../CMSIS/core_cm4.h ****   {
 815:../CMSIS/core_cm4.h ****     __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
 816:../CMSIS/core_cm4.h ****     __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
 817:../CMSIS/core_cm4.h ****     __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
 818:../CMSIS/core_cm4.h ****   }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
 819:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[864U];
 820:../CMSIS/core_cm4.h ****   __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
 821:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[15U];
 822:../CMSIS/core_cm4.h ****   __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
 823:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[15U];
 824:../CMSIS/core_cm4.h ****   __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
 825:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[29U];
 826:../CMSIS/core_cm4.h ****   __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register *
 827:../CMSIS/core_cm4.h ****   __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
 828:../CMSIS/core_cm4.h ****   __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Reg
 829:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[43U];
 830:../CMSIS/core_cm4.h ****   __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
 831:../CMSIS/core_cm4.h ****   __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
 832:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[6U];
 833:../CMSIS/core_cm4.h ****   __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Re
 834:../CMSIS/core_cm4.h ****   __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Re
 835:../CMSIS/core_cm4.h ****   __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Re
 836:../CMSIS/core_cm4.h ****   __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Re
 837:../CMSIS/core_cm4.h ****   __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Re
 838:../CMSIS/core_cm4.h ****   __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Re
 839:../CMSIS/core_cm4.h ****   __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Re
 840:../CMSIS/core_cm4.h ****   __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Re
 841:../CMSIS/core_cm4.h ****   __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Re
 842:../CMSIS/core_cm4.h ****   __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Re
 843:../CMSIS/core_cm4.h ****   __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Re
 844:../CMSIS/core_cm4.h ****   __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Re
 845:../CMSIS/core_cm4.h **** } ITM_Type;
 846:../CMSIS/core_cm4.h **** 
 847:../CMSIS/core_cm4.h **** /* ITM Trace Privilege Register Definitions */
 848:../CMSIS/core_cm4.h **** #define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM 
 849:../CMSIS/core_cm4.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM 
 850:../CMSIS/core_cm4.h **** 
 851:../CMSIS/core_cm4.h **** /* ITM Trace Control Register Definitions */
 852:../CMSIS/core_cm4.h **** #define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM 
 853:../CMSIS/core_cm4.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 854:../CMSIS/core_cm4.h **** 
 855:../CMSIS/core_cm4.h **** #define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM 
 856:../CMSIS/core_cm4.h **** #define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM 
 857:../CMSIS/core_cm4.h **** 
 858:../CMSIS/core_cm4.h **** #define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM 
 859:../CMSIS/core_cm4.h **** #define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM 
 860:../CMSIS/core_cm4.h **** 
 861:../CMSIS/core_cm4.h **** #define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM 
 862:../CMSIS/core_cm4.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 863:../CMSIS/core_cm4.h **** 
 864:../CMSIS/core_cm4.h **** #define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM 
 865:../CMSIS/core_cm4.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 866:../CMSIS/core_cm4.h **** 
 867:../CMSIS/core_cm4.h **** #define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM 
 868:../CMSIS/core_cm4.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 869:../CMSIS/core_cm4.h **** 
 870:../CMSIS/core_cm4.h **** #define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM 
 871:../CMSIS/core_cm4.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 872:../CMSIS/core_cm4.h **** 
 873:../CMSIS/core_cm4.h **** #define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM 
 874:../CMSIS/core_cm4.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 875:../CMSIS/core_cm4.h **** 
 876:../CMSIS/core_cm4.h **** #define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM 
 877:../CMSIS/core_cm4.h **** #define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM 
 878:../CMSIS/core_cm4.h **** 
 879:../CMSIS/core_cm4.h **** /* ITM Integration Write Register Definitions */
 880:../CMSIS/core_cm4.h **** #define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM 
 881:../CMSIS/core_cm4.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM 
 882:../CMSIS/core_cm4.h **** 
 883:../CMSIS/core_cm4.h **** /* ITM Integration Read Register Definitions */
 884:../CMSIS/core_cm4.h **** #define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM 
 885:../CMSIS/core_cm4.h **** #define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM 
 886:../CMSIS/core_cm4.h **** 
 887:../CMSIS/core_cm4.h **** /* ITM Integration Mode Control Register Definitions */
 888:../CMSIS/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM 
 889:../CMSIS/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM 
 890:../CMSIS/core_cm4.h **** 
 891:../CMSIS/core_cm4.h **** /* ITM Lock Status Register Definitions */
 892:../CMSIS/core_cm4.h **** #define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM 
 893:../CMSIS/core_cm4.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 894:../CMSIS/core_cm4.h **** 
 895:../CMSIS/core_cm4.h **** #define ITM_LSR_Access_Pos                  1U                                            /*!< ITM 
 896:../CMSIS/core_cm4.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 897:../CMSIS/core_cm4.h **** 
 898:../CMSIS/core_cm4.h **** #define ITM_LSR_Present_Pos                 0U                                            /*!< ITM 
 899:../CMSIS/core_cm4.h **** #define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM 
 900:../CMSIS/core_cm4.h **** 
 901:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_ITM */
 902:../CMSIS/core_cm4.h **** 
 903:../CMSIS/core_cm4.h **** 
 904:../CMSIS/core_cm4.h **** /**
 905:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 906:../CMSIS/core_cm4.h ****   \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
 907:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Data Watchpoint and Trace (DWT)
 908:../CMSIS/core_cm4.h ****   @{
 909:../CMSIS/core_cm4.h ****  */
 910:../CMSIS/core_cm4.h **** 
 911:../CMSIS/core_cm4.h **** /**
 912:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 913:../CMSIS/core_cm4.h ****  */
 914:../CMSIS/core_cm4.h **** typedef struct
 915:../CMSIS/core_cm4.h **** {
 916:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
 917:../CMSIS/core_cm4.h ****   __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
 918:../CMSIS/core_cm4.h ****   __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
 919:../CMSIS/core_cm4.h ****   __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Registe
 920:../CMSIS/core_cm4.h ****   __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
 921:../CMSIS/core_cm4.h ****   __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
 922:../CMSIS/core_cm4.h ****   __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Registe
 923:../CMSIS/core_cm4.h ****   __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register 
 924:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
 925:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
 926:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
 927:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
 928:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
 929:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
 930:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
 931:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[1U];
 932:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
 933:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
 934:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
 935:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[1U];
 936:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
 937:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
 938:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
 939:../CMSIS/core_cm4.h **** } DWT_Type;
 940:../CMSIS/core_cm4.h **** 
 941:../CMSIS/core_cm4.h **** /* DWT Control Register Definitions */
 942:../CMSIS/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTR
 943:../CMSIS/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTR
 944:../CMSIS/core_cm4.h **** 
 945:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTR
 946:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTR
 947:../CMSIS/core_cm4.h **** 
 948:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTR
 949:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTR
 950:../CMSIS/core_cm4.h **** 
 951:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTR
 952:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTR
 953:../CMSIS/core_cm4.h **** 
 954:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTR
 955:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTR
 956:../CMSIS/core_cm4.h **** 
 957:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTR
 958:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTR
 959:../CMSIS/core_cm4.h **** 
 960:../CMSIS/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTR
 961:../CMSIS/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTR
 962:../CMSIS/core_cm4.h **** 
 963:../CMSIS/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTR
 964:../CMSIS/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTR
 965:../CMSIS/core_cm4.h **** 
 966:../CMSIS/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTR
 967:../CMSIS/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTR
 968:../CMSIS/core_cm4.h **** 
 969:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTR
 970:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTR
 971:../CMSIS/core_cm4.h **** 
 972:../CMSIS/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTR
 973:../CMSIS/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTR
 974:../CMSIS/core_cm4.h **** 
 975:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTR
 976:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTR
 977:../CMSIS/core_cm4.h **** 
 978:../CMSIS/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTR
 979:../CMSIS/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTR
 980:../CMSIS/core_cm4.h **** 
 981:../CMSIS/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTR
 982:../CMSIS/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTR
 983:../CMSIS/core_cm4.h **** 
 984:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTR
 985:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTR
 986:../CMSIS/core_cm4.h **** 
 987:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTR
 988:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTR
 989:../CMSIS/core_cm4.h **** 
 990:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTR
 991:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTR
 992:../CMSIS/core_cm4.h **** 
 993:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTR
 994:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTR
 995:../CMSIS/core_cm4.h **** 
 996:../CMSIS/core_cm4.h **** /* DWT CPI Count Register Definitions */
 997:../CMSIS/core_cm4.h **** #define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPI
 998:../CMSIS/core_cm4.h **** #define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPI
 999:../CMSIS/core_cm4.h **** 
1000:../CMSIS/core_cm4.h **** /* DWT Exception Overhead Count Register Definitions */
1001:../CMSIS/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXC
1002:../CMSIS/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXC
1003:../CMSIS/core_cm4.h **** 
1004:../CMSIS/core_cm4.h **** /* DWT Sleep Count Register Definitions */
1005:../CMSIS/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLE
1006:../CMSIS/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLE
1007:../CMSIS/core_cm4.h **** 
1008:../CMSIS/core_cm4.h **** /* DWT LSU Count Register Definitions */
1009:../CMSIS/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSU
1010:../CMSIS/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSU
1011:../CMSIS/core_cm4.h **** 
1012:../CMSIS/core_cm4.h **** /* DWT Folded-instruction Count Register Definitions */
1013:../CMSIS/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOL
1014:../CMSIS/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOL
1015:../CMSIS/core_cm4.h **** 
1016:../CMSIS/core_cm4.h **** /* DWT Comparator Mask Register Definitions */
1017:../CMSIS/core_cm4.h **** #define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MAS
1018:../CMSIS/core_cm4.h **** #define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MAS
1019:../CMSIS/core_cm4.h **** 
1020:../CMSIS/core_cm4.h **** /* DWT Comparator Function Register Definitions */
1021:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUN
1022:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUN
1023:../CMSIS/core_cm4.h **** 
1024:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUN
1025:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUN
1026:../CMSIS/core_cm4.h **** 
1027:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUN
1028:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUN
1029:../CMSIS/core_cm4.h **** 
1030:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUN
1031:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUN
1032:../CMSIS/core_cm4.h **** 
1033:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUN
1034:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUN
1035:../CMSIS/core_cm4.h **** 
1036:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUN
1037:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUN
1038:../CMSIS/core_cm4.h **** 
1039:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUN
1040:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUN
1041:../CMSIS/core_cm4.h **** 
1042:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUN
1043:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUN
1044:../CMSIS/core_cm4.h **** 
1045:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUN
1046:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUN
1047:../CMSIS/core_cm4.h **** 
1048:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_DWT */
1049:../CMSIS/core_cm4.h **** 
1050:../CMSIS/core_cm4.h **** 
1051:../CMSIS/core_cm4.h **** /**
1052:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1053:../CMSIS/core_cm4.h ****   \defgroup CMSIS_TPI     Trace Port Interface (TPI)
1054:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Trace Port Interface (TPI)
1055:../CMSIS/core_cm4.h ****   @{
1056:../CMSIS/core_cm4.h ****  */
1057:../CMSIS/core_cm4.h **** 
1058:../CMSIS/core_cm4.h **** /**
1059:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Trace Port Interface Register (TPI).
1060:../CMSIS/core_cm4.h ****  */
1061:../CMSIS/core_cm4.h **** typedef struct
1062:../CMSIS/core_cm4.h **** {
1063:../CMSIS/core_cm4.h ****   __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Reg
1064:../CMSIS/core_cm4.h ****   __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Regis
1065:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[2U];
1066:../CMSIS/core_cm4.h ****   __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Reg
1067:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[55U];
1068:../CMSIS/core_cm4.h ****   __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *
1069:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[131U];
1070:../CMSIS/core_cm4.h ****   __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Regis
1071:../CMSIS/core_cm4.h ****   __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Regi
1072:../CMSIS/core_cm4.h ****   __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counte
1073:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[759U];
1074:../CMSIS/core_cm4.h ****   __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
1075:../CMSIS/core_cm4.h ****   __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
1076:../CMSIS/core_cm4.h ****   __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
1077:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[1U];
1078:../CMSIS/core_cm4.h ****   __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
1079:../CMSIS/core_cm4.h ****   __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
1080:../CMSIS/core_cm4.h ****   __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
1081:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[39U];
1082:../CMSIS/core_cm4.h ****   __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
1083:../CMSIS/core_cm4.h ****   __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
1084:../CMSIS/core_cm4.h ****         uint32_t RESERVED7[8U];
1085:../CMSIS/core_cm4.h ****   __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
1086:../CMSIS/core_cm4.h ****   __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
1087:../CMSIS/core_cm4.h **** } TPI_Type;
1088:../CMSIS/core_cm4.h **** 
1089:../CMSIS/core_cm4.h **** /* TPI Asynchronous Clock Prescaler Register Definitions */
1090:../CMSIS/core_cm4.h **** #define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACP
1091:../CMSIS/core_cm4.h **** #define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACP
1092:../CMSIS/core_cm4.h **** 
1093:../CMSIS/core_cm4.h **** /* TPI Selected Pin Protocol Register Definitions */
1094:../CMSIS/core_cm4.h **** #define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPP
1095:../CMSIS/core_cm4.h **** #define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPP
1096:../CMSIS/core_cm4.h **** 
1097:../CMSIS/core_cm4.h **** /* TPI Formatter and Flush Status Register Definitions */
1098:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFS
1099:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFS
1100:../CMSIS/core_cm4.h **** 
1101:../CMSIS/core_cm4.h **** #define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFS
1102:../CMSIS/core_cm4.h **** #define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFS
1103:../CMSIS/core_cm4.h **** 
1104:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFS
1105:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFS
1106:../CMSIS/core_cm4.h **** 
1107:../CMSIS/core_cm4.h **** #define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFS
1108:../CMSIS/core_cm4.h **** #define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFS
1109:../CMSIS/core_cm4.h **** 
1110:../CMSIS/core_cm4.h **** /* TPI Formatter and Flush Control Register Definitions */
1111:../CMSIS/core_cm4.h **** #define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFC
1112:../CMSIS/core_cm4.h **** #define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFC
1113:../CMSIS/core_cm4.h **** 
1114:../CMSIS/core_cm4.h **** #define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFC
1115:../CMSIS/core_cm4.h **** #define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFC
1116:../CMSIS/core_cm4.h **** 
1117:../CMSIS/core_cm4.h **** /* TPI TRIGGER Register Definitions */
1118:../CMSIS/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRI
1119:../CMSIS/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRI
1120:../CMSIS/core_cm4.h **** 
1121:../CMSIS/core_cm4.h **** /* TPI Integration ETM Data Register Definitions (FIFO0) */
1122:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1123:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIF
1124:../CMSIS/core_cm4.h **** 
1125:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1126:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIF
1127:../CMSIS/core_cm4.h **** 
1128:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1129:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIF
1130:../CMSIS/core_cm4.h **** 
1131:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1132:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIF
1133:../CMSIS/core_cm4.h **** 
1134:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIF
1135:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIF
1136:../CMSIS/core_cm4.h **** 
1137:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIF
1138:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIF
1139:../CMSIS/core_cm4.h **** 
1140:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIF
1141:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIF
1142:../CMSIS/core_cm4.h **** 
1143:../CMSIS/core_cm4.h **** /* TPI ITATBCTR2 Register Definitions */
1144:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITA
1145:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITA
1146:../CMSIS/core_cm4.h **** 
1147:../CMSIS/core_cm4.h **** /* TPI Integration ITM Data Register Definitions (FIFO1) */
1148:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1149:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIF
1150:../CMSIS/core_cm4.h **** 
1151:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1152:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIF
1153:../CMSIS/core_cm4.h **** 
1154:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1155:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIF
1156:../CMSIS/core_cm4.h **** 
1157:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1158:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIF
1159:../CMSIS/core_cm4.h **** 
1160:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIF
1161:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIF
1162:../CMSIS/core_cm4.h **** 
1163:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIF
1164:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIF
1165:../CMSIS/core_cm4.h **** 
1166:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIF
1167:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIF
1168:../CMSIS/core_cm4.h **** 
1169:../CMSIS/core_cm4.h **** /* TPI ITATBCTR0 Register Definitions */
1170:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITA
1171:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITA
1172:../CMSIS/core_cm4.h **** 
1173:../CMSIS/core_cm4.h **** /* TPI Integration Mode Control Register Definitions */
1174:../CMSIS/core_cm4.h **** #define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITC
1175:../CMSIS/core_cm4.h **** #define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITC
1176:../CMSIS/core_cm4.h **** 
1177:../CMSIS/core_cm4.h **** /* TPI DEVID Register Definitions */
1178:../CMSIS/core_cm4.h **** #define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEV
1179:../CMSIS/core_cm4.h **** #define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEV
1180:../CMSIS/core_cm4.h **** 
1181:../CMSIS/core_cm4.h **** #define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEV
1182:../CMSIS/core_cm4.h **** #define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEV
1183:../CMSIS/core_cm4.h **** 
1184:../CMSIS/core_cm4.h **** #define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEV
1185:../CMSIS/core_cm4.h **** #define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEV
1186:../CMSIS/core_cm4.h **** 
1187:../CMSIS/core_cm4.h **** #define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEV
1188:../CMSIS/core_cm4.h **** #define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEV
1189:../CMSIS/core_cm4.h **** 
1190:../CMSIS/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEV
1191:../CMSIS/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEV
1192:../CMSIS/core_cm4.h **** 
1193:../CMSIS/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEV
1194:../CMSIS/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEV
1195:../CMSIS/core_cm4.h **** 
1196:../CMSIS/core_cm4.h **** /* TPI DEVTYPE Register Definitions */
1197:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEV
1198:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEV
1199:../CMSIS/core_cm4.h **** 
1200:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEV
1201:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEV
1202:../CMSIS/core_cm4.h **** 
1203:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_TPI */
1204:../CMSIS/core_cm4.h **** 
1205:../CMSIS/core_cm4.h **** 
1206:../CMSIS/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1207:../CMSIS/core_cm4.h **** /**
1208:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1209:../CMSIS/core_cm4.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
1210:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
1211:../CMSIS/core_cm4.h ****   @{
1212:../CMSIS/core_cm4.h ****  */
1213:../CMSIS/core_cm4.h **** 
1214:../CMSIS/core_cm4.h **** /**
1215:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
1216:../CMSIS/core_cm4.h ****  */
1217:../CMSIS/core_cm4.h **** typedef struct
1218:../CMSIS/core_cm4.h **** {
1219:../CMSIS/core_cm4.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
1220:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
1221:../CMSIS/core_cm4.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
1222:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
1223:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
1224:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
1225:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
1226:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
1227:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
1228:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
1229:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
1230:../CMSIS/core_cm4.h **** } MPU_Type;
1231:../CMSIS/core_cm4.h **** 
1232:../CMSIS/core_cm4.h **** /* MPU Type Register Definitions */
1233:../CMSIS/core_cm4.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
1234:../CMSIS/core_cm4.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
1235:../CMSIS/core_cm4.h **** 
1236:../CMSIS/core_cm4.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
1237:../CMSIS/core_cm4.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
1238:../CMSIS/core_cm4.h **** 
1239:../CMSIS/core_cm4.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
1240:../CMSIS/core_cm4.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
1241:../CMSIS/core_cm4.h **** 
1242:../CMSIS/core_cm4.h **** /* MPU Control Register Definitions */
1243:../CMSIS/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
1244:../CMSIS/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
1245:../CMSIS/core_cm4.h **** 
1246:../CMSIS/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
1247:../CMSIS/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
1248:../CMSIS/core_cm4.h **** 
1249:../CMSIS/core_cm4.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
1250:../CMSIS/core_cm4.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
1251:../CMSIS/core_cm4.h **** 
1252:../CMSIS/core_cm4.h **** /* MPU Region Number Register Definitions */
1253:../CMSIS/core_cm4.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
1254:../CMSIS/core_cm4.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
1255:../CMSIS/core_cm4.h **** 
1256:../CMSIS/core_cm4.h **** /* MPU Region Base Address Register Definitions */
1257:../CMSIS/core_cm4.h **** #define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU 
1258:../CMSIS/core_cm4.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
1259:../CMSIS/core_cm4.h **** 
1260:../CMSIS/core_cm4.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
1261:../CMSIS/core_cm4.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
1262:../CMSIS/core_cm4.h **** 
1263:../CMSIS/core_cm4.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
1264:../CMSIS/core_cm4.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
1265:../CMSIS/core_cm4.h **** 
1266:../CMSIS/core_cm4.h **** /* MPU Region Attribute and Size Register Definitions */
1267:../CMSIS/core_cm4.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
1268:../CMSIS/core_cm4.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
1269:../CMSIS/core_cm4.h **** 
1270:../CMSIS/core_cm4.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
1271:../CMSIS/core_cm4.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
1272:../CMSIS/core_cm4.h **** 
1273:../CMSIS/core_cm4.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
1274:../CMSIS/core_cm4.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
1275:../CMSIS/core_cm4.h **** 
1276:../CMSIS/core_cm4.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
1277:../CMSIS/core_cm4.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
1278:../CMSIS/core_cm4.h **** 
1279:../CMSIS/core_cm4.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
1280:../CMSIS/core_cm4.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
1281:../CMSIS/core_cm4.h **** 
1282:../CMSIS/core_cm4.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
1283:../CMSIS/core_cm4.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
1284:../CMSIS/core_cm4.h **** 
1285:../CMSIS/core_cm4.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
1286:../CMSIS/core_cm4.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
1287:../CMSIS/core_cm4.h **** 
1288:../CMSIS/core_cm4.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
1289:../CMSIS/core_cm4.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
1290:../CMSIS/core_cm4.h **** 
1291:../CMSIS/core_cm4.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
1292:../CMSIS/core_cm4.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
1293:../CMSIS/core_cm4.h **** 
1294:../CMSIS/core_cm4.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
1295:../CMSIS/core_cm4.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
1296:../CMSIS/core_cm4.h **** 
1297:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_MPU */
1298:../CMSIS/core_cm4.h **** #endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
1299:../CMSIS/core_cm4.h **** 
1300:../CMSIS/core_cm4.h **** 
1301:../CMSIS/core_cm4.h **** /**
1302:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1303:../CMSIS/core_cm4.h ****   \defgroup CMSIS_FPU     Floating Point Unit (FPU)
1304:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Floating Point Unit (FPU)
1305:../CMSIS/core_cm4.h ****   @{
1306:../CMSIS/core_cm4.h ****  */
1307:../CMSIS/core_cm4.h **** 
1308:../CMSIS/core_cm4.h **** /**
1309:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Floating Point Unit (FPU).
1310:../CMSIS/core_cm4.h ****  */
1311:../CMSIS/core_cm4.h **** typedef struct
1312:../CMSIS/core_cm4.h **** {
1313:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
1314:../CMSIS/core_cm4.h ****   __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control R
1315:../CMSIS/core_cm4.h ****   __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address R
1316:../CMSIS/core_cm4.h ****   __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Co
1317:../CMSIS/core_cm4.h ****   __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 
1318:../CMSIS/core_cm4.h ****   __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 
1319:../CMSIS/core_cm4.h **** } FPU_Type;
1320:../CMSIS/core_cm4.h **** 
1321:../CMSIS/core_cm4.h **** /* Floating-Point Context Control Register Definitions */
1322:../CMSIS/core_cm4.h **** #define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCC
1323:../CMSIS/core_cm4.h **** #define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCC
1324:../CMSIS/core_cm4.h **** 
1325:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCC
1326:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCC
1327:../CMSIS/core_cm4.h **** 
1328:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCC
1329:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCC
1330:../CMSIS/core_cm4.h **** 
1331:../CMSIS/core_cm4.h **** #define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCC
1332:../CMSIS/core_cm4.h **** #define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCC
1333:../CMSIS/core_cm4.h **** 
1334:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCC
1335:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCC
1336:../CMSIS/core_cm4.h **** 
1337:../CMSIS/core_cm4.h **** #define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCC
1338:../CMSIS/core_cm4.h **** #define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCC
1339:../CMSIS/core_cm4.h **** 
1340:../CMSIS/core_cm4.h **** #define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCC
1341:../CMSIS/core_cm4.h **** #define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCC
1342:../CMSIS/core_cm4.h **** 
1343:../CMSIS/core_cm4.h **** #define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCC
1344:../CMSIS/core_cm4.h **** #define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCC
1345:../CMSIS/core_cm4.h **** 
1346:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCC
1347:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCC
1348:../CMSIS/core_cm4.h **** 
1349:../CMSIS/core_cm4.h **** /* Floating-Point Context Address Register Definitions */
1350:../CMSIS/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCA
1351:../CMSIS/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCA
1352:../CMSIS/core_cm4.h **** 
1353:../CMSIS/core_cm4.h **** /* Floating-Point Default Status Control Register Definitions */
1354:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDS
1355:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDS
1356:../CMSIS/core_cm4.h **** 
1357:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDS
1358:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDS
1359:../CMSIS/core_cm4.h **** 
1360:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDS
1361:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDS
1362:../CMSIS/core_cm4.h **** 
1363:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDS
1364:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDS
1365:../CMSIS/core_cm4.h **** 
1366:../CMSIS/core_cm4.h **** /* Media and FP Feature Register 0 Definitions */
1367:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR
1368:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR
1369:../CMSIS/core_cm4.h **** 
1370:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR
1371:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR
1372:../CMSIS/core_cm4.h **** 
1373:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR
1374:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR
1375:../CMSIS/core_cm4.h **** 
1376:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR
1377:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR
1378:../CMSIS/core_cm4.h **** 
1379:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR
1380:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR
1381:../CMSIS/core_cm4.h **** 
1382:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR
1383:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR
1384:../CMSIS/core_cm4.h **** 
1385:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR
1386:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR
1387:../CMSIS/core_cm4.h **** 
1388:../CMSIS/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR
1389:../CMSIS/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR
1390:../CMSIS/core_cm4.h **** 
1391:../CMSIS/core_cm4.h **** /* Media and FP Feature Register 1 Definitions */
1392:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR
1393:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR
1394:../CMSIS/core_cm4.h **** 
1395:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR
1396:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR
1397:../CMSIS/core_cm4.h **** 
1398:../CMSIS/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR
1399:../CMSIS/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR
1400:../CMSIS/core_cm4.h **** 
1401:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR
1402:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR
1403:../CMSIS/core_cm4.h **** 
1404:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_FPU */
1405:../CMSIS/core_cm4.h **** 
1406:../CMSIS/core_cm4.h **** 
1407:../CMSIS/core_cm4.h **** /**
1408:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1409:../CMSIS/core_cm4.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
1410:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Core Debug Registers
1411:../CMSIS/core_cm4.h ****   @{
1412:../CMSIS/core_cm4.h ****  */
1413:../CMSIS/core_cm4.h **** 
1414:../CMSIS/core_cm4.h **** /**
1415:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Core Debug Register (CoreDebug).
1416:../CMSIS/core_cm4.h ****  */
1417:../CMSIS/core_cm4.h **** typedef struct
1418:../CMSIS/core_cm4.h **** {
1419:../CMSIS/core_cm4.h ****   __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
1420:../CMSIS/core_cm4.h ****   __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
1421:../CMSIS/core_cm4.h ****   __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
1422:../CMSIS/core_cm4.h ****   __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
1423:../CMSIS/core_cm4.h **** } CoreDebug_Type;
1424:../CMSIS/core_cm4.h **** 
1425:../CMSIS/core_cm4.h **** /* Debug Halting Control and Status Register Definitions */
1426:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< Core
1427:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
1428:../CMSIS/core_cm4.h **** 
1429:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< Core
1430:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
1431:../CMSIS/core_cm4.h **** 
1432:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< Core
1433:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
1434:../CMSIS/core_cm4.h **** 
1435:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< Core
1436:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
1437:../CMSIS/core_cm4.h **** 
1438:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< Core
1439:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
1440:../CMSIS/core_cm4.h **** 
1441:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< Core
1442:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
1443:../CMSIS/core_cm4.h **** 
1444:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< Core
1445:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
1446:../CMSIS/core_cm4.h **** 
1447:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< Core
1448:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
1449:../CMSIS/core_cm4.h **** 
1450:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< Core
1451:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
1452:../CMSIS/core_cm4.h **** 
1453:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< Core
1454:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
1455:../CMSIS/core_cm4.h **** 
1456:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< Core
1457:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
1458:../CMSIS/core_cm4.h **** 
1459:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< Core
1460:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< Core
1461:../CMSIS/core_cm4.h **** 
1462:../CMSIS/core_cm4.h **** /* Debug Core Register Selector Register Definitions */
1463:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< Core
1464:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
1465:../CMSIS/core_cm4.h **** 
1466:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< Core
1467:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< Core
1468:../CMSIS/core_cm4.h **** 
1469:../CMSIS/core_cm4.h **** /* Debug Exception and Monitor Control Register Definitions */
1470:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< Core
1471:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
1472:../CMSIS/core_cm4.h **** 
1473:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< Core
1474:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
1475:../CMSIS/core_cm4.h **** 
1476:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< Core
1477:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
1478:../CMSIS/core_cm4.h **** 
1479:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< Core
1480:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
1481:../CMSIS/core_cm4.h **** 
1482:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< Core
1483:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
1484:../CMSIS/core_cm4.h **** 
1485:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< Core
1486:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
1487:../CMSIS/core_cm4.h **** 
1488:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< Core
1489:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
1490:../CMSIS/core_cm4.h **** 
1491:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< Core
1492:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
1493:../CMSIS/core_cm4.h **** 
1494:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< Core
1495:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
1496:../CMSIS/core_cm4.h **** 
1497:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< Core
1498:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
1499:../CMSIS/core_cm4.h **** 
1500:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< Core
1501:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
1502:../CMSIS/core_cm4.h **** 
1503:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< Core
1504:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
1505:../CMSIS/core_cm4.h **** 
1506:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< Core
1507:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< Core
1508:../CMSIS/core_cm4.h **** 
1509:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_CoreDebug */
1510:../CMSIS/core_cm4.h **** 
1511:../CMSIS/core_cm4.h **** 
1512:../CMSIS/core_cm4.h **** /**
1513:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
1514:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
1515:../CMSIS/core_cm4.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
1516:../CMSIS/core_cm4.h ****   @{
1517:../CMSIS/core_cm4.h ****  */
1518:../CMSIS/core_cm4.h **** 
1519:../CMSIS/core_cm4.h **** /**
1520:../CMSIS/core_cm4.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
1521:../CMSIS/core_cm4.h ****   \param[in] field  Name of the register bit field.
1522:../CMSIS/core_cm4.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
1523:../CMSIS/core_cm4.h ****   \return           Masked and shifted value.
1524:../CMSIS/core_cm4.h **** */
1525:../CMSIS/core_cm4.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
1526:../CMSIS/core_cm4.h **** 
1527:../CMSIS/core_cm4.h **** /**
1528:../CMSIS/core_cm4.h ****   \brief     Mask and shift a register value to extract a bit filed value.
1529:../CMSIS/core_cm4.h ****   \param[in] field  Name of the register bit field.
1530:../CMSIS/core_cm4.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
1531:../CMSIS/core_cm4.h ****   \return           Masked and shifted bit field value.
1532:../CMSIS/core_cm4.h **** */
1533:../CMSIS/core_cm4.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
1534:../CMSIS/core_cm4.h **** 
1535:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_core_bitfield */
1536:../CMSIS/core_cm4.h **** 
1537:../CMSIS/core_cm4.h **** 
1538:../CMSIS/core_cm4.h **** /**
1539:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
1540:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_core_base     Core Definitions
1541:../CMSIS/core_cm4.h ****   \brief      Definitions for base addresses, unions, and structures.
1542:../CMSIS/core_cm4.h ****   @{
1543:../CMSIS/core_cm4.h ****  */
1544:../CMSIS/core_cm4.h **** 
1545:../CMSIS/core_cm4.h **** /* Memory mapping of Core Hardware */
1546:../CMSIS/core_cm4.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
1547:../CMSIS/core_cm4.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
1548:../CMSIS/core_cm4.h **** #define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
1549:../CMSIS/core_cm4.h **** #define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
1550:../CMSIS/core_cm4.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
1551:../CMSIS/core_cm4.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
1552:../CMSIS/core_cm4.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
1553:../CMSIS/core_cm4.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
1554:../CMSIS/core_cm4.h **** 
1555:../CMSIS/core_cm4.h **** #define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register 
1556:../CMSIS/core_cm4.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
1557:../CMSIS/core_cm4.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
1558:../CMSIS/core_cm4.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
1559:../CMSIS/core_cm4.h **** #define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct
1560:../CMSIS/core_cm4.h **** #define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct
1561:../CMSIS/core_cm4.h **** #define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct
1562:../CMSIS/core_cm4.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
1563:../CMSIS/core_cm4.h **** 
1564:../CMSIS/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1565:../CMSIS/core_cm4.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
1566:../CMSIS/core_cm4.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
1567:../CMSIS/core_cm4.h **** #endif
1568:../CMSIS/core_cm4.h **** 
1569:../CMSIS/core_cm4.h **** #define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
1570:../CMSIS/core_cm4.h **** #define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
1571:../CMSIS/core_cm4.h **** 
1572:../CMSIS/core_cm4.h **** /*@} */
1573:../CMSIS/core_cm4.h **** 
1574:../CMSIS/core_cm4.h **** 
1575:../CMSIS/core_cm4.h **** 
1576:../CMSIS/core_cm4.h **** /*******************************************************************************
1577:../CMSIS/core_cm4.h ****  *                Hardware Abstraction Layer
1578:../CMSIS/core_cm4.h ****   Core Function Interface contains:
1579:../CMSIS/core_cm4.h ****   - Core NVIC Functions
1580:../CMSIS/core_cm4.h ****   - Core SysTick Functions
1581:../CMSIS/core_cm4.h ****   - Core Debug Functions
1582:../CMSIS/core_cm4.h ****   - Core Register Access Functions
1583:../CMSIS/core_cm4.h ****  ******************************************************************************/
1584:../CMSIS/core_cm4.h **** /**
1585:../CMSIS/core_cm4.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
1586:../CMSIS/core_cm4.h **** */
1587:../CMSIS/core_cm4.h **** 
1588:../CMSIS/core_cm4.h **** 
1589:../CMSIS/core_cm4.h **** 
1590:../CMSIS/core_cm4.h **** /* ##########################   NVIC functions  #################################### */
1591:../CMSIS/core_cm4.h **** /**
1592:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_Core_FunctionInterface
1593:../CMSIS/core_cm4.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
1594:../CMSIS/core_cm4.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
1595:../CMSIS/core_cm4.h ****   @{
1596:../CMSIS/core_cm4.h ****  */
1597:../CMSIS/core_cm4.h **** 
1598:../CMSIS/core_cm4.h **** #ifdef CMSIS_NVIC_VIRTUAL
1599:../CMSIS/core_cm4.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
1600:../CMSIS/core_cm4.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
1601:../CMSIS/core_cm4.h ****   #endif
1602:../CMSIS/core_cm4.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
1603:../CMSIS/core_cm4.h **** #else
1604:../CMSIS/core_cm4.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
1605:../CMSIS/core_cm4.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
1606:../CMSIS/core_cm4.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
1607:../CMSIS/core_cm4.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
1608:../CMSIS/core_cm4.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
1609:../CMSIS/core_cm4.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
1610:../CMSIS/core_cm4.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
1611:../CMSIS/core_cm4.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
1612:../CMSIS/core_cm4.h ****   #define NVIC_GetActive              __NVIC_GetActive
1613:../CMSIS/core_cm4.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
1614:../CMSIS/core_cm4.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
1615:../CMSIS/core_cm4.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
1616:../CMSIS/core_cm4.h **** #endif /* CMSIS_NVIC_VIRTUAL */
1617:../CMSIS/core_cm4.h **** 
1618:../CMSIS/core_cm4.h **** #ifdef CMSIS_VECTAB_VIRTUAL
1619:../CMSIS/core_cm4.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1620:../CMSIS/core_cm4.h ****    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
1621:../CMSIS/core_cm4.h ****   #endif
1622:../CMSIS/core_cm4.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1623:../CMSIS/core_cm4.h **** #else
1624:../CMSIS/core_cm4.h ****   #define NVIC_SetVector              __NVIC_SetVector
1625:../CMSIS/core_cm4.h ****   #define NVIC_GetVector              __NVIC_GetVector
1626:../CMSIS/core_cm4.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
1627:../CMSIS/core_cm4.h **** 
1628:../CMSIS/core_cm4.h **** #define NVIC_USER_IRQ_OFFSET          16
1629:../CMSIS/core_cm4.h **** 
1630:../CMSIS/core_cm4.h **** 
1631:../CMSIS/core_cm4.h **** 
1632:../CMSIS/core_cm4.h **** /**
1633:../CMSIS/core_cm4.h ****   \brief   Set Priority Grouping
1634:../CMSIS/core_cm4.h ****   \details Sets the priority grouping field using the required unlock sequence.
1635:../CMSIS/core_cm4.h ****            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
1636:../CMSIS/core_cm4.h ****            Only values from 0..7 are used.
1637:../CMSIS/core_cm4.h ****            In case of a conflict between priority grouping and available
1638:../CMSIS/core_cm4.h ****            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
1639:../CMSIS/core_cm4.h ****   \param [in]      PriorityGroup  Priority grouping field.
1640:../CMSIS/core_cm4.h ****  */
1641:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
1642:../CMSIS/core_cm4.h **** {
1643:../CMSIS/core_cm4.h ****   uint32_t reg_value;
1644:../CMSIS/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 a
1645:../CMSIS/core_cm4.h **** 
1646:../CMSIS/core_cm4.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
1647:../CMSIS/core_cm4.h ****   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to chan
1648:../CMSIS/core_cm4.h ****   reg_value  =  (reg_value                                   |
1649:../CMSIS/core_cm4.h ****                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
1650:../CMSIS/core_cm4.h ****                 (PriorityGroupTmp << 8U)                      );              /* Insert write key a
1651:../CMSIS/core_cm4.h ****   SCB->AIRCR =  reg_value;
1652:../CMSIS/core_cm4.h **** }
1653:../CMSIS/core_cm4.h **** 
1654:../CMSIS/core_cm4.h **** 
1655:../CMSIS/core_cm4.h **** /**
1656:../CMSIS/core_cm4.h ****   \brief   Get Priority Grouping
1657:../CMSIS/core_cm4.h ****   \details Reads the priority grouping field from the NVIC Interrupt Controller.
1658:../CMSIS/core_cm4.h ****   \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
1659:../CMSIS/core_cm4.h ****  */
1660:../CMSIS/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
1661:../CMSIS/core_cm4.h **** {
1662:../CMSIS/core_cm4.h ****   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
1663:../CMSIS/core_cm4.h **** }
1664:../CMSIS/core_cm4.h **** 
1665:../CMSIS/core_cm4.h **** 
1666:../CMSIS/core_cm4.h **** /**
1667:../CMSIS/core_cm4.h ****   \brief   Enable Interrupt
1668:../CMSIS/core_cm4.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
1669:../CMSIS/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1670:../CMSIS/core_cm4.h ****   \note    IRQn must not be negative.
1671:../CMSIS/core_cm4.h ****  */
1672:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
1673:../CMSIS/core_cm4.h **** {
1674:../CMSIS/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1675:../CMSIS/core_cm4.h ****   {
1676:../CMSIS/core_cm4.h ****     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) &
1677:../CMSIS/core_cm4.h ****   }
1678:../CMSIS/core_cm4.h **** }
1679:../CMSIS/core_cm4.h **** 
1680:../CMSIS/core_cm4.h **** 
1681:../CMSIS/core_cm4.h **** /**
1682:../CMSIS/core_cm4.h ****   \brief   Get Interrupt Enable status
1683:../CMSIS/core_cm4.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
1684:../CMSIS/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1685:../CMSIS/core_cm4.h ****   \return             0  Interrupt is not enabled.
1686:../CMSIS/core_cm4.h ****   \return             1  Interrupt is enabled.
1687:../CMSIS/core_cm4.h ****   \note    IRQn must not be negative.
1688:../CMSIS/core_cm4.h ****  */
1689:../CMSIS/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
1690:../CMSIS/core_cm4.h **** {
1691:../CMSIS/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1692:../CMSIS/core_cm4.h ****   {
1693:../CMSIS/core_cm4.h ****     return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32
1694:../CMSIS/core_cm4.h ****   }
1695:../CMSIS/core_cm4.h ****   else
1696:../CMSIS/core_cm4.h ****   {
1697:../CMSIS/core_cm4.h ****     return(0U);
1698:../CMSIS/core_cm4.h ****   }
1699:../CMSIS/core_cm4.h **** }
1700:../CMSIS/core_cm4.h **** 
1701:../CMSIS/core_cm4.h **** 
1702:../CMSIS/core_cm4.h **** /**
1703:../CMSIS/core_cm4.h ****   \brief   Disable Interrupt
1704:../CMSIS/core_cm4.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
1705:../CMSIS/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1706:../CMSIS/core_cm4.h ****   \note    IRQn must not be negative.
1707:../CMSIS/core_cm4.h ****  */
1708:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
1709:../CMSIS/core_cm4.h **** {
1710:../CMSIS/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
 3287              		.loc 5 1710 0
 3288 002a 002E     		cmp	r6, #0
 3289 002c 0BDB     		blt	.L320
1711:../CMSIS/core_cm4.h ****   {
1712:../CMSIS/core_cm4.h ****     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) &
 3290              		.loc 5 1712 0
 3291 002e 06F01F01 		and	r1, r6, #31
 3292              	.LVL365:
 3293 0032 7309     		lsrs	r3, r6, #5
 3294 0034 8A40     		lsls	r2, r2, r1
 3295 0036 2033     		adds	r3, r3, #32
 3296 0038 4349     		ldr	r1, .L331+4
 3297 003a 41F82320 		str	r2, [r1, r3, lsl #2]
 3298              	.LBB534:
 3299              	.LBB535:
 3300              		.loc 3 833 0
 3301              		.syntax unified
 3302              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 3303 003e BFF34F8F 		dsb 0xF
 3304              	@ 0 "" 2
 3305              		.thumb
 3306              		.syntax unified
 3307              	.LBE535:
 3308              	.LBE534:
 3309              	.LBB536:
 3310              	.LBB537:
 822:../CMSIS/cmsis_gcc.h **** }
 3311              		.loc 3 822 0
 3312              		.syntax unified
 3313              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 3314 0042 BFF36F8F 		isb 0xF
 3315              	@ 0 "" 2
 3316              		.thumb
 3317              		.syntax unified
 3318              	.L320:
 3319              	.LVL366:
 3320              	.LBE537:
 3321              	.LBE536:
 3322              	.LBE533:
 3323              	.LBE532:
 3324              	.LBE531:
 3325              	.LBB538:
 3326              	.LBB539:
 3327              	.LBB540:
 3328              	.LBB541:
 753:../drivers/fsl_dspi.h **** }
 3329              		.loc 2 753 0
 3330 0046 2368     		ldr	r3, [r4]
 3331              	.LBE541:
 3332              	.LBE540:
 866:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 3333              		.loc 1 866 0
 3334 0048 D7F80C90 		ldr	r9, [r7, #12]
 3335              	.LBB543:
 3336              	.LBB542:
 753:../drivers/fsl_dspi.h **** }
 3337              		.loc 2 753 0
 3338 004c 43F00103 		orr	r3, r3, #1
 3339 0050 2360     		str	r3, [r4]
 3340              	.LVL367:
 3341              	.LBE542:
 3342              	.LBE543:
 3343              	.LBB544:
 3344              	.LBB545:
 782:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 3345              		.loc 2 782 0
 3346 0052 2368     		ldr	r3, [r4]
 3347 0054 43F44063 		orr	r3, r3, #3072
 3348 0058 2360     		str	r3, [r4]
 3349              	.LVL368:
 3350              	.LBE545:
 3351              	.LBE544:
 3352              	.LBB546:
 3353              	.LBB547:
 580:../drivers/fsl_dspi.h **** }
 3354              		.loc 2 580 0
 3355 005a 3C4B     		ldr	r3, .L331+8
 3356 005c E362     		str	r3, [r4, #44]
 3357              	.LVL369:
 3358              	.LBE547:
 3359              	.LBE546:
 866:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 3360              		.loc 1 866 0
 3361 005e 0121     		movs	r1, #1
 3362 0060 C9F30313 		ubfx	r3, r9, #4, #4
 3363 0064 01FA03F3 		lsl	r3, r1, r3
 871:../drivers/fsl_dspi.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 3364              		.loc 1 871 0
 3365 0068 0DF1080A 		add	r10, sp, #8
 866:../drivers/fsl_dspi.c ****     commandStruct.isEndOfQueue = false;
 3366              		.loc 1 866 0
 3367 006c 8DF80230 		strb	r3, [sp, #2]
 867:../drivers/fsl_dspi.c ****     commandStruct.clearTransferCount = false;
 3368              		.loc 1 867 0
 3369 0070 0023     		movs	r3, #0
 3370 0072 8DF80330 		strb	r3, [sp, #3]
 868:../drivers/fsl_dspi.c ****     commandStruct.whichCtar =
 3371              		.loc 1 868 0
 3372 0076 8DF80430 		strb	r3, [sp, #4]
 871:../drivers/fsl_dspi.c ****     handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
 3373              		.loc 1 871 0
 3374 007a C9F30053 		ubfx	r3, r9, #20, #1
 3375 007e 0AF8083D 		strb	r3, [r10, #-8]!
 870:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
 3376              		.loc 1 870 0
 3377 0082 09F00F08 		and	r8, r9, #15
 872:../drivers/fsl_dspi.c **** 
 3378              		.loc 1 872 0
 3379 0086 5046     		mov	r0, r10
 869:../drivers/fsl_dspi.c ****         (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR
 3380              		.loc 1 869 0
 3381 0088 8DF80180 		strb	r8, [sp, #1]
 872:../drivers/fsl_dspi.c **** 
 3382              		.loc 1 872 0
 3383 008c FFF7FEFF 		bl	DSPI_MasterGetFormattedCommand.constprop.4
 3384              	.LVL370:
 875:../drivers/fsl_dspi.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 3385              		.loc 1 875 0
 3386 0090 C9F34059 		ubfx	r9, r9, #21, #1
 872:../drivers/fsl_dspi.c **** 
 3387              		.loc 1 872 0
 3388 0094 6860     		str	r0, [r5, #4]
 876:../drivers/fsl_dspi.c **** 
 3389              		.loc 1 876 0
 3390 0096 5046     		mov	r0, r10
 874:../drivers/fsl_dspi.c ****     commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer)
 3391              		.loc 1 874 0
 3392 0098 8DF80310 		strb	r1, [sp, #3]
 875:../drivers/fsl_dspi.c ****     handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
 3393              		.loc 1 875 0
 3394 009c 8DF80090 		strb	r9, [sp]
 876:../drivers/fsl_dspi.c **** 
 3395              		.loc 1 876 0
 3396 00a0 FFF7FEFF 		bl	DSPI_MasterGetFormattedCommand.constprop.4
 3397              	.LVL371:
 878:../drivers/fsl_dspi.c **** 
 3398              		.loc 1 878 0
 3399 00a4 08F10208 		add	r8, r8, #2
 3400 00a8 04EB8808 		add	r8, r4, r8, lsl #2
 876:../drivers/fsl_dspi.c **** 
 3401              		.loc 1 876 0
 3402 00ac A860     		str	r0, [r5, #8]
 878:../drivers/fsl_dspi.c **** 
 3403              		.loc 1 878 0
 3404 00ae D8F80430 		ldr	r3, [r8, #4]
 3405 00b2 C3F3C363 		ubfx	r3, r3, #27, #4
 3406 00b6 0133     		adds	r3, r3, #1
 3407 00b8 2B60     		str	r3, [r5]
 880:../drivers/fsl_dspi.c ****     {
 3408              		.loc 1 880 0
 3409 00ba 2368     		ldr	r3, [r4]
 3410 00bc DA04     		lsls	r2, r3, #19
 3411 00be 02D4     		bmi	.L321
 3412 00c0 2368     		ldr	r3, [r4]
 3413 00c2 9B04     		lsls	r3, r3, #18
 3414 00c4 27D5     		bpl	.L322
 3415              	.L321:
 882:../drivers/fsl_dspi.c ****     }
 3416              		.loc 1 882 0
 3417 00c6 0123     		movs	r3, #1
 3418 00c8 2B73     		strb	r3, [r5, #12]
 3419              	.L323:
 888:../drivers/fsl_dspi.c ****     handle->rxData = transfer->rxData;
 3420              		.loc 1 888 0
 3421 00ca 3B68     		ldr	r3, [r7]
 3422 00cc 2B61     		str	r3, [r5, #16]
 889:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = transfer->dataSize;
 3423              		.loc 1 889 0
 3424 00ce 7B68     		ldr	r3, [r7, #4]
 3425 00d0 6B61     		str	r3, [r5, #20]
 890:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 3426              		.loc 1 890 0
 3427 00d2 BB68     		ldr	r3, [r7, #8]
 3428 00d4 AB61     		str	r3, [r5, #24]
 891:../drivers/fsl_dspi.c ****     handle->totalByteCount = transfer->dataSize;
 3429              		.loc 1 891 0
 3430 00d6 BB68     		ldr	r3, [r7, #8]
 3431 00d8 EB61     		str	r3, [r5, #28]
 892:../drivers/fsl_dspi.c **** }
 3432              		.loc 1 892 0
 3433 00da BB68     		ldr	r3, [r7, #8]
 3434 00dc 2B62     		str	r3, [r5, #32]
 3435              	.LVL372:
 3436              	.LBE539:
 3437              	.LBE538:
 923:../drivers/fsl_dspi.c **** 
 3438              		.loc 1 923 0
 3439 00de 1C4B     		ldr	r3, .L331+12
 3440 00e0 1C4A     		ldr	r2, .L331+16
 3441 00e2 1A60     		str	r2, [r3]
 925:../drivers/fsl_dspi.c ****     DSPI_StartTransfer(base);
 3442              		.loc 1 925 0
 3443 00e4 4FF40031 		mov	r1, #131072
 3444 00e8 2046     		mov	r0, r4
 3445 00ea FFF7FEFF 		bl	DSPI_EnableInterrupts
 3446              	.LVL373:
 3447              	.LBB549:
 3448              	.LBB550:
 742:../drivers/fsl_dspi.h **** }
 3449              		.loc 2 742 0
 3450 00ee 2368     		ldr	r3, [r4]
 3451 00f0 23F00103 		bic	r3, r3, #1
 3452 00f4 2360     		str	r3, [r4]
 3453              	.LVL374:
 3454              	.LBE550:
 3455              	.LBE549:
 929:../drivers/fsl_dspi.c **** 
 3456              		.loc 1 929 0
 3457 00f6 2946     		mov	r1, r5
 3458 00f8 FFF7FEFF 		bl	DSPI_MasterTransferFillUpTxFifo
 3459              	.LVL375:
 3460              	.LBB551:
 3461              	.LBB552:
 3462              	.LBB553:
1674:../CMSIS/core_cm4.h ****   {
 3463              		.loc 5 1674 0
 3464 00fc 002E     		cmp	r6, #0
 3465 00fe 08DB     		blt	.L330
 3466              	.LVL376:
1676:../CMSIS/core_cm4.h ****   }
 3467              		.loc 5 1676 0
 3468 0100 7209     		lsrs	r2, r6, #5
 3469 0102 0123     		movs	r3, #1
 3470 0104 06F01F06 		and	r6, r6, #31
 3471              	.LVL377:
 3472 0108 03FA06F6 		lsl	r6, r3, r6
 3473 010c 0E4B     		ldr	r3, .L331+4
 3474 010e 43F82260 		str	r6, [r3, r2, lsl #2]
 3475              	.L330:
1674:../CMSIS/core_cm4.h ****   {
 3476              		.loc 5 1674 0
 3477 0112 0020     		movs	r0, #0
 3478 0114 10E0     		b	.L318
 3479              	.LVL378:
 3480              	.L322:
 3481              	.LBE553:
 3482              	.LBE552:
 3483              	.LBE551:
 3484              	.LBB554:
 3485              	.LBB548:
 886:../drivers/fsl_dspi.c ****     }
 3486              		.loc 1 886 0
 3487 0116 104B     		ldr	r3, .L331+20
 3488 0118 9C42     		cmp	r4, r3
 3489 011a 0AD0     		beq	.L327
 3490 011c 03F58053 		add	r3, r3, #4096
 3491 0120 9C42     		cmp	r4, r3
 3492 0122 04D0     		beq	.L324
 3493 0124 0D49     		ldr	r1, .L331+24
 3494 0126 8C42     		cmp	r4, r1
 3495 0128 14BF     		ite	ne
 3496 012a FF21     		movne	r1, #255
 3497 012c 0121     		moveq	r1, #1
 3498              	.L324:
 3499 012e 2973     		strb	r1, [r5, #12]
 3500 0130 CBE7     		b	.L323
 3501              	.L327:
 3502 0132 0421     		movs	r1, #4
 3503 0134 FBE7     		b	.L324
 3504              	.LVL379:
 3505              	.L325:
 3506              	.LBE548:
 3507              	.LBE554:
 3508              	.LBE530:
 3509              	.LBE529:
 903:../drivers/fsl_dspi.c ****     }
 3510              		.loc 1 903 0
 3511 0136 0420     		movs	r0, #4
 3512              	.LVL380:
 3513              	.L318:
 935:../drivers/fsl_dspi.c **** 
 3514              		.loc 1 935 0
 3515 0138 02B0     		add	sp, sp, #8
 3516              		.cfi_remember_state
 3517              		.cfi_def_cfa_offset 32
 3518              		@ sp needed
 3519 013a BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 3520              	.LVL381:
 3521              	.L326:
 3522              		.cfi_restore_state
 909:../drivers/fsl_dspi.c ****     }
 3523              		.loc 1 909 0
 3524 013e 4FF41670 		mov	r0, #600
 3525              	.LVL382:
 3526 0142 F9E7     		b	.L318
 3527              	.L332:
 3528              		.align	2
 3529              	.L331:
 3530 0144 00000000 		.word	.LANCHOR9
 3531 0148 00E100E0 		.word	-536813312
 3532 014c 00000ADA 		.word	-636878848
 3533 0150 00000000 		.word	.LANCHOR0
 3534 0154 00000000 		.word	DSPI_MasterTransferHandleIRQ
 3535 0158 00C00240 		.word	1073922048
 3536 015c 00C00A40 		.word	1074446336
 3537              		.cfi_endproc
 3538              	.LFE186:
 3540              		.section	.text.DSPI_MasterHalfDuplexTransferBlocking,"ax",%progbits
 3541              		.align	1
 3542              		.global	DSPI_MasterHalfDuplexTransferBlocking
 3543              		.syntax unified
 3544              		.thumb
 3545              		.thumb_func
 3546              		.fpu fpv4-sp-d16
 3548              	DSPI_MasterHalfDuplexTransferBlocking:
 3549              	.LFB187:
 938:../drivers/fsl_dspi.c ****     assert(xfer);
 3550              		.loc 1 938 0
 3551              		.cfi_startproc
 3552              		@ args = 0, pretend = 0, frame = 16
 3553              		@ frame_needed = 0, uses_anonymous_args = 0
 3554              	.LVL383:
 3555 0000 30B5     		push	{r4, r5, lr}
 3556              		.cfi_def_cfa_offset 12
 3557              		.cfi_offset 4, -12
 3558              		.cfi_offset 5, -8
 3559              		.cfi_offset 14, -4
 3560 0002 0C46     		mov	r4, r1
 3561 0004 85B0     		sub	sp, sp, #20
 3562              		.cfi_def_cfa_offset 32
 938:../drivers/fsl_dspi.c ****     assert(xfer);
 3563              		.loc 1 938 0
 3564 0006 0546     		mov	r5, r0
 941:../drivers/fsl_dspi.c ****     status_t status;
 3565              		.loc 1 941 0
 3566 0008 1022     		movs	r2, #16
 3567 000a 0021     		movs	r1, #0
 3568              	.LVL384:
 3569 000c 6846     		mov	r0, sp
 3570              	.LVL385:
 3571 000e FFF7FEFF 		bl	memset
 3572              	.LVL386:
 944:../drivers/fsl_dspi.c ****     {
 3573              		.loc 1 944 0
 3574 0012 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 3575 0014 EBB1     		cbz	r3, .L334
 946:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
 3576              		.loc 1 946 0
 3577 0016 2368     		ldr	r3, [r4]
 3578 0018 0093     		str	r3, [sp]
 948:../drivers/fsl_dspi.c ****     }
 3579              		.loc 1 948 0
 3580 001a A368     		ldr	r3, [r4, #8]
 3581              	.L341:
 957:../drivers/fsl_dspi.c ****     {
 3582              		.loc 1 957 0
 3583 001c 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 954:../drivers/fsl_dspi.c ****     }
 3584              		.loc 1 954 0
 3585 001e 0293     		str	r3, [sp, #8]
 3586 0020 2369     		ldr	r3, [r4, #16]
 957:../drivers/fsl_dspi.c ****     {
 3587              		.loc 1 957 0
 3588 0022 D2B1     		cbz	r2, .L336
 959:../drivers/fsl_dspi.c ****     }
 3589              		.loc 1 959 0
 3590 0024 43F40013 		orr	r3, r3, #2097152
 3591              	.L342:
 966:../drivers/fsl_dspi.c ****     if (status != kStatus_Success)
 3592              		.loc 1 966 0
 3593 0028 6946     		mov	r1, sp
 3594 002a 2846     		mov	r0, r5
 963:../drivers/fsl_dspi.c ****     }
 3595              		.loc 1 963 0
 3596 002c 0393     		str	r3, [sp, #12]
 966:../drivers/fsl_dspi.c ****     if (status != kStatus_Success)
 3597              		.loc 1 966 0
 3598 002e FFF7FEFF 		bl	DSPI_MasterTransferBlocking
 3599              	.LVL387:
 967:../drivers/fsl_dspi.c ****     {
 3600              		.loc 1 967 0
 3601 0032 60B9     		cbnz	r0, .L333
 972:../drivers/fsl_dspi.c ****     {
 3602              		.loc 1 972 0
 3603 0034 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 3604 0036 9BB1     		cbz	r3, .L339
 975:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
 3605              		.loc 1 975 0
 3606 0038 6368     		ldr	r3, [r4, #4]
 3607 003a 0193     		str	r3, [sp, #4]
 976:../drivers/fsl_dspi.c ****     }
 3608              		.loc 1 976 0
 3609 003c E368     		ldr	r3, [r4, #12]
 974:../drivers/fsl_dspi.c ****         tempXfer.rxData = xfer->rxData;
 3610              		.loc 1 974 0
 3611 003e 0090     		str	r0, [sp]
 3612              	.L343:
 982:../drivers/fsl_dspi.c ****     }
 3613              		.loc 1 982 0
 3614 0040 0293     		str	r3, [sp, #8]
 987:../drivers/fsl_dspi.c **** 
 3615              		.loc 1 987 0
 3616 0042 6946     		mov	r1, sp
 984:../drivers/fsl_dspi.c **** 
 3617              		.loc 1 984 0
 3618 0044 2369     		ldr	r3, [r4, #16]
 3619 0046 0393     		str	r3, [sp, #12]
 987:../drivers/fsl_dspi.c **** 
 3620              		.loc 1 987 0
 3621 0048 2846     		mov	r0, r5
 3622              	.LVL388:
 3623 004a FFF7FEFF 		bl	DSPI_MasterTransferBlocking
 3624              	.LVL389:
 3625              	.L333:
 990:../drivers/fsl_dspi.c **** 
 3626              		.loc 1 990 0
 3627 004e 05B0     		add	sp, sp, #20
 3628              		.cfi_remember_state
 3629              		.cfi_def_cfa_offset 12
 3630              		@ sp needed
 3631 0050 30BD     		pop	{r4, r5, pc}
 3632              	.LVL390:
 3633              	.L334:
 3634              		.cfi_restore_state
 953:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
 3635              		.loc 1 953 0
 3636 0052 6368     		ldr	r3, [r4, #4]
 3637 0054 0193     		str	r3, [sp, #4]
 954:../drivers/fsl_dspi.c ****     }
 3638              		.loc 1 954 0
 3639 0056 E368     		ldr	r3, [r4, #12]
 3640 0058 E0E7     		b	.L341
 3641              	.L336:
 963:../drivers/fsl_dspi.c ****     }
 3642              		.loc 1 963 0
 3643 005a 23F40013 		bic	r3, r3, #2097152
 3644 005e E3E7     		b	.L342
 3645              	.LVL391:
 3646              	.L339:
 980:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
 3647              		.loc 1 980 0
 3648 0060 2268     		ldr	r2, [r4]
 981:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->txDataSize;
 3649              		.loc 1 981 0
 3650 0062 CDE90023 		strd	r2, r3, [sp]
 982:../drivers/fsl_dspi.c ****     }
 3651              		.loc 1 982 0
 3652 0066 A368     		ldr	r3, [r4, #8]
 3653 0068 EAE7     		b	.L343
 3654              		.cfi_endproc
 3655              	.LFE187:
 3657              		.section	.text.DSPI_MasterHalfDuplexTransferNonBlocking,"ax",%progbits
 3658              		.align	1
 3659              		.global	DSPI_MasterHalfDuplexTransferNonBlocking
 3660              		.syntax unified
 3661              		.thumb
 3662              		.thumb_func
 3663              		.fpu fpv4-sp-d16
 3665              	DSPI_MasterHalfDuplexTransferNonBlocking:
 3666              	.LFB188:
 995:../drivers/fsl_dspi.c ****     assert(xfer);
 3667              		.loc 1 995 0
 3668              		.cfi_startproc
 3669              		@ args = 0, pretend = 0, frame = 16
 3670              		@ frame_needed = 0, uses_anonymous_args = 0
 3671              	.LVL392:
 3672 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 3673              		.cfi_def_cfa_offset 32
 3674              		.cfi_offset 4, -16
 3675              		.cfi_offset 5, -12
 3676              		.cfi_offset 6, -8
 3677              		.cfi_offset 14, -4
 995:../drivers/fsl_dspi.c ****     assert(xfer);
 3678              		.loc 1 995 0
 3679 0002 1446     		mov	r4, r2
 3680 0004 0546     		mov	r5, r0
 3681 0006 0E46     		mov	r6, r1
 998:../drivers/fsl_dspi.c ****     status_t status;
 3682              		.loc 1 998 0
 3683 0008 1022     		movs	r2, #16
 3684              	.LVL393:
 3685 000a 0021     		movs	r1, #0
 3686              	.LVL394:
 3687 000c 6846     		mov	r0, sp
 3688              	.LVL395:
 3689 000e FFF7FEFF 		bl	memset
 3690              	.LVL396:
1001:../drivers/fsl_dspi.c ****     {
 3691              		.loc 1 1001 0
 3692 0012 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 3693 0014 F3B1     		cbz	r3, .L345
1003:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
 3694              		.loc 1 1003 0
 3695 0016 2368     		ldr	r3, [r4]
 3696 0018 0093     		str	r3, [sp]
1005:../drivers/fsl_dspi.c ****     }
 3697              		.loc 1 1005 0
 3698 001a A368     		ldr	r3, [r4, #8]
 3699              	.L352:
1014:../drivers/fsl_dspi.c ****     {
 3700              		.loc 1 1014 0
 3701 001c 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
1011:../drivers/fsl_dspi.c ****     }
 3702              		.loc 1 1011 0
 3703 001e 0293     		str	r3, [sp, #8]
 3704 0020 2369     		ldr	r3, [r4, #16]
1014:../drivers/fsl_dspi.c ****     {
 3705              		.loc 1 1014 0
 3706 0022 DAB1     		cbz	r2, .L347
1016:../drivers/fsl_dspi.c ****     }
 3707              		.loc 1 1016 0
 3708 0024 43F40013 		orr	r3, r3, #2097152
 3709              	.L353:
1023:../drivers/fsl_dspi.c ****     if (status != kStatus_Success)
 3710              		.loc 1 1023 0
 3711 0028 6946     		mov	r1, sp
 3712 002a 2846     		mov	r0, r5
1020:../drivers/fsl_dspi.c ****     }
 3713              		.loc 1 1020 0
 3714 002c 0393     		str	r3, [sp, #12]
1023:../drivers/fsl_dspi.c ****     if (status != kStatus_Success)
 3715              		.loc 1 1023 0
 3716 002e FFF7FEFF 		bl	DSPI_MasterTransferBlocking
 3717              	.LVL397:
1024:../drivers/fsl_dspi.c ****     {
 3718              		.loc 1 1024 0
 3719 0032 68B9     		cbnz	r0, .L344
1029:../drivers/fsl_dspi.c ****     {
 3720              		.loc 1 1029 0
 3721 0034 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 3722 0036 A3B1     		cbz	r3, .L350
1032:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
 3723              		.loc 1 1032 0
 3724 0038 6368     		ldr	r3, [r4, #4]
 3725 003a 0193     		str	r3, [sp, #4]
1033:../drivers/fsl_dspi.c ****     }
 3726              		.loc 1 1033 0
 3727 003c E368     		ldr	r3, [r4, #12]
1031:../drivers/fsl_dspi.c ****         tempXfer.rxData = xfer->rxData;
 3728              		.loc 1 1031 0
 3729 003e 0090     		str	r0, [sp]
 3730              	.L354:
1039:../drivers/fsl_dspi.c ****     }
 3731              		.loc 1 1039 0
 3732 0040 0293     		str	r3, [sp, #8]
1043:../drivers/fsl_dspi.c **** 
 3733              		.loc 1 1043 0
 3734 0042 6A46     		mov	r2, sp
1041:../drivers/fsl_dspi.c **** 
 3735              		.loc 1 1041 0
 3736 0044 2369     		ldr	r3, [r4, #16]
 3737 0046 0393     		str	r3, [sp, #12]
1043:../drivers/fsl_dspi.c **** 
 3738              		.loc 1 1043 0
 3739 0048 3146     		mov	r1, r6
 3740 004a 2846     		mov	r0, r5
 3741              	.LVL398:
 3742 004c FFF7FEFF 		bl	DSPI_MasterTransferNonBlocking
 3743              	.LVL399:
 3744              	.L344:
1046:../drivers/fsl_dspi.c **** 
 3745              		.loc 1 1046 0
 3746 0050 04B0     		add	sp, sp, #16
 3747              		.cfi_remember_state
 3748              		.cfi_def_cfa_offset 16
 3749              		@ sp needed
 3750 0052 70BD     		pop	{r4, r5, r6, pc}
 3751              	.LVL400:
 3752              	.L345:
 3753              		.cfi_restore_state
1010:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->rxDataSize;
 3754              		.loc 1 1010 0
 3755 0054 6368     		ldr	r3, [r4, #4]
 3756 0056 0193     		str	r3, [sp, #4]
1011:../drivers/fsl_dspi.c ****     }
 3757              		.loc 1 1011 0
 3758 0058 E368     		ldr	r3, [r4, #12]
 3759 005a DFE7     		b	.L352
 3760              	.L347:
1020:../drivers/fsl_dspi.c ****     }
 3761              		.loc 1 1020 0
 3762 005c 23F40013 		bic	r3, r3, #2097152
 3763 0060 E2E7     		b	.L353
 3764              	.LVL401:
 3765              	.L350:
1037:../drivers/fsl_dspi.c ****         tempXfer.rxData = NULL;
 3766              		.loc 1 1037 0
 3767 0062 2268     		ldr	r2, [r4]
1038:../drivers/fsl_dspi.c ****         tempXfer.dataSize = xfer->txDataSize;
 3768              		.loc 1 1038 0
 3769 0064 CDE90023 		strd	r2, r3, [sp]
1039:../drivers/fsl_dspi.c ****     }
 3770              		.loc 1 1039 0
 3771 0068 A368     		ldr	r3, [r4, #8]
 3772 006a E9E7     		b	.L354
 3773              		.cfi_endproc
 3774              	.LFE188:
 3776              		.section	.text.DSPI_MasterTransferGetCount,"ax",%progbits
 3777              		.align	1
 3778              		.global	DSPI_MasterTransferGetCount
 3779              		.syntax unified
 3780              		.thumb
 3781              		.thumb_func
 3782              		.fpu fpv4-sp-d16
 3784              	DSPI_MasterTransferGetCount:
 3785              	.LFB189:
1049:../drivers/fsl_dspi.c ****     assert(handle);
 3786              		.loc 1 1049 0
 3787              		.cfi_startproc
 3788              		@ args = 0, pretend = 0, frame = 0
 3789              		@ frame_needed = 0, uses_anonymous_args = 0
 3790              		@ link register save eliminated.
 3791              	.LVL402:
1052:../drivers/fsl_dspi.c ****     {
 3792              		.loc 1 1052 0
 3793 0000 6AB1     		cbz	r2, .L358
1058:../drivers/fsl_dspi.c ****     {
 3794              		.loc 1 1058 0
 3795 0002 91F82430 		ldrb	r3, [r1, #36]	@ zero_extendqisi2
 3796 0006 012B     		cmp	r3, #1
1064:../drivers/fsl_dspi.c ****     return kStatus_Success;
 3797              		.loc 1 1064 0
 3798 0008 0BBF     		itete	eq
 3799 000a 0B6A     		ldreq	r3, [r1, #32]
1061:../drivers/fsl_dspi.c ****     }
 3800              		.loc 1 1061 0
 3801 000c 0620     		movne	r0, #6
 3802              	.LVL403:
1064:../drivers/fsl_dspi.c ****     return kStatus_Success;
 3803              		.loc 1 1064 0
 3804 000e C869     		ldreq	r0, [r1, #28]
1060:../drivers/fsl_dspi.c ****         return kStatus_NoTransferInProgress;
 3805              		.loc 1 1060 0
 3806 0010 0023     		movne	r3, #0
1064:../drivers/fsl_dspi.c ****     return kStatus_Success;
 3807              		.loc 1 1064 0
 3808 0012 09BF     		itett	eq
 3809 0014 1B1A     		subeq	r3, r3, r0
1060:../drivers/fsl_dspi.c ****         return kStatus_NoTransferInProgress;
 3810              		.loc 1 1060 0
 3811 0016 1360     		strne	r3, [r2]
1064:../drivers/fsl_dspi.c ****     return kStatus_Success;
 3812              		.loc 1 1064 0
 3813 0018 1360     		streq	r3, [r2]
1065:../drivers/fsl_dspi.c **** }
 3814              		.loc 1 1065 0
 3815 001a 0020     		moveq	r0, #0
 3816 001c 7047     		bx	lr
 3817              	.LVL404:
 3818              	.L358:
1054:../drivers/fsl_dspi.c ****     }
 3819              		.loc 1 1054 0
 3820 001e 0420     		movs	r0, #4
 3821              	.LVL405:
1066:../drivers/fsl_dspi.c **** 
 3822              		.loc 1 1066 0
 3823 0020 7047     		bx	lr
 3824              		.cfi_endproc
 3825              	.LFE189:
 3827              		.section	.text.DSPI_MasterTransferAbort,"ax",%progbits
 3828              		.align	1
 3829              		.global	DSPI_MasterTransferAbort
 3830              		.syntax unified
 3831              		.thumb
 3832              		.thumb_func
 3833              		.fpu fpv4-sp-d16
 3835              	DSPI_MasterTransferAbort:
 3836              	.LFB192:
1214:../drivers/fsl_dspi.c ****     assert(handle);
 3837              		.loc 1 1214 0
 3838              		.cfi_startproc
 3839              		@ args = 0, pretend = 0, frame = 0
 3840              		@ frame_needed = 0, uses_anonymous_args = 0
 3841              		@ link register save eliminated.
 3842              	.LVL406:
 3843              	.LBB555:
 3844              	.LBB556:
 753:../drivers/fsl_dspi.h **** }
 3845              		.loc 2 753 0
 3846 0000 0368     		ldr	r3, [r0]
 3847 0002 43F00103 		orr	r3, r3, #1
 3848 0006 0360     		str	r3, [r0]
 3849              	.LVL407:
 3850              	.LBE556:
 3851              	.LBE555:
 3852              	.LBB557:
 3853              	.LBB558:
 620:../drivers/fsl_dspi.h **** }
 3854              		.loc 2 620 0
 3855 0008 036B     		ldr	r3, [r0, #48]
 3856 000a 23F00073 		bic	r3, r3, #33554432
 3857 000e 23F40033 		bic	r3, r3, #131072
 3858 0012 0363     		str	r3, [r0, #48]
 3859              	.LVL408:
 3860              	.LBE558:
 3861              	.LBE557:
1222:../drivers/fsl_dspi.c **** }
 3862              		.loc 1 1222 0
 3863 0014 0023     		movs	r3, #0
 3864 0016 81F82430 		strb	r3, [r1, #36]
1223:../drivers/fsl_dspi.c **** 
 3865              		.loc 1 1223 0
 3866 001a 7047     		bx	lr
 3867              		.cfi_endproc
 3868              	.LFE192:
 3870              		.section	.text.DSPI_SlaveTransferCreateHandle,"ax",%progbits
 3871              		.align	1
 3872              		.global	DSPI_SlaveTransferCreateHandle
 3873              		.syntax unified
 3874              		.thumb
 3875              		.thumb_func
 3876              		.fpu fpv4-sp-d16
 3878              	DSPI_SlaveTransferCreateHandle:
 3879              	.LFB194:
1336:../drivers/fsl_dspi.c ****     assert(handle);
 3880              		.loc 1 1336 0
 3881              		.cfi_startproc
 3882              		@ args = 0, pretend = 0, frame = 0
 3883              		@ frame_needed = 0, uses_anonymous_args = 0
 3884              	.LVL409:
 3885 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3886              		.cfi_def_cfa_offset 24
 3887              		.cfi_offset 3, -24
 3888              		.cfi_offset 4, -20
 3889              		.cfi_offset 5, -16
 3890              		.cfi_offset 6, -12
 3891              		.cfi_offset 7, -8
 3892              		.cfi_offset 14, -4
1336:../drivers/fsl_dspi.c ****     assert(handle);
 3893              		.loc 1 1336 0
 3894 0002 0C46     		mov	r4, r1
 3895 0004 0746     		mov	r7, r0
 3896 0006 1646     		mov	r6, r2
1340:../drivers/fsl_dspi.c **** 
 3897              		.loc 1 1340 0
 3898 0008 0021     		movs	r1, #0
 3899              	.LVL410:
 3900 000a 2422     		movs	r2, #36
 3901              	.LVL411:
 3902 000c 2046     		mov	r0, r4
 3903              	.LVL412:
1336:../drivers/fsl_dspi.c ****     assert(handle);
 3904              		.loc 1 1336 0
 3905 000e 1D46     		mov	r5, r3
1340:../drivers/fsl_dspi.c **** 
 3906              		.loc 1 1340 0
 3907 0010 FFF7FEFF 		bl	memset
 3908              	.LVL413:
1342:../drivers/fsl_dspi.c **** 
 3909              		.loc 1 1342 0
 3910 0014 3846     		mov	r0, r7
 3911 0016 FFF7FEFF 		bl	DSPI_GetInstance
 3912              	.LVL414:
 3913 001a 034B     		ldr	r3, .L361
1345:../drivers/fsl_dspi.c **** }
 3914              		.loc 1 1345 0
 3915 001c C4E90965 		strd	r6, r5, [r4, #36]
1342:../drivers/fsl_dspi.c **** 
 3916              		.loc 1 1342 0
 3917 0020 43F82040 		str	r4, [r3, r0, lsl #2]
1346:../drivers/fsl_dspi.c **** 
 3918              		.loc 1 1346 0
 3919 0024 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3920              	.LVL415:
 3921              	.L362:
 3922 0026 00BF     		.align	2
 3923              	.L361:
 3924 0028 00000000 		.word	.LANCHOR8
 3925              		.cfi_endproc
 3926              	.LFE194:
 3928              		.section	.text.DSPI_SlaveTransferNonBlocking,"ax",%progbits
 3929              		.align	1
 3930              		.global	DSPI_SlaveTransferNonBlocking
 3931              		.syntax unified
 3932              		.thumb
 3933              		.thumb_func
 3934              		.fpu fpv4-sp-d16
 3936              	DSPI_SlaveTransferNonBlocking:
 3937              	.LFB195:
1349:../drivers/fsl_dspi.c ****     assert(handle);
 3938              		.loc 1 1349 0
 3939              		.cfi_startproc
 3940              		@ args = 0, pretend = 0, frame = 0
 3941              		@ frame_needed = 0, uses_anonymous_args = 0
 3942              	.LVL416:
 3943 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3944              		.cfi_def_cfa_offset 24
 3945              		.cfi_offset 3, -24
 3946              		.cfi_offset 4, -20
 3947              		.cfi_offset 5, -16
 3948              		.cfi_offset 6, -12
 3949              		.cfi_offset 7, -8
 3950              		.cfi_offset 14, -4
1354:../drivers/fsl_dspi.c ****     {
 3951              		.loc 1 1354 0
 3952 0002 9368     		ldr	r3, [r2, #8]
1349:../drivers/fsl_dspi.c ****     assert(handle);
 3953              		.loc 1 1349 0
 3954 0004 0546     		mov	r5, r0
 3955 0006 0C46     		mov	r4, r1
1354:../drivers/fsl_dspi.c ****     {
 3956              		.loc 1 1354 0
 3957 0008 002B     		cmp	r3, #0
 3958 000a 00F09780 		beq	.L379
1360:../drivers/fsl_dspi.c ****     {
 3959              		.loc 1 1360 0
 3960 000e 1768     		ldr	r7, [r2]
 3961 0010 1FB9     		cbnz	r7, .L365
1360:../drivers/fsl_dspi.c ****     {
 3962              		.loc 1 1360 0 is_stmt 0 discriminator 1
 3963 0012 5368     		ldr	r3, [r2, #4]
 3964 0014 002B     		cmp	r3, #0
 3965 0016 00F09180 		beq	.L379
 3966              	.L365:
1366:../drivers/fsl_dspi.c ****     {
 3967              		.loc 1 1366 0 is_stmt 1
 3968 001a 237F     		ldrb	r3, [r4, #28]	@ zero_extendqisi2
 3969 001c 012B     		cmp	r3, #1
 3970 001e 00F08F80 		beq	.L380
1370:../drivers/fsl_dspi.c **** 
 3971              		.loc 1 1370 0
 3972 0022 0121     		movs	r1, #1
 3973              	.LVL417:
 3974 0024 2177     		strb	r1, [r4, #28]
1373:../drivers/fsl_dspi.c **** 
 3975              		.loc 1 1373 0
 3976 0026 2846     		mov	r0, r5
 3977              	.LVL418:
 3978 0028 FFF7FEFF 		bl	DSPI_GetInstance
 3979              	.LVL419:
 3980 002c 464B     		ldr	r3, .L391
 3981 002e 1B56     		ldrsb	r3, [r3, r0]
 3982              	.LVL420:
 3983              	.LBB577:
 3984              	.LBB578:
 3985              	.LBB579:
1674:../CMSIS/core_cm4.h ****   {
 3986              		.loc 5 1674 0
 3987 0030 002B     		cmp	r3, #0
 3988              	.LBE579:
 3989              	.LBE578:
 3990              	.LBE577:
1373:../drivers/fsl_dspi.c **** 
 3991              		.loc 1 1373 0
 3992 0032 0646     		mov	r6, r0
 3993              	.LBB582:
 3994              	.LBB581:
 3995              	.LBB580:
1674:../CMSIS/core_cm4.h ****   {
 3996              		.loc 5 1674 0
 3997 0034 07DB     		blt	.L366
1676:../CMSIS/core_cm4.h ****   }
 3998              		.loc 5 1676 0
 3999 0036 5809     		lsrs	r0, r3, #5
 4000 0038 03F01F03 		and	r3, r3, #31
 4001              	.LVL421:
 4002 003c 01FA03F3 		lsl	r3, r1, r3
 4003 0040 4249     		ldr	r1, .L391+4
 4004 0042 41F82030 		str	r3, [r1, r0, lsl #2]
 4005              	.L366:
 4006              	.LVL422:
 4007              	.LBE580:
 4008              	.LBE581:
 4009              	.LBE582:
1377:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = transfer->dataSize;
 4010              		.loc 1 1377 0
 4011 0046 5368     		ldr	r3, [r2, #4]
1376:../drivers/fsl_dspi.c ****     handle->rxData = transfer->rxData;
 4012              		.loc 1 1376 0
 4013 0048 A760     		str	r7, [r4, #8]
1377:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = transfer->dataSize;
 4014              		.loc 1 1377 0
 4015 004a E360     		str	r3, [r4, #12]
1378:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = transfer->dataSize;
 4016              		.loc 1 1378 0
 4017 004c 9368     		ldr	r3, [r2, #8]
 4018 004e 2361     		str	r3, [r4, #16]
1379:../drivers/fsl_dspi.c ****     handle->totalByteCount = transfer->dataSize;
 4019              		.loc 1 1379 0
 4020 0050 9368     		ldr	r3, [r2, #8]
 4021 0052 6361     		str	r3, [r4, #20]
1380:../drivers/fsl_dspi.c **** 
 4022              		.loc 1 1380 0
 4023 0054 9368     		ldr	r3, [r2, #8]
 4024 0056 A361     		str	r3, [r4, #24]
1382:../drivers/fsl_dspi.c **** 
 4025              		.loc 1 1382 0
 4026 0058 0023     		movs	r3, #0
 4027 005a 2362     		str	r3, [r4, #32]
 4028              	.LVL423:
1384:../drivers/fsl_dspi.c ****     handle->bitsPerFrame =
 4029              		.loc 1 1384 0
 4030 005c D368     		ldr	r3, [r2, #12]
1393:../drivers/fsl_dspi.c **** 
 4031              		.loc 1 1393 0
 4032 005e 3C4A     		ldr	r2, .L391+8
 4033              	.LVL424:
1386:../drivers/fsl_dspi.c **** 
 4034              		.loc 1 1386 0
 4035 0060 03F00703 		and	r3, r3, #7
 4036 0064 0233     		adds	r3, r3, #2
 4037 0066 05EB8303 		add	r3, r5, r3, lsl #2
1396:../drivers/fsl_dspi.c **** 
 4038              		.loc 1 1396 0
 4039 006a 4FF40031 		mov	r1, #131072
1386:../drivers/fsl_dspi.c **** 
 4040              		.loc 1 1386 0
 4041 006e 5B68     		ldr	r3, [r3, #4]
 4042 0070 DB0E     		lsrs	r3, r3, #27
 4043 0072 0133     		adds	r3, r3, #1
1385:../drivers/fsl_dspi.c ****         (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) +
 4044              		.loc 1 1385 0
 4045 0074 2360     		str	r3, [r4]
 4046              	.LVL425:
 4047              	.LBB583:
 4048              	.LBB584:
 753:../drivers/fsl_dspi.h **** }
 4049              		.loc 2 753 0
 4050 0076 2B68     		ldr	r3, [r5]
 4051 0078 43F00103 		orr	r3, r3, #1
 4052 007c 2B60     		str	r3, [r5]
 4053              	.LVL426:
 4054              	.LBE584:
 4055              	.LBE583:
 4056              	.LBB585:
 4057              	.LBB586:
 782:../drivers/fsl_dspi.h ****                 SPI_MCR_CLR_RXF(flushRxFifo);
 4058              		.loc 2 782 0
 4059 007e 2B68     		ldr	r3, [r5]
 4060 0080 43F44063 		orr	r3, r3, #3072
 4061 0084 2B60     		str	r3, [r5]
 4062              	.LVL427:
 4063              	.LBE586:
 4064              	.LBE585:
 4065              	.LBB587:
 4066              	.LBB588:
 580:../drivers/fsl_dspi.h **** }
 4067              		.loc 2 580 0
 4068 0086 334B     		ldr	r3, .L391+12
 4069 0088 EB62     		str	r3, [r5, #44]
 4070              	.LVL428:
 4071              	.LBE588:
 4072              	.LBE587:
1393:../drivers/fsl_dspi.c **** 
 4073              		.loc 1 1393 0
 4074 008a 334B     		ldr	r3, .L391+16
1396:../drivers/fsl_dspi.c **** 
 4075              		.loc 1 1396 0
 4076 008c 2846     		mov	r0, r5
1393:../drivers/fsl_dspi.c **** 
 4077              		.loc 1 1393 0
 4078 008e 1A60     		str	r2, [r3]
1396:../drivers/fsl_dspi.c **** 
 4079              		.loc 1 1396 0
 4080 0090 FFF7FEFF 		bl	DSPI_EnableInterrupts
 4081              	.LVL429:
1398:../drivers/fsl_dspi.c ****     {
 4082              		.loc 1 1398 0
 4083 0094 E368     		ldr	r3, [r4, #12]
 4084 0096 1BB1     		cbz	r3, .L367
 4085              	.LVL430:
1401:../drivers/fsl_dspi.c ****     }
 4086              		.loc 1 1401 0
 4087 0098 4FF40021 		mov	r1, #524288
 4088 009c FFF7FEFF 		bl	DSPI_EnableInterrupts
 4089              	.LVL431:
 4090              	.L367:
1403:../drivers/fsl_dspi.c ****     {
 4091              		.loc 1 1403 0
 4092 00a0 A368     		ldr	r3, [r4, #8]
 4093 00a2 23B1     		cbz	r3, .L368
1406:../drivers/fsl_dspi.c ****     }
 4094              		.loc 1 1406 0
 4095 00a4 4FF00061 		mov	r1, #134217728
 4096 00a8 2846     		mov	r0, r5
 4097              	.LVL432:
 4098 00aa FFF7FEFF 		bl	DSPI_EnableInterrupts
 4099              	.LVL433:
 4100              	.L368:
 4101              	.LBB589:
 4102              	.LBB590:
 742:../drivers/fsl_dspi.h **** }
 4103              		.loc 2 742 0
 4104 00ae 2B68     		ldr	r3, [r5]
 4105 00b0 23F00103 		bic	r3, r3, #1
 4106 00b4 2B60     		str	r3, [r5]
 4107              	.LVL434:
 4108              	.LBE590:
 4109              	.LBE589:
 4110              	.LBB591:
 4111              	.LBB592:
1442:../drivers/fsl_dspi.c **** 
 4112              		.loc 1 1442 0
 4113 00b6 294B     		ldr	r3, .L391+20
 4114 00b8 9A5D     		ldrb	r2, [r3, r6]	@ zero_extendqisi2
 4115              	.LVL435:
1508:../drivers/fsl_dspi.c ****                 }
 4116              		.loc 1 1508 0
 4117 00ba 1102     		lsls	r1, r2, #8
 4118 00bc 42EA0106 		orr	r6, r2, r1
 4119              	.LVL436:
 4120              	.LBB593:
 4121              	.LBB594:
 580:../drivers/fsl_dspi.h **** }
 4122              		.loc 2 580 0
 4123 00c0 4FF00077 		mov	r7, #33554432
 4124              	.LVL437:
 4125              	.L369:
 4126              	.LBE594:
 4127              	.LBE593:
 4128              	.LBB596:
 4129              	.LBB597:
 561:../drivers/fsl_dspi.h **** }
 4130              		.loc 2 561 0
 4131 00c4 E86A     		ldr	r0, [r5, #44]
 4132              	.LVL438:
 4133              	.LBE597:
 4134              	.LBE596:
1447:../drivers/fsl_dspi.c ****     {
 4135              		.loc 1 1447 0
 4136 00c6 10F00070 		ands	r0, r0, #33554432
 4137 00ca 00D1     		bne	.L377
 4138              	.LVL439:
 4139              	.L363:
 4140              	.LBE592:
 4141              	.LBE591:
1415:../drivers/fsl_dspi.c **** 
 4142              		.loc 1 1415 0
 4143 00cc F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4144              	.LVL440:
 4145              	.L377:
 4146              	.LBB600:
 4147              	.LBB599:
1450:../drivers/fsl_dspi.c ****         {
 4148              		.loc 1 1450 0
 4149 00ce 2069     		ldr	r0, [r4, #16]
 4150 00d0 0028     		cmp	r0, #0
 4151 00d2 FBD0     		beq	.L363
1453:../drivers/fsl_dspi.c ****             {
 4152              		.loc 1 1453 0
 4153 00d4 2368     		ldr	r3, [r4]
 4154 00d6 082B     		cmp	r3, #8
1456:../drivers/fsl_dspi.c ****                 {
 4155              		.loc 1 1456 0
 4156 00d8 A368     		ldr	r3, [r4, #8]
1453:../drivers/fsl_dspi.c ****             {
 4157              		.loc 1 1453 0
 4158 00da 0BD8     		bhi	.L370
1456:../drivers/fsl_dspi.c ****                 {
 4159              		.loc 1 1456 0
 4160 00dc 43B1     		cbz	r3, .L382
1459:../drivers/fsl_dspi.c ****                     handle->txData++;
 4161              		.loc 1 1459 0
 4162 00de A368     		ldr	r3, [r4, #8]
1460:../drivers/fsl_dspi.c ****                 }
 4163              		.loc 1 1460 0
 4164 00e0 A068     		ldr	r0, [r4, #8]
1459:../drivers/fsl_dspi.c ****                     handle->txData++;
 4165              		.loc 1 1459 0
 4166 00e2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 4167              	.LVL441:
1460:../drivers/fsl_dspi.c ****                 }
 4168              		.loc 1 1460 0
 4169 00e4 0130     		adds	r0, r0, #1
 4170 00e6 A060     		str	r0, [r4, #8]
 4171              	.LVL442:
 4172              	.L371:
1468:../drivers/fsl_dspi.c ****             }
 4173              		.loc 1 1468 0
 4174 00e8 2069     		ldr	r0, [r4, #16]
 4175 00ea 0138     		subs	r0, r0, #1
 4176              	.L390:
1495:../drivers/fsl_dspi.c ****                     }
 4177              		.loc 1 1495 0
 4178 00ec 2061     		str	r0, [r4, #16]
 4179 00ee 0EE0     		b	.L372
 4180              	.LVL443:
 4181              	.L382:
1464:../drivers/fsl_dspi.c ****                 }
 4182              		.loc 1 1464 0
 4183 00f0 1346     		mov	r3, r2
 4184 00f2 F9E7     		b	.L371
 4185              	.L370:
1477:../drivers/fsl_dspi.c ****                 {
 4186              		.loc 1 1477 0
 4187 00f4 C3B1     		cbz	r3, .L373
1480:../drivers/fsl_dspi.c ****                     handle->txData++;
 4188              		.loc 1 1480 0
 4189 00f6 A368     		ldr	r3, [r4, #8]
1481:../drivers/fsl_dspi.c **** 
 4190              		.loc 1 1481 0
 4191 00f8 A068     		ldr	r0, [r4, #8]
1480:../drivers/fsl_dspi.c ****                     handle->txData++;
 4192              		.loc 1 1480 0
 4193 00fa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 4194              	.LVL444:
1481:../drivers/fsl_dspi.c **** 
 4195              		.loc 1 1481 0
 4196 00fc 0130     		adds	r0, r0, #1
 4197 00fe A060     		str	r0, [r4, #8]
1483:../drivers/fsl_dspi.c ****                     {
 4198              		.loc 1 1483 0
 4199 0100 2069     		ldr	r0, [r4, #16]
 4200 0102 0128     		cmp	r0, #1
 4201 0104 06D1     		bne	.L374
1486:../drivers/fsl_dspi.c ****                         /* Update second byte of transmit data to second byte of dummy pattern */
 4202              		.loc 1 1486 0
 4203 0106 2069     		ldr	r0, [r4, #16]
 4204 0108 0138     		subs	r0, r0, #1
 4205 010a 2061     		str	r0, [r4, #16]
1488:../drivers/fsl_dspi.c ****                     }
 4206              		.loc 1 1488 0
 4207 010c 0B43     		orrs	r3, r3, r1
 4208              	.LVL445:
 4209              	.L372:
1518:../drivers/fsl_dspi.c **** 
 4210              		.loc 1 1518 0
 4211 010e 6B63     		str	r3, [r5, #52]
 4212              	.LVL446:
 4213              	.LBB598:
 4214              	.LBB595:
 580:../drivers/fsl_dspi.h **** }
 4215              		.loc 2 580 0
 4216 0110 EF62     		str	r7, [r5, #44]
 4217 0112 D7E7     		b	.L369
 4218              	.LVL447:
 4219              	.L374:
 4220              	.LBE595:
 4221              	.LBE598:
1493:../drivers/fsl_dspi.c ****                         handle->txData++;
 4222              		.loc 1 1493 0
 4223 0114 A068     		ldr	r0, [r4, #8]
 4224 0116 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4225 0118 43EA0023 		orr	r3, r3, r0, lsl #8
 4226              	.LVL448:
1494:../drivers/fsl_dspi.c ****                         handle->remainingSendByteCount -= 2;
 4227              		.loc 1 1494 0
 4228 011c A068     		ldr	r0, [r4, #8]
 4229 011e 0130     		adds	r0, r0, #1
 4230 0120 A060     		str	r0, [r4, #8]
1495:../drivers/fsl_dspi.c ****                     }
 4231              		.loc 1 1495 0
 4232 0122 2069     		ldr	r0, [r4, #16]
 4233 0124 0238     		subs	r0, r0, #2
 4234 0126 E1E7     		b	.L390
 4235              	.LVL449:
 4236              	.L373:
1500:../drivers/fsl_dspi.c ****                     {
 4237              		.loc 1 1500 0
 4238 0128 2369     		ldr	r3, [r4, #16]
 4239 012a 012B     		cmp	r3, #1
1502:../drivers/fsl_dspi.c ****                     }
 4240              		.loc 1 1502 0
 4241 012c 2369     		ldr	r3, [r4, #16]
 4242 012e 0CBF     		ite	eq
 4243 0130 03F1FF33 		addeq	r3, r3, #-1
1506:../drivers/fsl_dspi.c ****                     }
 4244              		.loc 1 1506 0
 4245 0134 023B     		subne	r3, r3, #2
 4246 0136 2361     		str	r3, [r4, #16]
1508:../drivers/fsl_dspi.c ****                 }
 4247              		.loc 1 1508 0
 4248 0138 3346     		mov	r3, r6
 4249 013a E8E7     		b	.L372
 4250              	.LVL450:
 4251              	.L379:
 4252              	.LBE599:
 4253              	.LBE600:
1356:../drivers/fsl_dspi.c ****     }
 4254              		.loc 1 1356 0
 4255 013c 0420     		movs	r0, #4
 4256              	.LVL451:
 4257 013e C5E7     		b	.L363
 4258              	.LVL452:
 4259              	.L380:
1368:../drivers/fsl_dspi.c ****     }
 4260              		.loc 1 1368 0
 4261 0140 4FF41670 		mov	r0, #600
 4262              	.LVL453:
 4263 0144 C2E7     		b	.L363
 4264              	.L392:
 4265 0146 00BF     		.align	2
 4266              	.L391:
 4267 0148 00000000 		.word	.LANCHOR9
 4268 014c 00E100E0 		.word	-536813312
 4269 0150 00000000 		.word	DSPI_SlaveTransferHandleIRQ
 4270 0154 00000ADA 		.word	-636878848
 4271 0158 00000000 		.word	.LANCHOR1
 4272 015c 00000000 		.word	.LANCHOR2
 4273              		.cfi_endproc
 4274              	.LFE195:
 4276              		.section	.text.DSPI_SlaveTransferGetCount,"ax",%progbits
 4277              		.align	1
 4278              		.global	DSPI_SlaveTransferGetCount
 4279              		.syntax unified
 4280              		.thumb
 4281              		.thumb_func
 4282              		.fpu fpv4-sp-d16
 4284              	DSPI_SlaveTransferGetCount:
 4285              	.LFB196:
1418:../drivers/fsl_dspi.c ****     assert(handle);
 4286              		.loc 1 1418 0
 4287              		.cfi_startproc
 4288              		@ args = 0, pretend = 0, frame = 0
 4289              		@ frame_needed = 0, uses_anonymous_args = 0
 4290              		@ link register save eliminated.
 4291              	.LVL454:
1421:../drivers/fsl_dspi.c ****     {
 4292              		.loc 1 1421 0
 4293 0000 62B1     		cbz	r2, .L396
1427:../drivers/fsl_dspi.c ****     {
 4294              		.loc 1 1427 0
 4295 0002 0B7F     		ldrb	r3, [r1, #28]	@ zero_extendqisi2
 4296 0004 012B     		cmp	r3, #1
1433:../drivers/fsl_dspi.c ****     return kStatus_Success;
 4297              		.loc 1 1433 0
 4298 0006 0BBF     		itete	eq
 4299 0008 8B69     		ldreq	r3, [r1, #24]
1430:../drivers/fsl_dspi.c ****     }
 4300              		.loc 1 1430 0
 4301 000a 0620     		movne	r0, #6
 4302              	.LVL455:
1433:../drivers/fsl_dspi.c ****     return kStatus_Success;
 4303              		.loc 1 1433 0
 4304 000c 4869     		ldreq	r0, [r1, #20]
1429:../drivers/fsl_dspi.c ****         return kStatus_NoTransferInProgress;
 4305              		.loc 1 1429 0
 4306 000e 0023     		movne	r3, #0
1433:../drivers/fsl_dspi.c ****     return kStatus_Success;
 4307              		.loc 1 1433 0
 4308 0010 09BF     		itett	eq
 4309 0012 1B1A     		subeq	r3, r3, r0
1429:../drivers/fsl_dspi.c ****         return kStatus_NoTransferInProgress;
 4310              		.loc 1 1429 0
 4311 0014 1360     		strne	r3, [r2]
1433:../drivers/fsl_dspi.c ****     return kStatus_Success;
 4312              		.loc 1 1433 0
 4313 0016 1360     		streq	r3, [r2]
1434:../drivers/fsl_dspi.c **** }
 4314              		.loc 1 1434 0
 4315 0018 0020     		moveq	r0, #0
 4316 001a 7047     		bx	lr
 4317              	.LVL456:
 4318              	.L396:
1423:../drivers/fsl_dspi.c ****     }
 4319              		.loc 1 1423 0
 4320 001c 0420     		movs	r0, #4
 4321              	.LVL457:
1435:../drivers/fsl_dspi.c **** 
 4322              		.loc 1 1435 0
 4323 001e 7047     		bx	lr
 4324              		.cfi_endproc
 4325              	.LFE196:
 4327              		.section	.text.DSPI_SlaveTransferAbort,"ax",%progbits
 4328              		.align	1
 4329              		.global	DSPI_SlaveTransferAbort
 4330              		.syntax unified
 4331              		.thumb
 4332              		.thumb_func
 4333              		.fpu fpv4-sp-d16
 4335              	DSPI_SlaveTransferAbort:
 4336              	.LFB199:
1558:../drivers/fsl_dspi.c ****     assert(handle);
 4337              		.loc 1 1558 0
 4338              		.cfi_startproc
 4339              		@ args = 0, pretend = 0, frame = 0
 4340              		@ frame_needed = 0, uses_anonymous_args = 0
 4341              		@ link register save eliminated.
 4342              	.LVL458:
 4343              	.LBB601:
 4344              	.LBB602:
 753:../drivers/fsl_dspi.h **** }
 4345              		.loc 2 753 0
 4346 0000 0368     		ldr	r3, [r0]
 4347 0002 43F00103 		orr	r3, r3, #1
 4348 0006 0360     		str	r3, [r0]
 4349              	.LVL459:
 4350              	.LBE602:
 4351              	.LBE601:
 4352              	.LBB603:
 4353              	.LBB604:
 620:../drivers/fsl_dspi.h **** }
 4354              		.loc 2 620 0
 4355 0008 036B     		ldr	r3, [r0, #48]
 4356 000a 23F02063 		bic	r3, r3, #167772160
 4357 000e 23F42023 		bic	r3, r3, #655360
 4358 0012 0363     		str	r3, [r0, #48]
 4359              	.LVL460:
 4360              	.LBE604:
 4361              	.LBE603:
1567:../drivers/fsl_dspi.c ****     handle->remainingSendByteCount = 0;
 4362              		.loc 1 1567 0
 4363 0014 0023     		movs	r3, #0
 4364 0016 0B77     		strb	r3, [r1, #28]
1568:../drivers/fsl_dspi.c ****     handle->remainingReceiveByteCount = 0;
 4365              		.loc 1 1568 0
 4366 0018 0B61     		str	r3, [r1, #16]
1569:../drivers/fsl_dspi.c **** }
 4367              		.loc 1 1569 0
 4368 001a 4B61     		str	r3, [r1, #20]
1570:../drivers/fsl_dspi.c **** 
 4369              		.loc 1 1570 0
 4370 001c 7047     		bx	lr
 4371              		.cfi_endproc
 4372              	.LFE199:
 4374              		.section	.text.SPI0_DriverIRQHandler,"ax",%progbits
 4375              		.align	1
 4376              		.global	SPI0_DriverIRQHandler
 4377              		.syntax unified
 4378              		.thumb
 4379              		.thumb_func
 4380              		.fpu fpv4-sp-d16
 4382              	SPI0_DriverIRQHandler:
 4383              	.LFB202:
1757:../drivers/fsl_dspi.c **** 
1758:../drivers/fsl_dspi.c **** #if defined(SPI0)
1759:../drivers/fsl_dspi.c **** void SPI0_DriverIRQHandler(void)
1760:../drivers/fsl_dspi.c **** {
 4384              		.loc 1 1760 0
 4385              		.cfi_startproc
 4386              		@ args = 0, pretend = 0, frame = 0
 4387              		@ frame_needed = 0, uses_anonymous_args = 0
 4388              		@ link register save eliminated.
1761:../drivers/fsl_dspi.c ****     assert(g_dspiHandle[0]);
1762:../drivers/fsl_dspi.c ****     DSPI_CommonIRQHandler(SPI0, g_dspiHandle[0]);
 4389              		.loc 1 1762 0
 4390 0000 024B     		ldr	r3, .L399
 4391 0002 0348     		ldr	r0, .L399+4
 4392 0004 1968     		ldr	r1, [r3]
 4393 0006 FFF7FEBF 		b	DSPI_CommonIRQHandler
 4394              	.LVL461:
 4395              	.L400:
 4396 000a 00BF     		.align	2
 4397              	.L399:
 4398 000c 00000000 		.word	.LANCHOR8
 4399 0010 00C00240 		.word	1073922048
 4400              		.cfi_endproc
 4401              	.LFE202:
 4403              		.section	.text.SPI1_DriverIRQHandler,"ax",%progbits
 4404              		.align	1
 4405              		.global	SPI1_DriverIRQHandler
 4406              		.syntax unified
 4407              		.thumb
 4408              		.thumb_func
 4409              		.fpu fpv4-sp-d16
 4411              	SPI1_DriverIRQHandler:
 4412              	.LFB203:
1763:../drivers/fsl_dspi.c **** }
1764:../drivers/fsl_dspi.c **** #endif
1765:../drivers/fsl_dspi.c **** 
1766:../drivers/fsl_dspi.c **** #if defined(SPI1)
1767:../drivers/fsl_dspi.c **** void SPI1_DriverIRQHandler(void)
1768:../drivers/fsl_dspi.c **** {
 4413              		.loc 1 1768 0
 4414              		.cfi_startproc
 4415              		@ args = 0, pretend = 0, frame = 0
 4416              		@ frame_needed = 0, uses_anonymous_args = 0
 4417              		@ link register save eliminated.
1769:../drivers/fsl_dspi.c ****     assert(g_dspiHandle[1]);
1770:../drivers/fsl_dspi.c ****     DSPI_CommonIRQHandler(SPI1, g_dspiHandle[1]);
 4418              		.loc 1 1770 0
 4419 0000 024B     		ldr	r3, .L402
 4420 0002 0348     		ldr	r0, .L402+4
 4421 0004 5968     		ldr	r1, [r3, #4]
 4422 0006 FFF7FEBF 		b	DSPI_CommonIRQHandler
 4423              	.LVL462:
 4424              	.L403:
 4425 000a 00BF     		.align	2
 4426              	.L402:
 4427 000c 00000000 		.word	.LANCHOR8
 4428 0010 00D00240 		.word	1073926144
 4429              		.cfi_endproc
 4430              	.LFE203:
 4432              		.section	.text.SPI2_DriverIRQHandler,"ax",%progbits
 4433              		.align	1
 4434              		.global	SPI2_DriverIRQHandler
 4435              		.syntax unified
 4436              		.thumb
 4437              		.thumb_func
 4438              		.fpu fpv4-sp-d16
 4440              	SPI2_DriverIRQHandler:
 4441              	.LFB204:
1771:../drivers/fsl_dspi.c **** }
1772:../drivers/fsl_dspi.c **** #endif
1773:../drivers/fsl_dspi.c **** 
1774:../drivers/fsl_dspi.c **** #if defined(SPI2)
1775:../drivers/fsl_dspi.c **** void SPI2_DriverIRQHandler(void)
1776:../drivers/fsl_dspi.c **** {
 4442              		.loc 1 1776 0
 4443              		.cfi_startproc
 4444              		@ args = 0, pretend = 0, frame = 0
 4445              		@ frame_needed = 0, uses_anonymous_args = 0
 4446              		@ link register save eliminated.
1777:../drivers/fsl_dspi.c ****     assert(g_dspiHandle[2]);
1778:../drivers/fsl_dspi.c ****     DSPI_CommonIRQHandler(SPI2, g_dspiHandle[2]);
 4447              		.loc 1 1778 0
 4448 0000 024B     		ldr	r3, .L405
 4449 0002 0348     		ldr	r0, .L405+4
 4450 0004 9968     		ldr	r1, [r3, #8]
 4451 0006 FFF7FEBF 		b	DSPI_CommonIRQHandler
 4452              	.LVL463:
 4453              	.L406:
 4454 000a 00BF     		.align	2
 4455              	.L405:
 4456 000c 00000000 		.word	.LANCHOR8
 4457 0010 00C00A40 		.word	1074446336
 4458              		.cfi_endproc
 4459              	.LFE204:
 4461              		.global	s_dummyData
 4462              		.section	.bss.g_dspiHandle,"aw",%nobits
 4463              		.align	2
 4464              		.set	.LANCHOR8,. + 0
 4467              	g_dspiHandle:
 4468 0000 00000000 		.space	12
 4468      00000000 
 4468      00000000 
 4469              		.section	.bss.s_dspiMasterIsr,"aw",%nobits
 4470              		.align	2
 4471              		.set	.LANCHOR0,. + 0
 4474              	s_dspiMasterIsr:
 4475 0000 00000000 		.space	4
 4476              		.section	.bss.s_dspiSlaveIsr,"aw",%nobits
 4477              		.align	2
 4478              		.set	.LANCHOR1,. + 0
 4481              	s_dspiSlaveIsr:
 4482 0000 00000000 		.space	4
 4483              		.section	.bss.s_dummyData,"aw",%nobits
 4484              		.set	.LANCHOR2,. + 0
 4487              	s_dummyData:
 4488 0000 000000   		.space	3
 4489              		.section	.rodata.s_baudratePrescaler,"a",%progbits
 4490              		.align	2
 4491              		.set	.LANCHOR5,. + 0
 4494              	s_baudratePrescaler:
 4495 0000 02000000 		.word	2
 4496 0004 03000000 		.word	3
 4497 0008 05000000 		.word	5
 4498 000c 07000000 		.word	7
 4499              		.section	.rodata.s_baudrateScaler,"a",%progbits
 4500              		.align	2
 4501              		.set	.LANCHOR4,. + 0
 4504              	s_baudrateScaler:
 4505 0000 02000000 		.word	2
 4506 0004 04000000 		.word	4
 4507 0008 06000000 		.word	6
 4508 000c 08000000 		.word	8
 4509 0010 10000000 		.word	16
 4510 0014 20000000 		.word	32
 4511 0018 40000000 		.word	64
 4512 001c 80000000 		.word	128
 4513 0020 00010000 		.word	256
 4514 0024 00020000 		.word	512
 4515 0028 00040000 		.word	1024
 4516 002c 00080000 		.word	2048
 4517 0030 00100000 		.word	4096
 4518 0034 00200000 		.word	8192
 4519 0038 00400000 		.word	16384
 4520 003c 00800000 		.word	32768
 4521              		.section	.rodata.s_delayPrescaler,"a",%progbits
 4522              		.align	2
 4523              		.set	.LANCHOR7,. + 0
 4526              	s_delayPrescaler:
 4527 0000 01000000 		.word	1
 4528 0004 03000000 		.word	3
 4529 0008 05000000 		.word	5
 4530 000c 07000000 		.word	7
 4531              		.section	.rodata.s_delayScaler,"a",%progbits
 4532              		.align	2
 4533              		.set	.LANCHOR6,. + 0
 4536              	s_delayScaler:
 4537 0000 02000000 		.word	2
 4538 0004 04000000 		.word	4
 4539 0008 08000000 		.word	8
 4540 000c 10000000 		.word	16
 4541 0010 20000000 		.word	32
 4542 0014 40000000 		.word	64
 4543 0018 80000000 		.word	128
 4544 001c 00010000 		.word	256
 4545 0020 00020000 		.word	512
 4546 0024 00040000 		.word	1024
 4547 0028 00080000 		.word	2048
 4548 002c 00100000 		.word	4096
 4549 0030 00200000 		.word	8192
 4550 0034 00400000 		.word	16384
 4551 0038 00800000 		.word	32768
 4552 003c 00000100 		.word	65536
 4553              		.section	.rodata.s_dspiClock,"a",%progbits
 4554              		.align	2
 4555              		.set	.LANCHOR3,. + 0
 4558              	s_dspiClock:
 4559 0000 0C003C10 		.word	272367628
 4560 0004 0D003C10 		.word	272367629
 4561 0008 0C003010 		.word	271581196
 4562              		.section	.rodata.s_dspiIRQ,"a",%progbits
 4563              		.set	.LANCHOR9,. + 0
 4566              	s_dspiIRQ:
 4567 0000 1A       		.byte	26
 4568 0001 1B       		.byte	27
 4569 0002 41       		.byte	65
 4570              		.text
 4571              	.Letext0:
 4572              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 4573              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 4574              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 4575              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 4576              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 4577              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 4578              		.file 12 "../CMSIS/MK64F12.h"
 4579              		.file 13 "../CMSIS/system_MK64F12.h"
 4580              		.file 14 "../drivers/fsl_common.h"
 4581              		.file 15 "<built-in>"
