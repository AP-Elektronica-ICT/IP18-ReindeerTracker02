   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_enet.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ENET_TransmitIRQHandler,"ax",%progbits
  18              		.align	1
  19              		.global	ENET_TransmitIRQHandler
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	ENET_TransmitIRQHandler:
  26              	.LFB180:
  27              		.file 1 "../drivers/fsl_enet.c"
   1:../drivers/fsl_enet.c **** /*
   2:../drivers/fsl_enet.c ****  * The Clear BSD License
   3:../drivers/fsl_enet.c ****  * Copyright (c) 2015 - 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_enet.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_enet.c ****  * All rights reserved.
   6:../drivers/fsl_enet.c ****  *
   7:../drivers/fsl_enet.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_enet.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_enet.c ****  * that the following conditions are met:
  10:../drivers/fsl_enet.c ****  *
  11:../drivers/fsl_enet.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_enet.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_enet.c ****  *
  14:../drivers/fsl_enet.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_enet.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_enet.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_enet.c ****  *
  18:../drivers/fsl_enet.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_enet.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_enet.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_enet.c ****  *
  22:../drivers/fsl_enet.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_enet.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_enet.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_enet.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_enet.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_enet.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_enet.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_enet.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_enet.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_enet.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_enet.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_enet.c ****  */
  34:../drivers/fsl_enet.c **** 
  35:../drivers/fsl_enet.c **** #include "fsl_enet.h"
  36:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
  37:../drivers/fsl_enet.c **** #include "fsl_cache.h"
  38:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
  39:../drivers/fsl_enet.c **** 
  40:../drivers/fsl_enet.c **** /*******************************************************************************
  41:../drivers/fsl_enet.c ****  * Definitions
  42:../drivers/fsl_enet.c ****  ******************************************************************************/
  43:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message IP version offset. */
  44:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPVERSION_OFFSET 0x0EU
  45:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP protocol offset. */
  46:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_PROTOCOL_OFFSET 0x17U
  47:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP port offset. */
  48:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_PORT_OFFSET 0x24U
  49:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP message type offset. */
  50:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_MSGTYPE_OFFSET 0x2AU
  51:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP version offset. */
  52:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_VERSION_OFFSET 0x2BU
  53:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP clock id offset. */
  54:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_CLKID_OFFSET 0x3EU
  55:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP sequence id offset. */
  56:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_SEQUENCEID_OFFSET 0x48U
  57:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP control offset. */
  58:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_CTL_OFFSET 0x4AU
  59:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP protocol offset. */
  60:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_PROTOCOL_OFFSET 0x14U
  61:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP port offset. */
  62:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_PORT_OFFSET 0x38U
  63:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP message type offset. */
  64:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_MSGTYPE_OFFSET 0x3EU
  65:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP version offset. */
  66:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_VERSION_OFFSET 0x3FU
  67:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP clock id offset. */
  68:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_CLKID_OFFSET 0x52U
  69:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP sequence id offset. */
  70:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_SEQUENCEID_OFFSET 0x5CU
  71:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP control offset. */
  72:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_CTL_OFFSET 0x5EU
  73:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet packet type offset. */
  74:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET 0x0CU
  75:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet message type offset. */
  76:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_MSGTYPE_OFFSET 0x0EU
  77:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet version type offset. */
  78:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_VERSION_OFFSET 0X0FU
  79:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet clock id offset. */
  80:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_CLOCKID_OFFSET 0x22
  81:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet sequence id offset. */
  82:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_SEQUENCEID_OFFSET 0x2c
  83:../drivers/fsl_enet.c **** /*! @brief Packet type Ethernet IEEE802.3 for PTPv2. */
  84:../drivers/fsl_enet.c **** #define ENET_ETHERNETL2 0x88F7U
  85:../drivers/fsl_enet.c **** /*! @brief Packet type IPv4. */
  86:../drivers/fsl_enet.c **** #define ENET_IPV4 0x0800U
  87:../drivers/fsl_enet.c **** /*! @brief Packet type IPv6. */
  88:../drivers/fsl_enet.c **** #define ENET_IPV6 0x86ddU
  89:../drivers/fsl_enet.c **** /*! @brief Packet type VLAN. */
  90:../drivers/fsl_enet.c **** #define ENET_8021QVLAN 0x8100U
  91:../drivers/fsl_enet.c **** /*! @brief UDP protocol type. */
  92:../drivers/fsl_enet.c **** #define ENET_UDPVERSION 0x0011U
  93:../drivers/fsl_enet.c **** /*! @brief Packet IP version IPv4. */
  94:../drivers/fsl_enet.c **** #define ENET_IPV4VERSION 0x0004U
  95:../drivers/fsl_enet.c **** /*! @brief Packet IP version IPv6. */
  96:../drivers/fsl_enet.c **** #define ENET_IPV6VERSION 0x0006U
  97:../drivers/fsl_enet.c **** /*! @brief Ethernet mac address length. */
  98:../drivers/fsl_enet.c **** #define ENET_FRAME_MACLEN 6U
  99:../drivers/fsl_enet.c **** /*! @brief Ethernet VLAN header length. */
 100:../drivers/fsl_enet.c **** #define ENET_FRAME_VLAN_TAGLEN 4U
 101:../drivers/fsl_enet.c **** /*! @brief MDC frequency. */
 102:../drivers/fsl_enet.c **** #define ENET_MDC_FREQUENCY 2500000U
 103:../drivers/fsl_enet.c **** /*! @brief NanoSecond in one second. */
 104:../drivers/fsl_enet.c **** #define ENET_NANOSECOND_ONE_SECOND 1000000000U
 105:../drivers/fsl_enet.c **** /*! @brief Define a common clock cycle delays used for time stamp capture. */
 106:../drivers/fsl_enet.c **** #define ENET_1588TIME_DELAY_COUNT 10U
 107:../drivers/fsl_enet.c **** 
 108:../drivers/fsl_enet.c **** /*! @brief Defines the macro for converting constants from host byte order to network byte order. *
 109:../drivers/fsl_enet.c **** #define ENET_HTONS(n) __REV16(n)
 110:../drivers/fsl_enet.c **** #define ENET_HTONL(n) __REV(n)
 111:../drivers/fsl_enet.c **** #define ENET_NTOHS(n) __REV16(n)
 112:../drivers/fsl_enet.c **** #define ENET_NTOHL(n) __REV(n)
 113:../drivers/fsl_enet.c **** 
 114:../drivers/fsl_enet.c **** /*! @brief Define the ENET ring/class bumber . */
 115:../drivers/fsl_enet.c **** enum _enet_ring_number
 116:../drivers/fsl_enet.c **** {
 117:../drivers/fsl_enet.c ****     kENET_Ring0 = 0U, /*!< ENET ring/class 0. */
 118:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 119:../drivers/fsl_enet.c ****     kENET_Ring1 = 1U, /*!< ENET ring/class 1. */
 120:../drivers/fsl_enet.c ****     kENET_Ring2 = 2U  /*!< ENET ring/class 2. */
 121:../drivers/fsl_enet.c **** #endif                /* FSL_FEATURE_ENET_QUEUE > 1 */
 122:../drivers/fsl_enet.c **** };
 123:../drivers/fsl_enet.c **** 
 124:../drivers/fsl_enet.c **** /*! @brief Define interrupt IRQ handler. */
 125:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 126:../drivers/fsl_enet.c **** typedef void (*enet_isr_ring_t)(ENET_Type *base, enet_handle_t *handle, uint32_t ringId);
 127:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 128:../drivers/fsl_enet.c **** typedef void (*enet_isr_t)(ENET_Type *base, enet_handle_t *handle);
 129:../drivers/fsl_enet.c **** 
 130:../drivers/fsl_enet.c **** /*******************************************************************************
 131:../drivers/fsl_enet.c **** * Prototypes
 132:../drivers/fsl_enet.c **** ******************************************************************************/
 133:../drivers/fsl_enet.c **** 
 134:../drivers/fsl_enet.c **** /*!
 135:../drivers/fsl_enet.c ****  * @brief Get the ENET instance from peripheral base address.
 136:../drivers/fsl_enet.c ****  *
 137:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 138:../drivers/fsl_enet.c ****  * @return ENET instance.
 139:../drivers/fsl_enet.c ****  */
 140:../drivers/fsl_enet.c **** uint32_t ENET_GetInstance(ENET_Type *base);
 141:../drivers/fsl_enet.c **** /*!
 142:../drivers/fsl_enet.c ****  * @brief Set ENET MAC controller with the configuration.
 143:../drivers/fsl_enet.c ****  *
 144:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 145:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 146:../drivers/fsl_enet.c ****  * @param config ENET Mac configuration.
 147:../drivers/fsl_enet.c ****  * @param bufferConfig ENET buffer configuration.
 148:../drivers/fsl_enet.c ****  * @param macAddr ENET six-byte mac address.
 149:../drivers/fsl_enet.c ****  * @param srcClock_Hz ENET module clock source, normally it's system clock.
 150:../drivers/fsl_enet.c ****  */
 151:../drivers/fsl_enet.c **** static void ENET_SetMacController(ENET_Type *base,
 152:../drivers/fsl_enet.c ****                                   enet_handle_t *handle,
 153:../drivers/fsl_enet.c ****                                   const enet_config_t *config,
 154:../drivers/fsl_enet.c ****                                   const enet_buffer_config_t *bufferConfig,
 155:../drivers/fsl_enet.c ****                                   uint8_t *macAddr,
 156:../drivers/fsl_enet.c ****                                   uint32_t srcClock_Hz);
 157:../drivers/fsl_enet.c **** /*!
 158:../drivers/fsl_enet.c ****  * @brief Set ENET handler.
 159:../drivers/fsl_enet.c ****  *
 160:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 161:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 162:../drivers/fsl_enet.c ****  * @param config ENET configuration stucture pointer.
 163:../drivers/fsl_enet.c ****  * @param bufferConfig ENET buffer configuration.
 164:../drivers/fsl_enet.c ****  */
 165:../drivers/fsl_enet.c **** static void ENET_SetHandler(ENET_Type *base,
 166:../drivers/fsl_enet.c ****                             enet_handle_t *handle,
 167:../drivers/fsl_enet.c ****                             const enet_config_t *config,
 168:../drivers/fsl_enet.c ****                             const enet_buffer_config_t *bufferConfig);
 169:../drivers/fsl_enet.c **** /*!
 170:../drivers/fsl_enet.c ****  * @brief Set ENET MAC transmit buffer descriptors.
 171:../drivers/fsl_enet.c ****  *
 172:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 173:../drivers/fsl_enet.c ****  * @param config The ENET configuration structure.
 174:../drivers/fsl_enet.c ****  * @param bufferConfig The ENET buffer configuration.
 175:../drivers/fsl_enet.c ****  */
 176:../drivers/fsl_enet.c **** static void ENET_SetTxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 177:../drivers/fsl_enet.c **** 
 178:../drivers/fsl_enet.c **** /*!
 179:../drivers/fsl_enet.c ****  * @brief Set ENET MAC receive buffer descriptors.
 180:../drivers/fsl_enet.c ****  *
 181:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 182:../drivers/fsl_enet.c ****  * @param config The ENET configuration structure.
 183:../drivers/fsl_enet.c ****  * @param bufferConfig The ENET buffer configuration.
 184:../drivers/fsl_enet.c ****  */
 185:../drivers/fsl_enet.c **** static void ENET_SetRxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 186:../drivers/fsl_enet.c **** 
 187:../drivers/fsl_enet.c **** /*!
 188:../drivers/fsl_enet.c ****  * @brief Updates the ENET read buffer descriptors.
 189:../drivers/fsl_enet.c ****  *
 190:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 191:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 192:../drivers/fsl_enet.c ****  * @param ringId The descriptor ring index, range from 0 ~ FSL_FEATURE_ENET_QUEUE - 1.
 193:../drivers/fsl_enet.c ****  *               0 ----- for single ring kinetis platform.
 194:../drivers/fsl_enet.c ****  *               0 ~ 2 for mulit-ring supported IMX8qm.
 195:../drivers/fsl_enet.c ****  */
 196:../drivers/fsl_enet.c **** static void ENET_UpdateReadBuffers(ENET_Type *base, enet_handle_t *handle, uint32_t ringId);
 197:../drivers/fsl_enet.c **** 
 198:../drivers/fsl_enet.c **** /*!
 199:../drivers/fsl_enet.c ****  * @brief Activates ENET send for multiple tx rings.
 200:../drivers/fsl_enet.c ****  *
 201:../drivers/fsl_enet.c ****  * @param base  ENET peripheral base address.
 202:../drivers/fsl_enet.c ****  * @param ringId The descriptor ring index, range from 0 ~ FSL_FEATURE_ENET_QUEUE - 1.
 203:../drivers/fsl_enet.c ****  *               0 ----- for single ring kinetis platform.
 204:../drivers/fsl_enet.c ****  *               0 ~ 2 for mulit-ring supported IMX8qm.
 205:../drivers/fsl_enet.c ****  *
 206:../drivers/fsl_enet.c ****  * @note This must be called after the MAC configuration and
 207:../drivers/fsl_enet.c ****  * state are ready. It must be called after the ENET_Init() and
 208:../drivers/fsl_enet.c ****  * this should be called when the ENET receive required.
 209:../drivers/fsl_enet.c ****  */
 210:../drivers/fsl_enet.c **** static void ENET_ActiveSend(ENET_Type *base, uint32_t ringId);
 211:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 212:../drivers/fsl_enet.c **** /*!
 213:../drivers/fsl_enet.c ****  * @brief Parses the ENET frame for time-stamp process of PTP 1588 frame.
 214:../drivers/fsl_enet.c ****  *
 215:../drivers/fsl_enet.c ****  * @param data  The ENET read data for frame parse.
 216:../drivers/fsl_enet.c ****  * @param ptpTsData The ENET PTP message and time-stamp data pointer.
 217:../drivers/fsl_enet.c ****  * @param isFastEnabled The fast parse flag.
 218:../drivers/fsl_enet.c ****  *        - true , Fast processing, only check if this is a PTP message.
 219:../drivers/fsl_enet.c ****  *        - false, Store the PTP message data after check the PTP message.
 220:../drivers/fsl_enet.c ****  */
 221:../drivers/fsl_enet.c **** static bool ENET_Ptp1588ParseFrame(const uint8_t *data, enet_ptp_time_data_t *ptpTsData, bool isFas
 222:../drivers/fsl_enet.c **** 
 223:../drivers/fsl_enet.c **** /*!
 224:../drivers/fsl_enet.c ****  * @brief Updates the new PTP 1588 time-stamp to the time-stamp buffer ring.
 225:../drivers/fsl_enet.c ****  *
 226:../drivers/fsl_enet.c ****  * @param ptpTsDataRing The PTP message and time-stamp data ring pointer.
 227:../drivers/fsl_enet.c ****  * @param ptpTimeData   The new PTP 1588 time-stamp data pointer.
 228:../drivers/fsl_enet.c ****  */
 229:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588UpdateTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
 230:../drivers/fsl_enet.c **** 
 231:../drivers/fsl_enet.c **** /*!
 232:../drivers/fsl_enet.c ****  * @brief Search up the right PTP 1588 time-stamp from the time-stamp buffer ring.
 233:../drivers/fsl_enet.c ****  *
 234:../drivers/fsl_enet.c ****  * @param ptpTsDataRing The PTP message and time-stamp data ring pointer.
 235:../drivers/fsl_enet.c ****  * @param ptpTimeData   The find out right PTP 1588 time-stamp data pointer with the specific PTP m
 236:../drivers/fsl_enet.c ****  */
 237:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588SearchTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
 238:../drivers/fsl_enet.c **** 
 239:../drivers/fsl_enet.c **** /*!
 240:../drivers/fsl_enet.c ****  * @brief Store the transmit time-stamp for event PTP frame in the time-stamp buffer ring.
 241:../drivers/fsl_enet.c ****  *
 242:../drivers/fsl_enet.c ****  * @param base   ENET peripheral base address.
 243:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 244:../drivers/fsl_enet.c ****  * @param ringId The descriptor ring index, range from 0 ~ FSL_FEATURE_ENET_QUEUE - 1.
 245:../drivers/fsl_enet.c ****  *               0 ----- for single ring kinetis platform.
 246:../drivers/fsl_enet.c ****  *               0 ~ 2 for mulit-ring supported IMX8qm.
 247:../drivers/fsl_enet.c ****  */
 248:../drivers/fsl_enet.c **** static status_t ENET_StoreTxFrameTime(ENET_Type *base, enet_handle_t *handle, uint32_t ringId);
 249:../drivers/fsl_enet.c **** 
 250:../drivers/fsl_enet.c **** /*!
 251:../drivers/fsl_enet.c ****  * @brief Store the receive time-stamp for event PTP frame in the time-stamp buffer ring.
 252:../drivers/fsl_enet.c ****  *
 253:../drivers/fsl_enet.c ****  * @param base   ENET peripheral base address.
 254:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 255:../drivers/fsl_enet.c ****  * @param ptpTimeData The PTP 1588 time-stamp data pointer.
 256:../drivers/fsl_enet.c ****  */
 257:../drivers/fsl_enet.c **** static status_t ENET_StoreRxFrameTime(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_data_t 
 258:../drivers/fsl_enet.c **** 
 259:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_AVB
 260:../drivers/fsl_enet.c **** /*!
 261:../drivers/fsl_enet.c ****  * @brief Gets the ring index for transmission.
 262:../drivers/fsl_enet.c ****  *
 263:../drivers/fsl_enet.c ****  * @param base  ENET peripheral base address.
 264:../drivers/fsl_enet.c ****  * @param data The ENET transmit data.
 265:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 266:../drivers/fsl_enet.c ****  *
 267:../drivers/fsl_enet.c ****  * @note This must be called after the MAC configuration and
 268:../drivers/fsl_enet.c ****  * state are ready. It must be called after the ENET_Init() and
 269:../drivers/fsl_enet.c ****  * this should be called when the ENET receive required.
 270:../drivers/fsl_enet.c ****  */
 271:../drivers/fsl_enet.c **** static uint8_t ENET_GetTxRingId(ENET_Type *base, uint8_t *data, enet_handle_t *handle);
 272:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 273:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 274:../drivers/fsl_enet.c **** 
 275:../drivers/fsl_enet.c **** /*******************************************************************************
 276:../drivers/fsl_enet.c ****  * Variables
 277:../drivers/fsl_enet.c ****  ******************************************************************************/
 278:../drivers/fsl_enet.c **** 
 279:../drivers/fsl_enet.c **** /*! @brief Pointers to enet handles for each instance. */
 280:../drivers/fsl_enet.c **** static enet_handle_t *s_ENETHandle[FSL_FEATURE_SOC_ENET_COUNT] = {NULL};
 281:../drivers/fsl_enet.c **** 
 282:../drivers/fsl_enet.c **** /*! @brief Pointers to enet clocks for each instance. */
 283:../drivers/fsl_enet.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 284:../drivers/fsl_enet.c **** const clock_ip_name_t s_enetClock[] = ENET_CLOCKS;
 285:../drivers/fsl_enet.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 286:../drivers/fsl_enet.c **** 
 287:../drivers/fsl_enet.c **** /*! @brief Pointers to enet transmit IRQ number for each instance. */
 288:../drivers/fsl_enet.c **** static const IRQn_Type s_enetTxIrqId[] = ENET_Transmit_IRQS;
 289:../drivers/fsl_enet.c **** /*! @brief Pointers to enet receive IRQ number for each instance. */
 290:../drivers/fsl_enet.c **** static const IRQn_Type s_enetRxIrqId[] = ENET_Receive_IRQS;
 291:../drivers/fsl_enet.c **** #if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) && ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 292:../drivers/fsl_enet.c **** /*! @brief Pointers to enet timestamp IRQ number for each instance. */
 293:../drivers/fsl_enet.c **** static const IRQn_Type s_enetTsIrqId[] = ENET_1588_Timer_IRQS;
 294:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 295:../drivers/fsl_enet.c **** /*! @brief Pointers to enet error IRQ number for each instance. */
 296:../drivers/fsl_enet.c **** static const IRQn_Type s_enetErrIrqId[] = ENET_Error_IRQS;
 297:../drivers/fsl_enet.c **** 
 298:../drivers/fsl_enet.c **** /*! @brief Pointers to enet bases for each instance. */
 299:../drivers/fsl_enet.c **** static ENET_Type *const s_enetBases[] = ENET_BASE_PTRS;
 300:../drivers/fsl_enet.c **** 
 301:../drivers/fsl_enet.c **** /* ENET ISR for transactional APIs. */
 302:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 303:../drivers/fsl_enet.c **** static enet_isr_ring_t s_enetTxIsr;
 304:../drivers/fsl_enet.c **** static enet_isr_ring_t s_enetRxIsr;
 305:../drivers/fsl_enet.c **** #else
 306:../drivers/fsl_enet.c **** static enet_isr_t s_enetTxIsr;
 307:../drivers/fsl_enet.c **** static enet_isr_t s_enetRxIsr;
 308:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 309:../drivers/fsl_enet.c **** static enet_isr_t s_enetErrIsr;
 310:../drivers/fsl_enet.c **** static enet_isr_t s_enetTsIsr;
 311:../drivers/fsl_enet.c **** /*******************************************************************************
 312:../drivers/fsl_enet.c ****  * Code
 313:../drivers/fsl_enet.c ****  ******************************************************************************/
 314:../drivers/fsl_enet.c **** 
 315:../drivers/fsl_enet.c **** uint32_t ENET_GetInstance(ENET_Type *base)
 316:../drivers/fsl_enet.c **** {
 317:../drivers/fsl_enet.c ****     uint32_t instance;
 318:../drivers/fsl_enet.c **** 
 319:../drivers/fsl_enet.c ****     /* Find the instance index from base address mappings. */
 320:../drivers/fsl_enet.c ****     for (instance = 0; instance < ARRAY_SIZE(s_enetBases); instance++)
 321:../drivers/fsl_enet.c ****     {
 322:../drivers/fsl_enet.c ****         if (s_enetBases[instance] == base)
 323:../drivers/fsl_enet.c ****         {
 324:../drivers/fsl_enet.c ****             break;
 325:../drivers/fsl_enet.c ****         }
 326:../drivers/fsl_enet.c ****     }
 327:../drivers/fsl_enet.c **** 
 328:../drivers/fsl_enet.c ****     assert(instance < ARRAY_SIZE(s_enetBases));
 329:../drivers/fsl_enet.c **** 
 330:../drivers/fsl_enet.c ****     return instance;
 331:../drivers/fsl_enet.c **** }
 332:../drivers/fsl_enet.c **** 
 333:../drivers/fsl_enet.c **** void ENET_GetDefaultConfig(enet_config_t *config)
 334:../drivers/fsl_enet.c **** {
 335:../drivers/fsl_enet.c ****     /* Checks input parameter. */
 336:../drivers/fsl_enet.c ****     assert(config);
 337:../drivers/fsl_enet.c **** 
 338:../drivers/fsl_enet.c ****     /* Initializes the MAC configure structure to zero. */
 339:../drivers/fsl_enet.c ****     memset(config, 0, sizeof(enet_config_t));
 340:../drivers/fsl_enet.c **** 
 341:../drivers/fsl_enet.c ****     /* Sets MII mode, full duplex, 100Mbps for MAC and PHY data interface. */
 342:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB 
 343:../drivers/fsl_enet.c ****     config->miiMode = kENET_RgmiiMode;
 344:../drivers/fsl_enet.c **** #else
 345:../drivers/fsl_enet.c ****     config->miiMode = kENET_RmiiMode;
 346:../drivers/fsl_enet.c **** #endif
 347:../drivers/fsl_enet.c ****     config->miiSpeed = kENET_MiiSpeed100M; 
 348:../drivers/fsl_enet.c ****     config->miiDuplex = kENET_MiiFullDuplex;
 349:../drivers/fsl_enet.c **** 
 350:../drivers/fsl_enet.c ****     config->ringNum = 1;
 351:../drivers/fsl_enet.c **** 
 352:../drivers/fsl_enet.c ****     /* Sets the maximum receive frame length. */
 353:../drivers/fsl_enet.c ****     config->rxMaxFrameLen = ENET_FRAME_MAX_FRAMELEN;
 354:../drivers/fsl_enet.c **** }
 355:../drivers/fsl_enet.c **** 
 356:../drivers/fsl_enet.c **** void ENET_Init(ENET_Type *base,
 357:../drivers/fsl_enet.c ****                enet_handle_t *handle,
 358:../drivers/fsl_enet.c ****                const enet_config_t *config,
 359:../drivers/fsl_enet.c ****                const enet_buffer_config_t *bufferConfig,
 360:../drivers/fsl_enet.c ****                uint8_t *macAddr,
 361:../drivers/fsl_enet.c ****                uint32_t srcClock_Hz)
 362:../drivers/fsl_enet.c **** {
 363:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 364:../drivers/fsl_enet.c ****     assert(handle);
 365:../drivers/fsl_enet.c ****     assert(config);
 366:../drivers/fsl_enet.c ****     assert(bufferConfig);
 367:../drivers/fsl_enet.c ****     assert(macAddr);
 368:../drivers/fsl_enet.c ****     assert(config->ringNum <= FSL_FEATURE_ENET_QUEUE);
 369:../drivers/fsl_enet.c **** 
 370:../drivers/fsl_enet.c ****     uint8_t count;
 371:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 372:../drivers/fsl_enet.c **** 
 373:../drivers/fsl_enet.c ****     /* Check the input parameter. */
 374:../drivers/fsl_enet.c ****     for (count = 0; count < config->ringNum; count++)
 375:../drivers/fsl_enet.c ****     {
 376:../drivers/fsl_enet.c ****         assert(buffCfg);
 377:../drivers/fsl_enet.c ****         assert(buffCfg->rxBuffSizeAlign * buffCfg->rxBdNumber > config->rxMaxFrameLen);
 378:../drivers/fsl_enet.c ****         buffCfg++;
 379:../drivers/fsl_enet.c ****     }
 380:../drivers/fsl_enet.c **** 
 381:../drivers/fsl_enet.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 382:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 383:../drivers/fsl_enet.c **** 
 384:../drivers/fsl_enet.c ****     /* Ungate ENET clock. */
 385:../drivers/fsl_enet.c ****     CLOCK_EnableClock(s_enetClock[instance]);
 386:../drivers/fsl_enet.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 387:../drivers/fsl_enet.c ****     /* Reset ENET module. */
 388:../drivers/fsl_enet.c ****     ENET_Reset(base);
 389:../drivers/fsl_enet.c **** 
 390:../drivers/fsl_enet.c ****     /* Initializes the ENET transmit buffer descriptors. */
 391:../drivers/fsl_enet.c ****     ENET_SetTxBufferDescriptors(handle, config, bufferConfig);
 392:../drivers/fsl_enet.c **** 
 393:../drivers/fsl_enet.c ****     /* Initializes the ENET receive buffer descriptors. */
 394:../drivers/fsl_enet.c ****     ENET_SetRxBufferDescriptors(handle, config, bufferConfig);
 395:../drivers/fsl_enet.c **** 
 396:../drivers/fsl_enet.c ****     /* Initializes the ENET MAC controller with basic function. */
 397:../drivers/fsl_enet.c ****     ENET_SetMacController(base, handle, config, bufferConfig, macAddr, srcClock_Hz);
 398:../drivers/fsl_enet.c **** 
 399:../drivers/fsl_enet.c ****     /* Set all buffers or data in handler for data transmit/receive process. */
 400:../drivers/fsl_enet.c ****     ENET_SetHandler(base, handle, config, bufferConfig);
 401:../drivers/fsl_enet.c **** }
 402:../drivers/fsl_enet.c **** 
 403:../drivers/fsl_enet.c **** void ENET_Deinit(ENET_Type *base)
 404:../drivers/fsl_enet.c **** {
 405:../drivers/fsl_enet.c ****     /* Disable interrupt. */
 406:../drivers/fsl_enet.c ****     base->EIMR = 0;
 407:../drivers/fsl_enet.c **** 
 408:../drivers/fsl_enet.c ****     /* Disable ENET. */
 409:../drivers/fsl_enet.c ****     base->ECR &= ~ENET_ECR_ETHEREN_MASK;
 410:../drivers/fsl_enet.c **** 
 411:../drivers/fsl_enet.c **** 
 412:../drivers/fsl_enet.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 413:../drivers/fsl_enet.c ****     /* Disables the clock source. */
 414:../drivers/fsl_enet.c ****     CLOCK_DisableClock(s_enetClock[ENET_GetInstance(base)]);
 415:../drivers/fsl_enet.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 416:../drivers/fsl_enet.c **** }
 417:../drivers/fsl_enet.c **** 
 418:../drivers/fsl_enet.c **** void ENET_SetCallback(enet_handle_t *handle, enet_callback_t callback, void *userData)
 419:../drivers/fsl_enet.c **** {
 420:../drivers/fsl_enet.c ****     assert(handle);
 421:../drivers/fsl_enet.c **** 
 422:../drivers/fsl_enet.c ****     /* Set callback and userData. */
 423:../drivers/fsl_enet.c ****     handle->callback = callback;
 424:../drivers/fsl_enet.c ****     handle->userData = userData;
 425:../drivers/fsl_enet.c **** }
 426:../drivers/fsl_enet.c **** 
 427:../drivers/fsl_enet.c **** static void ENET_SetHandler(ENET_Type *base,
 428:../drivers/fsl_enet.c ****                             enet_handle_t *handle,
 429:../drivers/fsl_enet.c ****                             const enet_config_t *config,
 430:../drivers/fsl_enet.c ****                             const enet_buffer_config_t *bufferConfig)
 431:../drivers/fsl_enet.c **** {
 432:../drivers/fsl_enet.c ****     uint8_t count;
 433:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 434:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 435:../drivers/fsl_enet.c **** 
 436:../drivers/fsl_enet.c ****     /* Store transfer parameters in handle pointer. */
 437:../drivers/fsl_enet.c ****     memset(handle, 0, sizeof(enet_handle_t));
 438:../drivers/fsl_enet.c **** 
 439:../drivers/fsl_enet.c ****     handle->ringNum = (config->ringNum > FSL_FEATURE_ENET_QUEUE) ? FSL_FEATURE_ENET_QUEUE : config-
 440:../drivers/fsl_enet.c ****     for (count = 0; count < handle->ringNum; count++)
 441:../drivers/fsl_enet.c ****     {
 442:../drivers/fsl_enet.c ****         handle->rxBdBase[count] = buffCfg->rxBdStartAddrAlign;
 443:../drivers/fsl_enet.c ****         handle->rxBdCurrent[count] = buffCfg->rxBdStartAddrAlign;
 444:../drivers/fsl_enet.c ****         handle->rxBuffSizeAlign[count] = buffCfg->rxBuffSizeAlign;
 445:../drivers/fsl_enet.c ****         handle->txBdBase[count] = buffCfg->txBdStartAddrAlign;
 446:../drivers/fsl_enet.c ****         handle->txBdCurrent[count] = buffCfg->txBdStartAddrAlign;
 447:../drivers/fsl_enet.c ****         handle->txBuffSizeAlign[count] = buffCfg->txBuffSizeAlign;
 448:../drivers/fsl_enet.c ****         buffCfg++;
 449:../drivers/fsl_enet.c ****     }
 450:../drivers/fsl_enet.c **** 
 451:../drivers/fsl_enet.c ****     /* Save the handle pointer in the global variables. */
 452:../drivers/fsl_enet.c ****     s_ENETHandle[instance] = handle;
 453:../drivers/fsl_enet.c **** 
 454:../drivers/fsl_enet.c ****     /* Set the IRQ handler when the interrupt is enabled. */
 455:../drivers/fsl_enet.c ****     if (config->interrupt & ENET_TX_INTERRUPT)
 456:../drivers/fsl_enet.c ****     {
 457:../drivers/fsl_enet.c ****         s_enetTxIsr = ENET_TransmitIRQHandler;
 458:../drivers/fsl_enet.c ****         EnableIRQ(s_enetTxIrqId[instance]);
 459:../drivers/fsl_enet.c ****     }
 460:../drivers/fsl_enet.c ****     if (config->interrupt & ENET_RX_INTERRUPT)
 461:../drivers/fsl_enet.c ****     {
 462:../drivers/fsl_enet.c ****         s_enetRxIsr = ENET_ReceiveIRQHandler;
 463:../drivers/fsl_enet.c ****         EnableIRQ(s_enetRxIrqId[instance]);
 464:../drivers/fsl_enet.c ****     }
 465:../drivers/fsl_enet.c ****     if (config->interrupt & ENET_ERR_INTERRUPT)
 466:../drivers/fsl_enet.c ****     {
 467:../drivers/fsl_enet.c ****         s_enetErrIsr = ENET_ErrorIRQHandler;
 468:../drivers/fsl_enet.c ****         EnableIRQ(s_enetErrIrqId[instance]);
 469:../drivers/fsl_enet.c ****     }
 470:../drivers/fsl_enet.c **** }
 471:../drivers/fsl_enet.c **** 
 472:../drivers/fsl_enet.c **** static void ENET_SetMacController(ENET_Type *base,
 473:../drivers/fsl_enet.c ****                                   enet_handle_t *handle,
 474:../drivers/fsl_enet.c ****                                   const enet_config_t *config,
 475:../drivers/fsl_enet.c ****                                   const enet_buffer_config_t *bufferConfig,
 476:../drivers/fsl_enet.c ****                                   uint8_t *macAddr,
 477:../drivers/fsl_enet.c ****                                   uint32_t srcClock_Hz)
 478:../drivers/fsl_enet.c **** {
 479:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 480:../drivers/fsl_enet.c ****     /* Check the MII mode/speed/duplex setting. */
 481:../drivers/fsl_enet.c ****     if (config->miiSpeed == kENET_MiiSpeed1000M)
 482:../drivers/fsl_enet.c ****     {
 483:../drivers/fsl_enet.c ****         /* Only RGMII mode has the 1000M bit/s. The 1000M only support full duplex. */
 484:../drivers/fsl_enet.c ****         assert(config->miiMode == kENET_RgmiiMode);
 485:../drivers/fsl_enet.c ****         assert(config->miiDuplex == kENET_MiiFullDuplex);
 486:../drivers/fsl_enet.c ****     }
 487:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 488:../drivers/fsl_enet.c **** 
 489:../drivers/fsl_enet.c ****     uint32_t rcr = 0;
 490:../drivers/fsl_enet.c ****     uint32_t tcr = 0;
 491:../drivers/fsl_enet.c ****     uint32_t ecr = base->ECR;
 492:../drivers/fsl_enet.c ****     uint32_t macSpecialConfig = config->macSpecialConfig;
 493:../drivers/fsl_enet.c ****     uint32_t maxFrameLen = config->rxMaxFrameLen;
 494:../drivers/fsl_enet.c **** 
 495:../drivers/fsl_enet.c ****     /* Maximum frame length check. */
 496:../drivers/fsl_enet.c ****     if ((macSpecialConfig & kENET_ControlVLANTagEnable) && (maxFrameLen <= ENET_FRAME_MAX_FRAMELEN)
 497:../drivers/fsl_enet.c ****     {
 498:../drivers/fsl_enet.c ****         maxFrameLen = (ENET_FRAME_MAX_FRAMELEN + ENET_FRAME_VLAN_TAGLEN);
 499:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 500:../drivers/fsl_enet.c ****         if (macSpecialConfig & kENET_ControlSVLANEnable)
 501:../drivers/fsl_enet.c ****         {
 502:../drivers/fsl_enet.c ****             /* Double vlan tag (SVLAN) supported. */
 503:../drivers/fsl_enet.c ****             maxFrameLen += ENET_FRAME_VLAN_TAGLEN;
 504:../drivers/fsl_enet.c ****         }
 505:../drivers/fsl_enet.c ****         ecr |= ((macSpecialConfig & kENET_ControlSVLANEnable) ? (ENET_ECR_SVLANEN_MASK | ENET_ECR_S
 506:../drivers/fsl_enet.c ****                ((macSpecialConfig & kENET_ControlVLANUseSecondTag) ? ENET_ECR_VLANUSE2ND_MASK : 0);
 507:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 508:../drivers/fsl_enet.c ****     }
 509:../drivers/fsl_enet.c **** 
 510:../drivers/fsl_enet.c ****     /* Configures MAC receive controller with user configure structure. */
 511:../drivers/fsl_enet.c ****     rcr = ((macSpecialConfig & kENET_ControlRxPayloadCheckEnable) ? ENET_RCR_NLC_MASK : 0) |
 512:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_CFEN_MASK : 0) |
 513:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_FCE_MASK : 0) |
 514:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxPadRemoveEnable) ? ENET_RCR_PADEN_MASK : 0) |
 515:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxBroadCastRejectEnable) ? ENET_RCR_BC_REJ_MASK : 0) |
 516:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlPromiscuousEnable) ? ENET_RCR_PROM_MASK : 0) |
 517:../drivers/fsl_enet.c ****           ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD_MASK;    
 518:../drivers/fsl_enet.c **** 
 519:../drivers/fsl_enet.c **** /* Set the RGMII or RMII, MII mode and control register. */
 520:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 521:../drivers/fsl_enet.c ****     if (config->miiMode == kENET_RgmiiMode)
 522:../drivers/fsl_enet.c ****     {
 523:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_RGMII_EN_MASK;
 524:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_MII_MODE_MASK;
 525:../drivers/fsl_enet.c ****     }
 526:../drivers/fsl_enet.c ****     else
 527:../drivers/fsl_enet.c ****     {
 528:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_RGMII_EN_MASK;
 529:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 530:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_MII_MODE_MASK;
 531:../drivers/fsl_enet.c ****         if (config->miiMode == kENET_RmiiMode)
 532:../drivers/fsl_enet.c ****         {
 533:../drivers/fsl_enet.c ****             rcr |= ENET_RCR_RMII_MODE_MASK;
 534:../drivers/fsl_enet.c ****         }
 535:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 536:../drivers/fsl_enet.c ****     }
 537:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 538:../drivers/fsl_enet.c ****     /* Speed. */
 539:../drivers/fsl_enet.c ****     if (config->miiSpeed == kENET_MiiSpeed10M)
 540:../drivers/fsl_enet.c ****     {
 541:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_RMII_10T_MASK;
 542:../drivers/fsl_enet.c ****     }
 543:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 544:../drivers/fsl_enet.c ****     if (config->miiSpeed == kENET_MiiSpeed1000M)
 545:../drivers/fsl_enet.c ****     {
 546:../drivers/fsl_enet.c ****         ecr |= ENET_ECR_SPEED_MASK;
 547:../drivers/fsl_enet.c ****     }
 548:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 549:../drivers/fsl_enet.c **** 
 550:../drivers/fsl_enet.c ****     /* Receive setting for half duplex. */
 551:../drivers/fsl_enet.c ****     if (config->miiDuplex == kENET_MiiHalfDuplex)
 552:../drivers/fsl_enet.c ****     {
 553:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_DRT_MASK;
 554:../drivers/fsl_enet.c ****     }
 555:../drivers/fsl_enet.c ****     /* Sets internal loop only for MII mode. */
 556:../drivers/fsl_enet.c ****     if ((config->macSpecialConfig & kENET_ControlMIILoopEnable) && (config->miiMode != kENET_RmiiMo
 557:../drivers/fsl_enet.c ****     {
 558:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_LOOP_MASK;
 559:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_DRT_MASK;
 560:../drivers/fsl_enet.c ****     }
 561:../drivers/fsl_enet.c ****     base->RCR = rcr;
 562:../drivers/fsl_enet.c **** 
 563:../drivers/fsl_enet.c ****     /* Configures MAC transmit controller: duplex mode, mac address insertion. */
 564:../drivers/fsl_enet.c ****     tcr = base->TCR & ~(ENET_TCR_FDEN_MASK | ENET_TCR_ADDINS_MASK);
 565:../drivers/fsl_enet.c ****     tcr |= (config->miiDuplex ? ENET_TCR_FDEN_MASK : 0) |
 566:../drivers/fsl_enet.c ****            ((macSpecialConfig & kENET_ControlMacAddrInsert) ? ENET_TCR_ADDINS_MASK : 0);
 567:../drivers/fsl_enet.c ****     base->TCR = tcr;
 568:../drivers/fsl_enet.c **** 
 569:../drivers/fsl_enet.c ****     /* Configures receive and transmit accelerator. */
 570:../drivers/fsl_enet.c ****     base->TACC = config->txAccelerConfig;
 571:../drivers/fsl_enet.c ****     base->RACC = config->rxAccelerConfig;
 572:../drivers/fsl_enet.c **** 
 573:../drivers/fsl_enet.c ****     /* Sets the pause duration and FIFO threshold for the flow control enabled case. */
 574:../drivers/fsl_enet.c ****     if (macSpecialConfig & kENET_ControlFlowControlEnable)
 575:../drivers/fsl_enet.c ****     {
 576:../drivers/fsl_enet.c ****         uint32_t reemReg;
 577:../drivers/fsl_enet.c ****         base->OPD = config->pauseDuration;
 578:../drivers/fsl_enet.c ****         reemReg = ENET_RSEM_RX_SECTION_EMPTY(config->rxFifoEmptyThreshold);
 579:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_T
 580:../drivers/fsl_enet.c ****         reemReg |= ENET_RSEM_STAT_SECTION_EMPTY(config->rxFifoStatEmptyThreshold);
 581:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 582:../drivers/fsl_enet.c ****         base->RSEM = reemReg;
 583:../drivers/fsl_enet.c ****     }
 584:../drivers/fsl_enet.c **** 
 585:../drivers/fsl_enet.c ****     /* FIFO threshold setting for store and forward enable/disable case. */
 586:../drivers/fsl_enet.c ****     if (macSpecialConfig & kENET_ControlStoreAndFwdDisable)
 587:../drivers/fsl_enet.c ****     {
 588:../drivers/fsl_enet.c ****         /* Transmit fifo watermark settings. */
 589:../drivers/fsl_enet.c ****         base->TFWR = config->txFifoWatermark & ENET_TFWR_TFWR_MASK;
 590:../drivers/fsl_enet.c ****         /* Receive fifo full threshold settings. */
 591:../drivers/fsl_enet.c ****         base->RSFL = config->rxFifoFullThreshold & ENET_RSFL_RX_SECTION_FULL_MASK;
 592:../drivers/fsl_enet.c ****     }
 593:../drivers/fsl_enet.c ****     else
 594:../drivers/fsl_enet.c ****     {
 595:../drivers/fsl_enet.c ****         /* Transmit fifo watermark settings. */
 596:../drivers/fsl_enet.c ****         base->TFWR = ENET_TFWR_STRFWD_MASK;
 597:../drivers/fsl_enet.c ****         base->RSFL = 0;
 598:../drivers/fsl_enet.c ****     }
 599:../drivers/fsl_enet.c **** 
 600:../drivers/fsl_enet.c ****     /* Enable store and forward when accelerator is enabled */
 601:../drivers/fsl_enet.c ****     if (config->txAccelerConfig & (kENET_TxAccelIpCheckEnabled | kENET_TxAccelProtoCheckEnabled))
 602:../drivers/fsl_enet.c ****     {
 603:../drivers/fsl_enet.c ****         base->TFWR = ENET_TFWR_STRFWD_MASK;
 604:../drivers/fsl_enet.c ****     }
 605:../drivers/fsl_enet.c ****     if (config->rxAccelerConfig & (kENET_RxAccelIpCheckEnabled | kENET_RxAccelProtoCheckEnabled))
 606:../drivers/fsl_enet.c ****     {
 607:../drivers/fsl_enet.c ****         base->RSFL = 0;
 608:../drivers/fsl_enet.c ****     }
 609:../drivers/fsl_enet.c **** 
 610:../drivers/fsl_enet.c ****     /* Initializes the ring 0. */
 611:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 612:../drivers/fsl_enet.c ****     base->TDSR = MEMORY_ConvertMemoryMapAddress((uint32_t)bufferConfig->txBdStartAddrAlign, kMEMORY
 613:../drivers/fsl_enet.c ****     base->RDSR = MEMORY_ConvertMemoryMapAddress((uint32_t)bufferConfig->rxBdStartAddrAlign, kMEMORY
 614:../drivers/fsl_enet.c **** #else
 615:../drivers/fsl_enet.c ****     base->TDSR = (uint32_t)bufferConfig->txBdStartAddrAlign;
 616:../drivers/fsl_enet.c ****     base->RDSR = (uint32_t)bufferConfig->rxBdStartAddrAlign;
 617:../drivers/fsl_enet.c **** #endif    
 618:../drivers/fsl_enet.c ****     base->MRBR = bufferConfig->rxBuffSizeAlign;
 619:../drivers/fsl_enet.c **** 
 620:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 621:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 622:../drivers/fsl_enet.c **** 
 623:../drivers/fsl_enet.c ****     if (config->ringNum > 1)
 624:../drivers/fsl_enet.c ****     {
 625:../drivers/fsl_enet.c ****         /* Initializes the ring 1. */
 626:../drivers/fsl_enet.c ****         buffCfg++;
 627:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 628:../drivers/fsl_enet.c ****         base->TDSR1 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->txBdStartAddrAlign, kMEMORY
 629:../drivers/fsl_enet.c ****         base->RDSR1 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->rxBdStartAddrAlign, kMEMORY
 630:../drivers/fsl_enet.c **** #else
 631:../drivers/fsl_enet.c ****         base->TDSR1 = (uint32_t)buffCfg->txBdStartAddrAlign;
 632:../drivers/fsl_enet.c ****         base->RDSR1 = (uint32_t)buffCfg->rxBdStartAddrAlign;     
 633:../drivers/fsl_enet.c **** #endif
 634:../drivers/fsl_enet.c ****         base->MRBR1 = buffCfg->rxBuffSizeAlign;
 635:../drivers/fsl_enet.c ****         /* Enable the DMAC for ring 1 and with no rx classification set. */
 636:../drivers/fsl_enet.c ****         base->DMACFG[0] = ENET_DMACFG_DMA_CLASS_EN_MASK;
 637:../drivers/fsl_enet.c ****     }
 638:../drivers/fsl_enet.c ****     if (config->ringNum > 2)
 639:../drivers/fsl_enet.c ****     {
 640:../drivers/fsl_enet.c ****         /* Initializes the ring 2. */
 641:../drivers/fsl_enet.c ****         buffCfg++;
 642:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 643:../drivers/fsl_enet.c ****         base->TDSR2 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->txBdStartAddrAlign, kMEMORY
 644:../drivers/fsl_enet.c ****         base->RDSR2 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->rxBdStartAddrAlign, kMEMORY
 645:../drivers/fsl_enet.c **** #else
 646:../drivers/fsl_enet.c ****         base->TDSR2 = (uint32_t)buffCfg->txBdStartAddrAlign;
 647:../drivers/fsl_enet.c ****         base->RDSR2 = (uint32_t)buffCfg->rxBdStartAddrAlign;
 648:../drivers/fsl_enet.c **** #endif
 649:../drivers/fsl_enet.c ****         base->MRBR2 = buffCfg->rxBuffSizeAlign;
 650:../drivers/fsl_enet.c ****         /* Enable the DMAC for ring 2 and with no rx classification set. */
 651:../drivers/fsl_enet.c ****         base->DMACFG[1] = ENET_DMACFG_DMA_CLASS_EN_MASK;
 652:../drivers/fsl_enet.c ****     }
 653:../drivers/fsl_enet.c **** 
 654:../drivers/fsl_enet.c ****     /* Default the class/ring 1 and 2 are not enabled and the receive classification is disabled
 655:../drivers/fsl_enet.c ****      * so we set the default transmit scheme with the round-robin mode. beacuse the legacy bd mode
 656:../drivers/fsl_enet.c ****      * only support the round-robin mode. if the avb feature is required, just call the setup avb
 657:../drivers/fsl_enet.c ****      * feature API. */
 658:../drivers/fsl_enet.c ****     base->QOS |= ENET_QOS_TX_SCHEME(1);
 659:../drivers/fsl_enet.c **** #endif /*  FSL_FEATURE_ENET_HAS_AVB */
 660:../drivers/fsl_enet.c **** 
 661:../drivers/fsl_enet.c ****     /* Configures the Mac address. */
 662:../drivers/fsl_enet.c ****     ENET_SetMacAddr(base, macAddr);
 663:../drivers/fsl_enet.c **** 
 664:../drivers/fsl_enet.c ****     /* Initialize the SMI if uninitialized. */
 665:../drivers/fsl_enet.c ****     if (!ENET_GetSMI(base))
 666:../drivers/fsl_enet.c ****     {
 667:../drivers/fsl_enet.c ****         ENET_SetSMI(base, srcClock_Hz, !!(config->macSpecialConfig & kENET_ControlSMIPreambleDisabl
 668:../drivers/fsl_enet.c ****     }
 669:../drivers/fsl_enet.c **** 
 670:../drivers/fsl_enet.c **** /* Enables Ethernet interrupt, enables the interrupt coalsecing if it is required. */
 671:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
 672:../drivers/fsl_enet.c ****     if (config->intCoalesceCfg)
 673:../drivers/fsl_enet.c ****     {
 674:../drivers/fsl_enet.c ****         uint32_t intMask = (ENET_EIMR_TXB_MASK | ENET_EIMR_RXB_MASK);
 675:../drivers/fsl_enet.c **** 
 676:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 677:../drivers/fsl_enet.c ****         uint8_t queue = 0;
 678:../drivers/fsl_enet.c ****         intMask |= ENET_EIMR_TXB2_MASK | ENET_EIMR_RXB2_MASK | ENET_EIMR_TXB1_MASK | ENET_EIMR_RXB1
 679:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 680:../drivers/fsl_enet.c **** 
 681:../drivers/fsl_enet.c ****         /* Clear all buffer interrupts. */
 682:../drivers/fsl_enet.c ****         base->EIMR &= ~intMask;
 683:../drivers/fsl_enet.c **** 
 684:../drivers/fsl_enet.c **** /* Set the interrupt coalescence. */
 685:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 686:../drivers/fsl_enet.c ****         for (queue = 0; queue < FSL_FEATURE_ENET_QUEUE; queue++)
 687:../drivers/fsl_enet.c ****         {
 688:../drivers/fsl_enet.c ****             base->TXIC[queue] = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[queue])
 689:../drivers/fsl_enet.c ****                                 config->intCoalesceCfg->txCoalesceTimeCount[queue] | ENET_TXIC_ICCS
 690:../drivers/fsl_enet.c ****                                 ENET_TXIC_ICEN_MASK;
 691:../drivers/fsl_enet.c ****             base->RXIC[queue] = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[queue])
 692:../drivers/fsl_enet.c ****                                 config->intCoalesceCfg->rxCoalesceTimeCount[queue] | ENET_RXIC_ICCS
 693:../drivers/fsl_enet.c ****                                 ENET_RXIC_ICEN_MASK;
 694:../drivers/fsl_enet.c ****         }
 695:../drivers/fsl_enet.c **** #else
 696:../drivers/fsl_enet.c ****         base->TXIC = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[0]) |
 697:../drivers/fsl_enet.c ****                      config->intCoalesceCfg->txCoalesceTimeCount[0] | ENET_TXIC_ICCS_MASK | ENET_TX
 698:../drivers/fsl_enet.c ****         base->RXIC = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[0]) |
 699:../drivers/fsl_enet.c ****                      config->intCoalesceCfg->rxCoalesceTimeCount[0] | ENET_RXIC_ICCS_MASK | ENET_RX
 700:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 701:../drivers/fsl_enet.c ****     }
 702:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
 703:../drivers/fsl_enet.c ****     ENET_EnableInterrupts(base, config->interrupt);
 704:../drivers/fsl_enet.c **** 
 705:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 706:../drivers/fsl_enet.c ****     /* Sets the 1588 enhanced feature. */
 707:../drivers/fsl_enet.c ****     ecr |= ENET_ECR_EN1588_MASK;
 708:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 709:../drivers/fsl_enet.c ****     /* Enables Ethernet module after all configuration except the buffer descriptor active. */
 710:../drivers/fsl_enet.c ****     ecr |= ENET_ECR_ETHEREN_MASK | ENET_ECR_DBSWP_MASK;
 711:../drivers/fsl_enet.c ****     base->ECR = ecr;
 712:../drivers/fsl_enet.c **** }
 713:../drivers/fsl_enet.c **** 
 714:../drivers/fsl_enet.c **** static void ENET_SetTxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 715:../drivers/fsl_enet.c **** {
 716:../drivers/fsl_enet.c ****     assert(config);
 717:../drivers/fsl_enet.c ****     assert(bufferConfig);
 718:../drivers/fsl_enet.c **** 
 719:../drivers/fsl_enet.c ****     /* Default single ring is supported. */
 720:../drivers/fsl_enet.c ****     uint8_t ringNum;
 721:../drivers/fsl_enet.c ****     uint32_t count;
 722:../drivers/fsl_enet.c ****     uint32_t txBuffSizeAlign;
 723:../drivers/fsl_enet.c ****     uint8_t *txBuffer;
 724:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 725:../drivers/fsl_enet.c **** 
 726:../drivers/fsl_enet.c ****     /* Check the input parameters. */
 727:../drivers/fsl_enet.c ****     for (ringNum = 0; ringNum < config->ringNum; ringNum++)
 728:../drivers/fsl_enet.c ****     {
 729:../drivers/fsl_enet.c ****         if ((buffCfg->txBdStartAddrAlign > 0) && (buffCfg->txBufferAlign > 0))
 730:../drivers/fsl_enet.c ****         {
 731:../drivers/fsl_enet.c ****             volatile enet_tx_bd_struct_t *curBuffDescrip = buffCfg->txBdStartAddrAlign;
 732:../drivers/fsl_enet.c ****             txBuffSizeAlign = buffCfg->txBuffSizeAlign;
 733:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 734:../drivers/fsl_enet.c ****             txBuffer = (uint8_t *)MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->txBufferAlign, 
 735:../drivers/fsl_enet.c **** #else
 736:../drivers/fsl_enet.c ****             txBuffer = buffCfg->txBufferAlign;
 737:../drivers/fsl_enet.c **** #endif
 738:../drivers/fsl_enet.c ****             for (count = 0; count < buffCfg->txBdNumber; count++)
 739:../drivers/fsl_enet.c ****             {
 740:../drivers/fsl_enet.c ****                 /* Set data buffer address. */
 741:../drivers/fsl_enet.c ****                 curBuffDescrip->buffer = (uint8_t *)((uint32_t)&txBuffer[count * txBuffSizeAlign]);
 742:../drivers/fsl_enet.c ****                 /* Initializes data length. */
 743:../drivers/fsl_enet.c ****                 curBuffDescrip->length = 0;
 744:../drivers/fsl_enet.c ****                 /* Sets the crc. */
 745:../drivers/fsl_enet.c ****                 curBuffDescrip->control = ENET_BUFFDESCRIPTOR_TX_TRANMITCRC_MASK;
 746:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 747:../drivers/fsl_enet.c ****                 if (count == buffCfg->txBdNumber - 1)
 748:../drivers/fsl_enet.c ****                 {
 749:../drivers/fsl_enet.c ****                     curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_WRAP_MASK;
 750:../drivers/fsl_enet.c ****                 }
 751:../drivers/fsl_enet.c **** 
 752:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 753:../drivers/fsl_enet.c ****                 /* Enable transmit interrupt for store the transmit timestamp. */
 754:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_INTERRUPT_MASK;
 755:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 756:../drivers/fsl_enet.c ****                 /* Set the type of the frame when the credit-based scheme is used. */
 757:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BD_FTYPE(ringNum);
 758:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 759:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 760:../drivers/fsl_enet.c ****                 /* Increase the index. */
 761:../drivers/fsl_enet.c ****                 curBuffDescrip++;
 762:../drivers/fsl_enet.c ****             }
 763:../drivers/fsl_enet.c ****         }
 764:../drivers/fsl_enet.c ****         buffCfg++;
 765:../drivers/fsl_enet.c ****     }
 766:../drivers/fsl_enet.c **** }
 767:../drivers/fsl_enet.c **** 
 768:../drivers/fsl_enet.c **** static void ENET_SetRxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 769:../drivers/fsl_enet.c **** {
 770:../drivers/fsl_enet.c ****     assert(config);
 771:../drivers/fsl_enet.c ****     assert(bufferConfig);
 772:../drivers/fsl_enet.c **** 
 773:../drivers/fsl_enet.c ****     /* Default single ring is supported. */
 774:../drivers/fsl_enet.c ****     uint8_t ringNum;
 775:../drivers/fsl_enet.c ****     uint32_t count;
 776:../drivers/fsl_enet.c ****     uint32_t rxBuffSizeAlign;
 777:../drivers/fsl_enet.c ****     uint8_t *rxBuffer;
 778:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 779:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 780:../drivers/fsl_enet.c ****     uint32_t mask = (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt);
 781:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 782:../drivers/fsl_enet.c **** 
 783:../drivers/fsl_enet.c ****     /* Check the input parameters. */
 784:../drivers/fsl_enet.c ****     for (ringNum = 0; ringNum < config->ringNum; ringNum++)
 785:../drivers/fsl_enet.c ****     {
 786:../drivers/fsl_enet.c ****         assert(buffCfg->rxBuffSizeAlign >= ENET_RX_MIN_BUFFERSIZE);
 787:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 788:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 789:../drivers/fsl_enet.c ****         if (ringNum == 1)
 790:../drivers/fsl_enet.c ****         {
 791:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame1Interrupt | kENET_RxBuffer1Interrupt);
 792:../drivers/fsl_enet.c ****         }
 793:../drivers/fsl_enet.c ****         else if (ringNum == 2)
 794:../drivers/fsl_enet.c ****         {
 795:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame2Interrupt | kENET_RxBuffer2Interrupt);
 796:../drivers/fsl_enet.c ****         }
 797:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 798:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 799:../drivers/fsl_enet.c **** 
 800:../drivers/fsl_enet.c ****         if ((buffCfg->rxBdStartAddrAlign > 0) && (buffCfg->rxBufferAlign > 0))
 801:../drivers/fsl_enet.c ****         {
 802:../drivers/fsl_enet.c ****             volatile enet_rx_bd_struct_t *curBuffDescrip = buffCfg->rxBdStartAddrAlign;
 803:../drivers/fsl_enet.c ****             rxBuffSizeAlign = buffCfg->rxBuffSizeAlign;
 804:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 805:../drivers/fsl_enet.c ****             rxBuffer = (uint8_t *)MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->rxBufferAlign, 
 806:../drivers/fsl_enet.c **** #else
 807:../drivers/fsl_enet.c ****             rxBuffer = buffCfg->rxBufferAlign;
 808:../drivers/fsl_enet.c **** #endif
 809:../drivers/fsl_enet.c ****             for (count = 0; count < buffCfg->rxBdNumber; count++)
 810:../drivers/fsl_enet.c ****             {
 811:../drivers/fsl_enet.c ****                 /* Set data buffer and the length. */
 812:../drivers/fsl_enet.c ****                 curBuffDescrip->buffer = (uint8_t *)((uint32_t)&rxBuffer[count * rxBuffSizeAlign]);
 813:../drivers/fsl_enet.c ****                 curBuffDescrip->length = 0;
 814:../drivers/fsl_enet.c **** 
 815:../drivers/fsl_enet.c ****                 /* Initializes the buffer descriptors with empty bit. */
 816:../drivers/fsl_enet.c ****                 curBuffDescrip->control = ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
 817:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 818:../drivers/fsl_enet.c ****                 if (count == buffCfg->rxBdNumber - 1)
 819:../drivers/fsl_enet.c ****                 {
 820:../drivers/fsl_enet.c ****                     curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_RX_WRAP_MASK;
 821:../drivers/fsl_enet.c ****                 }
 822:../drivers/fsl_enet.c **** 
 823:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 824:../drivers/fsl_enet.c ****                 if (config->interrupt & mask)
 825:../drivers/fsl_enet.c ****                 {
 826:../drivers/fsl_enet.c ****                     /* Enable receive interrupt. */
 827:../drivers/fsl_enet.c ****                     curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_RX_INTERRUPT_MASK;
 828:../drivers/fsl_enet.c ****                 }
 829:../drivers/fsl_enet.c ****                 else
 830:../drivers/fsl_enet.c ****                 {
 831:../drivers/fsl_enet.c ****                     curBuffDescrip->controlExtend1 = 0;
 832:../drivers/fsl_enet.c ****                 }
 833:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 834:../drivers/fsl_enet.c ****                 /* Increase the index. */
 835:../drivers/fsl_enet.c ****                 curBuffDescrip++;
 836:../drivers/fsl_enet.c ****             }
 837:../drivers/fsl_enet.c ****         }
 838:../drivers/fsl_enet.c ****         buffCfg++;
 839:../drivers/fsl_enet.c ****     }
 840:../drivers/fsl_enet.c **** }
 841:../drivers/fsl_enet.c **** 
 842:../drivers/fsl_enet.c **** static void ENET_ActiveSend(ENET_Type *base, uint32_t ringId)
 843:../drivers/fsl_enet.c **** {
 844:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
 845:../drivers/fsl_enet.c **** 
 846:../drivers/fsl_enet.c ****     switch (ringId)
 847:../drivers/fsl_enet.c ****     {
 848:../drivers/fsl_enet.c ****         case kENET_Ring0:
 849:../drivers/fsl_enet.c ****             base->TDAR = ENET_TDAR_TDAR_MASK;
 850:../drivers/fsl_enet.c ****             break;
 851:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 852:../drivers/fsl_enet.c ****         case kENET_Ring1:
 853:../drivers/fsl_enet.c ****             base->TDAR1 = ENET_TDAR1_TDAR_MASK;
 854:../drivers/fsl_enet.c ****             break;
 855:../drivers/fsl_enet.c ****         case kENET_Ring2:
 856:../drivers/fsl_enet.c ****             base->TDAR2 = ENET_TDAR2_TDAR_MASK;
 857:../drivers/fsl_enet.c ****             break;
 858:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 859:../drivers/fsl_enet.c ****         default:
 860:../drivers/fsl_enet.c ****             base->TDAR = ENET_TDAR_TDAR_MASK;
 861:../drivers/fsl_enet.c ****             break;
 862:../drivers/fsl_enet.c ****     }
 863:../drivers/fsl_enet.c **** }
 864:../drivers/fsl_enet.c **** 
 865:../drivers/fsl_enet.c **** void ENET_SetMII(ENET_Type *base, enet_mii_speed_t speed, enet_mii_duplex_t duplex)
 866:../drivers/fsl_enet.c **** {
 867:../drivers/fsl_enet.c ****     uint32_t rcr = base->RCR;
 868:../drivers/fsl_enet.c ****     uint32_t tcr = base->TCR;
 869:../drivers/fsl_enet.c **** 
 870:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 871:../drivers/fsl_enet.c ****     uint32_t ecr = base->ECR;
 872:../drivers/fsl_enet.c **** 
 873:../drivers/fsl_enet.c ****     if (kENET_MiiSpeed1000M == speed)
 874:../drivers/fsl_enet.c ****     {
 875:../drivers/fsl_enet.c ****         assert(duplex == kENET_MiiFullDuplex);
 876:../drivers/fsl_enet.c ****         ecr |= ENET_ECR_SPEED_MASK;
 877:../drivers/fsl_enet.c ****     }
 878:../drivers/fsl_enet.c ****     else
 879:../drivers/fsl_enet.c ****     {
 880:../drivers/fsl_enet.c ****         ecr &= ~ENET_ECR_SPEED_MASK;
 881:../drivers/fsl_enet.c ****     }
 882:../drivers/fsl_enet.c **** 
 883:../drivers/fsl_enet.c ****     base->ECR = ecr;
 884:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 885:../drivers/fsl_enet.c **** 
 886:../drivers/fsl_enet.c ****     /* Sets speed mode. */
 887:../drivers/fsl_enet.c ****     if (kENET_MiiSpeed10M == speed)
 888:../drivers/fsl_enet.c ****     {
 889:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_RMII_10T_MASK;
 890:../drivers/fsl_enet.c ****     }
 891:../drivers/fsl_enet.c ****     else
 892:../drivers/fsl_enet.c ****     {
 893:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_RMII_10T_MASK;
 894:../drivers/fsl_enet.c ****     }
 895:../drivers/fsl_enet.c ****     /* Set duplex mode. */
 896:../drivers/fsl_enet.c ****     if (duplex == kENET_MiiHalfDuplex)
 897:../drivers/fsl_enet.c ****     {
 898:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_DRT_MASK;
 899:../drivers/fsl_enet.c ****         tcr &= ~ENET_TCR_FDEN_MASK;
 900:../drivers/fsl_enet.c ****     }
 901:../drivers/fsl_enet.c ****     else
 902:../drivers/fsl_enet.c ****     {
 903:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_DRT_MASK;
 904:../drivers/fsl_enet.c ****         tcr |= ENET_TCR_FDEN_MASK;
 905:../drivers/fsl_enet.c ****     }
 906:../drivers/fsl_enet.c **** 
 907:../drivers/fsl_enet.c ****     base->RCR = rcr;
 908:../drivers/fsl_enet.c ****     base->TCR = tcr;
 909:../drivers/fsl_enet.c **** }
 910:../drivers/fsl_enet.c **** 
 911:../drivers/fsl_enet.c **** void ENET_SetMacAddr(ENET_Type *base, uint8_t *macAddr)
 912:../drivers/fsl_enet.c **** {
 913:../drivers/fsl_enet.c ****     uint32_t address;
 914:../drivers/fsl_enet.c **** 
 915:../drivers/fsl_enet.c ****     /* Set physical address lower register. */
 916:../drivers/fsl_enet.c ****     address = (uint32_t)(((uint32_t)macAddr[0] << 24U) | ((uint32_t)macAddr[1] << 16U) | ((uint32_t
 917:../drivers/fsl_enet.c ****                          (uint32_t)macAddr[3]);
 918:../drivers/fsl_enet.c ****     base->PALR = address;
 919:../drivers/fsl_enet.c ****     /* Set physical address high register. */
 920:../drivers/fsl_enet.c ****     address = (uint32_t)(((uint32_t)macAddr[4] << 8U) | ((uint32_t)macAddr[5]));
 921:../drivers/fsl_enet.c ****     base->PAUR = address << ENET_PAUR_PADDR2_SHIFT;
 922:../drivers/fsl_enet.c **** }
 923:../drivers/fsl_enet.c **** 
 924:../drivers/fsl_enet.c **** void ENET_GetMacAddr(ENET_Type *base, uint8_t *macAddr)
 925:../drivers/fsl_enet.c **** {
 926:../drivers/fsl_enet.c ****     assert(macAddr);
 927:../drivers/fsl_enet.c **** 
 928:../drivers/fsl_enet.c ****     uint32_t address;
 929:../drivers/fsl_enet.c **** 
 930:../drivers/fsl_enet.c ****     /* Get from physical address lower register. */
 931:../drivers/fsl_enet.c ****     address = base->PALR;
 932:../drivers/fsl_enet.c ****     macAddr[0] = 0xFFU & (address >> 24U);
 933:../drivers/fsl_enet.c ****     macAddr[1] = 0xFFU & (address >> 16U);
 934:../drivers/fsl_enet.c ****     macAddr[2] = 0xFFU & (address >> 8U);
 935:../drivers/fsl_enet.c ****     macAddr[3] = 0xFFU & address;
 936:../drivers/fsl_enet.c **** 
 937:../drivers/fsl_enet.c ****     /* Get from physical address high register. */
 938:../drivers/fsl_enet.c ****     address = (base->PAUR & ENET_PAUR_PADDR2_MASK) >> ENET_PAUR_PADDR2_SHIFT;
 939:../drivers/fsl_enet.c ****     macAddr[4] = 0xFFU & (address >> 8U);
 940:../drivers/fsl_enet.c ****     macAddr[5] = 0xFFU & address;
 941:../drivers/fsl_enet.c **** }
 942:../drivers/fsl_enet.c **** 
 943:../drivers/fsl_enet.c **** void ENET_SetSMI(ENET_Type *base, uint32_t srcClock_Hz, bool isPreambleDisabled)
 944:../drivers/fsl_enet.c **** {
 945:../drivers/fsl_enet.c ****     assert(srcClock_Hz);
 946:../drivers/fsl_enet.c **** 
 947:../drivers/fsl_enet.c ****     uint32_t clkCycle = 0;
 948:../drivers/fsl_enet.c ****     uint32_t speed = 0;
 949:../drivers/fsl_enet.c ****     uint32_t mscr = 0;
 950:../drivers/fsl_enet.c **** 
 951:../drivers/fsl_enet.c ****     /* Calculate the MII speed which controls the frequency of the MDC. */
 952:../drivers/fsl_enet.c ****     speed = srcClock_Hz / (2 * ENET_MDC_FREQUENCY);
 953:../drivers/fsl_enet.c ****     /* Calculate the hold time on the MDIO output. */
 954:../drivers/fsl_enet.c ****     clkCycle = (10 + ENET_NANOSECOND_ONE_SECOND / srcClock_Hz - 1) / (ENET_NANOSECOND_ONE_SECOND / 
 955:../drivers/fsl_enet.c ****     /* Build the configuration for MDC/MDIO control. */
 956:../drivers/fsl_enet.c ****     mscr = ENET_MSCR_MII_SPEED(speed) | ENET_MSCR_HOLDTIME(clkCycle) | (isPreambleDisabled ? ENET_M
 957:../drivers/fsl_enet.c ****     base->MSCR = mscr;
 958:../drivers/fsl_enet.c **** }
 959:../drivers/fsl_enet.c **** 
 960:../drivers/fsl_enet.c **** void ENET_StartSMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_write_t operat
 961:../drivers/fsl_enet.c **** {
 962:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 963:../drivers/fsl_enet.c **** 
 964:../drivers/fsl_enet.c ****     /* Build MII write command. */
 965:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg)
 966:../drivers/fsl_enet.c ****            (data & 0xFFFF);
 967:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 968:../drivers/fsl_enet.c **** }
 969:../drivers/fsl_enet.c **** 
 970:../drivers/fsl_enet.c **** void ENET_StartSMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_read_t operatio
 971:../drivers/fsl_enet.c **** {
 972:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 973:../drivers/fsl_enet.c **** 
 974:../drivers/fsl_enet.c ****     /* Build MII read command. */
 975:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg)
 976:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 977:../drivers/fsl_enet.c **** }
 978:../drivers/fsl_enet.c **** 
 979:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
 980:../drivers/fsl_enet.c **** void ENET_StartExtC45SMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data)
 981:../drivers/fsl_enet.c **** {
 982:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 983:../drivers/fsl_enet.c **** 
 984:../drivers/fsl_enet.c ****     /* Parse the address from the input register. */
 985:../drivers/fsl_enet.c ****     uint16_t devAddr = (phyReg >> ENET_MMFR_TA_SHIFT) & 0x1FU;
 986:../drivers/fsl_enet.c ****     uint16_t regAddr = (uint16_t)(phyReg & 0xFFFFU);
 987:../drivers/fsl_enet.c **** 
 988:../drivers/fsl_enet.c ****     /* Address write firstly. */
 989:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MM
 990:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2) | ENET_MMFR_DATA(regAddr);
 991:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 992:../drivers/fsl_enet.c **** 
 993:../drivers/fsl_enet.c ****     /* Build MII write command. */
 994:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiWriteFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_M
 995:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2) | ENET_MMFR_DATA(data);
 996:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 997:../drivers/fsl_enet.c **** }
 998:../drivers/fsl_enet.c **** 
 999:../drivers/fsl_enet.c **** void ENET_StartExtC45SMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg)
1000:../drivers/fsl_enet.c **** {
1001:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
1002:../drivers/fsl_enet.c **** 
1003:../drivers/fsl_enet.c ****     /* Parse the address from the input register. */
1004:../drivers/fsl_enet.c ****     uint16_t devAddr = (phyReg >> ENET_MMFR_TA_SHIFT) & 0x1FU;
1005:../drivers/fsl_enet.c ****     uint16_t regAddr = (uint16_t)(phyReg & 0xFFFFU);
1006:../drivers/fsl_enet.c **** 
1007:../drivers/fsl_enet.c ****     /* Address write firstly. */
1008:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MM
1009:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2) | ENET_MMFR_DATA(regAddr);
1010:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
1011:../drivers/fsl_enet.c **** 
1012:../drivers/fsl_enet.c ****     /* Build MII read command. */
1013:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiReadFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_MM
1014:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2);
1015:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
1016:../drivers/fsl_enet.c **** }
1017:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */
1018:../drivers/fsl_enet.c **** 
1019:../drivers/fsl_enet.c **** void ENET_GetRxErrBeforeReadFrame(enet_handle_t *handle, enet_data_error_stats_t *eErrorStatic)
1020:../drivers/fsl_enet.c **** {
1021:../drivers/fsl_enet.c ****     assert(handle);
1022:../drivers/fsl_enet.c ****     assert(handle->rxBdCurrent[0]);
1023:../drivers/fsl_enet.c ****     assert(eErrorStatic);
1024:../drivers/fsl_enet.c **** 
1025:../drivers/fsl_enet.c ****     uint16_t control = 0;
1026:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[0];
1027:../drivers/fsl_enet.c **** 
1028:../drivers/fsl_enet.c ****     do
1029:../drivers/fsl_enet.c ****     {
1030:../drivers/fsl_enet.c ****         /* The last buffer descriptor of a frame. */
1031:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1032:../drivers/fsl_enet.c ****         {
1033:../drivers/fsl_enet.c ****             control = curBuffDescrip->control;
1034:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
1035:../drivers/fsl_enet.c ****             {
1036:../drivers/fsl_enet.c ****                 /* The receive truncate error. */
1037:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxTruncateErr++;
1038:../drivers/fsl_enet.c ****             }
1039:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK)
1040:../drivers/fsl_enet.c ****             {
1041:../drivers/fsl_enet.c ****                 /* The receive over run error. */
1042:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxOverRunErr++;
1043:../drivers/fsl_enet.c ****             }
1044:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK)
1045:../drivers/fsl_enet.c ****             {
1046:../drivers/fsl_enet.c ****                 /* The receive length violation error. */
1047:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxLenGreaterErr++;
1048:../drivers/fsl_enet.c ****             }
1049:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK)
1050:../drivers/fsl_enet.c ****             {
1051:../drivers/fsl_enet.c ****                 /* The receive alignment error. */
1052:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxAlignErr++;
1053:../drivers/fsl_enet.c ****             }
1054:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_CRC_MASK)
1055:../drivers/fsl_enet.c ****             {
1056:../drivers/fsl_enet.c ****                 /* The receive CRC error. */
1057:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxFcsErr++;
1058:../drivers/fsl_enet.c ****             }
1059:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1060:../drivers/fsl_enet.c ****             uint16_t controlExt = curBuffDescrip->controlExtend1;
1061:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_MACERR_MASK)
1062:../drivers/fsl_enet.c ****             {
1063:../drivers/fsl_enet.c ****                 /* The MAC error. */
1064:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxMacErr++;
1065:../drivers/fsl_enet.c ****             }
1066:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK)
1067:../drivers/fsl_enet.c ****             {
1068:../drivers/fsl_enet.c ****                 /* The PHY error. */
1069:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxPhyErr++;
1070:../drivers/fsl_enet.c ****             }
1071:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_COLLISION_MASK)
1072:../drivers/fsl_enet.c ****             {
1073:../drivers/fsl_enet.c ****                 /* The receive collision error. */
1074:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxCollisionErr++;
1075:../drivers/fsl_enet.c ****             }
1076:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1077:../drivers/fsl_enet.c **** 
1078:../drivers/fsl_enet.c ****             break;
1079:../drivers/fsl_enet.c ****         }
1080:../drivers/fsl_enet.c **** 
1081:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1082:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1083:../drivers/fsl_enet.c ****         {
1084:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[0];
1085:../drivers/fsl_enet.c ****         }
1086:../drivers/fsl_enet.c ****         else
1087:../drivers/fsl_enet.c ****         {
1088:../drivers/fsl_enet.c ****             curBuffDescrip++;
1089:../drivers/fsl_enet.c ****         }
1090:../drivers/fsl_enet.c **** 
1091:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[0]);
1092:../drivers/fsl_enet.c **** }
1093:../drivers/fsl_enet.c **** 
1094:../drivers/fsl_enet.c **** status_t ENET_GetRxFrameSize(enet_handle_t *handle, uint32_t *length)
1095:../drivers/fsl_enet.c **** {
1096:../drivers/fsl_enet.c ****     assert(handle);
1097:../drivers/fsl_enet.c ****     assert(handle->rxBdCurrent[0]);
1098:../drivers/fsl_enet.c ****     assert(length);
1099:../drivers/fsl_enet.c **** 
1100:../drivers/fsl_enet.c ****     /* Reset the length to zero. */
1101:../drivers/fsl_enet.c ****     *length = 0;
1102:../drivers/fsl_enet.c **** 
1103:../drivers/fsl_enet.c ****     uint16_t validLastMask = ENET_BUFFDESCRIPTOR_RX_LAST_MASK | ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
1104:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[0];
1105:../drivers/fsl_enet.c **** 
1106:../drivers/fsl_enet.c ****     /* Check the current buffer descriptor's empty flag.  if empty means there is no frame received
1107:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)
1108:../drivers/fsl_enet.c ****     {
1109:../drivers/fsl_enet.c ****         return kStatus_ENET_RxFrameEmpty;
1110:../drivers/fsl_enet.c ****     }
1111:../drivers/fsl_enet.c **** 
1112:../drivers/fsl_enet.c ****     do
1113:../drivers/fsl_enet.c ****     {
1114:../drivers/fsl_enet.c ****         /* Add check for abnormal case. */
1115:../drivers/fsl_enet.c ****         if ((!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)) && (!curBuffDescrip->l
1116:../drivers/fsl_enet.c ****         {
1117:../drivers/fsl_enet.c ****             return kStatus_ENET_RxFrameError;
1118:../drivers/fsl_enet.c ****         }
1119:../drivers/fsl_enet.c **** 
1120:../drivers/fsl_enet.c ****         /* Find the last buffer descriptor. */
1121:../drivers/fsl_enet.c ****         if ((curBuffDescrip->control & validLastMask) == ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1122:../drivers/fsl_enet.c ****         {
1123:../drivers/fsl_enet.c ****             /* The last buffer descriptor in the frame check the status of the received frame. */
1124:../drivers/fsl_enet.c ****             if ((curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_ERR_MASK)
1125:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1126:../drivers/fsl_enet.c ****                 || (curBuffDescrip->controlExtend1 & ENET_BUFFDESCRIPTOR_RX_EXT_ERR_MASK)
1127:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1128:../drivers/fsl_enet.c ****                     )
1129:../drivers/fsl_enet.c ****             {
1130:../drivers/fsl_enet.c ****                 return kStatus_ENET_RxFrameError;
1131:../drivers/fsl_enet.c ****             }
1132:../drivers/fsl_enet.c ****             /* FCS is removed by MAC. */
1133:../drivers/fsl_enet.c ****             *length = curBuffDescrip->length;
1134:../drivers/fsl_enet.c ****             return kStatus_Success;
1135:../drivers/fsl_enet.c ****         }
1136:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1137:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1138:../drivers/fsl_enet.c ****         {
1139:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[0];
1140:../drivers/fsl_enet.c ****         }
1141:../drivers/fsl_enet.c ****         else
1142:../drivers/fsl_enet.c ****         {
1143:../drivers/fsl_enet.c ****             curBuffDescrip++;
1144:../drivers/fsl_enet.c ****         }
1145:../drivers/fsl_enet.c **** 
1146:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[0]);
1147:../drivers/fsl_enet.c **** 
1148:../drivers/fsl_enet.c ****     /* The frame is on processing - set to empty status to make application to receive it next time
1149:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameEmpty;
1150:../drivers/fsl_enet.c **** }
1151:../drivers/fsl_enet.c **** 
1152:../drivers/fsl_enet.c **** status_t ENET_ReadFrame(ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length)
1153:../drivers/fsl_enet.c **** {
1154:../drivers/fsl_enet.c ****     assert(handle);
1155:../drivers/fsl_enet.c ****     assert(handle->rxBdCurrent[0]);
1156:../drivers/fsl_enet.c **** 
1157:../drivers/fsl_enet.c ****     uint32_t len = 0;
1158:../drivers/fsl_enet.c ****     uint32_t offset = 0;
1159:../drivers/fsl_enet.c ****     uint16_t control;
1160:../drivers/fsl_enet.c ****     bool isLastBuff = false;
1161:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[0];
1162:../drivers/fsl_enet.c ****     status_t result = kStatus_Success;
1163:../drivers/fsl_enet.c ****     uint32_t address;
1164:../drivers/fsl_enet.c **** 
1165:../drivers/fsl_enet.c ****     /* For data-NULL input, only update the buffer descriptor. */
1166:../drivers/fsl_enet.c ****     if (!data)
1167:../drivers/fsl_enet.c ****     {
1168:../drivers/fsl_enet.c ****         do
1169:../drivers/fsl_enet.c ****         {
1170:../drivers/fsl_enet.c ****             /* Update the control flag. */
1171:../drivers/fsl_enet.c ****             control = handle->rxBdCurrent[0]->control;
1172:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
1173:../drivers/fsl_enet.c ****             ENET_UpdateReadBuffers(base, handle, 0);
1174:../drivers/fsl_enet.c **** 
1175:../drivers/fsl_enet.c ****             /* Find the last buffer descriptor for the frame. */
1176:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1177:../drivers/fsl_enet.c ****             {
1178:../drivers/fsl_enet.c ****                 break;
1179:../drivers/fsl_enet.c ****             }
1180:../drivers/fsl_enet.c **** 
1181:../drivers/fsl_enet.c ****         } while (handle->rxBdCurrent[0] != curBuffDescrip);
1182:../drivers/fsl_enet.c **** 
1183:../drivers/fsl_enet.c ****         return result;
1184:../drivers/fsl_enet.c ****     }
1185:../drivers/fsl_enet.c ****     else
1186:../drivers/fsl_enet.c ****     {
1187:../drivers/fsl_enet.c ****         /* A frame on one buffer or several receive buffers are both considered. */
1188:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1189:../drivers/fsl_enet.c ****         /* Add the cache invalidate maintain. */
1190:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1191:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1192:../drivers/fsl_enet.c **** #else
1193:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1194:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1195:../drivers/fsl_enet.c ****         DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[0]);
1196:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1197:../drivers/fsl_enet.c **** /* A frame on one buffer or several receive buffers are both considered. */
1198:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1199:../drivers/fsl_enet.c ****         enet_ptp_time_data_t ptpTimestamp;
1200:../drivers/fsl_enet.c ****         bool isPtpEventMessage = false;
1201:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1202:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1203:../drivers/fsl_enet.c **** #else
1204:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1205:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1206:../drivers/fsl_enet.c ****         /* Parse the PTP message according to the header message. */
1207:../drivers/fsl_enet.c ****         isPtpEventMessage = ENET_Ptp1588ParseFrame((uint8_t *)address, &ptpTimestamp, false);
1208:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1209:../drivers/fsl_enet.c **** 
1210:../drivers/fsl_enet.c ****         while (!isLastBuff)
1211:../drivers/fsl_enet.c ****         {
1212:../drivers/fsl_enet.c ****             /* The last buffer descriptor of a frame. */
1213:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1214:../drivers/fsl_enet.c ****             {
1215:../drivers/fsl_enet.c ****                 /* This is a valid frame. */
1216:../drivers/fsl_enet.c ****                 isLastBuff = true;
1217:../drivers/fsl_enet.c ****                 if (length == curBuffDescrip->length)
1218:../drivers/fsl_enet.c ****                 {
1219:../drivers/fsl_enet.c ****                     /* Copy the frame to user's buffer without FCS. */
1220:../drivers/fsl_enet.c ****                     len = curBuffDescrip->length - offset;
1221:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1222:../drivers/fsl_enet.c ****                     address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMO
1223:../drivers/fsl_enet.c **** #else
1224:../drivers/fsl_enet.c ****                     address = (uint32_t)curBuffDescrip->buffer;
1225:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1226:../drivers/fsl_enet.c ****                     memcpy(data + offset, (void *)address, len);
1227:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1228:../drivers/fsl_enet.c ****                     /* Store the PTP 1588 timestamp for received PTP event frame. */
1229:../drivers/fsl_enet.c ****                     if (isPtpEventMessage)
1230:../drivers/fsl_enet.c ****                     {
1231:../drivers/fsl_enet.c ****                         /* Set the timestamp to the timestamp ring. */
1232:../drivers/fsl_enet.c ****                         ptpTimestamp.timeStamp.nanosecond = curBuffDescrip->timestamp;
1233:../drivers/fsl_enet.c ****                         result = ENET_StoreRxFrameTime(base, handle, &ptpTimestamp);
1234:../drivers/fsl_enet.c ****                     }
1235:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1236:../drivers/fsl_enet.c **** 
1237:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1238:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, 0);
1239:../drivers/fsl_enet.c ****                     return result;
1240:../drivers/fsl_enet.c ****                 }
1241:../drivers/fsl_enet.c ****                 else
1242:../drivers/fsl_enet.c ****                 {
1243:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1244:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, 0);
1245:../drivers/fsl_enet.c ****                 }
1246:../drivers/fsl_enet.c ****             }
1247:../drivers/fsl_enet.c ****             else
1248:../drivers/fsl_enet.c ****             {
1249:../drivers/fsl_enet.c ****                 /* Store a frame on several buffer descriptors. */
1250:../drivers/fsl_enet.c ****                 isLastBuff = false;
1251:../drivers/fsl_enet.c ****                 /* Length check. */
1252:../drivers/fsl_enet.c ****                 if (offset >= length)
1253:../drivers/fsl_enet.c ****                 {
1254:../drivers/fsl_enet.c ****                     break;
1255:../drivers/fsl_enet.c ****                 }
1256:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1257:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1258:../drivers/fsl_enet.c **** #else
1259:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1260:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1261:../drivers/fsl_enet.c ****                 memcpy(data + offset, (void *)address, handle->rxBuffSizeAlign[0]);
1262:../drivers/fsl_enet.c ****                 offset += handle->rxBuffSizeAlign[0];
1263:../drivers/fsl_enet.c **** 
1264:../drivers/fsl_enet.c ****                 /* Updates the receive buffer descriptors. */
1265:../drivers/fsl_enet.c ****                 ENET_UpdateReadBuffers(base, handle, 0);
1266:../drivers/fsl_enet.c ****             }
1267:../drivers/fsl_enet.c **** 
1268:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor. */
1269:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdCurrent[0];
1270:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1271:../drivers/fsl_enet.c ****             /* Add the cache invalidate maintain. */
1272:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1273:../drivers/fsl_enet.c ****             address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2L
1274:../drivers/fsl_enet.c **** #else
1275:../drivers/fsl_enet.c ****             address = (uint32_t)curBuffDescrip->buffer;
1276:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */            
1277:../drivers/fsl_enet.c ****             DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[0]);
1278:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1279:../drivers/fsl_enet.c ****         }
1280:../drivers/fsl_enet.c ****     }
1281:../drivers/fsl_enet.c **** 
1282:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameFail;
1283:../drivers/fsl_enet.c **** }
1284:../drivers/fsl_enet.c **** 
1285:../drivers/fsl_enet.c **** static void ENET_UpdateReadBuffers(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
1286:../drivers/fsl_enet.c **** {
1287:../drivers/fsl_enet.c ****     assert(handle);
1288:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1289:../drivers/fsl_enet.c **** 
1290:../drivers/fsl_enet.c ****     /* Clears status. */
1291:../drivers/fsl_enet.c ****     handle->rxBdCurrent[ringId]->control &= ENET_BUFFDESCRIPTOR_RX_WRAP_MASK;
1292:../drivers/fsl_enet.c ****     /* Sets the receive buffer descriptor with the empty flag. */
1293:../drivers/fsl_enet.c ****     handle->rxBdCurrent[ringId]->control |= ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
1294:../drivers/fsl_enet.c **** 
1295:../drivers/fsl_enet.c ****     /* Increase current buffer descriptor to the next one. */
1296:../drivers/fsl_enet.c ****     if (handle->rxBdCurrent[ringId]->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1297:../drivers/fsl_enet.c ****     {
1298:../drivers/fsl_enet.c ****         handle->rxBdCurrent[ringId] = handle->rxBdBase[ringId];
1299:../drivers/fsl_enet.c ****     }
1300:../drivers/fsl_enet.c ****     else
1301:../drivers/fsl_enet.c ****     {
1302:../drivers/fsl_enet.c ****         handle->rxBdCurrent[ringId]++;
1303:../drivers/fsl_enet.c ****     }
1304:../drivers/fsl_enet.c **** 
1305:../drivers/fsl_enet.c ****     /* Actives the receive buffer descriptor. */
1306:../drivers/fsl_enet.c ****     switch (ringId)
1307:../drivers/fsl_enet.c ****     {
1308:../drivers/fsl_enet.c ****         case kENET_Ring0:
1309:../drivers/fsl_enet.c ****             base->RDAR = ENET_RDAR_RDAR_MASK;
1310:../drivers/fsl_enet.c ****             break;
1311:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
1312:../drivers/fsl_enet.c ****         case kENET_Ring1:
1313:../drivers/fsl_enet.c ****             base->RDAR1 = ENET_RDAR1_RDAR_MASK;
1314:../drivers/fsl_enet.c ****             break;
1315:../drivers/fsl_enet.c ****         case kENET_Ring2:
1316:../drivers/fsl_enet.c ****             base->RDAR2 = ENET_RDAR2_RDAR_MASK;
1317:../drivers/fsl_enet.c ****             break;
1318:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
1319:../drivers/fsl_enet.c ****         default:
1320:../drivers/fsl_enet.c ****             base->RDAR = ENET_RDAR_RDAR_MASK;
1321:../drivers/fsl_enet.c ****             break;
1322:../drivers/fsl_enet.c ****     }
1323:../drivers/fsl_enet.c **** }
1324:../drivers/fsl_enet.c **** 
1325:../drivers/fsl_enet.c **** status_t ENET_SendFrame(ENET_Type *base, enet_handle_t *handle, const uint8_t *data, uint32_t lengt
1326:../drivers/fsl_enet.c **** {
1327:../drivers/fsl_enet.c ****     assert(handle);
1328:../drivers/fsl_enet.c ****     assert(data);
1329:../drivers/fsl_enet.c **** 
1330:../drivers/fsl_enet.c ****     volatile enet_tx_bd_struct_t *curBuffDescrip;
1331:../drivers/fsl_enet.c ****     uint32_t len = 0;
1332:../drivers/fsl_enet.c ****     uint32_t sizeleft = 0;
1333:../drivers/fsl_enet.c ****     uint32_t address;
1334:../drivers/fsl_enet.c **** 
1335:../drivers/fsl_enet.c ****     /* Check the frame length. */
1336:../drivers/fsl_enet.c ****     if (length > ENET_FRAME_MAX_FRAMELEN)
1337:../drivers/fsl_enet.c ****     {
1338:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameOverLen;
1339:../drivers/fsl_enet.c ****     }
1340:../drivers/fsl_enet.c **** 
1341:../drivers/fsl_enet.c ****     /* Check if the transmit buffer is ready. */
1342:../drivers/fsl_enet.c ****     curBuffDescrip = handle->txBdCurrent[0];
1343:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
1344:../drivers/fsl_enet.c ****     {
1345:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1346:../drivers/fsl_enet.c ****     }
1347:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1348:../drivers/fsl_enet.c ****     bool isPtpEventMessage = false;
1349:../drivers/fsl_enet.c ****     /* Check PTP message with the PTP header. */
1350:../drivers/fsl_enet.c ****     isPtpEventMessage = ENET_Ptp1588ParseFrame(data, NULL, true);
1351:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1352:../drivers/fsl_enet.c ****     /* One transmit buffer is enough for one frame. */
1353:../drivers/fsl_enet.c ****     if (handle->txBuffSizeAlign[0] >= length)
1354:../drivers/fsl_enet.c ****     {
1355:../drivers/fsl_enet.c ****         /* Copy data to the buffer for uDMA transfer. */
1356:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1357:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1358:../drivers/fsl_enet.c **** #else
1359:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1360:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1361:../drivers/fsl_enet.c ****         memcpy((void *)address, data, length);
1362:../drivers/fsl_enet.c ****         /* Set data length. */
1363:../drivers/fsl_enet.c ****         curBuffDescrip->length = length;
1364:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1365:../drivers/fsl_enet.c ****         /* For enable the timestamp. */
1366:../drivers/fsl_enet.c ****         if (isPtpEventMessage)
1367:../drivers/fsl_enet.c ****         {
1368:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1369:../drivers/fsl_enet.c ****         }
1370:../drivers/fsl_enet.c ****         else
1371:../drivers/fsl_enet.c ****         {
1372:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1373:../drivers/fsl_enet.c ****         }
1374:../drivers/fsl_enet.c **** 
1375:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1376:../drivers/fsl_enet.c ****         curBuffDescrip->control |= (ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_TX_LAST
1377:../drivers/fsl_enet.c **** 
1378:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor address. */
1379:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1380:../drivers/fsl_enet.c ****         {
1381:../drivers/fsl_enet.c ****             handle->txBdCurrent[0] = handle->txBdBase[0];
1382:../drivers/fsl_enet.c ****         }
1383:../drivers/fsl_enet.c ****         else
1384:../drivers/fsl_enet.c ****         {
1385:../drivers/fsl_enet.c ****             handle->txBdCurrent[0]++;
1386:../drivers/fsl_enet.c ****         }
1387:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1388:../drivers/fsl_enet.c ****         /* Add the cache clean maintain. */
1389:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1390:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1391:../drivers/fsl_enet.c **** #else
1392:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1393:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1394:../drivers/fsl_enet.c ****         DCACHE_CleanByRange(address, length);
1395:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1396:../drivers/fsl_enet.c ****         /* Active the transmit buffer descriptor. */
1397:../drivers/fsl_enet.c ****         ENET_ActiveSend(base, 0);
1398:../drivers/fsl_enet.c **** 
1399:../drivers/fsl_enet.c ****         return kStatus_Success;
1400:../drivers/fsl_enet.c ****     }
1401:../drivers/fsl_enet.c ****     else
1402:../drivers/fsl_enet.c ****     {
1403:../drivers/fsl_enet.c ****         /* One frame requires more than one transmit buffers. */
1404:../drivers/fsl_enet.c ****         do
1405:../drivers/fsl_enet.c ****         {
1406:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1407:../drivers/fsl_enet.c ****             /* For enable the timestamp. */
1408:../drivers/fsl_enet.c ****             if (isPtpEventMessage)
1409:../drivers/fsl_enet.c ****             {
1410:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1411:../drivers/fsl_enet.c ****             }
1412:../drivers/fsl_enet.c ****             else
1413:../drivers/fsl_enet.c ****             {
1414:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1415:../drivers/fsl_enet.c ****             }
1416:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1417:../drivers/fsl_enet.c **** 
1418:../drivers/fsl_enet.c ****             /* Increase the buffer descriptor address. */
1419:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1420:../drivers/fsl_enet.c ****             {
1421:../drivers/fsl_enet.c ****                 handle->txBdCurrent[0] = handle->txBdBase[0];
1422:../drivers/fsl_enet.c ****             }
1423:../drivers/fsl_enet.c ****             else
1424:../drivers/fsl_enet.c ****             {
1425:../drivers/fsl_enet.c ****                 handle->txBdCurrent[0]++;
1426:../drivers/fsl_enet.c ****             }
1427:../drivers/fsl_enet.c ****             /* update the size left to be transmit. */
1428:../drivers/fsl_enet.c ****             sizeleft = length - len;
1429:../drivers/fsl_enet.c ****             if (sizeleft > handle->txBuffSizeAlign[0])
1430:../drivers/fsl_enet.c ****             {
1431:../drivers/fsl_enet.c ****                 /* Data copy. */
1432:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1433:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1434:../drivers/fsl_enet.c **** #else
1435:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1436:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1437:../drivers/fsl_enet.c ****                 memcpy((void *)address, data + len, handle->txBuffSizeAlign[0]);
1438:../drivers/fsl_enet.c ****                 /* Data length update. */
1439:../drivers/fsl_enet.c ****                 curBuffDescrip->length = handle->txBuffSizeAlign[0];
1440:../drivers/fsl_enet.c ****                 len += handle->txBuffSizeAlign[0];
1441:../drivers/fsl_enet.c ****                 /* Sets the control flag. */
1442:../drivers/fsl_enet.c ****                 curBuffDescrip->control &= ~ENET_BUFFDESCRIPTOR_TX_LAST_MASK;
1443:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
1444:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
1445:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, 0);
1446:../drivers/fsl_enet.c ****             }
1447:../drivers/fsl_enet.c ****             else
1448:../drivers/fsl_enet.c ****             {
1449:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1450:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1451:../drivers/fsl_enet.c **** #else
1452:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1453:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1454:../drivers/fsl_enet.c ****                 memcpy((void *)address, data + len, sizeleft);
1455:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
1456:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
1457:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_
1458:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1459:../drivers/fsl_enet.c ****                 /* Add the cache clean maintain. */
1460:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1461:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1462:../drivers/fsl_enet.c **** #else
1463:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1464:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1465:../drivers/fsl_enet.c ****                 DCACHE_CleanByRange(address, handle->txBuffSizeAlign[0]);
1466:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */                 
1467:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor. */
1468:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, 0);
1469:../drivers/fsl_enet.c **** 
1470:../drivers/fsl_enet.c ****                 return kStatus_Success;
1471:../drivers/fsl_enet.c ****             }
1472:../drivers/fsl_enet.c **** 
1473:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor address. */
1474:../drivers/fsl_enet.c ****             curBuffDescrip = handle->txBdCurrent[0];
1475:../drivers/fsl_enet.c **** 
1476:../drivers/fsl_enet.c ****         } while (!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK));
1477:../drivers/fsl_enet.c **** 
1478:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1479:../drivers/fsl_enet.c ****     }
1480:../drivers/fsl_enet.c **** }
1481:../drivers/fsl_enet.c **** 
1482:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
1483:../drivers/fsl_enet.c **** void ENET_GetRxErrBeforeReadFrameMultiRing(enet_handle_t *handle,
1484:../drivers/fsl_enet.c ****                                            enet_data_error_stats_t *eErrorStatic,
1485:../drivers/fsl_enet.c ****                                            uint32_t ringId)
1486:../drivers/fsl_enet.c **** {
1487:../drivers/fsl_enet.c ****     assert(handle);
1488:../drivers/fsl_enet.c ****     assert(eErrorStatic);
1489:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1490:../drivers/fsl_enet.c **** 
1491:../drivers/fsl_enet.c ****     uint16_t control = 0;
1492:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[ringId];
1493:../drivers/fsl_enet.c **** 
1494:../drivers/fsl_enet.c ****     do
1495:../drivers/fsl_enet.c ****     {
1496:../drivers/fsl_enet.c ****         /* The last buffer descriptor of a frame. */
1497:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1498:../drivers/fsl_enet.c ****         {
1499:../drivers/fsl_enet.c ****             control = curBuffDescrip->control;
1500:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
1501:../drivers/fsl_enet.c ****             {
1502:../drivers/fsl_enet.c ****                 /* The receive truncate error. */
1503:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxTruncateErr++;
1504:../drivers/fsl_enet.c ****             }
1505:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK)
1506:../drivers/fsl_enet.c ****             {
1507:../drivers/fsl_enet.c ****                 /* The receive over run error. */
1508:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxOverRunErr++;
1509:../drivers/fsl_enet.c ****             }
1510:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK)
1511:../drivers/fsl_enet.c ****             {
1512:../drivers/fsl_enet.c ****                 /* The receive length violation error. */
1513:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxLenGreaterErr++;
1514:../drivers/fsl_enet.c ****             }
1515:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK)
1516:../drivers/fsl_enet.c ****             {
1517:../drivers/fsl_enet.c ****                 /* The receive alignment error. */
1518:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxAlignErr++;
1519:../drivers/fsl_enet.c ****             }
1520:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_CRC_MASK)
1521:../drivers/fsl_enet.c ****             {
1522:../drivers/fsl_enet.c ****                 /* The receive CRC error. */
1523:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxFcsErr++;
1524:../drivers/fsl_enet.c ****             }
1525:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1526:../drivers/fsl_enet.c ****             uint16_t controlExt = curBuffDescrip->controlExtend1;
1527:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_MACERR_MASK)
1528:../drivers/fsl_enet.c ****             {
1529:../drivers/fsl_enet.c ****                 /* The MAC error. */
1530:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxMacErr++;
1531:../drivers/fsl_enet.c ****             }
1532:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK)
1533:../drivers/fsl_enet.c ****             {
1534:../drivers/fsl_enet.c ****                 /* The PHY error. */
1535:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxPhyErr++;
1536:../drivers/fsl_enet.c ****             }
1537:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_COLLISION_MASK)
1538:../drivers/fsl_enet.c ****             {
1539:../drivers/fsl_enet.c ****                 /* The receive collision error. */
1540:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxCollisionErr++;
1541:../drivers/fsl_enet.c ****             }
1542:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1543:../drivers/fsl_enet.c **** 
1544:../drivers/fsl_enet.c ****             break;
1545:../drivers/fsl_enet.c ****         }
1546:../drivers/fsl_enet.c **** 
1547:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1548:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1549:../drivers/fsl_enet.c ****         {
1550:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[ringId];
1551:../drivers/fsl_enet.c ****         }
1552:../drivers/fsl_enet.c ****         else
1553:../drivers/fsl_enet.c ****         {
1554:../drivers/fsl_enet.c ****             curBuffDescrip++;
1555:../drivers/fsl_enet.c ****         }
1556:../drivers/fsl_enet.c **** 
1557:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[ringId]);
1558:../drivers/fsl_enet.c **** }
1559:../drivers/fsl_enet.c **** 
1560:../drivers/fsl_enet.c **** status_t ENET_GetRxFrameSizeMultiRing(enet_handle_t *handle, uint32_t *length, uint32_t ringId)
1561:../drivers/fsl_enet.c **** {
1562:../drivers/fsl_enet.c ****     assert(handle);
1563:../drivers/fsl_enet.c ****     assert(length);
1564:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1565:../drivers/fsl_enet.c **** 
1566:../drivers/fsl_enet.c ****     /* Reset the length to zero. */
1567:../drivers/fsl_enet.c ****     *length = 0;
1568:../drivers/fsl_enet.c ****     uint16_t validLastMask = ENET_BUFFDESCRIPTOR_RX_LAST_MASK | ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
1569:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip;
1570:../drivers/fsl_enet.c **** 
1571:../drivers/fsl_enet.c ****     curBuffDescrip = handle->rxBdCurrent[ringId];
1572:../drivers/fsl_enet.c ****     /* Check the current buffer descriptor's empty flag.  if empty means there is no frame received
1573:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)
1574:../drivers/fsl_enet.c ****     {
1575:../drivers/fsl_enet.c ****         return kStatus_ENET_RxFrameEmpty;
1576:../drivers/fsl_enet.c ****     }
1577:../drivers/fsl_enet.c **** 
1578:../drivers/fsl_enet.c ****     do
1579:../drivers/fsl_enet.c ****     {
1580:../drivers/fsl_enet.c ****         /* Add check for abnormal case. */
1581:../drivers/fsl_enet.c ****         if ((!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)) && (!curBuffDescrip->l
1582:../drivers/fsl_enet.c ****         {
1583:../drivers/fsl_enet.c ****             return kStatus_ENET_RxFrameError;
1584:../drivers/fsl_enet.c ****         }        
1585:../drivers/fsl_enet.c ****         /* Find the last buffer descriptor. */
1586:../drivers/fsl_enet.c ****         if ((curBuffDescrip->control & validLastMask) == ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1587:../drivers/fsl_enet.c ****         {
1588:../drivers/fsl_enet.c ****             /* The last buffer descriptor in the frame check the status of the received frame. */
1589:../drivers/fsl_enet.c ****             if ((curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_ERR_MASK)
1590:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1591:../drivers/fsl_enet.c ****                 || (curBuffDescrip->controlExtend1 & ENET_BUFFDESCRIPTOR_RX_EXT_ERR_MASK)
1592:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1593:../drivers/fsl_enet.c ****                     )
1594:../drivers/fsl_enet.c ****             {
1595:../drivers/fsl_enet.c ****                 return kStatus_ENET_RxFrameError;
1596:../drivers/fsl_enet.c ****             }
1597:../drivers/fsl_enet.c ****             /* FCS is removed by MAC. */
1598:../drivers/fsl_enet.c ****             *length = curBuffDescrip->length;
1599:../drivers/fsl_enet.c ****             return kStatus_Success;
1600:../drivers/fsl_enet.c ****         }
1601:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1602:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1603:../drivers/fsl_enet.c ****         {
1604:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[ringId];
1605:../drivers/fsl_enet.c ****         }
1606:../drivers/fsl_enet.c ****         else
1607:../drivers/fsl_enet.c ****         {
1608:../drivers/fsl_enet.c ****             curBuffDescrip++;
1609:../drivers/fsl_enet.c ****         }
1610:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[ringId]);
1611:../drivers/fsl_enet.c **** 
1612:../drivers/fsl_enet.c ****     /* The frame is on processing - set to empty status to make application to receive it next time
1613:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameEmpty;
1614:../drivers/fsl_enet.c **** }
1615:../drivers/fsl_enet.c **** 
1616:../drivers/fsl_enet.c **** status_t ENET_ReadFrameMultiRing(
1617:../drivers/fsl_enet.c ****     ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length, uint32_t ringId)
1618:../drivers/fsl_enet.c **** {
1619:../drivers/fsl_enet.c ****     assert(handle);
1620:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1621:../drivers/fsl_enet.c **** 
1622:../drivers/fsl_enet.c ****     uint32_t len = 0;
1623:../drivers/fsl_enet.c ****     uint32_t offset = 0;
1624:../drivers/fsl_enet.c ****     uint16_t control;
1625:../drivers/fsl_enet.c ****     bool isLastBuff = false;
1626:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[ringId];
1627:../drivers/fsl_enet.c ****     status_t result = kStatus_Success;
1628:../drivers/fsl_enet.c ****     uint32_t address;
1629:../drivers/fsl_enet.c **** 
1630:../drivers/fsl_enet.c ****     /* For data-NULL input, only update the buffer descriptor. */
1631:../drivers/fsl_enet.c ****     if (!data)
1632:../drivers/fsl_enet.c ****     {
1633:../drivers/fsl_enet.c ****         do
1634:../drivers/fsl_enet.c ****         {
1635:../drivers/fsl_enet.c ****             /* Update the control flag. */
1636:../drivers/fsl_enet.c ****             control = handle->rxBdCurrent[ringId]->control;
1637:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
1638:../drivers/fsl_enet.c ****             ENET_UpdateReadBuffers(base, handle, ringId);
1639:../drivers/fsl_enet.c **** 
1640:../drivers/fsl_enet.c ****             /* Find the last buffer descriptor for the frame. */
1641:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1642:../drivers/fsl_enet.c ****             {
1643:../drivers/fsl_enet.c ****                 break;
1644:../drivers/fsl_enet.c ****             }
1645:../drivers/fsl_enet.c **** 
1646:../drivers/fsl_enet.c ****         } while (handle->rxBdCurrent[ringId] != curBuffDescrip);
1647:../drivers/fsl_enet.c **** 
1648:../drivers/fsl_enet.c ****         return result;
1649:../drivers/fsl_enet.c ****     }
1650:../drivers/fsl_enet.c ****     else
1651:../drivers/fsl_enet.c ****     {
1652:../drivers/fsl_enet.c ****         /* A frame on one buffer or several receive buffers are both considered. */
1653:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1654:../drivers/fsl_enet.c ****         /* Add the cache invalidate maintain. */
1655:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1656:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1657:../drivers/fsl_enet.c **** #else
1658:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1659:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1660:../drivers/fsl_enet.c ****         DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[ringId]);
1661:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1662:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1663:../drivers/fsl_enet.c ****         enet_ptp_time_data_t ptpTimestamp;
1664:../drivers/fsl_enet.c ****         bool isPtpEventMessage = false;
1665:../drivers/fsl_enet.c **** 
1666:../drivers/fsl_enet.c ****         /* Parse the PTP message according to the header message. */
1667:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1668:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1669:../drivers/fsl_enet.c **** #else
1670:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1671:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1672:../drivers/fsl_enet.c ****         isPtpEventMessage = ENET_Ptp1588ParseFrame((uint8_t *)address, &ptpTimestamp, false);
1673:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1674:../drivers/fsl_enet.c **** 
1675:../drivers/fsl_enet.c ****         while (!isLastBuff)
1676:../drivers/fsl_enet.c ****         {
1677:../drivers/fsl_enet.c ****             /* The last buffer descriptor of a frame. */
1678:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1679:../drivers/fsl_enet.c ****             {
1680:../drivers/fsl_enet.c ****                 /* This is a valid frame. */
1681:../drivers/fsl_enet.c ****                 isLastBuff = true;
1682:../drivers/fsl_enet.c ****                 if (length == curBuffDescrip->length)
1683:../drivers/fsl_enet.c ****                 {
1684:../drivers/fsl_enet.c ****                     /* Copy the frame to user's buffer without FCS. */
1685:../drivers/fsl_enet.c ****                     len = curBuffDescrip->length - offset;
1686:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1687:../drivers/fsl_enet.c ****                     address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMO
1688:../drivers/fsl_enet.c **** #else
1689:../drivers/fsl_enet.c ****                     address = (uint32_t)curBuffDescrip->buffer;
1690:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1691:../drivers/fsl_enet.c ****                     memcpy(data + offset, (void *)address, len);
1692:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1693:../drivers/fsl_enet.c ****                     /* Store the PTP 1588 timestamp for received PTP event frame. */
1694:../drivers/fsl_enet.c ****                     if (isPtpEventMessage)
1695:../drivers/fsl_enet.c ****                     {
1696:../drivers/fsl_enet.c ****                         /* Set the timestamp to the timestamp ring. */
1697:../drivers/fsl_enet.c ****                         ptpTimestamp.timeStamp.nanosecond = curBuffDescrip->timestamp;
1698:../drivers/fsl_enet.c ****                         result = ENET_StoreRxFrameTime(base, handle, &ptpTimestamp);
1699:../drivers/fsl_enet.c ****                     }
1700:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1701:../drivers/fsl_enet.c **** 
1702:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1703:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, ringId);
1704:../drivers/fsl_enet.c ****                     return result;
1705:../drivers/fsl_enet.c ****                 }
1706:../drivers/fsl_enet.c ****                 else
1707:../drivers/fsl_enet.c ****                 {
1708:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1709:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, ringId);
1710:../drivers/fsl_enet.c ****                 }
1711:../drivers/fsl_enet.c ****             }
1712:../drivers/fsl_enet.c ****             else
1713:../drivers/fsl_enet.c ****             {
1714:../drivers/fsl_enet.c ****                 /* Store a frame on several buffer descriptors. */
1715:../drivers/fsl_enet.c ****                 isLastBuff = false;
1716:../drivers/fsl_enet.c ****                 /* Length check. */
1717:../drivers/fsl_enet.c ****                 if (offset >= length)
1718:../drivers/fsl_enet.c ****                 {
1719:../drivers/fsl_enet.c ****                     break;
1720:../drivers/fsl_enet.c ****                 }
1721:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1722:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1723:../drivers/fsl_enet.c **** #else
1724:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1725:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1726:../drivers/fsl_enet.c ****                 memcpy(data + offset, (void *)address, handle->rxBuffSizeAlign[ringId]);
1727:../drivers/fsl_enet.c ****                 offset += handle->rxBuffSizeAlign[ringId];
1728:../drivers/fsl_enet.c **** 
1729:../drivers/fsl_enet.c **** 
1730:../drivers/fsl_enet.c ****                 /* Updates the receive buffer descriptors. */
1731:../drivers/fsl_enet.c ****                 ENET_UpdateReadBuffers(base, handle, ringId);
1732:../drivers/fsl_enet.c ****             }
1733:../drivers/fsl_enet.c **** 
1734:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor. */
1735:../drivers/fsl_enet.c **** 
1736:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdCurrent[ringId];
1737:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1738:../drivers/fsl_enet.c ****             /* Add the cache invalidate maintain. */
1739:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1740:../drivers/fsl_enet.c ****             address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2L
1741:../drivers/fsl_enet.c **** #else
1742:../drivers/fsl_enet.c ****             address = (uint32_t)curBuffDescrip->buffer;
1743:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1744:../drivers/fsl_enet.c ****             DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[ringId]);
1745:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1746:../drivers/fsl_enet.c ****         }
1747:../drivers/fsl_enet.c ****     }
1748:../drivers/fsl_enet.c **** 
1749:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameFail;
1750:../drivers/fsl_enet.c **** }
1751:../drivers/fsl_enet.c **** 
1752:../drivers/fsl_enet.c **** 
1753:../drivers/fsl_enet.c **** status_t ENET_SendFrameMultiRing(
1754:../drivers/fsl_enet.c ****     ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length, uint32_t ringId)
1755:../drivers/fsl_enet.c **** {
1756:../drivers/fsl_enet.c ****     assert(handle);
1757:../drivers/fsl_enet.c ****     assert(data);
1758:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1759:../drivers/fsl_enet.c **** 
1760:../drivers/fsl_enet.c ****     volatile enet_tx_bd_struct_t *curBuffDescrip;
1761:../drivers/fsl_enet.c ****     uint32_t len = 0;
1762:../drivers/fsl_enet.c ****     uint32_t sizeleft = 0;
1763:../drivers/fsl_enet.c ****     uint32_t address;
1764:../drivers/fsl_enet.c **** 
1765:../drivers/fsl_enet.c ****     /* Check the frame length. */
1766:../drivers/fsl_enet.c ****     if (length > ENET_FRAME_MAX_FRAMELEN)
1767:../drivers/fsl_enet.c ****     {
1768:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameOverLen;
1769:../drivers/fsl_enet.c ****     }
1770:../drivers/fsl_enet.c **** 
1771:../drivers/fsl_enet.c ****     /* Check if the transmit buffer is ready. */
1772:../drivers/fsl_enet.c ****     curBuffDescrip = handle->txBdCurrent[ringId];
1773:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
1774:../drivers/fsl_enet.c ****     {
1775:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1776:../drivers/fsl_enet.c ****     }
1777:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1778:../drivers/fsl_enet.c ****     bool isPtpEventMessage = false;
1779:../drivers/fsl_enet.c ****     /* Check PTP message with the PTP header. */
1780:../drivers/fsl_enet.c ****     isPtpEventMessage = ENET_Ptp1588ParseFrame(data, NULL, true);
1781:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1782:../drivers/fsl_enet.c ****     /* One transmit buffer is enough for one frame. */
1783:../drivers/fsl_enet.c ****     if (handle->txBuffSizeAlign[ringId] >= length)
1784:../drivers/fsl_enet.c ****     {
1785:../drivers/fsl_enet.c ****         /* Copy data to the buffer for uDMA transfer. */
1786:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1787:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1788:../drivers/fsl_enet.c **** #else
1789:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1790:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1791:../drivers/fsl_enet.c ****         memcpy((void *)address, data, length);
1792:../drivers/fsl_enet.c **** 
1793:../drivers/fsl_enet.c ****         /* Set data length. */
1794:../drivers/fsl_enet.c ****         curBuffDescrip->length = length;
1795:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1796:../drivers/fsl_enet.c ****         /* For enable the timestamp. */
1797:../drivers/fsl_enet.c ****         if (isPtpEventMessage)
1798:../drivers/fsl_enet.c ****         {
1799:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1800:../drivers/fsl_enet.c ****         }
1801:../drivers/fsl_enet.c ****         else
1802:../drivers/fsl_enet.c ****         {
1803:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1804:../drivers/fsl_enet.c ****         }
1805:../drivers/fsl_enet.c **** 
1806:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1807:../drivers/fsl_enet.c ****         curBuffDescrip->control |= (ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_TX_LAST
1808:../drivers/fsl_enet.c **** 
1809:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor address. */
1810:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1811:../drivers/fsl_enet.c ****         {
1812:../drivers/fsl_enet.c ****             handle->txBdCurrent[ringId] = handle->txBdBase[ringId];
1813:../drivers/fsl_enet.c ****         }
1814:../drivers/fsl_enet.c ****         else
1815:../drivers/fsl_enet.c ****         {
1816:../drivers/fsl_enet.c ****             handle->txBdCurrent[ringId]++;
1817:../drivers/fsl_enet.c ****         }
1818:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1819:../drivers/fsl_enet.c ****         /* Add the cache clean maintain. */
1820:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1821:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1822:../drivers/fsl_enet.c **** #else
1823:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1824:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1825:../drivers/fsl_enet.c ****         DCACHE_CleanByRange(address, length);
1826:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1827:../drivers/fsl_enet.c ****         /* Active the transmit buffer descriptor. */
1828:../drivers/fsl_enet.c ****         ENET_ActiveSend(base, ringId);
1829:../drivers/fsl_enet.c **** 
1830:../drivers/fsl_enet.c ****         return kStatus_Success;
1831:../drivers/fsl_enet.c ****     }
1832:../drivers/fsl_enet.c ****     else
1833:../drivers/fsl_enet.c ****     {
1834:../drivers/fsl_enet.c ****         /* One frame requires more than one transmit buffers. */
1835:../drivers/fsl_enet.c ****         do
1836:../drivers/fsl_enet.c ****         {
1837:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1838:../drivers/fsl_enet.c ****             /* For enable the timestamp. */
1839:../drivers/fsl_enet.c ****             if (isPtpEventMessage)
1840:../drivers/fsl_enet.c ****             {
1841:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1842:../drivers/fsl_enet.c ****             }
1843:../drivers/fsl_enet.c ****             else
1844:../drivers/fsl_enet.c ****             {
1845:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1846:../drivers/fsl_enet.c ****             }
1847:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1848:../drivers/fsl_enet.c **** 
1849:../drivers/fsl_enet.c ****             /* Increase the buffer descriptor address. */
1850:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1851:../drivers/fsl_enet.c ****             {
1852:../drivers/fsl_enet.c ****                 handle->txBdCurrent[ringId] = handle->txBdBase[ringId];
1853:../drivers/fsl_enet.c ****             }
1854:../drivers/fsl_enet.c ****             else
1855:../drivers/fsl_enet.c ****             {
1856:../drivers/fsl_enet.c ****                 handle->txBdCurrent[ringId]++;
1857:../drivers/fsl_enet.c ****             }
1858:../drivers/fsl_enet.c ****             /* update the size left to be transmit. */
1859:../drivers/fsl_enet.c ****             sizeleft = length - len;
1860:../drivers/fsl_enet.c ****             if (sizeleft > handle->txBuffSizeAlign[ringId])
1861:../drivers/fsl_enet.c ****             {
1862:../drivers/fsl_enet.c ****                 /* Data copy. */
1863:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1864:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1865:../drivers/fsl_enet.c **** #else
1866:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1867:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1868:../drivers/fsl_enet.c ****                 memcpy((void*)address, data + len, handle->txBuffSizeAlign[ringId]);
1869:../drivers/fsl_enet.c ****                 /* Data length update. */
1870:../drivers/fsl_enet.c ****                 curBuffDescrip->length = handle->txBuffSizeAlign[ringId];
1871:../drivers/fsl_enet.c ****                 len += handle->txBuffSizeAlign[ringId];
1872:../drivers/fsl_enet.c ****                 /* Sets the control flag. */
1873:../drivers/fsl_enet.c ****                 curBuffDescrip->control &= ~ENET_BUFFDESCRIPTOR_TX_LAST_MASK;
1874:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
1875:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1876:../drivers/fsl_enet.c ****                 /* Add the cache clean maintain. */
1877:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1878:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1879:../drivers/fsl_enet.c **** #else
1880:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1881:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1882:../drivers/fsl_enet.c ****                 DCACHE_CleanByRange(address, handle->txBuffSizeAlign[ringId]);
1883:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1884:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
1885:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, ringId);
1886:../drivers/fsl_enet.c ****             }
1887:../drivers/fsl_enet.c ****             else
1888:../drivers/fsl_enet.c ****             {
1889:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1890:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1891:../drivers/fsl_enet.c **** #else
1892:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1893:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1894:../drivers/fsl_enet.c ****                 memcpy((void *)address, data + len, sizeleft);
1895:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
1896:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
1897:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_
1898:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1899:../drivers/fsl_enet.c ****                 /* Add the cache clean maintain. */
1900:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1901:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1902:../drivers/fsl_enet.c **** #else
1903:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1904:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1905:../drivers/fsl_enet.c ****                 DCACHE_CleanByRange(address, sizeleft);
1906:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1907:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor. */
1908:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, ringId);
1909:../drivers/fsl_enet.c **** 
1910:../drivers/fsl_enet.c ****                 return kStatus_Success;
1911:../drivers/fsl_enet.c ****             }
1912:../drivers/fsl_enet.c **** 
1913:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor address. */
1914:../drivers/fsl_enet.c ****             curBuffDescrip = handle->txBdCurrent[ringId];
1915:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1916:../drivers/fsl_enet.c **** /* Add the cache invalidate maintain. */
1917:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1918:../drivers/fsl_enet.c ****         } while (!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK));
1919:../drivers/fsl_enet.c **** 
1920:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1921:../drivers/fsl_enet.c ****     }
1922:../drivers/fsl_enet.c **** }
1923:../drivers/fsl_enet.c **** #endif /*  FSL_FEATURE_ENET_QUEUE > 1 */
1924:../drivers/fsl_enet.c **** 
1925:../drivers/fsl_enet.c **** void ENET_AddMulticastGroup(ENET_Type *base, uint8_t *address)
1926:../drivers/fsl_enet.c **** {
1927:../drivers/fsl_enet.c ****     assert(address);
1928:../drivers/fsl_enet.c **** 
1929:../drivers/fsl_enet.c ****     uint32_t crc = 0xFFFFFFFFU;
1930:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
1931:../drivers/fsl_enet.c ****     uint32_t count2 = 0;
1932:../drivers/fsl_enet.c **** 
1933:../drivers/fsl_enet.c ****     /* Calculates the CRC-32 polynomial on the multicast group address. */
1934:../drivers/fsl_enet.c ****     for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
1935:../drivers/fsl_enet.c ****     {
1936:../drivers/fsl_enet.c ****         uint8_t c = address[count1];
1937:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
1938:../drivers/fsl_enet.c ****         {
1939:../drivers/fsl_enet.c ****             if ((c ^ crc) & 1U)
1940:../drivers/fsl_enet.c ****             {
1941:../drivers/fsl_enet.c ****                 crc >>= 1U;
1942:../drivers/fsl_enet.c ****                 c >>= 1U;
1943:../drivers/fsl_enet.c ****                 crc ^= 0xEDB88320U;
1944:../drivers/fsl_enet.c ****             }
1945:../drivers/fsl_enet.c ****             else
1946:../drivers/fsl_enet.c ****             {
1947:../drivers/fsl_enet.c ****                 crc >>= 1U;
1948:../drivers/fsl_enet.c ****                 c >>= 1U;
1949:../drivers/fsl_enet.c ****             }
1950:../drivers/fsl_enet.c ****         }
1951:../drivers/fsl_enet.c ****     }
1952:../drivers/fsl_enet.c **** 
1953:../drivers/fsl_enet.c ****     /* Enable a multicast group address. */
1954:../drivers/fsl_enet.c ****     if (!((crc >> 0x1FU) & 1U))
1955:../drivers/fsl_enet.c ****     {
1956:../drivers/fsl_enet.c ****         base->GALR |= 1U << ((crc >> 0x1AU) & 0x1FU);
1957:../drivers/fsl_enet.c ****     }
1958:../drivers/fsl_enet.c ****     else
1959:../drivers/fsl_enet.c ****     {
1960:../drivers/fsl_enet.c ****         base->GAUR |= 1U << ((crc >> 0x1AU) & 0x1FU);
1961:../drivers/fsl_enet.c ****     }
1962:../drivers/fsl_enet.c **** }
1963:../drivers/fsl_enet.c **** 
1964:../drivers/fsl_enet.c **** void ENET_LeaveMulticastGroup(ENET_Type *base, uint8_t *address)
1965:../drivers/fsl_enet.c **** {
1966:../drivers/fsl_enet.c ****     assert(address);
1967:../drivers/fsl_enet.c **** 
1968:../drivers/fsl_enet.c ****     uint32_t crc = 0xFFFFFFFFU;
1969:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
1970:../drivers/fsl_enet.c ****     uint32_t count2 = 0;
1971:../drivers/fsl_enet.c **** 
1972:../drivers/fsl_enet.c ****     /* Calculates the CRC-32 polynomial on the multicast group address. */
1973:../drivers/fsl_enet.c ****     for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
1974:../drivers/fsl_enet.c ****     {
1975:../drivers/fsl_enet.c ****         uint8_t c = address[count1];
1976:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
1977:../drivers/fsl_enet.c ****         {
1978:../drivers/fsl_enet.c ****             if ((c ^ crc) & 1U)
1979:../drivers/fsl_enet.c ****             {
1980:../drivers/fsl_enet.c ****                 crc >>= 1U;
1981:../drivers/fsl_enet.c ****                 c >>= 1U;
1982:../drivers/fsl_enet.c ****                 crc ^= 0xEDB88320U;
1983:../drivers/fsl_enet.c ****             }
1984:../drivers/fsl_enet.c ****             else
1985:../drivers/fsl_enet.c ****             {
1986:../drivers/fsl_enet.c ****                 crc >>= 1U;
1987:../drivers/fsl_enet.c ****                 c >>= 1U;
1988:../drivers/fsl_enet.c ****             }
1989:../drivers/fsl_enet.c ****         }
1990:../drivers/fsl_enet.c ****     }
1991:../drivers/fsl_enet.c **** 
1992:../drivers/fsl_enet.c ****     /* Set the hash table. */
1993:../drivers/fsl_enet.c ****     if (!((crc >> 0x1FU) & 1U))
1994:../drivers/fsl_enet.c ****     {
1995:../drivers/fsl_enet.c ****         base->GALR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
1996:../drivers/fsl_enet.c ****     }
1997:../drivers/fsl_enet.c ****     else
1998:../drivers/fsl_enet.c ****     {
1999:../drivers/fsl_enet.c ****         base->GAUR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
2000:../drivers/fsl_enet.c ****     }
2001:../drivers/fsl_enet.c **** }
2002:../drivers/fsl_enet.c **** 
2003:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
2004:../drivers/fsl_enet.c **** status_t ENET_GetTxErrAfterSendFrame(enet_handle_t *handle, enet_data_error_stats_t *eErrorStatic)
2005:../drivers/fsl_enet.c **** {
2006:../drivers/fsl_enet.c ****     assert(handle);
2007:../drivers/fsl_enet.c ****     assert(eErrorStatic);
2008:../drivers/fsl_enet.c **** 
2009:../drivers/fsl_enet.c ****     uint16_t control = 0;
2010:../drivers/fsl_enet.c ****     uint16_t controlExt = 0;
2011:../drivers/fsl_enet.c **** 
2012:../drivers/fsl_enet.c ****     do
2013:../drivers/fsl_enet.c ****     {
2014:../drivers/fsl_enet.c ****         /* Get the current dirty transmit buffer descriptor. */
2015:../drivers/fsl_enet.c ****     control = handle->txBdDirtyStatic[0]->control;
2016:../drivers/fsl_enet.c ****     controlExt = handle->txBdDirtyStatic[0]->controlExtend0;
2017:../drivers/fsl_enet.c **** 
2018:../drivers/fsl_enet.c ****         /* Get the control status data, If the buffer descriptor has not been processed break out. 
2019:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2020:../drivers/fsl_enet.c ****         {
2021:../drivers/fsl_enet.c ****             return kStatus_ENET_TxFrameBusy;
2022:../drivers/fsl_enet.c ****         }
2023:../drivers/fsl_enet.c ****         /* Increase the transmit dirty static pointer. */
2024:../drivers/fsl_enet.c ****         if (handle->txBdDirtyStatic[0]->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
2025:../drivers/fsl_enet.c ****         {
2026:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[0] = handle->txBdBase[0];
2027:../drivers/fsl_enet.c ****         }
2028:../drivers/fsl_enet.c ****         else
2029:../drivers/fsl_enet.c ****         {
2030:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[0]++;
2031:../drivers/fsl_enet.c ****         }
2032:../drivers/fsl_enet.c **** 
2033:../drivers/fsl_enet.c ****         /* If the transmit buffer descriptor is ready and the last buffer descriptor, store packet 
2034:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_LAST_MASK)
2035:../drivers/fsl_enet.c ****         {
2036:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_ERR_MASK)
2037:../drivers/fsl_enet.c ****             {
2038:../drivers/fsl_enet.c ****                 /* Transmit error. */
2039:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxErr++;
2040:../drivers/fsl_enet.c ****             }
2041:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_EXCCOLLISIONERR_MASK)
2042:../drivers/fsl_enet.c ****             {
2043:../drivers/fsl_enet.c ****                 /* Transmit excess collision error. */
2044:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxExcessCollisionErr++;
2045:../drivers/fsl_enet.c ****             }
2046:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_LATECOLLISIONERR_MASK)
2047:../drivers/fsl_enet.c ****             {
2048:../drivers/fsl_enet.c ****                 /* Transmit late collision error. */
2049:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxLateCollisionErr++;
2050:../drivers/fsl_enet.c ****             }
2051:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_UNDERFLOWERR_MASK)
2052:../drivers/fsl_enet.c ****             {
2053:../drivers/fsl_enet.c ****                 /* Transmit under flow error. */
2054:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxUnderFlowErr++;
2055:../drivers/fsl_enet.c ****             }
2056:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_OVERFLOWERR_MASK)
2057:../drivers/fsl_enet.c ****             {
2058:../drivers/fsl_enet.c ****                 /* Transmit over flow error. */
2059:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxOverFlowErr++;
2060:../drivers/fsl_enet.c ****             }
2061:../drivers/fsl_enet.c ****             return kStatus_Success;
2062:../drivers/fsl_enet.c ****         }
2063:../drivers/fsl_enet.c **** 
2064:../drivers/fsl_enet.c ****     } while (handle->txBdDirtyStatic[0] != handle->txBdCurrent[0]);
2065:../drivers/fsl_enet.c **** 
2066:../drivers/fsl_enet.c ****     return kStatus_ENET_TxFrameFail;
2067:../drivers/fsl_enet.c **** }
2068:../drivers/fsl_enet.c **** 
2069:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1 
2070:../drivers/fsl_enet.c **** status_t ENET_GetTxErrAfterSendFrameMultiRing(enet_handle_t *handle, enet_data_error_stats_t *eErro
2071:../drivers/fsl_enet.c ****                                                                              uint32_t ringId)
2072:../drivers/fsl_enet.c **** {
2073:../drivers/fsl_enet.c ****     assert(handle);
2074:../drivers/fsl_enet.c ****     assert(eErrorStatic);
2075:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
2076:../drivers/fsl_enet.c **** 
2077:../drivers/fsl_enet.c ****     uint16_t control = 0;
2078:../drivers/fsl_enet.c ****     uint16_t controlExt = 0;
2079:../drivers/fsl_enet.c **** 
2080:../drivers/fsl_enet.c ****     do
2081:../drivers/fsl_enet.c ****     {
2082:../drivers/fsl_enet.c ****         /* Get the current dirty transmit buffer descriptor. */
2083:../drivers/fsl_enet.c ****         control = handle->txBdDirtyStatic[ringId]->control;
2084:../drivers/fsl_enet.c ****         controlExt = handle->txBdDirtyStatic[ringId]->controlExtend0;
2085:../drivers/fsl_enet.c ****         /* Get the control status data, If the buffer descriptor has not been processed break out. 
2086:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2087:../drivers/fsl_enet.c ****         {
2088:../drivers/fsl_enet.c ****             return kStatus_ENET_TxFrameBusy;
2089:../drivers/fsl_enet.c ****         }
2090:../drivers/fsl_enet.c ****         /* Increase the transmit dirty static pointer. */
2091:../drivers/fsl_enet.c ****         if (handle->txBdDirtyStatic[ringId]->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
2092:../drivers/fsl_enet.c ****         {
2093:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[ringId] = handle->txBdBase[ringId];
2094:../drivers/fsl_enet.c ****         }
2095:../drivers/fsl_enet.c ****         else
2096:../drivers/fsl_enet.c ****         {
2097:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[ringId]++;
2098:../drivers/fsl_enet.c ****         }
2099:../drivers/fsl_enet.c **** 
2100:../drivers/fsl_enet.c ****         /* If the transmit buffer descriptor is ready and the last buffer descriptor, store packet 
2101:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_LAST_MASK)
2102:../drivers/fsl_enet.c ****         {
2103:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_ERR_MASK)
2104:../drivers/fsl_enet.c ****             {
2105:../drivers/fsl_enet.c ****                 /* Transmit error. */
2106:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxErr++;
2107:../drivers/fsl_enet.c ****             }
2108:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_EXCCOLLISIONERR_MASK)
2109:../drivers/fsl_enet.c ****             {
2110:../drivers/fsl_enet.c ****                 /* Transmit excess collision error. */
2111:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxExcessCollisionErr++;
2112:../drivers/fsl_enet.c ****             }
2113:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_LATECOLLISIONERR_MASK)
2114:../drivers/fsl_enet.c ****             {
2115:../drivers/fsl_enet.c ****                 /* Transmit late collision error. */
2116:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxLateCollisionErr++;
2117:../drivers/fsl_enet.c ****             }
2118:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_UNDERFLOWERR_MASK)
2119:../drivers/fsl_enet.c ****             {
2120:../drivers/fsl_enet.c ****                 /* Transmit under flow error. */
2121:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxUnderFlowErr++;
2122:../drivers/fsl_enet.c ****             }
2123:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_OVERFLOWERR_MASK)
2124:../drivers/fsl_enet.c ****             {
2125:../drivers/fsl_enet.c ****                 /* Transmit over flow error. */
2126:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxOverFlowErr++;
2127:../drivers/fsl_enet.c ****             }
2128:../drivers/fsl_enet.c ****             return kStatus_Success;
2129:../drivers/fsl_enet.c ****         }
2130:../drivers/fsl_enet.c **** 
2131:../drivers/fsl_enet.c ****     } while (handle->txBdDirtyStatic[ringId] != handle->txBdCurrent[ringId]);
2132:../drivers/fsl_enet.c **** 
2133:../drivers/fsl_enet.c ****     return kStatus_ENET_TxFrameFail;
2134:../drivers/fsl_enet.c **** }
2135:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2136:../drivers/fsl_enet.c **** 
2137:../drivers/fsl_enet.c **** static bool ENET_Ptp1588ParseFrame(const uint8_t *data, enet_ptp_time_data_t *ptpTsData, bool isFas
2138:../drivers/fsl_enet.c **** {
2139:../drivers/fsl_enet.c ****     assert(data);
2140:../drivers/fsl_enet.c ****     if (!isFastEnabled)
2141:../drivers/fsl_enet.c ****     {
2142:../drivers/fsl_enet.c ****         assert(ptpTsData);
2143:../drivers/fsl_enet.c ****     }
2144:../drivers/fsl_enet.c **** 
2145:../drivers/fsl_enet.c ****     bool isPtpMsg = false;
2146:../drivers/fsl_enet.c ****     const uint8_t *buffer = data;
2147:../drivers/fsl_enet.c ****     uint16_t ptpType;
2148:../drivers/fsl_enet.c **** 
2149:../drivers/fsl_enet.c ****     /* Check for VLAN frame.
2150:../drivers/fsl_enet.c ****      * Add Double vlan tag check for receiving extended QIN vlan frame. */
2151:../drivers/fsl_enet.c ****     if (*(uint16_t *)(buffer + ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET) == (ENET_HTONS(ENET_8021QVLAN)
2152:../drivers/fsl_enet.c **** #if defined(FSL_FEATUR_ENET_HAS_AVB) && FSL_FEATURE_HAS_AVB
2153:../drivers/fsl_enet.c ****       || ENET_HTONS(ENET_8021QSVLAN)
2154:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
2155:../drivers/fsl_enet.c ****     ))
2156:../drivers/fsl_enet.c ****     {
2157:../drivers/fsl_enet.c ****         buffer += ENET_FRAME_VLAN_TAGLEN;
2158:../drivers/fsl_enet.c **** #if defined(FSL_FEATUR_ENET_HAS_AVB) && FSL_FEATURE_HAS_AVB
2159:../drivers/fsl_enet.c ****         if (*(uint16_t *)(buffer + ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET) == ENET_HTONS(ENET_8021QVL
2160:../drivers/fsl_enet.c ****         {
2161:../drivers/fsl_enet.c ****             buffer += ENET_FRAME_VLAN_TAGLEN;          
2162:../drivers/fsl_enet.c ****         }
2163:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
2164:../drivers/fsl_enet.c ****     }
2165:../drivers/fsl_enet.c **** 
2166:../drivers/fsl_enet.c ****     ptpType = *(uint16_t *)(buffer + ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET);
2167:../drivers/fsl_enet.c ****     switch (ENET_HTONS(ptpType))
2168:../drivers/fsl_enet.c ****     { /* Ethernet layer 2. */
2169:../drivers/fsl_enet.c ****         case ENET_ETHERNETL2:
2170:../drivers/fsl_enet.c ****             if (*(uint8_t *)(buffer + ENET_PTP1588_ETHL2_MSGTYPE_OFFSET) <= kENET_PtpEventMsgType)
2171:../drivers/fsl_enet.c ****             {
2172:../drivers/fsl_enet.c ****                 isPtpMsg = true;
2173:../drivers/fsl_enet.c ****                 if (!isFastEnabled)
2174:../drivers/fsl_enet.c ****                 {
2175:../drivers/fsl_enet.c ****                     /* It's a ptpv2 message and store the ptp header information. */
2176:../drivers/fsl_enet.c ****                     ptpTsData->version = (*(uint8_t *)(buffer + ENET_PTP1588_ETHL2_VERSION_OFFSET))
2177:../drivers/fsl_enet.c ****                     ptpTsData->messageType = (*(uint8_t *)(buffer + ENET_PTP1588_ETHL2_MSGTYPE_OFFS
2178:../drivers/fsl_enet.c ****                     ptpTsData->sequenceId = ENET_HTONS(*(uint16_t *)(buffer + ENET_PTP1588_ETHL2_SE
2179:../drivers/fsl_enet.c ****                     memcpy((void *)&ptpTsData->sourcePortId[0], (void *)(buffer + ENET_PTP1588_ETHL
2180:../drivers/fsl_enet.c ****                            kENET_PtpSrcPortIdLen);
2181:../drivers/fsl_enet.c ****                 }
2182:../drivers/fsl_enet.c ****             }
2183:../drivers/fsl_enet.c ****             break;
2184:../drivers/fsl_enet.c ****         /* IPV4. */
2185:../drivers/fsl_enet.c ****         case ENET_IPV4:
2186:../drivers/fsl_enet.c ****             if ((*(uint8_t *)(buffer + ENET_PTP1588_IPVERSION_OFFSET) >> 4) == ENET_IPV4VERSION)
2187:../drivers/fsl_enet.c ****             {
2188:../drivers/fsl_enet.c ****                 if (((*(uint16_t *)(buffer + ENET_PTP1588_IPV4_UDP_PORT_OFFSET)) == ENET_HTONS(kENE
2189:../drivers/fsl_enet.c ****                     (*(uint8_t *)(buffer + ENET_PTP1588_IPV4_UDP_PROTOCOL_OFFSET) == ENET_UDPVERSIO
2190:../drivers/fsl_enet.c ****                 {
2191:../drivers/fsl_enet.c ****                     /* Set the PTP message flag. */
2192:../drivers/fsl_enet.c ****                     isPtpMsg = true;
2193:../drivers/fsl_enet.c ****                     if (!isFastEnabled)
2194:../drivers/fsl_enet.c ****                     {
2195:../drivers/fsl_enet.c ****                         /* It's a IPV4 ptp message and store the ptp header information. */
2196:../drivers/fsl_enet.c ****                         ptpTsData->version = (*(uint8_t *)(buffer + ENET_PTP1588_IPV4_UDP_VERSION_O
2197:../drivers/fsl_enet.c ****                         ptpTsData->messageType = (*(uint8_t *)(buffer + ENET_PTP1588_IPV4_UDP_MSGTY
2198:../drivers/fsl_enet.c ****                         ptpTsData->sequenceId =
2199:../drivers/fsl_enet.c ****                             ENET_HTONS(*(uint16_t *)(buffer + ENET_PTP1588_IPV4_UDP_SEQUENCEID_OFFS
2200:../drivers/fsl_enet.c ****                         memcpy((void *)&ptpTsData->sourcePortId[0],
2201:../drivers/fsl_enet.c ****                                (void *)(buffer + ENET_PTP1588_IPV4_UDP_CLKID_OFFSET), kENET_PtpSrcP
2202:../drivers/fsl_enet.c ****                     }
2203:../drivers/fsl_enet.c ****                 }
2204:../drivers/fsl_enet.c ****             }
2205:../drivers/fsl_enet.c ****             break;
2206:../drivers/fsl_enet.c ****         /* IPV6. */
2207:../drivers/fsl_enet.c ****         case ENET_IPV6:
2208:../drivers/fsl_enet.c ****             if ((*(uint8_t *)(buffer + ENET_PTP1588_IPVERSION_OFFSET) >> 4) == ENET_IPV6VERSION)
2209:../drivers/fsl_enet.c ****             {
2210:../drivers/fsl_enet.c ****                 if (((*(uint16_t *)(buffer + ENET_PTP1588_IPV6_UDP_PORT_OFFSET)) == ENET_HTONS(kENE
2211:../drivers/fsl_enet.c ****                     (*(uint8_t *)(buffer + ENET_PTP1588_IPV6_UDP_PROTOCOL_OFFSET) == ENET_UDPVERSIO
2212:../drivers/fsl_enet.c ****                 {
2213:../drivers/fsl_enet.c ****                     /* Set the PTP message flag. */
2214:../drivers/fsl_enet.c ****                     isPtpMsg = true;
2215:../drivers/fsl_enet.c ****                     if (!isFastEnabled)
2216:../drivers/fsl_enet.c ****                     {
2217:../drivers/fsl_enet.c ****                         /* It's a IPV6 ptp message and store the ptp header information. */
2218:../drivers/fsl_enet.c ****                         ptpTsData->version = (*(uint8_t *)(buffer + ENET_PTP1588_IPV6_UDP_VERSION_O
2219:../drivers/fsl_enet.c ****                         ptpTsData->messageType = (*(uint8_t *)(buffer + ENET_PTP1588_IPV6_UDP_MSGTY
2220:../drivers/fsl_enet.c ****                         ptpTsData->sequenceId =
2221:../drivers/fsl_enet.c ****                             ENET_HTONS(*(uint16_t *)(buffer + ENET_PTP1588_IPV6_UDP_SEQUENCEID_OFFS
2222:../drivers/fsl_enet.c ****                         memcpy((void *)&ptpTsData->sourcePortId[0],
2223:../drivers/fsl_enet.c ****                                (void *)(buffer + ENET_PTP1588_IPV6_UDP_CLKID_OFFSET), kENET_PtpSrcP
2224:../drivers/fsl_enet.c ****                     }
2225:../drivers/fsl_enet.c ****                 }
2226:../drivers/fsl_enet.c ****             }
2227:../drivers/fsl_enet.c ****             break;
2228:../drivers/fsl_enet.c ****         default:
2229:../drivers/fsl_enet.c ****             break;
2230:../drivers/fsl_enet.c ****     }
2231:../drivers/fsl_enet.c ****     return isPtpMsg;
2232:../drivers/fsl_enet.c **** }
2233:../drivers/fsl_enet.c **** 
2234:../drivers/fsl_enet.c **** void ENET_Ptp1588Configure(ENET_Type *base, enet_handle_t *handle, enet_ptp_config_t *ptpConfig)
2235:../drivers/fsl_enet.c **** {
2236:../drivers/fsl_enet.c ****     assert(handle);
2237:../drivers/fsl_enet.c ****     assert(ptpConfig);
2238:../drivers/fsl_enet.c ****     uint8_t count;
2239:../drivers/fsl_enet.c **** 
2240:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
2241:../drivers/fsl_enet.c ****     uint32_t mask = kENET_TxBufferInterrupt;
2242:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2243:../drivers/fsl_enet.c ****     mask |= kENET_TxBuffer1Interrupt | kENET_TxBuffer2Interrupt;
2244:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2245:../drivers/fsl_enet.c **** 
2246:../drivers/fsl_enet.c ****     /* Start the 1588 timer. */
2247:../drivers/fsl_enet.c ****     ENET_Ptp1588StartTimer(base, ptpConfig->ptp1588ClockSrc_Hz);
2248:../drivers/fsl_enet.c **** 
2249:../drivers/fsl_enet.c ****     for (count = 0; count < handle->ringNum; count++)
2250:../drivers/fsl_enet.c ****     {
2251:../drivers/fsl_enet.c ****         handle->txBdDirtyTime[count] = handle->txBdBase[count];
2252:../drivers/fsl_enet.c ****         handle->txBdDirtyStatic[count] = handle->txBdBase[count];
2253:../drivers/fsl_enet.c ****     }
2254:../drivers/fsl_enet.c **** 
2255:../drivers/fsl_enet.c ****     /* Setting the receive and transmit state for transaction. */
2256:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.ptpTsData = ptpConfig->rxPtpTsData;
2257:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.size = ptpConfig->ptpTsRxBuffNum;
2258:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.front = 0;
2259:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.end = 0;
2260:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.ptpTsData = ptpConfig->txPtpTsData;
2261:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.size = ptpConfig->ptpTsTxBuffNum;
2262:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.front = 0;
2263:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.end = 0;
2264:../drivers/fsl_enet.c ****     handle->msTimerSecond = 0;
2265:../drivers/fsl_enet.c **** 
2266:../drivers/fsl_enet.c ****     /* Set the IRQ handler when the interrupt is enabled. */
2267:../drivers/fsl_enet.c ****     s_enetTxIsr = ENET_TransmitIRQHandler;
2268:../drivers/fsl_enet.c ****     s_enetTsIsr = ENET_Ptp1588TimerIRQHandler;
2269:../drivers/fsl_enet.c **** 
2270:../drivers/fsl_enet.c ****     /* Enables the time stamp interrupt and transmit frame interrupt to
2271:../drivers/fsl_enet.c ****      * handle the time-stamp . */
2272:../drivers/fsl_enet.c ****     ENET_EnableInterrupts(base, (ENET_TS_INTERRUPT | ENET_TX_INTERRUPT));
2273:../drivers/fsl_enet.c ****     ENET_DisableInterrupts(base, mask);
2274:../drivers/fsl_enet.c **** 
2275:../drivers/fsl_enet.c ****     EnableIRQ(s_enetTsIrqId[instance]);
2276:../drivers/fsl_enet.c ****     EnableIRQ(s_enetTxIrqId[instance]);
2277:../drivers/fsl_enet.c **** }
2278:../drivers/fsl_enet.c **** 
2279:../drivers/fsl_enet.c **** void ENET_Ptp1588StartTimer(ENET_Type *base, uint32_t ptpClkSrc)
2280:../drivers/fsl_enet.c **** {
2281:../drivers/fsl_enet.c ****     /* Restart PTP 1588 timer, master clock. */
2282:../drivers/fsl_enet.c ****     base->ATCR = ENET_ATCR_RESTART_MASK;
2283:../drivers/fsl_enet.c **** 
2284:../drivers/fsl_enet.c ****     /* Initializes PTP 1588 timer. */
2285:../drivers/fsl_enet.c ****     base->ATINC = ENET_ATINC_INC(ENET_NANOSECOND_ONE_SECOND / ptpClkSrc);
2286:../drivers/fsl_enet.c ****     base->ATPER = ENET_NANOSECOND_ONE_SECOND;
2287:../drivers/fsl_enet.c ****     /* Sets periodical event and the event signal output assertion and Actives PTP 1588 timer.  */
2288:../drivers/fsl_enet.c ****     base->ATCR = ENET_ATCR_PEREN_MASK | ENET_ATCR_PINPER_MASK | ENET_ATCR_EN_MASK;
2289:../drivers/fsl_enet.c **** }
2290:../drivers/fsl_enet.c **** 
2291:../drivers/fsl_enet.c **** void ENET_Ptp1588GetTimer(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_t *ptpTime)
2292:../drivers/fsl_enet.c **** {
2293:../drivers/fsl_enet.c ****     assert(handle);
2294:../drivers/fsl_enet.c ****     assert(ptpTime);
2295:../drivers/fsl_enet.c ****     uint16_t count = ENET_1588TIME_DELAY_COUNT;
2296:../drivers/fsl_enet.c ****     uint32_t primask;
2297:../drivers/fsl_enet.c **** 
2298:../drivers/fsl_enet.c ****     /* Disables the interrupt. */
2299:../drivers/fsl_enet.c ****     primask = DisableGlobalIRQ();
2300:../drivers/fsl_enet.c **** 
2301:../drivers/fsl_enet.c ****     /* Get the current PTP time. */
2302:../drivers/fsl_enet.c ****     ptpTime->second = handle->msTimerSecond;
2303:../drivers/fsl_enet.c ****     /* Get the nanosecond from the master timer. */
2304:../drivers/fsl_enet.c ****     base->ATCR |= ENET_ATCR_CAPTURE_MASK;
2305:../drivers/fsl_enet.c ****     /* Add at least six clock cycle delay to get accurate time.
2306:../drivers/fsl_enet.c ****        It's the requirement when the 1588 clock source is slower
2307:../drivers/fsl_enet.c ****        than the register clock.
2308:../drivers/fsl_enet.c ****     */
2309:../drivers/fsl_enet.c ****     while (count--)
2310:../drivers/fsl_enet.c ****     {
2311:../drivers/fsl_enet.c ****         __NOP();
2312:../drivers/fsl_enet.c ****     }
2313:../drivers/fsl_enet.c ****     /* Get the captured time. */
2314:../drivers/fsl_enet.c ****     ptpTime->nanosecond = base->ATVR;
2315:../drivers/fsl_enet.c **** 
2316:../drivers/fsl_enet.c ****     /* Enables the interrupt. */
2317:../drivers/fsl_enet.c ****     EnableGlobalIRQ(primask);
2318:../drivers/fsl_enet.c **** }
2319:../drivers/fsl_enet.c **** 
2320:../drivers/fsl_enet.c **** void ENET_Ptp1588SetTimer(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_t *ptpTime)
2321:../drivers/fsl_enet.c **** {
2322:../drivers/fsl_enet.c ****     assert(handle);
2323:../drivers/fsl_enet.c ****     assert(ptpTime);
2324:../drivers/fsl_enet.c **** 
2325:../drivers/fsl_enet.c ****     uint32_t primask;
2326:../drivers/fsl_enet.c **** 
2327:../drivers/fsl_enet.c ****     /* Disables the interrupt. */
2328:../drivers/fsl_enet.c ****     primask = DisableGlobalIRQ();
2329:../drivers/fsl_enet.c **** 
2330:../drivers/fsl_enet.c ****     /* Sets PTP timer. */
2331:../drivers/fsl_enet.c ****     handle->msTimerSecond = ptpTime->second;
2332:../drivers/fsl_enet.c ****     base->ATVR = ptpTime->nanosecond;
2333:../drivers/fsl_enet.c **** 
2334:../drivers/fsl_enet.c ****     /* Enables the interrupt. */
2335:../drivers/fsl_enet.c ****     EnableGlobalIRQ(primask);
2336:../drivers/fsl_enet.c **** }
2337:../drivers/fsl_enet.c **** 
2338:../drivers/fsl_enet.c **** void ENET_Ptp1588AdjustTimer(ENET_Type *base, uint32_t corrIncrease, uint32_t corrPeriod)
2339:../drivers/fsl_enet.c **** {
2340:../drivers/fsl_enet.c ****     /* Set correction for PTP timer increment. */
2341:../drivers/fsl_enet.c ****     base->ATINC = (base->ATINC & ~ENET_ATINC_INC_CORR_MASK) | (corrIncrease << ENET_ATINC_INC_CORR_
2342:../drivers/fsl_enet.c ****     /* Set correction for PTP timer period. */
2343:../drivers/fsl_enet.c ****     base->ATCOR = (base->ATCOR & ~ENET_ATCOR_COR_MASK) | (corrPeriod << ENET_ATCOR_COR_SHIFT);
2344:../drivers/fsl_enet.c **** }
2345:../drivers/fsl_enet.c **** 
2346:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588UpdateTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
2347:../drivers/fsl_enet.c **** {
2348:../drivers/fsl_enet.c ****     assert(ptpTsDataRing);
2349:../drivers/fsl_enet.c ****     assert(ptpTsDataRing->ptpTsData);
2350:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2351:../drivers/fsl_enet.c **** 
2352:../drivers/fsl_enet.c ****     uint16_t usedBuffer = 0;
2353:../drivers/fsl_enet.c **** 
2354:../drivers/fsl_enet.c ****     /* Check if the buffers ring is full. */
2355:../drivers/fsl_enet.c ****     if (ptpTsDataRing->end >= ptpTsDataRing->front)
2356:../drivers/fsl_enet.c ****     {
2357:../drivers/fsl_enet.c ****         usedBuffer = ptpTsDataRing->end - ptpTsDataRing->front;
2358:../drivers/fsl_enet.c ****     }
2359:../drivers/fsl_enet.c ****     else
2360:../drivers/fsl_enet.c ****     {
2361:../drivers/fsl_enet.c ****         usedBuffer = ptpTsDataRing->size - (ptpTsDataRing->front - ptpTsDataRing->end);
2362:../drivers/fsl_enet.c ****     }
2363:../drivers/fsl_enet.c **** 
2364:../drivers/fsl_enet.c ****     if (usedBuffer == ptpTsDataRing->size)
2365:../drivers/fsl_enet.c ****     {
2366:../drivers/fsl_enet.c ****         return kStatus_ENET_PtpTsRingFull;
2367:../drivers/fsl_enet.c ****     }
2368:../drivers/fsl_enet.c **** 
2369:../drivers/fsl_enet.c ****     /* Copy the new data into the buffer. */
2370:../drivers/fsl_enet.c ****     memcpy((ptpTsDataRing->ptpTsData + ptpTsDataRing->end), ptpTimeData, sizeof(enet_ptp_time_data_
2371:../drivers/fsl_enet.c **** 
2372:../drivers/fsl_enet.c ****     /* Increase the buffer pointer to the next empty one. */
2373:../drivers/fsl_enet.c ****     ptpTsDataRing->end = (ptpTsDataRing->end + 1) % ptpTsDataRing->size;
2374:../drivers/fsl_enet.c **** 
2375:../drivers/fsl_enet.c ****     return kStatus_Success;
2376:../drivers/fsl_enet.c **** }
2377:../drivers/fsl_enet.c **** 
2378:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588SearchTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
2379:../drivers/fsl_enet.c **** {
2380:../drivers/fsl_enet.c ****     assert(ptpTsDataRing);
2381:../drivers/fsl_enet.c ****     assert(ptpTsDataRing->ptpTsData);
2382:../drivers/fsl_enet.c ****     assert(ptpTimedata);
2383:../drivers/fsl_enet.c **** 
2384:../drivers/fsl_enet.c ****     uint32_t index;
2385:../drivers/fsl_enet.c ****     uint32_t size;
2386:../drivers/fsl_enet.c ****     uint16_t usedBuffer = 0;
2387:../drivers/fsl_enet.c **** 
2388:../drivers/fsl_enet.c ****     /* Check the PTP 1588 timestamp ring. */
2389:../drivers/fsl_enet.c ****     if (ptpTsDataRing->front == ptpTsDataRing->end)
2390:../drivers/fsl_enet.c ****     {
2391:../drivers/fsl_enet.c ****         return kStatus_ENET_PtpTsRingEmpty;
2392:../drivers/fsl_enet.c ****     }
2393:../drivers/fsl_enet.c **** 
2394:../drivers/fsl_enet.c ****     /* Search the element in the ring buffer */
2395:../drivers/fsl_enet.c ****     index = ptpTsDataRing->front;
2396:../drivers/fsl_enet.c ****     size = ptpTsDataRing->size;
2397:../drivers/fsl_enet.c ****     while (index != ptpTsDataRing->end)
2398:../drivers/fsl_enet.c ****     {
2399:../drivers/fsl_enet.c ****         if (((ptpTsDataRing->ptpTsData + index)->sequenceId == ptpTimedata->sequenceId) &&
2400:../drivers/fsl_enet.c ****             (!memcmp(((void *)&(ptpTsDataRing->ptpTsData + index)->sourcePortId[0]),
2401:../drivers/fsl_enet.c ****                      (void *)&ptpTimedata->sourcePortId[0], kENET_PtpSrcPortIdLen)) &&
2402:../drivers/fsl_enet.c ****             ((ptpTsDataRing->ptpTsData + index)->version == ptpTimedata->version) &&
2403:../drivers/fsl_enet.c ****             ((ptpTsDataRing->ptpTsData + index)->messageType == ptpTimedata->messageType))
2404:../drivers/fsl_enet.c ****         {
2405:../drivers/fsl_enet.c ****             break;
2406:../drivers/fsl_enet.c ****         }
2407:../drivers/fsl_enet.c **** 
2408:../drivers/fsl_enet.c ****         /* Increase the ptp ring index. */
2409:../drivers/fsl_enet.c ****         index = (index + 1) % size;
2410:../drivers/fsl_enet.c ****     }
2411:../drivers/fsl_enet.c **** 
2412:../drivers/fsl_enet.c ****     if (index == ptpTsDataRing->end)
2413:../drivers/fsl_enet.c ****     {
2414:../drivers/fsl_enet.c ****         /* Check if buffers is full. */
2415:../drivers/fsl_enet.c ****         if (ptpTsDataRing->end >= ptpTsDataRing->front)
2416:../drivers/fsl_enet.c ****         {
2417:../drivers/fsl_enet.c ****             usedBuffer = ptpTsDataRing->end - ptpTsDataRing->front;
2418:../drivers/fsl_enet.c ****         }
2419:../drivers/fsl_enet.c ****         else
2420:../drivers/fsl_enet.c ****         {
2421:../drivers/fsl_enet.c ****             usedBuffer = ptpTsDataRing->size - (ptpTsDataRing->front - ptpTsDataRing->end);
2422:../drivers/fsl_enet.c ****         }
2423:../drivers/fsl_enet.c **** 
2424:../drivers/fsl_enet.c ****         if (usedBuffer == ptpTsDataRing->size)
2425:../drivers/fsl_enet.c ****         { /* Drop one in the front. */
2426:../drivers/fsl_enet.c ****             ptpTsDataRing->front = (ptpTsDataRing->front + 1) % size;
2427:../drivers/fsl_enet.c ****         }
2428:../drivers/fsl_enet.c ****         return kStatus_ENET_PtpTsRingFull;
2429:../drivers/fsl_enet.c ****     }
2430:../drivers/fsl_enet.c **** 
2431:../drivers/fsl_enet.c ****     /* Get the right timestamp of the required ptp messag. */
2432:../drivers/fsl_enet.c ****     ptpTimedata->timeStamp.second = (ptpTsDataRing->ptpTsData + index)->timeStamp.second;
2433:../drivers/fsl_enet.c ****     ptpTimedata->timeStamp.nanosecond = (ptpTsDataRing->ptpTsData + index)->timeStamp.nanosecond;
2434:../drivers/fsl_enet.c **** 
2435:../drivers/fsl_enet.c ****     /* Increase the index. */
2436:../drivers/fsl_enet.c ****     ptpTsDataRing->front = (ptpTsDataRing->front + 1) % size;
2437:../drivers/fsl_enet.c **** 
2438:../drivers/fsl_enet.c ****     return kStatus_Success;
2439:../drivers/fsl_enet.c **** }
2440:../drivers/fsl_enet.c **** 
2441:../drivers/fsl_enet.c **** static status_t ENET_StoreRxFrameTime(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_data_t 
2442:../drivers/fsl_enet.c **** {
2443:../drivers/fsl_enet.c ****     assert(handle);
2444:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2445:../drivers/fsl_enet.c **** 
2446:../drivers/fsl_enet.c ****     bool ptpTimerWrap = false;
2447:../drivers/fsl_enet.c ****     enet_ptp_time_t ptpTimer;
2448:../drivers/fsl_enet.c ****     uint32_t primask;
2449:../drivers/fsl_enet.c **** 
2450:../drivers/fsl_enet.c ****     /* Disables the interrupt. */
2451:../drivers/fsl_enet.c ****     primask = DisableGlobalIRQ();
2452:../drivers/fsl_enet.c **** 
2453:../drivers/fsl_enet.c ****     /* Get current PTP timer nanosecond value. */
2454:../drivers/fsl_enet.c ****     ENET_Ptp1588GetTimer(base, handle, &ptpTimer);
2455:../drivers/fsl_enet.c **** 
2456:../drivers/fsl_enet.c ****     /* Get PTP timer wrap event. */
2457:../drivers/fsl_enet.c ****     ptpTimerWrap = base->EIR & kENET_TsTimerInterrupt;
2458:../drivers/fsl_enet.c **** 
2459:../drivers/fsl_enet.c ****     /* Get transmit time stamp second. */
2460:../drivers/fsl_enet.c ****     if ((ptpTimer.nanosecond > ptpTimeData->timeStamp.nanosecond) ||
2461:../drivers/fsl_enet.c ****         ((ptpTimer.nanosecond < ptpTimeData->timeStamp.nanosecond) && ptpTimerWrap))
2462:../drivers/fsl_enet.c ****     {
2463:../drivers/fsl_enet.c ****         ptpTimeData->timeStamp.second = handle->msTimerSecond;
2464:../drivers/fsl_enet.c ****     }
2465:../drivers/fsl_enet.c ****     else
2466:../drivers/fsl_enet.c ****     {
2467:../drivers/fsl_enet.c ****         ptpTimeData->timeStamp.second = handle->msTimerSecond - 1;
2468:../drivers/fsl_enet.c ****     }
2469:../drivers/fsl_enet.c ****     /* Enable the interrupt. */
2470:../drivers/fsl_enet.c ****     EnableGlobalIRQ(primask);
2471:../drivers/fsl_enet.c **** 
2472:../drivers/fsl_enet.c ****     /* Store the timestamp to the receive time stamp ring. */
2473:../drivers/fsl_enet.c ****     /* Check if the buffers ring is full. */
2474:../drivers/fsl_enet.c ****     return ENET_Ptp1588UpdateTimeRing(&handle->rxPtpTsDataRing, ptpTimeData);
2475:../drivers/fsl_enet.c **** }
2476:../drivers/fsl_enet.c **** 
2477:../drivers/fsl_enet.c **** static status_t ENET_StoreTxFrameTime(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
2478:../drivers/fsl_enet.c **** {
2479:../drivers/fsl_enet.c ****     assert(handle);
2480:../drivers/fsl_enet.c **** 
2481:../drivers/fsl_enet.c ****     uint32_t primask;
2482:../drivers/fsl_enet.c ****     bool ptpTimerWrap;
2483:../drivers/fsl_enet.c ****     bool isPtpEventMessage = false;
2484:../drivers/fsl_enet.c ****     enet_ptp_time_data_t ptpTimeData;
2485:../drivers/fsl_enet.c ****     volatile enet_tx_bd_struct_t *curBuffDescrip = handle->txBdDirtyTime[ringId];
2486:../drivers/fsl_enet.c ****     uint32_t address;
2487:../drivers/fsl_enet.c **** 
2488:../drivers/fsl_enet.c ****     /* Get the control status data, If the buffer descriptor has not been processed break out. */
2489:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2490:../drivers/fsl_enet.c ****     {
2491:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
2492:../drivers/fsl_enet.c ****     }
2493:../drivers/fsl_enet.c **** 
2494:../drivers/fsl_enet.c ****     /* Parse the PTP message. */
2495:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
2496:../drivers/fsl_enet.c ****     address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local);
2497:../drivers/fsl_enet.c **** #else
2498:../drivers/fsl_enet.c ****     address = (uint32_t)curBuffDescrip->buffer;
2499:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
2500:../drivers/fsl_enet.c ****     isPtpEventMessage = ENET_Ptp1588ParseFrame((uint8_t *)address, &ptpTimeData, false);
2501:../drivers/fsl_enet.c ****     if (isPtpEventMessage)
2502:../drivers/fsl_enet.c ****     {
2503:../drivers/fsl_enet.c ****         do
2504:../drivers/fsl_enet.c ****         {
2505:../drivers/fsl_enet.c ****             /* Increase current buffer descriptor to the next one. */
2506:../drivers/fsl_enet.c ****             if (handle->txBdDirtyTime[ringId]->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
2507:../drivers/fsl_enet.c ****             {
2508:../drivers/fsl_enet.c ****                 handle->txBdDirtyTime[ringId] = handle->txBdBase[ringId];
2509:../drivers/fsl_enet.c ****             }
2510:../drivers/fsl_enet.c ****             else
2511:../drivers/fsl_enet.c ****             {
2512:../drivers/fsl_enet.c ****                 handle->txBdDirtyTime[ringId]++;
2513:../drivers/fsl_enet.c ****             }
2514:../drivers/fsl_enet.c **** 
2515:../drivers/fsl_enet.c ****             /* Do time stamp check on the last buffer descriptor of the frame. */
2516:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_LAST_MASK)
2517:../drivers/fsl_enet.c ****             {
2518:../drivers/fsl_enet.c ****                 /* Disables the interrupt. */
2519:../drivers/fsl_enet.c ****                 primask = DisableGlobalIRQ();
2520:../drivers/fsl_enet.c **** 
2521:../drivers/fsl_enet.c ****                 /* Get current PTP timer nanosecond value. */
2522:../drivers/fsl_enet.c ****                 ENET_Ptp1588GetTimer(base, handle, &ptpTimeData.timeStamp);
2523:../drivers/fsl_enet.c **** 
2524:../drivers/fsl_enet.c ****                 /* Get PTP timer wrap event. */
2525:../drivers/fsl_enet.c ****                 ptpTimerWrap = base->EIR & kENET_TsTimerInterrupt;
2526:../drivers/fsl_enet.c **** 
2527:../drivers/fsl_enet.c ****                 /* Get transmit time stamp second. */
2528:../drivers/fsl_enet.c ****                 if ((ptpTimeData.timeStamp.nanosecond > curBuffDescrip->timestamp) ||
2529:../drivers/fsl_enet.c ****                     ((ptpTimeData.timeStamp.nanosecond < curBuffDescrip->timestamp) && ptpTimerWrap
2530:../drivers/fsl_enet.c ****                 {
2531:../drivers/fsl_enet.c ****                     ptpTimeData.timeStamp.second = handle->msTimerSecond;
2532:../drivers/fsl_enet.c ****                 }
2533:../drivers/fsl_enet.c ****                 else
2534:../drivers/fsl_enet.c ****                 {
2535:../drivers/fsl_enet.c ****                     ptpTimeData.timeStamp.second = handle->msTimerSecond - 1;
2536:../drivers/fsl_enet.c ****                 }
2537:../drivers/fsl_enet.c **** 
2538:../drivers/fsl_enet.c ****                 /* Enable the interrupt. */
2539:../drivers/fsl_enet.c ****                 EnableGlobalIRQ(primask);
2540:../drivers/fsl_enet.c **** 
2541:../drivers/fsl_enet.c ****                 /* Store the timestamp to the transmit timestamp ring. */
2542:../drivers/fsl_enet.c ****                 return ENET_Ptp1588UpdateTimeRing(&handle->txPtpTsDataRing, &ptpTimeData);
2543:../drivers/fsl_enet.c ****             }
2544:../drivers/fsl_enet.c **** 
2545:../drivers/fsl_enet.c ****             /* Get the current transmit buffer descriptor. */
2546:../drivers/fsl_enet.c ****             curBuffDescrip = handle->txBdDirtyTime[ringId];
2547:../drivers/fsl_enet.c **** 
2548:../drivers/fsl_enet.c **** 
2549:../drivers/fsl_enet.c ****             /* Get the control status data, If the buffer descriptor has not been processed break o
2550:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2551:../drivers/fsl_enet.c ****             {
2552:../drivers/fsl_enet.c ****                 return kStatus_ENET_TxFrameBusy;
2553:../drivers/fsl_enet.c ****             }
2554:../drivers/fsl_enet.c ****         } while (handle->txBdDirtyTime[ringId] != handle->txBdCurrent[ringId]);
2555:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameFail;
2556:../drivers/fsl_enet.c ****     }
2557:../drivers/fsl_enet.c ****     return kStatus_Success;
2558:../drivers/fsl_enet.c **** }
2559:../drivers/fsl_enet.c **** 
2560:../drivers/fsl_enet.c **** status_t ENET_GetTxFrameTime(enet_handle_t *handle, enet_ptp_time_data_t *ptpTimeData)
2561:../drivers/fsl_enet.c **** {
2562:../drivers/fsl_enet.c ****     assert(handle);
2563:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2564:../drivers/fsl_enet.c **** 
2565:../drivers/fsl_enet.c ****     return ENET_Ptp1588SearchTimeRing(&handle->txPtpTsDataRing, ptpTimeData);
2566:../drivers/fsl_enet.c **** }
2567:../drivers/fsl_enet.c **** 
2568:../drivers/fsl_enet.c **** status_t ENET_GetRxFrameTime(enet_handle_t *handle, enet_ptp_time_data_t *ptpTimeData)
2569:../drivers/fsl_enet.c **** {
2570:../drivers/fsl_enet.c ****     assert(handle);
2571:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2572:../drivers/fsl_enet.c **** 
2573:../drivers/fsl_enet.c ****     return ENET_Ptp1588SearchTimeRing(&handle->rxPtpTsDataRing, ptpTimeData);
2574:../drivers/fsl_enet.c **** }
2575:../drivers/fsl_enet.c **** 
2576:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
2577:../drivers/fsl_enet.c **** void ENET_AVBConfigure(ENET_Type *base, enet_handle_t *handle, const enet_avb_config_t *config)
2578:../drivers/fsl_enet.c **** {
2579:../drivers/fsl_enet.c ****     assert(config);
2580:../drivers/fsl_enet.c **** 
2581:../drivers/fsl_enet.c ****     uint8_t count = 0;
2582:../drivers/fsl_enet.c **** 
2583:../drivers/fsl_enet.c ****     for (count = 0; count < FSL_FEATURE_ENET_QUEUE - 1; count++)
2584:../drivers/fsl_enet.c ****     {
2585:../drivers/fsl_enet.c ****         /* Set the AVB receive ring classification match when the match is not 0. */
2586:../drivers/fsl_enet.c ****         if (config->rxClassifyMatch[count])
2587:../drivers/fsl_enet.c ****         {
2588:../drivers/fsl_enet.c ****             base->RCMR[count] = (config->rxClassifyMatch[count] & 0xFFFF) | ENET_RCMR_MATCHEN_MASK;
2589:../drivers/fsl_enet.c ****         }
2590:../drivers/fsl_enet.c ****         /* Set the dma controller for the extended ring. */
2591:../drivers/fsl_enet.c ****         base->DMACFG[count] |= ENET_DMACFG_IDLE_SLOPE(config->idleSlope[count]);
2592:../drivers/fsl_enet.c ****     }
2593:../drivers/fsl_enet.c **** 
2594:../drivers/fsl_enet.c ****     /* Shall use the credit-based scheme for avb. */
2595:../drivers/fsl_enet.c ****     base->QOS &= ~ENET_QOS_TX_SCHEME_MASK;
2596:../drivers/fsl_enet.c ****     base->QOS |= ENET_QOS_RX_FLUSH0_MASK;
2597:../drivers/fsl_enet.c **** }
2598:../drivers/fsl_enet.c **** #endif /* FSL_FETAURE_ENET_HAS_AVB */
2599:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
2600:../drivers/fsl_enet.c **** 
2601:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2602:../drivers/fsl_enet.c **** void ENET_TransmitIRQHandler(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
2603:../drivers/fsl_enet.c **** #else
2604:../drivers/fsl_enet.c **** void ENET_TransmitIRQHandler(ENET_Type *base, enet_handle_t *handle)
2605:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2606:../drivers/fsl_enet.c **** {
  28              		.loc 1 2606 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  34              		.cfi_def_cfa_offset 24
  35              		.cfi_offset 3, -24
  36              		.cfi_offset 4, -20
  37              		.cfi_offset 5, -16
  38              		.cfi_offset 6, -12
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  41              		.loc 1 2606 0
  42 0002 0446     		mov	r4, r0
  43 0004 0D46     		mov	r5, r1
2607:../drivers/fsl_enet.c ****     assert(handle);
2608:../drivers/fsl_enet.c ****     uint32_t mask = kENET_TxBufferInterrupt | kENET_TxFrameInterrupt;
2609:../drivers/fsl_enet.c **** #if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) || (FSL_FEATURE_ENET_QUEUE > 1)
2610:../drivers/fsl_enet.c ****     uint32_t index = 0;
2611:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTORMODE  || (FSL_FEATURE_ENET_QUEUE > 1) */
2612:../drivers/fsl_enet.c **** 
2613:../drivers/fsl_enet.c **** /* Check if the transmit interrupt happen. */
2614:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2615:../drivers/fsl_enet.c ****     switch (ringId)
2616:../drivers/fsl_enet.c ****     {
2617:../drivers/fsl_enet.c ****         case kENET_Ring1:
2618:../drivers/fsl_enet.c ****             mask = (kENET_TxFrame1Interrupt | kENET_TxBuffer1Interrupt);
2619:../drivers/fsl_enet.c ****             break;
2620:../drivers/fsl_enet.c ****         case kENET_Ring2:
2621:../drivers/fsl_enet.c ****             mask = (kENET_TxFrame2Interrupt | kENET_TxBuffer2Interrupt);
2622:../drivers/fsl_enet.c ****             break;
2623:../drivers/fsl_enet.c ****         default:
2624:../drivers/fsl_enet.c ****             break;
2625:../drivers/fsl_enet.c ****     }
2626:../drivers/fsl_enet.c ****     index = ringId;
2627:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2628:../drivers/fsl_enet.c **** 
2629:../drivers/fsl_enet.c ****     while (mask & base->EIR)
2630:../drivers/fsl_enet.c ****     {
2631:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
2632:../drivers/fsl_enet.c ****         if (base->EIR & kENET_TxFrameInterrupt)
2633:../drivers/fsl_enet.c ****         {
2634:../drivers/fsl_enet.c ****             /* Store the transmit timestamp from the buffer descriptor should be done here. */
2635:../drivers/fsl_enet.c ****             ENET_StoreTxFrameTime(base, handle, index);
2636:../drivers/fsl_enet.c ****         }
2637:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
2638:../drivers/fsl_enet.c **** 
2639:../drivers/fsl_enet.c ****         /* Clear the transmit interrupt event. */
2640:../drivers/fsl_enet.c ****         base->EIR = mask;
  44              		.loc 1 2640 0
  45 0006 4FF04067 		mov	r7, #201326592
  46              	.LVL1:
  47              	.L3:
2629:../drivers/fsl_enet.c ****     {
  48              		.loc 1 2629 0
  49 000a 6368     		ldr	r3, [r4, #4]
  50 000c 13F0406F 		tst	r3, #201326592
  51 0010 00D1     		bne	.L4
2641:../drivers/fsl_enet.c **** 
2642:../drivers/fsl_enet.c ****         /* Callback function. */
2643:../drivers/fsl_enet.c ****         if (handle->callback)
2644:../drivers/fsl_enet.c ****         {
2645:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2646:../drivers/fsl_enet.c ****             handle->callback(base, handle, index, kENET_TxEvent, handle->userData);
2647:../drivers/fsl_enet.c **** #else
2648:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_TxEvent, handle->userData);
2649:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2650:../drivers/fsl_enet.c ****         }
2651:../drivers/fsl_enet.c ****     }
2652:../drivers/fsl_enet.c **** }
  52              		.loc 1 2652 0
  53 0012 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
  54              	.LVL2:
  55              	.L4:
2643:../drivers/fsl_enet.c ****         {
  56              		.loc 1 2643 0
  57 0014 EE69     		ldr	r6, [r5, #28]
2640:../drivers/fsl_enet.c **** 
  58              		.loc 1 2640 0
  59 0016 6760     		str	r7, [r4, #4]
2643:../drivers/fsl_enet.c ****         {
  60              		.loc 1 2643 0
  61 0018 002E     		cmp	r6, #0
  62 001a F6D0     		beq	.L3
2648:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
  63              		.loc 1 2648 0
  64 001c 2B6A     		ldr	r3, [r5, #32]
  65 001e 0122     		movs	r2, #1
  66 0020 2946     		mov	r1, r5
  67 0022 2046     		mov	r0, r4
  68 0024 B047     		blx	r6
  69              	.LVL3:
  70 0026 F0E7     		b	.L3
  71              		.cfi_endproc
  72              	.LFE180:
  74              		.section	.text.ENET_ReceiveIRQHandler,"ax",%progbits
  75              		.align	1
  76              		.global	ENET_ReceiveIRQHandler
  77              		.syntax unified
  78              		.thumb
  79              		.thumb_func
  80              		.fpu fpv4-sp-d16
  82              	ENET_ReceiveIRQHandler:
  83              	.LFB181:
2653:../drivers/fsl_enet.c **** 
2654:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2655:../drivers/fsl_enet.c **** void ENET_ReceiveIRQHandler(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
2656:../drivers/fsl_enet.c **** #else
2657:../drivers/fsl_enet.c **** void ENET_ReceiveIRQHandler(ENET_Type *base, enet_handle_t *handle)
2658:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2659:../drivers/fsl_enet.c **** {
  84              		.loc 1 2659 0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              	.LVL4:
  89 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  90              		.cfi_def_cfa_offset 24
  91              		.cfi_offset 3, -24
  92              		.cfi_offset 4, -20
  93              		.cfi_offset 5, -16
  94              		.cfi_offset 6, -12
  95              		.cfi_offset 7, -8
  96              		.cfi_offset 14, -4
  97              		.loc 1 2659 0
  98 0002 0446     		mov	r4, r0
  99 0004 0D46     		mov	r5, r1
2660:../drivers/fsl_enet.c ****     assert(handle);
2661:../drivers/fsl_enet.c ****     uint32_t mask = kENET_RxFrameInterrupt | kENET_RxBufferInterrupt;
2662:../drivers/fsl_enet.c **** 
2663:../drivers/fsl_enet.c **** /* Check if the receive interrupt happen. */
2664:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2665:../drivers/fsl_enet.c ****     switch (ringId)
2666:../drivers/fsl_enet.c ****     {
2667:../drivers/fsl_enet.c ****         case kENET_Ring1:
2668:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame1Interrupt | kENET_RxBuffer1Interrupt);
2669:../drivers/fsl_enet.c ****             break;
2670:../drivers/fsl_enet.c ****         case kENET_Ring2:
2671:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame2Interrupt | kENET_RxBuffer2Interrupt);
2672:../drivers/fsl_enet.c ****             break;
2673:../drivers/fsl_enet.c ****         default:
2674:../drivers/fsl_enet.c ****             break;
2675:../drivers/fsl_enet.c ****     }
2676:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2677:../drivers/fsl_enet.c **** 
2678:../drivers/fsl_enet.c ****     while (mask & base->EIR)
2679:../drivers/fsl_enet.c ****     {
2680:../drivers/fsl_enet.c ****         /* Clear the transmit interrupt event. */
2681:../drivers/fsl_enet.c ****         base->EIR = mask;
 100              		.loc 1 2681 0
 101 0006 4FF04077 		mov	r7, #50331648
 102              	.LVL5:
 103              	.L9:
2678:../drivers/fsl_enet.c ****     {
 104              		.loc 1 2678 0
 105 000a 6368     		ldr	r3, [r4, #4]
 106 000c 13F0407F 		tst	r3, #50331648
 107 0010 00D1     		bne	.L10
2682:../drivers/fsl_enet.c **** 
2683:../drivers/fsl_enet.c ****         /* Callback function. */
2684:../drivers/fsl_enet.c ****         if (handle->callback)
2685:../drivers/fsl_enet.c ****         {
2686:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2687:../drivers/fsl_enet.c ****             handle->callback(base, handle, ringId, kENET_RxEvent, handle->userData);
2688:../drivers/fsl_enet.c **** #else
2689:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_RxEvent, handle->userData);
2690:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2691:../drivers/fsl_enet.c ****         }
2692:../drivers/fsl_enet.c ****     }
2693:../drivers/fsl_enet.c **** }
 108              		.loc 1 2693 0
 109 0012 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 110              	.LVL6:
 111              	.L10:
2684:../drivers/fsl_enet.c ****         {
 112              		.loc 1 2684 0
 113 0014 EE69     		ldr	r6, [r5, #28]
2681:../drivers/fsl_enet.c **** 
 114              		.loc 1 2681 0
 115 0016 6760     		str	r7, [r4, #4]
2684:../drivers/fsl_enet.c ****         {
 116              		.loc 1 2684 0
 117 0018 002E     		cmp	r6, #0
 118 001a F6D0     		beq	.L9
2689:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 119              		.loc 1 2689 0
 120 001c 2B6A     		ldr	r3, [r5, #32]
 121 001e 0022     		movs	r2, #0
 122 0020 2946     		mov	r1, r5
 123 0022 2046     		mov	r0, r4
 124 0024 B047     		blx	r6
 125              	.LVL7:
 126 0026 F0E7     		b	.L9
 127              		.cfi_endproc
 128              	.LFE181:
 130              		.section	.text.ENET_ErrorIRQHandler,"ax",%progbits
 131              		.align	1
 132              		.global	ENET_ErrorIRQHandler
 133              		.syntax unified
 134              		.thumb
 135              		.thumb_func
 136              		.fpu fpv4-sp-d16
 138              	ENET_ErrorIRQHandler:
 139              	.LFB182:
2694:../drivers/fsl_enet.c **** 
2695:../drivers/fsl_enet.c **** void ENET_ErrorIRQHandler(ENET_Type *base, enet_handle_t *handle)
2696:../drivers/fsl_enet.c **** {
 140              		.loc 1 2696 0
 141              		.cfi_startproc
 142              		@ args = 0, pretend = 0, frame = 0
 143              		@ frame_needed = 0, uses_anonymous_args = 0
 144              	.LVL8:
 145 0000 38B5     		push	{r3, r4, r5, lr}
 146              		.cfi_def_cfa_offset 16
 147              		.cfi_offset 3, -16
 148              		.cfi_offset 4, -12
 149              		.cfi_offset 5, -8
 150              		.cfi_offset 14, -4
2697:../drivers/fsl_enet.c ****     assert(handle);
2698:../drivers/fsl_enet.c **** 
2699:../drivers/fsl_enet.c ****     uint32_t errMask = kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_Pa
2700:../drivers/fsl_enet.c ****                        kENET_LateCollisionInterrupt | kENET_RetryLimitInterrupt | kENET_UnderrunInt
2701:../drivers/fsl_enet.c **** 
2702:../drivers/fsl_enet.c ****     /* Check if the error interrupt happen. */
2703:../drivers/fsl_enet.c ****     if (kENET_WakeupInterrupt & base->EIR)
 151              		.loc 1 2703 0
 152 0002 4468     		ldr	r4, [r0, #4]
 153 0004 14F4003F 		tst	r4, #131072
 154 0008 CC69     		ldr	r4, [r1, #28]
 155 000a 0DD0     		beq	.L14
2704:../drivers/fsl_enet.c ****     {
2705:../drivers/fsl_enet.c ****         /* Clear the wakeup interrupt. */
2706:../drivers/fsl_enet.c ****         base->EIR = kENET_WakeupInterrupt;
 156              		.loc 1 2706 0
 157 000c 4FF40035 		mov	r5, #131072
 158 0010 4560     		str	r5, [r0, #4]
 159              	.LVL9:
 160              	.LBB42:
 161              	.LBB43:
 162              		.file 2 "../drivers/fsl_enet.h"
   1:../drivers/fsl_enet.h **** /*
   2:../drivers/fsl_enet.h ****  * The Clear BSD License
   3:../drivers/fsl_enet.h ****  * Copyright (c) 2015 - 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_enet.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_enet.h ****  * All rights reserved.
   6:../drivers/fsl_enet.h ****  *
   7:../drivers/fsl_enet.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_enet.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_enet.h ****  * that the following conditions are met:
  10:../drivers/fsl_enet.h ****  *
  11:../drivers/fsl_enet.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_enet.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_enet.h ****  *
  14:../drivers/fsl_enet.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_enet.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_enet.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_enet.h ****  *
  18:../drivers/fsl_enet.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_enet.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_enet.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_enet.h ****  *
  22:../drivers/fsl_enet.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_enet.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_enet.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_enet.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_enet.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_enet.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_enet.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_enet.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_enet.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_enet.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_enet.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_enet.h ****  */
  34:../drivers/fsl_enet.h **** #ifndef _FSL_ENET_H_
  35:../drivers/fsl_enet.h **** #define _FSL_ENET_H_
  36:../drivers/fsl_enet.h **** 
  37:../drivers/fsl_enet.h **** #include "fsl_common.h"
  38:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
  39:../drivers/fsl_enet.h **** #include "fsl_memory.h"
  40:../drivers/fsl_enet.h **** #endif
  41:../drivers/fsl_enet.h **** /*!
  42:../drivers/fsl_enet.h ****  * @addtogroup enet
  43:../drivers/fsl_enet.h ****  * @{
  44:../drivers/fsl_enet.h ****  */
  45:../drivers/fsl_enet.h **** 
  46:../drivers/fsl_enet.h **** /*******************************************************************************
  47:../drivers/fsl_enet.h ****  * Definitions
  48:../drivers/fsl_enet.h ****  ******************************************************************************/
  49:../drivers/fsl_enet.h **** 
  50:../drivers/fsl_enet.h **** /*! @name Driver version */
  51:../drivers/fsl_enet.h **** /*@{*/
  52:../drivers/fsl_enet.h **** /*! @brief Defines the driver version. */
  53:../drivers/fsl_enet.h **** #define FSL_ENET_DRIVER_VERSION (MAKE_VERSION(2, 2, 2)) /*!< Version 2.2.2. */
  54:../drivers/fsl_enet.h **** /*@}*/
  55:../drivers/fsl_enet.h **** 
  56:../drivers/fsl_enet.h **** /*! @name ENET DESCRIPTOR QUEUE */
  57:../drivers/fsl_enet.h **** /*@{*/
  58:../drivers/fsl_enet.h **** /*! @brief Defines the queue number. */
  59:../drivers/fsl_enet.h **** #ifndef FSL_FEATURE_ENET_QUEUE
  60:../drivers/fsl_enet.h **** #define FSL_FEATURE_ENET_QUEUE 1 /* Singal queue for previous IP. */
  61:../drivers/fsl_enet.h **** #endif
  62:../drivers/fsl_enet.h **** /*@}*/
  63:../drivers/fsl_enet.h **** 
  64:../drivers/fsl_enet.h **** /*! @name Control and status region bit masks of the receive buffer descriptor. */
  65:../drivers/fsl_enet.h **** /*@{*/
  66:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK 0x8000U       /*!< Empty bit mask. */
  67:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_SOFTOWNER1_MASK 0x4000U  /*!< Software owner one mask. */
  68:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_WRAP_MASK 0x2000U        /*!< Next buffer descriptor is the start ad
  69:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_SOFTOWNER2_Mask 0x1000U  /*!< Software owner two mask. */
  70:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_LAST_MASK 0x0800U        /*!< Last BD of the frame mask. */
  71:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_MISS_MASK 0x0100U        /*!< Received because of the promiscuous mo
  72:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_BROADCAST_MASK 0x0080U   /*!< Broadcast packet mask. */
  73:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_MULTICAST_MASK 0x0040U   /*!< Multicast packet mask. */
  74:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK 0x0020U /*!< Length violation mask. */
  75:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK 0x0010U     /*!< Non-octet aligned frame mask. */
  76:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_CRC_MASK 0x0004U         /*!< CRC error mask. */
  77:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK 0x0002U     /*!< FIFO overrun mask. */
  78:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK 0x0001U       /*!< Frame is truncated mask. */
  79:../drivers/fsl_enet.h **** /*@}*/
  80:../drivers/fsl_enet.h **** 
  81:../drivers/fsl_enet.h **** /*! @name Control and status bit masks of the transmit buffer descriptor. */
  82:../drivers/fsl_enet.h **** /*@{*/
  83:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_READY_MASK 0x8000U       /*!< Ready bit mask. */
  84:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_SOFTOWENER1_MASK 0x4000U /*!< Software owner one mask. */
  85:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_WRAP_MASK 0x2000U        /*!< Wrap buffer descriptor mask. */
  86:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_SOFTOWENER2_MASK 0x1000U /*!< Software owner two mask. */
  87:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_LAST_MASK 0x0800U        /*!< Last BD of the frame mask. */
  88:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_TRANMITCRC_MASK 0x0400U  /*!< Transmit CRC mask. */
  89:../drivers/fsl_enet.h **** /*@}*/
  90:../drivers/fsl_enet.h **** 
  91:../drivers/fsl_enet.h **** /* Extended control regions for enhanced buffer descriptors. */
  92:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
  93:../drivers/fsl_enet.h **** /*! @name First extended control region bit masks of the receive buffer descriptor. */
  94:../drivers/fsl_enet.h **** /*@{*/
  95:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_IPV4_MASK 0x0001U             /*!< Ipv4 frame mask. */
  96:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_IPV6_MASK 0x0002U             /*!< Ipv6 frame mask. */
  97:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_VLAN_MASK 0x0004U             /*!< VLAN frame mask. */
  98:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_PROTOCOLCHECKSUM_MASK 0x0010U /*!< Protocol checksum error mask. */
  99:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_IPHEADCHECKSUM_MASK 0x0020U   /*!< IP header checksum error mask. */
 100:../drivers/fsl_enet.h **** /*@}*/
 101:../drivers/fsl_enet.h **** 
 102:../drivers/fsl_enet.h **** /*! @name Second extended control region bit masks of the receive buffer descriptor. */
 103:../drivers/fsl_enet.h **** /*@{*/
 104:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_INTERRUPT_MASK 0x0080U /*!< BD interrupt mask. */
 105:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_UNICAST_MASK 0x0100U   /*!< Unicast frame mask. */
 106:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_COLLISION_MASK 0x0200U /*!< BD collision mask. */
 107:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK 0x0400U    /*!< PHY error mask. */
 108:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_MACERR_MASK 0x8000U    /*!< Mac error mask. */
 109:../drivers/fsl_enet.h **** /*@}*/
 110:../drivers/fsl_enet.h **** 
 111:../drivers/fsl_enet.h **** /*! @name First extended control region bit masks of the transmit buffer descriptor. */
 112:../drivers/fsl_enet.h **** /*@{*/
 113:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_ERR_MASK 0x8000U              /*!< Transmit error mask. */
 114:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_UNDERFLOWERR_MASK 0x2000U     /*!< Underflow error mask. */
 115:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_EXCCOLLISIONERR_MASK 0x1000U  /*!< Excess collision error mask. */
 116:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_FRAMEERR_MASK 0x0800U         /*!< Frame error mask. */
 117:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_LATECOLLISIONERR_MASK 0x0400U /*!< Late collision error mask. */
 118:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_OVERFLOWERR_MASK 0x0200U      /*!< Overflow error mask. */
 119:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_TIMESTAMPERR_MASK 0x0100U     /*!< Timestamp error mask. */
 120:../drivers/fsl_enet.h **** /*@}*/
 121:../drivers/fsl_enet.h **** 
 122:../drivers/fsl_enet.h **** /*! @name Second extended control region bit masks of the transmit buffer descriptor. */
 123:../drivers/fsl_enet.h **** /*@{*/
 124:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_INTERRUPT_MASK 0x4000U /*!< Interrupt mask. */
 125:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK 0x2000U /*!< Timestamp flag mask. */
 126:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 127:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_USETXLAUNCHTIME_MASK 0x0100U /*!< Use the transmit launch time. */
 128:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_FRAMETYPE_MASK 0x00F0U       /*!< Frame type mask. */
 129:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_FRAMETYPE_SHIFT 4U           /*!< Frame type shift. */
 130:../drivers/fsl_enet.h **** #define ENET_BD_FTYPE(n) ((n << ENET_BUFFDESCRIPTOR_TX_FRAMETYPE_SHIFT) & ENET_BUFFDESCRIPTOR_TX_FR
 131:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 132:../drivers/fsl_enet.h **** /*@}*/
 133:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 134:../drivers/fsl_enet.h **** 
 135:../drivers/fsl_enet.h **** /*! @brief Defines the receive error status flag mask. */
 136:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_ERR_MASK                                        \
 137:../drivers/fsl_enet.h ****     (ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK | ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK | \
 138:../drivers/fsl_enet.h ****      ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK | ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK | ENET_BUFFDESCR
 139:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 140:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_EXT_ERR_MASK \
 141:../drivers/fsl_enet.h ****     (ENET_BUFFDESCRIPTOR_RX_MACERR_MASK | ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK | ENET_BUFFDESCRIPTOR_
 142:../drivers/fsl_enet.h **** #endif
 143:../drivers/fsl_enet.h **** 
 144:../drivers/fsl_enet.h **** /*! @name Defines some Ethernet parameters. */
 145:../drivers/fsl_enet.h **** /*@{*/
 146:../drivers/fsl_enet.h **** #define ENET_FRAME_MAX_FRAMELEN 1518U /*!< Default maximum Ethernet frame size. */
 147:../drivers/fsl_enet.h **** 
 148:../drivers/fsl_enet.h **** #define ENET_FIFO_MIN_RX_FULL 5U    /*!< ENET minimum receive FIFO full. */
 149:../drivers/fsl_enet.h **** #define ENET_RX_MIN_BUFFERSIZE 256U /*!< ENET minimum buffer size. */
 150:../drivers/fsl_enet.h **** #define ENET_PHY_MAXADDRESS (ENET_MMFR_PA_MASK >> ENET_MMFR_PA_SHIFT)
 151:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 152:../drivers/fsl_enet.h **** #define ENET_TX_INTERRUPT                                                                          
 153:../drivers/fsl_enet.h ****     (kENET_TxFrameInterrupt | kENET_TxBufferInterrupt | kENET_TxFrame1Interrupt | kENET_TxBuffer1In
 154:../drivers/fsl_enet.h ****      kENET_TxFrame2Interrupt | kENET_TxBuffer2Interrupt)
 155:../drivers/fsl_enet.h **** #define ENET_RX_INTERRUPT                                                                          
 156:../drivers/fsl_enet.h ****     (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt | kENET_RxFrame1Interrupt | kENET_RxBuffer1In
 157:../drivers/fsl_enet.h ****      kENET_RxFrame2Interrupt | kENET_RxBuffer2Interrupt)
 158:../drivers/fsl_enet.h **** #else
 159:../drivers/fsl_enet.h **** #define ENET_TX_INTERRUPT (kENET_TxFrameInterrupt | kENET_TxBufferInterrupt)
 160:../drivers/fsl_enet.h **** #define ENET_RX_INTERRUPT (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt)
 161:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 162:../drivers/fsl_enet.h **** #define ENET_TS_INTERRUPT (kENET_TsTimerInterrupt | kENET_TsAvailInterrupt)
 163:../drivers/fsl_enet.h **** #define ENET_ERR_INTERRUPT                                                                         
 164:../drivers/fsl_enet.h ****     (kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_LateCollisionInterru
 165:../drivers/fsl_enet.h ****      kENET_RetryLimitInterrupt | kENET_UnderrunInterrupt | kENET_PayloadRxInterrupt)
 166:../drivers/fsl_enet.h **** #define ENET_ERR_INTERRUPT                                                                         
 167:../drivers/fsl_enet.h ****     (kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_LateCollisionInterru
 168:../drivers/fsl_enet.h ****      kENET_RetryLimitInterrupt | kENET_UnderrunInterrupt | kENET_PayloadRxInterrupt)
 169:../drivers/fsl_enet.h **** /*@}*/
 170:../drivers/fsl_enet.h **** 
 171:../drivers/fsl_enet.h **** /*! @brief Defines the status return codes for transaction. */
 172:../drivers/fsl_enet.h **** enum _enet_status
 173:../drivers/fsl_enet.h **** {
 174:../drivers/fsl_enet.h ****     kStatus_ENET_RxFrameError = MAKE_STATUS(kStatusGroup_ENET, 0U),   /*!< A frame received but dat
 175:../drivers/fsl_enet.h ****     kStatus_ENET_RxFrameFail = MAKE_STATUS(kStatusGroup_ENET, 1U),    /*!< Failed to receive a fram
 176:../drivers/fsl_enet.h ****     kStatus_ENET_RxFrameEmpty = MAKE_STATUS(kStatusGroup_ENET, 2U),   /*!< No frame arrive. */
 177:../drivers/fsl_enet.h ****     kStatus_ENET_TxFrameOverLen = MAKE_STATUS(kStatusGroup_ENET, 3U), /*!< Tx frame over length. */
 178:../drivers/fsl_enet.h ****     kStatus_ENET_TxFrameBusy = MAKE_STATUS(kStatusGroup_ENET, 4U),    /*!< Tx buffer descriptors ar
 179:../drivers/fsl_enet.h ****     kStatus_ENET_TxFrameFail = MAKE_STATUS(kStatusGroup_ENET, 5U)     /*!< Transmit frame fail. */
 180:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 181:../drivers/fsl_enet.h ****     ,
 182:../drivers/fsl_enet.h ****     kStatus_ENET_PtpTsRingFull = MAKE_STATUS(kStatusGroup_ENET, 6U), /*!< Timestamp ring full. */
 183:../drivers/fsl_enet.h ****     kStatus_ENET_PtpTsRingEmpty = MAKE_STATUS(kStatusGroup_ENET, 7U) /*!< Timestamp ring empty. */
 184:../drivers/fsl_enet.h **** #endif                                                               /* ENET_ENHANCEDBUFFERDESCRIPT
 185:../drivers/fsl_enet.h **** };
 186:../drivers/fsl_enet.h **** 
 187:../drivers/fsl_enet.h **** /*! @brief Defines the MII/RMII/RGMII mode for data interface between the MAC and the PHY. */
 188:../drivers/fsl_enet.h **** typedef enum _enet_mii_mode
 189:../drivers/fsl_enet.h **** {
 190:../drivers/fsl_enet.h ****     kENET_MiiMode = 0U,  /*!< MII mode for data interface. */
 191:../drivers/fsl_enet.h ****     kENET_RmiiMode = 1U, /*!< RMII mode for data interface. */
 192:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 193:../drivers/fsl_enet.h ****     kENET_RgmiiMode = 2U /*!< RGMII mode for data interface.  */
 194:../drivers/fsl_enet.h **** #endif                   /* FSL_FEATURE_ENET_HAS_AVB */
 195:../drivers/fsl_enet.h **** } enet_mii_mode_t;
 196:../drivers/fsl_enet.h **** 
 197:../drivers/fsl_enet.h **** /*! @brief Defines the 10/100/1000 Mbps speed for the MII data interface.
 198:../drivers/fsl_enet.h ****  *
 199:../drivers/fsl_enet.h ****  * Notice: "kENET_MiiSpeed1000M" only supported when mii mode is "kENET_RgmiiMode".
 200:../drivers/fsl_enet.h ****  */
 201:../drivers/fsl_enet.h **** typedef enum _enet_mii_speed
 202:../drivers/fsl_enet.h **** {
 203:../drivers/fsl_enet.h ****     kENET_MiiSpeed10M = 0U,  /*!< Speed 10 Mbps. */
 204:../drivers/fsl_enet.h ****     kENET_MiiSpeed100M = 1U, /*!< Speed 100 Mbps. */
 205:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 206:../drivers/fsl_enet.h ****     kENET_MiiSpeed1000M = 2U /*!< Speed 1000M bps. */
 207:../drivers/fsl_enet.h **** #endif                       /* FSL_FEATURE_ENET_HAS_AVB */
 208:../drivers/fsl_enet.h **** } enet_mii_speed_t;
 209:../drivers/fsl_enet.h **** 
 210:../drivers/fsl_enet.h **** /*! @brief Defines the half or full duplex for the MII data interface. */
 211:../drivers/fsl_enet.h **** typedef enum _enet_mii_duplex
 212:../drivers/fsl_enet.h **** {
 213:../drivers/fsl_enet.h ****     kENET_MiiHalfDuplex = 0U, /*!< Half duplex mode. */
 214:../drivers/fsl_enet.h ****     kENET_MiiFullDuplex       /*!< Full duplex mode. */
 215:../drivers/fsl_enet.h **** } enet_mii_duplex_t;
 216:../drivers/fsl_enet.h **** 
 217:../drivers/fsl_enet.h **** /*! @brief Define the MII opcode for normal MDIO_CLAUSES_22 Frame. */
 218:../drivers/fsl_enet.h **** typedef enum _enet_mii_write
 219:../drivers/fsl_enet.h **** {
 220:../drivers/fsl_enet.h ****     kENET_MiiWriteNoCompliant = 0U, /*!< Write frame operation, but not MII-compliant. */
 221:../drivers/fsl_enet.h ****     kENET_MiiWriteValidFrame        /*!< Write frame operation for a valid MII management frame. */
 222:../drivers/fsl_enet.h **** } enet_mii_write_t;
 223:../drivers/fsl_enet.h **** 
 224:../drivers/fsl_enet.h **** /*! @brief Defines the read operation for the MII management frame. */
 225:../drivers/fsl_enet.h **** typedef enum _enet_mii_read
 226:../drivers/fsl_enet.h **** {
 227:../drivers/fsl_enet.h ****     kENET_MiiReadValidFrame = 2U, /*!< Read frame operation for a valid MII management frame. */
 228:../drivers/fsl_enet.h ****     kENET_MiiReadNoCompliant = 3U /*!< Read frame operation, but not MII-compliant. */
 229:../drivers/fsl_enet.h **** } enet_mii_read_t;
 230:../drivers/fsl_enet.h **** 
 231:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
 232:../drivers/fsl_enet.h **** /*! @brief Define the MII opcode for extended MDIO_CLAUSES_45 Frame. */
 233:../drivers/fsl_enet.h **** typedef enum _enet_mii_extend_opcode
 234:../drivers/fsl_enet.h **** {
 235:../drivers/fsl_enet.h ****     kENET_MiiAddrWrite_C45 = 0U,  /*!< Address Write operation. */
 236:../drivers/fsl_enet.h ****     kENET_MiiWriteFrame_C45 = 1U, /*!< Write frame operation for a valid MII management frame. */
 237:../drivers/fsl_enet.h ****     kENET_MiiReadFrame_C45 = 3U   /*!< Read frame operation for a valid MII management frame. */
 238:../drivers/fsl_enet.h **** } enet_mii_extend_opcode;
 239:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */
 240:../drivers/fsl_enet.h **** 
 241:../drivers/fsl_enet.h **** /*! @brief Defines a special configuration for ENET MAC controller.
 242:../drivers/fsl_enet.h ****  *
 243:../drivers/fsl_enet.h ****  * These control flags are provided for special user requirements.
 244:../drivers/fsl_enet.h ****  * Normally, these control flags are unused for ENET initialization.
 245:../drivers/fsl_enet.h ****  * For special requirements, set the flags to
 246:../drivers/fsl_enet.h ****  * macSpecialConfig in the enet_config_t.
 247:../drivers/fsl_enet.h ****  * The kENET_ControlStoreAndFwdDisable is used to disable the FIFO store
 248:../drivers/fsl_enet.h ****  * and forward. FIFO store and forward means that the FIFO read/send is started
 249:../drivers/fsl_enet.h ****  * when a complete frame is stored in TX/RX FIFO. If this flag is set,
 250:../drivers/fsl_enet.h ****  * configure rxFifoFullThreshold and txFifoWatermark
 251:../drivers/fsl_enet.h ****  * in the enet_config_t.
 252:../drivers/fsl_enet.h ****  */
 253:../drivers/fsl_enet.h **** typedef enum _enet_special_control_flag
 254:../drivers/fsl_enet.h **** {
 255:../drivers/fsl_enet.h ****     kENET_ControlFlowControlEnable = 0x0001U,       /*!< Enable ENET flow control: pause frame. */
 256:../drivers/fsl_enet.h ****     kENET_ControlRxPayloadCheckEnable = 0x0002U,    /*!< Enable ENET receive payload length check. 
 257:../drivers/fsl_enet.h ****     kENET_ControlRxPadRemoveEnable = 0x0004U,       /*!< Padding is removed from received frames. *
 258:../drivers/fsl_enet.h ****     kENET_ControlRxBroadCastRejectEnable = 0x0008U, /*!< Enable broadcast frame reject. */
 259:../drivers/fsl_enet.h ****     kENET_ControlMacAddrInsert = 0x0010U,           /*!< Enable MAC address insert. */
 260:../drivers/fsl_enet.h ****     kENET_ControlStoreAndFwdDisable = 0x0020U,      /*!< Enable FIFO store and forward. */
 261:../drivers/fsl_enet.h ****     kENET_ControlSMIPreambleDisable = 0x0040U,      /*!< Enable SMI preamble. */
 262:../drivers/fsl_enet.h ****     kENET_ControlPromiscuousEnable = 0x0080U,       /*!< Enable promiscuous mode. */
 263:../drivers/fsl_enet.h ****     kENET_ControlMIILoopEnable = 0x0100U,           /*!< Enable ENET MII loop back. */
 264:../drivers/fsl_enet.h ****     kENET_ControlVLANTagEnable = 0x0200U,           /*!< Enable normal VLAN (single vlan tag). */
 265:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 266:../drivers/fsl_enet.h ****     kENET_ControlSVLANEnable = 0x0400U,     /*!< Enable S-VLAN. */
 267:../drivers/fsl_enet.h ****     kENET_ControlVLANUseSecondTag = 0x0800U /*!< Enable extracting the second vlan tag for further 
 268:../drivers/fsl_enet.h **** #endif                                      /* FSL_FEATURE_ENET_HAS_AVB */
 269:../drivers/fsl_enet.h **** } enet_special_control_flag_t;
 270:../drivers/fsl_enet.h **** 
 271:../drivers/fsl_enet.h **** /*! @brief List of interrupts supported by the peripheral. This
 272:../drivers/fsl_enet.h ****  * enumeration uses one-bot encoding to allow a logical OR of multiple
 273:../drivers/fsl_enet.h ****  * members. Members usually map to interrupt enable bits in one or more
 274:../drivers/fsl_enet.h ****  * peripheral registers.
 275:../drivers/fsl_enet.h ****  */
 276:../drivers/fsl_enet.h **** typedef enum _enet_interrupt_enable
 277:../drivers/fsl_enet.h **** {
 278:../drivers/fsl_enet.h ****     kENET_BabrInterrupt = ENET_EIR_BABR_MASK,        /*!< Babbling receive error interrupt source *
 279:../drivers/fsl_enet.h ****     kENET_BabtInterrupt = ENET_EIR_BABT_MASK,        /*!< Babbling transmit error interrupt source 
 280:../drivers/fsl_enet.h ****     kENET_GraceStopInterrupt = ENET_EIR_GRA_MASK,    /*!< Graceful stop complete interrupt source *
 281:../drivers/fsl_enet.h ****     kENET_TxFrameInterrupt = ENET_EIR_TXF_MASK,      /*!< TX FRAME interrupt source */
 282:../drivers/fsl_enet.h ****     kENET_TxBufferInterrupt = ENET_EIR_TXB_MASK,     /*!< TX BUFFER interrupt source */
 283:../drivers/fsl_enet.h ****     kENET_RxFrameInterrupt = ENET_EIR_RXF_MASK,      /*!< RX FRAME interrupt source */
 284:../drivers/fsl_enet.h ****     kENET_RxBufferInterrupt = ENET_EIR_RXB_MASK,     /*!< RX BUFFER interrupt source */
 285:../drivers/fsl_enet.h ****     kENET_MiiInterrupt = ENET_EIR_MII_MASK,          /*!< MII interrupt source */
 286:../drivers/fsl_enet.h ****     kENET_EBusERInterrupt = ENET_EIR_EBERR_MASK,     /*!< Ethernet bus error interrupt source */
 287:../drivers/fsl_enet.h ****     kENET_LateCollisionInterrupt = ENET_EIR_LC_MASK, /*!< Late collision interrupt source */
 288:../drivers/fsl_enet.h ****     kENET_RetryLimitInterrupt = ENET_EIR_RL_MASK,    /*!< Collision Retry Limit interrupt source */
 289:../drivers/fsl_enet.h ****     kENET_UnderrunInterrupt = ENET_EIR_UN_MASK,      /*!< Transmit FIFO underrun interrupt source *
 290:../drivers/fsl_enet.h ****     kENET_PayloadRxInterrupt = ENET_EIR_PLR_MASK,    /*!< Payload Receive error interrupt source */
 291:../drivers/fsl_enet.h ****     kENET_WakeupInterrupt = ENET_EIR_WAKEUP_MASK,    /*!< WAKEUP interrupt source */
 292:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 293:../drivers/fsl_enet.h ****     kENET_RxFlush2Interrupt = ENET_EIR_RXFLUSH_2_MASK, /*!< Rx DMA ring2 flush indication. */
 294:../drivers/fsl_enet.h ****     kENET_RxFlush1Interrupt = ENET_EIR_RXFLUSH_1_MASK, /*!< Rx DMA ring1 flush indication. */
 295:../drivers/fsl_enet.h ****     kENET_RxFlush0Interrupt = ENET_EIR_RXFLUSH_0_MASK, /*!< RX DMA ring0 flush indication. */
 296:../drivers/fsl_enet.h ****     kENET_TxFrame2Interrupt = ENET_EIR_TXF2_MASK,      /*!< Tx frame interrupt for Tx ring/class 2.
 297:../drivers/fsl_enet.h ****     kENET_TxBuffer2Interrupt = ENET_EIR_TXB2_MASK,     /*!< Tx buffer interrupt for Tx ring/class 2
 298:../drivers/fsl_enet.h ****     kENET_RxFrame2Interrupt = ENET_EIR_RXF2_MASK,      /*!< Rx frame interrupt for Rx ring/class 2.
 299:../drivers/fsl_enet.h ****     kENET_RxBuffer2Interrupt = ENET_EIR_RXB2_MASK,     /*!< Rx buffer interrupt for Rx ring/class 2
 300:../drivers/fsl_enet.h ****     kENET_TxFrame1Interrupt = ENET_EIR_TXF1_MASK,      /*!< Tx frame interrupt for Tx ring/class 1.
 301:../drivers/fsl_enet.h ****     kENET_TxBuffer1Interrupt = ENET_EIR_TXB1_MASK,     /*!< Tx buffer interrupt for Tx ring/class 1
 302:../drivers/fsl_enet.h ****     kENET_RxFrame1Interrupt = ENET_EIR_RXF1_MASK,      /*!< Rx frame interrupt for Rx ring/class 1.
 303:../drivers/fsl_enet.h ****     kENET_RxBuffer1Interrupt = ENET_EIR_RXB1_MASK,     /*!< Rx buffer interrupt for Rx ring/class 1
 304:../drivers/fsl_enet.h **** #endif                                                 /* FSL_FEATURE_ENET_QUEUE > 1 */
 305:../drivers/fsl_enet.h ****     kENET_TsAvailInterrupt = ENET_EIR_TS_AVAIL_MASK,   /*!< TS AVAIL interrupt source for PTP */
 306:../drivers/fsl_enet.h ****     kENET_TsTimerInterrupt = ENET_EIR_TS_TIMER_MASK    /*!< TS WRAP interrupt source for PTP */
 307:../drivers/fsl_enet.h **** } enet_interrupt_enable_t;
 308:../drivers/fsl_enet.h **** 
 309:../drivers/fsl_enet.h **** /*! @brief Defines the common interrupt event for callback use. */
 310:../drivers/fsl_enet.h **** typedef enum _enet_event
 311:../drivers/fsl_enet.h **** {
 312:../drivers/fsl_enet.h ****     kENET_RxEvent,            /*!< Receive event. */
 313:../drivers/fsl_enet.h ****     kENET_TxEvent,            /*!< Transmit event. */
 314:../drivers/fsl_enet.h ****     kENET_ErrEvent,           /*!< Error event: BABR/BABT/EBERR/LC/RL/UN/PLR . */
 315:../drivers/fsl_enet.h ****     kENET_WakeUpEvent,        /*!< Wake up from sleep mode event. */
 316:../drivers/fsl_enet.h ****     kENET_TimeStampEvent,     /*!< Time stamp event. */
 317:../drivers/fsl_enet.h ****     kENET_TimeStampAvailEvent /*!< Time stamp available event.*/
 318:../drivers/fsl_enet.h **** } enet_event_t;
 319:../drivers/fsl_enet.h **** 
 320:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 321:../drivers/fsl_enet.h **** /*! @brief Defines certain idle slope for bandwidth fraction. */
 322:../drivers/fsl_enet.h **** typedef enum _enet_idle_slope
 323:../drivers/fsl_enet.h **** {
 324:../drivers/fsl_enet.h ****     kENET_IdleSlope1 = 1U,       /*!< The bandwidth fraction is about 0.002. */
 325:../drivers/fsl_enet.h ****     kENET_IdleSlope2 = 2U,       /*!< The bandwidth fraction is about 0.003. */
 326:../drivers/fsl_enet.h ****     kENET_IdleSlope4 = 4U,       /*!< The bandwidth fraction is about 0.008. */
 327:../drivers/fsl_enet.h ****     kENET_IdleSlope8 = 8U,       /*!< The bandwidth fraction is about 0.02. */
 328:../drivers/fsl_enet.h ****     kENET_IdleSlope16 = 16U,     /*!< The bandwidth fraction is about 0.03. */
 329:../drivers/fsl_enet.h ****     kENET_IdleSlope32 = 32U,     /*!< The bandwidth fraction is about 0.06. */
 330:../drivers/fsl_enet.h ****     kENET_IdleSlope64 = 64U,     /*!< The bandwidth fraction is about 0.11. */
 331:../drivers/fsl_enet.h ****     kENET_IdleSlope128 = 128U,   /*!< The bandwidth fraction is about 0.20. */
 332:../drivers/fsl_enet.h ****     kENET_IdleSlope256 = 256U,   /*!< The bandwidth fraction is about 0.33. */
 333:../drivers/fsl_enet.h ****     kENET_IdleSlope384 = 384U,   /*!< The bandwidth fraction is about 0.43. */
 334:../drivers/fsl_enet.h ****     kENET_IdleSlope512 = 512U,   /*!< The bandwidth fraction is about 0.50. */
 335:../drivers/fsl_enet.h ****     kENET_IdleSlope640 = 640U,   /*!< The bandwidth fraction is about 0.56. */
 336:../drivers/fsl_enet.h ****     kENET_IdleSlope768 = 768U,   /*!< The bandwidth fraction is about 0.60. */
 337:../drivers/fsl_enet.h ****     kENET_IdleSlope896 = 896U,   /*!< The bandwidth fraction is about 0.64. */
 338:../drivers/fsl_enet.h ****     kENET_IdleSlope1024 = 1024U, /*!< The bandwidth fraction is about 0.67. */
 339:../drivers/fsl_enet.h ****     kENET_IdleSlope1152 = 1152U, /*!< The bandwidth fraction is about 0.69. */
 340:../drivers/fsl_enet.h ****     kENET_IdleSlope1280 = 1280U, /*!< The bandwidth fraction is about 0.71. */
 341:../drivers/fsl_enet.h ****     kENET_IdleSlope1408 = 1408U, /*!< The bandwidth fraction is about 0.73. */
 342:../drivers/fsl_enet.h ****     kENET_IdleSlope1536 = 1536U  /*!< The bandwidth fraction is about 0.75. */
 343:../drivers/fsl_enet.h **** } enet_idle_slope_t;
 344:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 345:../drivers/fsl_enet.h **** 
 346:../drivers/fsl_enet.h **** /*! @brief Defines the transmit accelerator configuration. */
 347:../drivers/fsl_enet.h **** typedef enum _enet_tx_accelerator
 348:../drivers/fsl_enet.h **** {
 349:../drivers/fsl_enet.h ****     kENET_TxAccelIsShift16Enabled = ENET_TACC_SHIFT16_MASK, /*!< Transmit FIFO shift-16. */
 350:../drivers/fsl_enet.h ****     kENET_TxAccelIpCheckEnabled = ENET_TACC_IPCHK_MASK,     /*!< Insert IP header checksum. */
 351:../drivers/fsl_enet.h ****     kENET_TxAccelProtoCheckEnabled = ENET_TACC_PROCHK_MASK  /*!< Insert protocol checksum. */
 352:../drivers/fsl_enet.h **** } enet_tx_accelerator_t;
 353:../drivers/fsl_enet.h **** 
 354:../drivers/fsl_enet.h **** /*! @brief Defines the receive accelerator configuration. */
 355:../drivers/fsl_enet.h **** typedef enum _enet_rx_accelerator
 356:../drivers/fsl_enet.h **** {
 357:../drivers/fsl_enet.h ****     kENET_RxAccelPadRemoveEnabled = ENET_RACC_PADREM_MASK,  /*!< Padding removal for short IP frame
 358:../drivers/fsl_enet.h ****     kENET_RxAccelIpCheckEnabled = ENET_RACC_IPDIS_MASK,     /*!< Discard with wrong IP header check
 359:../drivers/fsl_enet.h ****     kENET_RxAccelProtoCheckEnabled = ENET_RACC_PRODIS_MASK, /*!< Discard with wrong protocol checks
 360:../drivers/fsl_enet.h ****     kENET_RxAccelMacCheckEnabled = ENET_RACC_LINEDIS_MASK,  /*!< Discard with Mac layer errors. */
 361:../drivers/fsl_enet.h ****     kENET_RxAccelisShift16Enabled = ENET_RACC_SHIFT16_MASK  /*!< Receive FIFO shift-16. */
 362:../drivers/fsl_enet.h **** } enet_rx_accelerator_t;
 363:../drivers/fsl_enet.h **** 
 364:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 365:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP message related constant. */
 366:../drivers/fsl_enet.h **** typedef enum _enet_ptp_event_type
 367:../drivers/fsl_enet.h **** {
 368:../drivers/fsl_enet.h ****     kENET_PtpEventMsgType = 3U,  /*!< PTP event message type. */
 369:../drivers/fsl_enet.h ****     kENET_PtpSrcPortIdLen = 10U, /*!< PTP message sequence id length. */
 370:../drivers/fsl_enet.h ****     kENET_PtpEventPort = 319U,   /*!< PTP event port number. */
 371:../drivers/fsl_enet.h ****     kENET_PtpGnrlPort = 320U     /*!< PTP general port number. */
 372:../drivers/fsl_enet.h **** } enet_ptp_event_type_t;
 373:../drivers/fsl_enet.h **** 
 374:../drivers/fsl_enet.h **** /*! @brief Defines the IEEE 1588 PTP timer channel numbers. */
 375:../drivers/fsl_enet.h **** typedef enum _enet_ptp_timer_channel
 376:../drivers/fsl_enet.h **** {
 377:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel1 = 0U, /*!< IEEE 1588 PTP timer Channel 1. */
 378:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel2,      /*!< IEEE 1588 PTP timer Channel 2. */
 379:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel3,      /*!< IEEE 1588 PTP timer Channel 3. */
 380:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel4       /*!< IEEE 1588 PTP timer Channel 4. */
 381:../drivers/fsl_enet.h **** } enet_ptp_timer_channel_t;
 382:../drivers/fsl_enet.h **** 
 383:../drivers/fsl_enet.h **** /*! @brief Defines the capture or compare mode for IEEE 1588 PTP timer channels. */
 384:../drivers/fsl_enet.h **** typedef enum _enet_ptp_timer_channel_mode
 385:../drivers/fsl_enet.h **** {
 386:../drivers/fsl_enet.h ****     kENET_PtpChannelDisable = 0U,                  /*!< Disable timer channel. */
 387:../drivers/fsl_enet.h ****     kENET_PtpChannelRisingCapture = 1U,            /*!< Input capture on rising edge. */
 388:../drivers/fsl_enet.h ****     kENET_PtpChannelFallingCapture = 2U,           /*!< Input capture on falling edge. */
 389:../drivers/fsl_enet.h ****     kENET_PtpChannelBothCapture = 3U,              /*!< Input capture on both edges. */
 390:../drivers/fsl_enet.h ****     kENET_PtpChannelSoftCompare = 4U,              /*!< Output compare software only. */
 391:../drivers/fsl_enet.h ****     kENET_PtpChannelToggleCompare = 5U,            /*!< Toggle output on compare. */
 392:../drivers/fsl_enet.h ****     kENET_PtpChannelClearCompare = 6U,             /*!< Clear output on compare. */
 393:../drivers/fsl_enet.h ****     kENET_PtpChannelSetCompare = 7U,               /*!< Set output on compare. */
 394:../drivers/fsl_enet.h ****     kENET_PtpChannelClearCompareSetOverflow = 10U, /*!< Clear output on compare, set output on over
 395:../drivers/fsl_enet.h ****     kENET_PtpChannelSetCompareClearOverflow = 11U, /*!< Set output on compare, clear output on over
 396:../drivers/fsl_enet.h ****     kENET_PtpChannelPulseLowonCompare = 14U,       /*!< Pulse output low on compare for one IEEE 15
 397:../drivers/fsl_enet.h ****     kENET_PtpChannelPulseHighonCompare = 15U       /*!< Pulse output high on compare for one IEEE 1
 398:../drivers/fsl_enet.h **** } enet_ptp_timer_channel_mode_t;
 399:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 400:../drivers/fsl_enet.h **** 
 401:../drivers/fsl_enet.h **** /*! @brief Defines the receive buffer descriptor structure for the little endian system.*/
 402:../drivers/fsl_enet.h **** typedef struct _enet_rx_bd_struct
 403:../drivers/fsl_enet.h **** {
 404:../drivers/fsl_enet.h ****     uint16_t length;  /*!< Buffer descriptor data length. */
 405:../drivers/fsl_enet.h ****     uint16_t control; /*!< Buffer descriptor control and status. */
 406:../drivers/fsl_enet.h ****     uint8_t *buffer;  /*!< Data buffer pointer. */
 407:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 408:../drivers/fsl_enet.h ****     uint16_t controlExtend0;  /*!< Extend buffer descriptor control0. */
 409:../drivers/fsl_enet.h ****     uint16_t controlExtend1;  /*!< Extend buffer descriptor control1. */
 410:../drivers/fsl_enet.h ****     uint16_t payloadCheckSum; /*!< Internal payload checksum. */
 411:../drivers/fsl_enet.h ****     uint8_t headerLength;     /*!< Header length. */
 412:../drivers/fsl_enet.h ****     uint8_t protocolTyte;     /*!< Protocol type. */
 413:../drivers/fsl_enet.h ****     uint16_t reserved0;
 414:../drivers/fsl_enet.h ****     uint16_t controlExtend2; /*!< Extend buffer descriptor control2. */
 415:../drivers/fsl_enet.h ****     uint32_t timestamp;      /*!< Timestamp. */
 416:../drivers/fsl_enet.h ****     uint16_t reserved1;
 417:../drivers/fsl_enet.h ****     uint16_t reserved2;
 418:../drivers/fsl_enet.h ****     uint16_t reserved3;
 419:../drivers/fsl_enet.h ****     uint16_t reserved4;
 420:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 421:../drivers/fsl_enet.h **** } enet_rx_bd_struct_t;
 422:../drivers/fsl_enet.h **** 
 423:../drivers/fsl_enet.h **** /*! @brief Defines the enhanced transmit buffer descriptor structure for the little endian system. 
 424:../drivers/fsl_enet.h **** typedef struct _enet_tx_bd_struct
 425:../drivers/fsl_enet.h **** {
 426:../drivers/fsl_enet.h ****     uint16_t length;  /*!< Buffer descriptor data length. */
 427:../drivers/fsl_enet.h ****     uint16_t control; /*!< Buffer descriptor control and status. */
 428:../drivers/fsl_enet.h ****     uint8_t *buffer;  /*!< Data buffer pointer. */
 429:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 430:../drivers/fsl_enet.h ****     uint16_t controlExtend0; /*!< Extend buffer descriptor control0. */
 431:../drivers/fsl_enet.h ****     uint16_t controlExtend1; /*!< Extend buffer descriptor control1. */
 432:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 433:../drivers/fsl_enet.h ****     int8_t *txLaunchTime; /*!< Transmit launch time. */
 434:../drivers/fsl_enet.h **** #else
 435:../drivers/fsl_enet.h ****     uint16_t reserved0;
 436:../drivers/fsl_enet.h ****     uint16_t reserved1;
 437:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 438:../drivers/fsl_enet.h ****     uint16_t reserved2;
 439:../drivers/fsl_enet.h ****     uint16_t controlExtend2; /*!< Extend buffer descriptor control2. */
 440:../drivers/fsl_enet.h ****     uint32_t timestamp;      /*!< Timestamp. */
 441:../drivers/fsl_enet.h ****     uint16_t reserved3;
 442:../drivers/fsl_enet.h ****     uint16_t reserved4;
 443:../drivers/fsl_enet.h ****     uint16_t reserved5;
 444:../drivers/fsl_enet.h ****     uint16_t reserved6;
 445:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 446:../drivers/fsl_enet.h **** } enet_tx_bd_struct_t;
 447:../drivers/fsl_enet.h **** 
 448:../drivers/fsl_enet.h **** /*! @brief Defines the ENET data error statistic structure. */
 449:../drivers/fsl_enet.h **** typedef struct _enet_data_error_stats
 450:../drivers/fsl_enet.h **** {
 451:../drivers/fsl_enet.h ****     uint32_t statsRxLenGreaterErr; /*!< Receive length greater than RCR[MAX_FL]. */
 452:../drivers/fsl_enet.h ****     uint32_t statsRxAlignErr;      /*!< Receive non-octet alignment/ */
 453:../drivers/fsl_enet.h ****     uint32_t statsRxFcsErr;        /*!< Receive CRC error. */
 454:../drivers/fsl_enet.h ****     uint32_t statsRxOverRunErr;    /*!< Receive over run. */
 455:../drivers/fsl_enet.h ****     uint32_t statsRxTruncateErr;   /*!< Receive truncate. */
 456:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 457:../drivers/fsl_enet.h ****     uint32_t statsRxProtocolChecksumErr; /*!< Receive protocol checksum error. */
 458:../drivers/fsl_enet.h ****     uint32_t statsRxIpHeadChecksumErr;   /*!< Receive IP header checksum error. */
 459:../drivers/fsl_enet.h ****     uint32_t statsRxMacErr;              /*!< Receive Mac error. */
 460:../drivers/fsl_enet.h ****     uint32_t statsRxPhyErr;              /*!< Receive PHY error. */
 461:../drivers/fsl_enet.h ****     uint32_t statsRxCollisionErr;        /*!< Receive collision. */
 462:../drivers/fsl_enet.h ****     uint32_t statsTxErr;                 /*!< The error happen when transmit the frame. */
 463:../drivers/fsl_enet.h ****     uint32_t statsTxFrameErr;            /*!< The transmit frame is error. */
 464:../drivers/fsl_enet.h ****     uint32_t statsTxOverFlowErr;         /*!< Transmit overflow. */
 465:../drivers/fsl_enet.h ****     uint32_t statsTxLateCollisionErr;    /*!< Transmit late collision. */
 466:../drivers/fsl_enet.h ****     uint32_t statsTxExcessCollisionErr;  /*!< Transmit excess collision.*/
 467:../drivers/fsl_enet.h ****     uint32_t statsTxUnderFlowErr;        /*!< Transmit under flow error. */
 468:../drivers/fsl_enet.h ****     uint32_t statsTxTsErr;               /*!< Transmit time stamp error. */
 469:../drivers/fsl_enet.h **** #endif                                   /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 470:../drivers/fsl_enet.h **** } enet_data_error_stats_t;
 471:../drivers/fsl_enet.h **** 
 472:../drivers/fsl_enet.h **** /*! @brief Defines the receive buffer descriptor configuration structure.
 473:../drivers/fsl_enet.h ****  *
 474:../drivers/fsl_enet.h ****  * Note that for the internal DMA requirements, the buffers have a corresponding alignment requirem
 475:../drivers/fsl_enet.h ****  * 1. The aligned receive and transmit buffer size must be evenly divisible by ENET_BUFF_ALIGNMENT.
 476:../drivers/fsl_enet.h ****  *    when the data buffers are in cacheable region when cache is enabled, all those size should be
 477:../drivers/fsl_enet.h ****  *    aligned to the maximum value of "ENET_BUFF_ALIGNMENT" and the cache line size.
 478:../drivers/fsl_enet.h ****  * 2. The aligned transmit and receive buffer descriptor start address must be at
 479:../drivers/fsl_enet.h ****  *    least 64 bit aligned. However, it's recommended to be evenly divisible by ENET_BUFF_ALIGNMENT
 480:../drivers/fsl_enet.h ****  *    buffer descriptors should be put in non-cacheable region when cache is enabled.
 481:../drivers/fsl_enet.h ****  * 3. The aligned transmit and receive data buffer start address must be evenly divisible by ENET_B
 482:../drivers/fsl_enet.h ****  *    Receive buffers should be continuous with the total size equal to "rxBdNumber * rxBuffSizeAli
 483:../drivers/fsl_enet.h ****  *    Transmit buffers should be continuous with the total size equal to "txBdNumber * txBuffSizeAl
 484:../drivers/fsl_enet.h ****  *    when the data buffers are in cacheable region when cache is enabled, all those size should be
 485:../drivers/fsl_enet.h ****  *    aligned to the maximum value of "ENET_BUFF_ALIGNMENT" and the cache line size.
 486:../drivers/fsl_enet.h ****  */
 487:../drivers/fsl_enet.h **** typedef struct _enet_buffer_config
 488:../drivers/fsl_enet.h **** {
 489:../drivers/fsl_enet.h ****     uint16_t rxBdNumber;      /*!< Receive buffer descriptor number. */
 490:../drivers/fsl_enet.h ****     uint16_t txBdNumber;      /*!< Transmit buffer descriptor number. */
 491:../drivers/fsl_enet.h ****     uint32_t rxBuffSizeAlign; /*!< Aligned receive data buffer size. */
 492:../drivers/fsl_enet.h ****     uint32_t txBuffSizeAlign; /*!< Aligned transmit data buffer size. */
 493:../drivers/fsl_enet.h ****     volatile enet_rx_bd_struct_t
 494:../drivers/fsl_enet.h ****         *rxBdStartAddrAlign; /*!< Aligned receive buffer descriptor start address: should be non-ca
 495:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 496:../drivers/fsl_enet.h ****         *txBdStartAddrAlign; /*!< Aligned transmit buffer descriptor start address: should be non-c
 497:../drivers/fsl_enet.h ****     uint8_t *rxBufferAlign;  /*!< Receive data buffer start address. */
 498:../drivers/fsl_enet.h ****     uint8_t *txBufferAlign;  /*!< Transmit data buffer start address. */
 499:../drivers/fsl_enet.h **** } enet_buffer_config_t;
 500:../drivers/fsl_enet.h **** 
 501:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 502:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP time stamp structure. */
 503:../drivers/fsl_enet.h **** typedef struct _enet_ptp_time
 504:../drivers/fsl_enet.h **** {
 505:../drivers/fsl_enet.h ****     uint64_t second;     /*!< Second. */
 506:../drivers/fsl_enet.h ****     uint32_t nanosecond; /*!< Nanosecond. */
 507:../drivers/fsl_enet.h **** } enet_ptp_time_t;
 508:../drivers/fsl_enet.h **** 
 509:../drivers/fsl_enet.h **** /*! @brief Defines the structure for the ENET PTP message data and timestamp data.*/
 510:../drivers/fsl_enet.h **** typedef struct _enet_ptp_time_data
 511:../drivers/fsl_enet.h **** {
 512:../drivers/fsl_enet.h ****     uint8_t version;                             /*!< PTP version. */
 513:../drivers/fsl_enet.h ****     uint8_t sourcePortId[kENET_PtpSrcPortIdLen]; /*!< PTP source port ID. */
 514:../drivers/fsl_enet.h ****     uint16_t sequenceId;                         /*!< PTP sequence ID. */
 515:../drivers/fsl_enet.h ****     uint8_t messageType;                         /*!< PTP message type. */
 516:../drivers/fsl_enet.h ****     enet_ptp_time_t timeStamp;                   /*!< PTP timestamp. */
 517:../drivers/fsl_enet.h **** } enet_ptp_time_data_t;
 518:../drivers/fsl_enet.h **** 
 519:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP ring buffer structure for the PTP message timestamp store.*/
 520:../drivers/fsl_enet.h **** typedef struct _enet_ptp_time_data_ring
 521:../drivers/fsl_enet.h **** {
 522:../drivers/fsl_enet.h ****     uint32_t front;                  /*!< The first index of the ring. */
 523:../drivers/fsl_enet.h ****     uint32_t end;                    /*!< The end index of the ring. */
 524:../drivers/fsl_enet.h ****     uint32_t size;                   /*!< The size of the ring. */
 525:../drivers/fsl_enet.h ****     enet_ptp_time_data_t *ptpTsData; /*!< PTP message data structure. */
 526:../drivers/fsl_enet.h **** } enet_ptp_time_data_ring_t;
 527:../drivers/fsl_enet.h **** 
 528:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP configuration structure. */
 529:../drivers/fsl_enet.h **** typedef struct _enet_ptp_config
 530:../drivers/fsl_enet.h **** {
 531:../drivers/fsl_enet.h ****     uint8_t ptpTsRxBuffNum;            /*!< Receive 1588 timestamp buffer number*/
 532:../drivers/fsl_enet.h ****     uint8_t ptpTsTxBuffNum;            /*!< Transmit 1588 timestamp buffer number*/
 533:../drivers/fsl_enet.h ****     enet_ptp_time_data_t *rxPtpTsData; /*!< The start address of 1588 receive timestamp buffers */
 534:../drivers/fsl_enet.h ****     enet_ptp_time_data_t *txPtpTsData; /*!< The start address of 1588 transmit timestamp buffers */
 535:../drivers/fsl_enet.h ****     enet_ptp_timer_channel_t channel;  /*!< Used for ERRATA_2579: the PTP 1588 timer channel for ti
 536:../drivers/fsl_enet.h ****     uint32_t ptp1588ClockSrc_Hz;       /*!< The clock source of the PTP 1588 timer. */
 537:../drivers/fsl_enet.h **** } enet_ptp_config_t;
 538:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 539:../drivers/fsl_enet.h **** 
 540:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
 541:../drivers/fsl_enet.h **** /*! @brief Defines the interrupt coalescing configure structure. */
 542:../drivers/fsl_enet.h **** typedef struct _enet_intcoalesce_config
 543:../drivers/fsl_enet.h **** {
 544:../drivers/fsl_enet.h ****     uint8_t txCoalesceFrameCount[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit interrupt coalescing frame 
 545:../drivers/fsl_enet.h ****     uint16_t txCoalesceTimeCount[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit interrupt coalescing timer 
 546:../drivers/fsl_enet.h ****     uint8_t rxCoalesceFrameCount[FSL_FEATURE_ENET_QUEUE]; /*!< Receive interrupt coalescing frame c
 547:../drivers/fsl_enet.h ****     uint16_t rxCoalesceTimeCount[FSL_FEATURE_ENET_QUEUE]; /*!< Receive interrupt coalescing timer c
 548:../drivers/fsl_enet.h **** } enet_intcoalesce_config_t;
 549:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
 550:../drivers/fsl_enet.h **** 
 551:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 552:../drivers/fsl_enet.h **** /*! @brief Defines the ENET AVB Configure structure.
 553:../drivers/fsl_enet.h ****  *
 554:../drivers/fsl_enet.h ****  * This is used for to configure the extended ring 1 and ring 2.
 555:../drivers/fsl_enet.h ****  * 1. The classification match format is (CMP3 << 12) | (CMP2 << 8) | (CMP1 << 4) | CMP0.
 556:../drivers/fsl_enet.h ****  * composed of four 3-bit compared VLAN priority field cmp0~cmp3, cm0 ~ cmp3 are used in parallel.
 557:../drivers/fsl_enet.h ****  *
 558:../drivers/fsl_enet.h ****  * If CMP1,2,3 are not unused, please set them to the same value as CMP0.
 559:../drivers/fsl_enet.h ****  * 2. The idleSlope is used to calculate the Band Width fraction, BW fraction = 1 / (1 + 512/idleSl
 560:../drivers/fsl_enet.h ****  * For avb configuration, the BW fraction of Class 1 and Class 2 combined must not exceed 0.75.
 561:../drivers/fsl_enet.h ****  */
 562:../drivers/fsl_enet.h **** typedef struct _enet_avb_config
 563:../drivers/fsl_enet.h **** {
 564:../drivers/fsl_enet.h ****     uint16_t rxClassifyMatch[FSL_FEATURE_ENET_QUEUE - 1];    /*!< The classification match value fo
 565:../drivers/fsl_enet.h ****     enet_idle_slope_t idleSlope[FSL_FEATURE_ENET_QUEUE - 1]; /*!< The idle slope for certian bandwi
 566:../drivers/fsl_enet.h **** } enet_avb_config_t;
 567:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 568:../drivers/fsl_enet.h **** 
 569:../drivers/fsl_enet.h **** /*! @brief Defines the basic configuration structure for the ENET device.
 570:../drivers/fsl_enet.h ****  *
 571:../drivers/fsl_enet.h ****  * Note:
 572:../drivers/fsl_enet.h ****  *  1. macSpecialConfig is used for a special control configuration, A logical OR of
 573:../drivers/fsl_enet.h ****  *  "enet_special_control_flag_t". For a special configuration for MAC,
 574:../drivers/fsl_enet.h ****  *  set this parameter to 0.
 575:../drivers/fsl_enet.h ****  *  2. txWatermark is used for a cut-through operation. It is in steps of 64 bytes:
 576:../drivers/fsl_enet.h ****  *  0/1  - 64 bytes written to TX FIFO before transmission of a frame begins.
 577:../drivers/fsl_enet.h ****  *  2    - 128 bytes written to TX FIFO ....
 578:../drivers/fsl_enet.h ****  *  3    - 192 bytes written to TX FIFO ....
 579:../drivers/fsl_enet.h ****  *  The maximum of txWatermark is 0x2F   - 4032 bytes written to TX FIFO ....
 580:../drivers/fsl_enet.h ****  *  txWatermark allows minimizing the transmit latency to set the txWatermark to 0 or 1
 581:../drivers/fsl_enet.h ****  *  or for larger bus access latency 3 or larger due to contention for the system bus.
 582:../drivers/fsl_enet.h ****  *  3. rxFifoFullThreshold is similar to the txWatermark for cut-through operation in RX.
 583:../drivers/fsl_enet.h ****  *  It is in 64-bit words. The minimum is ENET_FIFO_MIN_RX_FULL and the maximum is 0xFF.
 584:../drivers/fsl_enet.h ****  *  If the end of the frame is stored in FIFO and the frame size if smaller than the
 585:../drivers/fsl_enet.h ****  *  txWatermark, the frame is still transmitted. The rule  is the
 586:../drivers/fsl_enet.h ****  *  same for rxFifoFullThreshold in the receive direction.
 587:../drivers/fsl_enet.h ****  *  4. When "kENET_ControlFlowControlEnable" is set in the macSpecialConfig, ensure
 588:../drivers/fsl_enet.h ****  *  that the pauseDuration, rxFifoEmptyThreshold, and rxFifoStatEmptyThreshold
 589:../drivers/fsl_enet.h ****  *  are set for flow control enabled case.
 590:../drivers/fsl_enet.h ****  *  5. When "kENET_ControlStoreAndFwdDisabled" is set in the macSpecialConfig, ensure
 591:../drivers/fsl_enet.h ****  *  that the rxFifoFullThreshold and txFifoWatermark are set for store and forward disable.
 592:../drivers/fsl_enet.h ****  *  6. The rxAccelerConfig and txAccelerConfig default setting with 0 - accelerator
 593:../drivers/fsl_enet.h ****  *  are disabled. The "enet_tx_accelerator_t" and "enet_rx_accelerator_t" are
 594:../drivers/fsl_enet.h ****  *  recommended to be used to enable the transmit and receive accelerator.
 595:../drivers/fsl_enet.h ****  *  After the accelerators are enabled, the store and forward feature should be enabled.
 596:../drivers/fsl_enet.h ****  *  As a result, kENET_ControlStoreAndFwdDisabled should not be set.
 597:../drivers/fsl_enet.h ****  *  7. The intCoalesceCfg can be used in the rx or tx enabled cases to decrese the CPU loading.
 598:../drivers/fsl_enet.h ****  */
 599:../drivers/fsl_enet.h **** typedef struct _enet_config
 600:../drivers/fsl_enet.h **** {
 601:../drivers/fsl_enet.h ****     uint32_t macSpecialConfig;    /*!< Mac special configuration. A logical OR of "enet_special_con
 602:../drivers/fsl_enet.h ****     uint32_t interrupt;           /*!< Mac interrupt source. A logical OR of "enet_interrupt_enable
 603:../drivers/fsl_enet.h ****     uint16_t rxMaxFrameLen;       /*!< Receive maximum frame length. */
 604:../drivers/fsl_enet.h ****     enet_mii_mode_t miiMode;      /*!< MII mode. */
 605:../drivers/fsl_enet.h ****     enet_mii_speed_t miiSpeed;    /*!< MII Speed. */
 606:../drivers/fsl_enet.h ****     enet_mii_duplex_t miiDuplex;  /*!< MII duplex. */
 607:../drivers/fsl_enet.h ****     uint8_t rxAccelerConfig;      /*!< Receive accelerator, A logical OR of "enet_rx_accelerator_t"
 608:../drivers/fsl_enet.h ****     uint8_t txAccelerConfig;      /*!< Transmit accelerator, A logical OR of "enet_rx_accelerator_t
 609:../drivers/fsl_enet.h ****     uint16_t pauseDuration;       /*!< For flow control enabled case: Pause duration. */
 610:../drivers/fsl_enet.h ****     uint8_t rxFifoEmptyThreshold; /*!< For flow control enabled case:  when RX FIFO level reaches t
 611:../drivers/fsl_enet.h ****                                      it makes MAC generate XOFF pause frame. */
 612:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_T
 613:../drivers/fsl_enet.h ****     uint8_t rxFifoStatEmptyThreshold; /*!< For flow control enabled case: number of frames in the r
 614:../drivers/fsl_enet.h ****                                     independent of size, that can be accept. If the limit is reache
 615:../drivers/fsl_enet.h ****                                     continues and a pause frame is triggered. */
 616:../drivers/fsl_enet.h **** #endif                                /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 617:../drivers/fsl_enet.h ****     uint8_t rxFifoFullThreshold;      /*!< For store and forward disable case, the data required in
 618:../drivers/fsl_enet.h ****                                       the MAC receive ready status. */
 619:../drivers/fsl_enet.h ****     uint8_t txFifoWatermark;          /*!< For store and forward disable case, the data required in
 620:../drivers/fsl_enet.h ****                                       before a frame transmit start. */
 621:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
 622:../drivers/fsl_enet.h ****     enet_intcoalesce_config_t
 623:../drivers/fsl_enet.h ****         *intCoalesceCfg; /* If the interrupt coalsecence is not required in the ring n(0,1,2), plea
 624:../drivers/fsl_enet.h ****                    to NULL. */
 625:../drivers/fsl_enet.h **** #endif                   /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
 626:../drivers/fsl_enet.h ****     uint8_t ringNum;     /*!< Number of used rings. default with 1 -- single ring. */
 627:../drivers/fsl_enet.h **** } enet_config_t;
 628:../drivers/fsl_enet.h **** 
 629:../drivers/fsl_enet.h **** /* Forward declaration of the handle typedef. */
 630:../drivers/fsl_enet.h **** typedef struct _enet_handle enet_handle_t;
 631:../drivers/fsl_enet.h **** 
 632:../drivers/fsl_enet.h **** /*! @brief ENET callback function. */
 633:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 634:../drivers/fsl_enet.h **** typedef void (*enet_callback_t)(
 635:../drivers/fsl_enet.h ****     ENET_Type *base, enet_handle_t *handle, uint32_t ringId, enet_event_t event, void *userData);
 636:../drivers/fsl_enet.h **** #else
 637:../drivers/fsl_enet.h **** typedef void (*enet_callback_t)(ENET_Type *base, enet_handle_t *handle, enet_event_t event, void *u
 638:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 639:../drivers/fsl_enet.h **** 
 640:../drivers/fsl_enet.h **** /*! @brief Defines the ENET handler structure. */
 641:../drivers/fsl_enet.h **** struct _enet_handle
 642:../drivers/fsl_enet.h **** {
 643:../drivers/fsl_enet.h ****     volatile enet_rx_bd_struct_t
 644:../drivers/fsl_enet.h ****         *rxBdBase[FSL_FEATURE_ENET_QUEUE]; /*!< Receive buffer descriptor base address pointer. */
 645:../drivers/fsl_enet.h ****     volatile enet_rx_bd_struct_t
 646:../drivers/fsl_enet.h ****         *rxBdCurrent[FSL_FEATURE_ENET_QUEUE]; /*!< The current available receive buffer descriptor 
 647:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 648:../drivers/fsl_enet.h ****         *txBdBase[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit buffer descriptor base address pointer. */
 649:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 650:../drivers/fsl_enet.h ****         *txBdCurrent[FSL_FEATURE_ENET_QUEUE];         /*!< The current available transmit buffer de
 651:../drivers/fsl_enet.h ****     uint32_t rxBuffSizeAlign[FSL_FEATURE_ENET_QUEUE]; /*!< Receive buffer size alignment. */
 652:../drivers/fsl_enet.h ****     uint32_t txBuffSizeAlign[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit buffer size alignment. */
 653:../drivers/fsl_enet.h ****     uint8_t ringNum;                                  /*!< Number of used rings. */
 654:../drivers/fsl_enet.h ****     enet_callback_t callback;                         /*!< Callback function. */
 655:../drivers/fsl_enet.h ****     void *userData;                                   /*!< Callback function parameter.*/
 656:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 657:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 658:../drivers/fsl_enet.h ****         *txBdDirtyStatic[FSL_FEATURE_ENET_QUEUE]; /*!< The dirty transmit buffer descriptor for err
 659:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 660:../drivers/fsl_enet.h ****         *txBdDirtyTime[FSL_FEATURE_ENET_QUEUE]; /*!< The dirty transmit buffer descriptor for time 
 661:../drivers/fsl_enet.h ****     uint64_t msTimerSecond;                     /*!< The second for Master PTP timer .*/
 662:../drivers/fsl_enet.h ****     enet_ptp_time_data_ring_t rxPtpTsDataRing;  /*!< Receive PTP 1588 time stamp data ring buffer. 
 663:../drivers/fsl_enet.h ****     enet_ptp_time_data_ring_t txPtpTsDataRing;  /*!< Transmit PTP 1588 time stamp data ring buffer.
 664:../drivers/fsl_enet.h **** #endif                                          /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 665:../drivers/fsl_enet.h **** };
 666:../drivers/fsl_enet.h **** 
 667:../drivers/fsl_enet.h **** /*******************************************************************************
 668:../drivers/fsl_enet.h ****  * API
 669:../drivers/fsl_enet.h ****  ******************************************************************************/
 670:../drivers/fsl_enet.h **** 
 671:../drivers/fsl_enet.h **** #if defined(__cplusplus)
 672:../drivers/fsl_enet.h **** extern "C" {
 673:../drivers/fsl_enet.h **** #endif
 674:../drivers/fsl_enet.h **** 
 675:../drivers/fsl_enet.h **** /*!
 676:../drivers/fsl_enet.h ****   * @name Initialization and De-initialization
 677:../drivers/fsl_enet.h ****   * @{
 678:../drivers/fsl_enet.h ****   */
 679:../drivers/fsl_enet.h **** 
 680:../drivers/fsl_enet.h **** /*!
 681:../drivers/fsl_enet.h ****  * @brief Gets the ENET default configuration structure.
 682:../drivers/fsl_enet.h ****  *
 683:../drivers/fsl_enet.h ****  * The purpose of this API is to get the default ENET MAC controller
 684:../drivers/fsl_enet.h ****  * configure structure for ENET_Init(). User may use the initialized
 685:../drivers/fsl_enet.h ****  * structure unchanged in ENET_Init(), or modify some fields of the
 686:../drivers/fsl_enet.h ****  * structure before calling ENET_Init().
 687:../drivers/fsl_enet.h ****  * Example:
 688:../drivers/fsl_enet.h ****    @code
 689:../drivers/fsl_enet.h ****    enet_config_t config;
 690:../drivers/fsl_enet.h ****    ENET_GetDefaultConfig(&config);
 691:../drivers/fsl_enet.h ****    @endcode
 692:../drivers/fsl_enet.h ****  * @param config The ENET mac controller configuration structure pointer.
 693:../drivers/fsl_enet.h ****  */
 694:../drivers/fsl_enet.h **** void ENET_GetDefaultConfig(enet_config_t *config);
 695:../drivers/fsl_enet.h **** 
 696:../drivers/fsl_enet.h **** /*!
 697:../drivers/fsl_enet.h ****  * @brief Initializes the ENET module.
 698:../drivers/fsl_enet.h ****  *
 699:../drivers/fsl_enet.h ****  * This function ungates the module clock and initializes it with the ENET configuration.
 700:../drivers/fsl_enet.h ****  *
 701:../drivers/fsl_enet.h ****  * @param base    ENET peripheral base address.
 702:../drivers/fsl_enet.h ****  * @param handle  ENET handler pointer.
 703:../drivers/fsl_enet.h ****  * @param config  ENET mac configuration structure pointer.
 704:../drivers/fsl_enet.h ****  *        The "enet_config_t" type mac configuration return from ENET_GetDefaultConfig
 705:../drivers/fsl_enet.h ****  *        can be used directly. It is also possible to verify the Mac configuration using other met
 706:../drivers/fsl_enet.h ****  * @param bufferConfig  ENET buffer configuration structure pointer.
 707:../drivers/fsl_enet.h ****  *        The buffer configuration should be prepared for ENET Initialization.
 708:../drivers/fsl_enet.h ****  *        It is the start address of "ringNum" enet_buffer_config structures.
 709:../drivers/fsl_enet.h ****  * @param macAddr  ENET mac address of Ethernet device. This MAC address should be
 710:../drivers/fsl_enet.h ****  *        provided.
 711:../drivers/fsl_enet.h ****  * @param srcClock_Hz The internal module clock source for MII clock.
 712:../drivers/fsl_enet.h ****  *
 713:../drivers/fsl_enet.h ****  * @note ENET has two buffer descriptors legacy buffer descriptors and
 714:../drivers/fsl_enet.h ****  * enhanced IEEE 1588 buffer descriptors. The legacy descriptor is used by default. To
 715:../drivers/fsl_enet.h ****  * use the IEEE 1588 feature, use the enhanced IEEE 1588 buffer descriptor
 716:../drivers/fsl_enet.h ****  * by defining "ENET_ENHANCEDBUFFERDESCRIPTOR_MODE" and calling ENET_Ptp1588Configure()
 717:../drivers/fsl_enet.h ****  * to configure the 1588 feature and related buffers after calling ENET_Init().
 718:../drivers/fsl_enet.h ****  */
 719:../drivers/fsl_enet.h **** void ENET_Init(ENET_Type *base,
 720:../drivers/fsl_enet.h ****                enet_handle_t *handle,
 721:../drivers/fsl_enet.h ****                const enet_config_t *config,
 722:../drivers/fsl_enet.h ****                const enet_buffer_config_t *bufferConfig,
 723:../drivers/fsl_enet.h ****                uint8_t *macAddr,
 724:../drivers/fsl_enet.h ****                uint32_t srcClock_Hz);
 725:../drivers/fsl_enet.h **** /*!
 726:../drivers/fsl_enet.h ****  * @brief Deinitializes the ENET module.
 727:../drivers/fsl_enet.h **** 
 728:../drivers/fsl_enet.h ****  * This function gates the module clock, clears ENET interrupts, and disables the ENET module.
 729:../drivers/fsl_enet.h ****  *
 730:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 731:../drivers/fsl_enet.h ****  */
 732:../drivers/fsl_enet.h **** void ENET_Deinit(ENET_Type *base);
 733:../drivers/fsl_enet.h **** 
 734:../drivers/fsl_enet.h **** /*!
 735:../drivers/fsl_enet.h ****  * @brief Resets the ENET module.
 736:../drivers/fsl_enet.h ****  *
 737:../drivers/fsl_enet.h ****  * This function restores the ENET module to reset state.
 738:../drivers/fsl_enet.h ****  * Note that this function sets all registers to
 739:../drivers/fsl_enet.h ****  * reset state. As a result, the ENET module can't work after calling this function.
 740:../drivers/fsl_enet.h ****  *
 741:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 742:../drivers/fsl_enet.h ****  */
 743:../drivers/fsl_enet.h **** static inline void ENET_Reset(ENET_Type *base)
 744:../drivers/fsl_enet.h **** {
 745:../drivers/fsl_enet.h ****     base->ECR |= ENET_ECR_RESET_MASK;
 746:../drivers/fsl_enet.h **** }
 747:../drivers/fsl_enet.h **** 
 748:../drivers/fsl_enet.h **** /* @} */
 749:../drivers/fsl_enet.h **** 
 750:../drivers/fsl_enet.h **** /*!
 751:../drivers/fsl_enet.h ****  * @name MII interface operation
 752:../drivers/fsl_enet.h ****  * @{
 753:../drivers/fsl_enet.h ****  */
 754:../drivers/fsl_enet.h **** 
 755:../drivers/fsl_enet.h **** /*!
 756:../drivers/fsl_enet.h ****  * @brief Sets the ENET MII speed and duplex.
 757:../drivers/fsl_enet.h ****  *
 758:../drivers/fsl_enet.h ****  * This API is provided to dynamically change the speed and dulpex for MAC.
 759:../drivers/fsl_enet.h ****  *
 760:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 761:../drivers/fsl_enet.h ****  * @param speed The speed of the RMII mode.
 762:../drivers/fsl_enet.h ****  * @param duplex The duplex of the RMII mode.
 763:../drivers/fsl_enet.h ****  */
 764:../drivers/fsl_enet.h **** void ENET_SetMII(ENET_Type *base, enet_mii_speed_t speed, enet_mii_duplex_t duplex);
 765:../drivers/fsl_enet.h **** 
 766:../drivers/fsl_enet.h **** /*!
 767:../drivers/fsl_enet.h ****  * @brief Sets the ENET SMI(serial management interface)- MII management interface.
 768:../drivers/fsl_enet.h ****  *
 769:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 770:../drivers/fsl_enet.h ****  * @param srcClock_Hz This is the ENET module clock frequency. Normally it's the system clock. See 
 771:../drivers/fsl_enet.h ****  * @param isPreambleDisabled The preamble disable flag.
 772:../drivers/fsl_enet.h ****  *        - true   Enables the preamble.
 773:../drivers/fsl_enet.h ****  *        - false  Disables the preamble.
 774:../drivers/fsl_enet.h ****  */
 775:../drivers/fsl_enet.h **** void ENET_SetSMI(ENET_Type *base, uint32_t srcClock_Hz, bool isPreambleDisabled);
 776:../drivers/fsl_enet.h **** 
 777:../drivers/fsl_enet.h **** /*!
 778:../drivers/fsl_enet.h ****  * @brief Gets the ENET SMI- MII management interface configuration.
 779:../drivers/fsl_enet.h ****  *
 780:../drivers/fsl_enet.h ****  * This API is used to get the SMI configuration to check whether the MII management
 781:../drivers/fsl_enet.h ****  * interface has been set.
 782:../drivers/fsl_enet.h ****  *
 783:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 784:../drivers/fsl_enet.h ****  * @return The SMI setup status true or false.
 785:../drivers/fsl_enet.h ****  */
 786:../drivers/fsl_enet.h **** static inline bool ENET_GetSMI(ENET_Type *base)
 787:../drivers/fsl_enet.h **** {
 788:../drivers/fsl_enet.h ****     return (0 != (base->MSCR & 0x7E));
 789:../drivers/fsl_enet.h **** }
 790:../drivers/fsl_enet.h **** 
 791:../drivers/fsl_enet.h **** /*!
 792:../drivers/fsl_enet.h ****  * @brief Reads data from the PHY register through an SMI interface.
 793:../drivers/fsl_enet.h ****  *
 794:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 795:../drivers/fsl_enet.h ****  * @return The data read from PHY
 796:../drivers/fsl_enet.h ****  */
 797:../drivers/fsl_enet.h **** static inline uint32_t ENET_ReadSMIData(ENET_Type *base)
 798:../drivers/fsl_enet.h **** {
 799:../drivers/fsl_enet.h ****     return (uint32_t)((base->MMFR & ENET_MMFR_DATA_MASK) >> ENET_MMFR_DATA_SHIFT);
 800:../drivers/fsl_enet.h **** }
 801:../drivers/fsl_enet.h **** 
 802:../drivers/fsl_enet.h **** /*!
 803:../drivers/fsl_enet.h ****  * @brief Starts an SMI (Serial Management Interface) read command.
 804:../drivers/fsl_enet.h ****  *
 805:../drivers/fsl_enet.h ****  * Used for standard IEEE802.3 MDIO Clause 22 format.
 806:../drivers/fsl_enet.h ****  *
 807:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 808:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 809:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. Range from 0 ~ 31.
 810:../drivers/fsl_enet.h ****  * @param operation The read operation.
 811:../drivers/fsl_enet.h ****  */
 812:../drivers/fsl_enet.h **** void ENET_StartSMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_read_t operatio
 813:../drivers/fsl_enet.h **** 
 814:../drivers/fsl_enet.h **** /*!
 815:../drivers/fsl_enet.h ****  * @brief Starts an SMI write command.
 816:../drivers/fsl_enet.h ****  *
 817:../drivers/fsl_enet.h ****  * Used for standard IEEE802.3 MDIO Clause 22 format.
 818:../drivers/fsl_enet.h ****  *
 819:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 820:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 821:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. Range from 0 ~ 31.
 822:../drivers/fsl_enet.h ****  * @param operation The write operation.
 823:../drivers/fsl_enet.h ****  * @param data The data written to PHY.
 824:../drivers/fsl_enet.h ****  */
 825:../drivers/fsl_enet.h **** void ENET_StartSMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_write_t operat
 826:../drivers/fsl_enet.h **** 
 827:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
 828:../drivers/fsl_enet.h **** /*!
 829:../drivers/fsl_enet.h ****  * @brief Starts the extended IEEE802.3 Clause 45 MDIO format SMI read command.
 830:../drivers/fsl_enet.h ****  *
 831:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 832:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 833:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. For MDIO IEEE802.3 Clause 45,
 834:../drivers/fsl_enet.h ****  *        the phyReg is a 21-bits combination of the devaddr (5 bits device address)
 835:../drivers/fsl_enet.h ****  *        and the regAddr (16 bits phy register): phyReg = (devaddr << 16) | regAddr.
 836:../drivers/fsl_enet.h ****  */
 837:../drivers/fsl_enet.h **** void ENET_StartExtC45SMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg);
 838:../drivers/fsl_enet.h **** 
 839:../drivers/fsl_enet.h **** /*!
 840:../drivers/fsl_enet.h ****  * @brief Starts the extended IEEE802.3 Clause 45 MDIO format SMI write command.
 841:../drivers/fsl_enet.h ****  *
 842:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 843:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 844:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. For MDIO IEEE802.3 Clause 45,
 845:../drivers/fsl_enet.h ****  *        the phyReg is a 21-bits combination of the devaddr (5 bits device address)
 846:../drivers/fsl_enet.h ****  *        and the regAddr (16 bits phy register): phyReg = (devaddr << 16) | regAddr.
 847:../drivers/fsl_enet.h ****  * @param data The data written to PHY.
 848:../drivers/fsl_enet.h ****  */
 849:../drivers/fsl_enet.h **** void ENET_StartExtC45SMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data);
 850:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */
 851:../drivers/fsl_enet.h **** 
 852:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 853:../drivers/fsl_enet.h **** /*!
 854:../drivers/fsl_enet.h ****  * @brief Control the usage of the delayed tx/rx RGMII clock.
 855:../drivers/fsl_enet.h ****  *
 856:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 857:../drivers/fsl_enet.h ****  * @param txEnabled  Enable or disable to generate the delayed version of RGMII_TXC.
 858:../drivers/fsl_enet.h ****  * @param rxEnabled  Enable or disable to use the delayed version of RGMII_RXC.
 859:../drivers/fsl_enet.h ****  */
 860:../drivers/fsl_enet.h **** 
 861:../drivers/fsl_enet.h **** static inline void ENET_SetRGMIIClockDelay(ENET_Type *base, bool txEnabled, bool rxEnabled)
 862:../drivers/fsl_enet.h **** {
 863:../drivers/fsl_enet.h ****     uint32_t ecrReg = base->ECR;
 864:../drivers/fsl_enet.h **** 
 865:../drivers/fsl_enet.h ****     /* Set for transmit clock delay. */
 866:../drivers/fsl_enet.h ****     if (txEnabled)
 867:../drivers/fsl_enet.h ****     {
 868:../drivers/fsl_enet.h ****         ecrReg |= ENET_ECR_TXC_DLY_MASK;
 869:../drivers/fsl_enet.h ****     }
 870:../drivers/fsl_enet.h ****     else
 871:../drivers/fsl_enet.h ****     {
 872:../drivers/fsl_enet.h ****         ecrReg &= ~ENET_ECR_TXC_DLY_MASK;
 873:../drivers/fsl_enet.h ****     }
 874:../drivers/fsl_enet.h **** 
 875:../drivers/fsl_enet.h ****     /* Set for receive clock delay. */
 876:../drivers/fsl_enet.h ****     if (rxEnabled)
 877:../drivers/fsl_enet.h ****     {
 878:../drivers/fsl_enet.h ****         ecrReg |= ENET_ECR_RXC_DLY_MASK;
 879:../drivers/fsl_enet.h ****     }
 880:../drivers/fsl_enet.h ****     else
 881:../drivers/fsl_enet.h ****     {
 882:../drivers/fsl_enet.h ****         ecrReg &= ~ENET_ECR_RXC_DLY_MASK;
 883:../drivers/fsl_enet.h ****     }
 884:../drivers/fsl_enet.h **** }
 885:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 886:../drivers/fsl_enet.h ****        /* @} */
 887:../drivers/fsl_enet.h **** 
 888:../drivers/fsl_enet.h **** /*!
 889:../drivers/fsl_enet.h ****  * @name MAC Address Filter
 890:../drivers/fsl_enet.h ****  * @{
 891:../drivers/fsl_enet.h ****  */
 892:../drivers/fsl_enet.h **** 
 893:../drivers/fsl_enet.h **** /*!
 894:../drivers/fsl_enet.h ****  * @brief Sets the ENET module Mac address.
 895:../drivers/fsl_enet.h ****  *
 896:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 897:../drivers/fsl_enet.h ****  * @param macAddr The six-byte Mac address pointer.
 898:../drivers/fsl_enet.h ****  *        The pointer is allocated by application and input into the API.
 899:../drivers/fsl_enet.h ****  */
 900:../drivers/fsl_enet.h **** void ENET_SetMacAddr(ENET_Type *base, uint8_t *macAddr);
 901:../drivers/fsl_enet.h **** 
 902:../drivers/fsl_enet.h **** /*!
 903:../drivers/fsl_enet.h ****  * @brief Gets the ENET module Mac address.
 904:../drivers/fsl_enet.h ****  *
 905:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 906:../drivers/fsl_enet.h ****  * @param macAddr The six-byte Mac address pointer.
 907:../drivers/fsl_enet.h ****  *        The pointer is allocated by application and input into the API.
 908:../drivers/fsl_enet.h ****  */
 909:../drivers/fsl_enet.h **** void ENET_GetMacAddr(ENET_Type *base, uint8_t *macAddr);
 910:../drivers/fsl_enet.h **** 
 911:../drivers/fsl_enet.h **** /*!
 912:../drivers/fsl_enet.h ****  * @brief Adds the ENET device to a multicast group.
 913:../drivers/fsl_enet.h ****  *
 914:../drivers/fsl_enet.h ****  * @param base    ENET peripheral base address.
 915:../drivers/fsl_enet.h ****  * @param address The six-byte multicast group address which is provided by application.
 916:../drivers/fsl_enet.h ****  */
 917:../drivers/fsl_enet.h **** void ENET_AddMulticastGroup(ENET_Type *base, uint8_t *address);
 918:../drivers/fsl_enet.h **** 
 919:../drivers/fsl_enet.h **** /*!
 920:../drivers/fsl_enet.h ****  * @brief Moves the ENET device from a multicast group.
 921:../drivers/fsl_enet.h ****  *
 922:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 923:../drivers/fsl_enet.h ****  * @param address The six-byte multicast group address which is provided by application.
 924:../drivers/fsl_enet.h ****  */
 925:../drivers/fsl_enet.h **** void ENET_LeaveMulticastGroup(ENET_Type *base, uint8_t *address);
 926:../drivers/fsl_enet.h **** 
 927:../drivers/fsl_enet.h **** /* @} */
 928:../drivers/fsl_enet.h **** 
 929:../drivers/fsl_enet.h **** /*!
 930:../drivers/fsl_enet.h ****  * @name Other basic operation
 931:../drivers/fsl_enet.h ****  * @{
 932:../drivers/fsl_enet.h ****  */
 933:../drivers/fsl_enet.h **** 
 934:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 935:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 936:../drivers/fsl_enet.h **** /*!
 937:../drivers/fsl_enet.h ****  * @brief Sets the ENET AVB feature.
 938:../drivers/fsl_enet.h ****  *
 939:../drivers/fsl_enet.h ****  * ENET AVB feature configuration, set the Receive classification match and transmit
 940:../drivers/fsl_enet.h ****  * bandwidth. This API is called when the AVB feature is required.
 941:../drivers/fsl_enet.h ****  *
 942:../drivers/fsl_enet.h ****  * Note: The AVB frames transmission scheme is credit-based tx scheme and it's only supported
 943:../drivers/fsl_enet.h ****  * with the Enhanced buffer descriptors. so the AVB configuration should only done with
 944:../drivers/fsl_enet.h ****  * Enhanced buffer descriptor. so when the AVB feature is required, please make sure the
 945:../drivers/fsl_enet.h ****  * the "ENET_ENHANCEDBUFFERDESCRIPTOR_MODE" is defined.
 946:../drivers/fsl_enet.h ****  *
 947:../drivers/fsl_enet.h ****  * @param base ENET peripheral base address.
 948:../drivers/fsl_enet.h ****  * @param handle ENET handler pointer.
 949:../drivers/fsl_enet.h ****  * @param config The ENET AVB feature configuration structure.
 950:../drivers/fsl_enet.h ****  */
 951:../drivers/fsl_enet.h **** void ENET_AVBConfigure(ENET_Type *base, enet_handle_t *handle, const enet_avb_config_t *config);
 952:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 953:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE  */
 954:../drivers/fsl_enet.h **** 
 955:../drivers/fsl_enet.h **** /*!
 956:../drivers/fsl_enet.h ****  * @brief Activates ENET read or receive.
 957:../drivers/fsl_enet.h ****  *
 958:../drivers/fsl_enet.h ****  * This function is to active the enet read process. It is
 959:../drivers/fsl_enet.h ****  * used for single descriptor ring/queue.
 960:../drivers/fsl_enet.h ****  *
 961:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 962:../drivers/fsl_enet.h ****  *
 963:../drivers/fsl_enet.h ****  * @note This must be called after the MAC configuration and
 964:../drivers/fsl_enet.h ****  * state are ready. It must be called after the ENET_Init() and
 965:../drivers/fsl_enet.h ****  * ENET_Ptp1588Configure(). This should be called when the ENET receive required.
 966:../drivers/fsl_enet.h ****  */
 967:../drivers/fsl_enet.h **** static inline void ENET_ActiveRead(ENET_Type *base)
 968:../drivers/fsl_enet.h **** {
 969:../drivers/fsl_enet.h ****     base->RDAR = ENET_RDAR_RDAR_MASK;
 970:../drivers/fsl_enet.h **** }
 971:../drivers/fsl_enet.h **** 
 972:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 973:../drivers/fsl_enet.h **** /*!
 974:../drivers/fsl_enet.h ****  * @brief Activates ENET read or receive for multiple-queue/ring.
 975:../drivers/fsl_enet.h ****  *
 976:../drivers/fsl_enet.h ****  * This function is to active the enet read process. It is
 977:../drivers/fsl_enet.h ****  * used for extended multiple descriptor rings/queues.
 978:../drivers/fsl_enet.h ****  *
 979:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 980:../drivers/fsl_enet.h ****  *
 981:../drivers/fsl_enet.h ****  * @note This must be called after the MAC configuration and
 982:../drivers/fsl_enet.h ****  * state are ready. It must be called after the ENET_Init() and
 983:../drivers/fsl_enet.h ****  * ENET_Ptp1588Configure(). This should be called when the ENET receive required.
 984:../drivers/fsl_enet.h ****  */
 985:../drivers/fsl_enet.h **** static inline void ENET_ActiveReadMultiRing(ENET_Type *base)
 986:../drivers/fsl_enet.h **** {
 987:../drivers/fsl_enet.h ****     base->RDAR = ENET_RDAR_RDAR_MASK;
 988:../drivers/fsl_enet.h ****     base->RDAR1 = ENET_RDAR1_RDAR_MASK;
 989:../drivers/fsl_enet.h ****     base->RDAR2 = ENET_RDAR2_RDAR_MASK;
 990:../drivers/fsl_enet.h **** }
 991:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 992:../drivers/fsl_enet.h **** 
 993:../drivers/fsl_enet.h **** /*!
 994:../drivers/fsl_enet.h ****  * @brief Enables/disables the MAC to enter sleep mode.
 995:../drivers/fsl_enet.h ****  * This function is used to set the MAC enter sleep mode.
 996:../drivers/fsl_enet.h ****  * When entering sleep mode, the magic frame wakeup interrupt should be enabled
 997:../drivers/fsl_enet.h ****  * to wake up MAC from the sleep mode and reset it to normal mode.
 998:../drivers/fsl_enet.h ****  *
 999:../drivers/fsl_enet.h ****  * @param base    ENET peripheral base address.
1000:../drivers/fsl_enet.h ****  * @param enable  True enable sleep mode, false disable sleep mode.
1001:../drivers/fsl_enet.h ****  */
1002:../drivers/fsl_enet.h **** static inline void ENET_EnableSleepMode(ENET_Type *base, bool enable)
1003:../drivers/fsl_enet.h **** {
1004:../drivers/fsl_enet.h ****     if (enable)
1005:../drivers/fsl_enet.h ****     {
1006:../drivers/fsl_enet.h ****         /* When this field is set, MAC enters sleep mode. */
1007:../drivers/fsl_enet.h ****         base->ECR |= ENET_ECR_SLEEP_MASK | ENET_ECR_MAGICEN_MASK;
1008:../drivers/fsl_enet.h ****     }
1009:../drivers/fsl_enet.h ****     else
1010:../drivers/fsl_enet.h ****     { /* MAC exits sleep mode. */
1011:../drivers/fsl_enet.h ****         base->ECR &= ~(ENET_ECR_SLEEP_MASK | ENET_ECR_MAGICEN_MASK);
 163              		.loc 2 1011 0
 164 0012 456A     		ldr	r5, [r0, #36]
 165 0014 25F00C05 		bic	r5, r5, #12
 166 0018 4562     		str	r5, [r0, #36]
 167              	.LVL10:
 168              	.LBE43:
 169              	.LBE42:
2707:../drivers/fsl_enet.c ****         /* wake up and enter the normal mode. */
2708:../drivers/fsl_enet.c ****         ENET_EnableSleepMode(base, false);
2709:../drivers/fsl_enet.c ****         /* Callback function. */
2710:../drivers/fsl_enet.c ****         if (handle->callback)
 170              		.loc 1 2710 0
 171 001a 14B1     		cbz	r4, .L16
2711:../drivers/fsl_enet.c ****         {
2712:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2713:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_WakeUpEvent, handle->userData);
2714:../drivers/fsl_enet.c **** #else
2715:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_WakeUpEvent, handle->userData);
 172              		.loc 1 2715 0
 173 001c 0B6A     		ldr	r3, [r1, #32]
 174 001e 0322     		movs	r2, #3
 175              	.LVL11:
 176              	.L21:
2716:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2717:../drivers/fsl_enet.c ****         }
2718:../drivers/fsl_enet.c ****     }
2719:../drivers/fsl_enet.c ****     else
2720:../drivers/fsl_enet.c ****     {
2721:../drivers/fsl_enet.c ****         /* Clear the error interrupt event status. */
2722:../drivers/fsl_enet.c ****         errMask &= base->EIR;
2723:../drivers/fsl_enet.c ****         base->EIR = errMask;
2724:../drivers/fsl_enet.c ****         /* Callback function. */
2725:../drivers/fsl_enet.c ****         if (handle->callback)
2726:../drivers/fsl_enet.c ****         {
2727:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2728:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_ErrEvent, handle->userData);
2729:../drivers/fsl_enet.c **** #else
2730:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_ErrEvent, handle->userData);
 177              		.loc 1 2730 0
 178 0020 A047     		blx	r4
 179              	.LVL12:
 180              	.L16:
 181              	.LBB44:
 182              	.LBB45:
 183              		.file 3 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 412:../CMSIS/cmsis_gcc.h **** }
 413:../CMSIS/cmsis_gcc.h **** 
 414:../CMSIS/cmsis_gcc.h **** 
 415:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 416:../CMSIS/cmsis_gcc.h **** /**
 417:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 418:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 419:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 420:../CMSIS/cmsis_gcc.h ****  */
 421:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 422:../CMSIS/cmsis_gcc.h **** {
 423:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 424:../CMSIS/cmsis_gcc.h **** }
 425:../CMSIS/cmsis_gcc.h **** #endif
 426:../CMSIS/cmsis_gcc.h **** 
 427:../CMSIS/cmsis_gcc.h **** 
 428:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 429:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 430:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 431:../CMSIS/cmsis_gcc.h **** /**
 432:../CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 433:../CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 434:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 435:../CMSIS/cmsis_gcc.h ****  */
 436:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 437:../CMSIS/cmsis_gcc.h **** {
 438:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 439:../CMSIS/cmsis_gcc.h **** }
 440:../CMSIS/cmsis_gcc.h **** 
 441:../CMSIS/cmsis_gcc.h **** 
 442:../CMSIS/cmsis_gcc.h **** /**
 443:../CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 444:../CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 445:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 446:../CMSIS/cmsis_gcc.h ****  */
 447:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 448:../CMSIS/cmsis_gcc.h **** {
 449:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 450:../CMSIS/cmsis_gcc.h **** }
 451:../CMSIS/cmsis_gcc.h **** 
 452:../CMSIS/cmsis_gcc.h **** 
 453:../CMSIS/cmsis_gcc.h **** /**
 454:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 455:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 456:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 457:../CMSIS/cmsis_gcc.h ****  */
 458:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 459:../CMSIS/cmsis_gcc.h **** {
 460:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 461:../CMSIS/cmsis_gcc.h **** 
 462:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 463:../CMSIS/cmsis_gcc.h ****   return(result);
 464:../CMSIS/cmsis_gcc.h **** }
 465:../CMSIS/cmsis_gcc.h **** 
 466:../CMSIS/cmsis_gcc.h **** 
 467:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 468:../CMSIS/cmsis_gcc.h **** /**
 469:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 470:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 471:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 472:../CMSIS/cmsis_gcc.h ****  */
 473:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 474:../CMSIS/cmsis_gcc.h **** {
 475:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 476:../CMSIS/cmsis_gcc.h **** 
 477:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 478:../CMSIS/cmsis_gcc.h ****   return(result);
 479:../CMSIS/cmsis_gcc.h **** }
 480:../CMSIS/cmsis_gcc.h **** #endif
 481:../CMSIS/cmsis_gcc.h **** 
 482:../CMSIS/cmsis_gcc.h **** 
 483:../CMSIS/cmsis_gcc.h **** /**
 484:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 485:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 486:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 487:../CMSIS/cmsis_gcc.h ****  */
 488:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 489:../CMSIS/cmsis_gcc.h **** {
 490:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 491:../CMSIS/cmsis_gcc.h **** }
 492:../CMSIS/cmsis_gcc.h **** 
 493:../CMSIS/cmsis_gcc.h **** 
 494:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 495:../CMSIS/cmsis_gcc.h **** /**
 496:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 497:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 498:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 499:../CMSIS/cmsis_gcc.h ****  */
 500:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 501:../CMSIS/cmsis_gcc.h **** {
 502:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 503:../CMSIS/cmsis_gcc.h **** }
 504:../CMSIS/cmsis_gcc.h **** #endif
 505:../CMSIS/cmsis_gcc.h **** 
 506:../CMSIS/cmsis_gcc.h **** 
 507:../CMSIS/cmsis_gcc.h **** /**
 508:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 509:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 510:../CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 511:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 512:../CMSIS/cmsis_gcc.h ****  */
 513:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 514:../CMSIS/cmsis_gcc.h **** {
 515:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 516:../CMSIS/cmsis_gcc.h **** }
 517:../CMSIS/cmsis_gcc.h **** 
 518:../CMSIS/cmsis_gcc.h **** 
 519:../CMSIS/cmsis_gcc.h **** /**
 520:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 521:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 522:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 523:../CMSIS/cmsis_gcc.h ****  */
 524:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 525:../CMSIS/cmsis_gcc.h **** {
 526:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 527:../CMSIS/cmsis_gcc.h **** 
 528:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 529:../CMSIS/cmsis_gcc.h ****   return(result);
 530:../CMSIS/cmsis_gcc.h **** }
 531:../CMSIS/cmsis_gcc.h **** 
 532:../CMSIS/cmsis_gcc.h **** 
 533:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 534:../CMSIS/cmsis_gcc.h **** /**
 535:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 536:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 537:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 538:../CMSIS/cmsis_gcc.h ****  */
 539:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 540:../CMSIS/cmsis_gcc.h **** {
 541:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 542:../CMSIS/cmsis_gcc.h **** 
 543:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 544:../CMSIS/cmsis_gcc.h ****   return(result);
 545:../CMSIS/cmsis_gcc.h **** }
 546:../CMSIS/cmsis_gcc.h **** #endif
 547:../CMSIS/cmsis_gcc.h **** 
 548:../CMSIS/cmsis_gcc.h **** 
 549:../CMSIS/cmsis_gcc.h **** /**
 550:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 551:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 552:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 553:../CMSIS/cmsis_gcc.h ****  */
 554:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 555:../CMSIS/cmsis_gcc.h **** {
 556:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 557:../CMSIS/cmsis_gcc.h **** }
 558:../CMSIS/cmsis_gcc.h **** 
 559:../CMSIS/cmsis_gcc.h **** 
 560:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 561:../CMSIS/cmsis_gcc.h **** /**
 562:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 563:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 564:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 565:../CMSIS/cmsis_gcc.h ****  */
 566:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 567:../CMSIS/cmsis_gcc.h **** {
 568:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 569:../CMSIS/cmsis_gcc.h **** }
 570:../CMSIS/cmsis_gcc.h **** #endif
 571:../CMSIS/cmsis_gcc.h **** 
 572:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 573:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 574:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 575:../CMSIS/cmsis_gcc.h **** 
 576:../CMSIS/cmsis_gcc.h **** 
 577:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 578:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 579:../CMSIS/cmsis_gcc.h **** 
 580:../CMSIS/cmsis_gcc.h **** /**
 581:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 582:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 583:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 584:../CMSIS/cmsis_gcc.h ****  */
 585:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 586:../CMSIS/cmsis_gcc.h **** {
 587:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 588:../CMSIS/cmsis_gcc.h **** 
 589:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 590:../CMSIS/cmsis_gcc.h ****   return(result);
 591:../CMSIS/cmsis_gcc.h **** }
 592:../CMSIS/cmsis_gcc.h **** 
 593:../CMSIS/cmsis_gcc.h **** 
 594:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 595:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 596:../CMSIS/cmsis_gcc.h **** /**
 597:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 598:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 599:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 600:../CMSIS/cmsis_gcc.h ****  */
 601:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 602:../CMSIS/cmsis_gcc.h **** {
 603:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 604:../CMSIS/cmsis_gcc.h **** 
 605:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 606:../CMSIS/cmsis_gcc.h ****   return(result);
 607:../CMSIS/cmsis_gcc.h **** }
 608:../CMSIS/cmsis_gcc.h **** #endif
 609:../CMSIS/cmsis_gcc.h **** 
 610:../CMSIS/cmsis_gcc.h **** 
 611:../CMSIS/cmsis_gcc.h **** /**
 612:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 613:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 614:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 615:../CMSIS/cmsis_gcc.h ****  */
 616:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 617:../CMSIS/cmsis_gcc.h **** {
 618:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 619:../CMSIS/cmsis_gcc.h **** }
 620:../CMSIS/cmsis_gcc.h **** 
 621:../CMSIS/cmsis_gcc.h **** 
 622:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 623:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 624:../CMSIS/cmsis_gcc.h **** /**
 625:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 626:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 627:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 628:../CMSIS/cmsis_gcc.h ****  */
 629:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 630:../CMSIS/cmsis_gcc.h **** {
 631:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 632:../CMSIS/cmsis_gcc.h **** }
 633:../CMSIS/cmsis_gcc.h **** #endif
 634:../CMSIS/cmsis_gcc.h **** 
 635:../CMSIS/cmsis_gcc.h **** 
 636:../CMSIS/cmsis_gcc.h **** /**
 637:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 638:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 639:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 640:../CMSIS/cmsis_gcc.h ****  */
 641:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 642:../CMSIS/cmsis_gcc.h **** {
 643:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 644:../CMSIS/cmsis_gcc.h **** 
 645:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 646:../CMSIS/cmsis_gcc.h **** 
 647:../CMSIS/cmsis_gcc.h ****   return(result);
 648:../CMSIS/cmsis_gcc.h **** }
 649:../CMSIS/cmsis_gcc.h **** 
 650:../CMSIS/cmsis_gcc.h **** 
 651:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 652:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 653:../CMSIS/cmsis_gcc.h **** /**
 654:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 655:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 656:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 657:../CMSIS/cmsis_gcc.h ****  */
 658:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 659:../CMSIS/cmsis_gcc.h **** {
 660:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 661:../CMSIS/cmsis_gcc.h **** 
 662:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 663:../CMSIS/cmsis_gcc.h ****   return(result);
 664:../CMSIS/cmsis_gcc.h **** }
 665:../CMSIS/cmsis_gcc.h **** #endif
 666:../CMSIS/cmsis_gcc.h **** 
 667:../CMSIS/cmsis_gcc.h **** 
 668:../CMSIS/cmsis_gcc.h **** /**
 669:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 670:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 671:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 672:../CMSIS/cmsis_gcc.h ****  */
 673:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 674:../CMSIS/cmsis_gcc.h **** {
 675:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 676:../CMSIS/cmsis_gcc.h **** }
 677:../CMSIS/cmsis_gcc.h **** 
 678:../CMSIS/cmsis_gcc.h **** 
 679:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 680:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 681:../CMSIS/cmsis_gcc.h **** /**
 682:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 683:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 684:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 685:../CMSIS/cmsis_gcc.h ****  */
 686:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 687:../CMSIS/cmsis_gcc.h **** {
 688:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 689:../CMSIS/cmsis_gcc.h **** }
 690:../CMSIS/cmsis_gcc.h **** #endif
 691:../CMSIS/cmsis_gcc.h **** 
 692:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 693:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 694:../CMSIS/cmsis_gcc.h **** 
 695:../CMSIS/cmsis_gcc.h **** 
 696:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 697:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 698:../CMSIS/cmsis_gcc.h **** 
 699:../CMSIS/cmsis_gcc.h **** /**
 700:../CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 701:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 702:../CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 703:../CMSIS/cmsis_gcc.h ****  */
 704:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 705:../CMSIS/cmsis_gcc.h **** {
 706:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 707:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 708:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 709:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 710:../CMSIS/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 711:../CMSIS/cmsis_gcc.h **** #else
 712:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 713:../CMSIS/cmsis_gcc.h **** 
 714:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 715:../CMSIS/cmsis_gcc.h ****   return(result);
 716:../CMSIS/cmsis_gcc.h **** #endif
 717:../CMSIS/cmsis_gcc.h **** #else
 718:../CMSIS/cmsis_gcc.h ****   return(0U);
 719:../CMSIS/cmsis_gcc.h **** #endif
 720:../CMSIS/cmsis_gcc.h **** }
 721:../CMSIS/cmsis_gcc.h **** 
 722:../CMSIS/cmsis_gcc.h **** 
 723:../CMSIS/cmsis_gcc.h **** /**
 724:../CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 725:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 726:../CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 727:../CMSIS/cmsis_gcc.h ****  */
 728:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 729:../CMSIS/cmsis_gcc.h **** {
 730:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 731:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 732:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 733:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 734:../CMSIS/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 735:../CMSIS/cmsis_gcc.h **** #else
 736:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 737:../CMSIS/cmsis_gcc.h **** #endif
 738:../CMSIS/cmsis_gcc.h **** #else
 739:../CMSIS/cmsis_gcc.h ****   (void)fpscr;
 740:../CMSIS/cmsis_gcc.h **** #endif
 741:../CMSIS/cmsis_gcc.h **** }
 742:../CMSIS/cmsis_gcc.h **** 
 743:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 744:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 745:../CMSIS/cmsis_gcc.h **** 
 746:../CMSIS/cmsis_gcc.h **** 
 747:../CMSIS/cmsis_gcc.h **** 
 748:../CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 749:../CMSIS/cmsis_gcc.h **** 
 750:../CMSIS/cmsis_gcc.h **** 
 751:../CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 752:../CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 753:../CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 754:../CMSIS/cmsis_gcc.h ****   @{
 755:../CMSIS/cmsis_gcc.h **** */
 756:../CMSIS/cmsis_gcc.h **** 
 757:../CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 758:../CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 759:../CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 760:../CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 761:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 762:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 763:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 764:../CMSIS/cmsis_gcc.h **** #else
 765:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 766:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 767:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 768:../CMSIS/cmsis_gcc.h **** #endif
 769:../CMSIS/cmsis_gcc.h **** 
 770:../CMSIS/cmsis_gcc.h **** /**
 771:../CMSIS/cmsis_gcc.h ****   \brief   No Operation
 772:../CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 773:../CMSIS/cmsis_gcc.h ****  */
 774:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 775:../CMSIS/cmsis_gcc.h **** //{
 776:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("nop");
 777:../CMSIS/cmsis_gcc.h **** //}
 778:../CMSIS/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 779:../CMSIS/cmsis_gcc.h **** 
 780:../CMSIS/cmsis_gcc.h **** /**
 781:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Interrupt
 782:../CMSIS/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 783:../CMSIS/cmsis_gcc.h ****  */
 784:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 785:../CMSIS/cmsis_gcc.h **** //{
 786:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 787:../CMSIS/cmsis_gcc.h **** //}
 788:../CMSIS/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 789:../CMSIS/cmsis_gcc.h **** 
 790:../CMSIS/cmsis_gcc.h **** 
 791:../CMSIS/cmsis_gcc.h **** /**
 792:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Event
 793:../CMSIS/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 794:../CMSIS/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 795:../CMSIS/cmsis_gcc.h ****  */
 796:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 797:../CMSIS/cmsis_gcc.h **** //{
 798:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 799:../CMSIS/cmsis_gcc.h **** //}
 800:../CMSIS/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 801:../CMSIS/cmsis_gcc.h **** 
 802:../CMSIS/cmsis_gcc.h **** 
 803:../CMSIS/cmsis_gcc.h **** /**
 804:../CMSIS/cmsis_gcc.h ****   \brief   Send Event
 805:../CMSIS/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 806:../CMSIS/cmsis_gcc.h ****  */
 807:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 808:../CMSIS/cmsis_gcc.h **** //{
 809:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("sev");
 810:../CMSIS/cmsis_gcc.h **** //}
 811:../CMSIS/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 812:../CMSIS/cmsis_gcc.h **** 
 813:../CMSIS/cmsis_gcc.h **** 
 814:../CMSIS/cmsis_gcc.h **** /**
 815:../CMSIS/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 816:../CMSIS/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 817:../CMSIS/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 818:../CMSIS/cmsis_gcc.h ****            after the instruction has been completed.
 819:../CMSIS/cmsis_gcc.h ****  */
 820:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 821:../CMSIS/cmsis_gcc.h **** {
 822:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 823:../CMSIS/cmsis_gcc.h **** }
 824:../CMSIS/cmsis_gcc.h **** 
 825:../CMSIS/cmsis_gcc.h **** 
 826:../CMSIS/cmsis_gcc.h **** /**
 827:../CMSIS/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 828:../CMSIS/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 829:../CMSIS/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 830:../CMSIS/cmsis_gcc.h ****  */
 831:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 832:../CMSIS/cmsis_gcc.h **** {
 833:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 184              		.loc 3 833 0
 185              		.syntax unified
 186              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 187 0022 BFF34F8F 		dsb 0xF
 188              	@ 0 "" 2
 189              		.thumb
 190              		.syntax unified
 191 0026 38BD     		pop	{r3, r4, r5, pc}
 192              	.LVL13:
 193              	.L14:
 194              	.LBE45:
 195              	.LBE44:
2722:../drivers/fsl_enet.c ****         base->EIR = errMask;
 196              		.loc 1 2722 0
 197 0028 4568     		ldr	r5, [r0, #4]
 198 002a 25F01F45 		bic	r5, r5, #-1627389952
 199 002e 25F40005 		bic	r5, r5, #8388608
 200 0032 AD0C     		lsrs	r5, r5, #18
 201 0034 AD04     		lsls	r5, r5, #18
 202              	.LVL14:
2723:../drivers/fsl_enet.c ****         /* Callback function. */
 203              		.loc 1 2723 0
 204 0036 4560     		str	r5, [r0, #4]
2725:../drivers/fsl_enet.c ****         {
 205              		.loc 1 2725 0
 206 0038 002C     		cmp	r4, #0
 207 003a F2D0     		beq	.L16
 208              		.loc 1 2730 0
 209 003c 0B6A     		ldr	r3, [r1, #32]
 210 003e 0222     		movs	r2, #2
 211 0040 EEE7     		b	.L21
 212              		.cfi_endproc
 213              	.LFE182:
 215              		.section	.text.ENET_UpdateReadBuffers.constprop.3,"ax",%progbits
 216              		.align	1
 217              		.syntax unified
 218              		.thumb
 219              		.thumb_func
 220              		.fpu fpv4-sp-d16
 222              	ENET_UpdateReadBuffers.constprop.3:
 223              	.LFB194:
1285:../drivers/fsl_enet.c **** {
 224              		.loc 1 1285 0
 225              		.cfi_startproc
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              		@ link register save eliminated.
 229              	.LVL15:
1291:../drivers/fsl_enet.c ****     /* Sets the receive buffer descriptor with the empty flag. */
 230              		.loc 1 1291 0
 231 0000 4B68     		ldr	r3, [r1, #4]
 232 0002 5A88     		ldrh	r2, [r3, #2]
 233 0004 02F40052 		and	r2, r2, #8192
 234 0008 5A80     		strh	r2, [r3, #2]	@ movhi
1293:../drivers/fsl_enet.c **** 
 235              		.loc 1 1293 0
 236 000a 5A88     		ldrh	r2, [r3, #2]
 237 000c 6FEA4242 		mvn	r2, r2, lsl #17
 238 0010 6FEA5242 		mvn	r2, r2, lsr #17
 239 0014 92B2     		uxth	r2, r2
 240 0016 5A80     		strh	r2, [r3, #2]	@ movhi
1296:../drivers/fsl_enet.c ****     {
 241              		.loc 1 1296 0
 242 0018 5A88     		ldrh	r2, [r3, #2]
 243 001a 9204     		lsls	r2, r2, #18
1298:../drivers/fsl_enet.c ****     }
 244              		.loc 1 1298 0
 245 001c 4CBF     		ite	mi
 246 001e 0B68     		ldrmi	r3, [r1]
1302:../drivers/fsl_enet.c ****     }
 247              		.loc 1 1302 0
 248 0020 0833     		addpl	r3, r3, #8
 249 0022 4B60     		str	r3, [r1, #4]
1309:../drivers/fsl_enet.c ****             break;
 250              		.loc 1 1309 0
 251 0024 4FF08073 		mov	r3, #16777216
 252 0028 0361     		str	r3, [r0, #16]
 253 002a 7047     		bx	lr
 254              		.cfi_endproc
 255              	.LFE194:
 257              		.section	.text.ENET_GetInstance,"ax",%progbits
 258              		.align	1
 259              		.global	ENET_GetInstance
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
 263              		.fpu fpv4-sp-d16
 265              	ENET_GetInstance:
 266              	.LFB157:
 316:../drivers/fsl_enet.c ****     uint32_t instance;
 267              		.loc 1 316 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              		@ link register save eliminated.
 272              	.LVL16:
 331:../drivers/fsl_enet.c **** 
 273              		.loc 1 331 0
 274 0000 024B     		ldr	r3, .L27
 275 0002 C01A     		subs	r0, r0, r3
 276              	.LVL17:
 277 0004 18BF     		it	ne
 278 0006 0120     		movne	r0, #1
 279              	.LVL18:
 280 0008 7047     		bx	lr
 281              	.L28:
 282 000a 00BF     		.align	2
 283              	.L27:
 284 000c 00000C40 		.word	1074528256
 285              		.cfi_endproc
 286              	.LFE157:
 288              		.section	.text.ENET_GetDefaultConfig,"ax",%progbits
 289              		.align	1
 290              		.global	ENET_GetDefaultConfig
 291              		.syntax unified
 292              		.thumb
 293              		.thumb_func
 294              		.fpu fpv4-sp-d16
 296              	ENET_GetDefaultConfig:
 297              	.LFB158:
 334:../drivers/fsl_enet.c ****     /* Checks input parameter. */
 298              		.loc 1 334 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              	.LVL19:
 303 0000 10B5     		push	{r4, lr}
 304              		.cfi_def_cfa_offset 8
 305              		.cfi_offset 4, -8
 306              		.cfi_offset 14, -4
 339:../drivers/fsl_enet.c **** 
 307              		.loc 1 339 0
 308 0002 1822     		movs	r2, #24
 334:../drivers/fsl_enet.c ****     /* Checks input parameter. */
 309              		.loc 1 334 0
 310 0004 0446     		mov	r4, r0
 339:../drivers/fsl_enet.c **** 
 311              		.loc 1 339 0
 312 0006 0021     		movs	r1, #0
 313 0008 FFF7FEFF 		bl	memset
 314              	.LVL20:
 345:../drivers/fsl_enet.c **** #endif
 315              		.loc 1 345 0
 316 000c 0123     		movs	r3, #1
 317 000e A372     		strb	r3, [r4, #10]
 347:../drivers/fsl_enet.c ****     config->miiDuplex = kENET_MiiFullDuplex;
 318              		.loc 1 347 0
 319 0010 E372     		strb	r3, [r4, #11]
 348:../drivers/fsl_enet.c **** 
 320              		.loc 1 348 0
 321 0012 2373     		strb	r3, [r4, #12]
 350:../drivers/fsl_enet.c **** 
 322              		.loc 1 350 0
 323 0014 A375     		strb	r3, [r4, #22]
 353:../drivers/fsl_enet.c **** }
 324              		.loc 1 353 0
 325 0016 40F2EE53 		movw	r3, #1518
 326 001a 2381     		strh	r3, [r4, #8]	@ movhi
 327 001c 10BD     		pop	{r4, pc}
 328              		.cfi_endproc
 329              	.LFE158:
 331              		.section	.text.ENET_Deinit,"ax",%progbits
 332              		.align	1
 333              		.global	ENET_Deinit
 334              		.syntax unified
 335              		.thumb
 336              		.thumb_func
 337              		.fpu fpv4-sp-d16
 339              	ENET_Deinit:
 340              	.LFB160:
 404:../drivers/fsl_enet.c ****     /* Disable interrupt. */
 341              		.loc 1 404 0
 342              		.cfi_startproc
 343              		@ args = 0, pretend = 0, frame = 0
 344              		@ frame_needed = 0, uses_anonymous_args = 0
 345              		@ link register save eliminated.
 346              	.LVL21:
 406:../drivers/fsl_enet.c **** 
 347              		.loc 1 406 0
 348 0000 0023     		movs	r3, #0
 349 0002 8360     		str	r3, [r0, #8]
 409:../drivers/fsl_enet.c **** 
 350              		.loc 1 409 0
 351 0004 436A     		ldr	r3, [r0, #36]
 352              	.LBB48:
 353              	.LBB49:
 354              		.file 4 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 355              		.loc 4 706 0
 356 0006 044A     		ldr	r2, .L31
 357              	.LBE49:
 358              	.LBE48:
 409:../drivers/fsl_enet.c **** 
 359              		.loc 1 409 0
 360 0008 23F00203 		bic	r3, r3, #2
 361 000c 4362     		str	r3, [r0, #36]
 362              	.LVL22:
 363              	.LBB51:
 364              	.LBB50:
 365              		.loc 4 706 0
 366 000e 1368     		ldr	r3, [r2]
 367 0010 23F00103 		bic	r3, r3, #1
 368 0014 1360     		str	r3, [r2]
 369              	.LVL23:
 370 0016 7047     		bx	lr
 371              	.L32:
 372              		.align	2
 373              	.L31:
 374 0018 2C800440 		.word	1074036780
 375              	.LBE50:
 376              	.LBE51:
 377              		.cfi_endproc
 378              	.LFE160:
 380              		.section	.text.ENET_SetCallback,"ax",%progbits
 381              		.align	1
 382              		.global	ENET_SetCallback
 383              		.syntax unified
 384              		.thumb
 385              		.thumb_func
 386              		.fpu fpv4-sp-d16
 388              	ENET_SetCallback:
 389              	.LFB161:
 419:../drivers/fsl_enet.c ****     assert(handle);
 390              		.loc 1 419 0
 391              		.cfi_startproc
 392              		@ args = 0, pretend = 0, frame = 0
 393              		@ frame_needed = 0, uses_anonymous_args = 0
 394              		@ link register save eliminated.
 395              	.LVL24:
 423:../drivers/fsl_enet.c ****     handle->userData = userData;
 396              		.loc 1 423 0
 397 0000 C161     		str	r1, [r0, #28]
 424:../drivers/fsl_enet.c **** }
 398              		.loc 1 424 0
 399 0002 0262     		str	r2, [r0, #32]
 400 0004 7047     		bx	lr
 401              		.cfi_endproc
 402              	.LFE161:
 404              		.section	.text.ENET_SetMII,"ax",%progbits
 405              		.align	1
 406              		.global	ENET_SetMII
 407              		.syntax unified
 408              		.thumb
 409              		.thumb_func
 410              		.fpu fpv4-sp-d16
 412              	ENET_SetMII:
 413              	.LFB167:
 866:../drivers/fsl_enet.c ****     uint32_t rcr = base->RCR;
 414              		.loc 1 866 0
 415              		.cfi_startproc
 416              		@ args = 0, pretend = 0, frame = 0
 417              		@ frame_needed = 0, uses_anonymous_args = 0
 418              	.LVL25:
 419 0000 10B5     		push	{r4, lr}
 420              		.cfi_def_cfa_offset 8
 421              		.cfi_offset 4, -8
 422              		.cfi_offset 14, -4
 867:../drivers/fsl_enet.c ****     uint32_t tcr = base->TCR;
 423              		.loc 1 867 0
 424 0002 D0F88430 		ldr	r3, [r0, #132]
 425              	.LVL26:
 868:../drivers/fsl_enet.c **** 
 426              		.loc 1 868 0
 427 0006 D0F8C440 		ldr	r4, [r0, #196]
 428              	.LVL27:
 887:../drivers/fsl_enet.c ****     {
 429              		.loc 1 887 0
 430 000a 59B9     		cbnz	r1, .L35
 889:../drivers/fsl_enet.c ****     }
 431              		.loc 1 889 0
 432 000c 43F40073 		orr	r3, r3, #512
 433              	.LVL28:
 434              	.L36:
 896:../drivers/fsl_enet.c ****     {
 435              		.loc 1 896 0
 436 0010 5AB9     		cbnz	r2, .L37
 898:../drivers/fsl_enet.c ****         tcr &= ~ENET_TCR_FDEN_MASK;
 437              		.loc 1 898 0
 438 0012 43F00203 		orr	r3, r3, #2
 439              	.LVL29:
 899:../drivers/fsl_enet.c ****     }
 440              		.loc 1 899 0
 441 0016 24F00404 		bic	r4, r4, #4
 442              	.LVL30:
 443              	.L38:
 907:../drivers/fsl_enet.c ****     base->TCR = tcr;
 444              		.loc 1 907 0
 445 001a C0F88430 		str	r3, [r0, #132]
 908:../drivers/fsl_enet.c **** }
 446              		.loc 1 908 0
 447 001e C0F8C440 		str	r4, [r0, #196]
 448 0022 10BD     		pop	{r4, pc}
 449              	.LVL31:
 450              	.L35:
 893:../drivers/fsl_enet.c ****     }
 451              		.loc 1 893 0
 452 0024 23F40073 		bic	r3, r3, #512
 453              	.LVL32:
 454 0028 F2E7     		b	.L36
 455              	.L37:
 903:../drivers/fsl_enet.c ****         tcr |= ENET_TCR_FDEN_MASK;
 456              		.loc 1 903 0
 457 002a 23F00203 		bic	r3, r3, #2
 458              	.LVL33:
 904:../drivers/fsl_enet.c ****     }
 459              		.loc 1 904 0
 460 002e 44F00404 		orr	r4, r4, #4
 461              	.LVL34:
 462 0032 F2E7     		b	.L38
 463              		.cfi_endproc
 464              	.LFE167:
 466              		.section	.text.ENET_SetMacAddr,"ax",%progbits
 467              		.align	1
 468              		.global	ENET_SetMacAddr
 469              		.syntax unified
 470              		.thumb
 471              		.thumb_func
 472              		.fpu fpv4-sp-d16
 474              	ENET_SetMacAddr:
 475              	.LFB168:
 912:../drivers/fsl_enet.c ****     uint32_t address;
 476              		.loc 1 912 0
 477              		.cfi_startproc
 478              		@ args = 0, pretend = 0, frame = 0
 479              		@ frame_needed = 0, uses_anonymous_args = 0
 480              		@ link register save eliminated.
 481              	.LVL35:
 916:../drivers/fsl_enet.c ****                          (uint32_t)macAddr[3]);
 482              		.loc 1 916 0
 483 0000 4B78     		ldrb	r3, [r1, #1]	@ zero_extendqisi2
 484 0002 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 485 0004 1B04     		lsls	r3, r3, #16
 486 0006 43EA0263 		orr	r3, r3, r2, lsl #24
 917:../drivers/fsl_enet.c ****     base->PALR = address;
 487              		.loc 1 917 0
 488 000a CA78     		ldrb	r2, [r1, #3]	@ zero_extendqisi2
 916:../drivers/fsl_enet.c ****                          (uint32_t)macAddr[3]);
 489              		.loc 1 916 0
 490 000c 1343     		orrs	r3, r3, r2
 491 000e 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 492 0010 43EA0223 		orr	r3, r3, r2, lsl #8
 493              	.LVL36:
 918:../drivers/fsl_enet.c ****     /* Set physical address high register. */
 494              		.loc 1 918 0
 495 0014 C0F8E430 		str	r3, [r0, #228]
 496              	.LVL37:
 920:../drivers/fsl_enet.c ****     base->PAUR = address << ENET_PAUR_PADDR2_SHIFT;
 497              		.loc 1 920 0
 498 0018 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
 499 001a 4B79     		ldrb	r3, [r1, #5]	@ zero_extendqisi2
 500 001c 43EA0223 		orr	r3, r3, r2, lsl #8
 921:../drivers/fsl_enet.c **** }
 501              		.loc 1 921 0
 502 0020 1B04     		lsls	r3, r3, #16
 503 0022 C0F8E830 		str	r3, [r0, #232]
 504              	.LVL38:
 505 0026 7047     		bx	lr
 506              		.cfi_endproc
 507              	.LFE168:
 509              		.section	.text.ENET_GetMacAddr,"ax",%progbits
 510              		.align	1
 511              		.global	ENET_GetMacAddr
 512              		.syntax unified
 513              		.thumb
 514              		.thumb_func
 515              		.fpu fpv4-sp-d16
 517              	ENET_GetMacAddr:
 518              	.LFB169:
 925:../drivers/fsl_enet.c ****     assert(macAddr);
 519              		.loc 1 925 0
 520              		.cfi_startproc
 521              		@ args = 0, pretend = 0, frame = 0
 522              		@ frame_needed = 0, uses_anonymous_args = 0
 523              		@ link register save eliminated.
 524              	.LVL39:
 931:../drivers/fsl_enet.c ****     macAddr[0] = 0xFFU & (address >> 24U);
 525              		.loc 1 931 0
 526 0000 D0F8E430 		ldr	r3, [r0, #228]
 527              	.LVL40:
 935:../drivers/fsl_enet.c **** 
 528              		.loc 1 935 0
 529 0004 CB70     		strb	r3, [r1, #3]
 932:../drivers/fsl_enet.c ****     macAddr[1] = 0xFFU & (address >> 16U);
 530              		.loc 1 932 0
 531 0006 1A0E     		lsrs	r2, r3, #24
 532 0008 0A70     		strb	r2, [r1]
 933:../drivers/fsl_enet.c ****     macAddr[2] = 0xFFU & (address >> 8U);
 533              		.loc 1 933 0
 534 000a 1A0C     		lsrs	r2, r3, #16
 535 000c 4A70     		strb	r2, [r1, #1]
 934:../drivers/fsl_enet.c ****     macAddr[3] = 0xFFU & address;
 536              		.loc 1 934 0
 537 000e 1A0A     		lsrs	r2, r3, #8
 538 0010 8A70     		strb	r2, [r1, #2]
 938:../drivers/fsl_enet.c ****     macAddr[4] = 0xFFU & (address >> 8U);
 539              		.loc 1 938 0
 540 0012 D0F8E830 		ldr	r3, [r0, #232]
 541              	.LVL41:
 939:../drivers/fsl_enet.c ****     macAddr[5] = 0xFFU & address;
 542              		.loc 1 939 0
 543 0016 1A0E     		lsrs	r2, r3, #24
 938:../drivers/fsl_enet.c ****     macAddr[4] = 0xFFU & (address >> 8U);
 544              		.loc 1 938 0
 545 0018 1B0C     		lsrs	r3, r3, #16
 546              	.LVL42:
 939:../drivers/fsl_enet.c ****     macAddr[5] = 0xFFU & address;
 547              		.loc 1 939 0
 548 001a 0A71     		strb	r2, [r1, #4]
 940:../drivers/fsl_enet.c **** }
 549              		.loc 1 940 0
 550 001c 4B71     		strb	r3, [r1, #5]
 551 001e 7047     		bx	lr
 552              		.cfi_endproc
 553              	.LFE169:
 555              		.section	.text.ENET_SetSMI,"ax",%progbits
 556              		.align	1
 557              		.global	ENET_SetSMI
 558              		.syntax unified
 559              		.thumb
 560              		.thumb_func
 561              		.fpu fpv4-sp-d16
 563              	ENET_SetSMI:
 564              	.LFB170:
 944:../drivers/fsl_enet.c ****     assert(srcClock_Hz);
 565              		.loc 1 944 0
 566              		.cfi_startproc
 567              		@ args = 0, pretend = 0, frame = 0
 568              		@ frame_needed = 0, uses_anonymous_args = 0
 569              	.LVL43:
 570 0000 10B5     		push	{r4, lr}
 571              		.cfi_def_cfa_offset 8
 572              		.cfi_offset 4, -8
 573              		.cfi_offset 14, -4
 954:../drivers/fsl_enet.c ****     /* Build the configuration for MDC/MDIO control. */
 574              		.loc 1 954 0
 575 0002 0D4C     		ldr	r4, .L44
 576 0004 B4FBF1F4 		udiv	r4, r4, r1
 577              	.LVL44:
 578 0008 04F10903 		add	r3, r4, #9
 579 000c B3FBF4F3 		udiv	r3, r3, r4
 580 0010 013B     		subs	r3, r3, #1
 581              	.LVL45:
 956:../drivers/fsl_enet.c ****     base->MSCR = mscr;
 582              		.loc 1 956 0
 583 0012 1B02     		lsls	r3, r3, #8
 584              	.LVL46:
 952:../drivers/fsl_enet.c ****     /* Calculate the hold time on the MDIO output. */
 585              		.loc 1 952 0
 586 0014 094C     		ldr	r4, .L44+4
 587              	.LVL47:
 588 0016 B1FBF4F1 		udiv	r1, r1, r4
 589              	.LVL48:
 956:../drivers/fsl_enet.c ****     base->MSCR = mscr;
 590              		.loc 1 956 0
 591 001a 4900     		lsls	r1, r1, #1
 592              	.LVL49:
 593 001c 002A     		cmp	r2, #0
 594 001e 03F4E063 		and	r3, r3, #1792
 595 0022 01F07E01 		and	r1, r1, #126
 596 0026 43EA0103 		orr	r3, r3, r1
 597 002a 14BF     		ite	ne
 598 002c 8022     		movne	r2, #128
 599              	.LVL50:
 600 002e 0022     		moveq	r2, #0
 601 0030 1343     		orrs	r3, r3, r2
 602              	.LVL51:
 957:../drivers/fsl_enet.c **** }
 603              		.loc 1 957 0
 604 0032 4364     		str	r3, [r0, #68]
 605 0034 10BD     		pop	{r4, pc}
 606              	.L45:
 607 0036 00BF     		.align	2
 608              	.L44:
 609 0038 00CA9A3B 		.word	1000000000
 610 003c 404B4C00 		.word	5000000
 611              		.cfi_endproc
 612              	.LFE170:
 614              		.section	.text.ENET_Init,"ax",%progbits
 615              		.align	1
 616              		.global	ENET_Init
 617              		.syntax unified
 618              		.thumb
 619              		.thumb_func
 620              		.fpu fpv4-sp-d16
 622              	ENET_Init:
 623              	.LFB159:
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 624              		.loc 1 362 0
 625              		.cfi_startproc
 626              		@ args = 8, pretend = 0, frame = 8
 627              		@ frame_needed = 0, uses_anonymous_args = 0
 628              	.LVL52:
 629 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 630              		.cfi_def_cfa_offset 48
 631              		.cfi_offset 4, -36
 632              		.cfi_offset 5, -32
 633              		.cfi_offset 6, -28
 634              		.cfi_offset 7, -24
 635              		.cfi_offset 8, -20
 636              		.cfi_offset 9, -16
 637              		.cfi_offset 10, -12
 638              		.cfi_offset 11, -8
 639              		.cfi_offset 14, -4
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 640              		.loc 1 362 0
 641 0004 1546     		mov	r5, r2
 642              	.LVL53:
 643              	.LBB83:
 644              	.LBB84:
 695:../drivers/fsl_clock.h **** }
 645              		.loc 4 695 0
 646 0006 B04A     		ldr	r2, .L129
 647              	.LVL54:
 648              	.LBE84:
 649              	.LBE83:
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 650              		.loc 1 362 0
 651 0008 1E46     		mov	r6, r3
 652              	.LBB86:
 653              	.LBB85:
 695:../drivers/fsl_clock.h **** }
 654              		.loc 4 695 0
 655 000a 1368     		ldr	r3, [r2]
 656              	.LVL55:
 657 000c 43F00103 		orr	r3, r3, #1
 658 0010 1360     		str	r3, [r2]
 659              	.LVL56:
 660              	.LBE85:
 661              	.LBE86:
 662              	.LBB87:
 663              	.LBB88:
 745:../drivers/fsl_enet.h **** }
 664              		.loc 2 745 0
 665 0012 436A     		ldr	r3, [r0, #36]
 666 0014 43F00103 		orr	r3, r3, #1
 667 0018 4362     		str	r3, [r0, #36]
 668              	.LVL57:
 669 001a AB7D     		ldrb	r3, [r5, #22]	@ zero_extendqisi2
 670 001c C3EBC303 		rsb	r3, r3, r3, lsl #3
 671 0020 06EB830A 		add	r10, r6, r3, lsl #2
 672              	.LBE88:
 673              	.LBE87:
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 674              		.loc 1 362 0
 675 0024 0446     		mov	r4, r0
 676 0026 8946     		mov	r9, r1
 677              	.LVL58:
 678              	.LBB90:
 679              	.LBB89:
 745:../drivers/fsl_enet.h **** }
 680              		.loc 2 745 0
 681 0028 3346     		mov	r3, r6
 682              	.LBE89:
 683              	.LBE90:
 684              	.LBB91:
 685              	.LBB92:
 686              	.LBB93:
 743:../drivers/fsl_enet.c ****                 /* Sets the crc. */
 687              		.loc 1 743 0
 688 002a 4FF0000B 		mov	fp, #0
 745:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 689              		.loc 1 745 0
 690 002e 4FF48068 		mov	r8, #1024
 691              	.LVL59:
 692              	.L47:
 693              	.LBE93:
 727:../drivers/fsl_enet.c ****     {
 694              		.loc 1 727 0
 695 0032 5345     		cmp	r3, r10
 696 0034 40F01981 		bne	.L53
 697              	.LVL60:
 698 0038 A97D     		ldrb	r1, [r5, #22]	@ zero_extendqisi2
 699 003a 1C22     		movs	r2, #28
 700 003c 01FB0222 		mla	r2, r1, r2, r2
 701 0040 B218     		adds	r2, r6, r2
 702 0042 06F11C03 		add	r3, r6, #28
 703 0046 0092     		str	r2, [sp]
 704              	.LBE92:
 705              	.LBE91:
 706              	.LBB96:
 707              	.LBB97:
 708              	.LBB98:
 813:../drivers/fsl_enet.c **** 
 709              		.loc 1 813 0
 710 0048 4FF0000B 		mov	fp, #0
 816:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 711              		.loc 1 816 0
 712 004c 4FF40048 		mov	r8, #32768
 713              	.L54:
 714              	.LVL61:
 715              	.LBE98:
 784:../drivers/fsl_enet.c ****     {
 716              		.loc 1 784 0
 717 0050 009A     		ldr	r2, [sp]
 718 0052 9A42     		cmp	r2, r3
 719 0054 40F03081 		bne	.L60
 720              	.LVL62:
 721              	.LBE97:
 722              	.LBE96:
 723              	.LBB101:
 724              	.LBB102:
 492:../drivers/fsl_enet.c ****     uint32_t maxFrameLen = config->rxMaxFrameLen;
 725              		.loc 1 492 0
 726 0058 2968     		ldr	r1, [r5]
 491:../drivers/fsl_enet.c ****     uint32_t macSpecialConfig = config->macSpecialConfig;
 727              		.loc 1 491 0
 728 005a 676A     		ldr	r7, [r4, #36]
 729              	.LVL63:
 493:../drivers/fsl_enet.c **** 
 730              		.loc 1 493 0
 731 005c 2B89     		ldrh	r3, [r5, #8]
 732              	.LVL64:
 496:../drivers/fsl_enet.c ****     {
 733              		.loc 1 496 0
 734 005e 8805     		lsls	r0, r1, #22
 735 0060 06D5     		bpl	.L61
 498:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 736              		.loc 1 498 0
 737 0062 40F2F252 		movw	r2, #1522
 738 0066 40F2EE50 		movw	r0, #1518
 739 006a 8342     		cmp	r3, r0
 740 006c 98BF     		it	ls
 741 006e 1346     		movls	r3, r2
 742              	.LVL65:
 743              	.L61:
 511:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_CFEN_MASK : 0) |
 744              		.loc 1 511 0
 745 0070 11F0020F 		tst	r1, #2
 746 0074 0CBF     		ite	eq
 747 0076 4FF0000B 		moveq	fp, #0
 748 007a 4FF0804B 		movne	fp, #1073741824
 512:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_FCE_MASK : 0) |
 749              		.loc 1 512 0
 750 007e 11F00100 		ands	r0, r1, #1
 513:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxPadRemoveEnable) ? ENET_RCR_PADEN_MASK : 0) |
 751              		.loc 1 513 0
 752 0082 15BF     		itete	ne
 753 0084 4FF0200E 		movne	lr, #32
 754 0088 8646     		moveq	lr, r0
 512:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_FCE_MASK : 0) |
 755              		.loc 1 512 0
 756 008a 4FF4004C 		movne	ip, #32768
 757 008e 8446     		moveq	ip, r0
 514:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxBroadCastRejectEnable) ? ENET_RCR_BC_REJ_MASK : 0) |
 758              		.loc 1 514 0
 759 0090 11F0040F 		tst	r1, #4
 760 0094 0CBF     		ite	eq
 761 0096 4FF0000A 		moveq	r10, #0
 762 009a 4FF4805A 		movne	r10, #4096
 515:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlPromiscuousEnable) ? ENET_RCR_PROM_MASK : 0) |
 763              		.loc 1 515 0
 764 009e 11F0080F 		tst	r1, #8
 765 00a2 0CBF     		ite	eq
 766 00a4 0022     		moveq	r2, #0
 767 00a6 1022     		movne	r2, #16
 768 00a8 0092     		str	r2, [sp]
 517:../drivers/fsl_enet.c **** 
 769              		.loc 1 517 0
 770 00aa 884A     		ldr	r2, .L129+4
 771 00ac 02EA0343 		and	r3, r2, r3, lsl #16
 772              	.LVL66:
 516:../drivers/fsl_enet.c ****           ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD_MASK;    
 773              		.loc 1 516 0
 774 00b0 43EA0B03 		orr	r3, r3, fp
 775 00b4 43EA0C03 		orr	r3, r3, ip
 776 00b8 43EA0E03 		orr	r3, r3, lr
 777 00bc 009A     		ldr	r2, [sp]
 531:../drivers/fsl_enet.c ****         {
 778              		.loc 1 531 0
 779 00be 95F80AE0 		ldrb	lr, [r5, #10]	@ zero_extendqisi2
 516:../drivers/fsl_enet.c ****           ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD_MASK;    
 780              		.loc 1 516 0
 781 00c2 11F0800F 		tst	r1, #128
 782 00c6 43EA0A03 		orr	r3, r3, r10
 783 00ca 0CBF     		ite	eq
 784 00cc 4FF00008 		moveq	r8, #0
 785 00d0 4FF00808 		movne	r8, #8
 786 00d4 1343     		orrs	r3, r3, r2
 787 00d6 43EA0803 		orr	r3, r3, r8
 788              	.LVL67:
 531:../drivers/fsl_enet.c ****         {
 789              		.loc 1 531 0
 790 00da BEF1010F 		cmp	lr, #1
 539:../drivers/fsl_enet.c ****     {
 791              		.loc 1 539 0
 792 00de EA7A     		ldrb	r2, [r5, #11]	@ zero_extendqisi2
 530:../drivers/fsl_enet.c ****         if (config->miiMode == kENET_RmiiMode)
 793              		.loc 1 530 0
 794 00e0 14BF     		ite	ne
 795 00e2 43F48043 		orrne	r3, r3, #16384
 796              	.LVL68:
 533:../drivers/fsl_enet.c ****         }
 797              		.loc 1 533 0
 798 00e6 43F48243 		orreq	r3, r3, #16640
 799 00ea 43F00403 		orr	r3, r3, #4
 800              	.LVL69:
 539:../drivers/fsl_enet.c ****     {
 801              		.loc 1 539 0
 802 00ee 0AB9     		cbnz	r2, .L69
 541:../drivers/fsl_enet.c ****     }
 803              		.loc 1 541 0
 804 00f0 43F40073 		orr	r3, r3, #512
 805              	.LVL70:
 806              	.L69:
 551:../drivers/fsl_enet.c ****     {
 807              		.loc 1 551 0
 808 00f4 2A7B     		ldrb	r2, [r5, #12]	@ zero_extendqisi2
 809 00f6 0AB9     		cbnz	r2, .L70
 553:../drivers/fsl_enet.c ****     }
 810              		.loc 1 553 0
 811 00f8 43F00203 		orr	r3, r3, #2
 812              	.LVL71:
 813              	.L70:
 556:../drivers/fsl_enet.c ****     {
 814              		.loc 1 556 0
 815 00fc 11F4807F 		tst	r1, #256
 816 0100 06D0     		beq	.L71
 817 0102 BEF1010F 		cmp	lr, #1
 818              	.LVL72:
 819 0106 1CBF     		itt	ne
 820 0108 23F00203 		bicne	r3, r3, #2
 821              	.LVL73:
 559:../drivers/fsl_enet.c ****     }
 822              		.loc 1 559 0
 823 010c 43F00103 		orrne	r3, r3, #1
 824              	.LVL74:
 825              	.L71:
 561:../drivers/fsl_enet.c **** 
 826              		.loc 1 561 0
 827 0110 C4F88430 		str	r3, [r4, #132]
 564:../drivers/fsl_enet.c ****     tcr |= (config->miiDuplex ? ENET_TCR_FDEN_MASK : 0) |
 828              		.loc 1 564 0
 829 0114 D4F8C430 		ldr	r3, [r4, #196]
 830              	.LVL75:
 565:../drivers/fsl_enet.c ****            ((macSpecialConfig & kENET_ControlMacAddrInsert) ? ENET_TCR_ADDINS_MASK : 0);
 831              		.loc 1 565 0
 832 0118 002A     		cmp	r2, #0
 833 011a 0CBF     		ite	eq
 834 011c 4FF0000E 		moveq	lr, #0
 835 0120 4FF0040E 		movne	lr, #4
 564:../drivers/fsl_enet.c ****     tcr |= (config->miiDuplex ? ENET_TCR_FDEN_MASK : 0) |
 836              		.loc 1 564 0
 837 0124 23F48273 		bic	r3, r3, #260
 838              	.LVL76:
 566:../drivers/fsl_enet.c ****     base->TCR = tcr;
 839              		.loc 1 566 0
 840 0128 11F0100F 		tst	r1, #16
 841 012c 0CBF     		ite	eq
 842 012e 0022     		moveq	r2, #0
 843 0130 4FF48072 		movne	r2, #256
 844 0134 43EA0E03 		orr	r3, r3, lr
 845              	.LVL77:
 565:../drivers/fsl_enet.c ****            ((macSpecialConfig & kENET_ControlMacAddrInsert) ? ENET_TCR_ADDINS_MASK : 0);
 846              		.loc 1 565 0
 847 0138 1343     		orrs	r3, r3, r2
 848              	.LVL78:
 567:../drivers/fsl_enet.c **** 
 849              		.loc 1 567 0
 850 013a C4F8C430 		str	r3, [r4, #196]
 851              	.LVL79:
 570:../drivers/fsl_enet.c ****     base->RACC = config->rxAccelerConfig;
 852              		.loc 1 570 0
 853 013e 95F80EE0 		ldrb	lr, [r5, #14]	@ zero_extendqisi2
 854 0142 C4F8C0E1 		str	lr, [r4, #448]
 571:../drivers/fsl_enet.c **** 
 855              		.loc 1 571 0
 856 0146 6A7B     		ldrb	r2, [r5, #13]	@ zero_extendqisi2
 857 0148 C4F8C421 		str	r2, [r4, #452]
 574:../drivers/fsl_enet.c ****     {
 858              		.loc 1 574 0
 859 014c 50B1     		cbz	r0, .L74
 860              	.LBB103:
 577:../drivers/fsl_enet.c ****         reemReg = ENET_RSEM_RX_SECTION_EMPTY(config->rxFifoEmptyThreshold);
 861              		.loc 1 577 0
 862 014e 2B8A     		ldrh	r3, [r5, #16]
 863              	.LVL80:
 864 0150 C4F8EC30 		str	r3, [r4, #236]
 580:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 865              		.loc 1 580 0
 866 0154 EB7C     		ldrb	r3, [r5, #19]	@ zero_extendqisi2
 578:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_T
 867              		.loc 1 578 0
 868 0156 A87C     		ldrb	r0, [r5, #18]	@ zero_extendqisi2
 869              	.LVL81:
 580:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 870              		.loc 1 580 0
 871 0158 1B04     		lsls	r3, r3, #16
 872 015a 03F4F813 		and	r3, r3, #2031616
 873 015e 0343     		orrs	r3, r3, r0
 874              	.LVL82:
 582:../drivers/fsl_enet.c ****     }
 875              		.loc 1 582 0
 876 0160 C4F89431 		str	r3, [r4, #404]
 877              	.LVL83:
 878              	.L74:
 879              	.LBE103:
 586:../drivers/fsl_enet.c ****     {
 880              		.loc 1 586 0
 881 0164 11F02001 		ands	r1, r1, #32
 882              	.LVL84:
 589:../drivers/fsl_enet.c ****         /* Receive fifo full threshold settings. */
 883              		.loc 1 589 0
 884 0168 1FBF     		itttt	ne
 885 016a 6B7D     		ldrbne	r3, [r5, #21]	@ zero_extendqisi2
 886 016c 03F03F03 		andne	r3, r3, #63
 887 0170 C4F84431 		strne	r3, [r4, #324]
 591:../drivers/fsl_enet.c ****     }
 888              		.loc 1 591 0
 889 0174 2B7D     		ldrbne	r3, [r5, #20]	@ zero_extendqisi2
 890 0176 11BF     		iteee	ne
 891 0178 C4F89031 		strne	r3, [r4, #400]
 596:../drivers/fsl_enet.c ****         base->RSFL = 0;
 892              		.loc 1 596 0
 893 017c 4FF48073 		moveq	r3, #256
 894 0180 C4F84431 		streq	r3, [r4, #324]
 597:../drivers/fsl_enet.c ****     }
 895              		.loc 1 597 0
 896 0184 C4F89011 		streq	r1, [r4, #400]
 601:../drivers/fsl_enet.c ****     {
 897              		.loc 1 601 0
 898 0188 1EF0180F 		tst	lr, #24
 603:../drivers/fsl_enet.c ****     }
 899              		.loc 1 603 0
 900 018c 1CBF     		itt	ne
 901 018e 4FF48073 		movne	r3, #256
 902 0192 C4F84431 		strne	r3, [r4, #324]
 605:../drivers/fsl_enet.c ****     {
 903              		.loc 1 605 0
 904 0196 12F0060F 		tst	r2, #6
 607:../drivers/fsl_enet.c ****     }
 905              		.loc 1 607 0
 906 019a 1CBF     		itt	ne
 907 019c 0023     		movne	r3, #0
 908 019e C4F89031 		strne	r3, [r4, #400]
 615:../drivers/fsl_enet.c ****     base->RDSR = (uint32_t)bufferConfig->rxBdStartAddrAlign;
 909              		.loc 1 615 0
 910 01a2 3369     		ldr	r3, [r6, #16]
 911 01a4 C4F88431 		str	r3, [r4, #388]
 616:../drivers/fsl_enet.c **** #endif    
 912              		.loc 1 616 0
 913 01a8 F368     		ldr	r3, [r6, #12]
 914 01aa C4F88031 		str	r3, [r4, #384]
 618:../drivers/fsl_enet.c **** 
 915              		.loc 1 618 0
 916 01ae 7368     		ldr	r3, [r6, #4]
 917 01b0 C4F88831 		str	r3, [r4, #392]
 662:../drivers/fsl_enet.c **** 
 918              		.loc 1 662 0
 919 01b4 0C99     		ldr	r1, [sp, #48]
 920 01b6 2046     		mov	r0, r4
 921 01b8 FFF7FEFF 		bl	ENET_SetMacAddr
 922              	.LVL85:
 923              	.LBB104:
 924              	.LBB105:
 788:../drivers/fsl_enet.h **** }
 925              		.loc 2 788 0
 926 01bc 636C     		ldr	r3, [r4, #68]
 927              	.LVL86:
 928              	.LBE105:
 929              	.LBE104:
 665:../drivers/fsl_enet.c ****     {
 930              		.loc 1 665 0
 931 01be 13F07E0F 		tst	r3, #126
 932 01c2 06D1     		bne	.L79
 933              	.LVL87:
 667:../drivers/fsl_enet.c ****     }
 934              		.loc 1 667 0
 935 01c4 2A68     		ldr	r2, [r5]
 936 01c6 0D99     		ldr	r1, [sp, #52]
 937 01c8 C2F38012 		ubfx	r2, r2, #6, #1
 938 01cc 2046     		mov	r0, r4
 939              	.LVL88:
 940 01ce FFF7FEFF 		bl	ENET_SetSMI
 941              	.LVL89:
 942              	.L79:
 943              	.LBB106:
 944              	.LBB107:
1012:../drivers/fsl_enet.h ****     }
1013:../drivers/fsl_enet.h **** }
1014:../drivers/fsl_enet.h **** 
1015:../drivers/fsl_enet.h **** /*!
1016:../drivers/fsl_enet.h ****  * @brief Gets ENET transmit and receive accelerator functions from MAC controller.
1017:../drivers/fsl_enet.h ****  *
1018:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
1019:../drivers/fsl_enet.h ****  * @param txAccelOption The transmit accelerator option. The "enet_tx_accelerator_t" is
1020:../drivers/fsl_enet.h ****  *         recommended to be used to as the mask to get the exact the accelerator option.
1021:../drivers/fsl_enet.h ****  * @param rxAccelOption The receive accelerator option. The "enet_rx_accelerator_t" is
1022:../drivers/fsl_enet.h ****  *         recommended to be used to as the mask to get the exact the accelerator option.
1023:../drivers/fsl_enet.h ****  */
1024:../drivers/fsl_enet.h **** static inline void ENET_GetAccelFunction(ENET_Type *base, uint32_t *txAccelOption, uint32_t *rxAcce
1025:../drivers/fsl_enet.h **** {
1026:../drivers/fsl_enet.h ****     assert(txAccelOption);
1027:../drivers/fsl_enet.h ****     assert(txAccelOption);
1028:../drivers/fsl_enet.h **** 
1029:../drivers/fsl_enet.h ****     *txAccelOption = base->TACC;
1030:../drivers/fsl_enet.h ****     *rxAccelOption = base->RACC;
1031:../drivers/fsl_enet.h **** }
1032:../drivers/fsl_enet.h **** 
1033:../drivers/fsl_enet.h **** /* @} */
1034:../drivers/fsl_enet.h **** 
1035:../drivers/fsl_enet.h **** /*!
1036:../drivers/fsl_enet.h ****  * @name Interrupts.
1037:../drivers/fsl_enet.h ****  * @{
1038:../drivers/fsl_enet.h ****  */
1039:../drivers/fsl_enet.h **** 
1040:../drivers/fsl_enet.h **** /*!
1041:../drivers/fsl_enet.h ****  * @brief Enables the ENET interrupt.
1042:../drivers/fsl_enet.h ****  *
1043:../drivers/fsl_enet.h ****  * This function enables the ENET interrupt according to the provided mask. The mask
1044:../drivers/fsl_enet.h ****  * is a logical OR of enumeration members. See @ref enet_interrupt_enable_t.
1045:../drivers/fsl_enet.h ****  * For example, to enable the TX frame interrupt and RX frame interrupt, do the following.
1046:../drivers/fsl_enet.h ****  * @code
1047:../drivers/fsl_enet.h ****  *     ENET_EnableInterrupts(ENET, kENET_TxFrameInterrupt | kENET_RxFrameInterrupt);
1048:../drivers/fsl_enet.h ****  * @endcode
1049:../drivers/fsl_enet.h ****  *
1050:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
1051:../drivers/fsl_enet.h ****  * @param mask  ENET interrupts to enable. This is a logical OR of the
1052:../drivers/fsl_enet.h ****  *             enumeration :: enet_interrupt_enable_t.
1053:../drivers/fsl_enet.h ****  */
1054:../drivers/fsl_enet.h **** static inline void ENET_EnableInterrupts(ENET_Type *base, uint32_t mask)
1055:../drivers/fsl_enet.h **** {
1056:../drivers/fsl_enet.h ****     base->EIMR |= mask;
 945              		.loc 2 1056 0
 946 01d2 6A68     		ldr	r2, [r5, #4]
 947 01d4 A368     		ldr	r3, [r4, #8]
 948              	.LBE107:
 949              	.LBE106:
 710:../drivers/fsl_enet.c ****     base->ECR = ecr;
 950              		.loc 1 710 0
 951 01d6 47F48177 		orr	r7, r7, #258
 952              	.LVL90:
 953              	.LBB109:
 954              	.LBB108:
 955              		.loc 2 1056 0
 956 01da 1343     		orrs	r3, r3, r2
 957 01dc A360     		str	r3, [r4, #8]
 958              	.LVL91:
 959              	.LBE108:
 960              	.LBE109:
 961              	.LBE102:
 962              	.LBE101:
 963              	.LBB111:
 964              	.LBB112:
 433:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 965              		.loc 1 433 0
 966 01de 2046     		mov	r0, r4
 967              	.LVL92:
 968              	.LBE112:
 969              	.LBE111:
 970              	.LBB123:
 971              	.LBB110:
 711:../drivers/fsl_enet.c **** }
 972              		.loc 1 711 0
 973 01e0 6762     		str	r7, [r4, #36]
 974              	.LVL93:
 975              	.LBE110:
 976              	.LBE123:
 977              	.LBB124:
 978              	.LBB122:
 433:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 979              		.loc 1 433 0
 980 01e2 FFF7FEFF 		bl	ENET_GetInstance
 981              	.LVL94:
 437:../drivers/fsl_enet.c **** 
 982              		.loc 1 437 0
 983 01e6 2422     		movs	r2, #36
 433:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 984              		.loc 1 433 0
 985 01e8 0446     		mov	r4, r0
 986              	.LVL95:
 437:../drivers/fsl_enet.c **** 
 987              		.loc 1 437 0
 988 01ea 0021     		movs	r1, #0
 989 01ec 4846     		mov	r0, r9
 990              	.LVL96:
 991 01ee FFF7FEFF 		bl	memset
 992              	.LVL97:
 439:../drivers/fsl_enet.c ****     for (count = 0; count < handle->ringNum; count++)
 993              		.loc 1 439 0
 994 01f2 AB7D     		ldrb	r3, [r5, #22]	@ zero_extendqisi2
 995 01f4 012B     		cmp	r3, #1
 996 01f6 28BF     		it	cs
 997 01f8 0123     		movcs	r3, #1
 998 01fa 89F81830 		strb	r3, [r9, #24]
 999              	.LVL98:
 440:../drivers/fsl_enet.c ****     {
 1000              		.loc 1 440 0
 1001 01fe 7BB1     		cbz	r3, .L80
 442:../drivers/fsl_enet.c ****         handle->rxBdCurrent[count] = buffCfg->rxBdStartAddrAlign;
 1002              		.loc 1 442 0
 1003 0200 F368     		ldr	r3, [r6, #12]
 1004 0202 C9F80030 		str	r3, [r9]
 443:../drivers/fsl_enet.c ****         handle->rxBuffSizeAlign[count] = buffCfg->rxBuffSizeAlign;
 1005              		.loc 1 443 0
 1006 0206 C9F80430 		str	r3, [r9, #4]
 444:../drivers/fsl_enet.c ****         handle->txBdBase[count] = buffCfg->txBdStartAddrAlign;
 1007              		.loc 1 444 0
 1008 020a 7368     		ldr	r3, [r6, #4]
 1009 020c C9F81030 		str	r3, [r9, #16]
 445:../drivers/fsl_enet.c ****         handle->txBdCurrent[count] = buffCfg->txBdStartAddrAlign;
 1010              		.loc 1 445 0
 1011 0210 3369     		ldr	r3, [r6, #16]
 1012 0212 C9F80830 		str	r3, [r9, #8]
 446:../drivers/fsl_enet.c ****         handle->txBuffSizeAlign[count] = buffCfg->txBuffSizeAlign;
 1013              		.loc 1 446 0
 1014 0216 C9F80C30 		str	r3, [r9, #12]
 447:../drivers/fsl_enet.c ****         buffCfg++;
 1015              		.loc 1 447 0
 1016 021a B368     		ldr	r3, [r6, #8]
 1017 021c C9F81430 		str	r3, [r9, #20]
 1018              	.LVL99:
 1019              	.L80:
 452:../drivers/fsl_enet.c **** 
 1020              		.loc 1 452 0
 1021 0220 2B4B     		ldr	r3, .L129+8
 1022 0222 43F82490 		str	r9, [r3, r4, lsl #2]
 455:../drivers/fsl_enet.c ****     {
 1023              		.loc 1 455 0
 1024 0226 6B68     		ldr	r3, [r5, #4]
 1025 0228 13F0406F 		tst	r3, #201326592
 1026 022c 06D0     		beq	.L81
 457:../drivers/fsl_enet.c ****         EnableIRQ(s_enetTxIrqId[instance]);
 1027              		.loc 1 457 0
 1028 022e 294A     		ldr	r2, .L129+12
 1029 0230 2949     		ldr	r1, .L129+16
 1030 0232 1160     		str	r1, [r2]
 1031              	.LVL100:
 1032              	.LBB113:
 1033              	.LBB114:
 1034              	.LBB115:
 1035              		.file 5 "../CMSIS/core_cm4.h"
   1:../CMSIS/core_cm4.h **** /**************************************************************************//**
   2:../CMSIS/core_cm4.h ****  * @file     core_cm4.h
   3:../CMSIS/core_cm4.h ****  * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm4.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm4.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm4.h ****  ******************************************************************************/
   7:../CMSIS/core_cm4.h **** /*
   8:../CMSIS/core_cm4.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm4.h ****  *
  10:../CMSIS/core_cm4.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm4.h ****  *
  12:../CMSIS/core_cm4.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm4.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm4.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm4.h ****  *
  16:../CMSIS/core_cm4.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm4.h ****  *
  18:../CMSIS/core_cm4.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm4.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm4.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm4.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm4.h ****  * limitations under the License.
  23:../CMSIS/core_cm4.h ****  */
  24:../CMSIS/core_cm4.h **** 
  25:../CMSIS/core_cm4.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm4.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm4.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm4.h **** #endif
  30:../CMSIS/core_cm4.h **** 
  31:../CMSIS/core_cm4.h **** #ifndef __CORE_CM4_H_GENERIC
  32:../CMSIS/core_cm4.h **** #define __CORE_CM4_H_GENERIC
  33:../CMSIS/core_cm4.h **** 
  34:../CMSIS/core_cm4.h **** #include <stdint.h>
  35:../CMSIS/core_cm4.h **** 
  36:../CMSIS/core_cm4.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm4.h ****  extern "C" {
  38:../CMSIS/core_cm4.h **** #endif
  39:../CMSIS/core_cm4.h **** 
  40:../CMSIS/core_cm4.h **** /**
  41:../CMSIS/core_cm4.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm4.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm4.h **** 
  44:../CMSIS/core_cm4.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm4.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm4.h **** 
  47:../CMSIS/core_cm4.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm4.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm4.h **** 
  50:../CMSIS/core_cm4.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm4.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm4.h ****  */
  53:../CMSIS/core_cm4.h **** 
  54:../CMSIS/core_cm4.h **** 
  55:../CMSIS/core_cm4.h **** /*******************************************************************************
  56:../CMSIS/core_cm4.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm4.h ****  ******************************************************************************/
  58:../CMSIS/core_cm4.h **** /**
  59:../CMSIS/core_cm4.h ****   \ingroup Cortex_M4
  60:../CMSIS/core_cm4.h ****   @{
  61:../CMSIS/core_cm4.h ****  */
  62:../CMSIS/core_cm4.h **** 
  63:../CMSIS/core_cm4.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm4.h ****  
  65:../CMSIS/core_cm4.h **** /* CMSIS CM4 definitions */
  66:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm4.h ****                                     __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:../CMSIS/core_cm4.h **** 
  71:../CMSIS/core_cm4.h **** #define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
  72:../CMSIS/core_cm4.h **** 
  73:../CMSIS/core_cm4.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm4.h ****     For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and fun
  75:../CMSIS/core_cm4.h **** */
  76:../CMSIS/core_cm4.h **** #if defined ( __CC_ARM )
  77:../CMSIS/core_cm4.h ****   #if defined __TARGET_FPU_VFP
  78:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  79:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
  80:../CMSIS/core_cm4.h ****     #else
  81:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
  82:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
  83:../CMSIS/core_cm4.h ****     #endif
  84:../CMSIS/core_cm4.h ****   #else
  85:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
  86:../CMSIS/core_cm4.h ****   #endif
  87:../CMSIS/core_cm4.h **** 
  88:../CMSIS/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  89:../CMSIS/core_cm4.h ****   #if defined __ARM_PCS_VFP
  90:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  91:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
  92:../CMSIS/core_cm4.h ****     #else
  93:../CMSIS/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
  94:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
  95:../CMSIS/core_cm4.h ****     #endif
  96:../CMSIS/core_cm4.h ****   #else
  97:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
  98:../CMSIS/core_cm4.h ****   #endif
  99:../CMSIS/core_cm4.h **** 
 100:../CMSIS/core_cm4.h **** #elif defined ( __GNUC__ )
 101:../CMSIS/core_cm4.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 102:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 103:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 104:../CMSIS/core_cm4.h ****     #else
 105:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 106:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 107:../CMSIS/core_cm4.h ****     #endif
 108:../CMSIS/core_cm4.h ****   #else
 109:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 110:../CMSIS/core_cm4.h ****   #endif
 111:../CMSIS/core_cm4.h **** 
 112:../CMSIS/core_cm4.h **** #elif defined ( __ICCARM__ )
 113:../CMSIS/core_cm4.h ****   #if defined __ARMVFP__
 114:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 115:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 116:../CMSIS/core_cm4.h ****     #else
 117:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 118:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 119:../CMSIS/core_cm4.h ****     #endif
 120:../CMSIS/core_cm4.h ****   #else
 121:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 122:../CMSIS/core_cm4.h ****   #endif
 123:../CMSIS/core_cm4.h **** 
 124:../CMSIS/core_cm4.h **** #elif defined ( __TI_ARM__ )
 125:../CMSIS/core_cm4.h ****   #if defined __TI_VFP_SUPPORT__
 126:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 127:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 128:../CMSIS/core_cm4.h ****     #else
 129:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 130:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 131:../CMSIS/core_cm4.h ****     #endif
 132:../CMSIS/core_cm4.h ****   #else
 133:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 134:../CMSIS/core_cm4.h ****   #endif
 135:../CMSIS/core_cm4.h **** 
 136:../CMSIS/core_cm4.h **** #elif defined ( __TASKING__ )
 137:../CMSIS/core_cm4.h ****   #if defined __FPU_VFP__
 138:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 139:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 140:../CMSIS/core_cm4.h ****     #else
 141:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 142:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 143:../CMSIS/core_cm4.h ****     #endif
 144:../CMSIS/core_cm4.h ****   #else
 145:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 146:../CMSIS/core_cm4.h ****   #endif
 147:../CMSIS/core_cm4.h **** 
 148:../CMSIS/core_cm4.h **** #elif defined ( __CSMC__ )
 149:../CMSIS/core_cm4.h ****   #if ( __CSMC__ & 0x400U)
 150:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 151:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 152:../CMSIS/core_cm4.h ****     #else
 153:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 154:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 155:../CMSIS/core_cm4.h ****     #endif
 156:../CMSIS/core_cm4.h ****   #else
 157:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 158:../CMSIS/core_cm4.h ****   #endif
 159:../CMSIS/core_cm4.h **** 
 160:../CMSIS/core_cm4.h **** #endif
 161:../CMSIS/core_cm4.h **** 
 162:../CMSIS/core_cm4.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 163:../CMSIS/core_cm4.h **** 
 164:../CMSIS/core_cm4.h **** 
 165:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 166:../CMSIS/core_cm4.h **** }
 167:../CMSIS/core_cm4.h **** #endif
 168:../CMSIS/core_cm4.h **** 
 169:../CMSIS/core_cm4.h **** #endif /* __CORE_CM4_H_GENERIC */
 170:../CMSIS/core_cm4.h **** 
 171:../CMSIS/core_cm4.h **** #ifndef __CMSIS_GENERIC
 172:../CMSIS/core_cm4.h **** 
 173:../CMSIS/core_cm4.h **** #ifndef __CORE_CM4_H_DEPENDANT
 174:../CMSIS/core_cm4.h **** #define __CORE_CM4_H_DEPENDANT
 175:../CMSIS/core_cm4.h **** 
 176:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 177:../CMSIS/core_cm4.h ****  extern "C" {
 178:../CMSIS/core_cm4.h **** #endif
 179:../CMSIS/core_cm4.h **** 
 180:../CMSIS/core_cm4.h **** /* check device defines and use defaults */
 181:../CMSIS/core_cm4.h **** #if defined __CHECK_DEVICE_DEFINES
 182:../CMSIS/core_cm4.h ****   #ifndef __CM4_REV
 183:../CMSIS/core_cm4.h ****     #define __CM4_REV               0x0000U
 184:../CMSIS/core_cm4.h ****     #warning "__CM4_REV not defined in device header file; using default!"
 185:../CMSIS/core_cm4.h ****   #endif
 186:../CMSIS/core_cm4.h **** 
 187:../CMSIS/core_cm4.h ****   #ifndef __FPU_PRESENT
 188:../CMSIS/core_cm4.h ****     #define __FPU_PRESENT             0U
 189:../CMSIS/core_cm4.h ****     #warning "__FPU_PRESENT not defined in device header file; using default!"
 190:../CMSIS/core_cm4.h ****   #endif
 191:../CMSIS/core_cm4.h **** 
 192:../CMSIS/core_cm4.h ****   #ifndef __MPU_PRESENT
 193:../CMSIS/core_cm4.h ****     #define __MPU_PRESENT             0U
 194:../CMSIS/core_cm4.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 195:../CMSIS/core_cm4.h ****   #endif
 196:../CMSIS/core_cm4.h **** 
 197:../CMSIS/core_cm4.h ****   #ifndef __NVIC_PRIO_BITS
 198:../CMSIS/core_cm4.h ****     #define __NVIC_PRIO_BITS          3U
 199:../CMSIS/core_cm4.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 200:../CMSIS/core_cm4.h ****   #endif
 201:../CMSIS/core_cm4.h **** 
 202:../CMSIS/core_cm4.h ****   #ifndef __Vendor_SysTickConfig
 203:../CMSIS/core_cm4.h ****     #define __Vendor_SysTickConfig    0U
 204:../CMSIS/core_cm4.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 205:../CMSIS/core_cm4.h ****   #endif
 206:../CMSIS/core_cm4.h **** #endif
 207:../CMSIS/core_cm4.h **** 
 208:../CMSIS/core_cm4.h **** /* IO definitions (access restrictions to peripheral registers) */
 209:../CMSIS/core_cm4.h **** /**
 210:../CMSIS/core_cm4.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 211:../CMSIS/core_cm4.h **** 
 212:../CMSIS/core_cm4.h ****     <strong>IO Type Qualifiers</strong> are used
 213:../CMSIS/core_cm4.h ****     \li to specify the access to peripheral variables.
 214:../CMSIS/core_cm4.h ****     \li for automatic generation of peripheral register debug information.
 215:../CMSIS/core_cm4.h **** */
 216:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 217:../CMSIS/core_cm4.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 218:../CMSIS/core_cm4.h **** #else
 219:../CMSIS/core_cm4.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 220:../CMSIS/core_cm4.h **** #endif
 221:../CMSIS/core_cm4.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 222:../CMSIS/core_cm4.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 223:../CMSIS/core_cm4.h **** 
 224:../CMSIS/core_cm4.h **** /* following defines should be used for structure members */
 225:../CMSIS/core_cm4.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 226:../CMSIS/core_cm4.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 227:../CMSIS/core_cm4.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 228:../CMSIS/core_cm4.h **** 
 229:../CMSIS/core_cm4.h **** /*@} end of group Cortex_M4 */
 230:../CMSIS/core_cm4.h **** 
 231:../CMSIS/core_cm4.h **** 
 232:../CMSIS/core_cm4.h **** 
 233:../CMSIS/core_cm4.h **** /*******************************************************************************
 234:../CMSIS/core_cm4.h ****  *                 Register Abstraction
 235:../CMSIS/core_cm4.h ****   Core Register contain:
 236:../CMSIS/core_cm4.h ****   - Core Register
 237:../CMSIS/core_cm4.h ****   - Core NVIC Register
 238:../CMSIS/core_cm4.h ****   - Core SCB Register
 239:../CMSIS/core_cm4.h ****   - Core SysTick Register
 240:../CMSIS/core_cm4.h ****   - Core Debug Register
 241:../CMSIS/core_cm4.h ****   - Core MPU Register
 242:../CMSIS/core_cm4.h ****   - Core FPU Register
 243:../CMSIS/core_cm4.h ****  ******************************************************************************/
 244:../CMSIS/core_cm4.h **** /**
 245:../CMSIS/core_cm4.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 246:../CMSIS/core_cm4.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 247:../CMSIS/core_cm4.h **** */
 248:../CMSIS/core_cm4.h **** 
 249:../CMSIS/core_cm4.h **** /**
 250:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
 251:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 252:../CMSIS/core_cm4.h ****   \brief      Core Register type definitions.
 253:../CMSIS/core_cm4.h ****   @{
 254:../CMSIS/core_cm4.h ****  */
 255:../CMSIS/core_cm4.h **** 
 256:../CMSIS/core_cm4.h **** /**
 257:../CMSIS/core_cm4.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 258:../CMSIS/core_cm4.h ****  */
 259:../CMSIS/core_cm4.h **** typedef union
 260:../CMSIS/core_cm4.h **** {
 261:../CMSIS/core_cm4.h ****   struct
 262:../CMSIS/core_cm4.h ****   {
 263:../CMSIS/core_cm4.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
 264:../CMSIS/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 265:../CMSIS/core_cm4.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
 266:../CMSIS/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 267:../CMSIS/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 268:../CMSIS/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 269:../CMSIS/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 270:../CMSIS/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 271:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 272:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 273:../CMSIS/core_cm4.h **** } APSR_Type;
 274:../CMSIS/core_cm4.h **** 
 275:../CMSIS/core_cm4.h **** /* APSR Register Definitions */
 276:../CMSIS/core_cm4.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 277:../CMSIS/core_cm4.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 278:../CMSIS/core_cm4.h **** 
 279:../CMSIS/core_cm4.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 280:../CMSIS/core_cm4.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 281:../CMSIS/core_cm4.h **** 
 282:../CMSIS/core_cm4.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 283:../CMSIS/core_cm4.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 284:../CMSIS/core_cm4.h **** 
 285:../CMSIS/core_cm4.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 286:../CMSIS/core_cm4.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 287:../CMSIS/core_cm4.h **** 
 288:../CMSIS/core_cm4.h **** #define APSR_Q_Pos                         27U                                            /*!< APSR
 289:../CMSIS/core_cm4.h **** #define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR
 290:../CMSIS/core_cm4.h **** 
 291:../CMSIS/core_cm4.h **** #define APSR_GE_Pos                        16U                                            /*!< APSR
 292:../CMSIS/core_cm4.h **** #define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR
 293:../CMSIS/core_cm4.h **** 
 294:../CMSIS/core_cm4.h **** 
 295:../CMSIS/core_cm4.h **** /**
 296:../CMSIS/core_cm4.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 297:../CMSIS/core_cm4.h ****  */
 298:../CMSIS/core_cm4.h **** typedef union
 299:../CMSIS/core_cm4.h **** {
 300:../CMSIS/core_cm4.h ****   struct
 301:../CMSIS/core_cm4.h ****   {
 302:../CMSIS/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 303:../CMSIS/core_cm4.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 304:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm4.h **** } IPSR_Type;
 307:../CMSIS/core_cm4.h **** 
 308:../CMSIS/core_cm4.h **** /* IPSR Register Definitions */
 309:../CMSIS/core_cm4.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 310:../CMSIS/core_cm4.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 311:../CMSIS/core_cm4.h **** 
 312:../CMSIS/core_cm4.h **** 
 313:../CMSIS/core_cm4.h **** /**
 314:../CMSIS/core_cm4.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 315:../CMSIS/core_cm4.h ****  */
 316:../CMSIS/core_cm4.h **** typedef union
 317:../CMSIS/core_cm4.h **** {
 318:../CMSIS/core_cm4.h ****   struct
 319:../CMSIS/core_cm4.h ****   {
 320:../CMSIS/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 321:../CMSIS/core_cm4.h ****     uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
 322:../CMSIS/core_cm4.h ****     uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
 323:../CMSIS/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 324:../CMSIS/core_cm4.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
 325:../CMSIS/core_cm4.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit */
 326:../CMSIS/core_cm4.h ****     uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
 327:../CMSIS/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 328:../CMSIS/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 329:../CMSIS/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 330:../CMSIS/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 331:../CMSIS/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 332:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 333:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 334:../CMSIS/core_cm4.h **** } xPSR_Type;
 335:../CMSIS/core_cm4.h **** 
 336:../CMSIS/core_cm4.h **** /* xPSR Register Definitions */
 337:../CMSIS/core_cm4.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 338:../CMSIS/core_cm4.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 339:../CMSIS/core_cm4.h **** 
 340:../CMSIS/core_cm4.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 341:../CMSIS/core_cm4.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 342:../CMSIS/core_cm4.h **** 
 343:../CMSIS/core_cm4.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 344:../CMSIS/core_cm4.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 345:../CMSIS/core_cm4.h **** 
 346:../CMSIS/core_cm4.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 347:../CMSIS/core_cm4.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 348:../CMSIS/core_cm4.h **** 
 349:../CMSIS/core_cm4.h **** #define xPSR_Q_Pos                         27U                                            /*!< xPSR
 350:../CMSIS/core_cm4.h **** #define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR
 351:../CMSIS/core_cm4.h **** 
 352:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR
 353:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR
 354:../CMSIS/core_cm4.h **** 
 355:../CMSIS/core_cm4.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 356:../CMSIS/core_cm4.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 357:../CMSIS/core_cm4.h **** 
 358:../CMSIS/core_cm4.h **** #define xPSR_GE_Pos                        16U                                            /*!< xPSR
 359:../CMSIS/core_cm4.h **** #define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR
 360:../CMSIS/core_cm4.h **** 
 361:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR
 362:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR
 363:../CMSIS/core_cm4.h **** 
 364:../CMSIS/core_cm4.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 365:../CMSIS/core_cm4.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 366:../CMSIS/core_cm4.h **** 
 367:../CMSIS/core_cm4.h **** 
 368:../CMSIS/core_cm4.h **** /**
 369:../CMSIS/core_cm4.h ****   \brief  Union type to access the Control Registers (CONTROL).
 370:../CMSIS/core_cm4.h ****  */
 371:../CMSIS/core_cm4.h **** typedef union
 372:../CMSIS/core_cm4.h **** {
 373:../CMSIS/core_cm4.h ****   struct
 374:../CMSIS/core_cm4.h ****   {
 375:../CMSIS/core_cm4.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 376:../CMSIS/core_cm4.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 377:../CMSIS/core_cm4.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
 378:../CMSIS/core_cm4.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
 379:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 380:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 381:../CMSIS/core_cm4.h **** } CONTROL_Type;
 382:../CMSIS/core_cm4.h **** 
 383:../CMSIS/core_cm4.h **** /* CONTROL Register Definitions */
 384:../CMSIS/core_cm4.h **** #define CONTROL_FPCA_Pos                    2U                                            /*!< CONT
 385:../CMSIS/core_cm4.h **** #define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONT
 386:../CMSIS/core_cm4.h **** 
 387:../CMSIS/core_cm4.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 388:../CMSIS/core_cm4.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 389:../CMSIS/core_cm4.h **** 
 390:../CMSIS/core_cm4.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 391:../CMSIS/core_cm4.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 392:../CMSIS/core_cm4.h **** 
 393:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_CORE */
 394:../CMSIS/core_cm4.h **** 
 395:../CMSIS/core_cm4.h **** 
 396:../CMSIS/core_cm4.h **** /**
 397:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
 398:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 399:../CMSIS/core_cm4.h ****   \brief      Type definitions for the NVIC Registers
 400:../CMSIS/core_cm4.h ****   @{
 401:../CMSIS/core_cm4.h ****  */
 402:../CMSIS/core_cm4.h **** 
 403:../CMSIS/core_cm4.h **** /**
 404:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 405:../CMSIS/core_cm4.h ****  */
 406:../CMSIS/core_cm4.h **** typedef struct
 407:../CMSIS/core_cm4.h **** {
 408:../CMSIS/core_cm4.h ****   __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 409:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[24U];
 410:../CMSIS/core_cm4.h ****   __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 411:../CMSIS/core_cm4.h ****         uint32_t RSERVED1[24U];
 412:../CMSIS/core_cm4.h ****   __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 413:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[24U];
 414:../CMSIS/core_cm4.h ****   __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 415:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[24U];
 416:../CMSIS/core_cm4.h ****   __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
 417:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[56U];
 418:../CMSIS/core_cm4.h ****   __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 419:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[644U];
 420:../CMSIS/core_cm4.h ****   __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 421:../CMSIS/core_cm4.h **** }  NVIC_Type;
 422:../CMSIS/core_cm4.h **** 
 423:../CMSIS/core_cm4.h **** /* Software Triggered Interrupt Register Definitions */
 424:../CMSIS/core_cm4.h **** #define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: I
 425:../CMSIS/core_cm4.h **** #define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: I
 426:../CMSIS/core_cm4.h **** 
 427:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_NVIC */
 428:../CMSIS/core_cm4.h **** 
 429:../CMSIS/core_cm4.h **** 
 430:../CMSIS/core_cm4.h **** /**
 431:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 432:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 433:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Control Block Registers
 434:../CMSIS/core_cm4.h ****   @{
 435:../CMSIS/core_cm4.h ****  */
 436:../CMSIS/core_cm4.h **** 
 437:../CMSIS/core_cm4.h **** /**
 438:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Control Block (SCB).
 439:../CMSIS/core_cm4.h ****  */
 440:../CMSIS/core_cm4.h **** typedef struct
 441:../CMSIS/core_cm4.h **** {
 442:../CMSIS/core_cm4.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 443:../CMSIS/core_cm4.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 444:../CMSIS/core_cm4.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 445:../CMSIS/core_cm4.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 446:../CMSIS/core_cm4.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 447:../CMSIS/core_cm4.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 448:../CMSIS/core_cm4.h ****   __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 449:../CMSIS/core_cm4.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 450:../CMSIS/core_cm4.h ****   __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 451:../CMSIS/core_cm4.h ****   __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
 452:../CMSIS/core_cm4.h ****   __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
 453:../CMSIS/core_cm4.h ****   __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register
 454:../CMSIS/core_cm4.h ****   __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
 455:../CMSIS/core_cm4.h ****   __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 456:../CMSIS/core_cm4.h ****   __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
 457:../CMSIS/core_cm4.h ****   __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
 458:../CMSIS/core_cm4.h ****   __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
 459:../CMSIS/core_cm4.h ****   __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
 460:../CMSIS/core_cm4.h ****   __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Regis
 461:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[5U];
 462:../CMSIS/core_cm4.h ****   __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Regis
 463:../CMSIS/core_cm4.h **** } SCB_Type;
 464:../CMSIS/core_cm4.h **** 
 465:../CMSIS/core_cm4.h **** /* SCB CPUID Register Definitions */
 466:../CMSIS/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 467:../CMSIS/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 468:../CMSIS/core_cm4.h **** 
 469:../CMSIS/core_cm4.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 470:../CMSIS/core_cm4.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 471:../CMSIS/core_cm4.h **** 
 472:../CMSIS/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 473:../CMSIS/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 474:../CMSIS/core_cm4.h **** 
 475:../CMSIS/core_cm4.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 476:../CMSIS/core_cm4.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 477:../CMSIS/core_cm4.h **** 
 478:../CMSIS/core_cm4.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 479:../CMSIS/core_cm4.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 480:../CMSIS/core_cm4.h **** 
 481:../CMSIS/core_cm4.h **** /* SCB Interrupt Control State Register Definitions */
 482:../CMSIS/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 483:../CMSIS/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 484:../CMSIS/core_cm4.h **** 
 485:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 486:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 487:../CMSIS/core_cm4.h **** 
 488:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 489:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 490:../CMSIS/core_cm4.h **** 
 491:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 492:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 493:../CMSIS/core_cm4.h **** 
 494:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 495:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 496:../CMSIS/core_cm4.h **** 
 497:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 498:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 499:../CMSIS/core_cm4.h **** 
 500:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 501:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 502:../CMSIS/core_cm4.h **** 
 503:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 504:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 505:../CMSIS/core_cm4.h **** 
 506:../CMSIS/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB 
 507:../CMSIS/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 508:../CMSIS/core_cm4.h **** 
 509:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 510:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 511:../CMSIS/core_cm4.h **** 
 512:../CMSIS/core_cm4.h **** /* SCB Vector Table Offset Register Definitions */
 513:../CMSIS/core_cm4.h **** #define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB 
 514:../CMSIS/core_cm4.h **** #define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB 
 515:../CMSIS/core_cm4.h **** 
 516:../CMSIS/core_cm4.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 517:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 518:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 519:../CMSIS/core_cm4.h **** 
 520:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 521:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 522:../CMSIS/core_cm4.h **** 
 523:../CMSIS/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 524:../CMSIS/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 525:../CMSIS/core_cm4.h **** 
 526:../CMSIS/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB 
 527:../CMSIS/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 528:../CMSIS/core_cm4.h **** 
 529:../CMSIS/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 530:../CMSIS/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 531:../CMSIS/core_cm4.h **** 
 532:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 533:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 534:../CMSIS/core_cm4.h **** 
 535:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB 
 536:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB 
 537:../CMSIS/core_cm4.h **** 
 538:../CMSIS/core_cm4.h **** /* SCB System Control Register Definitions */
 539:../CMSIS/core_cm4.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 540:../CMSIS/core_cm4.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 541:../CMSIS/core_cm4.h **** 
 542:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 543:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 544:../CMSIS/core_cm4.h **** 
 545:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 546:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 547:../CMSIS/core_cm4.h **** 
 548:../CMSIS/core_cm4.h **** /* SCB Configuration Control Register Definitions */
 549:../CMSIS/core_cm4.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 550:../CMSIS/core_cm4.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 551:../CMSIS/core_cm4.h **** 
 552:../CMSIS/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB 
 553:../CMSIS/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 554:../CMSIS/core_cm4.h **** 
 555:../CMSIS/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB 
 556:../CMSIS/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 557:../CMSIS/core_cm4.h **** 
 558:../CMSIS/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 559:../CMSIS/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 560:../CMSIS/core_cm4.h **** 
 561:../CMSIS/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB 
 562:../CMSIS/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 563:../CMSIS/core_cm4.h **** 
 564:../CMSIS/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB 
 565:../CMSIS/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB 
 566:../CMSIS/core_cm4.h **** 
 567:../CMSIS/core_cm4.h **** /* SCB System Handler Control and State Register Definitions */
 568:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB 
 569:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 570:../CMSIS/core_cm4.h **** 
 571:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB 
 572:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 573:../CMSIS/core_cm4.h **** 
 574:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB 
 575:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 576:../CMSIS/core_cm4.h **** 
 577:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 578:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 579:../CMSIS/core_cm4.h **** 
 580:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB 
 581:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 582:../CMSIS/core_cm4.h **** 
 583:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB 
 584:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 585:../CMSIS/core_cm4.h **** 
 586:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB 
 587:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 588:../CMSIS/core_cm4.h **** 
 589:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB 
 590:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 591:../CMSIS/core_cm4.h **** 
 592:../CMSIS/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB 
 593:../CMSIS/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
 594:../CMSIS/core_cm4.h **** 
 595:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB 
 596:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 597:../CMSIS/core_cm4.h **** 
 598:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB 
 599:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 600:../CMSIS/core_cm4.h **** 
 601:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB 
 602:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 603:../CMSIS/core_cm4.h **** 
 604:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB 
 605:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 606:../CMSIS/core_cm4.h **** 
 607:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB 
 608:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB 
 609:../CMSIS/core_cm4.h **** 
 610:../CMSIS/core_cm4.h **** /* SCB Configurable Fault Status Register Definitions */
 611:../CMSIS/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB 
 612:../CMSIS/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 613:../CMSIS/core_cm4.h **** 
 614:../CMSIS/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB 
 615:../CMSIS/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 616:../CMSIS/core_cm4.h **** 
 617:../CMSIS/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB 
 618:../CMSIS/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB 
 619:../CMSIS/core_cm4.h **** 
 620:../CMSIS/core_cm4.h **** /* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
 621:../CMSIS/core_cm4.h **** #define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB 
 622:../CMSIS/core_cm4.h **** #define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB 
 623:../CMSIS/core_cm4.h **** 
 624:../CMSIS/core_cm4.h **** #define SCB_CFSR_MLSPERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 5U)               /*!< SCB 
 625:../CMSIS/core_cm4.h **** #define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB 
 626:../CMSIS/core_cm4.h **** 
 627:../CMSIS/core_cm4.h **** #define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB 
 628:../CMSIS/core_cm4.h **** #define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB 
 629:../CMSIS/core_cm4.h **** 
 630:../CMSIS/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB 
 631:../CMSIS/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB 
 632:../CMSIS/core_cm4.h **** 
 633:../CMSIS/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB 
 634:../CMSIS/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB 
 635:../CMSIS/core_cm4.h **** 
 636:../CMSIS/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB 
 637:../CMSIS/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB 
 638:../CMSIS/core_cm4.h **** 
 639:../CMSIS/core_cm4.h **** /* BusFault Status Register (part of SCB Configurable Fault Status Register) */
 640:../CMSIS/core_cm4.h **** #define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB 
 641:../CMSIS/core_cm4.h **** #define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB 
 642:../CMSIS/core_cm4.h **** 
 643:../CMSIS/core_cm4.h **** #define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB 
 644:../CMSIS/core_cm4.h **** #define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB 
 645:../CMSIS/core_cm4.h **** 
 646:../CMSIS/core_cm4.h **** #define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB 
 647:../CMSIS/core_cm4.h **** #define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB 
 648:../CMSIS/core_cm4.h **** 
 649:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB 
 650:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB 
 651:../CMSIS/core_cm4.h **** 
 652:../CMSIS/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB 
 653:../CMSIS/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB 
 654:../CMSIS/core_cm4.h **** 
 655:../CMSIS/core_cm4.h **** #define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB 
 656:../CMSIS/core_cm4.h **** #define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB 
 657:../CMSIS/core_cm4.h **** 
 658:../CMSIS/core_cm4.h **** #define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB 
 659:../CMSIS/core_cm4.h **** #define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB 
 660:../CMSIS/core_cm4.h **** 
 661:../CMSIS/core_cm4.h **** /* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
 662:../CMSIS/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB 
 663:../CMSIS/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB 
 664:../CMSIS/core_cm4.h **** 
 665:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB 
 666:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB 
 667:../CMSIS/core_cm4.h **** 
 668:../CMSIS/core_cm4.h **** #define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB 
 669:../CMSIS/core_cm4.h **** #define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB 
 670:../CMSIS/core_cm4.h **** 
 671:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB 
 672:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB 
 673:../CMSIS/core_cm4.h **** 
 674:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB 
 675:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB 
 676:../CMSIS/core_cm4.h **** 
 677:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB 
 678:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB 
 679:../CMSIS/core_cm4.h **** 
 680:../CMSIS/core_cm4.h **** /* SCB Hard Fault Status Register Definitions */
 681:../CMSIS/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB 
 682:../CMSIS/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 683:../CMSIS/core_cm4.h **** 
 684:../CMSIS/core_cm4.h **** #define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB 
 685:../CMSIS/core_cm4.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 686:../CMSIS/core_cm4.h **** 
 687:../CMSIS/core_cm4.h **** #define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB 
 688:../CMSIS/core_cm4.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 689:../CMSIS/core_cm4.h **** 
 690:../CMSIS/core_cm4.h **** /* SCB Debug Fault Status Register Definitions */
 691:../CMSIS/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB 
 692:../CMSIS/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 693:../CMSIS/core_cm4.h **** 
 694:../CMSIS/core_cm4.h **** #define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB 
 695:../CMSIS/core_cm4.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 696:../CMSIS/core_cm4.h **** 
 697:../CMSIS/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB 
 698:../CMSIS/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 699:../CMSIS/core_cm4.h **** 
 700:../CMSIS/core_cm4.h **** #define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB 
 701:../CMSIS/core_cm4.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 702:../CMSIS/core_cm4.h **** 
 703:../CMSIS/core_cm4.h **** #define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB 
 704:../CMSIS/core_cm4.h **** #define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB 
 705:../CMSIS/core_cm4.h **** 
 706:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SCB */
 707:../CMSIS/core_cm4.h **** 
 708:../CMSIS/core_cm4.h **** 
 709:../CMSIS/core_cm4.h **** /**
 710:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 711:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
 712:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Control and ID Register not in the SCB
 713:../CMSIS/core_cm4.h ****   @{
 714:../CMSIS/core_cm4.h ****  */
 715:../CMSIS/core_cm4.h **** 
 716:../CMSIS/core_cm4.h **** /**
 717:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Control and ID Register not in the SCB.
 718:../CMSIS/core_cm4.h ****  */
 719:../CMSIS/core_cm4.h **** typedef struct
 720:../CMSIS/core_cm4.h **** {
 721:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
 722:../CMSIS/core_cm4.h ****   __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Regist
 723:../CMSIS/core_cm4.h ****   __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
 724:../CMSIS/core_cm4.h **** } SCnSCB_Type;
 725:../CMSIS/core_cm4.h **** 
 726:../CMSIS/core_cm4.h **** /* Interrupt Controller Type Register Definitions */
 727:../CMSIS/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: I
 728:../CMSIS/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: I
 729:../CMSIS/core_cm4.h **** 
 730:../CMSIS/core_cm4.h **** /* Auxiliary Control Register Definitions */
 731:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: 
 732:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: 
 733:../CMSIS/core_cm4.h **** 
 734:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: 
 735:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: 
 736:../CMSIS/core_cm4.h **** 
 737:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: 
 738:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: 
 739:../CMSIS/core_cm4.h **** 
 740:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: 
 741:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: 
 742:../CMSIS/core_cm4.h **** 
 743:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: 
 744:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: 
 745:../CMSIS/core_cm4.h **** 
 746:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SCnotSCB */
 747:../CMSIS/core_cm4.h **** 
 748:../CMSIS/core_cm4.h **** 
 749:../CMSIS/core_cm4.h **** /**
 750:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 751:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 752:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Timer Registers.
 753:../CMSIS/core_cm4.h ****   @{
 754:../CMSIS/core_cm4.h ****  */
 755:../CMSIS/core_cm4.h **** 
 756:../CMSIS/core_cm4.h **** /**
 757:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Timer (SysTick).
 758:../CMSIS/core_cm4.h ****  */
 759:../CMSIS/core_cm4.h **** typedef struct
 760:../CMSIS/core_cm4.h **** {
 761:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 762:../CMSIS/core_cm4.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 763:../CMSIS/core_cm4.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 764:../CMSIS/core_cm4.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 765:../CMSIS/core_cm4.h **** } SysTick_Type;
 766:../CMSIS/core_cm4.h **** 
 767:../CMSIS/core_cm4.h **** /* SysTick Control / Status Register Definitions */
 768:../CMSIS/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 769:../CMSIS/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 770:../CMSIS/core_cm4.h **** 
 771:../CMSIS/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 772:../CMSIS/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 773:../CMSIS/core_cm4.h **** 
 774:../CMSIS/core_cm4.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 775:../CMSIS/core_cm4.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 776:../CMSIS/core_cm4.h **** 
 777:../CMSIS/core_cm4.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 778:../CMSIS/core_cm4.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 779:../CMSIS/core_cm4.h **** 
 780:../CMSIS/core_cm4.h **** /* SysTick Reload Register Definitions */
 781:../CMSIS/core_cm4.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 782:../CMSIS/core_cm4.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 783:../CMSIS/core_cm4.h **** 
 784:../CMSIS/core_cm4.h **** /* SysTick Current Register Definitions */
 785:../CMSIS/core_cm4.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 786:../CMSIS/core_cm4.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 787:../CMSIS/core_cm4.h **** 
 788:../CMSIS/core_cm4.h **** /* SysTick Calibration Register Definitions */
 789:../CMSIS/core_cm4.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 790:../CMSIS/core_cm4.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 791:../CMSIS/core_cm4.h **** 
 792:../CMSIS/core_cm4.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 793:../CMSIS/core_cm4.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 794:../CMSIS/core_cm4.h **** 
 795:../CMSIS/core_cm4.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 796:../CMSIS/core_cm4.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 797:../CMSIS/core_cm4.h **** 
 798:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SysTick */
 799:../CMSIS/core_cm4.h **** 
 800:../CMSIS/core_cm4.h **** 
 801:../CMSIS/core_cm4.h **** /**
 802:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 803:../CMSIS/core_cm4.h ****   \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
 804:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
 805:../CMSIS/core_cm4.h ****   @{
 806:../CMSIS/core_cm4.h ****  */
 807:../CMSIS/core_cm4.h **** 
 808:../CMSIS/core_cm4.h **** /**
 809:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 810:../CMSIS/core_cm4.h ****  */
 811:../CMSIS/core_cm4.h **** typedef struct
 812:../CMSIS/core_cm4.h **** {
 813:../CMSIS/core_cm4.h ****   __OM  union
 814:../CMSIS/core_cm4.h ****   {
 815:../CMSIS/core_cm4.h ****     __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
 816:../CMSIS/core_cm4.h ****     __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
 817:../CMSIS/core_cm4.h ****     __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
 818:../CMSIS/core_cm4.h ****   }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
 819:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[864U];
 820:../CMSIS/core_cm4.h ****   __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
 821:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[15U];
 822:../CMSIS/core_cm4.h ****   __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
 823:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[15U];
 824:../CMSIS/core_cm4.h ****   __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
 825:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[29U];
 826:../CMSIS/core_cm4.h ****   __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register *
 827:../CMSIS/core_cm4.h ****   __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
 828:../CMSIS/core_cm4.h ****   __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Reg
 829:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[43U];
 830:../CMSIS/core_cm4.h ****   __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
 831:../CMSIS/core_cm4.h ****   __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
 832:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[6U];
 833:../CMSIS/core_cm4.h ****   __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Re
 834:../CMSIS/core_cm4.h ****   __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Re
 835:../CMSIS/core_cm4.h ****   __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Re
 836:../CMSIS/core_cm4.h ****   __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Re
 837:../CMSIS/core_cm4.h ****   __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Re
 838:../CMSIS/core_cm4.h ****   __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Re
 839:../CMSIS/core_cm4.h ****   __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Re
 840:../CMSIS/core_cm4.h ****   __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Re
 841:../CMSIS/core_cm4.h ****   __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Re
 842:../CMSIS/core_cm4.h ****   __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Re
 843:../CMSIS/core_cm4.h ****   __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Re
 844:../CMSIS/core_cm4.h ****   __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Re
 845:../CMSIS/core_cm4.h **** } ITM_Type;
 846:../CMSIS/core_cm4.h **** 
 847:../CMSIS/core_cm4.h **** /* ITM Trace Privilege Register Definitions */
 848:../CMSIS/core_cm4.h **** #define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM 
 849:../CMSIS/core_cm4.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM 
 850:../CMSIS/core_cm4.h **** 
 851:../CMSIS/core_cm4.h **** /* ITM Trace Control Register Definitions */
 852:../CMSIS/core_cm4.h **** #define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM 
 853:../CMSIS/core_cm4.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 854:../CMSIS/core_cm4.h **** 
 855:../CMSIS/core_cm4.h **** #define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM 
 856:../CMSIS/core_cm4.h **** #define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM 
 857:../CMSIS/core_cm4.h **** 
 858:../CMSIS/core_cm4.h **** #define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM 
 859:../CMSIS/core_cm4.h **** #define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM 
 860:../CMSIS/core_cm4.h **** 
 861:../CMSIS/core_cm4.h **** #define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM 
 862:../CMSIS/core_cm4.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 863:../CMSIS/core_cm4.h **** 
 864:../CMSIS/core_cm4.h **** #define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM 
 865:../CMSIS/core_cm4.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 866:../CMSIS/core_cm4.h **** 
 867:../CMSIS/core_cm4.h **** #define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM 
 868:../CMSIS/core_cm4.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 869:../CMSIS/core_cm4.h **** 
 870:../CMSIS/core_cm4.h **** #define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM 
 871:../CMSIS/core_cm4.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 872:../CMSIS/core_cm4.h **** 
 873:../CMSIS/core_cm4.h **** #define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM 
 874:../CMSIS/core_cm4.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 875:../CMSIS/core_cm4.h **** 
 876:../CMSIS/core_cm4.h **** #define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM 
 877:../CMSIS/core_cm4.h **** #define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM 
 878:../CMSIS/core_cm4.h **** 
 879:../CMSIS/core_cm4.h **** /* ITM Integration Write Register Definitions */
 880:../CMSIS/core_cm4.h **** #define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM 
 881:../CMSIS/core_cm4.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM 
 882:../CMSIS/core_cm4.h **** 
 883:../CMSIS/core_cm4.h **** /* ITM Integration Read Register Definitions */
 884:../CMSIS/core_cm4.h **** #define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM 
 885:../CMSIS/core_cm4.h **** #define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM 
 886:../CMSIS/core_cm4.h **** 
 887:../CMSIS/core_cm4.h **** /* ITM Integration Mode Control Register Definitions */
 888:../CMSIS/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM 
 889:../CMSIS/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM 
 890:../CMSIS/core_cm4.h **** 
 891:../CMSIS/core_cm4.h **** /* ITM Lock Status Register Definitions */
 892:../CMSIS/core_cm4.h **** #define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM 
 893:../CMSIS/core_cm4.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 894:../CMSIS/core_cm4.h **** 
 895:../CMSIS/core_cm4.h **** #define ITM_LSR_Access_Pos                  1U                                            /*!< ITM 
 896:../CMSIS/core_cm4.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 897:../CMSIS/core_cm4.h **** 
 898:../CMSIS/core_cm4.h **** #define ITM_LSR_Present_Pos                 0U                                            /*!< ITM 
 899:../CMSIS/core_cm4.h **** #define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM 
 900:../CMSIS/core_cm4.h **** 
 901:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_ITM */
 902:../CMSIS/core_cm4.h **** 
 903:../CMSIS/core_cm4.h **** 
 904:../CMSIS/core_cm4.h **** /**
 905:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 906:../CMSIS/core_cm4.h ****   \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
 907:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Data Watchpoint and Trace (DWT)
 908:../CMSIS/core_cm4.h ****   @{
 909:../CMSIS/core_cm4.h ****  */
 910:../CMSIS/core_cm4.h **** 
 911:../CMSIS/core_cm4.h **** /**
 912:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 913:../CMSIS/core_cm4.h ****  */
 914:../CMSIS/core_cm4.h **** typedef struct
 915:../CMSIS/core_cm4.h **** {
 916:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
 917:../CMSIS/core_cm4.h ****   __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
 918:../CMSIS/core_cm4.h ****   __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
 919:../CMSIS/core_cm4.h ****   __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Registe
 920:../CMSIS/core_cm4.h ****   __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
 921:../CMSIS/core_cm4.h ****   __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
 922:../CMSIS/core_cm4.h ****   __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Registe
 923:../CMSIS/core_cm4.h ****   __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register 
 924:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
 925:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
 926:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
 927:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
 928:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
 929:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
 930:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
 931:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[1U];
 932:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
 933:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
 934:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
 935:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[1U];
 936:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
 937:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
 938:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
 939:../CMSIS/core_cm4.h **** } DWT_Type;
 940:../CMSIS/core_cm4.h **** 
 941:../CMSIS/core_cm4.h **** /* DWT Control Register Definitions */
 942:../CMSIS/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTR
 943:../CMSIS/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTR
 944:../CMSIS/core_cm4.h **** 
 945:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTR
 946:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTR
 947:../CMSIS/core_cm4.h **** 
 948:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTR
 949:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTR
 950:../CMSIS/core_cm4.h **** 
 951:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTR
 952:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTR
 953:../CMSIS/core_cm4.h **** 
 954:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTR
 955:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTR
 956:../CMSIS/core_cm4.h **** 
 957:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTR
 958:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTR
 959:../CMSIS/core_cm4.h **** 
 960:../CMSIS/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTR
 961:../CMSIS/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTR
 962:../CMSIS/core_cm4.h **** 
 963:../CMSIS/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTR
 964:../CMSIS/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTR
 965:../CMSIS/core_cm4.h **** 
 966:../CMSIS/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTR
 967:../CMSIS/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTR
 968:../CMSIS/core_cm4.h **** 
 969:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTR
 970:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTR
 971:../CMSIS/core_cm4.h **** 
 972:../CMSIS/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTR
 973:../CMSIS/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTR
 974:../CMSIS/core_cm4.h **** 
 975:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTR
 976:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTR
 977:../CMSIS/core_cm4.h **** 
 978:../CMSIS/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTR
 979:../CMSIS/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTR
 980:../CMSIS/core_cm4.h **** 
 981:../CMSIS/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTR
 982:../CMSIS/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTR
 983:../CMSIS/core_cm4.h **** 
 984:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTR
 985:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTR
 986:../CMSIS/core_cm4.h **** 
 987:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTR
 988:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTR
 989:../CMSIS/core_cm4.h **** 
 990:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTR
 991:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTR
 992:../CMSIS/core_cm4.h **** 
 993:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTR
 994:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTR
 995:../CMSIS/core_cm4.h **** 
 996:../CMSIS/core_cm4.h **** /* DWT CPI Count Register Definitions */
 997:../CMSIS/core_cm4.h **** #define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPI
 998:../CMSIS/core_cm4.h **** #define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPI
 999:../CMSIS/core_cm4.h **** 
1000:../CMSIS/core_cm4.h **** /* DWT Exception Overhead Count Register Definitions */
1001:../CMSIS/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXC
1002:../CMSIS/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXC
1003:../CMSIS/core_cm4.h **** 
1004:../CMSIS/core_cm4.h **** /* DWT Sleep Count Register Definitions */
1005:../CMSIS/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLE
1006:../CMSIS/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLE
1007:../CMSIS/core_cm4.h **** 
1008:../CMSIS/core_cm4.h **** /* DWT LSU Count Register Definitions */
1009:../CMSIS/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSU
1010:../CMSIS/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSU
1011:../CMSIS/core_cm4.h **** 
1012:../CMSIS/core_cm4.h **** /* DWT Folded-instruction Count Register Definitions */
1013:../CMSIS/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOL
1014:../CMSIS/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOL
1015:../CMSIS/core_cm4.h **** 
1016:../CMSIS/core_cm4.h **** /* DWT Comparator Mask Register Definitions */
1017:../CMSIS/core_cm4.h **** #define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MAS
1018:../CMSIS/core_cm4.h **** #define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MAS
1019:../CMSIS/core_cm4.h **** 
1020:../CMSIS/core_cm4.h **** /* DWT Comparator Function Register Definitions */
1021:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUN
1022:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUN
1023:../CMSIS/core_cm4.h **** 
1024:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUN
1025:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUN
1026:../CMSIS/core_cm4.h **** 
1027:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUN
1028:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUN
1029:../CMSIS/core_cm4.h **** 
1030:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUN
1031:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUN
1032:../CMSIS/core_cm4.h **** 
1033:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUN
1034:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUN
1035:../CMSIS/core_cm4.h **** 
1036:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUN
1037:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUN
1038:../CMSIS/core_cm4.h **** 
1039:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUN
1040:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUN
1041:../CMSIS/core_cm4.h **** 
1042:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUN
1043:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUN
1044:../CMSIS/core_cm4.h **** 
1045:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUN
1046:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUN
1047:../CMSIS/core_cm4.h **** 
1048:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_DWT */
1049:../CMSIS/core_cm4.h **** 
1050:../CMSIS/core_cm4.h **** 
1051:../CMSIS/core_cm4.h **** /**
1052:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1053:../CMSIS/core_cm4.h ****   \defgroup CMSIS_TPI     Trace Port Interface (TPI)
1054:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Trace Port Interface (TPI)
1055:../CMSIS/core_cm4.h ****   @{
1056:../CMSIS/core_cm4.h ****  */
1057:../CMSIS/core_cm4.h **** 
1058:../CMSIS/core_cm4.h **** /**
1059:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Trace Port Interface Register (TPI).
1060:../CMSIS/core_cm4.h ****  */
1061:../CMSIS/core_cm4.h **** typedef struct
1062:../CMSIS/core_cm4.h **** {
1063:../CMSIS/core_cm4.h ****   __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Reg
1064:../CMSIS/core_cm4.h ****   __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Regis
1065:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[2U];
1066:../CMSIS/core_cm4.h ****   __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Reg
1067:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[55U];
1068:../CMSIS/core_cm4.h ****   __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *
1069:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[131U];
1070:../CMSIS/core_cm4.h ****   __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Regis
1071:../CMSIS/core_cm4.h ****   __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Regi
1072:../CMSIS/core_cm4.h ****   __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counte
1073:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[759U];
1074:../CMSIS/core_cm4.h ****   __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
1075:../CMSIS/core_cm4.h ****   __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
1076:../CMSIS/core_cm4.h ****   __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
1077:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[1U];
1078:../CMSIS/core_cm4.h ****   __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
1079:../CMSIS/core_cm4.h ****   __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
1080:../CMSIS/core_cm4.h ****   __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
1081:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[39U];
1082:../CMSIS/core_cm4.h ****   __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
1083:../CMSIS/core_cm4.h ****   __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
1084:../CMSIS/core_cm4.h ****         uint32_t RESERVED7[8U];
1085:../CMSIS/core_cm4.h ****   __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
1086:../CMSIS/core_cm4.h ****   __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
1087:../CMSIS/core_cm4.h **** } TPI_Type;
1088:../CMSIS/core_cm4.h **** 
1089:../CMSIS/core_cm4.h **** /* TPI Asynchronous Clock Prescaler Register Definitions */
1090:../CMSIS/core_cm4.h **** #define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACP
1091:../CMSIS/core_cm4.h **** #define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACP
1092:../CMSIS/core_cm4.h **** 
1093:../CMSIS/core_cm4.h **** /* TPI Selected Pin Protocol Register Definitions */
1094:../CMSIS/core_cm4.h **** #define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPP
1095:../CMSIS/core_cm4.h **** #define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPP
1096:../CMSIS/core_cm4.h **** 
1097:../CMSIS/core_cm4.h **** /* TPI Formatter and Flush Status Register Definitions */
1098:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFS
1099:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFS
1100:../CMSIS/core_cm4.h **** 
1101:../CMSIS/core_cm4.h **** #define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFS
1102:../CMSIS/core_cm4.h **** #define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFS
1103:../CMSIS/core_cm4.h **** 
1104:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFS
1105:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFS
1106:../CMSIS/core_cm4.h **** 
1107:../CMSIS/core_cm4.h **** #define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFS
1108:../CMSIS/core_cm4.h **** #define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFS
1109:../CMSIS/core_cm4.h **** 
1110:../CMSIS/core_cm4.h **** /* TPI Formatter and Flush Control Register Definitions */
1111:../CMSIS/core_cm4.h **** #define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFC
1112:../CMSIS/core_cm4.h **** #define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFC
1113:../CMSIS/core_cm4.h **** 
1114:../CMSIS/core_cm4.h **** #define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFC
1115:../CMSIS/core_cm4.h **** #define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFC
1116:../CMSIS/core_cm4.h **** 
1117:../CMSIS/core_cm4.h **** /* TPI TRIGGER Register Definitions */
1118:../CMSIS/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRI
1119:../CMSIS/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRI
1120:../CMSIS/core_cm4.h **** 
1121:../CMSIS/core_cm4.h **** /* TPI Integration ETM Data Register Definitions (FIFO0) */
1122:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1123:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIF
1124:../CMSIS/core_cm4.h **** 
1125:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1126:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIF
1127:../CMSIS/core_cm4.h **** 
1128:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1129:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIF
1130:../CMSIS/core_cm4.h **** 
1131:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1132:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIF
1133:../CMSIS/core_cm4.h **** 
1134:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIF
1135:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIF
1136:../CMSIS/core_cm4.h **** 
1137:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIF
1138:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIF
1139:../CMSIS/core_cm4.h **** 
1140:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIF
1141:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIF
1142:../CMSIS/core_cm4.h **** 
1143:../CMSIS/core_cm4.h **** /* TPI ITATBCTR2 Register Definitions */
1144:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITA
1145:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITA
1146:../CMSIS/core_cm4.h **** 
1147:../CMSIS/core_cm4.h **** /* TPI Integration ITM Data Register Definitions (FIFO1) */
1148:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1149:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIF
1150:../CMSIS/core_cm4.h **** 
1151:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1152:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIF
1153:../CMSIS/core_cm4.h **** 
1154:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1155:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIF
1156:../CMSIS/core_cm4.h **** 
1157:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1158:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIF
1159:../CMSIS/core_cm4.h **** 
1160:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIF
1161:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIF
1162:../CMSIS/core_cm4.h **** 
1163:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIF
1164:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIF
1165:../CMSIS/core_cm4.h **** 
1166:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIF
1167:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIF
1168:../CMSIS/core_cm4.h **** 
1169:../CMSIS/core_cm4.h **** /* TPI ITATBCTR0 Register Definitions */
1170:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITA
1171:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITA
1172:../CMSIS/core_cm4.h **** 
1173:../CMSIS/core_cm4.h **** /* TPI Integration Mode Control Register Definitions */
1174:../CMSIS/core_cm4.h **** #define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITC
1175:../CMSIS/core_cm4.h **** #define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITC
1176:../CMSIS/core_cm4.h **** 
1177:../CMSIS/core_cm4.h **** /* TPI DEVID Register Definitions */
1178:../CMSIS/core_cm4.h **** #define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEV
1179:../CMSIS/core_cm4.h **** #define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEV
1180:../CMSIS/core_cm4.h **** 
1181:../CMSIS/core_cm4.h **** #define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEV
1182:../CMSIS/core_cm4.h **** #define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEV
1183:../CMSIS/core_cm4.h **** 
1184:../CMSIS/core_cm4.h **** #define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEV
1185:../CMSIS/core_cm4.h **** #define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEV
1186:../CMSIS/core_cm4.h **** 
1187:../CMSIS/core_cm4.h **** #define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEV
1188:../CMSIS/core_cm4.h **** #define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEV
1189:../CMSIS/core_cm4.h **** 
1190:../CMSIS/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEV
1191:../CMSIS/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEV
1192:../CMSIS/core_cm4.h **** 
1193:../CMSIS/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEV
1194:../CMSIS/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEV
1195:../CMSIS/core_cm4.h **** 
1196:../CMSIS/core_cm4.h **** /* TPI DEVTYPE Register Definitions */
1197:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEV
1198:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEV
1199:../CMSIS/core_cm4.h **** 
1200:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEV
1201:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEV
1202:../CMSIS/core_cm4.h **** 
1203:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_TPI */
1204:../CMSIS/core_cm4.h **** 
1205:../CMSIS/core_cm4.h **** 
1206:../CMSIS/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1207:../CMSIS/core_cm4.h **** /**
1208:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1209:../CMSIS/core_cm4.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
1210:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
1211:../CMSIS/core_cm4.h ****   @{
1212:../CMSIS/core_cm4.h ****  */
1213:../CMSIS/core_cm4.h **** 
1214:../CMSIS/core_cm4.h **** /**
1215:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
1216:../CMSIS/core_cm4.h ****  */
1217:../CMSIS/core_cm4.h **** typedef struct
1218:../CMSIS/core_cm4.h **** {
1219:../CMSIS/core_cm4.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
1220:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
1221:../CMSIS/core_cm4.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
1222:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
1223:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
1224:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
1225:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
1226:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
1227:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
1228:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
1229:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
1230:../CMSIS/core_cm4.h **** } MPU_Type;
1231:../CMSIS/core_cm4.h **** 
1232:../CMSIS/core_cm4.h **** /* MPU Type Register Definitions */
1233:../CMSIS/core_cm4.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
1234:../CMSIS/core_cm4.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
1235:../CMSIS/core_cm4.h **** 
1236:../CMSIS/core_cm4.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
1237:../CMSIS/core_cm4.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
1238:../CMSIS/core_cm4.h **** 
1239:../CMSIS/core_cm4.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
1240:../CMSIS/core_cm4.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
1241:../CMSIS/core_cm4.h **** 
1242:../CMSIS/core_cm4.h **** /* MPU Control Register Definitions */
1243:../CMSIS/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
1244:../CMSIS/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
1245:../CMSIS/core_cm4.h **** 
1246:../CMSIS/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
1247:../CMSIS/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
1248:../CMSIS/core_cm4.h **** 
1249:../CMSIS/core_cm4.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
1250:../CMSIS/core_cm4.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
1251:../CMSIS/core_cm4.h **** 
1252:../CMSIS/core_cm4.h **** /* MPU Region Number Register Definitions */
1253:../CMSIS/core_cm4.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
1254:../CMSIS/core_cm4.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
1255:../CMSIS/core_cm4.h **** 
1256:../CMSIS/core_cm4.h **** /* MPU Region Base Address Register Definitions */
1257:../CMSIS/core_cm4.h **** #define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU 
1258:../CMSIS/core_cm4.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
1259:../CMSIS/core_cm4.h **** 
1260:../CMSIS/core_cm4.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
1261:../CMSIS/core_cm4.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
1262:../CMSIS/core_cm4.h **** 
1263:../CMSIS/core_cm4.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
1264:../CMSIS/core_cm4.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
1265:../CMSIS/core_cm4.h **** 
1266:../CMSIS/core_cm4.h **** /* MPU Region Attribute and Size Register Definitions */
1267:../CMSIS/core_cm4.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
1268:../CMSIS/core_cm4.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
1269:../CMSIS/core_cm4.h **** 
1270:../CMSIS/core_cm4.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
1271:../CMSIS/core_cm4.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
1272:../CMSIS/core_cm4.h **** 
1273:../CMSIS/core_cm4.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
1274:../CMSIS/core_cm4.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
1275:../CMSIS/core_cm4.h **** 
1276:../CMSIS/core_cm4.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
1277:../CMSIS/core_cm4.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
1278:../CMSIS/core_cm4.h **** 
1279:../CMSIS/core_cm4.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
1280:../CMSIS/core_cm4.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
1281:../CMSIS/core_cm4.h **** 
1282:../CMSIS/core_cm4.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
1283:../CMSIS/core_cm4.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
1284:../CMSIS/core_cm4.h **** 
1285:../CMSIS/core_cm4.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
1286:../CMSIS/core_cm4.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
1287:../CMSIS/core_cm4.h **** 
1288:../CMSIS/core_cm4.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
1289:../CMSIS/core_cm4.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
1290:../CMSIS/core_cm4.h **** 
1291:../CMSIS/core_cm4.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
1292:../CMSIS/core_cm4.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
1293:../CMSIS/core_cm4.h **** 
1294:../CMSIS/core_cm4.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
1295:../CMSIS/core_cm4.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
1296:../CMSIS/core_cm4.h **** 
1297:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_MPU */
1298:../CMSIS/core_cm4.h **** #endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
1299:../CMSIS/core_cm4.h **** 
1300:../CMSIS/core_cm4.h **** 
1301:../CMSIS/core_cm4.h **** /**
1302:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1303:../CMSIS/core_cm4.h ****   \defgroup CMSIS_FPU     Floating Point Unit (FPU)
1304:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Floating Point Unit (FPU)
1305:../CMSIS/core_cm4.h ****   @{
1306:../CMSIS/core_cm4.h ****  */
1307:../CMSIS/core_cm4.h **** 
1308:../CMSIS/core_cm4.h **** /**
1309:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Floating Point Unit (FPU).
1310:../CMSIS/core_cm4.h ****  */
1311:../CMSIS/core_cm4.h **** typedef struct
1312:../CMSIS/core_cm4.h **** {
1313:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
1314:../CMSIS/core_cm4.h ****   __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control R
1315:../CMSIS/core_cm4.h ****   __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address R
1316:../CMSIS/core_cm4.h ****   __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Co
1317:../CMSIS/core_cm4.h ****   __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 
1318:../CMSIS/core_cm4.h ****   __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 
1319:../CMSIS/core_cm4.h **** } FPU_Type;
1320:../CMSIS/core_cm4.h **** 
1321:../CMSIS/core_cm4.h **** /* Floating-Point Context Control Register Definitions */
1322:../CMSIS/core_cm4.h **** #define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCC
1323:../CMSIS/core_cm4.h **** #define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCC
1324:../CMSIS/core_cm4.h **** 
1325:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCC
1326:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCC
1327:../CMSIS/core_cm4.h **** 
1328:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCC
1329:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCC
1330:../CMSIS/core_cm4.h **** 
1331:../CMSIS/core_cm4.h **** #define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCC
1332:../CMSIS/core_cm4.h **** #define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCC
1333:../CMSIS/core_cm4.h **** 
1334:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCC
1335:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCC
1336:../CMSIS/core_cm4.h **** 
1337:../CMSIS/core_cm4.h **** #define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCC
1338:../CMSIS/core_cm4.h **** #define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCC
1339:../CMSIS/core_cm4.h **** 
1340:../CMSIS/core_cm4.h **** #define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCC
1341:../CMSIS/core_cm4.h **** #define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCC
1342:../CMSIS/core_cm4.h **** 
1343:../CMSIS/core_cm4.h **** #define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCC
1344:../CMSIS/core_cm4.h **** #define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCC
1345:../CMSIS/core_cm4.h **** 
1346:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCC
1347:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCC
1348:../CMSIS/core_cm4.h **** 
1349:../CMSIS/core_cm4.h **** /* Floating-Point Context Address Register Definitions */
1350:../CMSIS/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCA
1351:../CMSIS/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCA
1352:../CMSIS/core_cm4.h **** 
1353:../CMSIS/core_cm4.h **** /* Floating-Point Default Status Control Register Definitions */
1354:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDS
1355:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDS
1356:../CMSIS/core_cm4.h **** 
1357:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDS
1358:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDS
1359:../CMSIS/core_cm4.h **** 
1360:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDS
1361:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDS
1362:../CMSIS/core_cm4.h **** 
1363:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDS
1364:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDS
1365:../CMSIS/core_cm4.h **** 
1366:../CMSIS/core_cm4.h **** /* Media and FP Feature Register 0 Definitions */
1367:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR
1368:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR
1369:../CMSIS/core_cm4.h **** 
1370:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR
1371:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR
1372:../CMSIS/core_cm4.h **** 
1373:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR
1374:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR
1375:../CMSIS/core_cm4.h **** 
1376:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR
1377:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR
1378:../CMSIS/core_cm4.h **** 
1379:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR
1380:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR
1381:../CMSIS/core_cm4.h **** 
1382:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR
1383:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR
1384:../CMSIS/core_cm4.h **** 
1385:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR
1386:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR
1387:../CMSIS/core_cm4.h **** 
1388:../CMSIS/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR
1389:../CMSIS/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR
1390:../CMSIS/core_cm4.h **** 
1391:../CMSIS/core_cm4.h **** /* Media and FP Feature Register 1 Definitions */
1392:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR
1393:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR
1394:../CMSIS/core_cm4.h **** 
1395:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR
1396:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR
1397:../CMSIS/core_cm4.h **** 
1398:../CMSIS/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR
1399:../CMSIS/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR
1400:../CMSIS/core_cm4.h **** 
1401:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR
1402:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR
1403:../CMSIS/core_cm4.h **** 
1404:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_FPU */
1405:../CMSIS/core_cm4.h **** 
1406:../CMSIS/core_cm4.h **** 
1407:../CMSIS/core_cm4.h **** /**
1408:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1409:../CMSIS/core_cm4.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
1410:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Core Debug Registers
1411:../CMSIS/core_cm4.h ****   @{
1412:../CMSIS/core_cm4.h ****  */
1413:../CMSIS/core_cm4.h **** 
1414:../CMSIS/core_cm4.h **** /**
1415:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Core Debug Register (CoreDebug).
1416:../CMSIS/core_cm4.h ****  */
1417:../CMSIS/core_cm4.h **** typedef struct
1418:../CMSIS/core_cm4.h **** {
1419:../CMSIS/core_cm4.h ****   __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
1420:../CMSIS/core_cm4.h ****   __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
1421:../CMSIS/core_cm4.h ****   __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
1422:../CMSIS/core_cm4.h ****   __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
1423:../CMSIS/core_cm4.h **** } CoreDebug_Type;
1424:../CMSIS/core_cm4.h **** 
1425:../CMSIS/core_cm4.h **** /* Debug Halting Control and Status Register Definitions */
1426:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< Core
1427:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
1428:../CMSIS/core_cm4.h **** 
1429:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< Core
1430:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
1431:../CMSIS/core_cm4.h **** 
1432:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< Core
1433:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
1434:../CMSIS/core_cm4.h **** 
1435:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< Core
1436:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
1437:../CMSIS/core_cm4.h **** 
1438:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< Core
1439:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
1440:../CMSIS/core_cm4.h **** 
1441:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< Core
1442:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
1443:../CMSIS/core_cm4.h **** 
1444:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< Core
1445:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
1446:../CMSIS/core_cm4.h **** 
1447:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< Core
1448:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
1449:../CMSIS/core_cm4.h **** 
1450:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< Core
1451:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
1452:../CMSIS/core_cm4.h **** 
1453:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< Core
1454:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
1455:../CMSIS/core_cm4.h **** 
1456:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< Core
1457:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
1458:../CMSIS/core_cm4.h **** 
1459:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< Core
1460:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< Core
1461:../CMSIS/core_cm4.h **** 
1462:../CMSIS/core_cm4.h **** /* Debug Core Register Selector Register Definitions */
1463:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< Core
1464:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
1465:../CMSIS/core_cm4.h **** 
1466:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< Core
1467:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< Core
1468:../CMSIS/core_cm4.h **** 
1469:../CMSIS/core_cm4.h **** /* Debug Exception and Monitor Control Register Definitions */
1470:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< Core
1471:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
1472:../CMSIS/core_cm4.h **** 
1473:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< Core
1474:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
1475:../CMSIS/core_cm4.h **** 
1476:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< Core
1477:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
1478:../CMSIS/core_cm4.h **** 
1479:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< Core
1480:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
1481:../CMSIS/core_cm4.h **** 
1482:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< Core
1483:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
1484:../CMSIS/core_cm4.h **** 
1485:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< Core
1486:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
1487:../CMSIS/core_cm4.h **** 
1488:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< Core
1489:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
1490:../CMSIS/core_cm4.h **** 
1491:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< Core
1492:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
1493:../CMSIS/core_cm4.h **** 
1494:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< Core
1495:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
1496:../CMSIS/core_cm4.h **** 
1497:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< Core
1498:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
1499:../CMSIS/core_cm4.h **** 
1500:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< Core
1501:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
1502:../CMSIS/core_cm4.h **** 
1503:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< Core
1504:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
1505:../CMSIS/core_cm4.h **** 
1506:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< Core
1507:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< Core
1508:../CMSIS/core_cm4.h **** 
1509:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_CoreDebug */
1510:../CMSIS/core_cm4.h **** 
1511:../CMSIS/core_cm4.h **** 
1512:../CMSIS/core_cm4.h **** /**
1513:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
1514:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
1515:../CMSIS/core_cm4.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
1516:../CMSIS/core_cm4.h ****   @{
1517:../CMSIS/core_cm4.h ****  */
1518:../CMSIS/core_cm4.h **** 
1519:../CMSIS/core_cm4.h **** /**
1520:../CMSIS/core_cm4.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
1521:../CMSIS/core_cm4.h ****   \param[in] field  Name of the register bit field.
1522:../CMSIS/core_cm4.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
1523:../CMSIS/core_cm4.h ****   \return           Masked and shifted value.
1524:../CMSIS/core_cm4.h **** */
1525:../CMSIS/core_cm4.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
1526:../CMSIS/core_cm4.h **** 
1527:../CMSIS/core_cm4.h **** /**
1528:../CMSIS/core_cm4.h ****   \brief     Mask and shift a register value to extract a bit filed value.
1529:../CMSIS/core_cm4.h ****   \param[in] field  Name of the register bit field.
1530:../CMSIS/core_cm4.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
1531:../CMSIS/core_cm4.h ****   \return           Masked and shifted bit field value.
1532:../CMSIS/core_cm4.h **** */
1533:../CMSIS/core_cm4.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
1534:../CMSIS/core_cm4.h **** 
1535:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_core_bitfield */
1536:../CMSIS/core_cm4.h **** 
1537:../CMSIS/core_cm4.h **** 
1538:../CMSIS/core_cm4.h **** /**
1539:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
1540:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_core_base     Core Definitions
1541:../CMSIS/core_cm4.h ****   \brief      Definitions for base addresses, unions, and structures.
1542:../CMSIS/core_cm4.h ****   @{
1543:../CMSIS/core_cm4.h ****  */
1544:../CMSIS/core_cm4.h **** 
1545:../CMSIS/core_cm4.h **** /* Memory mapping of Core Hardware */
1546:../CMSIS/core_cm4.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
1547:../CMSIS/core_cm4.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
1548:../CMSIS/core_cm4.h **** #define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
1549:../CMSIS/core_cm4.h **** #define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
1550:../CMSIS/core_cm4.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
1551:../CMSIS/core_cm4.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
1552:../CMSIS/core_cm4.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
1553:../CMSIS/core_cm4.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
1554:../CMSIS/core_cm4.h **** 
1555:../CMSIS/core_cm4.h **** #define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register 
1556:../CMSIS/core_cm4.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
1557:../CMSIS/core_cm4.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
1558:../CMSIS/core_cm4.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
1559:../CMSIS/core_cm4.h **** #define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct
1560:../CMSIS/core_cm4.h **** #define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct
1561:../CMSIS/core_cm4.h **** #define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct
1562:../CMSIS/core_cm4.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
1563:../CMSIS/core_cm4.h **** 
1564:../CMSIS/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1565:../CMSIS/core_cm4.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
1566:../CMSIS/core_cm4.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
1567:../CMSIS/core_cm4.h **** #endif
1568:../CMSIS/core_cm4.h **** 
1569:../CMSIS/core_cm4.h **** #define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
1570:../CMSIS/core_cm4.h **** #define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
1571:../CMSIS/core_cm4.h **** 
1572:../CMSIS/core_cm4.h **** /*@} */
1573:../CMSIS/core_cm4.h **** 
1574:../CMSIS/core_cm4.h **** 
1575:../CMSIS/core_cm4.h **** 
1576:../CMSIS/core_cm4.h **** /*******************************************************************************
1577:../CMSIS/core_cm4.h ****  *                Hardware Abstraction Layer
1578:../CMSIS/core_cm4.h ****   Core Function Interface contains:
1579:../CMSIS/core_cm4.h ****   - Core NVIC Functions
1580:../CMSIS/core_cm4.h ****   - Core SysTick Functions
1581:../CMSIS/core_cm4.h ****   - Core Debug Functions
1582:../CMSIS/core_cm4.h ****   - Core Register Access Functions
1583:../CMSIS/core_cm4.h ****  ******************************************************************************/
1584:../CMSIS/core_cm4.h **** /**
1585:../CMSIS/core_cm4.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
1586:../CMSIS/core_cm4.h **** */
1587:../CMSIS/core_cm4.h **** 
1588:../CMSIS/core_cm4.h **** 
1589:../CMSIS/core_cm4.h **** 
1590:../CMSIS/core_cm4.h **** /* ##########################   NVIC functions  #################################### */
1591:../CMSIS/core_cm4.h **** /**
1592:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_Core_FunctionInterface
1593:../CMSIS/core_cm4.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
1594:../CMSIS/core_cm4.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
1595:../CMSIS/core_cm4.h ****   @{
1596:../CMSIS/core_cm4.h ****  */
1597:../CMSIS/core_cm4.h **** 
1598:../CMSIS/core_cm4.h **** #ifdef CMSIS_NVIC_VIRTUAL
1599:../CMSIS/core_cm4.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
1600:../CMSIS/core_cm4.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
1601:../CMSIS/core_cm4.h ****   #endif
1602:../CMSIS/core_cm4.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
1603:../CMSIS/core_cm4.h **** #else
1604:../CMSIS/core_cm4.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
1605:../CMSIS/core_cm4.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
1606:../CMSIS/core_cm4.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
1607:../CMSIS/core_cm4.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
1608:../CMSIS/core_cm4.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
1609:../CMSIS/core_cm4.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
1610:../CMSIS/core_cm4.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
1611:../CMSIS/core_cm4.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
1612:../CMSIS/core_cm4.h ****   #define NVIC_GetActive              __NVIC_GetActive
1613:../CMSIS/core_cm4.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
1614:../CMSIS/core_cm4.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
1615:../CMSIS/core_cm4.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
1616:../CMSIS/core_cm4.h **** #endif /* CMSIS_NVIC_VIRTUAL */
1617:../CMSIS/core_cm4.h **** 
1618:../CMSIS/core_cm4.h **** #ifdef CMSIS_VECTAB_VIRTUAL
1619:../CMSIS/core_cm4.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1620:../CMSIS/core_cm4.h ****    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
1621:../CMSIS/core_cm4.h ****   #endif
1622:../CMSIS/core_cm4.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1623:../CMSIS/core_cm4.h **** #else
1624:../CMSIS/core_cm4.h ****   #define NVIC_SetVector              __NVIC_SetVector
1625:../CMSIS/core_cm4.h ****   #define NVIC_GetVector              __NVIC_GetVector
1626:../CMSIS/core_cm4.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
1627:../CMSIS/core_cm4.h **** 
1628:../CMSIS/core_cm4.h **** #define NVIC_USER_IRQ_OFFSET          16
1629:../CMSIS/core_cm4.h **** 
1630:../CMSIS/core_cm4.h **** 
1631:../CMSIS/core_cm4.h **** 
1632:../CMSIS/core_cm4.h **** /**
1633:../CMSIS/core_cm4.h ****   \brief   Set Priority Grouping
1634:../CMSIS/core_cm4.h ****   \details Sets the priority grouping field using the required unlock sequence.
1635:../CMSIS/core_cm4.h ****            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
1636:../CMSIS/core_cm4.h ****            Only values from 0..7 are used.
1637:../CMSIS/core_cm4.h ****            In case of a conflict between priority grouping and available
1638:../CMSIS/core_cm4.h ****            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
1639:../CMSIS/core_cm4.h ****   \param [in]      PriorityGroup  Priority grouping field.
1640:../CMSIS/core_cm4.h ****  */
1641:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
1642:../CMSIS/core_cm4.h **** {
1643:../CMSIS/core_cm4.h ****   uint32_t reg_value;
1644:../CMSIS/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 a
1645:../CMSIS/core_cm4.h **** 
1646:../CMSIS/core_cm4.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
1647:../CMSIS/core_cm4.h ****   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to chan
1648:../CMSIS/core_cm4.h ****   reg_value  =  (reg_value                                   |
1649:../CMSIS/core_cm4.h ****                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
1650:../CMSIS/core_cm4.h ****                 (PriorityGroupTmp << 8U)                      );              /* Insert write key a
1651:../CMSIS/core_cm4.h ****   SCB->AIRCR =  reg_value;
1652:../CMSIS/core_cm4.h **** }
1653:../CMSIS/core_cm4.h **** 
1654:../CMSIS/core_cm4.h **** 
1655:../CMSIS/core_cm4.h **** /**
1656:../CMSIS/core_cm4.h ****   \brief   Get Priority Grouping
1657:../CMSIS/core_cm4.h ****   \details Reads the priority grouping field from the NVIC Interrupt Controller.
1658:../CMSIS/core_cm4.h ****   \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
1659:../CMSIS/core_cm4.h ****  */
1660:../CMSIS/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
1661:../CMSIS/core_cm4.h **** {
1662:../CMSIS/core_cm4.h ****   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
1663:../CMSIS/core_cm4.h **** }
1664:../CMSIS/core_cm4.h **** 
1665:../CMSIS/core_cm4.h **** 
1666:../CMSIS/core_cm4.h **** /**
1667:../CMSIS/core_cm4.h ****   \brief   Enable Interrupt
1668:../CMSIS/core_cm4.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
1669:../CMSIS/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1670:../CMSIS/core_cm4.h ****   \note    IRQn must not be negative.
1671:../CMSIS/core_cm4.h ****  */
1672:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
1673:../CMSIS/core_cm4.h **** {
1674:../CMSIS/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1675:../CMSIS/core_cm4.h ****   {
1676:../CMSIS/core_cm4.h ****     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) &
 1036              		.loc 5 1676 0
 1037 0234 294A     		ldr	r2, .L129+20
 1038 0236 4FF40021 		mov	r1, #524288
 1039 023a 9160     		str	r1, [r2, #8]
 1040              	.LVL101:
 1041              	.L81:
 1042              	.LBE115:
 1043              	.LBE114:
 1044              	.LBE113:
 460:../drivers/fsl_enet.c ****     {
 1045              		.loc 1 460 0
 1046 023c 13F0407F 		tst	r3, #50331648
 1047 0240 06D0     		beq	.L82
 462:../drivers/fsl_enet.c ****         EnableIRQ(s_enetRxIrqId[instance]);
 1048              		.loc 1 462 0
 1049 0242 274A     		ldr	r2, .L129+24
 1050 0244 2749     		ldr	r1, .L129+28
 1051 0246 1160     		str	r1, [r2]
 1052              	.LVL102:
 1053              	.LBB116:
 1054              	.LBB117:
 1055              	.LBB118:
 1056              		.loc 5 1676 0
 1057 0248 244A     		ldr	r2, .L129+20
 1058 024a 4FF48011 		mov	r1, #1048576
 1059 024e 9160     		str	r1, [r2, #8]
 1060              	.LVL103:
 1061              	.L82:
 1062              	.LBE118:
 1063              	.LBE117:
 1064              	.LBE116:
 465:../drivers/fsl_enet.c ****     {
 1065              		.loc 1 465 0
 1066 0250 254A     		ldr	r2, .L129+32
 1067 0252 1342     		tst	r3, r2
 1068 0254 06D0     		beq	.L46
 467:../drivers/fsl_enet.c ****         EnableIRQ(s_enetErrIrqId[instance]);
 1069              		.loc 1 467 0
 1070 0256 254B     		ldr	r3, .L129+36
 1071 0258 254A     		ldr	r2, .L129+40
 1072 025a 1A60     		str	r2, [r3]
 1073              	.LVL104:
 1074              	.LBB119:
 1075              	.LBB120:
 1076              	.LBB121:
 1077              		.loc 5 1676 0
 1078 025c 1F4B     		ldr	r3, .L129+20
 1079 025e 4FF40012 		mov	r2, #2097152
 1080 0262 9A60     		str	r2, [r3, #8]
 1081              	.LVL105:
 1082              	.L46:
 1083              	.LBE121:
 1084              	.LBE120:
 1085              	.LBE119:
 1086              	.LBE122:
 1087              	.LBE124:
 401:../drivers/fsl_enet.c **** 
 1088              		.loc 1 401 0
 1089 0264 03B0     		add	sp, sp, #12
 1090              		.cfi_remember_state
 1091              		.cfi_def_cfa_offset 36
 1092              		@ sp needed
 1093 0266 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1094              	.LVL106:
 1095              	.L53:
 1096              		.cfi_restore_state
 1097              	.LBB125:
 1098              	.LBB95:
 729:../drivers/fsl_enet.c ****         {
 1099              		.loc 1 729 0
 1100 026a D3F810E0 		ldr	lr, [r3, #16]
 1101 026e BEF1000F 		cmp	lr, #0
 1102 0272 01D1     		bne	.L48
 1103              	.L49:
 764:../drivers/fsl_enet.c ****     }
 1104              		.loc 1 764 0
 1105 0274 1C33     		adds	r3, r3, #28
 1106              	.LVL107:
 1107 0276 DCE6     		b	.L47
 1108              	.L48:
 729:../drivers/fsl_enet.c ****         {
 1109              		.loc 1 729 0
 1110 0278 9969     		ldr	r1, [r3, #24]
 1111 027a 0029     		cmp	r1, #0
 1112 027c FAD0     		beq	.L49
 1113              	.LVL108:
 1114              	.LBB94:
 738:../drivers/fsl_enet.c ****             {
 1115              		.loc 1 738 0
 1116 027e B3F802C0 		ldrh	ip, [r3, #2]
 732:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1117              		.loc 1 732 0
 1118 0282 9A68     		ldr	r2, [r3, #8]
 1119 0284 0192     		str	r2, [sp, #4]
 1120              	.LVL109:
 747:../drivers/fsl_enet.c ****                 {
 1121              		.loc 1 747 0
 1122 0286 0CF1FF32 		add	r2, ip, #-1
 1123              	.LVL110:
 1124 028a 0092     		str	r2, [sp]
 738:../drivers/fsl_enet.c ****             {
 1125              		.loc 1 738 0
 1126 028c 0022     		movs	r2, #0
 1127              	.LVL111:
 1128              	.L50:
 1129 028e 6245     		cmp	r2, ip
 1130 0290 0EEBC207 		add	r7, lr, r2, lsl #3
 1131              	.LVL112:
 1132 0294 EED2     		bcs	.L49
 747:../drivers/fsl_enet.c ****                 {
 1133              		.loc 1 747 0
 1134 0296 0098     		ldr	r0, [sp]
 741:../drivers/fsl_enet.c ****                 /* Initializes data length. */
 1135              		.loc 1 741 0
 1136 0298 7960     		str	r1, [r7, #4]
 743:../drivers/fsl_enet.c ****                 /* Sets the crc. */
 1137              		.loc 1 743 0
 1138 029a 2EF832B0 		strh	fp, [lr, r2, lsl #3]	@ movhi
 747:../drivers/fsl_enet.c ****                 {
 1139              		.loc 1 747 0
 1140 029e 9042     		cmp	r0, r2
 745:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 1141              		.loc 1 745 0
 1142 02a0 A7F80280 		strh	r8, [r7, #2]	@ movhi
 749:../drivers/fsl_enet.c ****                 }
 1143              		.loc 1 749 0
 1144 02a4 01BF     		itttt	eq
 1145 02a6 7888     		ldrheq	r0, [r7, #2]
 1146 02a8 80B2     		uxtheq	r0, r0
 1147 02aa 40F40050 		orreq	r0, r0, #8192
 1148 02ae 7880     		strheq	r0, [r7, #2]	@ movhi
 1149              	.LVL113:
 1150 02b0 0198     		ldr	r0, [sp, #4]
 738:../drivers/fsl_enet.c ****             {
 1151              		.loc 1 738 0
 1152 02b2 0132     		adds	r2, r2, #1
 1153              	.LVL114:
 1154 02b4 0144     		add	r1, r1, r0
 1155 02b6 EAE7     		b	.L50
 1156              	.LVL115:
 1157              	.L60:
 1158              	.LBE94:
 1159              	.LBE95:
 1160              	.LBE125:
 1161              	.LBB126:
 1162              	.LBB100:
 800:../drivers/fsl_enet.c ****         {
 1163              		.loc 1 800 0
 1164 02b8 53F810EC 		ldr	lr, [r3, #-16]
 1165 02bc BEF1000F 		cmp	lr, #0
 1166 02c0 18D1     		bne	.L55
 1167              	.L56:
 1168              	.LVL116:
 1169 02c2 1C33     		adds	r3, r3, #28
 1170              	.LVL117:
 1171 02c4 C4E6     		b	.L54
 1172              	.L130:
 1173 02c6 00BF     		.align	2
 1174              	.L129:
 1175 02c8 2C800440 		.word	1074036780
 1176 02cc 0000FF3F 		.word	1073676288
 1177 02d0 00000000 		.word	.LANCHOR0
 1178 02d4 00000000 		.word	.LANCHOR1
 1179 02d8 00000000 		.word	ENET_TransmitIRQHandler
 1180 02dc 00E100E0 		.word	-536813312
 1181 02e0 00000000 		.word	.LANCHOR2
 1182 02e4 00000000 		.word	ENET_ReceiveIRQHandler
 1183 02e8 00007C60 		.word	1618739200
 1184 02ec 00000000 		.word	.LANCHOR3
 1185 02f0 00000000 		.word	ENET_ErrorIRQHandler
 1186              	.L55:
 1187 02f4 53F8081C 		ldr	r1, [r3, #-8]
 1188 02f8 0029     		cmp	r1, #0
 1189 02fa E2D0     		beq	.L56
 1190              	.LVL118:
 1191              	.LBB99:
 809:../drivers/fsl_enet.c ****             {
 1192              		.loc 1 809 0
 1193 02fc 33F81CCC 		ldrh	ip, [r3, #-28]
 803:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1194              		.loc 1 803 0
 1195 0300 53F8182C 		ldr	r2, [r3, #-24]
 1196 0304 0192     		str	r2, [sp, #4]
 1197              	.LVL119:
 818:../drivers/fsl_enet.c ****                 {
 1198              		.loc 1 818 0
 1199 0306 0CF1FF3A 		add	r10, ip, #-1
 809:../drivers/fsl_enet.c ****             {
 1200              		.loc 1 809 0
 1201 030a 0022     		movs	r2, #0
 1202              	.LVL120:
 1203              	.L57:
 1204 030c 6245     		cmp	r2, ip
 1205 030e 0EEBC207 		add	r7, lr, r2, lsl #3
 1206              	.LVL121:
 1207 0312 D6D2     		bcs	.L56
 812:../drivers/fsl_enet.c ****                 curBuffDescrip->length = 0;
 1208              		.loc 1 812 0
 1209 0314 7960     		str	r1, [r7, #4]
 813:../drivers/fsl_enet.c **** 
 1210              		.loc 1 813 0
 1211 0316 2EF832B0 		strh	fp, [lr, r2, lsl #3]	@ movhi
 818:../drivers/fsl_enet.c ****                 {
 1212              		.loc 1 818 0
 1213 031a 5245     		cmp	r2, r10
 816:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 1214              		.loc 1 816 0
 1215 031c A7F80280 		strh	r8, [r7, #2]	@ movhi
 820:../drivers/fsl_enet.c ****                 }
 1216              		.loc 1 820 0
 1217 0320 01BF     		itttt	eq
 1218 0322 7888     		ldrheq	r0, [r7, #2]
 1219 0324 80B2     		uxtheq	r0, r0
 1220 0326 40F40050 		orreq	r0, r0, #8192
 1221 032a 7880     		strheq	r0, [r7, #2]	@ movhi
 1222              	.LVL122:
 1223 032c 0198     		ldr	r0, [sp, #4]
 809:../drivers/fsl_enet.c ****             {
 1224              		.loc 1 809 0
 1225 032e 0132     		adds	r2, r2, #1
 1226              	.LVL123:
 1227 0330 0144     		add	r1, r1, r0
 1228 0332 EBE7     		b	.L57
 1229              	.LBE99:
 1230              	.LBE100:
 1231              	.LBE126:
 1232              		.cfi_endproc
 1233              	.LFE159:
 1235              		.section	.text.ENET_StartSMIWrite,"ax",%progbits
 1236              		.align	1
 1237              		.global	ENET_StartSMIWrite
 1238              		.syntax unified
 1239              		.thumb
 1240              		.thumb_func
 1241              		.fpu fpv4-sp-d16
 1243              	ENET_StartSMIWrite:
 1244              	.LFB171:
 961:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 1245              		.loc 1 961 0
 1246              		.cfi_startproc
 1247              		@ args = 4, pretend = 0, frame = 0
 1248              		@ frame_needed = 0, uses_anonymous_args = 0
 1249              	.LVL124:
 1250 0000 10B5     		push	{r4, lr}
 1251              		.cfi_def_cfa_offset 8
 1252              		.cfi_offset 4, -8
 1253              		.cfi_offset 14, -4
 966:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 1254              		.loc 1 966 0
 1255 0002 BDF80840 		ldrh	r4, [sp, #8]
 965:../drivers/fsl_enet.c ****            (data & 0xFFFF);
 1256              		.loc 1 965 0
 1257 0006 9204     		lsls	r2, r2, #18
 1258              	.LVL125:
 1259 0008 44F08044 		orr	r4, r4, #1073741824
 1260 000c 02F4F802 		and	r2, r2, #8126464
 1261 0010 44F40034 		orr	r4, r4, #131072
 1262 0014 C905     		lsls	r1, r1, #23
 1263              	.LVL126:
 1264 0016 2243     		orrs	r2, r2, r4
 1265 0018 01F07861 		and	r1, r1, #260046848
 1266 001c 1B07     		lsls	r3, r3, #28
 1267              	.LVL127:
 1268 001e 0A43     		orrs	r2, r2, r1
 1269 0020 03F04053 		and	r3, r3, #805306368
 1270 0024 1A43     		orrs	r2, r2, r3
 1271              	.LVL128:
 967:../drivers/fsl_enet.c **** }
 1272              		.loc 1 967 0
 1273 0026 0264     		str	r2, [r0, #64]
 1274 0028 10BD     		pop	{r4, pc}
 1275              		.cfi_endproc
 1276              	.LFE171:
 1278              		.section	.text.ENET_StartSMIRead,"ax",%progbits
 1279              		.align	1
 1280              		.global	ENET_StartSMIRead
 1281              		.syntax unified
 1282              		.thumb
 1283              		.thumb_func
 1284              		.fpu fpv4-sp-d16
 1286              	ENET_StartSMIRead:
 1287              	.LFB172:
 971:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 1288              		.loc 1 971 0
 1289              		.cfi_startproc
 1290              		@ args = 0, pretend = 0, frame = 0
 1291              		@ frame_needed = 0, uses_anonymous_args = 0
 1292              		@ link register save eliminated.
 1293              	.LVL129:
 975:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 1294              		.loc 1 975 0
 1295 0000 9204     		lsls	r2, r2, #18
 1296              	.LVL130:
 1297 0002 02F4F802 		and	r2, r2, #8126464
 1298 0006 42F08042 		orr	r2, r2, #1073741824
 1299 000a C905     		lsls	r1, r1, #23
 1300              	.LVL131:
 1301 000c 42F40032 		orr	r2, r2, #131072
 1302 0010 01F07861 		and	r1, r1, #260046848
 1303 0014 1B07     		lsls	r3, r3, #28
 1304              	.LVL132:
 1305 0016 0A43     		orrs	r2, r2, r1
 1306 0018 03F04053 		and	r3, r3, #805306368
 1307 001c 1A43     		orrs	r2, r2, r3
 1308              	.LVL133:
 976:../drivers/fsl_enet.c **** }
 1309              		.loc 1 976 0
 1310 001e 0264     		str	r2, [r0, #64]
 1311 0020 7047     		bx	lr
 1312              		.cfi_endproc
 1313              	.LFE172:
 1315              		.section	.text.ENET_GetRxErrBeforeReadFrame,"ax",%progbits
 1316              		.align	1
 1317              		.global	ENET_GetRxErrBeforeReadFrame
 1318              		.syntax unified
 1319              		.thumb
 1320              		.thumb_func
 1321              		.fpu fpv4-sp-d16
 1323              	ENET_GetRxErrBeforeReadFrame:
 1324              	.LFB173:
1020:../drivers/fsl_enet.c ****     assert(handle);
 1325              		.loc 1 1020 0
 1326              		.cfi_startproc
 1327              		@ args = 0, pretend = 0, frame = 0
 1328              		@ frame_needed = 0, uses_anonymous_args = 0
 1329              	.LVL134:
 1330 0000 10B5     		push	{r4, lr}
 1331              		.cfi_def_cfa_offset 8
 1332              		.cfi_offset 4, -8
 1333              		.cfi_offset 14, -4
1026:../drivers/fsl_enet.c **** 
 1334              		.loc 1 1026 0
 1335 0002 4268     		ldr	r2, [r0, #4]
 1336              	.LVL135:
 1337 0004 1346     		mov	r3, r2
 1338              	.LVL136:
 1339              	.L143:
1031:../drivers/fsl_enet.c ****         {
 1340              		.loc 1 1031 0
 1341 0006 5C88     		ldrh	r4, [r3, #2]
 1342 0008 2405     		lsls	r4, r4, #20
 1343 000a 1BD5     		bpl	.L134
1033:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
 1344              		.loc 1 1033 0
 1345 000c 5B88     		ldrh	r3, [r3, #2]
 1346              	.LVL137:
 1347 000e 9BB2     		uxth	r3, r3
 1348              	.LVL138:
1034:../drivers/fsl_enet.c ****             {
 1349              		.loc 1 1034 0
 1350 0010 DA07     		lsls	r2, r3, #31
1037:../drivers/fsl_enet.c ****             }
 1351              		.loc 1 1037 0
 1352 0012 42BF     		ittt	mi
 1353 0014 0A69     		ldrmi	r2, [r1, #16]
 1354 0016 0132     		addmi	r2, r2, #1
 1355 0018 0A61     		strmi	r2, [r1, #16]
1039:../drivers/fsl_enet.c ****             {
 1356              		.loc 1 1039 0
 1357 001a 9C07     		lsls	r4, r3, #30
1042:../drivers/fsl_enet.c ****             }
 1358              		.loc 1 1042 0
 1359 001c 42BF     		ittt	mi
 1360 001e CA68     		ldrmi	r2, [r1, #12]
 1361 0020 0132     		addmi	r2, r2, #1
 1362 0022 CA60     		strmi	r2, [r1, #12]
1044:../drivers/fsl_enet.c ****             {
 1363              		.loc 1 1044 0
 1364 0024 9806     		lsls	r0, r3, #26
 1365              	.LVL139:
1047:../drivers/fsl_enet.c ****             }
 1366              		.loc 1 1047 0
 1367 0026 42BF     		ittt	mi
 1368 0028 0A68     		ldrmi	r2, [r1]
 1369 002a 0132     		addmi	r2, r2, #1
 1370 002c 0A60     		strmi	r2, [r1]
1049:../drivers/fsl_enet.c ****             {
 1371              		.loc 1 1049 0
 1372 002e DA06     		lsls	r2, r3, #27
1052:../drivers/fsl_enet.c ****             }
 1373              		.loc 1 1052 0
 1374 0030 42BF     		ittt	mi
 1375 0032 4A68     		ldrmi	r2, [r1, #4]
 1376 0034 0132     		addmi	r2, r2, #1
 1377 0036 4A60     		strmi	r2, [r1, #4]
1054:../drivers/fsl_enet.c ****             {
 1378              		.loc 1 1054 0
 1379 0038 5B07     		lsls	r3, r3, #29
 1380              	.LVL140:
 1381 003a 0AD5     		bpl	.L133
1057:../drivers/fsl_enet.c ****             }
 1382              		.loc 1 1057 0
 1383 003c 8B68     		ldr	r3, [r1, #8]
 1384 003e 0133     		adds	r3, r3, #1
 1385 0040 8B60     		str	r3, [r1, #8]
 1386 0042 10BD     		pop	{r4, pc}
 1387              	.LVL141:
 1388              	.L134:
1082:../drivers/fsl_enet.c ****         {
 1389              		.loc 1 1082 0
 1390 0044 5C88     		ldrh	r4, [r3, #2]
 1391 0046 A404     		lsls	r4, r4, #18
1084:../drivers/fsl_enet.c ****         }
 1392              		.loc 1 1084 0
 1393 0048 4CBF     		ite	mi
 1394 004a 0368     		ldrmi	r3, [r0]
 1395              	.LVL142:
1088:../drivers/fsl_enet.c ****         }
 1396              		.loc 1 1088 0
 1397 004c 0833     		addpl	r3, r3, #8
 1398              	.LVL143:
1091:../drivers/fsl_enet.c **** }
 1399              		.loc 1 1091 0
 1400 004e 9342     		cmp	r3, r2
 1401 0050 D9D1     		bne	.L143
 1402              	.LVL144:
 1403              	.L133:
 1404 0052 10BD     		pop	{r4, pc}
 1405              		.cfi_endproc
 1406              	.LFE173:
 1408              		.section	.text.ENET_GetRxFrameSize,"ax",%progbits
 1409              		.align	1
 1410              		.global	ENET_GetRxFrameSize
 1411              		.syntax unified
 1412              		.thumb
 1413              		.thumb_func
 1414              		.fpu fpv4-sp-d16
 1416              	ENET_GetRxFrameSize:
 1417              	.LFB174:
1095:../drivers/fsl_enet.c ****     assert(handle);
 1418              		.loc 1 1095 0
 1419              		.cfi_startproc
 1420              		@ args = 0, pretend = 0, frame = 0
 1421              		@ frame_needed = 0, uses_anonymous_args = 0
 1422              	.LVL145:
 1423 0000 30B5     		push	{r4, r5, lr}
 1424              		.cfi_def_cfa_offset 12
 1425              		.cfi_offset 4, -12
 1426              		.cfi_offset 5, -8
 1427              		.cfi_offset 14, -4
1104:../drivers/fsl_enet.c **** 
 1428              		.loc 1 1104 0
 1429 0002 4468     		ldr	r4, [r0, #4]
1101:../drivers/fsl_enet.c **** 
 1430              		.loc 1 1101 0
 1431 0004 0023     		movs	r3, #0
 1432 0006 0B60     		str	r3, [r1]
 1433              	.LVL146:
1107:../drivers/fsl_enet.c ****     {
 1434              		.loc 1 1107 0
 1435 0008 6388     		ldrh	r3, [r4, #2]
 1436 000a 1D04     		lsls	r5, r3, #16
 1437 000c 1CD4     		bmi	.L165
1121:../drivers/fsl_enet.c ****         {
 1438              		.loc 1 1121 0
 1439 000e 114D     		ldr	r5, .L169
 1440 0010 2346     		mov	r3, r4
 1441              	.LVL147:
 1442              	.L164:
1115:../drivers/fsl_enet.c ****         {
 1443              		.loc 1 1115 0
 1444 0012 5A88     		ldrh	r2, [r3, #2]
 1445 0014 1204     		lsls	r2, r2, #16
 1446 0016 02D4     		bmi	.L160
1115:../drivers/fsl_enet.c ****         {
 1447              		.loc 1 1115 0 is_stmt 0 discriminator 1
 1448 0018 1A88     		ldrh	r2, [r3]
 1449 001a 92B2     		uxth	r2, r2
 1450 001c BAB1     		cbz	r2, .L167
 1451              	.L160:
1121:../drivers/fsl_enet.c ****         {
 1452              		.loc 1 1121 0 is_stmt 1
 1453 001e 5A88     		ldrh	r2, [r3, #2]
 1454 0020 92B2     		uxth	r2, r2
 1455 0022 2A40     		ands	r2, r2, r5
 1456 0024 B2F5006F 		cmp	r2, #2048
 1457 0028 07D1     		bne	.L161
1124:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1458              		.loc 1 1124 0
 1459 002a 5888     		ldrh	r0, [r3, #2]
 1460              	.LVL148:
 1461 002c 10F03700 		ands	r0, r0, #55
 1462 0030 0DD1     		bne	.L167
1133:../drivers/fsl_enet.c ****             return kStatus_Success;
 1463              		.loc 1 1133 0
 1464 0032 1B88     		ldrh	r3, [r3]
 1465              	.LVL149:
 1466 0034 9BB2     		uxth	r3, r3
 1467 0036 0B60     		str	r3, [r1]
1134:../drivers/fsl_enet.c ****         }
 1468              		.loc 1 1134 0
 1469 0038 30BD     		pop	{r4, r5, pc}
 1470              	.LVL150:
 1471              	.L161:
1137:../drivers/fsl_enet.c ****         {
 1472              		.loc 1 1137 0
 1473 003a 5A88     		ldrh	r2, [r3, #2]
 1474 003c 9204     		lsls	r2, r2, #18
1139:../drivers/fsl_enet.c ****         }
 1475              		.loc 1 1139 0
 1476 003e 4CBF     		ite	mi
 1477 0040 0368     		ldrmi	r3, [r0]
 1478              	.LVL151:
1143:../drivers/fsl_enet.c ****         }
 1479              		.loc 1 1143 0
 1480 0042 0833     		addpl	r3, r3, #8
 1481              	.LVL152:
1146:../drivers/fsl_enet.c **** 
 1482              		.loc 1 1146 0
 1483 0044 A342     		cmp	r3, r4
 1484 0046 E4D1     		bne	.L164
 1485              	.LVL153:
 1486              	.L165:
1109:../drivers/fsl_enet.c ****     }
 1487              		.loc 1 1109 0
 1488 0048 40F6A270 		movw	r0, #4002
 1489              	.LVL154:
 1490 004c 30BD     		pop	{r4, r5, pc}
 1491              	.LVL155:
 1492              	.L167:
1117:../drivers/fsl_enet.c ****         }
 1493              		.loc 1 1117 0
 1494 004e 4FF47A60 		mov	r0, #4000
1150:../drivers/fsl_enet.c **** 
 1495              		.loc 1 1150 0
 1496 0052 30BD     		pop	{r4, r5, pc}
 1497              	.L170:
 1498              		.align	2
 1499              	.L169:
 1500 0054 0088FFFF 		.word	-30720
 1501              		.cfi_endproc
 1502              	.LFE174:
 1504              		.section	.text.ENET_ReadFrame,"ax",%progbits
 1505              		.align	1
 1506              		.global	ENET_ReadFrame
 1507              		.syntax unified
 1508              		.thumb
 1509              		.thumb_func
 1510              		.fpu fpv4-sp-d16
 1512              	ENET_ReadFrame:
 1513              	.LFB175:
1153:../drivers/fsl_enet.c ****     assert(handle);
 1514              		.loc 1 1153 0
 1515              		.cfi_startproc
 1516              		@ args = 0, pretend = 0, frame = 0
 1517              		@ frame_needed = 0, uses_anonymous_args = 0
 1518              	.LVL156:
 1519 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1520              		.cfi_def_cfa_offset 32
 1521              		.cfi_offset 4, -32
 1522              		.cfi_offset 5, -28
 1523              		.cfi_offset 6, -24
 1524              		.cfi_offset 7, -20
 1525              		.cfi_offset 8, -16
 1526              		.cfi_offset 9, -12
 1527              		.cfi_offset 10, -8
 1528              		.cfi_offset 14, -4
1153:../drivers/fsl_enet.c ****     assert(handle);
 1529              		.loc 1 1153 0
 1530 0004 0646     		mov	r6, r0
 1531 0006 0D46     		mov	r5, r1
 1532 0008 9946     		mov	r9, r3
1161:../drivers/fsl_enet.c ****     status_t result = kStatus_Success;
 1533              		.loc 1 1161 0
 1534 000a 4F68     		ldr	r7, [r1, #4]
 1535              	.LVL157:
1166:../drivers/fsl_enet.c ****     {
 1536              		.loc 1 1166 0
 1537 000c 9246     		mov	r10, r2
 1538 000e 72B9     		cbnz	r2, .L172
 1539              	.LVL158:
 1540              	.L174:
1171:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
 1541              		.loc 1 1171 0
 1542 0010 6B68     		ldr	r3, [r5, #4]
 1543 0012 5C88     		ldrh	r4, [r3, #2]
1173:../drivers/fsl_enet.c **** 
 1544              		.loc 1 1173 0
 1545 0014 3046     		mov	r0, r6
1171:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
 1546              		.loc 1 1171 0
 1547 0016 A4B2     		uxth	r4, r4
 1548              	.LVL159:
1173:../drivers/fsl_enet.c **** 
 1549              		.loc 1 1173 0
 1550 0018 2946     		mov	r1, r5
 1551              	.LVL160:
 1552 001a FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1553              	.LVL161:
1176:../drivers/fsl_enet.c ****             {
 1554              		.loc 1 1176 0
 1555 001e 14F40060 		ands	r0, r4, #2048
 1556 0022 1BD1     		bne	.L181
 1557              	.LVL162:
1181:../drivers/fsl_enet.c **** 
 1558              		.loc 1 1181 0
 1559 0024 6B68     		ldr	r3, [r5, #4]
 1560 0026 9F42     		cmp	r7, r3
 1561 0028 F2D1     		bne	.L174
 1562 002a BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1563              	.LVL163:
 1564              	.L172:
 1565 002e 4FF00008 		mov	r8, #0
 1566              	.LVL164:
 1567              	.L180:
1213:../drivers/fsl_enet.c ****             {
 1568              		.loc 1 1213 0
 1569 0032 7B88     		ldrh	r3, [r7, #2]
 1570 0034 13F40064 		ands	r4, r3, #2048
 1571 0038 1CD0     		beq	.L175
 1572              	.LVL165:
1217:../drivers/fsl_enet.c ****                 {
 1573              		.loc 1 1217 0
 1574 003a 3B88     		ldrh	r3, [r7]
 1575 003c 9BB2     		uxth	r3, r3
 1576 003e 9945     		cmp	r9, r3
 1577 0040 0FD1     		bne	.L176
1220:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1578              		.loc 1 1220 0
 1579 0042 3A88     		ldrh	r2, [r7]
1224:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1580              		.loc 1 1224 0
 1581 0044 7968     		ldr	r1, [r7, #4]
 1582              	.LVL166:
1220:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1583              		.loc 1 1220 0
 1584 0046 92B2     		uxth	r2, r2
 1585              	.LVL167:
1226:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1586              		.loc 1 1226 0
 1587 0048 A2EB0802 		sub	r2, r2, r8
 1588              	.LVL168:
 1589 004c 0AEB0800 		add	r0, r10, r8
 1590 0050 FFF7FEFF 		bl	memcpy
 1591              	.LVL169:
1238:../drivers/fsl_enet.c ****                     return result;
 1592              		.loc 1 1238 0
 1593 0054 2946     		mov	r1, r5
 1594 0056 3046     		mov	r0, r6
 1595 0058 FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1596              	.LVL170:
 1597              	.L181:
1183:../drivers/fsl_enet.c ****     }
 1598              		.loc 1 1183 0
 1599 005c 0020     		movs	r0, #0
1283:../drivers/fsl_enet.c **** 
 1600              		.loc 1 1283 0
 1601 005e BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1602              	.LVL171:
 1603              	.L176:
1244:../drivers/fsl_enet.c ****                 }
 1604              		.loc 1 1244 0
 1605 0062 2946     		mov	r1, r5
 1606              	.LVL172:
 1607 0064 3046     		mov	r0, r6
 1608              	.LVL173:
 1609 0066 FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1610              	.LVL174:
1216:../drivers/fsl_enet.c ****                 if (length == curBuffDescrip->length)
 1611              		.loc 1 1216 0
 1612 006a 0124     		movs	r4, #1
 1613              	.LVL175:
 1614              	.L177:
1269:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
 1615              		.loc 1 1269 0
 1616 006c 6F68     		ldr	r7, [r5, #4]
 1617              	.LVL176:
1210:../drivers/fsl_enet.c ****         {
 1618              		.loc 1 1210 0
 1619 006e 002C     		cmp	r4, #0
 1620 0070 DFD0     		beq	.L180
 1621 0072 01E0     		b	.L179
 1622              	.LVL177:
 1623              	.L175:
1252:../drivers/fsl_enet.c ****                 {
 1624              		.loc 1 1252 0
 1625 0074 C145     		cmp	r9, r8
 1626 0076 03D8     		bhi	.L178
 1627              	.LVL178:
 1628              	.L179:
1282:../drivers/fsl_enet.c **** }
 1629              		.loc 1 1282 0
 1630 0078 40F6A170 		movw	r0, #4001
 1631              	.LVL179:
 1632 007c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1633              	.LVL180:
 1634              	.L178:
1259:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1635              		.loc 1 1259 0
 1636 0080 7968     		ldr	r1, [r7, #4]
 1637              	.LVL181:
1261:../drivers/fsl_enet.c ****                 offset += handle->rxBuffSizeAlign[0];
 1638              		.loc 1 1261 0
 1639 0082 2A69     		ldr	r2, [r5, #16]
 1640 0084 0AEB0800 		add	r0, r10, r8
 1641              	.LVL182:
 1642 0088 FFF7FEFF 		bl	memcpy
 1643              	.LVL183:
1262:../drivers/fsl_enet.c **** 
 1644              		.loc 1 1262 0
 1645 008c 2B69     		ldr	r3, [r5, #16]
1265:../drivers/fsl_enet.c ****             }
 1646              		.loc 1 1265 0
 1647 008e 2946     		mov	r1, r5
 1648 0090 3046     		mov	r0, r6
1262:../drivers/fsl_enet.c **** 
 1649              		.loc 1 1262 0
 1650 0092 9844     		add	r8, r8, r3
 1651              	.LVL184:
1265:../drivers/fsl_enet.c ****             }
 1652              		.loc 1 1265 0
 1653 0094 FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1654              	.LVL185:
 1655 0098 E8E7     		b	.L177
 1656              		.cfi_endproc
 1657              	.LFE175:
 1659              		.section	.text.ENET_SendFrame,"ax",%progbits
 1660              		.align	1
 1661              		.global	ENET_SendFrame
 1662              		.syntax unified
 1663              		.thumb
 1664              		.thumb_func
 1665              		.fpu fpv4-sp-d16
 1667              	ENET_SendFrame:
 1668              	.LFB177:
1326:../drivers/fsl_enet.c ****     assert(handle);
 1669              		.loc 1 1326 0
 1670              		.cfi_startproc
 1671              		@ args = 0, pretend = 0, frame = 0
 1672              		@ frame_needed = 0, uses_anonymous_args = 0
 1673              	.LVL186:
 1674 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1675              		.cfi_def_cfa_offset 40
 1676              		.cfi_offset 3, -40
 1677              		.cfi_offset 4, -36
 1678              		.cfi_offset 5, -32
 1679              		.cfi_offset 6, -28
 1680              		.cfi_offset 7, -24
 1681              		.cfi_offset 8, -20
 1682              		.cfi_offset 9, -16
 1683              		.cfi_offset 10, -12
 1684              		.cfi_offset 11, -8
 1685              		.cfi_offset 14, -4
1326:../drivers/fsl_enet.c ****     assert(handle);
 1686              		.loc 1 1326 0
 1687 0004 1E46     		mov	r6, r3
1336:../drivers/fsl_enet.c ****     {
 1688              		.loc 1 1336 0
 1689 0006 40F2EE53 		movw	r3, #1518
 1690              	.LVL187:
 1691 000a 9E42     		cmp	r6, r3
1326:../drivers/fsl_enet.c ****     assert(handle);
 1692              		.loc 1 1326 0
 1693 000c 0746     		mov	r7, r0
 1694 000e 0D46     		mov	r5, r1
 1695 0010 9146     		mov	r9, r2
1336:../drivers/fsl_enet.c ****     {
 1696              		.loc 1 1336 0
 1697 0012 5DD8     		bhi	.L194
1342:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
 1698              		.loc 1 1342 0
 1699 0014 CC68     		ldr	r4, [r1, #12]
 1700              	.LVL188:
1343:../drivers/fsl_enet.c ****     {
 1701              		.loc 1 1343 0
 1702 0016 6388     		ldrh	r3, [r4, #2]
 1703 0018 1804     		lsls	r0, r3, #16
 1704              	.LVL189:
 1705 001a 03D5     		bpl	.L185
 1706              	.LVL190:
 1707              	.L193:
1345:../drivers/fsl_enet.c ****     }
 1708              		.loc 1 1345 0
 1709 001c 40F6A470 		movw	r0, #4004
 1710 0020 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1711              	.LVL191:
 1712              	.L185:
1353:../drivers/fsl_enet.c ****     {
 1713              		.loc 1 1353 0
 1714 0024 4B69     		ldr	r3, [r1, #20]
 1715 0026 9E42     		cmp	r6, r3
 1716 0028 18D8     		bhi	.L186
1361:../drivers/fsl_enet.c ****         /* Set data length. */
 1717              		.loc 1 1361 0
 1718 002a 3246     		mov	r2, r6
 1719              	.LVL192:
 1720 002c 4946     		mov	r1, r9
 1721              	.LVL193:
1359:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1722              		.loc 1 1359 0
 1723 002e 6068     		ldr	r0, [r4, #4]
 1724              	.LVL194:
1363:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1725              		.loc 1 1363 0
 1726 0030 B6B2     		uxth	r6, r6
 1727              	.LVL195:
1361:../drivers/fsl_enet.c ****         /* Set data length. */
 1728              		.loc 1 1361 0
 1729 0032 FFF7FEFF 		bl	memcpy
 1730              	.LVL196:
1363:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1731              		.loc 1 1363 0
 1732 0036 2680     		strh	r6, [r4]	@ movhi
1376:../drivers/fsl_enet.c **** 
 1733              		.loc 1 1376 0
 1734 0038 6388     		ldrh	r3, [r4, #2]
 1735 003a 9BB2     		uxth	r3, r3
 1736 003c 43F40843 		orr	r3, r3, #34816
 1737 0040 6380     		strh	r3, [r4, #2]	@ movhi
1379:../drivers/fsl_enet.c ****         {
 1738              		.loc 1 1379 0
 1739 0042 6388     		ldrh	r3, [r4, #2]
 1740 0044 9904     		lsls	r1, r3, #18
1385:../drivers/fsl_enet.c ****         }
 1741              		.loc 1 1385 0
 1742 0046 56BF     		itet	pl
 1743 0048 EB68     		ldrpl	r3, [r5, #12]
1381:../drivers/fsl_enet.c ****         }
 1744              		.loc 1 1381 0
 1745 004a AB68     		ldrmi	r3, [r5, #8]
1385:../drivers/fsl_enet.c ****         }
 1746              		.loc 1 1385 0
 1747 004c 0833     		addpl	r3, r3, #8
 1748 004e EB60     		str	r3, [r5, #12]
 1749              	.LVL197:
 1750              	.L198:
 1751              	.LBB127:
 1752              	.LBB128:
 849:../drivers/fsl_enet.c ****             break;
 1753              		.loc 1 849 0
 1754 0050 4FF08073 		mov	r3, #16777216
 1755 0054 7B61     		str	r3, [r7, #20]
 1756              	.LVL198:
 1757              	.LBE128:
 1758              	.LBE127:
1470:../drivers/fsl_enet.c ****             }
 1759              		.loc 1 1470 0
 1760 0056 0020     		movs	r0, #0
 1761 0058 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1762              	.LVL199:
 1763              	.L186:
 1764 005c 4FF00008 		mov	r8, #0
 1765              	.LBB129:
 1766              	.LBB130:
 849:../drivers/fsl_enet.c ****             break;
 1767              		.loc 1 849 0
 1768 0060 4FF0807A 		mov	r10, #16777216
 1769              	.LVL200:
 1770              	.L192:
 1771              	.LBE130:
 1772              	.LBE129:
1419:../drivers/fsl_enet.c ****             {
 1773              		.loc 1 1419 0
 1774 0064 6388     		ldrh	r3, [r4, #2]
1435:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1775              		.loc 1 1435 0
 1776 0066 6068     		ldr	r0, [r4, #4]
1419:../drivers/fsl_enet.c ****             {
 1777              		.loc 1 1419 0
 1778 0068 9A04     		lsls	r2, r3, #18
1425:../drivers/fsl_enet.c ****             }
 1779              		.loc 1 1425 0
 1780 006a 58BF     		it	pl
 1781 006c EB68     		ldrpl	r3, [r5, #12]
1429:../drivers/fsl_enet.c ****             {
 1782              		.loc 1 1429 0
 1783 006e 6A69     		ldr	r2, [r5, #20]
1421:../drivers/fsl_enet.c ****             }
 1784              		.loc 1 1421 0
 1785 0070 48BF     		it	mi
 1786 0072 AB68     		ldrmi	r3, [r5, #8]
1428:../drivers/fsl_enet.c ****             if (sizeleft > handle->txBuffSizeAlign[0])
 1787              		.loc 1 1428 0
 1788 0074 A6EB080B 		sub	fp, r6, r8
 1789              	.LVL201:
1425:../drivers/fsl_enet.c ****             }
 1790              		.loc 1 1425 0
 1791 0078 58BF     		it	pl
 1792 007a 0833     		addpl	r3, r3, #8
1429:../drivers/fsl_enet.c ****             {
 1793              		.loc 1 1429 0
 1794 007c 9345     		cmp	fp, r2
1425:../drivers/fsl_enet.c ****             }
 1795              		.loc 1 1425 0
 1796 007e EB60     		str	r3, [r5, #12]
 1797 0080 09EB0801 		add	r1, r9, r8
1429:../drivers/fsl_enet.c ****             {
 1798              		.loc 1 1429 0
 1799 0084 17D9     		bls	.L191
 1800              	.LVL202:
1437:../drivers/fsl_enet.c ****                 /* Data length update. */
 1801              		.loc 1 1437 0
 1802 0086 FFF7FEFF 		bl	memcpy
 1803              	.LVL203:
1439:../drivers/fsl_enet.c ****                 len += handle->txBuffSizeAlign[0];
 1804              		.loc 1 1439 0
 1805 008a 6B69     		ldr	r3, [r5, #20]
 1806 008c 9AB2     		uxth	r2, r3
 1807 008e 2280     		strh	r2, [r4]	@ movhi
1442:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
 1808              		.loc 1 1442 0
 1809 0090 6288     		ldrh	r2, [r4, #2]
 1810 0092 22F40062 		bic	r2, r2, #2048
 1811 0096 1204     		lsls	r2, r2, #16
 1812 0098 120C     		lsrs	r2, r2, #16
 1813 009a 6280     		strh	r2, [r4, #2]	@ movhi
1440:../drivers/fsl_enet.c ****                 /* Sets the control flag. */
 1814              		.loc 1 1440 0
 1815 009c 9844     		add	r8, r8, r3
 1816              	.LVL204:
1443:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
 1817              		.loc 1 1443 0
 1818 009e 6388     		ldrh	r3, [r4, #2]
 1819 00a0 9BB2     		uxth	r3, r3
 1820 00a2 43F40043 		orr	r3, r3, #32768
 1821 00a6 6380     		strh	r3, [r4, #2]	@ movhi
 1822              	.LVL205:
1474:../drivers/fsl_enet.c **** 
 1823              		.loc 1 1474 0
 1824 00a8 EC68     		ldr	r4, [r5, #12]
 1825              	.LVL206:
 1826              	.LBB132:
 1827              	.LBB131:
 849:../drivers/fsl_enet.c ****             break;
 1828              		.loc 1 849 0
 1829 00aa C7F814A0 		str	r10, [r7, #20]
 1830              	.LVL207:
 1831              	.LBE131:
 1832              	.LBE132:
1476:../drivers/fsl_enet.c **** 
 1833              		.loc 1 1476 0
 1834 00ae 6388     		ldrh	r3, [r4, #2]
 1835 00b0 1B04     		lsls	r3, r3, #16
 1836 00b2 D7D5     		bpl	.L192
 1837 00b4 B2E7     		b	.L193
 1838              	.L191:
 1839              	.LVL208:
1454:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
 1840              		.loc 1 1454 0
 1841 00b6 5A46     		mov	r2, fp
1455:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
 1842              		.loc 1 1455 0
 1843 00b8 1FFA8BFB 		uxth	fp, fp
 1844              	.LVL209:
1454:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
 1845              		.loc 1 1454 0
 1846 00bc FFF7FEFF 		bl	memcpy
 1847              	.LVL210:
1455:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
 1848              		.loc 1 1455 0
 1849 00c0 A4F800B0 		strh	fp, [r4]	@ movhi
1457:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
 1850              		.loc 1 1457 0
 1851 00c4 6388     		ldrh	r3, [r4, #2]
 1852 00c6 9BB2     		uxth	r3, r3
 1853 00c8 43F40843 		orr	r3, r3, #34816
 1854 00cc 6380     		strh	r3, [r4, #2]	@ movhi
 1855 00ce BFE7     		b	.L198
 1856              	.LVL211:
 1857              	.L194:
1338:../drivers/fsl_enet.c ****     }
 1858              		.loc 1 1338 0
 1859 00d0 40F6A370 		movw	r0, #4003
 1860              	.LVL212:
1480:../drivers/fsl_enet.c **** 
 1861              		.loc 1 1480 0
 1862 00d4 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1863              		.cfi_endproc
 1864              	.LFE177:
 1866              		.section	.text.ENET_AddMulticastGroup,"ax",%progbits
 1867              		.align	1
 1868              		.global	ENET_AddMulticastGroup
 1869              		.syntax unified
 1870              		.thumb
 1871              		.thumb_func
 1872              		.fpu fpv4-sp-d16
 1874              	ENET_AddMulticastGroup:
 1875              	.LFB178:
1926:../drivers/fsl_enet.c ****     assert(address);
 1876              		.loc 1 1926 0
 1877              		.cfi_startproc
 1878              		@ args = 0, pretend = 0, frame = 0
 1879              		@ frame_needed = 0, uses_anonymous_args = 0
 1880              	.LVL213:
 1881 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1882              		.cfi_def_cfa_offset 20
 1883              		.cfi_offset 4, -20
 1884              		.cfi_offset 5, -16
 1885              		.cfi_offset 6, -12
 1886              		.cfi_offset 7, -8
 1887              		.cfi_offset 14, -4
 1888              	.LBB133:
1943:../drivers/fsl_enet.c ****             }
 1889              		.loc 1 1943 0
 1890 0002 174E     		ldr	r6, .L208
 1891 0004 4C1E     		subs	r4, r1, #1
 1892              	.LBE133:
1929:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
 1893              		.loc 1 1929 0
 1894 0006 4FF0FF33 		mov	r3, #-1
 1895 000a 0531     		adds	r1, r1, #5
 1896              	.LVL214:
 1897              	.L203:
 1898              	.LBB134:
1936:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
 1899              		.loc 1 1936 0
 1900 000c 14F8012F 		ldrb	r2, [r4, #1]!	@ zero_extendqisi2
 1901              	.LVL215:
 1902 0010 0825     		movs	r5, #8
 1903              	.LVL216:
 1904              	.L202:
1939:../drivers/fsl_enet.c ****             {
 1905              		.loc 1 1939 0
 1906 0012 82EA0307 		eor	r7, r2, r3
 1907 0016 17F0010F 		tst	r7, #1
 1908 001a 4FEA5303 		lsr	r3, r3, #1
 1909              	.LVL217:
 1910 001e 4FEA5202 		lsr	r2, r2, #1
 1911              	.LVL218:
1943:../drivers/fsl_enet.c ****             }
 1912              		.loc 1 1943 0
 1913 0022 18BF     		it	ne
 1914 0024 7340     		eorne	r3, r3, r6
1937:../drivers/fsl_enet.c ****         {
 1915              		.loc 1 1937 0
 1916 0026 013D     		subs	r5, r5, #1
 1917              	.LVL219:
1942:../drivers/fsl_enet.c ****                 crc ^= 0xEDB88320U;
 1918              		.loc 1 1942 0
 1919 0028 D2B2     		uxtb	r2, r2
 1920              	.LVL220:
1937:../drivers/fsl_enet.c ****         {
 1921              		.loc 1 1937 0
 1922 002a F2D1     		bne	.L202
 1923              	.LVL221:
 1924              	.LBE134:
1934:../drivers/fsl_enet.c ****     {
 1925              		.loc 1 1934 0 discriminator 2
 1926 002c 8C42     		cmp	r4, r1
 1927 002e EDD1     		bne	.L203
1954:../drivers/fsl_enet.c ****     {
 1928              		.loc 1 1954 0
 1929 0030 002B     		cmp	r3, #0
 1930 0032 4FF00102 		mov	r2, #1
 1931              	.LVL222:
 1932 0036 4FEA9363 		lsr	r3, r3, #26
 1933              	.LVL223:
 1934 003a 07DB     		blt	.L204
1956:../drivers/fsl_enet.c ****     }
 1935              		.loc 1 1956 0
 1936 003c D0F82411 		ldr	r1, [r0, #292]
 1937              	.LVL224:
 1938 0040 02FA03F3 		lsl	r3, r2, r3
 1939 0044 0B43     		orrs	r3, r3, r1
 1940 0046 C0F82431 		str	r3, [r0, #292]
 1941 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 1942              	.LVL225:
 1943              	.L204:
1960:../drivers/fsl_enet.c ****     }
 1944              		.loc 1 1960 0
 1945 004c D0F82011 		ldr	r1, [r0, #288]
 1946 0050 03F01F03 		and	r3, r3, #31
 1947 0054 02FA03F3 		lsl	r3, r2, r3
 1948 0058 0B43     		orrs	r3, r3, r1
 1949 005a C0F82031 		str	r3, [r0, #288]
 1950 005e F0BD     		pop	{r4, r5, r6, r7, pc}
 1951              	.LVL226:
 1952              	.L209:
 1953              		.align	2
 1954              	.L208:
 1955 0060 2083B8ED 		.word	-306674912
 1956              		.cfi_endproc
 1957              	.LFE178:
 1959              		.section	.text.ENET_LeaveMulticastGroup,"ax",%progbits
 1960              		.align	1
 1961              		.global	ENET_LeaveMulticastGroup
 1962              		.syntax unified
 1963              		.thumb
 1964              		.thumb_func
 1965              		.fpu fpv4-sp-d16
 1967              	ENET_LeaveMulticastGroup:
 1968              	.LFB179:
1965:../drivers/fsl_enet.c ****     assert(address);
 1969              		.loc 1 1965 0
 1970              		.cfi_startproc
 1971              		@ args = 0, pretend = 0, frame = 0
 1972              		@ frame_needed = 0, uses_anonymous_args = 0
 1973              	.LVL227:
 1974 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1975              		.cfi_def_cfa_offset 20
 1976              		.cfi_offset 4, -20
 1977              		.cfi_offset 5, -16
 1978              		.cfi_offset 6, -12
 1979              		.cfi_offset 7, -8
 1980              		.cfi_offset 14, -4
 1981              	.LBB135:
1982:../drivers/fsl_enet.c ****             }
 1982              		.loc 1 1982 0
 1983 0002 184E     		ldr	r6, .L219
 1984 0004 4C1E     		subs	r4, r1, #1
 1985              	.LBE135:
1968:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
 1986              		.loc 1 1968 0
 1987 0006 4FF0FF33 		mov	r3, #-1
 1988 000a 0531     		adds	r1, r1, #5
 1989              	.LVL228:
 1990              	.L214:
 1991              	.LBB136:
1975:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
 1992              		.loc 1 1975 0
 1993 000c 14F8012F 		ldrb	r2, [r4, #1]!	@ zero_extendqisi2
 1994              	.LVL229:
 1995 0010 0825     		movs	r5, #8
 1996              	.LVL230:
 1997              	.L213:
1978:../drivers/fsl_enet.c ****             {
 1998              		.loc 1 1978 0
 1999 0012 82EA0307 		eor	r7, r2, r3
 2000 0016 17F0010F 		tst	r7, #1
 2001 001a 4FEA5303 		lsr	r3, r3, #1
 2002              	.LVL231:
 2003 001e 4FEA5202 		lsr	r2, r2, #1
 2004              	.LVL232:
1982:../drivers/fsl_enet.c ****             }
 2005              		.loc 1 1982 0
 2006 0022 18BF     		it	ne
 2007 0024 7340     		eorne	r3, r3, r6
1976:../drivers/fsl_enet.c ****         {
 2008              		.loc 1 1976 0
 2009 0026 013D     		subs	r5, r5, #1
 2010              	.LVL233:
1981:../drivers/fsl_enet.c ****                 crc ^= 0xEDB88320U;
 2011              		.loc 1 1981 0
 2012 0028 D2B2     		uxtb	r2, r2
 2013              	.LVL234:
1976:../drivers/fsl_enet.c ****         {
 2014              		.loc 1 1976 0
 2015 002a F2D1     		bne	.L213
 2016              	.LVL235:
 2017              	.LBE136:
1973:../drivers/fsl_enet.c ****     {
 2018              		.loc 1 1973 0 discriminator 2
 2019 002c 8C42     		cmp	r4, r1
 2020 002e EDD1     		bne	.L214
1993:../drivers/fsl_enet.c ****     {
 2021              		.loc 1 1993 0
 2022 0030 002B     		cmp	r3, #0
 2023 0032 4FF00102 		mov	r2, #1
 2024              	.LVL236:
 2025 0036 4FEA9363 		lsr	r3, r3, #26
 2026              	.LVL237:
 2027 003a 08DB     		blt	.L215
1995:../drivers/fsl_enet.c ****     }
 2028              		.loc 1 1995 0
 2029 003c D0F82411 		ldr	r1, [r0, #292]
 2030              	.LVL238:
 2031 0040 02FA03F3 		lsl	r3, r2, r3
 2032 0044 21EA0303 		bic	r3, r1, r3
 2033 0048 C0F82431 		str	r3, [r0, #292]
 2034 004c F0BD     		pop	{r4, r5, r6, r7, pc}
 2035              	.LVL239:
 2036              	.L215:
1999:../drivers/fsl_enet.c ****     }
 2037              		.loc 1 1999 0
 2038 004e D0F82011 		ldr	r1, [r0, #288]
 2039 0052 03F01F03 		and	r3, r3, #31
 2040 0056 02FA03F3 		lsl	r3, r2, r3
 2041 005a 21EA0303 		bic	r3, r1, r3
 2042 005e C0F82031 		str	r3, [r0, #288]
 2043 0062 F0BD     		pop	{r4, r5, r6, r7, pc}
 2044              	.LVL240:
 2045              	.L220:
 2046              		.align	2
 2047              	.L219:
 2048 0064 2083B8ED 		.word	-306674912
 2049              		.cfi_endproc
 2050              	.LFE179:
 2052              		.section	.text.ENET_CommonFrame0IRQHandler,"ax",%progbits
 2053              		.align	1
 2054              		.global	ENET_CommonFrame0IRQHandler
 2055              		.syntax unified
 2056              		.thumb
 2057              		.thumb_func
 2058              		.fpu fpv4-sp-d16
 2060              	ENET_CommonFrame0IRQHandler:
 2061              	.LFB183:
2731:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2732:../drivers/fsl_enet.c ****         }
2733:../drivers/fsl_enet.c ****     }
2734:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2735:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2736:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2737:../drivers/fsl_enet.c ****     __DSB();
2738:../drivers/fsl_enet.c **** #endif
2739:../drivers/fsl_enet.c **** }
2740:../drivers/fsl_enet.c **** 
2741:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
2742:../drivers/fsl_enet.c **** void ENET_Ptp1588TimerIRQHandler(ENET_Type *base, enet_handle_t *handle)
2743:../drivers/fsl_enet.c **** {
2744:../drivers/fsl_enet.c ****     assert(handle);
2745:../drivers/fsl_enet.c **** 
2746:../drivers/fsl_enet.c ****     /* Check if the PTP time stamp interrupt happen. */
2747:../drivers/fsl_enet.c ****     if (kENET_TsTimerInterrupt & base->EIR)
2748:../drivers/fsl_enet.c ****     {
2749:../drivers/fsl_enet.c ****         /* Clear the time stamp interrupt. */
2750:../drivers/fsl_enet.c ****         base->EIR = kENET_TsTimerInterrupt;
2751:../drivers/fsl_enet.c **** 
2752:../drivers/fsl_enet.c ****         /* Increase timer second counter. */
2753:../drivers/fsl_enet.c ****         handle->msTimerSecond++;
2754:../drivers/fsl_enet.c **** 
2755:../drivers/fsl_enet.c ****         /* Callback function. */
2756:../drivers/fsl_enet.c ****         if (handle->callback)
2757:../drivers/fsl_enet.c ****         {
2758:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2759:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_TimeStampEvent, handle->userData);
2760:../drivers/fsl_enet.c **** #else
2761:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_TimeStampEvent, handle->userData);
2762:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2763:../drivers/fsl_enet.c ****         }
2764:../drivers/fsl_enet.c ****     }
2765:../drivers/fsl_enet.c ****     else
2766:../drivers/fsl_enet.c ****     {
2767:../drivers/fsl_enet.c ****         /* Clear the time stamp interrupt. */
2768:../drivers/fsl_enet.c ****         base->EIR = kENET_TsAvailInterrupt;
2769:../drivers/fsl_enet.c ****         /* Callback function. */
2770:../drivers/fsl_enet.c ****         if (handle->callback)
2771:../drivers/fsl_enet.c ****         {
2772:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2773:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_TimeStampAvailEvent, handle->userData);
2774:../drivers/fsl_enet.c **** #else
2775:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_TimeStampAvailEvent, handle->userData);
2776:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2777:../drivers/fsl_enet.c ****         }
2778:../drivers/fsl_enet.c ****     }
2779:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2780:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2781:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2782:../drivers/fsl_enet.c ****     __DSB();
2783:../drivers/fsl_enet.c **** #endif
2784:../drivers/fsl_enet.c **** }
2785:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
2786:../drivers/fsl_enet.c **** 
2787:../drivers/fsl_enet.c **** void ENET_CommonFrame0IRQHandler(ENET_Type *base)
2788:../drivers/fsl_enet.c **** {
 2062              		.loc 1 2788 0
 2063              		.cfi_startproc
 2064              		@ args = 0, pretend = 0, frame = 0
 2065              		@ frame_needed = 0, uses_anonymous_args = 0
 2066              	.LVL241:
 2067 0000 70B5     		push	{r4, r5, r6, lr}
 2068              		.cfi_def_cfa_offset 16
 2069              		.cfi_offset 4, -16
 2070              		.cfi_offset 5, -12
 2071              		.cfi_offset 6, -8
 2072              		.cfi_offset 14, -4
2789:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
 2073              		.loc 1 2789 0
 2074 0002 4668     		ldr	r6, [r0, #4]
 2075              	.LVL242:
2788:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
 2076              		.loc 1 2788 0
 2077 0004 0446     		mov	r4, r0
2790:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 2078              		.loc 1 2790 0
 2079 0006 FFF7FEFF 		bl	ENET_GetInstance
 2080              	.LVL243:
2791:../drivers/fsl_enet.c **** 
2792:../drivers/fsl_enet.c ****     if (event & (kENET_TxBufferInterrupt | kENET_TxFrameInterrupt))
 2081              		.loc 1 2792 0
 2082 000a 16F0406F 		tst	r6, #201326592
2790:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 2083              		.loc 1 2790 0
 2084 000e 0546     		mov	r5, r0
 2085              	.LVL244:
 2086              		.loc 1 2792 0
 2087 0010 06D0     		beq	.L222
2793:../drivers/fsl_enet.c ****     {
2794:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2795:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance], 0);
2796:../drivers/fsl_enet.c **** #else
2797:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance]);
 2088              		.loc 1 2797 0
 2089 0012 134B     		ldr	r3, .L238
 2090 0014 134A     		ldr	r2, .L238+4
 2091 0016 1B68     		ldr	r3, [r3]
 2092 0018 52F82010 		ldr	r1, [r2, r0, lsl #2]
 2093 001c 2046     		mov	r0, r4
 2094              	.LVL245:
 2095 001e 9847     		blx	r3
 2096              	.LVL246:
 2097              	.L222:
2798:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2799:../drivers/fsl_enet.c ****     }
2800:../drivers/fsl_enet.c **** 
2801:../drivers/fsl_enet.c ****     if (event & (kENET_RxBufferInterrupt | kENET_RxFrameInterrupt))
 2098              		.loc 1 2801 0
 2099 0020 16F0407F 		tst	r6, #50331648
 2100 0024 06D0     		beq	.L223
2802:../drivers/fsl_enet.c ****     {
2803:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2804:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance], 0);
2805:../drivers/fsl_enet.c **** #else
2806:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance]);
 2101              		.loc 1 2806 0
 2102 0026 104B     		ldr	r3, .L238+8
 2103 0028 0E4A     		ldr	r2, .L238+4
 2104 002a 1B68     		ldr	r3, [r3]
 2105 002c 52F82510 		ldr	r1, [r2, r5, lsl #2]
 2106 0030 2046     		mov	r0, r4
 2107 0032 9847     		blx	r3
 2108              	.LVL247:
 2109              	.L223:
2807:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2808:../drivers/fsl_enet.c ****     }
2809:../drivers/fsl_enet.c **** 
2810:../drivers/fsl_enet.c ****     if (event & ENET_TS_INTERRUPT)
 2110              		.loc 1 2810 0
 2111 0034 16F4C03F 		tst	r6, #98304
 2112 0038 05D0     		beq	.L224
2811:../drivers/fsl_enet.c ****     {
2812:../drivers/fsl_enet.c ****         s_enetTsIsr(base, s_ENETHandle[instance]);
 2113              		.loc 1 2812 0
 2114 003a 0A4B     		ldr	r3, .L238+4
 2115 003c 2046     		mov	r0, r4
 2116 003e 53F82510 		ldr	r1, [r3, r5, lsl #2]
 2117 0042 0023     		movs	r3, #0
 2118 0044 9847     		blx	r3
 2119              	.LVL248:
 2120              	.L224:
2813:../drivers/fsl_enet.c ****     }
2814:../drivers/fsl_enet.c ****     if (event & ENET_ERR_INTERRUPT)
 2121              		.loc 1 2814 0
 2122 0046 094B     		ldr	r3, .L238+12
 2123 0048 1E42     		tst	r6, r3
 2124 004a 06D0     		beq	.L225
2815:../drivers/fsl_enet.c ****     {
2816:../drivers/fsl_enet.c ****         s_enetErrIsr(base, s_ENETHandle[instance]);
 2125              		.loc 1 2816 0
 2126 004c 084B     		ldr	r3, .L238+16
 2127 004e 054A     		ldr	r2, .L238+4
 2128 0050 1B68     		ldr	r3, [r3]
 2129 0052 52F82510 		ldr	r1, [r2, r5, lsl #2]
 2130 0056 2046     		mov	r0, r4
 2131 0058 9847     		blx	r3
 2132              	.LVL249:
 2133              	.L225:
 2134              	.LBB137:
 2135              	.LBB138:
 2136              		.loc 3 833 0
 2137              		.syntax unified
 2138              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2139 005a BFF34F8F 		dsb 0xF
 2140              	@ 0 "" 2
 2141              		.thumb
 2142              		.syntax unified
 2143 005e 70BD     		pop	{r4, r5, r6, pc}
 2144              	.LVL250:
 2145              	.L239:
 2146              		.align	2
 2147              	.L238:
 2148 0060 00000000 		.word	.LANCHOR1
 2149 0064 00000000 		.word	.LANCHOR0
 2150 0068 00000000 		.word	.LANCHOR2
 2151 006c 00007C60 		.word	1618739200
 2152 0070 00000000 		.word	.LANCHOR3
 2153              	.LBE138:
 2154              	.LBE137:
 2155              		.cfi_endproc
 2156              	.LFE183:
 2158              		.section	.text.ENET_Transmit_IRQHandler,"ax",%progbits
 2159              		.align	1
 2160              		.global	ENET_Transmit_IRQHandler
 2161              		.syntax unified
 2162              		.thumb
 2163              		.thumb_func
 2164              		.fpu fpv4-sp-d16
 2166              	ENET_Transmit_IRQHandler:
 2167              	.LFB184:
2817:../drivers/fsl_enet.c ****     }
2818:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2819:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2820:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2821:../drivers/fsl_enet.c ****     __DSB();
2822:../drivers/fsl_enet.c **** #endif
2823:../drivers/fsl_enet.c **** }
2824:../drivers/fsl_enet.c **** 
2825:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2826:../drivers/fsl_enet.c **** void ENET_CommonFrame1IRQHandler(ENET_Type *base)
2827:../drivers/fsl_enet.c **** {
2828:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
2829:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
2830:../drivers/fsl_enet.c **** 
2831:../drivers/fsl_enet.c ****     if (event & (kENET_TxBuffer1Interrupt | kENET_TxFrame1Interrupt))
2832:../drivers/fsl_enet.c ****     {
2833:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance], 1);
2834:../drivers/fsl_enet.c ****     }
2835:../drivers/fsl_enet.c **** 
2836:../drivers/fsl_enet.c ****     if (event & (kENET_RxBuffer1Interrupt | kENET_RxFrame1Interrupt))
2837:../drivers/fsl_enet.c ****     {
2838:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance], 1);
2839:../drivers/fsl_enet.c ****     }
2840:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2841:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2842:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2843:../drivers/fsl_enet.c ****     __DSB();
2844:../drivers/fsl_enet.c **** #endif
2845:../drivers/fsl_enet.c **** }
2846:../drivers/fsl_enet.c **** 
2847:../drivers/fsl_enet.c **** void ENET_CommonFrame2IRQHandler(ENET_Type *base)
2848:../drivers/fsl_enet.c **** {
2849:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
2850:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
2851:../drivers/fsl_enet.c **** 
2852:../drivers/fsl_enet.c ****     if (event & (kENET_TxBuffer2Interrupt | kENET_TxFrame2Interrupt))
2853:../drivers/fsl_enet.c ****     {
2854:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance], 2);
2855:../drivers/fsl_enet.c ****     }
2856:../drivers/fsl_enet.c **** 
2857:../drivers/fsl_enet.c ****     if (event & (kENET_RxBuffer2Interrupt | kENET_RxFrame2Interrupt))
2858:../drivers/fsl_enet.c ****     {
2859:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance], 2);
2860:../drivers/fsl_enet.c ****     }
2861:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2862:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2863:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2864:../drivers/fsl_enet.c ****     __DSB();
2865:../drivers/fsl_enet.c **** #endif
2866:../drivers/fsl_enet.c **** }
2867:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2868:../drivers/fsl_enet.c **** 
2869:../drivers/fsl_enet.c **** #if defined(ENET)
2870:../drivers/fsl_enet.c **** void ENET_Transmit_IRQHandler(void)
2871:../drivers/fsl_enet.c **** {
 2168              		.loc 1 2871 0
 2169              		.cfi_startproc
 2170              		@ args = 0, pretend = 0, frame = 0
 2171              		@ frame_needed = 0, uses_anonymous_args = 0
 2172 0000 08B5     		push	{r3, lr}
 2173              		.cfi_def_cfa_offset 8
 2174              		.cfi_offset 3, -8
 2175              		.cfi_offset 14, -4
2872:../drivers/fsl_enet.c ****     s_enetTxIsr(ENET, s_ENETHandle[0]);
 2176              		.loc 1 2872 0
 2177 0002 044A     		ldr	r2, .L241
 2178 0004 044B     		ldr	r3, .L241+4
 2179 0006 1168     		ldr	r1, [r2]
 2180 0008 1B68     		ldr	r3, [r3]
 2181 000a 0448     		ldr	r0, .L241+8
 2182 000c 9847     		blx	r3
 2183              	.LVL251:
 2184              	.LBB139:
 2185              	.LBB140:
 2186              		.loc 3 833 0
 2187              		.syntax unified
 2188              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2189 000e BFF34F8F 		dsb 0xF
 2190              	@ 0 "" 2
 2191              		.thumb
 2192              		.syntax unified
 2193 0012 08BD     		pop	{r3, pc}
 2194              	.L242:
 2195              		.align	2
 2196              	.L241:
 2197 0014 00000000 		.word	.LANCHOR0
 2198 0018 00000000 		.word	.LANCHOR1
 2199 001c 00000C40 		.word	1074528256
 2200              	.LBE140:
 2201              	.LBE139:
 2202              		.cfi_endproc
 2203              	.LFE184:
 2205              		.section	.text.ENET_Receive_IRQHandler,"ax",%progbits
 2206              		.align	1
 2207              		.global	ENET_Receive_IRQHandler
 2208              		.syntax unified
 2209              		.thumb
 2210              		.thumb_func
 2211              		.fpu fpv4-sp-d16
 2213              	ENET_Receive_IRQHandler:
 2214              	.LFB185:
2873:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2874:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2875:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2876:../drivers/fsl_enet.c ****     __DSB();
2877:../drivers/fsl_enet.c **** #endif
2878:../drivers/fsl_enet.c **** }
2879:../drivers/fsl_enet.c **** 
2880:../drivers/fsl_enet.c **** void ENET_Receive_IRQHandler(void)
2881:../drivers/fsl_enet.c **** {
 2215              		.loc 1 2881 0
 2216              		.cfi_startproc
 2217              		@ args = 0, pretend = 0, frame = 0
 2218              		@ frame_needed = 0, uses_anonymous_args = 0
 2219 0000 08B5     		push	{r3, lr}
 2220              		.cfi_def_cfa_offset 8
 2221              		.cfi_offset 3, -8
 2222              		.cfi_offset 14, -4
2882:../drivers/fsl_enet.c ****     s_enetRxIsr(ENET, s_ENETHandle[0]);
 2223              		.loc 1 2882 0
 2224 0002 044A     		ldr	r2, .L244
 2225 0004 044B     		ldr	r3, .L244+4
 2226 0006 1168     		ldr	r1, [r2]
 2227 0008 1B68     		ldr	r3, [r3]
 2228 000a 0448     		ldr	r0, .L244+8
 2229 000c 9847     		blx	r3
 2230              	.LVL252:
 2231              	.LBB141:
 2232              	.LBB142:
 2233              		.loc 3 833 0
 2234              		.syntax unified
 2235              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2236 000e BFF34F8F 		dsb 0xF
 2237              	@ 0 "" 2
 2238              		.thumb
 2239              		.syntax unified
 2240 0012 08BD     		pop	{r3, pc}
 2241              	.L245:
 2242              		.align	2
 2243              	.L244:
 2244 0014 00000000 		.word	.LANCHOR0
 2245 0018 00000000 		.word	.LANCHOR2
 2246 001c 00000C40 		.word	1074528256
 2247              	.LBE142:
 2248              	.LBE141:
 2249              		.cfi_endproc
 2250              	.LFE185:
 2252              		.section	.text.ENET_Error_IRQHandler,"ax",%progbits
 2253              		.align	1
 2254              		.global	ENET_Error_IRQHandler
 2255              		.syntax unified
 2256              		.thumb
 2257              		.thumb_func
 2258              		.fpu fpv4-sp-d16
 2260              	ENET_Error_IRQHandler:
 2261              	.LFB186:
2883:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2884:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2885:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2886:../drivers/fsl_enet.c ****     __DSB();
2887:../drivers/fsl_enet.c **** #endif
2888:../drivers/fsl_enet.c **** }
2889:../drivers/fsl_enet.c **** 
2890:../drivers/fsl_enet.c **** void ENET_Error_IRQHandler(void)
2891:../drivers/fsl_enet.c **** {
 2262              		.loc 1 2891 0
 2263              		.cfi_startproc
 2264              		@ args = 0, pretend = 0, frame = 0
 2265              		@ frame_needed = 0, uses_anonymous_args = 0
 2266 0000 08B5     		push	{r3, lr}
 2267              		.cfi_def_cfa_offset 8
 2268              		.cfi_offset 3, -8
 2269              		.cfi_offset 14, -4
2892:../drivers/fsl_enet.c ****     s_enetErrIsr(ENET, s_ENETHandle[0]);
 2270              		.loc 1 2892 0
 2271 0002 044A     		ldr	r2, .L247
 2272 0004 044B     		ldr	r3, .L247+4
 2273 0006 1168     		ldr	r1, [r2]
 2274 0008 1B68     		ldr	r3, [r3]
 2275 000a 0448     		ldr	r0, .L247+8
 2276 000c 9847     		blx	r3
 2277              	.LVL253:
 2278              	.LBB143:
 2279              	.LBB144:
 2280              		.loc 3 833 0
 2281              		.syntax unified
 2282              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2283 000e BFF34F8F 		dsb 0xF
 2284              	@ 0 "" 2
 2285              		.thumb
 2286              		.syntax unified
 2287 0012 08BD     		pop	{r3, pc}
 2288              	.L248:
 2289              		.align	2
 2290              	.L247:
 2291 0014 00000000 		.word	.LANCHOR0
 2292 0018 00000000 		.word	.LANCHOR3
 2293 001c 00000C40 		.word	1074528256
 2294              	.LBE144:
 2295              	.LBE143:
 2296              		.cfi_endproc
 2297              	.LFE186:
 2299              		.section	.text.ENET_1588_Timer_IRQHandler,"ax",%progbits
 2300              		.align	1
 2301              		.global	ENET_1588_Timer_IRQHandler
 2302              		.syntax unified
 2303              		.thumb
 2304              		.thumb_func
 2305              		.fpu fpv4-sp-d16
 2307              	ENET_1588_Timer_IRQHandler:
 2308              	.LFB187:
2893:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2894:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2895:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2896:../drivers/fsl_enet.c ****     __DSB();
2897:../drivers/fsl_enet.c **** #endif
2898:../drivers/fsl_enet.c **** }
2899:../drivers/fsl_enet.c **** 
2900:../drivers/fsl_enet.c **** void ENET_1588_Timer_IRQHandler(void)
2901:../drivers/fsl_enet.c **** {
 2309              		.loc 1 2901 0
 2310              		.cfi_startproc
 2311              		@ args = 0, pretend = 0, frame = 0
 2312              		@ frame_needed = 0, uses_anonymous_args = 0
 2313 0000 08B5     		push	{r3, lr}
 2314              		.cfi_def_cfa_offset 8
 2315              		.cfi_offset 3, -8
 2316              		.cfi_offset 14, -4
2902:../drivers/fsl_enet.c ****     s_enetTsIsr(ENET, s_ENETHandle[0]);
 2317              		.loc 1 2902 0
 2318 0002 044B     		ldr	r3, .L250
 2319 0004 0448     		ldr	r0, .L250+4
 2320 0006 1968     		ldr	r1, [r3]
 2321 0008 0023     		movs	r3, #0
 2322 000a 9847     		blx	r3
 2323              	.LVL254:
 2324              	.LBB145:
 2325              	.LBB146:
 2326              		.loc 3 833 0
 2327              		.syntax unified
 2328              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2329 000c BFF34F8F 		dsb 0xF
 2330              	@ 0 "" 2
 2331              		.thumb
 2332              		.syntax unified
 2333 0010 08BD     		pop	{r3, pc}
 2334              	.L251:
 2335 0012 00BF     		.align	2
 2336              	.L250:
 2337 0014 00000000 		.word	.LANCHOR0
 2338 0018 00000C40 		.word	1074528256
 2339              	.LBE146:
 2340              	.LBE145:
 2341              		.cfi_endproc
 2342              	.LFE187:
 2344              		.section	.text.ENET_DriverIRQHandler,"ax",%progbits
 2345              		.align	1
 2346              		.global	ENET_DriverIRQHandler
 2347              		.syntax unified
 2348              		.thumb
 2349              		.thumb_func
 2350              		.fpu fpv4-sp-d16
 2352              	ENET_DriverIRQHandler:
 2353              	.LFB188:
2903:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2904:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2905:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2906:../drivers/fsl_enet.c ****     __DSB();
2907:../drivers/fsl_enet.c **** #endif
2908:../drivers/fsl_enet.c **** }
2909:../drivers/fsl_enet.c **** 
2910:../drivers/fsl_enet.c **** void ENET_DriverIRQHandler(void)
2911:../drivers/fsl_enet.c **** {
 2354              		.loc 1 2911 0
 2355              		.cfi_startproc
 2356              		@ args = 0, pretend = 0, frame = 0
 2357              		@ frame_needed = 0, uses_anonymous_args = 0
 2358 0000 08B5     		push	{r3, lr}
 2359              		.cfi_def_cfa_offset 8
 2360              		.cfi_offset 3, -8
 2361              		.cfi_offset 14, -4
2912:../drivers/fsl_enet.c ****     ENET_CommonFrame0IRQHandler(ENET);
 2362              		.loc 1 2912 0
 2363 0002 0448     		ldr	r0, .L253
 2364 0004 FFF7FEFF 		bl	ENET_CommonFrame0IRQHandler
 2365              	.LVL255:
 2366              	.LBB147:
 2367              	.LBB148:
 2368              		.loc 3 833 0
 2369              		.syntax unified
 2370              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2371 0008 BFF34F8F 		dsb 0xF
 2372              	@ 0 "" 2
 2373              		.thumb
 2374              		.syntax unified
 2375              	.LBE148:
 2376              	.LBE147:
 2377              	.LBB149:
 2378              	.LBB150:
 2379              		.syntax unified
 2380              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2381 000c BFF34F8F 		dsb 0xF
 2382              	@ 0 "" 2
 2383              		.thumb
 2384              		.syntax unified
 2385 0010 08BD     		pop	{r3, pc}
 2386              	.L254:
 2387 0012 00BF     		.align	2
 2388              	.L253:
 2389 0014 00000C40 		.word	1074528256
 2390              	.LBE150:
 2391              	.LBE149:
 2392              		.cfi_endproc
 2393              	.LFE188:
 2395              		.global	s_enetClock
 2396              		.section	.bss.s_ENETHandle,"aw",%nobits
 2397              		.align	2
 2398              		.set	.LANCHOR0,. + 0
 2401              	s_ENETHandle:
 2402 0000 00000000 		.space	4
 2403              		.section	.bss.s_enetErrIsr,"aw",%nobits
 2404              		.align	2
 2405              		.set	.LANCHOR3,. + 0
 2408              	s_enetErrIsr:
 2409 0000 00000000 		.space	4
 2410              		.section	.bss.s_enetRxIsr,"aw",%nobits
 2411              		.align	2
 2412              		.set	.LANCHOR2,. + 0
 2415              	s_enetRxIsr:
 2416 0000 00000000 		.space	4
 2417              		.section	.bss.s_enetTxIsr,"aw",%nobits
 2418              		.align	2
 2419              		.set	.LANCHOR1,. + 0
 2422              	s_enetTxIsr:
 2423 0000 00000000 		.space	4
 2424              		.section	.rodata.s_enetClock,"a",%progbits
 2425              		.align	2
 2428              	s_enetClock:
 2429 0000 00002C10 		.word	271319040
 2430              		.text
 2431              	.Letext0:
 2432              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 2433              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 2434              		.file 8 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 2435              		.file 9 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 2436              		.file 10 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef
 2437              		.file 11 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 2438              		.file 12 "../CMSIS/MK64F12.h"
 2439              		.file 13 "../CMSIS/system_MK64F12.h"
 2440              		.file 14 "../drivers/fsl_common.h"
