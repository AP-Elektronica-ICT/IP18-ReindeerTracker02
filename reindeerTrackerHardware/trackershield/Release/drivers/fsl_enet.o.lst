   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_enet.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ENET_TransmitIRQHandler,"ax",%progbits
  18              		.align	1
  19              		.global	ENET_TransmitIRQHandler
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	ENET_TransmitIRQHandler:
  26              	.LFB180:
  27              		.file 1 "../drivers/fsl_enet.c"
   1:../drivers/fsl_enet.c **** /*
   2:../drivers/fsl_enet.c ****  * The Clear BSD License
   3:../drivers/fsl_enet.c ****  * Copyright (c) 2015 - 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_enet.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_enet.c ****  * All rights reserved.
   6:../drivers/fsl_enet.c ****  *
   7:../drivers/fsl_enet.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_enet.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_enet.c ****  * that the following conditions are met:
  10:../drivers/fsl_enet.c ****  *
  11:../drivers/fsl_enet.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_enet.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_enet.c ****  *
  14:../drivers/fsl_enet.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_enet.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_enet.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_enet.c ****  *
  18:../drivers/fsl_enet.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_enet.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_enet.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_enet.c ****  *
  22:../drivers/fsl_enet.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_enet.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_enet.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_enet.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_enet.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_enet.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_enet.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_enet.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_enet.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_enet.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_enet.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_enet.c ****  */
  34:../drivers/fsl_enet.c **** 
  35:../drivers/fsl_enet.c **** #include "fsl_enet.h"
  36:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
  37:../drivers/fsl_enet.c **** #include "fsl_cache.h"
  38:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
  39:../drivers/fsl_enet.c **** 
  40:../drivers/fsl_enet.c **** /*******************************************************************************
  41:../drivers/fsl_enet.c ****  * Definitions
  42:../drivers/fsl_enet.c ****  ******************************************************************************/
  43:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message IP version offset. */
  44:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPVERSION_OFFSET 0x0EU
  45:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP protocol offset. */
  46:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_PROTOCOL_OFFSET 0x17U
  47:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP port offset. */
  48:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_PORT_OFFSET 0x24U
  49:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP message type offset. */
  50:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_MSGTYPE_OFFSET 0x2AU
  51:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP version offset. */
  52:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_VERSION_OFFSET 0x2BU
  53:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP clock id offset. */
  54:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_CLKID_OFFSET 0x3EU
  55:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP sequence id offset. */
  56:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_SEQUENCEID_OFFSET 0x48U
  57:../drivers/fsl_enet.c **** /*! @brief IPv4 PTP message UDP control offset. */
  58:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV4_UDP_CTL_OFFSET 0x4AU
  59:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP protocol offset. */
  60:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_PROTOCOL_OFFSET 0x14U
  61:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP port offset. */
  62:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_PORT_OFFSET 0x38U
  63:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP message type offset. */
  64:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_MSGTYPE_OFFSET 0x3EU
  65:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP version offset. */
  66:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_VERSION_OFFSET 0x3FU
  67:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP clock id offset. */
  68:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_CLKID_OFFSET 0x52U
  69:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP sequence id offset. */
  70:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_SEQUENCEID_OFFSET 0x5CU
  71:../drivers/fsl_enet.c **** /*! @brief IPv6 PTP message UDP control offset. */
  72:../drivers/fsl_enet.c **** #define ENET_PTP1588_IPV6_UDP_CTL_OFFSET 0x5EU
  73:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet packet type offset. */
  74:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET 0x0CU
  75:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet message type offset. */
  76:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_MSGTYPE_OFFSET 0x0EU
  77:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet version type offset. */
  78:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_VERSION_OFFSET 0X0FU
  79:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet clock id offset. */
  80:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_CLOCKID_OFFSET 0x22
  81:../drivers/fsl_enet.c **** /*! @brief PTPv2 message Ethernet sequence id offset. */
  82:../drivers/fsl_enet.c **** #define ENET_PTP1588_ETHL2_SEQUENCEID_OFFSET 0x2c
  83:../drivers/fsl_enet.c **** /*! @brief Packet type Ethernet IEEE802.3 for PTPv2. */
  84:../drivers/fsl_enet.c **** #define ENET_ETHERNETL2 0x88F7U
  85:../drivers/fsl_enet.c **** /*! @brief Packet type IPv4. */
  86:../drivers/fsl_enet.c **** #define ENET_IPV4 0x0800U
  87:../drivers/fsl_enet.c **** /*! @brief Packet type IPv6. */
  88:../drivers/fsl_enet.c **** #define ENET_IPV6 0x86ddU
  89:../drivers/fsl_enet.c **** /*! @brief Packet type VLAN. */
  90:../drivers/fsl_enet.c **** #define ENET_8021QVLAN 0x8100U
  91:../drivers/fsl_enet.c **** /*! @brief UDP protocol type. */
  92:../drivers/fsl_enet.c **** #define ENET_UDPVERSION 0x0011U
  93:../drivers/fsl_enet.c **** /*! @brief Packet IP version IPv4. */
  94:../drivers/fsl_enet.c **** #define ENET_IPV4VERSION 0x0004U
  95:../drivers/fsl_enet.c **** /*! @brief Packet IP version IPv6. */
  96:../drivers/fsl_enet.c **** #define ENET_IPV6VERSION 0x0006U
  97:../drivers/fsl_enet.c **** /*! @brief Ethernet mac address length. */
  98:../drivers/fsl_enet.c **** #define ENET_FRAME_MACLEN 6U
  99:../drivers/fsl_enet.c **** /*! @brief Ethernet VLAN header length. */
 100:../drivers/fsl_enet.c **** #define ENET_FRAME_VLAN_TAGLEN 4U
 101:../drivers/fsl_enet.c **** /*! @brief MDC frequency. */
 102:../drivers/fsl_enet.c **** #define ENET_MDC_FREQUENCY 2500000U
 103:../drivers/fsl_enet.c **** /*! @brief NanoSecond in one second. */
 104:../drivers/fsl_enet.c **** #define ENET_NANOSECOND_ONE_SECOND 1000000000U
 105:../drivers/fsl_enet.c **** /*! @brief Define a common clock cycle delays used for time stamp capture. */
 106:../drivers/fsl_enet.c **** #define ENET_1588TIME_DELAY_COUNT 10U
 107:../drivers/fsl_enet.c **** 
 108:../drivers/fsl_enet.c **** /*! @brief Defines the macro for converting constants from host byte order to network byte order. *
 109:../drivers/fsl_enet.c **** #define ENET_HTONS(n) __REV16(n)
 110:../drivers/fsl_enet.c **** #define ENET_HTONL(n) __REV(n)
 111:../drivers/fsl_enet.c **** #define ENET_NTOHS(n) __REV16(n)
 112:../drivers/fsl_enet.c **** #define ENET_NTOHL(n) __REV(n)
 113:../drivers/fsl_enet.c **** 
 114:../drivers/fsl_enet.c **** /*! @brief Define the ENET ring/class bumber . */
 115:../drivers/fsl_enet.c **** enum _enet_ring_number
 116:../drivers/fsl_enet.c **** {
 117:../drivers/fsl_enet.c ****     kENET_Ring0 = 0U, /*!< ENET ring/class 0. */
 118:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 119:../drivers/fsl_enet.c ****     kENET_Ring1 = 1U, /*!< ENET ring/class 1. */
 120:../drivers/fsl_enet.c ****     kENET_Ring2 = 2U  /*!< ENET ring/class 2. */
 121:../drivers/fsl_enet.c **** #endif                /* FSL_FEATURE_ENET_QUEUE > 1 */
 122:../drivers/fsl_enet.c **** };
 123:../drivers/fsl_enet.c **** 
 124:../drivers/fsl_enet.c **** /*! @brief Define interrupt IRQ handler. */
 125:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 126:../drivers/fsl_enet.c **** typedef void (*enet_isr_ring_t)(ENET_Type *base, enet_handle_t *handle, uint32_t ringId);
 127:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 128:../drivers/fsl_enet.c **** typedef void (*enet_isr_t)(ENET_Type *base, enet_handle_t *handle);
 129:../drivers/fsl_enet.c **** 
 130:../drivers/fsl_enet.c **** /*******************************************************************************
 131:../drivers/fsl_enet.c **** * Prototypes
 132:../drivers/fsl_enet.c **** ******************************************************************************/
 133:../drivers/fsl_enet.c **** 
 134:../drivers/fsl_enet.c **** /*!
 135:../drivers/fsl_enet.c ****  * @brief Get the ENET instance from peripheral base address.
 136:../drivers/fsl_enet.c ****  *
 137:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 138:../drivers/fsl_enet.c ****  * @return ENET instance.
 139:../drivers/fsl_enet.c ****  */
 140:../drivers/fsl_enet.c **** uint32_t ENET_GetInstance(ENET_Type *base);
 141:../drivers/fsl_enet.c **** /*!
 142:../drivers/fsl_enet.c ****  * @brief Set ENET MAC controller with the configuration.
 143:../drivers/fsl_enet.c ****  *
 144:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 145:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 146:../drivers/fsl_enet.c ****  * @param config ENET Mac configuration.
 147:../drivers/fsl_enet.c ****  * @param bufferConfig ENET buffer configuration.
 148:../drivers/fsl_enet.c ****  * @param macAddr ENET six-byte mac address.
 149:../drivers/fsl_enet.c ****  * @param srcClock_Hz ENET module clock source, normally it's system clock.
 150:../drivers/fsl_enet.c ****  */
 151:../drivers/fsl_enet.c **** static void ENET_SetMacController(ENET_Type *base,
 152:../drivers/fsl_enet.c ****                                   enet_handle_t *handle,
 153:../drivers/fsl_enet.c ****                                   const enet_config_t *config,
 154:../drivers/fsl_enet.c ****                                   const enet_buffer_config_t *bufferConfig,
 155:../drivers/fsl_enet.c ****                                   uint8_t *macAddr,
 156:../drivers/fsl_enet.c ****                                   uint32_t srcClock_Hz);
 157:../drivers/fsl_enet.c **** /*!
 158:../drivers/fsl_enet.c ****  * @brief Set ENET handler.
 159:../drivers/fsl_enet.c ****  *
 160:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 161:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 162:../drivers/fsl_enet.c ****  * @param config ENET configuration stucture pointer.
 163:../drivers/fsl_enet.c ****  * @param bufferConfig ENET buffer configuration.
 164:../drivers/fsl_enet.c ****  */
 165:../drivers/fsl_enet.c **** static void ENET_SetHandler(ENET_Type *base,
 166:../drivers/fsl_enet.c ****                             enet_handle_t *handle,
 167:../drivers/fsl_enet.c ****                             const enet_config_t *config,
 168:../drivers/fsl_enet.c ****                             const enet_buffer_config_t *bufferConfig);
 169:../drivers/fsl_enet.c **** /*!
 170:../drivers/fsl_enet.c ****  * @brief Set ENET MAC transmit buffer descriptors.
 171:../drivers/fsl_enet.c ****  *
 172:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 173:../drivers/fsl_enet.c ****  * @param config The ENET configuration structure.
 174:../drivers/fsl_enet.c ****  * @param bufferConfig The ENET buffer configuration.
 175:../drivers/fsl_enet.c ****  */
 176:../drivers/fsl_enet.c **** static void ENET_SetTxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 177:../drivers/fsl_enet.c **** 
 178:../drivers/fsl_enet.c **** /*!
 179:../drivers/fsl_enet.c ****  * @brief Set ENET MAC receive buffer descriptors.
 180:../drivers/fsl_enet.c ****  *
 181:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 182:../drivers/fsl_enet.c ****  * @param config The ENET configuration structure.
 183:../drivers/fsl_enet.c ****  * @param bufferConfig The ENET buffer configuration.
 184:../drivers/fsl_enet.c ****  */
 185:../drivers/fsl_enet.c **** static void ENET_SetRxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 186:../drivers/fsl_enet.c **** 
 187:../drivers/fsl_enet.c **** /*!
 188:../drivers/fsl_enet.c ****  * @brief Updates the ENET read buffer descriptors.
 189:../drivers/fsl_enet.c ****  *
 190:../drivers/fsl_enet.c ****  * @param base ENET peripheral base address.
 191:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 192:../drivers/fsl_enet.c ****  * @param ringId The descriptor ring index, range from 0 ~ FSL_FEATURE_ENET_QUEUE - 1.
 193:../drivers/fsl_enet.c ****  *               0 ----- for single ring kinetis platform.
 194:../drivers/fsl_enet.c ****  *               0 ~ 2 for mulit-ring supported IMX8qm.
 195:../drivers/fsl_enet.c ****  */
 196:../drivers/fsl_enet.c **** static void ENET_UpdateReadBuffers(ENET_Type *base, enet_handle_t *handle, uint32_t ringId);
 197:../drivers/fsl_enet.c **** 
 198:../drivers/fsl_enet.c **** /*!
 199:../drivers/fsl_enet.c ****  * @brief Activates ENET send for multiple tx rings.
 200:../drivers/fsl_enet.c ****  *
 201:../drivers/fsl_enet.c ****  * @param base  ENET peripheral base address.
 202:../drivers/fsl_enet.c ****  * @param ringId The descriptor ring index, range from 0 ~ FSL_FEATURE_ENET_QUEUE - 1.
 203:../drivers/fsl_enet.c ****  *               0 ----- for single ring kinetis platform.
 204:../drivers/fsl_enet.c ****  *               0 ~ 2 for mulit-ring supported IMX8qm.
 205:../drivers/fsl_enet.c ****  *
 206:../drivers/fsl_enet.c ****  * @note This must be called after the MAC configuration and
 207:../drivers/fsl_enet.c ****  * state are ready. It must be called after the ENET_Init() and
 208:../drivers/fsl_enet.c ****  * this should be called when the ENET receive required.
 209:../drivers/fsl_enet.c ****  */
 210:../drivers/fsl_enet.c **** static void ENET_ActiveSend(ENET_Type *base, uint32_t ringId);
 211:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 212:../drivers/fsl_enet.c **** /*!
 213:../drivers/fsl_enet.c ****  * @brief Parses the ENET frame for time-stamp process of PTP 1588 frame.
 214:../drivers/fsl_enet.c ****  *
 215:../drivers/fsl_enet.c ****  * @param data  The ENET read data for frame parse.
 216:../drivers/fsl_enet.c ****  * @param ptpTsData The ENET PTP message and time-stamp data pointer.
 217:../drivers/fsl_enet.c ****  * @param isFastEnabled The fast parse flag.
 218:../drivers/fsl_enet.c ****  *        - true , Fast processing, only check if this is a PTP message.
 219:../drivers/fsl_enet.c ****  *        - false, Store the PTP message data after check the PTP message.
 220:../drivers/fsl_enet.c ****  */
 221:../drivers/fsl_enet.c **** static bool ENET_Ptp1588ParseFrame(const uint8_t *data, enet_ptp_time_data_t *ptpTsData, bool isFas
 222:../drivers/fsl_enet.c **** 
 223:../drivers/fsl_enet.c **** /*!
 224:../drivers/fsl_enet.c ****  * @brief Updates the new PTP 1588 time-stamp to the time-stamp buffer ring.
 225:../drivers/fsl_enet.c ****  *
 226:../drivers/fsl_enet.c ****  * @param ptpTsDataRing The PTP message and time-stamp data ring pointer.
 227:../drivers/fsl_enet.c ****  * @param ptpTimeData   The new PTP 1588 time-stamp data pointer.
 228:../drivers/fsl_enet.c ****  */
 229:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588UpdateTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
 230:../drivers/fsl_enet.c **** 
 231:../drivers/fsl_enet.c **** /*!
 232:../drivers/fsl_enet.c ****  * @brief Search up the right PTP 1588 time-stamp from the time-stamp buffer ring.
 233:../drivers/fsl_enet.c ****  *
 234:../drivers/fsl_enet.c ****  * @param ptpTsDataRing The PTP message and time-stamp data ring pointer.
 235:../drivers/fsl_enet.c ****  * @param ptpTimeData   The find out right PTP 1588 time-stamp data pointer with the specific PTP m
 236:../drivers/fsl_enet.c ****  */
 237:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588SearchTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
 238:../drivers/fsl_enet.c **** 
 239:../drivers/fsl_enet.c **** /*!
 240:../drivers/fsl_enet.c ****  * @brief Store the transmit time-stamp for event PTP frame in the time-stamp buffer ring.
 241:../drivers/fsl_enet.c ****  *
 242:../drivers/fsl_enet.c ****  * @param base   ENET peripheral base address.
 243:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 244:../drivers/fsl_enet.c ****  * @param ringId The descriptor ring index, range from 0 ~ FSL_FEATURE_ENET_QUEUE - 1.
 245:../drivers/fsl_enet.c ****  *               0 ----- for single ring kinetis platform.
 246:../drivers/fsl_enet.c ****  *               0 ~ 2 for mulit-ring supported IMX8qm.
 247:../drivers/fsl_enet.c ****  */
 248:../drivers/fsl_enet.c **** static status_t ENET_StoreTxFrameTime(ENET_Type *base, enet_handle_t *handle, uint32_t ringId);
 249:../drivers/fsl_enet.c **** 
 250:../drivers/fsl_enet.c **** /*!
 251:../drivers/fsl_enet.c ****  * @brief Store the receive time-stamp for event PTP frame in the time-stamp buffer ring.
 252:../drivers/fsl_enet.c ****  *
 253:../drivers/fsl_enet.c ****  * @param base   ENET peripheral base address.
 254:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 255:../drivers/fsl_enet.c ****  * @param ptpTimeData The PTP 1588 time-stamp data pointer.
 256:../drivers/fsl_enet.c ****  */
 257:../drivers/fsl_enet.c **** static status_t ENET_StoreRxFrameTime(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_data_t 
 258:../drivers/fsl_enet.c **** 
 259:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_AVB
 260:../drivers/fsl_enet.c **** /*!
 261:../drivers/fsl_enet.c ****  * @brief Gets the ring index for transmission.
 262:../drivers/fsl_enet.c ****  *
 263:../drivers/fsl_enet.c ****  * @param base  ENET peripheral base address.
 264:../drivers/fsl_enet.c ****  * @param data The ENET transmit data.
 265:../drivers/fsl_enet.c ****  * @param handle The ENET handle pointer.
 266:../drivers/fsl_enet.c ****  *
 267:../drivers/fsl_enet.c ****  * @note This must be called after the MAC configuration and
 268:../drivers/fsl_enet.c ****  * state are ready. It must be called after the ENET_Init() and
 269:../drivers/fsl_enet.c ****  * this should be called when the ENET receive required.
 270:../drivers/fsl_enet.c ****  */
 271:../drivers/fsl_enet.c **** static uint8_t ENET_GetTxRingId(ENET_Type *base, uint8_t *data, enet_handle_t *handle);
 272:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 273:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 274:../drivers/fsl_enet.c **** 
 275:../drivers/fsl_enet.c **** /*******************************************************************************
 276:../drivers/fsl_enet.c ****  * Variables
 277:../drivers/fsl_enet.c ****  ******************************************************************************/
 278:../drivers/fsl_enet.c **** 
 279:../drivers/fsl_enet.c **** /*! @brief Pointers to enet handles for each instance. */
 280:../drivers/fsl_enet.c **** static enet_handle_t *s_ENETHandle[FSL_FEATURE_SOC_ENET_COUNT] = {NULL};
 281:../drivers/fsl_enet.c **** 
 282:../drivers/fsl_enet.c **** /*! @brief Pointers to enet clocks for each instance. */
 283:../drivers/fsl_enet.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 284:../drivers/fsl_enet.c **** const clock_ip_name_t s_enetClock[] = ENET_CLOCKS;
 285:../drivers/fsl_enet.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 286:../drivers/fsl_enet.c **** 
 287:../drivers/fsl_enet.c **** /*! @brief Pointers to enet transmit IRQ number for each instance. */
 288:../drivers/fsl_enet.c **** static const IRQn_Type s_enetTxIrqId[] = ENET_Transmit_IRQS;
 289:../drivers/fsl_enet.c **** /*! @brief Pointers to enet receive IRQ number for each instance. */
 290:../drivers/fsl_enet.c **** static const IRQn_Type s_enetRxIrqId[] = ENET_Receive_IRQS;
 291:../drivers/fsl_enet.c **** #if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) && ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 292:../drivers/fsl_enet.c **** /*! @brief Pointers to enet timestamp IRQ number for each instance. */
 293:../drivers/fsl_enet.c **** static const IRQn_Type s_enetTsIrqId[] = ENET_1588_Timer_IRQS;
 294:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 295:../drivers/fsl_enet.c **** /*! @brief Pointers to enet error IRQ number for each instance. */
 296:../drivers/fsl_enet.c **** static const IRQn_Type s_enetErrIrqId[] = ENET_Error_IRQS;
 297:../drivers/fsl_enet.c **** 
 298:../drivers/fsl_enet.c **** /*! @brief Pointers to enet bases for each instance. */
 299:../drivers/fsl_enet.c **** static ENET_Type *const s_enetBases[] = ENET_BASE_PTRS;
 300:../drivers/fsl_enet.c **** 
 301:../drivers/fsl_enet.c **** /* ENET ISR for transactional APIs. */
 302:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 303:../drivers/fsl_enet.c **** static enet_isr_ring_t s_enetTxIsr;
 304:../drivers/fsl_enet.c **** static enet_isr_ring_t s_enetRxIsr;
 305:../drivers/fsl_enet.c **** #else
 306:../drivers/fsl_enet.c **** static enet_isr_t s_enetTxIsr;
 307:../drivers/fsl_enet.c **** static enet_isr_t s_enetRxIsr;
 308:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 309:../drivers/fsl_enet.c **** static enet_isr_t s_enetErrIsr;
 310:../drivers/fsl_enet.c **** static enet_isr_t s_enetTsIsr;
 311:../drivers/fsl_enet.c **** /*******************************************************************************
 312:../drivers/fsl_enet.c ****  * Code
 313:../drivers/fsl_enet.c ****  ******************************************************************************/
 314:../drivers/fsl_enet.c **** 
 315:../drivers/fsl_enet.c **** uint32_t ENET_GetInstance(ENET_Type *base)
 316:../drivers/fsl_enet.c **** {
 317:../drivers/fsl_enet.c ****     uint32_t instance;
 318:../drivers/fsl_enet.c **** 
 319:../drivers/fsl_enet.c ****     /* Find the instance index from base address mappings. */
 320:../drivers/fsl_enet.c ****     for (instance = 0; instance < ARRAY_SIZE(s_enetBases); instance++)
 321:../drivers/fsl_enet.c ****     {
 322:../drivers/fsl_enet.c ****         if (s_enetBases[instance] == base)
 323:../drivers/fsl_enet.c ****         {
 324:../drivers/fsl_enet.c ****             break;
 325:../drivers/fsl_enet.c ****         }
 326:../drivers/fsl_enet.c ****     }
 327:../drivers/fsl_enet.c **** 
 328:../drivers/fsl_enet.c ****     assert(instance < ARRAY_SIZE(s_enetBases));
 329:../drivers/fsl_enet.c **** 
 330:../drivers/fsl_enet.c ****     return instance;
 331:../drivers/fsl_enet.c **** }
 332:../drivers/fsl_enet.c **** 
 333:../drivers/fsl_enet.c **** void ENET_GetDefaultConfig(enet_config_t *config)
 334:../drivers/fsl_enet.c **** {
 335:../drivers/fsl_enet.c ****     /* Checks input parameter. */
 336:../drivers/fsl_enet.c ****     assert(config);
 337:../drivers/fsl_enet.c **** 
 338:../drivers/fsl_enet.c ****     /* Initializes the MAC configure structure to zero. */
 339:../drivers/fsl_enet.c ****     memset(config, 0, sizeof(enet_config_t));
 340:../drivers/fsl_enet.c **** 
 341:../drivers/fsl_enet.c ****     /* Sets MII mode, full duplex, 100Mbps for MAC and PHY data interface. */
 342:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB 
 343:../drivers/fsl_enet.c ****     config->miiMode = kENET_RgmiiMode;
 344:../drivers/fsl_enet.c **** #else
 345:../drivers/fsl_enet.c ****     config->miiMode = kENET_RmiiMode;
 346:../drivers/fsl_enet.c **** #endif
 347:../drivers/fsl_enet.c ****     config->miiSpeed = kENET_MiiSpeed100M; 
 348:../drivers/fsl_enet.c ****     config->miiDuplex = kENET_MiiFullDuplex;
 349:../drivers/fsl_enet.c **** 
 350:../drivers/fsl_enet.c ****     config->ringNum = 1;
 351:../drivers/fsl_enet.c **** 
 352:../drivers/fsl_enet.c ****     /* Sets the maximum receive frame length. */
 353:../drivers/fsl_enet.c ****     config->rxMaxFrameLen = ENET_FRAME_MAX_FRAMELEN;
 354:../drivers/fsl_enet.c **** }
 355:../drivers/fsl_enet.c **** 
 356:../drivers/fsl_enet.c **** void ENET_Init(ENET_Type *base,
 357:../drivers/fsl_enet.c ****                enet_handle_t *handle,
 358:../drivers/fsl_enet.c ****                const enet_config_t *config,
 359:../drivers/fsl_enet.c ****                const enet_buffer_config_t *bufferConfig,
 360:../drivers/fsl_enet.c ****                uint8_t *macAddr,
 361:../drivers/fsl_enet.c ****                uint32_t srcClock_Hz)
 362:../drivers/fsl_enet.c **** {
 363:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 364:../drivers/fsl_enet.c ****     assert(handle);
 365:../drivers/fsl_enet.c ****     assert(config);
 366:../drivers/fsl_enet.c ****     assert(bufferConfig);
 367:../drivers/fsl_enet.c ****     assert(macAddr);
 368:../drivers/fsl_enet.c ****     assert(config->ringNum <= FSL_FEATURE_ENET_QUEUE);
 369:../drivers/fsl_enet.c **** 
 370:../drivers/fsl_enet.c ****     uint8_t count;
 371:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 372:../drivers/fsl_enet.c **** 
 373:../drivers/fsl_enet.c ****     /* Check the input parameter. */
 374:../drivers/fsl_enet.c ****     for (count = 0; count < config->ringNum; count++)
 375:../drivers/fsl_enet.c ****     {
 376:../drivers/fsl_enet.c ****         assert(buffCfg);
 377:../drivers/fsl_enet.c ****         assert(buffCfg->rxBuffSizeAlign * buffCfg->rxBdNumber > config->rxMaxFrameLen);
 378:../drivers/fsl_enet.c ****         buffCfg++;
 379:../drivers/fsl_enet.c ****     }
 380:../drivers/fsl_enet.c **** 
 381:../drivers/fsl_enet.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 382:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 383:../drivers/fsl_enet.c **** 
 384:../drivers/fsl_enet.c ****     /* Ungate ENET clock. */
 385:../drivers/fsl_enet.c ****     CLOCK_EnableClock(s_enetClock[instance]);
 386:../drivers/fsl_enet.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 387:../drivers/fsl_enet.c ****     /* Reset ENET module. */
 388:../drivers/fsl_enet.c ****     ENET_Reset(base);
 389:../drivers/fsl_enet.c **** 
 390:../drivers/fsl_enet.c ****     /* Initializes the ENET transmit buffer descriptors. */
 391:../drivers/fsl_enet.c ****     ENET_SetTxBufferDescriptors(handle, config, bufferConfig);
 392:../drivers/fsl_enet.c **** 
 393:../drivers/fsl_enet.c ****     /* Initializes the ENET receive buffer descriptors. */
 394:../drivers/fsl_enet.c ****     ENET_SetRxBufferDescriptors(handle, config, bufferConfig);
 395:../drivers/fsl_enet.c **** 
 396:../drivers/fsl_enet.c ****     /* Initializes the ENET MAC controller with basic function. */
 397:../drivers/fsl_enet.c ****     ENET_SetMacController(base, handle, config, bufferConfig, macAddr, srcClock_Hz);
 398:../drivers/fsl_enet.c **** 
 399:../drivers/fsl_enet.c ****     /* Set all buffers or data in handler for data transmit/receive process. */
 400:../drivers/fsl_enet.c ****     ENET_SetHandler(base, handle, config, bufferConfig);
 401:../drivers/fsl_enet.c **** }
 402:../drivers/fsl_enet.c **** 
 403:../drivers/fsl_enet.c **** void ENET_Deinit(ENET_Type *base)
 404:../drivers/fsl_enet.c **** {
 405:../drivers/fsl_enet.c ****     /* Disable interrupt. */
 406:../drivers/fsl_enet.c ****     base->EIMR = 0;
 407:../drivers/fsl_enet.c **** 
 408:../drivers/fsl_enet.c ****     /* Disable ENET. */
 409:../drivers/fsl_enet.c ****     base->ECR &= ~ENET_ECR_ETHEREN_MASK;
 410:../drivers/fsl_enet.c **** 
 411:../drivers/fsl_enet.c **** 
 412:../drivers/fsl_enet.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 413:../drivers/fsl_enet.c ****     /* Disables the clock source. */
 414:../drivers/fsl_enet.c ****     CLOCK_DisableClock(s_enetClock[ENET_GetInstance(base)]);
 415:../drivers/fsl_enet.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 416:../drivers/fsl_enet.c **** }
 417:../drivers/fsl_enet.c **** 
 418:../drivers/fsl_enet.c **** void ENET_SetCallback(enet_handle_t *handle, enet_callback_t callback, void *userData)
 419:../drivers/fsl_enet.c **** {
 420:../drivers/fsl_enet.c ****     assert(handle);
 421:../drivers/fsl_enet.c **** 
 422:../drivers/fsl_enet.c ****     /* Set callback and userData. */
 423:../drivers/fsl_enet.c ****     handle->callback = callback;
 424:../drivers/fsl_enet.c ****     handle->userData = userData;
 425:../drivers/fsl_enet.c **** }
 426:../drivers/fsl_enet.c **** 
 427:../drivers/fsl_enet.c **** static void ENET_SetHandler(ENET_Type *base,
 428:../drivers/fsl_enet.c ****                             enet_handle_t *handle,
 429:../drivers/fsl_enet.c ****                             const enet_config_t *config,
 430:../drivers/fsl_enet.c ****                             const enet_buffer_config_t *bufferConfig)
 431:../drivers/fsl_enet.c **** {
 432:../drivers/fsl_enet.c ****     uint8_t count;
 433:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 434:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 435:../drivers/fsl_enet.c **** 
 436:../drivers/fsl_enet.c ****     /* Store transfer parameters in handle pointer. */
 437:../drivers/fsl_enet.c ****     memset(handle, 0, sizeof(enet_handle_t));
 438:../drivers/fsl_enet.c **** 
 439:../drivers/fsl_enet.c ****     handle->ringNum = (config->ringNum > FSL_FEATURE_ENET_QUEUE) ? FSL_FEATURE_ENET_QUEUE : config-
 440:../drivers/fsl_enet.c ****     for (count = 0; count < handle->ringNum; count++)
 441:../drivers/fsl_enet.c ****     {
 442:../drivers/fsl_enet.c ****         handle->rxBdBase[count] = buffCfg->rxBdStartAddrAlign;
 443:../drivers/fsl_enet.c ****         handle->rxBdCurrent[count] = buffCfg->rxBdStartAddrAlign;
 444:../drivers/fsl_enet.c ****         handle->rxBuffSizeAlign[count] = buffCfg->rxBuffSizeAlign;
 445:../drivers/fsl_enet.c ****         handle->txBdBase[count] = buffCfg->txBdStartAddrAlign;
 446:../drivers/fsl_enet.c ****         handle->txBdCurrent[count] = buffCfg->txBdStartAddrAlign;
 447:../drivers/fsl_enet.c ****         handle->txBuffSizeAlign[count] = buffCfg->txBuffSizeAlign;
 448:../drivers/fsl_enet.c ****         buffCfg++;
 449:../drivers/fsl_enet.c ****     }
 450:../drivers/fsl_enet.c **** 
 451:../drivers/fsl_enet.c ****     /* Save the handle pointer in the global variables. */
 452:../drivers/fsl_enet.c ****     s_ENETHandle[instance] = handle;
 453:../drivers/fsl_enet.c **** 
 454:../drivers/fsl_enet.c ****     /* Set the IRQ handler when the interrupt is enabled. */
 455:../drivers/fsl_enet.c ****     if (config->interrupt & ENET_TX_INTERRUPT)
 456:../drivers/fsl_enet.c ****     {
 457:../drivers/fsl_enet.c ****         s_enetTxIsr = ENET_TransmitIRQHandler;
 458:../drivers/fsl_enet.c ****         EnableIRQ(s_enetTxIrqId[instance]);
 459:../drivers/fsl_enet.c ****     }
 460:../drivers/fsl_enet.c ****     if (config->interrupt & ENET_RX_INTERRUPT)
 461:../drivers/fsl_enet.c ****     {
 462:../drivers/fsl_enet.c ****         s_enetRxIsr = ENET_ReceiveIRQHandler;
 463:../drivers/fsl_enet.c ****         EnableIRQ(s_enetRxIrqId[instance]);
 464:../drivers/fsl_enet.c ****     }
 465:../drivers/fsl_enet.c ****     if (config->interrupt & ENET_ERR_INTERRUPT)
 466:../drivers/fsl_enet.c ****     {
 467:../drivers/fsl_enet.c ****         s_enetErrIsr = ENET_ErrorIRQHandler;
 468:../drivers/fsl_enet.c ****         EnableIRQ(s_enetErrIrqId[instance]);
 469:../drivers/fsl_enet.c ****     }
 470:../drivers/fsl_enet.c **** }
 471:../drivers/fsl_enet.c **** 
 472:../drivers/fsl_enet.c **** static void ENET_SetMacController(ENET_Type *base,
 473:../drivers/fsl_enet.c ****                                   enet_handle_t *handle,
 474:../drivers/fsl_enet.c ****                                   const enet_config_t *config,
 475:../drivers/fsl_enet.c ****                                   const enet_buffer_config_t *bufferConfig,
 476:../drivers/fsl_enet.c ****                                   uint8_t *macAddr,
 477:../drivers/fsl_enet.c ****                                   uint32_t srcClock_Hz)
 478:../drivers/fsl_enet.c **** {
 479:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 480:../drivers/fsl_enet.c ****     /* Check the MII mode/speed/duplex setting. */
 481:../drivers/fsl_enet.c ****     if (config->miiSpeed == kENET_MiiSpeed1000M)
 482:../drivers/fsl_enet.c ****     {
 483:../drivers/fsl_enet.c ****         /* Only RGMII mode has the 1000M bit/s. The 1000M only support full duplex. */
 484:../drivers/fsl_enet.c ****         assert(config->miiMode == kENET_RgmiiMode);
 485:../drivers/fsl_enet.c ****         assert(config->miiDuplex == kENET_MiiFullDuplex);
 486:../drivers/fsl_enet.c ****     }
 487:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 488:../drivers/fsl_enet.c **** 
 489:../drivers/fsl_enet.c ****     uint32_t rcr = 0;
 490:../drivers/fsl_enet.c ****     uint32_t tcr = 0;
 491:../drivers/fsl_enet.c ****     uint32_t ecr = base->ECR;
 492:../drivers/fsl_enet.c ****     uint32_t macSpecialConfig = config->macSpecialConfig;
 493:../drivers/fsl_enet.c ****     uint32_t maxFrameLen = config->rxMaxFrameLen;
 494:../drivers/fsl_enet.c **** 
 495:../drivers/fsl_enet.c ****     /* Maximum frame length check. */
 496:../drivers/fsl_enet.c ****     if ((macSpecialConfig & kENET_ControlVLANTagEnable) && (maxFrameLen <= ENET_FRAME_MAX_FRAMELEN)
 497:../drivers/fsl_enet.c ****     {
 498:../drivers/fsl_enet.c ****         maxFrameLen = (ENET_FRAME_MAX_FRAMELEN + ENET_FRAME_VLAN_TAGLEN);
 499:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 500:../drivers/fsl_enet.c ****         if (macSpecialConfig & kENET_ControlSVLANEnable)
 501:../drivers/fsl_enet.c ****         {
 502:../drivers/fsl_enet.c ****             /* Double vlan tag (SVLAN) supported. */
 503:../drivers/fsl_enet.c ****             maxFrameLen += ENET_FRAME_VLAN_TAGLEN;
 504:../drivers/fsl_enet.c ****         }
 505:../drivers/fsl_enet.c ****         ecr |= ((macSpecialConfig & kENET_ControlSVLANEnable) ? (ENET_ECR_SVLANEN_MASK | ENET_ECR_S
 506:../drivers/fsl_enet.c ****                ((macSpecialConfig & kENET_ControlVLANUseSecondTag) ? ENET_ECR_VLANUSE2ND_MASK : 0);
 507:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 508:../drivers/fsl_enet.c ****     }
 509:../drivers/fsl_enet.c **** 
 510:../drivers/fsl_enet.c ****     /* Configures MAC receive controller with user configure structure. */
 511:../drivers/fsl_enet.c ****     rcr = ((macSpecialConfig & kENET_ControlRxPayloadCheckEnable) ? ENET_RCR_NLC_MASK : 0) |
 512:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_CFEN_MASK : 0) |
 513:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_FCE_MASK : 0) |
 514:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxPadRemoveEnable) ? ENET_RCR_PADEN_MASK : 0) |
 515:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxBroadCastRejectEnable) ? ENET_RCR_BC_REJ_MASK : 0) |
 516:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlPromiscuousEnable) ? ENET_RCR_PROM_MASK : 0) |
 517:../drivers/fsl_enet.c ****           ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD_MASK;    
 518:../drivers/fsl_enet.c **** 
 519:../drivers/fsl_enet.c **** /* Set the RGMII or RMII, MII mode and control register. */
 520:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 521:../drivers/fsl_enet.c ****     if (config->miiMode == kENET_RgmiiMode)
 522:../drivers/fsl_enet.c ****     {
 523:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_RGMII_EN_MASK;
 524:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_MII_MODE_MASK;
 525:../drivers/fsl_enet.c ****     }
 526:../drivers/fsl_enet.c ****     else
 527:../drivers/fsl_enet.c ****     {
 528:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_RGMII_EN_MASK;
 529:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 530:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_MII_MODE_MASK;
 531:../drivers/fsl_enet.c ****         if (config->miiMode == kENET_RmiiMode)
 532:../drivers/fsl_enet.c ****         {
 533:../drivers/fsl_enet.c ****             rcr |= ENET_RCR_RMII_MODE_MASK;
 534:../drivers/fsl_enet.c ****         }
 535:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 536:../drivers/fsl_enet.c ****     }
 537:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 538:../drivers/fsl_enet.c ****     /* Speed. */
 539:../drivers/fsl_enet.c ****     if (config->miiSpeed == kENET_MiiSpeed10M)
 540:../drivers/fsl_enet.c ****     {
 541:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_RMII_10T_MASK;
 542:../drivers/fsl_enet.c ****     }
 543:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 544:../drivers/fsl_enet.c ****     if (config->miiSpeed == kENET_MiiSpeed1000M)
 545:../drivers/fsl_enet.c ****     {
 546:../drivers/fsl_enet.c ****         ecr |= ENET_ECR_SPEED_MASK;
 547:../drivers/fsl_enet.c ****     }
 548:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 549:../drivers/fsl_enet.c **** 
 550:../drivers/fsl_enet.c ****     /* Receive setting for half duplex. */
 551:../drivers/fsl_enet.c ****     if (config->miiDuplex == kENET_MiiHalfDuplex)
 552:../drivers/fsl_enet.c ****     {
 553:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_DRT_MASK;
 554:../drivers/fsl_enet.c ****     }
 555:../drivers/fsl_enet.c ****     /* Sets internal loop only for MII mode. */
 556:../drivers/fsl_enet.c ****     if ((config->macSpecialConfig & kENET_ControlMIILoopEnable) && (config->miiMode != kENET_RmiiMo
 557:../drivers/fsl_enet.c ****     {
 558:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_LOOP_MASK;
 559:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_DRT_MASK;
 560:../drivers/fsl_enet.c ****     }
 561:../drivers/fsl_enet.c ****     base->RCR = rcr;
 562:../drivers/fsl_enet.c **** 
 563:../drivers/fsl_enet.c ****     /* Configures MAC transmit controller: duplex mode, mac address insertion. */
 564:../drivers/fsl_enet.c ****     tcr = base->TCR & ~(ENET_TCR_FDEN_MASK | ENET_TCR_ADDINS_MASK);
 565:../drivers/fsl_enet.c ****     tcr |= (config->miiDuplex ? ENET_TCR_FDEN_MASK : 0) |
 566:../drivers/fsl_enet.c ****            ((macSpecialConfig & kENET_ControlMacAddrInsert) ? ENET_TCR_ADDINS_MASK : 0);
 567:../drivers/fsl_enet.c ****     base->TCR = tcr;
 568:../drivers/fsl_enet.c **** 
 569:../drivers/fsl_enet.c ****     /* Configures receive and transmit accelerator. */
 570:../drivers/fsl_enet.c ****     base->TACC = config->txAccelerConfig;
 571:../drivers/fsl_enet.c ****     base->RACC = config->rxAccelerConfig;
 572:../drivers/fsl_enet.c **** 
 573:../drivers/fsl_enet.c ****     /* Sets the pause duration and FIFO threshold for the flow control enabled case. */
 574:../drivers/fsl_enet.c ****     if (macSpecialConfig & kENET_ControlFlowControlEnable)
 575:../drivers/fsl_enet.c ****     {
 576:../drivers/fsl_enet.c ****         uint32_t reemReg;
 577:../drivers/fsl_enet.c ****         base->OPD = config->pauseDuration;
 578:../drivers/fsl_enet.c ****         reemReg = ENET_RSEM_RX_SECTION_EMPTY(config->rxFifoEmptyThreshold);
 579:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_T
 580:../drivers/fsl_enet.c ****         reemReg |= ENET_RSEM_STAT_SECTION_EMPTY(config->rxFifoStatEmptyThreshold);
 581:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 582:../drivers/fsl_enet.c ****         base->RSEM = reemReg;
 583:../drivers/fsl_enet.c ****     }
 584:../drivers/fsl_enet.c **** 
 585:../drivers/fsl_enet.c ****     /* FIFO threshold setting for store and forward enable/disable case. */
 586:../drivers/fsl_enet.c ****     if (macSpecialConfig & kENET_ControlStoreAndFwdDisable)
 587:../drivers/fsl_enet.c ****     {
 588:../drivers/fsl_enet.c ****         /* Transmit fifo watermark settings. */
 589:../drivers/fsl_enet.c ****         base->TFWR = config->txFifoWatermark & ENET_TFWR_TFWR_MASK;
 590:../drivers/fsl_enet.c ****         /* Receive fifo full threshold settings. */
 591:../drivers/fsl_enet.c ****         base->RSFL = config->rxFifoFullThreshold & ENET_RSFL_RX_SECTION_FULL_MASK;
 592:../drivers/fsl_enet.c ****     }
 593:../drivers/fsl_enet.c ****     else
 594:../drivers/fsl_enet.c ****     {
 595:../drivers/fsl_enet.c ****         /* Transmit fifo watermark settings. */
 596:../drivers/fsl_enet.c ****         base->TFWR = ENET_TFWR_STRFWD_MASK;
 597:../drivers/fsl_enet.c ****         base->RSFL = 0;
 598:../drivers/fsl_enet.c ****     }
 599:../drivers/fsl_enet.c **** 
 600:../drivers/fsl_enet.c ****     /* Enable store and forward when accelerator is enabled */
 601:../drivers/fsl_enet.c ****     if (config->txAccelerConfig & (kENET_TxAccelIpCheckEnabled | kENET_TxAccelProtoCheckEnabled))
 602:../drivers/fsl_enet.c ****     {
 603:../drivers/fsl_enet.c ****         base->TFWR = ENET_TFWR_STRFWD_MASK;
 604:../drivers/fsl_enet.c ****     }
 605:../drivers/fsl_enet.c ****     if (config->rxAccelerConfig & (kENET_RxAccelIpCheckEnabled | kENET_RxAccelProtoCheckEnabled))
 606:../drivers/fsl_enet.c ****     {
 607:../drivers/fsl_enet.c ****         base->RSFL = 0;
 608:../drivers/fsl_enet.c ****     }
 609:../drivers/fsl_enet.c **** 
 610:../drivers/fsl_enet.c ****     /* Initializes the ring 0. */
 611:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 612:../drivers/fsl_enet.c ****     base->TDSR = MEMORY_ConvertMemoryMapAddress((uint32_t)bufferConfig->txBdStartAddrAlign, kMEMORY
 613:../drivers/fsl_enet.c ****     base->RDSR = MEMORY_ConvertMemoryMapAddress((uint32_t)bufferConfig->rxBdStartAddrAlign, kMEMORY
 614:../drivers/fsl_enet.c **** #else
 615:../drivers/fsl_enet.c ****     base->TDSR = (uint32_t)bufferConfig->txBdStartAddrAlign;
 616:../drivers/fsl_enet.c ****     base->RDSR = (uint32_t)bufferConfig->rxBdStartAddrAlign;
 617:../drivers/fsl_enet.c **** #endif    
 618:../drivers/fsl_enet.c ****     base->MRBR = bufferConfig->rxBuffSizeAlign;
 619:../drivers/fsl_enet.c **** 
 620:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 621:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 622:../drivers/fsl_enet.c **** 
 623:../drivers/fsl_enet.c ****     if (config->ringNum > 1)
 624:../drivers/fsl_enet.c ****     {
 625:../drivers/fsl_enet.c ****         /* Initializes the ring 1. */
 626:../drivers/fsl_enet.c ****         buffCfg++;
 627:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 628:../drivers/fsl_enet.c ****         base->TDSR1 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->txBdStartAddrAlign, kMEMORY
 629:../drivers/fsl_enet.c ****         base->RDSR1 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->rxBdStartAddrAlign, kMEMORY
 630:../drivers/fsl_enet.c **** #else
 631:../drivers/fsl_enet.c ****         base->TDSR1 = (uint32_t)buffCfg->txBdStartAddrAlign;
 632:../drivers/fsl_enet.c ****         base->RDSR1 = (uint32_t)buffCfg->rxBdStartAddrAlign;     
 633:../drivers/fsl_enet.c **** #endif
 634:../drivers/fsl_enet.c ****         base->MRBR1 = buffCfg->rxBuffSizeAlign;
 635:../drivers/fsl_enet.c ****         /* Enable the DMAC for ring 1 and with no rx classification set. */
 636:../drivers/fsl_enet.c ****         base->DMACFG[0] = ENET_DMACFG_DMA_CLASS_EN_MASK;
 637:../drivers/fsl_enet.c ****     }
 638:../drivers/fsl_enet.c ****     if (config->ringNum > 2)
 639:../drivers/fsl_enet.c ****     {
 640:../drivers/fsl_enet.c ****         /* Initializes the ring 2. */
 641:../drivers/fsl_enet.c ****         buffCfg++;
 642:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 643:../drivers/fsl_enet.c ****         base->TDSR2 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->txBdStartAddrAlign, kMEMORY
 644:../drivers/fsl_enet.c ****         base->RDSR2 = MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->rxBdStartAddrAlign, kMEMORY
 645:../drivers/fsl_enet.c **** #else
 646:../drivers/fsl_enet.c ****         base->TDSR2 = (uint32_t)buffCfg->txBdStartAddrAlign;
 647:../drivers/fsl_enet.c ****         base->RDSR2 = (uint32_t)buffCfg->rxBdStartAddrAlign;
 648:../drivers/fsl_enet.c **** #endif
 649:../drivers/fsl_enet.c ****         base->MRBR2 = buffCfg->rxBuffSizeAlign;
 650:../drivers/fsl_enet.c ****         /* Enable the DMAC for ring 2 and with no rx classification set. */
 651:../drivers/fsl_enet.c ****         base->DMACFG[1] = ENET_DMACFG_DMA_CLASS_EN_MASK;
 652:../drivers/fsl_enet.c ****     }
 653:../drivers/fsl_enet.c **** 
 654:../drivers/fsl_enet.c ****     /* Default the class/ring 1 and 2 are not enabled and the receive classification is disabled
 655:../drivers/fsl_enet.c ****      * so we set the default transmit scheme with the round-robin mode. beacuse the legacy bd mode
 656:../drivers/fsl_enet.c ****      * only support the round-robin mode. if the avb feature is required, just call the setup avb
 657:../drivers/fsl_enet.c ****      * feature API. */
 658:../drivers/fsl_enet.c ****     base->QOS |= ENET_QOS_TX_SCHEME(1);
 659:../drivers/fsl_enet.c **** #endif /*  FSL_FEATURE_ENET_HAS_AVB */
 660:../drivers/fsl_enet.c **** 
 661:../drivers/fsl_enet.c ****     /* Configures the Mac address. */
 662:../drivers/fsl_enet.c ****     ENET_SetMacAddr(base, macAddr);
 663:../drivers/fsl_enet.c **** 
 664:../drivers/fsl_enet.c ****     /* Initialize the SMI if uninitialized. */
 665:../drivers/fsl_enet.c ****     if (!ENET_GetSMI(base))
 666:../drivers/fsl_enet.c ****     {
 667:../drivers/fsl_enet.c ****         ENET_SetSMI(base, srcClock_Hz, !!(config->macSpecialConfig & kENET_ControlSMIPreambleDisabl
 668:../drivers/fsl_enet.c ****     }
 669:../drivers/fsl_enet.c **** 
 670:../drivers/fsl_enet.c **** /* Enables Ethernet interrupt, enables the interrupt coalsecing if it is required. */
 671:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
 672:../drivers/fsl_enet.c ****     if (config->intCoalesceCfg)
 673:../drivers/fsl_enet.c ****     {
 674:../drivers/fsl_enet.c ****         uint32_t intMask = (ENET_EIMR_TXB_MASK | ENET_EIMR_RXB_MASK);
 675:../drivers/fsl_enet.c **** 
 676:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 677:../drivers/fsl_enet.c ****         uint8_t queue = 0;
 678:../drivers/fsl_enet.c ****         intMask |= ENET_EIMR_TXB2_MASK | ENET_EIMR_RXB2_MASK | ENET_EIMR_TXB1_MASK | ENET_EIMR_RXB1
 679:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 680:../drivers/fsl_enet.c **** 
 681:../drivers/fsl_enet.c ****         /* Clear all buffer interrupts. */
 682:../drivers/fsl_enet.c ****         base->EIMR &= ~intMask;
 683:../drivers/fsl_enet.c **** 
 684:../drivers/fsl_enet.c **** /* Set the interrupt coalescence. */
 685:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 686:../drivers/fsl_enet.c ****         for (queue = 0; queue < FSL_FEATURE_ENET_QUEUE; queue++)
 687:../drivers/fsl_enet.c ****         {
 688:../drivers/fsl_enet.c ****             base->TXIC[queue] = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[queue])
 689:../drivers/fsl_enet.c ****                                 config->intCoalesceCfg->txCoalesceTimeCount[queue] | ENET_TXIC_ICCS
 690:../drivers/fsl_enet.c ****                                 ENET_TXIC_ICEN_MASK;
 691:../drivers/fsl_enet.c ****             base->RXIC[queue] = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[queue])
 692:../drivers/fsl_enet.c ****                                 config->intCoalesceCfg->rxCoalesceTimeCount[queue] | ENET_RXIC_ICCS
 693:../drivers/fsl_enet.c ****                                 ENET_RXIC_ICEN_MASK;
 694:../drivers/fsl_enet.c ****         }
 695:../drivers/fsl_enet.c **** #else
 696:../drivers/fsl_enet.c ****         base->TXIC = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[0]) |
 697:../drivers/fsl_enet.c ****                      config->intCoalesceCfg->txCoalesceTimeCount[0] | ENET_TXIC_ICCS_MASK | ENET_TX
 698:../drivers/fsl_enet.c ****         base->RXIC = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[0]) |
 699:../drivers/fsl_enet.c ****                      config->intCoalesceCfg->rxCoalesceTimeCount[0] | ENET_RXIC_ICCS_MASK | ENET_RX
 700:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 701:../drivers/fsl_enet.c ****     }
 702:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
 703:../drivers/fsl_enet.c ****     ENET_EnableInterrupts(base, config->interrupt);
 704:../drivers/fsl_enet.c **** 
 705:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 706:../drivers/fsl_enet.c ****     /* Sets the 1588 enhanced feature. */
 707:../drivers/fsl_enet.c ****     ecr |= ENET_ECR_EN1588_MASK;
 708:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 709:../drivers/fsl_enet.c ****     /* Enables Ethernet module after all configuration except the buffer descriptor active. */
 710:../drivers/fsl_enet.c ****     ecr |= ENET_ECR_ETHEREN_MASK | ENET_ECR_DBSWP_MASK;
 711:../drivers/fsl_enet.c ****     base->ECR = ecr;
 712:../drivers/fsl_enet.c **** }
 713:../drivers/fsl_enet.c **** 
 714:../drivers/fsl_enet.c **** static void ENET_SetTxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 715:../drivers/fsl_enet.c **** {
 716:../drivers/fsl_enet.c ****     assert(config);
 717:../drivers/fsl_enet.c ****     assert(bufferConfig);
 718:../drivers/fsl_enet.c **** 
 719:../drivers/fsl_enet.c ****     /* Default single ring is supported. */
 720:../drivers/fsl_enet.c ****     uint8_t ringNum;
 721:../drivers/fsl_enet.c ****     uint32_t count;
 722:../drivers/fsl_enet.c ****     uint32_t txBuffSizeAlign;
 723:../drivers/fsl_enet.c ****     uint8_t *txBuffer;
 724:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 725:../drivers/fsl_enet.c **** 
 726:../drivers/fsl_enet.c ****     /* Check the input parameters. */
 727:../drivers/fsl_enet.c ****     for (ringNum = 0; ringNum < config->ringNum; ringNum++)
 728:../drivers/fsl_enet.c ****     {
 729:../drivers/fsl_enet.c ****         if ((buffCfg->txBdStartAddrAlign > 0) && (buffCfg->txBufferAlign > 0))
 730:../drivers/fsl_enet.c ****         {
 731:../drivers/fsl_enet.c ****             volatile enet_tx_bd_struct_t *curBuffDescrip = buffCfg->txBdStartAddrAlign;
 732:../drivers/fsl_enet.c ****             txBuffSizeAlign = buffCfg->txBuffSizeAlign;
 733:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 734:../drivers/fsl_enet.c ****             txBuffer = (uint8_t *)MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->txBufferAlign, 
 735:../drivers/fsl_enet.c **** #else
 736:../drivers/fsl_enet.c ****             txBuffer = buffCfg->txBufferAlign;
 737:../drivers/fsl_enet.c **** #endif
 738:../drivers/fsl_enet.c ****             for (count = 0; count < buffCfg->txBdNumber; count++)
 739:../drivers/fsl_enet.c ****             {
 740:../drivers/fsl_enet.c ****                 /* Set data buffer address. */
 741:../drivers/fsl_enet.c ****                 curBuffDescrip->buffer = (uint8_t *)((uint32_t)&txBuffer[count * txBuffSizeAlign]);
 742:../drivers/fsl_enet.c ****                 /* Initializes data length. */
 743:../drivers/fsl_enet.c ****                 curBuffDescrip->length = 0;
 744:../drivers/fsl_enet.c ****                 /* Sets the crc. */
 745:../drivers/fsl_enet.c ****                 curBuffDescrip->control = ENET_BUFFDESCRIPTOR_TX_TRANMITCRC_MASK;
 746:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 747:../drivers/fsl_enet.c ****                 if (count == buffCfg->txBdNumber - 1)
 748:../drivers/fsl_enet.c ****                 {
 749:../drivers/fsl_enet.c ****                     curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_WRAP_MASK;
 750:../drivers/fsl_enet.c ****                 }
 751:../drivers/fsl_enet.c **** 
 752:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 753:../drivers/fsl_enet.c ****                 /* Enable transmit interrupt for store the transmit timestamp. */
 754:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_INTERRUPT_MASK;
 755:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 756:../drivers/fsl_enet.c ****                 /* Set the type of the frame when the credit-based scheme is used. */
 757:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BD_FTYPE(ringNum);
 758:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 759:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 760:../drivers/fsl_enet.c ****                 /* Increase the index. */
 761:../drivers/fsl_enet.c ****                 curBuffDescrip++;
 762:../drivers/fsl_enet.c ****             }
 763:../drivers/fsl_enet.c ****         }
 764:../drivers/fsl_enet.c ****         buffCfg++;
 765:../drivers/fsl_enet.c ****     }
 766:../drivers/fsl_enet.c **** }
 767:../drivers/fsl_enet.c **** 
 768:../drivers/fsl_enet.c **** static void ENET_SetRxBufferDescriptors(enet_handle_t *handle, const enet_config_t *config, const e
 769:../drivers/fsl_enet.c **** {
 770:../drivers/fsl_enet.c ****     assert(config);
 771:../drivers/fsl_enet.c ****     assert(bufferConfig);
 772:../drivers/fsl_enet.c **** 
 773:../drivers/fsl_enet.c ****     /* Default single ring is supported. */
 774:../drivers/fsl_enet.c ****     uint8_t ringNum;
 775:../drivers/fsl_enet.c ****     uint32_t count;
 776:../drivers/fsl_enet.c ****     uint32_t rxBuffSizeAlign;
 777:../drivers/fsl_enet.c ****     uint8_t *rxBuffer;
 778:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 779:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 780:../drivers/fsl_enet.c ****     uint32_t mask = (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt);
 781:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 782:../drivers/fsl_enet.c **** 
 783:../drivers/fsl_enet.c ****     /* Check the input parameters. */
 784:../drivers/fsl_enet.c ****     for (ringNum = 0; ringNum < config->ringNum; ringNum++)
 785:../drivers/fsl_enet.c ****     {
 786:../drivers/fsl_enet.c ****         assert(buffCfg->rxBuffSizeAlign >= ENET_RX_MIN_BUFFERSIZE);
 787:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 788:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 789:../drivers/fsl_enet.c ****         if (ringNum == 1)
 790:../drivers/fsl_enet.c ****         {
 791:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame1Interrupt | kENET_RxBuffer1Interrupt);
 792:../drivers/fsl_enet.c ****         }
 793:../drivers/fsl_enet.c ****         else if (ringNum == 2)
 794:../drivers/fsl_enet.c ****         {
 795:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame2Interrupt | kENET_RxBuffer2Interrupt);
 796:../drivers/fsl_enet.c ****         }
 797:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 798:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 799:../drivers/fsl_enet.c **** 
 800:../drivers/fsl_enet.c ****         if ((buffCfg->rxBdStartAddrAlign > 0) && (buffCfg->rxBufferAlign > 0))
 801:../drivers/fsl_enet.c ****         {
 802:../drivers/fsl_enet.c ****             volatile enet_rx_bd_struct_t *curBuffDescrip = buffCfg->rxBdStartAddrAlign;
 803:../drivers/fsl_enet.c ****             rxBuffSizeAlign = buffCfg->rxBuffSizeAlign;
 804:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 805:../drivers/fsl_enet.c ****             rxBuffer = (uint8_t *)MEMORY_ConvertMemoryMapAddress((uint32_t)buffCfg->rxBufferAlign, 
 806:../drivers/fsl_enet.c **** #else
 807:../drivers/fsl_enet.c ****             rxBuffer = buffCfg->rxBufferAlign;
 808:../drivers/fsl_enet.c **** #endif
 809:../drivers/fsl_enet.c ****             for (count = 0; count < buffCfg->rxBdNumber; count++)
 810:../drivers/fsl_enet.c ****             {
 811:../drivers/fsl_enet.c ****                 /* Set data buffer and the length. */
 812:../drivers/fsl_enet.c ****                 curBuffDescrip->buffer = (uint8_t *)((uint32_t)&rxBuffer[count * rxBuffSizeAlign]);
 813:../drivers/fsl_enet.c ****                 curBuffDescrip->length = 0;
 814:../drivers/fsl_enet.c **** 
 815:../drivers/fsl_enet.c ****                 /* Initializes the buffer descriptors with empty bit. */
 816:../drivers/fsl_enet.c ****                 curBuffDescrip->control = ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
 817:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 818:../drivers/fsl_enet.c ****                 if (count == buffCfg->rxBdNumber - 1)
 819:../drivers/fsl_enet.c ****                 {
 820:../drivers/fsl_enet.c ****                     curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_RX_WRAP_MASK;
 821:../drivers/fsl_enet.c ****                 }
 822:../drivers/fsl_enet.c **** 
 823:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 824:../drivers/fsl_enet.c ****                 if (config->interrupt & mask)
 825:../drivers/fsl_enet.c ****                 {
 826:../drivers/fsl_enet.c ****                     /* Enable receive interrupt. */
 827:../drivers/fsl_enet.c ****                     curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_RX_INTERRUPT_MASK;
 828:../drivers/fsl_enet.c ****                 }
 829:../drivers/fsl_enet.c ****                 else
 830:../drivers/fsl_enet.c ****                 {
 831:../drivers/fsl_enet.c ****                     curBuffDescrip->controlExtend1 = 0;
 832:../drivers/fsl_enet.c ****                 }
 833:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 834:../drivers/fsl_enet.c ****                 /* Increase the index. */
 835:../drivers/fsl_enet.c ****                 curBuffDescrip++;
 836:../drivers/fsl_enet.c ****             }
 837:../drivers/fsl_enet.c ****         }
 838:../drivers/fsl_enet.c ****         buffCfg++;
 839:../drivers/fsl_enet.c ****     }
 840:../drivers/fsl_enet.c **** }
 841:../drivers/fsl_enet.c **** 
 842:../drivers/fsl_enet.c **** static void ENET_ActiveSend(ENET_Type *base, uint32_t ringId)
 843:../drivers/fsl_enet.c **** {
 844:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
 845:../drivers/fsl_enet.c **** 
 846:../drivers/fsl_enet.c ****     switch (ringId)
 847:../drivers/fsl_enet.c ****     {
 848:../drivers/fsl_enet.c ****         case kENET_Ring0:
 849:../drivers/fsl_enet.c ****             base->TDAR = ENET_TDAR_TDAR_MASK;
 850:../drivers/fsl_enet.c ****             break;
 851:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
 852:../drivers/fsl_enet.c ****         case kENET_Ring1:
 853:../drivers/fsl_enet.c ****             base->TDAR1 = ENET_TDAR1_TDAR_MASK;
 854:../drivers/fsl_enet.c ****             break;
 855:../drivers/fsl_enet.c ****         case kENET_Ring2:
 856:../drivers/fsl_enet.c ****             base->TDAR2 = ENET_TDAR2_TDAR_MASK;
 857:../drivers/fsl_enet.c ****             break;
 858:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 859:../drivers/fsl_enet.c ****         default:
 860:../drivers/fsl_enet.c ****             base->TDAR = ENET_TDAR_TDAR_MASK;
 861:../drivers/fsl_enet.c ****             break;
 862:../drivers/fsl_enet.c ****     }
 863:../drivers/fsl_enet.c **** }
 864:../drivers/fsl_enet.c **** 
 865:../drivers/fsl_enet.c **** void ENET_SetMII(ENET_Type *base, enet_mii_speed_t speed, enet_mii_duplex_t duplex)
 866:../drivers/fsl_enet.c **** {
 867:../drivers/fsl_enet.c ****     uint32_t rcr = base->RCR;
 868:../drivers/fsl_enet.c ****     uint32_t tcr = base->TCR;
 869:../drivers/fsl_enet.c **** 
 870:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 871:../drivers/fsl_enet.c ****     uint32_t ecr = base->ECR;
 872:../drivers/fsl_enet.c **** 
 873:../drivers/fsl_enet.c ****     if (kENET_MiiSpeed1000M == speed)
 874:../drivers/fsl_enet.c ****     {
 875:../drivers/fsl_enet.c ****         assert(duplex == kENET_MiiFullDuplex);
 876:../drivers/fsl_enet.c ****         ecr |= ENET_ECR_SPEED_MASK;
 877:../drivers/fsl_enet.c ****     }
 878:../drivers/fsl_enet.c ****     else
 879:../drivers/fsl_enet.c ****     {
 880:../drivers/fsl_enet.c ****         ecr &= ~ENET_ECR_SPEED_MASK;
 881:../drivers/fsl_enet.c ****     }
 882:../drivers/fsl_enet.c **** 
 883:../drivers/fsl_enet.c ****     base->ECR = ecr;
 884:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 885:../drivers/fsl_enet.c **** 
 886:../drivers/fsl_enet.c ****     /* Sets speed mode. */
 887:../drivers/fsl_enet.c ****     if (kENET_MiiSpeed10M == speed)
 888:../drivers/fsl_enet.c ****     {
 889:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_RMII_10T_MASK;
 890:../drivers/fsl_enet.c ****     }
 891:../drivers/fsl_enet.c ****     else
 892:../drivers/fsl_enet.c ****     {
 893:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_RMII_10T_MASK;
 894:../drivers/fsl_enet.c ****     }
 895:../drivers/fsl_enet.c ****     /* Set duplex mode. */
 896:../drivers/fsl_enet.c ****     if (duplex == kENET_MiiHalfDuplex)
 897:../drivers/fsl_enet.c ****     {
 898:../drivers/fsl_enet.c ****         rcr |= ENET_RCR_DRT_MASK;
 899:../drivers/fsl_enet.c ****         tcr &= ~ENET_TCR_FDEN_MASK;
 900:../drivers/fsl_enet.c ****     }
 901:../drivers/fsl_enet.c ****     else
 902:../drivers/fsl_enet.c ****     {
 903:../drivers/fsl_enet.c ****         rcr &= ~ENET_RCR_DRT_MASK;
 904:../drivers/fsl_enet.c ****         tcr |= ENET_TCR_FDEN_MASK;
 905:../drivers/fsl_enet.c ****     }
 906:../drivers/fsl_enet.c **** 
 907:../drivers/fsl_enet.c ****     base->RCR = rcr;
 908:../drivers/fsl_enet.c ****     base->TCR = tcr;
 909:../drivers/fsl_enet.c **** }
 910:../drivers/fsl_enet.c **** 
 911:../drivers/fsl_enet.c **** void ENET_SetMacAddr(ENET_Type *base, uint8_t *macAddr)
 912:../drivers/fsl_enet.c **** {
 913:../drivers/fsl_enet.c ****     uint32_t address;
 914:../drivers/fsl_enet.c **** 
 915:../drivers/fsl_enet.c ****     /* Set physical address lower register. */
 916:../drivers/fsl_enet.c ****     address = (uint32_t)(((uint32_t)macAddr[0] << 24U) | ((uint32_t)macAddr[1] << 16U) | ((uint32_t
 917:../drivers/fsl_enet.c ****                          (uint32_t)macAddr[3]);
 918:../drivers/fsl_enet.c ****     base->PALR = address;
 919:../drivers/fsl_enet.c ****     /* Set physical address high register. */
 920:../drivers/fsl_enet.c ****     address = (uint32_t)(((uint32_t)macAddr[4] << 8U) | ((uint32_t)macAddr[5]));
 921:../drivers/fsl_enet.c ****     base->PAUR = address << ENET_PAUR_PADDR2_SHIFT;
 922:../drivers/fsl_enet.c **** }
 923:../drivers/fsl_enet.c **** 
 924:../drivers/fsl_enet.c **** void ENET_GetMacAddr(ENET_Type *base, uint8_t *macAddr)
 925:../drivers/fsl_enet.c **** {
 926:../drivers/fsl_enet.c ****     assert(macAddr);
 927:../drivers/fsl_enet.c **** 
 928:../drivers/fsl_enet.c ****     uint32_t address;
 929:../drivers/fsl_enet.c **** 
 930:../drivers/fsl_enet.c ****     /* Get from physical address lower register. */
 931:../drivers/fsl_enet.c ****     address = base->PALR;
 932:../drivers/fsl_enet.c ****     macAddr[0] = 0xFFU & (address >> 24U);
 933:../drivers/fsl_enet.c ****     macAddr[1] = 0xFFU & (address >> 16U);
 934:../drivers/fsl_enet.c ****     macAddr[2] = 0xFFU & (address >> 8U);
 935:../drivers/fsl_enet.c ****     macAddr[3] = 0xFFU & address;
 936:../drivers/fsl_enet.c **** 
 937:../drivers/fsl_enet.c ****     /* Get from physical address high register. */
 938:../drivers/fsl_enet.c ****     address = (base->PAUR & ENET_PAUR_PADDR2_MASK) >> ENET_PAUR_PADDR2_SHIFT;
 939:../drivers/fsl_enet.c ****     macAddr[4] = 0xFFU & (address >> 8U);
 940:../drivers/fsl_enet.c ****     macAddr[5] = 0xFFU & address;
 941:../drivers/fsl_enet.c **** }
 942:../drivers/fsl_enet.c **** 
 943:../drivers/fsl_enet.c **** void ENET_SetSMI(ENET_Type *base, uint32_t srcClock_Hz, bool isPreambleDisabled)
 944:../drivers/fsl_enet.c **** {
 945:../drivers/fsl_enet.c ****     assert(srcClock_Hz);
 946:../drivers/fsl_enet.c **** 
 947:../drivers/fsl_enet.c ****     uint32_t clkCycle = 0;
 948:../drivers/fsl_enet.c ****     uint32_t speed = 0;
 949:../drivers/fsl_enet.c ****     uint32_t mscr = 0;
 950:../drivers/fsl_enet.c **** 
 951:../drivers/fsl_enet.c ****     /* Calculate the MII speed which controls the frequency of the MDC. */
 952:../drivers/fsl_enet.c ****     speed = srcClock_Hz / (2 * ENET_MDC_FREQUENCY);
 953:../drivers/fsl_enet.c ****     /* Calculate the hold time on the MDIO output. */
 954:../drivers/fsl_enet.c ****     clkCycle = (10 + ENET_NANOSECOND_ONE_SECOND / srcClock_Hz - 1) / (ENET_NANOSECOND_ONE_SECOND / 
 955:../drivers/fsl_enet.c ****     /* Build the configuration for MDC/MDIO control. */
 956:../drivers/fsl_enet.c ****     mscr = ENET_MSCR_MII_SPEED(speed) | ENET_MSCR_HOLDTIME(clkCycle) | (isPreambleDisabled ? ENET_M
 957:../drivers/fsl_enet.c ****     base->MSCR = mscr;
 958:../drivers/fsl_enet.c **** }
 959:../drivers/fsl_enet.c **** 
 960:../drivers/fsl_enet.c **** void ENET_StartSMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_write_t operat
 961:../drivers/fsl_enet.c **** {
 962:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 963:../drivers/fsl_enet.c **** 
 964:../drivers/fsl_enet.c ****     /* Build MII write command. */
 965:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg)
 966:../drivers/fsl_enet.c ****            (data & 0xFFFF);
 967:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 968:../drivers/fsl_enet.c **** }
 969:../drivers/fsl_enet.c **** 
 970:../drivers/fsl_enet.c **** void ENET_StartSMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_read_t operatio
 971:../drivers/fsl_enet.c **** {
 972:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 973:../drivers/fsl_enet.c **** 
 974:../drivers/fsl_enet.c ****     /* Build MII read command. */
 975:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg)
 976:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 977:../drivers/fsl_enet.c **** }
 978:../drivers/fsl_enet.c **** 
 979:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
 980:../drivers/fsl_enet.c **** void ENET_StartExtC45SMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data)
 981:../drivers/fsl_enet.c **** {
 982:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 983:../drivers/fsl_enet.c **** 
 984:../drivers/fsl_enet.c ****     /* Parse the address from the input register. */
 985:../drivers/fsl_enet.c ****     uint16_t devAddr = (phyReg >> ENET_MMFR_TA_SHIFT) & 0x1FU;
 986:../drivers/fsl_enet.c ****     uint16_t regAddr = (uint16_t)(phyReg & 0xFFFFU);
 987:../drivers/fsl_enet.c **** 
 988:../drivers/fsl_enet.c ****     /* Address write firstly. */
 989:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MM
 990:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2) | ENET_MMFR_DATA(regAddr);
 991:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 992:../drivers/fsl_enet.c **** 
 993:../drivers/fsl_enet.c ****     /* Build MII write command. */
 994:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiWriteFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_M
 995:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2) | ENET_MMFR_DATA(data);
 996:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 997:../drivers/fsl_enet.c **** }
 998:../drivers/fsl_enet.c **** 
 999:../drivers/fsl_enet.c **** void ENET_StartExtC45SMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg)
1000:../drivers/fsl_enet.c **** {
1001:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
1002:../drivers/fsl_enet.c **** 
1003:../drivers/fsl_enet.c ****     /* Parse the address from the input register. */
1004:../drivers/fsl_enet.c ****     uint16_t devAddr = (phyReg >> ENET_MMFR_TA_SHIFT) & 0x1FU;
1005:../drivers/fsl_enet.c ****     uint16_t regAddr = (uint16_t)(phyReg & 0xFFFFU);
1006:../drivers/fsl_enet.c **** 
1007:../drivers/fsl_enet.c ****     /* Address write firstly. */
1008:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MM
1009:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2) | ENET_MMFR_DATA(regAddr);
1010:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
1011:../drivers/fsl_enet.c **** 
1012:../drivers/fsl_enet.c ****     /* Build MII read command. */
1013:../drivers/fsl_enet.c ****     mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiReadFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_MM
1014:../drivers/fsl_enet.c ****            ENET_MMFR_TA(2);
1015:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
1016:../drivers/fsl_enet.c **** }
1017:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */
1018:../drivers/fsl_enet.c **** 
1019:../drivers/fsl_enet.c **** void ENET_GetRxErrBeforeReadFrame(enet_handle_t *handle, enet_data_error_stats_t *eErrorStatic)
1020:../drivers/fsl_enet.c **** {
1021:../drivers/fsl_enet.c ****     assert(handle);
1022:../drivers/fsl_enet.c ****     assert(handle->rxBdCurrent[0]);
1023:../drivers/fsl_enet.c ****     assert(eErrorStatic);
1024:../drivers/fsl_enet.c **** 
1025:../drivers/fsl_enet.c ****     uint16_t control = 0;
1026:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[0];
1027:../drivers/fsl_enet.c **** 
1028:../drivers/fsl_enet.c ****     do
1029:../drivers/fsl_enet.c ****     {
1030:../drivers/fsl_enet.c ****         /* The last buffer descriptor of a frame. */
1031:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1032:../drivers/fsl_enet.c ****         {
1033:../drivers/fsl_enet.c ****             control = curBuffDescrip->control;
1034:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
1035:../drivers/fsl_enet.c ****             {
1036:../drivers/fsl_enet.c ****                 /* The receive truncate error. */
1037:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxTruncateErr++;
1038:../drivers/fsl_enet.c ****             }
1039:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK)
1040:../drivers/fsl_enet.c ****             {
1041:../drivers/fsl_enet.c ****                 /* The receive over run error. */
1042:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxOverRunErr++;
1043:../drivers/fsl_enet.c ****             }
1044:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK)
1045:../drivers/fsl_enet.c ****             {
1046:../drivers/fsl_enet.c ****                 /* The receive length violation error. */
1047:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxLenGreaterErr++;
1048:../drivers/fsl_enet.c ****             }
1049:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK)
1050:../drivers/fsl_enet.c ****             {
1051:../drivers/fsl_enet.c ****                 /* The receive alignment error. */
1052:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxAlignErr++;
1053:../drivers/fsl_enet.c ****             }
1054:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_CRC_MASK)
1055:../drivers/fsl_enet.c ****             {
1056:../drivers/fsl_enet.c ****                 /* The receive CRC error. */
1057:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxFcsErr++;
1058:../drivers/fsl_enet.c ****             }
1059:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1060:../drivers/fsl_enet.c ****             uint16_t controlExt = curBuffDescrip->controlExtend1;
1061:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_MACERR_MASK)
1062:../drivers/fsl_enet.c ****             {
1063:../drivers/fsl_enet.c ****                 /* The MAC error. */
1064:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxMacErr++;
1065:../drivers/fsl_enet.c ****             }
1066:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK)
1067:../drivers/fsl_enet.c ****             {
1068:../drivers/fsl_enet.c ****                 /* The PHY error. */
1069:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxPhyErr++;
1070:../drivers/fsl_enet.c ****             }
1071:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_COLLISION_MASK)
1072:../drivers/fsl_enet.c ****             {
1073:../drivers/fsl_enet.c ****                 /* The receive collision error. */
1074:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxCollisionErr++;
1075:../drivers/fsl_enet.c ****             }
1076:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1077:../drivers/fsl_enet.c **** 
1078:../drivers/fsl_enet.c ****             break;
1079:../drivers/fsl_enet.c ****         }
1080:../drivers/fsl_enet.c **** 
1081:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1082:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1083:../drivers/fsl_enet.c ****         {
1084:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[0];
1085:../drivers/fsl_enet.c ****         }
1086:../drivers/fsl_enet.c ****         else
1087:../drivers/fsl_enet.c ****         {
1088:../drivers/fsl_enet.c ****             curBuffDescrip++;
1089:../drivers/fsl_enet.c ****         }
1090:../drivers/fsl_enet.c **** 
1091:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[0]);
1092:../drivers/fsl_enet.c **** }
1093:../drivers/fsl_enet.c **** 
1094:../drivers/fsl_enet.c **** status_t ENET_GetRxFrameSize(enet_handle_t *handle, uint32_t *length)
1095:../drivers/fsl_enet.c **** {
1096:../drivers/fsl_enet.c ****     assert(handle);
1097:../drivers/fsl_enet.c ****     assert(handle->rxBdCurrent[0]);
1098:../drivers/fsl_enet.c ****     assert(length);
1099:../drivers/fsl_enet.c **** 
1100:../drivers/fsl_enet.c ****     /* Reset the length to zero. */
1101:../drivers/fsl_enet.c ****     *length = 0;
1102:../drivers/fsl_enet.c **** 
1103:../drivers/fsl_enet.c ****     uint16_t validLastMask = ENET_BUFFDESCRIPTOR_RX_LAST_MASK | ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
1104:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[0];
1105:../drivers/fsl_enet.c **** 
1106:../drivers/fsl_enet.c ****     /* Check the current buffer descriptor's empty flag.  if empty means there is no frame received
1107:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)
1108:../drivers/fsl_enet.c ****     {
1109:../drivers/fsl_enet.c ****         return kStatus_ENET_RxFrameEmpty;
1110:../drivers/fsl_enet.c ****     }
1111:../drivers/fsl_enet.c **** 
1112:../drivers/fsl_enet.c ****     do
1113:../drivers/fsl_enet.c ****     {
1114:../drivers/fsl_enet.c ****         /* Add check for abnormal case. */
1115:../drivers/fsl_enet.c ****         if ((!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)) && (!curBuffDescrip->l
1116:../drivers/fsl_enet.c ****         {
1117:../drivers/fsl_enet.c ****             return kStatus_ENET_RxFrameError;
1118:../drivers/fsl_enet.c ****         }
1119:../drivers/fsl_enet.c **** 
1120:../drivers/fsl_enet.c ****         /* Find the last buffer descriptor. */
1121:../drivers/fsl_enet.c ****         if ((curBuffDescrip->control & validLastMask) == ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1122:../drivers/fsl_enet.c ****         {
1123:../drivers/fsl_enet.c ****             /* The last buffer descriptor in the frame check the status of the received frame. */
1124:../drivers/fsl_enet.c ****             if ((curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_ERR_MASK)
1125:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1126:../drivers/fsl_enet.c ****                 || (curBuffDescrip->controlExtend1 & ENET_BUFFDESCRIPTOR_RX_EXT_ERR_MASK)
1127:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1128:../drivers/fsl_enet.c ****                     )
1129:../drivers/fsl_enet.c ****             {
1130:../drivers/fsl_enet.c ****                 return kStatus_ENET_RxFrameError;
1131:../drivers/fsl_enet.c ****             }
1132:../drivers/fsl_enet.c ****             /* FCS is removed by MAC. */
1133:../drivers/fsl_enet.c ****             *length = curBuffDescrip->length;
1134:../drivers/fsl_enet.c ****             return kStatus_Success;
1135:../drivers/fsl_enet.c ****         }
1136:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1137:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1138:../drivers/fsl_enet.c ****         {
1139:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[0];
1140:../drivers/fsl_enet.c ****         }
1141:../drivers/fsl_enet.c ****         else
1142:../drivers/fsl_enet.c ****         {
1143:../drivers/fsl_enet.c ****             curBuffDescrip++;
1144:../drivers/fsl_enet.c ****         }
1145:../drivers/fsl_enet.c **** 
1146:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[0]);
1147:../drivers/fsl_enet.c **** 
1148:../drivers/fsl_enet.c ****     /* The frame is on processing - set to empty status to make application to receive it next time
1149:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameEmpty;
1150:../drivers/fsl_enet.c **** }
1151:../drivers/fsl_enet.c **** 
1152:../drivers/fsl_enet.c **** status_t ENET_ReadFrame(ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length)
1153:../drivers/fsl_enet.c **** {
1154:../drivers/fsl_enet.c ****     assert(handle);
1155:../drivers/fsl_enet.c ****     assert(handle->rxBdCurrent[0]);
1156:../drivers/fsl_enet.c **** 
1157:../drivers/fsl_enet.c ****     uint32_t len = 0;
1158:../drivers/fsl_enet.c ****     uint32_t offset = 0;
1159:../drivers/fsl_enet.c ****     uint16_t control;
1160:../drivers/fsl_enet.c ****     bool isLastBuff = false;
1161:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[0];
1162:../drivers/fsl_enet.c ****     status_t result = kStatus_Success;
1163:../drivers/fsl_enet.c ****     uint32_t address;
1164:../drivers/fsl_enet.c **** 
1165:../drivers/fsl_enet.c ****     /* For data-NULL input, only update the buffer descriptor. */
1166:../drivers/fsl_enet.c ****     if (!data)
1167:../drivers/fsl_enet.c ****     {
1168:../drivers/fsl_enet.c ****         do
1169:../drivers/fsl_enet.c ****         {
1170:../drivers/fsl_enet.c ****             /* Update the control flag. */
1171:../drivers/fsl_enet.c ****             control = handle->rxBdCurrent[0]->control;
1172:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
1173:../drivers/fsl_enet.c ****             ENET_UpdateReadBuffers(base, handle, 0);
1174:../drivers/fsl_enet.c **** 
1175:../drivers/fsl_enet.c ****             /* Find the last buffer descriptor for the frame. */
1176:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1177:../drivers/fsl_enet.c ****             {
1178:../drivers/fsl_enet.c ****                 break;
1179:../drivers/fsl_enet.c ****             }
1180:../drivers/fsl_enet.c **** 
1181:../drivers/fsl_enet.c ****         } while (handle->rxBdCurrent[0] != curBuffDescrip);
1182:../drivers/fsl_enet.c **** 
1183:../drivers/fsl_enet.c ****         return result;
1184:../drivers/fsl_enet.c ****     }
1185:../drivers/fsl_enet.c ****     else
1186:../drivers/fsl_enet.c ****     {
1187:../drivers/fsl_enet.c ****         /* A frame on one buffer or several receive buffers are both considered. */
1188:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1189:../drivers/fsl_enet.c ****         /* Add the cache invalidate maintain. */
1190:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1191:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1192:../drivers/fsl_enet.c **** #else
1193:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1194:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1195:../drivers/fsl_enet.c ****         DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[0]);
1196:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1197:../drivers/fsl_enet.c **** /* A frame on one buffer or several receive buffers are both considered. */
1198:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1199:../drivers/fsl_enet.c ****         enet_ptp_time_data_t ptpTimestamp;
1200:../drivers/fsl_enet.c ****         bool isPtpEventMessage = false;
1201:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1202:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1203:../drivers/fsl_enet.c **** #else
1204:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1205:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1206:../drivers/fsl_enet.c ****         /* Parse the PTP message according to the header message. */
1207:../drivers/fsl_enet.c ****         isPtpEventMessage = ENET_Ptp1588ParseFrame((uint8_t *)address, &ptpTimestamp, false);
1208:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1209:../drivers/fsl_enet.c **** 
1210:../drivers/fsl_enet.c ****         while (!isLastBuff)
1211:../drivers/fsl_enet.c ****         {
1212:../drivers/fsl_enet.c ****             /* The last buffer descriptor of a frame. */
1213:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1214:../drivers/fsl_enet.c ****             {
1215:../drivers/fsl_enet.c ****                 /* This is a valid frame. */
1216:../drivers/fsl_enet.c ****                 isLastBuff = true;
1217:../drivers/fsl_enet.c ****                 if (length == curBuffDescrip->length)
1218:../drivers/fsl_enet.c ****                 {
1219:../drivers/fsl_enet.c ****                     /* Copy the frame to user's buffer without FCS. */
1220:../drivers/fsl_enet.c ****                     len = curBuffDescrip->length - offset;
1221:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1222:../drivers/fsl_enet.c ****                     address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMO
1223:../drivers/fsl_enet.c **** #else
1224:../drivers/fsl_enet.c ****                     address = (uint32_t)curBuffDescrip->buffer;
1225:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1226:../drivers/fsl_enet.c ****                     memcpy(data + offset, (void *)address, len);
1227:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1228:../drivers/fsl_enet.c ****                     /* Store the PTP 1588 timestamp for received PTP event frame. */
1229:../drivers/fsl_enet.c ****                     if (isPtpEventMessage)
1230:../drivers/fsl_enet.c ****                     {
1231:../drivers/fsl_enet.c ****                         /* Set the timestamp to the timestamp ring. */
1232:../drivers/fsl_enet.c ****                         ptpTimestamp.timeStamp.nanosecond = curBuffDescrip->timestamp;
1233:../drivers/fsl_enet.c ****                         result = ENET_StoreRxFrameTime(base, handle, &ptpTimestamp);
1234:../drivers/fsl_enet.c ****                     }
1235:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1236:../drivers/fsl_enet.c **** 
1237:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1238:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, 0);
1239:../drivers/fsl_enet.c ****                     return result;
1240:../drivers/fsl_enet.c ****                 }
1241:../drivers/fsl_enet.c ****                 else
1242:../drivers/fsl_enet.c ****                 {
1243:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1244:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, 0);
1245:../drivers/fsl_enet.c ****                 }
1246:../drivers/fsl_enet.c ****             }
1247:../drivers/fsl_enet.c ****             else
1248:../drivers/fsl_enet.c ****             {
1249:../drivers/fsl_enet.c ****                 /* Store a frame on several buffer descriptors. */
1250:../drivers/fsl_enet.c ****                 isLastBuff = false;
1251:../drivers/fsl_enet.c ****                 /* Length check. */
1252:../drivers/fsl_enet.c ****                 if (offset >= length)
1253:../drivers/fsl_enet.c ****                 {
1254:../drivers/fsl_enet.c ****                     break;
1255:../drivers/fsl_enet.c ****                 }
1256:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1257:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1258:../drivers/fsl_enet.c **** #else
1259:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1260:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1261:../drivers/fsl_enet.c ****                 memcpy(data + offset, (void *)address, handle->rxBuffSizeAlign[0]);
1262:../drivers/fsl_enet.c ****                 offset += handle->rxBuffSizeAlign[0];
1263:../drivers/fsl_enet.c **** 
1264:../drivers/fsl_enet.c ****                 /* Updates the receive buffer descriptors. */
1265:../drivers/fsl_enet.c ****                 ENET_UpdateReadBuffers(base, handle, 0);
1266:../drivers/fsl_enet.c ****             }
1267:../drivers/fsl_enet.c **** 
1268:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor. */
1269:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdCurrent[0];
1270:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1271:../drivers/fsl_enet.c ****             /* Add the cache invalidate maintain. */
1272:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1273:../drivers/fsl_enet.c ****             address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2L
1274:../drivers/fsl_enet.c **** #else
1275:../drivers/fsl_enet.c ****             address = (uint32_t)curBuffDescrip->buffer;
1276:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */            
1277:../drivers/fsl_enet.c ****             DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[0]);
1278:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1279:../drivers/fsl_enet.c ****         }
1280:../drivers/fsl_enet.c ****     }
1281:../drivers/fsl_enet.c **** 
1282:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameFail;
1283:../drivers/fsl_enet.c **** }
1284:../drivers/fsl_enet.c **** 
1285:../drivers/fsl_enet.c **** static void ENET_UpdateReadBuffers(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
1286:../drivers/fsl_enet.c **** {
1287:../drivers/fsl_enet.c ****     assert(handle);
1288:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1289:../drivers/fsl_enet.c **** 
1290:../drivers/fsl_enet.c ****     /* Clears status. */
1291:../drivers/fsl_enet.c ****     handle->rxBdCurrent[ringId]->control &= ENET_BUFFDESCRIPTOR_RX_WRAP_MASK;
1292:../drivers/fsl_enet.c ****     /* Sets the receive buffer descriptor with the empty flag. */
1293:../drivers/fsl_enet.c ****     handle->rxBdCurrent[ringId]->control |= ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
1294:../drivers/fsl_enet.c **** 
1295:../drivers/fsl_enet.c ****     /* Increase current buffer descriptor to the next one. */
1296:../drivers/fsl_enet.c ****     if (handle->rxBdCurrent[ringId]->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1297:../drivers/fsl_enet.c ****     {
1298:../drivers/fsl_enet.c ****         handle->rxBdCurrent[ringId] = handle->rxBdBase[ringId];
1299:../drivers/fsl_enet.c ****     }
1300:../drivers/fsl_enet.c ****     else
1301:../drivers/fsl_enet.c ****     {
1302:../drivers/fsl_enet.c ****         handle->rxBdCurrent[ringId]++;
1303:../drivers/fsl_enet.c ****     }
1304:../drivers/fsl_enet.c **** 
1305:../drivers/fsl_enet.c ****     /* Actives the receive buffer descriptor. */
1306:../drivers/fsl_enet.c ****     switch (ringId)
1307:../drivers/fsl_enet.c ****     {
1308:../drivers/fsl_enet.c ****         case kENET_Ring0:
1309:../drivers/fsl_enet.c ****             base->RDAR = ENET_RDAR_RDAR_MASK;
1310:../drivers/fsl_enet.c ****             break;
1311:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
1312:../drivers/fsl_enet.c ****         case kENET_Ring1:
1313:../drivers/fsl_enet.c ****             base->RDAR1 = ENET_RDAR1_RDAR_MASK;
1314:../drivers/fsl_enet.c ****             break;
1315:../drivers/fsl_enet.c ****         case kENET_Ring2:
1316:../drivers/fsl_enet.c ****             base->RDAR2 = ENET_RDAR2_RDAR_MASK;
1317:../drivers/fsl_enet.c ****             break;
1318:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
1319:../drivers/fsl_enet.c ****         default:
1320:../drivers/fsl_enet.c ****             base->RDAR = ENET_RDAR_RDAR_MASK;
1321:../drivers/fsl_enet.c ****             break;
1322:../drivers/fsl_enet.c ****     }
1323:../drivers/fsl_enet.c **** }
1324:../drivers/fsl_enet.c **** 
1325:../drivers/fsl_enet.c **** status_t ENET_SendFrame(ENET_Type *base, enet_handle_t *handle, const uint8_t *data, uint32_t lengt
1326:../drivers/fsl_enet.c **** {
1327:../drivers/fsl_enet.c ****     assert(handle);
1328:../drivers/fsl_enet.c ****     assert(data);
1329:../drivers/fsl_enet.c **** 
1330:../drivers/fsl_enet.c ****     volatile enet_tx_bd_struct_t *curBuffDescrip;
1331:../drivers/fsl_enet.c ****     uint32_t len = 0;
1332:../drivers/fsl_enet.c ****     uint32_t sizeleft = 0;
1333:../drivers/fsl_enet.c ****     uint32_t address;
1334:../drivers/fsl_enet.c **** 
1335:../drivers/fsl_enet.c ****     /* Check the frame length. */
1336:../drivers/fsl_enet.c ****     if (length > ENET_FRAME_MAX_FRAMELEN)
1337:../drivers/fsl_enet.c ****     {
1338:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameOverLen;
1339:../drivers/fsl_enet.c ****     }
1340:../drivers/fsl_enet.c **** 
1341:../drivers/fsl_enet.c ****     /* Check if the transmit buffer is ready. */
1342:../drivers/fsl_enet.c ****     curBuffDescrip = handle->txBdCurrent[0];
1343:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
1344:../drivers/fsl_enet.c ****     {
1345:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1346:../drivers/fsl_enet.c ****     }
1347:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1348:../drivers/fsl_enet.c ****     bool isPtpEventMessage = false;
1349:../drivers/fsl_enet.c ****     /* Check PTP message with the PTP header. */
1350:../drivers/fsl_enet.c ****     isPtpEventMessage = ENET_Ptp1588ParseFrame(data, NULL, true);
1351:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1352:../drivers/fsl_enet.c ****     /* One transmit buffer is enough for one frame. */
1353:../drivers/fsl_enet.c ****     if (handle->txBuffSizeAlign[0] >= length)
1354:../drivers/fsl_enet.c ****     {
1355:../drivers/fsl_enet.c ****         /* Copy data to the buffer for uDMA transfer. */
1356:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1357:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1358:../drivers/fsl_enet.c **** #else
1359:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1360:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1361:../drivers/fsl_enet.c ****         memcpy((void *)address, data, length);
1362:../drivers/fsl_enet.c ****         /* Set data length. */
1363:../drivers/fsl_enet.c ****         curBuffDescrip->length = length;
1364:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1365:../drivers/fsl_enet.c ****         /* For enable the timestamp. */
1366:../drivers/fsl_enet.c ****         if (isPtpEventMessage)
1367:../drivers/fsl_enet.c ****         {
1368:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1369:../drivers/fsl_enet.c ****         }
1370:../drivers/fsl_enet.c ****         else
1371:../drivers/fsl_enet.c ****         {
1372:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1373:../drivers/fsl_enet.c ****         }
1374:../drivers/fsl_enet.c **** 
1375:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1376:../drivers/fsl_enet.c ****         curBuffDescrip->control |= (ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_TX_LAST
1377:../drivers/fsl_enet.c **** 
1378:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor address. */
1379:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1380:../drivers/fsl_enet.c ****         {
1381:../drivers/fsl_enet.c ****             handle->txBdCurrent[0] = handle->txBdBase[0];
1382:../drivers/fsl_enet.c ****         }
1383:../drivers/fsl_enet.c ****         else
1384:../drivers/fsl_enet.c ****         {
1385:../drivers/fsl_enet.c ****             handle->txBdCurrent[0]++;
1386:../drivers/fsl_enet.c ****         }
1387:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1388:../drivers/fsl_enet.c ****         /* Add the cache clean maintain. */
1389:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1390:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1391:../drivers/fsl_enet.c **** #else
1392:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1393:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1394:../drivers/fsl_enet.c ****         DCACHE_CleanByRange(address, length);
1395:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1396:../drivers/fsl_enet.c ****         /* Active the transmit buffer descriptor. */
1397:../drivers/fsl_enet.c ****         ENET_ActiveSend(base, 0);
1398:../drivers/fsl_enet.c **** 
1399:../drivers/fsl_enet.c ****         return kStatus_Success;
1400:../drivers/fsl_enet.c ****     }
1401:../drivers/fsl_enet.c ****     else
1402:../drivers/fsl_enet.c ****     {
1403:../drivers/fsl_enet.c ****         /* One frame requires more than one transmit buffers. */
1404:../drivers/fsl_enet.c ****         do
1405:../drivers/fsl_enet.c ****         {
1406:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1407:../drivers/fsl_enet.c ****             /* For enable the timestamp. */
1408:../drivers/fsl_enet.c ****             if (isPtpEventMessage)
1409:../drivers/fsl_enet.c ****             {
1410:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1411:../drivers/fsl_enet.c ****             }
1412:../drivers/fsl_enet.c ****             else
1413:../drivers/fsl_enet.c ****             {
1414:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1415:../drivers/fsl_enet.c ****             }
1416:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1417:../drivers/fsl_enet.c **** 
1418:../drivers/fsl_enet.c ****             /* Increase the buffer descriptor address. */
1419:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1420:../drivers/fsl_enet.c ****             {
1421:../drivers/fsl_enet.c ****                 handle->txBdCurrent[0] = handle->txBdBase[0];
1422:../drivers/fsl_enet.c ****             }
1423:../drivers/fsl_enet.c ****             else
1424:../drivers/fsl_enet.c ****             {
1425:../drivers/fsl_enet.c ****                 handle->txBdCurrent[0]++;
1426:../drivers/fsl_enet.c ****             }
1427:../drivers/fsl_enet.c ****             /* update the size left to be transmit. */
1428:../drivers/fsl_enet.c ****             sizeleft = length - len;
1429:../drivers/fsl_enet.c ****             if (sizeleft > handle->txBuffSizeAlign[0])
1430:../drivers/fsl_enet.c ****             {
1431:../drivers/fsl_enet.c ****                 /* Data copy. */
1432:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1433:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1434:../drivers/fsl_enet.c **** #else
1435:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1436:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1437:../drivers/fsl_enet.c ****                 memcpy((void *)address, data + len, handle->txBuffSizeAlign[0]);
1438:../drivers/fsl_enet.c ****                 /* Data length update. */
1439:../drivers/fsl_enet.c ****                 curBuffDescrip->length = handle->txBuffSizeAlign[0];
1440:../drivers/fsl_enet.c ****                 len += handle->txBuffSizeAlign[0];
1441:../drivers/fsl_enet.c ****                 /* Sets the control flag. */
1442:../drivers/fsl_enet.c ****                 curBuffDescrip->control &= ~ENET_BUFFDESCRIPTOR_TX_LAST_MASK;
1443:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
1444:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
1445:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, 0);
1446:../drivers/fsl_enet.c ****             }
1447:../drivers/fsl_enet.c ****             else
1448:../drivers/fsl_enet.c ****             {
1449:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1450:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1451:../drivers/fsl_enet.c **** #else
1452:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1453:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1454:../drivers/fsl_enet.c ****                 memcpy((void *)address, data + len, sizeleft);
1455:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
1456:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
1457:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_
1458:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1459:../drivers/fsl_enet.c ****                 /* Add the cache clean maintain. */
1460:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1461:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1462:../drivers/fsl_enet.c **** #else
1463:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1464:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1465:../drivers/fsl_enet.c ****                 DCACHE_CleanByRange(address, handle->txBuffSizeAlign[0]);
1466:../drivers/fsl_enet.c **** #endif  /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */                 
1467:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor. */
1468:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, 0);
1469:../drivers/fsl_enet.c **** 
1470:../drivers/fsl_enet.c ****                 return kStatus_Success;
1471:../drivers/fsl_enet.c ****             }
1472:../drivers/fsl_enet.c **** 
1473:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor address. */
1474:../drivers/fsl_enet.c ****             curBuffDescrip = handle->txBdCurrent[0];
1475:../drivers/fsl_enet.c **** 
1476:../drivers/fsl_enet.c ****         } while (!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK));
1477:../drivers/fsl_enet.c **** 
1478:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1479:../drivers/fsl_enet.c ****     }
1480:../drivers/fsl_enet.c **** }
1481:../drivers/fsl_enet.c **** 
1482:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
1483:../drivers/fsl_enet.c **** void ENET_GetRxErrBeforeReadFrameMultiRing(enet_handle_t *handle,
1484:../drivers/fsl_enet.c ****                                            enet_data_error_stats_t *eErrorStatic,
1485:../drivers/fsl_enet.c ****                                            uint32_t ringId)
1486:../drivers/fsl_enet.c **** {
1487:../drivers/fsl_enet.c ****     assert(handle);
1488:../drivers/fsl_enet.c ****     assert(eErrorStatic);
1489:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1490:../drivers/fsl_enet.c **** 
1491:../drivers/fsl_enet.c ****     uint16_t control = 0;
1492:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[ringId];
1493:../drivers/fsl_enet.c **** 
1494:../drivers/fsl_enet.c ****     do
1495:../drivers/fsl_enet.c ****     {
1496:../drivers/fsl_enet.c ****         /* The last buffer descriptor of a frame. */
1497:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1498:../drivers/fsl_enet.c ****         {
1499:../drivers/fsl_enet.c ****             control = curBuffDescrip->control;
1500:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
1501:../drivers/fsl_enet.c ****             {
1502:../drivers/fsl_enet.c ****                 /* The receive truncate error. */
1503:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxTruncateErr++;
1504:../drivers/fsl_enet.c ****             }
1505:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK)
1506:../drivers/fsl_enet.c ****             {
1507:../drivers/fsl_enet.c ****                 /* The receive over run error. */
1508:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxOverRunErr++;
1509:../drivers/fsl_enet.c ****             }
1510:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK)
1511:../drivers/fsl_enet.c ****             {
1512:../drivers/fsl_enet.c ****                 /* The receive length violation error. */
1513:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxLenGreaterErr++;
1514:../drivers/fsl_enet.c ****             }
1515:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK)
1516:../drivers/fsl_enet.c ****             {
1517:../drivers/fsl_enet.c ****                 /* The receive alignment error. */
1518:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxAlignErr++;
1519:../drivers/fsl_enet.c ****             }
1520:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_CRC_MASK)
1521:../drivers/fsl_enet.c ****             {
1522:../drivers/fsl_enet.c ****                 /* The receive CRC error. */
1523:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxFcsErr++;
1524:../drivers/fsl_enet.c ****             }
1525:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1526:../drivers/fsl_enet.c ****             uint16_t controlExt = curBuffDescrip->controlExtend1;
1527:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_MACERR_MASK)
1528:../drivers/fsl_enet.c ****             {
1529:../drivers/fsl_enet.c ****                 /* The MAC error. */
1530:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxMacErr++;
1531:../drivers/fsl_enet.c ****             }
1532:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK)
1533:../drivers/fsl_enet.c ****             {
1534:../drivers/fsl_enet.c ****                 /* The PHY error. */
1535:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxPhyErr++;
1536:../drivers/fsl_enet.c ****             }
1537:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_RX_COLLISION_MASK)
1538:../drivers/fsl_enet.c ****             {
1539:../drivers/fsl_enet.c ****                 /* The receive collision error. */
1540:../drivers/fsl_enet.c ****                 eErrorStatic->statsRxCollisionErr++;
1541:../drivers/fsl_enet.c ****             }
1542:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1543:../drivers/fsl_enet.c **** 
1544:../drivers/fsl_enet.c ****             break;
1545:../drivers/fsl_enet.c ****         }
1546:../drivers/fsl_enet.c **** 
1547:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1548:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1549:../drivers/fsl_enet.c ****         {
1550:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[ringId];
1551:../drivers/fsl_enet.c ****         }
1552:../drivers/fsl_enet.c ****         else
1553:../drivers/fsl_enet.c ****         {
1554:../drivers/fsl_enet.c ****             curBuffDescrip++;
1555:../drivers/fsl_enet.c ****         }
1556:../drivers/fsl_enet.c **** 
1557:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[ringId]);
1558:../drivers/fsl_enet.c **** }
1559:../drivers/fsl_enet.c **** 
1560:../drivers/fsl_enet.c **** status_t ENET_GetRxFrameSizeMultiRing(enet_handle_t *handle, uint32_t *length, uint32_t ringId)
1561:../drivers/fsl_enet.c **** {
1562:../drivers/fsl_enet.c ****     assert(handle);
1563:../drivers/fsl_enet.c ****     assert(length);
1564:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1565:../drivers/fsl_enet.c **** 
1566:../drivers/fsl_enet.c ****     /* Reset the length to zero. */
1567:../drivers/fsl_enet.c ****     *length = 0;
1568:../drivers/fsl_enet.c ****     uint16_t validLastMask = ENET_BUFFDESCRIPTOR_RX_LAST_MASK | ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
1569:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip;
1570:../drivers/fsl_enet.c **** 
1571:../drivers/fsl_enet.c ****     curBuffDescrip = handle->rxBdCurrent[ringId];
1572:../drivers/fsl_enet.c ****     /* Check the current buffer descriptor's empty flag.  if empty means there is no frame received
1573:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)
1574:../drivers/fsl_enet.c ****     {
1575:../drivers/fsl_enet.c ****         return kStatus_ENET_RxFrameEmpty;
1576:../drivers/fsl_enet.c ****     }
1577:../drivers/fsl_enet.c **** 
1578:../drivers/fsl_enet.c ****     do
1579:../drivers/fsl_enet.c ****     {
1580:../drivers/fsl_enet.c ****         /* Add check for abnormal case. */
1581:../drivers/fsl_enet.c ****         if ((!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)) && (!curBuffDescrip->l
1582:../drivers/fsl_enet.c ****         {
1583:../drivers/fsl_enet.c ****             return kStatus_ENET_RxFrameError;
1584:../drivers/fsl_enet.c ****         }        
1585:../drivers/fsl_enet.c ****         /* Find the last buffer descriptor. */
1586:../drivers/fsl_enet.c ****         if ((curBuffDescrip->control & validLastMask) == ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1587:../drivers/fsl_enet.c ****         {
1588:../drivers/fsl_enet.c ****             /* The last buffer descriptor in the frame check the status of the received frame. */
1589:../drivers/fsl_enet.c ****             if ((curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_ERR_MASK)
1590:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1591:../drivers/fsl_enet.c ****                 || (curBuffDescrip->controlExtend1 & ENET_BUFFDESCRIPTOR_RX_EXT_ERR_MASK)
1592:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1593:../drivers/fsl_enet.c ****                     )
1594:../drivers/fsl_enet.c ****             {
1595:../drivers/fsl_enet.c ****                 return kStatus_ENET_RxFrameError;
1596:../drivers/fsl_enet.c ****             }
1597:../drivers/fsl_enet.c ****             /* FCS is removed by MAC. */
1598:../drivers/fsl_enet.c ****             *length = curBuffDescrip->length;
1599:../drivers/fsl_enet.c ****             return kStatus_Success;
1600:../drivers/fsl_enet.c ****         }
1601:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring
1602:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
1603:../drivers/fsl_enet.c ****         {
1604:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdBase[ringId];
1605:../drivers/fsl_enet.c ****         }
1606:../drivers/fsl_enet.c ****         else
1607:../drivers/fsl_enet.c ****         {
1608:../drivers/fsl_enet.c ****             curBuffDescrip++;
1609:../drivers/fsl_enet.c ****         }
1610:../drivers/fsl_enet.c ****     } while (curBuffDescrip != handle->rxBdCurrent[ringId]);
1611:../drivers/fsl_enet.c **** 
1612:../drivers/fsl_enet.c ****     /* The frame is on processing - set to empty status to make application to receive it next time
1613:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameEmpty;
1614:../drivers/fsl_enet.c **** }
1615:../drivers/fsl_enet.c **** 
1616:../drivers/fsl_enet.c **** status_t ENET_ReadFrameMultiRing(
1617:../drivers/fsl_enet.c ****     ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length, uint32_t ringId)
1618:../drivers/fsl_enet.c **** {
1619:../drivers/fsl_enet.c ****     assert(handle);
1620:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1621:../drivers/fsl_enet.c **** 
1622:../drivers/fsl_enet.c ****     uint32_t len = 0;
1623:../drivers/fsl_enet.c ****     uint32_t offset = 0;
1624:../drivers/fsl_enet.c ****     uint16_t control;
1625:../drivers/fsl_enet.c ****     bool isLastBuff = false;
1626:../drivers/fsl_enet.c ****     volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent[ringId];
1627:../drivers/fsl_enet.c ****     status_t result = kStatus_Success;
1628:../drivers/fsl_enet.c ****     uint32_t address;
1629:../drivers/fsl_enet.c **** 
1630:../drivers/fsl_enet.c ****     /* For data-NULL input, only update the buffer descriptor. */
1631:../drivers/fsl_enet.c ****     if (!data)
1632:../drivers/fsl_enet.c ****     {
1633:../drivers/fsl_enet.c ****         do
1634:../drivers/fsl_enet.c ****         {
1635:../drivers/fsl_enet.c ****             /* Update the control flag. */
1636:../drivers/fsl_enet.c ****             control = handle->rxBdCurrent[ringId]->control;
1637:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
1638:../drivers/fsl_enet.c ****             ENET_UpdateReadBuffers(base, handle, ringId);
1639:../drivers/fsl_enet.c **** 
1640:../drivers/fsl_enet.c ****             /* Find the last buffer descriptor for the frame. */
1641:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1642:../drivers/fsl_enet.c ****             {
1643:../drivers/fsl_enet.c ****                 break;
1644:../drivers/fsl_enet.c ****             }
1645:../drivers/fsl_enet.c **** 
1646:../drivers/fsl_enet.c ****         } while (handle->rxBdCurrent[ringId] != curBuffDescrip);
1647:../drivers/fsl_enet.c **** 
1648:../drivers/fsl_enet.c ****         return result;
1649:../drivers/fsl_enet.c ****     }
1650:../drivers/fsl_enet.c ****     else
1651:../drivers/fsl_enet.c ****     {
1652:../drivers/fsl_enet.c ****         /* A frame on one buffer or several receive buffers are both considered. */
1653:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1654:../drivers/fsl_enet.c ****         /* Add the cache invalidate maintain. */
1655:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1656:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1657:../drivers/fsl_enet.c **** #else
1658:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1659:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1660:../drivers/fsl_enet.c ****         DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[ringId]);
1661:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1662:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1663:../drivers/fsl_enet.c ****         enet_ptp_time_data_t ptpTimestamp;
1664:../drivers/fsl_enet.c ****         bool isPtpEventMessage = false;
1665:../drivers/fsl_enet.c **** 
1666:../drivers/fsl_enet.c ****         /* Parse the PTP message according to the header message. */
1667:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1668:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1669:../drivers/fsl_enet.c **** #else
1670:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1671:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1672:../drivers/fsl_enet.c ****         isPtpEventMessage = ENET_Ptp1588ParseFrame((uint8_t *)address, &ptpTimestamp, false);
1673:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1674:../drivers/fsl_enet.c **** 
1675:../drivers/fsl_enet.c ****         while (!isLastBuff)
1676:../drivers/fsl_enet.c ****         {
1677:../drivers/fsl_enet.c ****             /* The last buffer descriptor of a frame. */
1678:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
1679:../drivers/fsl_enet.c ****             {
1680:../drivers/fsl_enet.c ****                 /* This is a valid frame. */
1681:../drivers/fsl_enet.c ****                 isLastBuff = true;
1682:../drivers/fsl_enet.c ****                 if (length == curBuffDescrip->length)
1683:../drivers/fsl_enet.c ****                 {
1684:../drivers/fsl_enet.c ****                     /* Copy the frame to user's buffer without FCS. */
1685:../drivers/fsl_enet.c ****                     len = curBuffDescrip->length - offset;
1686:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1687:../drivers/fsl_enet.c ****                     address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMO
1688:../drivers/fsl_enet.c **** #else
1689:../drivers/fsl_enet.c ****                     address = (uint32_t)curBuffDescrip->buffer;
1690:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1691:../drivers/fsl_enet.c ****                     memcpy(data + offset, (void *)address, len);
1692:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1693:../drivers/fsl_enet.c ****                     /* Store the PTP 1588 timestamp for received PTP event frame. */
1694:../drivers/fsl_enet.c ****                     if (isPtpEventMessage)
1695:../drivers/fsl_enet.c ****                     {
1696:../drivers/fsl_enet.c ****                         /* Set the timestamp to the timestamp ring. */
1697:../drivers/fsl_enet.c ****                         ptpTimestamp.timeStamp.nanosecond = curBuffDescrip->timestamp;
1698:../drivers/fsl_enet.c ****                         result = ENET_StoreRxFrameTime(base, handle, &ptpTimestamp);
1699:../drivers/fsl_enet.c ****                     }
1700:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1701:../drivers/fsl_enet.c **** 
1702:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1703:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, ringId);
1704:../drivers/fsl_enet.c ****                     return result;
1705:../drivers/fsl_enet.c ****                 }
1706:../drivers/fsl_enet.c ****                 else
1707:../drivers/fsl_enet.c ****                 {
1708:../drivers/fsl_enet.c ****                     /* Updates the receive buffer descriptors. */
1709:../drivers/fsl_enet.c ****                     ENET_UpdateReadBuffers(base, handle, ringId);
1710:../drivers/fsl_enet.c ****                 }
1711:../drivers/fsl_enet.c ****             }
1712:../drivers/fsl_enet.c ****             else
1713:../drivers/fsl_enet.c ****             {
1714:../drivers/fsl_enet.c ****                 /* Store a frame on several buffer descriptors. */
1715:../drivers/fsl_enet.c ****                 isLastBuff = false;
1716:../drivers/fsl_enet.c ****                 /* Length check. */
1717:../drivers/fsl_enet.c ****                 if (offset >= length)
1718:../drivers/fsl_enet.c ****                 {
1719:../drivers/fsl_enet.c ****                     break;
1720:../drivers/fsl_enet.c ****                 }
1721:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1722:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1723:../drivers/fsl_enet.c **** #else
1724:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1725:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1726:../drivers/fsl_enet.c ****                 memcpy(data + offset, (void *)address, handle->rxBuffSizeAlign[ringId]);
1727:../drivers/fsl_enet.c ****                 offset += handle->rxBuffSizeAlign[ringId];
1728:../drivers/fsl_enet.c **** 
1729:../drivers/fsl_enet.c **** 
1730:../drivers/fsl_enet.c ****                 /* Updates the receive buffer descriptors. */
1731:../drivers/fsl_enet.c ****                 ENET_UpdateReadBuffers(base, handle, ringId);
1732:../drivers/fsl_enet.c ****             }
1733:../drivers/fsl_enet.c **** 
1734:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor. */
1735:../drivers/fsl_enet.c **** 
1736:../drivers/fsl_enet.c ****             curBuffDescrip = handle->rxBdCurrent[ringId];
1737:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1738:../drivers/fsl_enet.c ****             /* Add the cache invalidate maintain. */
1739:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1740:../drivers/fsl_enet.c ****             address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2L
1741:../drivers/fsl_enet.c **** #else
1742:../drivers/fsl_enet.c ****             address = (uint32_t)curBuffDescrip->buffer;
1743:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1744:../drivers/fsl_enet.c ****             DCACHE_InvalidateByRange(address, handle->rxBuffSizeAlign[ringId]);
1745:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1746:../drivers/fsl_enet.c ****         }
1747:../drivers/fsl_enet.c ****     }
1748:../drivers/fsl_enet.c **** 
1749:../drivers/fsl_enet.c ****     return kStatus_ENET_RxFrameFail;
1750:../drivers/fsl_enet.c **** }
1751:../drivers/fsl_enet.c **** 
1752:../drivers/fsl_enet.c **** 
1753:../drivers/fsl_enet.c **** status_t ENET_SendFrameMultiRing(
1754:../drivers/fsl_enet.c ****     ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length, uint32_t ringId)
1755:../drivers/fsl_enet.c **** {
1756:../drivers/fsl_enet.c ****     assert(handle);
1757:../drivers/fsl_enet.c ****     assert(data);
1758:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
1759:../drivers/fsl_enet.c **** 
1760:../drivers/fsl_enet.c ****     volatile enet_tx_bd_struct_t *curBuffDescrip;
1761:../drivers/fsl_enet.c ****     uint32_t len = 0;
1762:../drivers/fsl_enet.c ****     uint32_t sizeleft = 0;
1763:../drivers/fsl_enet.c ****     uint32_t address;
1764:../drivers/fsl_enet.c **** 
1765:../drivers/fsl_enet.c ****     /* Check the frame length. */
1766:../drivers/fsl_enet.c ****     if (length > ENET_FRAME_MAX_FRAMELEN)
1767:../drivers/fsl_enet.c ****     {
1768:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameOverLen;
1769:../drivers/fsl_enet.c ****     }
1770:../drivers/fsl_enet.c **** 
1771:../drivers/fsl_enet.c ****     /* Check if the transmit buffer is ready. */
1772:../drivers/fsl_enet.c ****     curBuffDescrip = handle->txBdCurrent[ringId];
1773:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
1774:../drivers/fsl_enet.c ****     {
1775:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1776:../drivers/fsl_enet.c ****     }
1777:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1778:../drivers/fsl_enet.c ****     bool isPtpEventMessage = false;
1779:../drivers/fsl_enet.c ****     /* Check PTP message with the PTP header. */
1780:../drivers/fsl_enet.c ****     isPtpEventMessage = ENET_Ptp1588ParseFrame(data, NULL, true);
1781:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1782:../drivers/fsl_enet.c ****     /* One transmit buffer is enough for one frame. */
1783:../drivers/fsl_enet.c ****     if (handle->txBuffSizeAlign[ringId] >= length)
1784:../drivers/fsl_enet.c ****     {
1785:../drivers/fsl_enet.c ****         /* Copy data to the buffer for uDMA transfer. */
1786:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1787:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1788:../drivers/fsl_enet.c **** #else
1789:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1790:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1791:../drivers/fsl_enet.c ****         memcpy((void *)address, data, length);
1792:../drivers/fsl_enet.c **** 
1793:../drivers/fsl_enet.c ****         /* Set data length. */
1794:../drivers/fsl_enet.c ****         curBuffDescrip->length = length;
1795:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1796:../drivers/fsl_enet.c ****         /* For enable the timestamp. */
1797:../drivers/fsl_enet.c ****         if (isPtpEventMessage)
1798:../drivers/fsl_enet.c ****         {
1799:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1800:../drivers/fsl_enet.c ****         }
1801:../drivers/fsl_enet.c ****         else
1802:../drivers/fsl_enet.c ****         {
1803:../drivers/fsl_enet.c ****             curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1804:../drivers/fsl_enet.c ****         }
1805:../drivers/fsl_enet.c **** 
1806:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1807:../drivers/fsl_enet.c ****         curBuffDescrip->control |= (ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_TX_LAST
1808:../drivers/fsl_enet.c **** 
1809:../drivers/fsl_enet.c ****         /* Increase the buffer descriptor address. */
1810:../drivers/fsl_enet.c ****         if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1811:../drivers/fsl_enet.c ****         {
1812:../drivers/fsl_enet.c ****             handle->txBdCurrent[ringId] = handle->txBdBase[ringId];
1813:../drivers/fsl_enet.c ****         }
1814:../drivers/fsl_enet.c ****         else
1815:../drivers/fsl_enet.c ****         {
1816:../drivers/fsl_enet.c ****             handle->txBdCurrent[ringId]++;
1817:../drivers/fsl_enet.c ****         }
1818:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1819:../drivers/fsl_enet.c ****         /* Add the cache clean maintain. */
1820:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1821:../drivers/fsl_enet.c ****         address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local
1822:../drivers/fsl_enet.c **** #else
1823:../drivers/fsl_enet.c ****         address = (uint32_t)curBuffDescrip->buffer;
1824:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1825:../drivers/fsl_enet.c ****         DCACHE_CleanByRange(address, length);
1826:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1827:../drivers/fsl_enet.c ****         /* Active the transmit buffer descriptor. */
1828:../drivers/fsl_enet.c ****         ENET_ActiveSend(base, ringId);
1829:../drivers/fsl_enet.c **** 
1830:../drivers/fsl_enet.c ****         return kStatus_Success;
1831:../drivers/fsl_enet.c ****     }
1832:../drivers/fsl_enet.c ****     else
1833:../drivers/fsl_enet.c ****     {
1834:../drivers/fsl_enet.c ****         /* One frame requires more than one transmit buffers. */
1835:../drivers/fsl_enet.c ****         do
1836:../drivers/fsl_enet.c ****         {
1837:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
1838:../drivers/fsl_enet.c ****             /* For enable the timestamp. */
1839:../drivers/fsl_enet.c ****             if (isPtpEventMessage)
1840:../drivers/fsl_enet.c ****             {
1841:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1842:../drivers/fsl_enet.c ****             }
1843:../drivers/fsl_enet.c ****             else
1844:../drivers/fsl_enet.c ****             {
1845:../drivers/fsl_enet.c ****                 curBuffDescrip->controlExtend1 &= ~ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK;
1846:../drivers/fsl_enet.c ****             }
1847:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
1848:../drivers/fsl_enet.c **** 
1849:../drivers/fsl_enet.c ****             /* Increase the buffer descriptor address. */
1850:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
1851:../drivers/fsl_enet.c ****             {
1852:../drivers/fsl_enet.c ****                 handle->txBdCurrent[ringId] = handle->txBdBase[ringId];
1853:../drivers/fsl_enet.c ****             }
1854:../drivers/fsl_enet.c ****             else
1855:../drivers/fsl_enet.c ****             {
1856:../drivers/fsl_enet.c ****                 handle->txBdCurrent[ringId]++;
1857:../drivers/fsl_enet.c ****             }
1858:../drivers/fsl_enet.c ****             /* update the size left to be transmit. */
1859:../drivers/fsl_enet.c ****             sizeleft = length - len;
1860:../drivers/fsl_enet.c ****             if (sizeleft > handle->txBuffSizeAlign[ringId])
1861:../drivers/fsl_enet.c ****             {
1862:../drivers/fsl_enet.c ****                 /* Data copy. */
1863:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1864:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1865:../drivers/fsl_enet.c **** #else
1866:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1867:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1868:../drivers/fsl_enet.c ****                 memcpy((void*)address, data + len, handle->txBuffSizeAlign[ringId]);
1869:../drivers/fsl_enet.c ****                 /* Data length update. */
1870:../drivers/fsl_enet.c ****                 curBuffDescrip->length = handle->txBuffSizeAlign[ringId];
1871:../drivers/fsl_enet.c ****                 len += handle->txBuffSizeAlign[ringId];
1872:../drivers/fsl_enet.c ****                 /* Sets the control flag. */
1873:../drivers/fsl_enet.c ****                 curBuffDescrip->control &= ~ENET_BUFFDESCRIPTOR_TX_LAST_MASK;
1874:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
1875:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1876:../drivers/fsl_enet.c ****                 /* Add the cache clean maintain. */
1877:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1878:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1879:../drivers/fsl_enet.c **** #else
1880:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1881:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1882:../drivers/fsl_enet.c ****                 DCACHE_CleanByRange(address, handle->txBuffSizeAlign[ringId]);
1883:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1884:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
1885:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, ringId);
1886:../drivers/fsl_enet.c ****             }
1887:../drivers/fsl_enet.c ****             else
1888:../drivers/fsl_enet.c ****             {
1889:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1890:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1891:../drivers/fsl_enet.c **** #else
1892:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1893:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1894:../drivers/fsl_enet.c ****                 memcpy((void *)address, data + len, sizeleft);
1895:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
1896:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
1897:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_
1898:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1899:../drivers/fsl_enet.c ****                 /* Add the cache clean maintain. */
1900:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
1901:../drivers/fsl_enet.c ****                 address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_D
1902:../drivers/fsl_enet.c **** #else
1903:../drivers/fsl_enet.c ****                 address = (uint32_t)curBuffDescrip->buffer;
1904:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
1905:../drivers/fsl_enet.c ****                 DCACHE_CleanByRange(address, sizeleft);
1906:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1907:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor. */
1908:../drivers/fsl_enet.c ****                 ENET_ActiveSend(base, ringId);
1909:../drivers/fsl_enet.c **** 
1910:../drivers/fsl_enet.c ****                 return kStatus_Success;
1911:../drivers/fsl_enet.c ****             }
1912:../drivers/fsl_enet.c **** 
1913:../drivers/fsl_enet.c ****             /* Get the current buffer descriptor address. */
1914:../drivers/fsl_enet.c ****             curBuffDescrip = handle->txBdCurrent[ringId];
1915:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
1916:../drivers/fsl_enet.c **** /* Add the cache invalidate maintain. */
1917:../drivers/fsl_enet.c **** #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
1918:../drivers/fsl_enet.c ****         } while (!(curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK));
1919:../drivers/fsl_enet.c **** 
1920:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
1921:../drivers/fsl_enet.c ****     }
1922:../drivers/fsl_enet.c **** }
1923:../drivers/fsl_enet.c **** #endif /*  FSL_FEATURE_ENET_QUEUE > 1 */
1924:../drivers/fsl_enet.c **** 
1925:../drivers/fsl_enet.c **** void ENET_AddMulticastGroup(ENET_Type *base, uint8_t *address)
1926:../drivers/fsl_enet.c **** {
1927:../drivers/fsl_enet.c ****     assert(address);
1928:../drivers/fsl_enet.c **** 
1929:../drivers/fsl_enet.c ****     uint32_t crc = 0xFFFFFFFFU;
1930:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
1931:../drivers/fsl_enet.c ****     uint32_t count2 = 0;
1932:../drivers/fsl_enet.c **** 
1933:../drivers/fsl_enet.c ****     /* Calculates the CRC-32 polynomial on the multicast group address. */
1934:../drivers/fsl_enet.c ****     for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
1935:../drivers/fsl_enet.c ****     {
1936:../drivers/fsl_enet.c ****         uint8_t c = address[count1];
1937:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
1938:../drivers/fsl_enet.c ****         {
1939:../drivers/fsl_enet.c ****             if ((c ^ crc) & 1U)
1940:../drivers/fsl_enet.c ****             {
1941:../drivers/fsl_enet.c ****                 crc >>= 1U;
1942:../drivers/fsl_enet.c ****                 c >>= 1U;
1943:../drivers/fsl_enet.c ****                 crc ^= 0xEDB88320U;
1944:../drivers/fsl_enet.c ****             }
1945:../drivers/fsl_enet.c ****             else
1946:../drivers/fsl_enet.c ****             {
1947:../drivers/fsl_enet.c ****                 crc >>= 1U;
1948:../drivers/fsl_enet.c ****                 c >>= 1U;
1949:../drivers/fsl_enet.c ****             }
1950:../drivers/fsl_enet.c ****         }
1951:../drivers/fsl_enet.c ****     }
1952:../drivers/fsl_enet.c **** 
1953:../drivers/fsl_enet.c ****     /* Enable a multicast group address. */
1954:../drivers/fsl_enet.c ****     if (!((crc >> 0x1FU) & 1U))
1955:../drivers/fsl_enet.c ****     {
1956:../drivers/fsl_enet.c ****         base->GALR |= 1U << ((crc >> 0x1AU) & 0x1FU);
1957:../drivers/fsl_enet.c ****     }
1958:../drivers/fsl_enet.c ****     else
1959:../drivers/fsl_enet.c ****     {
1960:../drivers/fsl_enet.c ****         base->GAUR |= 1U << ((crc >> 0x1AU) & 0x1FU);
1961:../drivers/fsl_enet.c ****     }
1962:../drivers/fsl_enet.c **** }
1963:../drivers/fsl_enet.c **** 
1964:../drivers/fsl_enet.c **** void ENET_LeaveMulticastGroup(ENET_Type *base, uint8_t *address)
1965:../drivers/fsl_enet.c **** {
1966:../drivers/fsl_enet.c ****     assert(address);
1967:../drivers/fsl_enet.c **** 
1968:../drivers/fsl_enet.c ****     uint32_t crc = 0xFFFFFFFFU;
1969:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
1970:../drivers/fsl_enet.c ****     uint32_t count2 = 0;
1971:../drivers/fsl_enet.c **** 
1972:../drivers/fsl_enet.c ****     /* Calculates the CRC-32 polynomial on the multicast group address. */
1973:../drivers/fsl_enet.c ****     for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
1974:../drivers/fsl_enet.c ****     {
1975:../drivers/fsl_enet.c ****         uint8_t c = address[count1];
1976:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
1977:../drivers/fsl_enet.c ****         {
1978:../drivers/fsl_enet.c ****             if ((c ^ crc) & 1U)
1979:../drivers/fsl_enet.c ****             {
1980:../drivers/fsl_enet.c ****                 crc >>= 1U;
1981:../drivers/fsl_enet.c ****                 c >>= 1U;
1982:../drivers/fsl_enet.c ****                 crc ^= 0xEDB88320U;
1983:../drivers/fsl_enet.c ****             }
1984:../drivers/fsl_enet.c ****             else
1985:../drivers/fsl_enet.c ****             {
1986:../drivers/fsl_enet.c ****                 crc >>= 1U;
1987:../drivers/fsl_enet.c ****                 c >>= 1U;
1988:../drivers/fsl_enet.c ****             }
1989:../drivers/fsl_enet.c ****         }
1990:../drivers/fsl_enet.c ****     }
1991:../drivers/fsl_enet.c **** 
1992:../drivers/fsl_enet.c ****     /* Set the hash table. */
1993:../drivers/fsl_enet.c ****     if (!((crc >> 0x1FU) & 1U))
1994:../drivers/fsl_enet.c ****     {
1995:../drivers/fsl_enet.c ****         base->GALR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
1996:../drivers/fsl_enet.c ****     }
1997:../drivers/fsl_enet.c ****     else
1998:../drivers/fsl_enet.c ****     {
1999:../drivers/fsl_enet.c ****         base->GAUR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
2000:../drivers/fsl_enet.c ****     }
2001:../drivers/fsl_enet.c **** }
2002:../drivers/fsl_enet.c **** 
2003:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
2004:../drivers/fsl_enet.c **** status_t ENET_GetTxErrAfterSendFrame(enet_handle_t *handle, enet_data_error_stats_t *eErrorStatic)
2005:../drivers/fsl_enet.c **** {
2006:../drivers/fsl_enet.c ****     assert(handle);
2007:../drivers/fsl_enet.c ****     assert(eErrorStatic);
2008:../drivers/fsl_enet.c **** 
2009:../drivers/fsl_enet.c ****     uint16_t control = 0;
2010:../drivers/fsl_enet.c ****     uint16_t controlExt = 0;
2011:../drivers/fsl_enet.c **** 
2012:../drivers/fsl_enet.c ****     do
2013:../drivers/fsl_enet.c ****     {
2014:../drivers/fsl_enet.c ****         /* Get the current dirty transmit buffer descriptor. */
2015:../drivers/fsl_enet.c ****     control = handle->txBdDirtyStatic[0]->control;
2016:../drivers/fsl_enet.c ****     controlExt = handle->txBdDirtyStatic[0]->controlExtend0;
2017:../drivers/fsl_enet.c **** 
2018:../drivers/fsl_enet.c ****         /* Get the control status data, If the buffer descriptor has not been processed break out. 
2019:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2020:../drivers/fsl_enet.c ****         {
2021:../drivers/fsl_enet.c ****             return kStatus_ENET_TxFrameBusy;
2022:../drivers/fsl_enet.c ****         }
2023:../drivers/fsl_enet.c ****         /* Increase the transmit dirty static pointer. */
2024:../drivers/fsl_enet.c ****         if (handle->txBdDirtyStatic[0]->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
2025:../drivers/fsl_enet.c ****         {
2026:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[0] = handle->txBdBase[0];
2027:../drivers/fsl_enet.c ****         }
2028:../drivers/fsl_enet.c ****         else
2029:../drivers/fsl_enet.c ****         {
2030:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[0]++;
2031:../drivers/fsl_enet.c ****         }
2032:../drivers/fsl_enet.c **** 
2033:../drivers/fsl_enet.c ****         /* If the transmit buffer descriptor is ready and the last buffer descriptor, store packet 
2034:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_LAST_MASK)
2035:../drivers/fsl_enet.c ****         {
2036:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_ERR_MASK)
2037:../drivers/fsl_enet.c ****             {
2038:../drivers/fsl_enet.c ****                 /* Transmit error. */
2039:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxErr++;
2040:../drivers/fsl_enet.c ****             }
2041:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_EXCCOLLISIONERR_MASK)
2042:../drivers/fsl_enet.c ****             {
2043:../drivers/fsl_enet.c ****                 /* Transmit excess collision error. */
2044:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxExcessCollisionErr++;
2045:../drivers/fsl_enet.c ****             }
2046:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_LATECOLLISIONERR_MASK)
2047:../drivers/fsl_enet.c ****             {
2048:../drivers/fsl_enet.c ****                 /* Transmit late collision error. */
2049:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxLateCollisionErr++;
2050:../drivers/fsl_enet.c ****             }
2051:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_UNDERFLOWERR_MASK)
2052:../drivers/fsl_enet.c ****             {
2053:../drivers/fsl_enet.c ****                 /* Transmit under flow error. */
2054:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxUnderFlowErr++;
2055:../drivers/fsl_enet.c ****             }
2056:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_OVERFLOWERR_MASK)
2057:../drivers/fsl_enet.c ****             {
2058:../drivers/fsl_enet.c ****                 /* Transmit over flow error. */
2059:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxOverFlowErr++;
2060:../drivers/fsl_enet.c ****             }
2061:../drivers/fsl_enet.c ****             return kStatus_Success;
2062:../drivers/fsl_enet.c ****         }
2063:../drivers/fsl_enet.c **** 
2064:../drivers/fsl_enet.c ****     } while (handle->txBdDirtyStatic[0] != handle->txBdCurrent[0]);
2065:../drivers/fsl_enet.c **** 
2066:../drivers/fsl_enet.c ****     return kStatus_ENET_TxFrameFail;
2067:../drivers/fsl_enet.c **** }
2068:../drivers/fsl_enet.c **** 
2069:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1 
2070:../drivers/fsl_enet.c **** status_t ENET_GetTxErrAfterSendFrameMultiRing(enet_handle_t *handle, enet_data_error_stats_t *eErro
2071:../drivers/fsl_enet.c ****                                                                              uint32_t ringId)
2072:../drivers/fsl_enet.c **** {
2073:../drivers/fsl_enet.c ****     assert(handle);
2074:../drivers/fsl_enet.c ****     assert(eErrorStatic);
2075:../drivers/fsl_enet.c ****     assert(ringId < FSL_FEATURE_ENET_QUEUE);
2076:../drivers/fsl_enet.c **** 
2077:../drivers/fsl_enet.c ****     uint16_t control = 0;
2078:../drivers/fsl_enet.c ****     uint16_t controlExt = 0;
2079:../drivers/fsl_enet.c **** 
2080:../drivers/fsl_enet.c ****     do
2081:../drivers/fsl_enet.c ****     {
2082:../drivers/fsl_enet.c ****         /* Get the current dirty transmit buffer descriptor. */
2083:../drivers/fsl_enet.c ****         control = handle->txBdDirtyStatic[ringId]->control;
2084:../drivers/fsl_enet.c ****         controlExt = handle->txBdDirtyStatic[ringId]->controlExtend0;
2085:../drivers/fsl_enet.c ****         /* Get the control status data, If the buffer descriptor has not been processed break out. 
2086:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2087:../drivers/fsl_enet.c ****         {
2088:../drivers/fsl_enet.c ****             return kStatus_ENET_TxFrameBusy;
2089:../drivers/fsl_enet.c ****         }
2090:../drivers/fsl_enet.c ****         /* Increase the transmit dirty static pointer. */
2091:../drivers/fsl_enet.c ****         if (handle->txBdDirtyStatic[ringId]->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
2092:../drivers/fsl_enet.c ****         {
2093:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[ringId] = handle->txBdBase[ringId];
2094:../drivers/fsl_enet.c ****         }
2095:../drivers/fsl_enet.c ****         else
2096:../drivers/fsl_enet.c ****         {
2097:../drivers/fsl_enet.c ****             handle->txBdDirtyStatic[ringId]++;
2098:../drivers/fsl_enet.c ****         }
2099:../drivers/fsl_enet.c **** 
2100:../drivers/fsl_enet.c ****         /* If the transmit buffer descriptor is ready and the last buffer descriptor, store packet 
2101:../drivers/fsl_enet.c ****         if (control & ENET_BUFFDESCRIPTOR_TX_LAST_MASK)
2102:../drivers/fsl_enet.c ****         {
2103:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_ERR_MASK)
2104:../drivers/fsl_enet.c ****             {
2105:../drivers/fsl_enet.c ****                 /* Transmit error. */
2106:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxErr++;
2107:../drivers/fsl_enet.c ****             }
2108:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_EXCCOLLISIONERR_MASK)
2109:../drivers/fsl_enet.c ****             {
2110:../drivers/fsl_enet.c ****                 /* Transmit excess collision error. */
2111:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxExcessCollisionErr++;
2112:../drivers/fsl_enet.c ****             }
2113:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_LATECOLLISIONERR_MASK)
2114:../drivers/fsl_enet.c ****             {
2115:../drivers/fsl_enet.c ****                 /* Transmit late collision error. */
2116:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxLateCollisionErr++;
2117:../drivers/fsl_enet.c ****             }
2118:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_UNDERFLOWERR_MASK)
2119:../drivers/fsl_enet.c ****             {
2120:../drivers/fsl_enet.c ****                 /* Transmit under flow error. */
2121:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxUnderFlowErr++;
2122:../drivers/fsl_enet.c ****             }
2123:../drivers/fsl_enet.c ****             if (controlExt & ENET_BUFFDESCRIPTOR_TX_OVERFLOWERR_MASK)
2124:../drivers/fsl_enet.c ****             {
2125:../drivers/fsl_enet.c ****                 /* Transmit over flow error. */
2126:../drivers/fsl_enet.c ****                 eErrorStatic->statsTxOverFlowErr++;
2127:../drivers/fsl_enet.c ****             }
2128:../drivers/fsl_enet.c ****             return kStatus_Success;
2129:../drivers/fsl_enet.c ****         }
2130:../drivers/fsl_enet.c **** 
2131:../drivers/fsl_enet.c ****     } while (handle->txBdDirtyStatic[ringId] != handle->txBdCurrent[ringId]);
2132:../drivers/fsl_enet.c **** 
2133:../drivers/fsl_enet.c ****     return kStatus_ENET_TxFrameFail;
2134:../drivers/fsl_enet.c **** }
2135:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2136:../drivers/fsl_enet.c **** 
2137:../drivers/fsl_enet.c **** static bool ENET_Ptp1588ParseFrame(const uint8_t *data, enet_ptp_time_data_t *ptpTsData, bool isFas
2138:../drivers/fsl_enet.c **** {
2139:../drivers/fsl_enet.c ****     assert(data);
2140:../drivers/fsl_enet.c ****     if (!isFastEnabled)
2141:../drivers/fsl_enet.c ****     {
2142:../drivers/fsl_enet.c ****         assert(ptpTsData);
2143:../drivers/fsl_enet.c ****     }
2144:../drivers/fsl_enet.c **** 
2145:../drivers/fsl_enet.c ****     bool isPtpMsg = false;
2146:../drivers/fsl_enet.c ****     const uint8_t *buffer = data;
2147:../drivers/fsl_enet.c ****     uint16_t ptpType;
2148:../drivers/fsl_enet.c **** 
2149:../drivers/fsl_enet.c ****     /* Check for VLAN frame.
2150:../drivers/fsl_enet.c ****      * Add Double vlan tag check for receiving extended QIN vlan frame. */
2151:../drivers/fsl_enet.c ****     if (*(uint16_t *)(buffer + ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET) == (ENET_HTONS(ENET_8021QVLAN)
2152:../drivers/fsl_enet.c **** #if defined(FSL_FEATUR_ENET_HAS_AVB) && FSL_FEATURE_HAS_AVB
2153:../drivers/fsl_enet.c ****       || ENET_HTONS(ENET_8021QSVLAN)
2154:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
2155:../drivers/fsl_enet.c ****     ))
2156:../drivers/fsl_enet.c ****     {
2157:../drivers/fsl_enet.c ****         buffer += ENET_FRAME_VLAN_TAGLEN;
2158:../drivers/fsl_enet.c **** #if defined(FSL_FEATUR_ENET_HAS_AVB) && FSL_FEATURE_HAS_AVB
2159:../drivers/fsl_enet.c ****         if (*(uint16_t *)(buffer + ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET) == ENET_HTONS(ENET_8021QVL
2160:../drivers/fsl_enet.c ****         {
2161:../drivers/fsl_enet.c ****             buffer += ENET_FRAME_VLAN_TAGLEN;          
2162:../drivers/fsl_enet.c ****         }
2163:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
2164:../drivers/fsl_enet.c ****     }
2165:../drivers/fsl_enet.c **** 
2166:../drivers/fsl_enet.c ****     ptpType = *(uint16_t *)(buffer + ENET_PTP1588_ETHL2_PACKETTYPE_OFFSET);
2167:../drivers/fsl_enet.c ****     switch (ENET_HTONS(ptpType))
2168:../drivers/fsl_enet.c ****     { /* Ethernet layer 2. */
2169:../drivers/fsl_enet.c ****         case ENET_ETHERNETL2:
2170:../drivers/fsl_enet.c ****             if (*(uint8_t *)(buffer + ENET_PTP1588_ETHL2_MSGTYPE_OFFSET) <= kENET_PtpEventMsgType)
2171:../drivers/fsl_enet.c ****             {
2172:../drivers/fsl_enet.c ****                 isPtpMsg = true;
2173:../drivers/fsl_enet.c ****                 if (!isFastEnabled)
2174:../drivers/fsl_enet.c ****                 {
2175:../drivers/fsl_enet.c ****                     /* It's a ptpv2 message and store the ptp header information. */
2176:../drivers/fsl_enet.c ****                     ptpTsData->version = (*(uint8_t *)(buffer + ENET_PTP1588_ETHL2_VERSION_OFFSET))
2177:../drivers/fsl_enet.c ****                     ptpTsData->messageType = (*(uint8_t *)(buffer + ENET_PTP1588_ETHL2_MSGTYPE_OFFS
2178:../drivers/fsl_enet.c ****                     ptpTsData->sequenceId = ENET_HTONS(*(uint16_t *)(buffer + ENET_PTP1588_ETHL2_SE
2179:../drivers/fsl_enet.c ****                     memcpy((void *)&ptpTsData->sourcePortId[0], (void *)(buffer + ENET_PTP1588_ETHL
2180:../drivers/fsl_enet.c ****                            kENET_PtpSrcPortIdLen);
2181:../drivers/fsl_enet.c ****                 }
2182:../drivers/fsl_enet.c ****             }
2183:../drivers/fsl_enet.c ****             break;
2184:../drivers/fsl_enet.c ****         /* IPV4. */
2185:../drivers/fsl_enet.c ****         case ENET_IPV4:
2186:../drivers/fsl_enet.c ****             if ((*(uint8_t *)(buffer + ENET_PTP1588_IPVERSION_OFFSET) >> 4) == ENET_IPV4VERSION)
2187:../drivers/fsl_enet.c ****             {
2188:../drivers/fsl_enet.c ****                 if (((*(uint16_t *)(buffer + ENET_PTP1588_IPV4_UDP_PORT_OFFSET)) == ENET_HTONS(kENE
2189:../drivers/fsl_enet.c ****                     (*(uint8_t *)(buffer + ENET_PTP1588_IPV4_UDP_PROTOCOL_OFFSET) == ENET_UDPVERSIO
2190:../drivers/fsl_enet.c ****                 {
2191:../drivers/fsl_enet.c ****                     /* Set the PTP message flag. */
2192:../drivers/fsl_enet.c ****                     isPtpMsg = true;
2193:../drivers/fsl_enet.c ****                     if (!isFastEnabled)
2194:../drivers/fsl_enet.c ****                     {
2195:../drivers/fsl_enet.c ****                         /* It's a IPV4 ptp message and store the ptp header information. */
2196:../drivers/fsl_enet.c ****                         ptpTsData->version = (*(uint8_t *)(buffer + ENET_PTP1588_IPV4_UDP_VERSION_O
2197:../drivers/fsl_enet.c ****                         ptpTsData->messageType = (*(uint8_t *)(buffer + ENET_PTP1588_IPV4_UDP_MSGTY
2198:../drivers/fsl_enet.c ****                         ptpTsData->sequenceId =
2199:../drivers/fsl_enet.c ****                             ENET_HTONS(*(uint16_t *)(buffer + ENET_PTP1588_IPV4_UDP_SEQUENCEID_OFFS
2200:../drivers/fsl_enet.c ****                         memcpy((void *)&ptpTsData->sourcePortId[0],
2201:../drivers/fsl_enet.c ****                                (void *)(buffer + ENET_PTP1588_IPV4_UDP_CLKID_OFFSET), kENET_PtpSrcP
2202:../drivers/fsl_enet.c ****                     }
2203:../drivers/fsl_enet.c ****                 }
2204:../drivers/fsl_enet.c ****             }
2205:../drivers/fsl_enet.c ****             break;
2206:../drivers/fsl_enet.c ****         /* IPV6. */
2207:../drivers/fsl_enet.c ****         case ENET_IPV6:
2208:../drivers/fsl_enet.c ****             if ((*(uint8_t *)(buffer + ENET_PTP1588_IPVERSION_OFFSET) >> 4) == ENET_IPV6VERSION)
2209:../drivers/fsl_enet.c ****             {
2210:../drivers/fsl_enet.c ****                 if (((*(uint16_t *)(buffer + ENET_PTP1588_IPV6_UDP_PORT_OFFSET)) == ENET_HTONS(kENE
2211:../drivers/fsl_enet.c ****                     (*(uint8_t *)(buffer + ENET_PTP1588_IPV6_UDP_PROTOCOL_OFFSET) == ENET_UDPVERSIO
2212:../drivers/fsl_enet.c ****                 {
2213:../drivers/fsl_enet.c ****                     /* Set the PTP message flag. */
2214:../drivers/fsl_enet.c ****                     isPtpMsg = true;
2215:../drivers/fsl_enet.c ****                     if (!isFastEnabled)
2216:../drivers/fsl_enet.c ****                     {
2217:../drivers/fsl_enet.c ****                         /* It's a IPV6 ptp message and store the ptp header information. */
2218:../drivers/fsl_enet.c ****                         ptpTsData->version = (*(uint8_t *)(buffer + ENET_PTP1588_IPV6_UDP_VERSION_O
2219:../drivers/fsl_enet.c ****                         ptpTsData->messageType = (*(uint8_t *)(buffer + ENET_PTP1588_IPV6_UDP_MSGTY
2220:../drivers/fsl_enet.c ****                         ptpTsData->sequenceId =
2221:../drivers/fsl_enet.c ****                             ENET_HTONS(*(uint16_t *)(buffer + ENET_PTP1588_IPV6_UDP_SEQUENCEID_OFFS
2222:../drivers/fsl_enet.c ****                         memcpy((void *)&ptpTsData->sourcePortId[0],
2223:../drivers/fsl_enet.c ****                                (void *)(buffer + ENET_PTP1588_IPV6_UDP_CLKID_OFFSET), kENET_PtpSrcP
2224:../drivers/fsl_enet.c ****                     }
2225:../drivers/fsl_enet.c ****                 }
2226:../drivers/fsl_enet.c ****             }
2227:../drivers/fsl_enet.c ****             break;
2228:../drivers/fsl_enet.c ****         default:
2229:../drivers/fsl_enet.c ****             break;
2230:../drivers/fsl_enet.c ****     }
2231:../drivers/fsl_enet.c ****     return isPtpMsg;
2232:../drivers/fsl_enet.c **** }
2233:../drivers/fsl_enet.c **** 
2234:../drivers/fsl_enet.c **** void ENET_Ptp1588Configure(ENET_Type *base, enet_handle_t *handle, enet_ptp_config_t *ptpConfig)
2235:../drivers/fsl_enet.c **** {
2236:../drivers/fsl_enet.c ****     assert(handle);
2237:../drivers/fsl_enet.c ****     assert(ptpConfig);
2238:../drivers/fsl_enet.c ****     uint8_t count;
2239:../drivers/fsl_enet.c **** 
2240:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
2241:../drivers/fsl_enet.c ****     uint32_t mask = kENET_TxBufferInterrupt;
2242:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2243:../drivers/fsl_enet.c ****     mask |= kENET_TxBuffer1Interrupt | kENET_TxBuffer2Interrupt;
2244:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2245:../drivers/fsl_enet.c **** 
2246:../drivers/fsl_enet.c ****     /* Start the 1588 timer. */
2247:../drivers/fsl_enet.c ****     ENET_Ptp1588StartTimer(base, ptpConfig->ptp1588ClockSrc_Hz);
2248:../drivers/fsl_enet.c **** 
2249:../drivers/fsl_enet.c ****     for (count = 0; count < handle->ringNum; count++)
2250:../drivers/fsl_enet.c ****     {
2251:../drivers/fsl_enet.c ****         handle->txBdDirtyTime[count] = handle->txBdBase[count];
2252:../drivers/fsl_enet.c ****         handle->txBdDirtyStatic[count] = handle->txBdBase[count];
2253:../drivers/fsl_enet.c ****     }
2254:../drivers/fsl_enet.c **** 
2255:../drivers/fsl_enet.c ****     /* Setting the receive and transmit state for transaction. */
2256:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.ptpTsData = ptpConfig->rxPtpTsData;
2257:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.size = ptpConfig->ptpTsRxBuffNum;
2258:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.front = 0;
2259:../drivers/fsl_enet.c ****     handle->rxPtpTsDataRing.end = 0;
2260:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.ptpTsData = ptpConfig->txPtpTsData;
2261:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.size = ptpConfig->ptpTsTxBuffNum;
2262:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.front = 0;
2263:../drivers/fsl_enet.c ****     handle->txPtpTsDataRing.end = 0;
2264:../drivers/fsl_enet.c ****     handle->msTimerSecond = 0;
2265:../drivers/fsl_enet.c **** 
2266:../drivers/fsl_enet.c ****     /* Set the IRQ handler when the interrupt is enabled. */
2267:../drivers/fsl_enet.c ****     s_enetTxIsr = ENET_TransmitIRQHandler;
2268:../drivers/fsl_enet.c ****     s_enetTsIsr = ENET_Ptp1588TimerIRQHandler;
2269:../drivers/fsl_enet.c **** 
2270:../drivers/fsl_enet.c ****     /* Enables the time stamp interrupt and transmit frame interrupt to
2271:../drivers/fsl_enet.c ****      * handle the time-stamp . */
2272:../drivers/fsl_enet.c ****     ENET_EnableInterrupts(base, (ENET_TS_INTERRUPT | ENET_TX_INTERRUPT));
2273:../drivers/fsl_enet.c ****     ENET_DisableInterrupts(base, mask);
2274:../drivers/fsl_enet.c **** 
2275:../drivers/fsl_enet.c ****     EnableIRQ(s_enetTsIrqId[instance]);
2276:../drivers/fsl_enet.c ****     EnableIRQ(s_enetTxIrqId[instance]);
2277:../drivers/fsl_enet.c **** }
2278:../drivers/fsl_enet.c **** 
2279:../drivers/fsl_enet.c **** void ENET_Ptp1588StartTimer(ENET_Type *base, uint32_t ptpClkSrc)
2280:../drivers/fsl_enet.c **** {
2281:../drivers/fsl_enet.c ****     /* Restart PTP 1588 timer, master clock. */
2282:../drivers/fsl_enet.c ****     base->ATCR = ENET_ATCR_RESTART_MASK;
2283:../drivers/fsl_enet.c **** 
2284:../drivers/fsl_enet.c ****     /* Initializes PTP 1588 timer. */
2285:../drivers/fsl_enet.c ****     base->ATINC = ENET_ATINC_INC(ENET_NANOSECOND_ONE_SECOND / ptpClkSrc);
2286:../drivers/fsl_enet.c ****     base->ATPER = ENET_NANOSECOND_ONE_SECOND;
2287:../drivers/fsl_enet.c ****     /* Sets periodical event and the event signal output assertion and Actives PTP 1588 timer.  */
2288:../drivers/fsl_enet.c ****     base->ATCR = ENET_ATCR_PEREN_MASK | ENET_ATCR_PINPER_MASK | ENET_ATCR_EN_MASK;
2289:../drivers/fsl_enet.c **** }
2290:../drivers/fsl_enet.c **** 
2291:../drivers/fsl_enet.c **** void ENET_Ptp1588GetTimer(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_t *ptpTime)
2292:../drivers/fsl_enet.c **** {
2293:../drivers/fsl_enet.c ****     assert(handle);
2294:../drivers/fsl_enet.c ****     assert(ptpTime);
2295:../drivers/fsl_enet.c ****     uint16_t count = ENET_1588TIME_DELAY_COUNT;
2296:../drivers/fsl_enet.c ****     uint32_t primask;
2297:../drivers/fsl_enet.c **** 
2298:../drivers/fsl_enet.c ****     /* Disables the interrupt. */
2299:../drivers/fsl_enet.c ****     primask = DisableGlobalIRQ();
2300:../drivers/fsl_enet.c **** 
2301:../drivers/fsl_enet.c ****     /* Get the current PTP time. */
2302:../drivers/fsl_enet.c ****     ptpTime->second = handle->msTimerSecond;
2303:../drivers/fsl_enet.c ****     /* Get the nanosecond from the master timer. */
2304:../drivers/fsl_enet.c ****     base->ATCR |= ENET_ATCR_CAPTURE_MASK;
2305:../drivers/fsl_enet.c ****     /* Add at least six clock cycle delay to get accurate time.
2306:../drivers/fsl_enet.c ****        It's the requirement when the 1588 clock source is slower
2307:../drivers/fsl_enet.c ****        than the register clock.
2308:../drivers/fsl_enet.c ****     */
2309:../drivers/fsl_enet.c ****     while (count--)
2310:../drivers/fsl_enet.c ****     {
2311:../drivers/fsl_enet.c ****         __NOP();
2312:../drivers/fsl_enet.c ****     }
2313:../drivers/fsl_enet.c ****     /* Get the captured time. */
2314:../drivers/fsl_enet.c ****     ptpTime->nanosecond = base->ATVR;
2315:../drivers/fsl_enet.c **** 
2316:../drivers/fsl_enet.c ****     /* Enables the interrupt. */
2317:../drivers/fsl_enet.c ****     EnableGlobalIRQ(primask);
2318:../drivers/fsl_enet.c **** }
2319:../drivers/fsl_enet.c **** 
2320:../drivers/fsl_enet.c **** void ENET_Ptp1588SetTimer(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_t *ptpTime)
2321:../drivers/fsl_enet.c **** {
2322:../drivers/fsl_enet.c ****     assert(handle);
2323:../drivers/fsl_enet.c ****     assert(ptpTime);
2324:../drivers/fsl_enet.c **** 
2325:../drivers/fsl_enet.c ****     uint32_t primask;
2326:../drivers/fsl_enet.c **** 
2327:../drivers/fsl_enet.c ****     /* Disables the interrupt. */
2328:../drivers/fsl_enet.c ****     primask = DisableGlobalIRQ();
2329:../drivers/fsl_enet.c **** 
2330:../drivers/fsl_enet.c ****     /* Sets PTP timer. */
2331:../drivers/fsl_enet.c ****     handle->msTimerSecond = ptpTime->second;
2332:../drivers/fsl_enet.c ****     base->ATVR = ptpTime->nanosecond;
2333:../drivers/fsl_enet.c **** 
2334:../drivers/fsl_enet.c ****     /* Enables the interrupt. */
2335:../drivers/fsl_enet.c ****     EnableGlobalIRQ(primask);
2336:../drivers/fsl_enet.c **** }
2337:../drivers/fsl_enet.c **** 
2338:../drivers/fsl_enet.c **** void ENET_Ptp1588AdjustTimer(ENET_Type *base, uint32_t corrIncrease, uint32_t corrPeriod)
2339:../drivers/fsl_enet.c **** {
2340:../drivers/fsl_enet.c ****     /* Set correction for PTP timer increment. */
2341:../drivers/fsl_enet.c ****     base->ATINC = (base->ATINC & ~ENET_ATINC_INC_CORR_MASK) | (corrIncrease << ENET_ATINC_INC_CORR_
2342:../drivers/fsl_enet.c ****     /* Set correction for PTP timer period. */
2343:../drivers/fsl_enet.c ****     base->ATCOR = (base->ATCOR & ~ENET_ATCOR_COR_MASK) | (corrPeriod << ENET_ATCOR_COR_SHIFT);
2344:../drivers/fsl_enet.c **** }
2345:../drivers/fsl_enet.c **** 
2346:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588UpdateTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
2347:../drivers/fsl_enet.c **** {
2348:../drivers/fsl_enet.c ****     assert(ptpTsDataRing);
2349:../drivers/fsl_enet.c ****     assert(ptpTsDataRing->ptpTsData);
2350:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2351:../drivers/fsl_enet.c **** 
2352:../drivers/fsl_enet.c ****     uint16_t usedBuffer = 0;
2353:../drivers/fsl_enet.c **** 
2354:../drivers/fsl_enet.c ****     /* Check if the buffers ring is full. */
2355:../drivers/fsl_enet.c ****     if (ptpTsDataRing->end >= ptpTsDataRing->front)
2356:../drivers/fsl_enet.c ****     {
2357:../drivers/fsl_enet.c ****         usedBuffer = ptpTsDataRing->end - ptpTsDataRing->front;
2358:../drivers/fsl_enet.c ****     }
2359:../drivers/fsl_enet.c ****     else
2360:../drivers/fsl_enet.c ****     {
2361:../drivers/fsl_enet.c ****         usedBuffer = ptpTsDataRing->size - (ptpTsDataRing->front - ptpTsDataRing->end);
2362:../drivers/fsl_enet.c ****     }
2363:../drivers/fsl_enet.c **** 
2364:../drivers/fsl_enet.c ****     if (usedBuffer == ptpTsDataRing->size)
2365:../drivers/fsl_enet.c ****     {
2366:../drivers/fsl_enet.c ****         return kStatus_ENET_PtpTsRingFull;
2367:../drivers/fsl_enet.c ****     }
2368:../drivers/fsl_enet.c **** 
2369:../drivers/fsl_enet.c ****     /* Copy the new data into the buffer. */
2370:../drivers/fsl_enet.c ****     memcpy((ptpTsDataRing->ptpTsData + ptpTsDataRing->end), ptpTimeData, sizeof(enet_ptp_time_data_
2371:../drivers/fsl_enet.c **** 
2372:../drivers/fsl_enet.c ****     /* Increase the buffer pointer to the next empty one. */
2373:../drivers/fsl_enet.c ****     ptpTsDataRing->end = (ptpTsDataRing->end + 1) % ptpTsDataRing->size;
2374:../drivers/fsl_enet.c **** 
2375:../drivers/fsl_enet.c ****     return kStatus_Success;
2376:../drivers/fsl_enet.c **** }
2377:../drivers/fsl_enet.c **** 
2378:../drivers/fsl_enet.c **** static status_t ENET_Ptp1588SearchTimeRing(enet_ptp_time_data_ring_t *ptpTsDataRing, enet_ptp_time_
2379:../drivers/fsl_enet.c **** {
2380:../drivers/fsl_enet.c ****     assert(ptpTsDataRing);
2381:../drivers/fsl_enet.c ****     assert(ptpTsDataRing->ptpTsData);
2382:../drivers/fsl_enet.c ****     assert(ptpTimedata);
2383:../drivers/fsl_enet.c **** 
2384:../drivers/fsl_enet.c ****     uint32_t index;
2385:../drivers/fsl_enet.c ****     uint32_t size;
2386:../drivers/fsl_enet.c ****     uint16_t usedBuffer = 0;
2387:../drivers/fsl_enet.c **** 
2388:../drivers/fsl_enet.c ****     /* Check the PTP 1588 timestamp ring. */
2389:../drivers/fsl_enet.c ****     if (ptpTsDataRing->front == ptpTsDataRing->end)
2390:../drivers/fsl_enet.c ****     {
2391:../drivers/fsl_enet.c ****         return kStatus_ENET_PtpTsRingEmpty;
2392:../drivers/fsl_enet.c ****     }
2393:../drivers/fsl_enet.c **** 
2394:../drivers/fsl_enet.c ****     /* Search the element in the ring buffer */
2395:../drivers/fsl_enet.c ****     index = ptpTsDataRing->front;
2396:../drivers/fsl_enet.c ****     size = ptpTsDataRing->size;
2397:../drivers/fsl_enet.c ****     while (index != ptpTsDataRing->end)
2398:../drivers/fsl_enet.c ****     {
2399:../drivers/fsl_enet.c ****         if (((ptpTsDataRing->ptpTsData + index)->sequenceId == ptpTimedata->sequenceId) &&
2400:../drivers/fsl_enet.c ****             (!memcmp(((void *)&(ptpTsDataRing->ptpTsData + index)->sourcePortId[0]),
2401:../drivers/fsl_enet.c ****                      (void *)&ptpTimedata->sourcePortId[0], kENET_PtpSrcPortIdLen)) &&
2402:../drivers/fsl_enet.c ****             ((ptpTsDataRing->ptpTsData + index)->version == ptpTimedata->version) &&
2403:../drivers/fsl_enet.c ****             ((ptpTsDataRing->ptpTsData + index)->messageType == ptpTimedata->messageType))
2404:../drivers/fsl_enet.c ****         {
2405:../drivers/fsl_enet.c ****             break;
2406:../drivers/fsl_enet.c ****         }
2407:../drivers/fsl_enet.c **** 
2408:../drivers/fsl_enet.c ****         /* Increase the ptp ring index. */
2409:../drivers/fsl_enet.c ****         index = (index + 1) % size;
2410:../drivers/fsl_enet.c ****     }
2411:../drivers/fsl_enet.c **** 
2412:../drivers/fsl_enet.c ****     if (index == ptpTsDataRing->end)
2413:../drivers/fsl_enet.c ****     {
2414:../drivers/fsl_enet.c ****         /* Check if buffers is full. */
2415:../drivers/fsl_enet.c ****         if (ptpTsDataRing->end >= ptpTsDataRing->front)
2416:../drivers/fsl_enet.c ****         {
2417:../drivers/fsl_enet.c ****             usedBuffer = ptpTsDataRing->end - ptpTsDataRing->front;
2418:../drivers/fsl_enet.c ****         }
2419:../drivers/fsl_enet.c ****         else
2420:../drivers/fsl_enet.c ****         {
2421:../drivers/fsl_enet.c ****             usedBuffer = ptpTsDataRing->size - (ptpTsDataRing->front - ptpTsDataRing->end);
2422:../drivers/fsl_enet.c ****         }
2423:../drivers/fsl_enet.c **** 
2424:../drivers/fsl_enet.c ****         if (usedBuffer == ptpTsDataRing->size)
2425:../drivers/fsl_enet.c ****         { /* Drop one in the front. */
2426:../drivers/fsl_enet.c ****             ptpTsDataRing->front = (ptpTsDataRing->front + 1) % size;
2427:../drivers/fsl_enet.c ****         }
2428:../drivers/fsl_enet.c ****         return kStatus_ENET_PtpTsRingFull;
2429:../drivers/fsl_enet.c ****     }
2430:../drivers/fsl_enet.c **** 
2431:../drivers/fsl_enet.c ****     /* Get the right timestamp of the required ptp messag. */
2432:../drivers/fsl_enet.c ****     ptpTimedata->timeStamp.second = (ptpTsDataRing->ptpTsData + index)->timeStamp.second;
2433:../drivers/fsl_enet.c ****     ptpTimedata->timeStamp.nanosecond = (ptpTsDataRing->ptpTsData + index)->timeStamp.nanosecond;
2434:../drivers/fsl_enet.c **** 
2435:../drivers/fsl_enet.c ****     /* Increase the index. */
2436:../drivers/fsl_enet.c ****     ptpTsDataRing->front = (ptpTsDataRing->front + 1) % size;
2437:../drivers/fsl_enet.c **** 
2438:../drivers/fsl_enet.c ****     return kStatus_Success;
2439:../drivers/fsl_enet.c **** }
2440:../drivers/fsl_enet.c **** 
2441:../drivers/fsl_enet.c **** static status_t ENET_StoreRxFrameTime(ENET_Type *base, enet_handle_t *handle, enet_ptp_time_data_t 
2442:../drivers/fsl_enet.c **** {
2443:../drivers/fsl_enet.c ****     assert(handle);
2444:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2445:../drivers/fsl_enet.c **** 
2446:../drivers/fsl_enet.c ****     bool ptpTimerWrap = false;
2447:../drivers/fsl_enet.c ****     enet_ptp_time_t ptpTimer;
2448:../drivers/fsl_enet.c ****     uint32_t primask;
2449:../drivers/fsl_enet.c **** 
2450:../drivers/fsl_enet.c ****     /* Disables the interrupt. */
2451:../drivers/fsl_enet.c ****     primask = DisableGlobalIRQ();
2452:../drivers/fsl_enet.c **** 
2453:../drivers/fsl_enet.c ****     /* Get current PTP timer nanosecond value. */
2454:../drivers/fsl_enet.c ****     ENET_Ptp1588GetTimer(base, handle, &ptpTimer);
2455:../drivers/fsl_enet.c **** 
2456:../drivers/fsl_enet.c ****     /* Get PTP timer wrap event. */
2457:../drivers/fsl_enet.c ****     ptpTimerWrap = base->EIR & kENET_TsTimerInterrupt;
2458:../drivers/fsl_enet.c **** 
2459:../drivers/fsl_enet.c ****     /* Get transmit time stamp second. */
2460:../drivers/fsl_enet.c ****     if ((ptpTimer.nanosecond > ptpTimeData->timeStamp.nanosecond) ||
2461:../drivers/fsl_enet.c ****         ((ptpTimer.nanosecond < ptpTimeData->timeStamp.nanosecond) && ptpTimerWrap))
2462:../drivers/fsl_enet.c ****     {
2463:../drivers/fsl_enet.c ****         ptpTimeData->timeStamp.second = handle->msTimerSecond;
2464:../drivers/fsl_enet.c ****     }
2465:../drivers/fsl_enet.c ****     else
2466:../drivers/fsl_enet.c ****     {
2467:../drivers/fsl_enet.c ****         ptpTimeData->timeStamp.second = handle->msTimerSecond - 1;
2468:../drivers/fsl_enet.c ****     }
2469:../drivers/fsl_enet.c ****     /* Enable the interrupt. */
2470:../drivers/fsl_enet.c ****     EnableGlobalIRQ(primask);
2471:../drivers/fsl_enet.c **** 
2472:../drivers/fsl_enet.c ****     /* Store the timestamp to the receive time stamp ring. */
2473:../drivers/fsl_enet.c ****     /* Check if the buffers ring is full. */
2474:../drivers/fsl_enet.c ****     return ENET_Ptp1588UpdateTimeRing(&handle->rxPtpTsDataRing, ptpTimeData);
2475:../drivers/fsl_enet.c **** }
2476:../drivers/fsl_enet.c **** 
2477:../drivers/fsl_enet.c **** static status_t ENET_StoreTxFrameTime(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
2478:../drivers/fsl_enet.c **** {
2479:../drivers/fsl_enet.c ****     assert(handle);
2480:../drivers/fsl_enet.c **** 
2481:../drivers/fsl_enet.c ****     uint32_t primask;
2482:../drivers/fsl_enet.c ****     bool ptpTimerWrap;
2483:../drivers/fsl_enet.c ****     bool isPtpEventMessage = false;
2484:../drivers/fsl_enet.c ****     enet_ptp_time_data_t ptpTimeData;
2485:../drivers/fsl_enet.c ****     volatile enet_tx_bd_struct_t *curBuffDescrip = handle->txBdDirtyTime[ringId];
2486:../drivers/fsl_enet.c ****     uint32_t address;
2487:../drivers/fsl_enet.c **** 
2488:../drivers/fsl_enet.c ****     /* Get the control status data, If the buffer descriptor has not been processed break out. */
2489:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2490:../drivers/fsl_enet.c ****     {
2491:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameBusy;
2492:../drivers/fsl_enet.c ****     }
2493:../drivers/fsl_enet.c **** 
2494:../drivers/fsl_enet.c ****     /* Parse the PTP message. */
2495:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
2496:../drivers/fsl_enet.c ****     address = MEMORY_ConvertMemoryMapAddress((uint32_t)curBuffDescrip->buffer,kMEMORY_DMA2Local);
2497:../drivers/fsl_enet.c **** #else
2498:../drivers/fsl_enet.c ****     address = (uint32_t)curBuffDescrip->buffer;
2499:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
2500:../drivers/fsl_enet.c ****     isPtpEventMessage = ENET_Ptp1588ParseFrame((uint8_t *)address, &ptpTimeData, false);
2501:../drivers/fsl_enet.c ****     if (isPtpEventMessage)
2502:../drivers/fsl_enet.c ****     {
2503:../drivers/fsl_enet.c ****         do
2504:../drivers/fsl_enet.c ****         {
2505:../drivers/fsl_enet.c ****             /* Increase current buffer descriptor to the next one. */
2506:../drivers/fsl_enet.c ****             if (handle->txBdDirtyTime[ringId]->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
2507:../drivers/fsl_enet.c ****             {
2508:../drivers/fsl_enet.c ****                 handle->txBdDirtyTime[ringId] = handle->txBdBase[ringId];
2509:../drivers/fsl_enet.c ****             }
2510:../drivers/fsl_enet.c ****             else
2511:../drivers/fsl_enet.c ****             {
2512:../drivers/fsl_enet.c ****                 handle->txBdDirtyTime[ringId]++;
2513:../drivers/fsl_enet.c ****             }
2514:../drivers/fsl_enet.c **** 
2515:../drivers/fsl_enet.c ****             /* Do time stamp check on the last buffer descriptor of the frame. */
2516:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_LAST_MASK)
2517:../drivers/fsl_enet.c ****             {
2518:../drivers/fsl_enet.c ****                 /* Disables the interrupt. */
2519:../drivers/fsl_enet.c ****                 primask = DisableGlobalIRQ();
2520:../drivers/fsl_enet.c **** 
2521:../drivers/fsl_enet.c ****                 /* Get current PTP timer nanosecond value. */
2522:../drivers/fsl_enet.c ****                 ENET_Ptp1588GetTimer(base, handle, &ptpTimeData.timeStamp);
2523:../drivers/fsl_enet.c **** 
2524:../drivers/fsl_enet.c ****                 /* Get PTP timer wrap event. */
2525:../drivers/fsl_enet.c ****                 ptpTimerWrap = base->EIR & kENET_TsTimerInterrupt;
2526:../drivers/fsl_enet.c **** 
2527:../drivers/fsl_enet.c ****                 /* Get transmit time stamp second. */
2528:../drivers/fsl_enet.c ****                 if ((ptpTimeData.timeStamp.nanosecond > curBuffDescrip->timestamp) ||
2529:../drivers/fsl_enet.c ****                     ((ptpTimeData.timeStamp.nanosecond < curBuffDescrip->timestamp) && ptpTimerWrap
2530:../drivers/fsl_enet.c ****                 {
2531:../drivers/fsl_enet.c ****                     ptpTimeData.timeStamp.second = handle->msTimerSecond;
2532:../drivers/fsl_enet.c ****                 }
2533:../drivers/fsl_enet.c ****                 else
2534:../drivers/fsl_enet.c ****                 {
2535:../drivers/fsl_enet.c ****                     ptpTimeData.timeStamp.second = handle->msTimerSecond - 1;
2536:../drivers/fsl_enet.c ****                 }
2537:../drivers/fsl_enet.c **** 
2538:../drivers/fsl_enet.c ****                 /* Enable the interrupt. */
2539:../drivers/fsl_enet.c ****                 EnableGlobalIRQ(primask);
2540:../drivers/fsl_enet.c **** 
2541:../drivers/fsl_enet.c ****                 /* Store the timestamp to the transmit timestamp ring. */
2542:../drivers/fsl_enet.c ****                 return ENET_Ptp1588UpdateTimeRing(&handle->txPtpTsDataRing, &ptpTimeData);
2543:../drivers/fsl_enet.c ****             }
2544:../drivers/fsl_enet.c **** 
2545:../drivers/fsl_enet.c ****             /* Get the current transmit buffer descriptor. */
2546:../drivers/fsl_enet.c ****             curBuffDescrip = handle->txBdDirtyTime[ringId];
2547:../drivers/fsl_enet.c **** 
2548:../drivers/fsl_enet.c **** 
2549:../drivers/fsl_enet.c ****             /* Get the control status data, If the buffer descriptor has not been processed break o
2550:../drivers/fsl_enet.c ****             if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
2551:../drivers/fsl_enet.c ****             {
2552:../drivers/fsl_enet.c ****                 return kStatus_ENET_TxFrameBusy;
2553:../drivers/fsl_enet.c ****             }
2554:../drivers/fsl_enet.c ****         } while (handle->txBdDirtyTime[ringId] != handle->txBdCurrent[ringId]);
2555:../drivers/fsl_enet.c ****         return kStatus_ENET_TxFrameFail;
2556:../drivers/fsl_enet.c ****     }
2557:../drivers/fsl_enet.c ****     return kStatus_Success;
2558:../drivers/fsl_enet.c **** }
2559:../drivers/fsl_enet.c **** 
2560:../drivers/fsl_enet.c **** status_t ENET_GetTxFrameTime(enet_handle_t *handle, enet_ptp_time_data_t *ptpTimeData)
2561:../drivers/fsl_enet.c **** {
2562:../drivers/fsl_enet.c ****     assert(handle);
2563:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2564:../drivers/fsl_enet.c **** 
2565:../drivers/fsl_enet.c ****     return ENET_Ptp1588SearchTimeRing(&handle->txPtpTsDataRing, ptpTimeData);
2566:../drivers/fsl_enet.c **** }
2567:../drivers/fsl_enet.c **** 
2568:../drivers/fsl_enet.c **** status_t ENET_GetRxFrameTime(enet_handle_t *handle, enet_ptp_time_data_t *ptpTimeData)
2569:../drivers/fsl_enet.c **** {
2570:../drivers/fsl_enet.c ****     assert(handle);
2571:../drivers/fsl_enet.c ****     assert(ptpTimeData);
2572:../drivers/fsl_enet.c **** 
2573:../drivers/fsl_enet.c ****     return ENET_Ptp1588SearchTimeRing(&handle->rxPtpTsDataRing, ptpTimeData);
2574:../drivers/fsl_enet.c **** }
2575:../drivers/fsl_enet.c **** 
2576:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
2577:../drivers/fsl_enet.c **** void ENET_AVBConfigure(ENET_Type *base, enet_handle_t *handle, const enet_avb_config_t *config)
2578:../drivers/fsl_enet.c **** {
2579:../drivers/fsl_enet.c ****     assert(config);
2580:../drivers/fsl_enet.c **** 
2581:../drivers/fsl_enet.c ****     uint8_t count = 0;
2582:../drivers/fsl_enet.c **** 
2583:../drivers/fsl_enet.c ****     for (count = 0; count < FSL_FEATURE_ENET_QUEUE - 1; count++)
2584:../drivers/fsl_enet.c ****     {
2585:../drivers/fsl_enet.c ****         /* Set the AVB receive ring classification match when the match is not 0. */
2586:../drivers/fsl_enet.c ****         if (config->rxClassifyMatch[count])
2587:../drivers/fsl_enet.c ****         {
2588:../drivers/fsl_enet.c ****             base->RCMR[count] = (config->rxClassifyMatch[count] & 0xFFFF) | ENET_RCMR_MATCHEN_MASK;
2589:../drivers/fsl_enet.c ****         }
2590:../drivers/fsl_enet.c ****         /* Set the dma controller for the extended ring. */
2591:../drivers/fsl_enet.c ****         base->DMACFG[count] |= ENET_DMACFG_IDLE_SLOPE(config->idleSlope[count]);
2592:../drivers/fsl_enet.c ****     }
2593:../drivers/fsl_enet.c **** 
2594:../drivers/fsl_enet.c ****     /* Shall use the credit-based scheme for avb. */
2595:../drivers/fsl_enet.c ****     base->QOS &= ~ENET_QOS_TX_SCHEME_MASK;
2596:../drivers/fsl_enet.c ****     base->QOS |= ENET_QOS_RX_FLUSH0_MASK;
2597:../drivers/fsl_enet.c **** }
2598:../drivers/fsl_enet.c **** #endif /* FSL_FETAURE_ENET_HAS_AVB */
2599:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
2600:../drivers/fsl_enet.c **** 
2601:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2602:../drivers/fsl_enet.c **** void ENET_TransmitIRQHandler(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
2603:../drivers/fsl_enet.c **** #else
2604:../drivers/fsl_enet.c **** void ENET_TransmitIRQHandler(ENET_Type *base, enet_handle_t *handle)
2605:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2606:../drivers/fsl_enet.c **** {
  28              		.loc 1 2606 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  34              		.cfi_def_cfa_offset 24
  35              		.cfi_offset 3, -24
  36              		.cfi_offset 4, -20
  37              		.cfi_offset 5, -16
  38              		.cfi_offset 6, -12
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  41              		.loc 1 2606 0
  42 0002 0446     		mov	r4, r0
  43 0004 0D46     		mov	r5, r1
2607:../drivers/fsl_enet.c ****     assert(handle);
2608:../drivers/fsl_enet.c ****     uint32_t mask = kENET_TxBufferInterrupt | kENET_TxFrameInterrupt;
2609:../drivers/fsl_enet.c **** #if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) || (FSL_FEATURE_ENET_QUEUE > 1)
2610:../drivers/fsl_enet.c ****     uint32_t index = 0;
2611:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTORMODE  || (FSL_FEATURE_ENET_QUEUE > 1) */
2612:../drivers/fsl_enet.c **** 
2613:../drivers/fsl_enet.c **** /* Check if the transmit interrupt happen. */
2614:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2615:../drivers/fsl_enet.c ****     switch (ringId)
2616:../drivers/fsl_enet.c ****     {
2617:../drivers/fsl_enet.c ****         case kENET_Ring1:
2618:../drivers/fsl_enet.c ****             mask = (kENET_TxFrame1Interrupt | kENET_TxBuffer1Interrupt);
2619:../drivers/fsl_enet.c ****             break;
2620:../drivers/fsl_enet.c ****         case kENET_Ring2:
2621:../drivers/fsl_enet.c ****             mask = (kENET_TxFrame2Interrupt | kENET_TxBuffer2Interrupt);
2622:../drivers/fsl_enet.c ****             break;
2623:../drivers/fsl_enet.c ****         default:
2624:../drivers/fsl_enet.c ****             break;
2625:../drivers/fsl_enet.c ****     }
2626:../drivers/fsl_enet.c ****     index = ringId;
2627:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2628:../drivers/fsl_enet.c **** 
2629:../drivers/fsl_enet.c ****     while (mask & base->EIR)
2630:../drivers/fsl_enet.c ****     {
2631:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
2632:../drivers/fsl_enet.c ****         if (base->EIR & kENET_TxFrameInterrupt)
2633:../drivers/fsl_enet.c ****         {
2634:../drivers/fsl_enet.c ****             /* Store the transmit timestamp from the buffer descriptor should be done here. */
2635:../drivers/fsl_enet.c ****             ENET_StoreTxFrameTime(base, handle, index);
2636:../drivers/fsl_enet.c ****         }
2637:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
2638:../drivers/fsl_enet.c **** 
2639:../drivers/fsl_enet.c ****         /* Clear the transmit interrupt event. */
2640:../drivers/fsl_enet.c ****         base->EIR = mask;
  44              		.loc 1 2640 0
  45 0006 4FF04067 		mov	r7, #201326592
  46              	.LVL1:
  47              	.L3:
2629:../drivers/fsl_enet.c ****     {
  48              		.loc 1 2629 0
  49 000a 6368     		ldr	r3, [r4, #4]
  50 000c 13F0406F 		tst	r3, #201326592
  51 0010 00D1     		bne	.L4
2641:../drivers/fsl_enet.c **** 
2642:../drivers/fsl_enet.c ****         /* Callback function. */
2643:../drivers/fsl_enet.c ****         if (handle->callback)
2644:../drivers/fsl_enet.c ****         {
2645:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2646:../drivers/fsl_enet.c ****             handle->callback(base, handle, index, kENET_TxEvent, handle->userData);
2647:../drivers/fsl_enet.c **** #else
2648:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_TxEvent, handle->userData);
2649:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2650:../drivers/fsl_enet.c ****         }
2651:../drivers/fsl_enet.c ****     }
2652:../drivers/fsl_enet.c **** }
  52              		.loc 1 2652 0
  53 0012 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
  54              	.LVL2:
  55              	.L4:
2643:../drivers/fsl_enet.c ****         {
  56              		.loc 1 2643 0
  57 0014 EE69     		ldr	r6, [r5, #28]
2640:../drivers/fsl_enet.c **** 
  58              		.loc 1 2640 0
  59 0016 6760     		str	r7, [r4, #4]
2643:../drivers/fsl_enet.c ****         {
  60              		.loc 1 2643 0
  61 0018 002E     		cmp	r6, #0
  62 001a F6D0     		beq	.L3
2648:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
  63              		.loc 1 2648 0
  64 001c 2B6A     		ldr	r3, [r5, #32]
  65 001e 0122     		movs	r2, #1
  66 0020 2946     		mov	r1, r5
  67 0022 2046     		mov	r0, r4
  68 0024 B047     		blx	r6
  69              	.LVL3:
  70 0026 F0E7     		b	.L3
  71              		.cfi_endproc
  72              	.LFE180:
  74              		.section	.text.ENET_ReceiveIRQHandler,"ax",%progbits
  75              		.align	1
  76              		.global	ENET_ReceiveIRQHandler
  77              		.syntax unified
  78              		.thumb
  79              		.thumb_func
  80              		.fpu fpv4-sp-d16
  82              	ENET_ReceiveIRQHandler:
  83              	.LFB181:
2653:../drivers/fsl_enet.c **** 
2654:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2655:../drivers/fsl_enet.c **** void ENET_ReceiveIRQHandler(ENET_Type *base, enet_handle_t *handle, uint32_t ringId)
2656:../drivers/fsl_enet.c **** #else
2657:../drivers/fsl_enet.c **** void ENET_ReceiveIRQHandler(ENET_Type *base, enet_handle_t *handle)
2658:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2659:../drivers/fsl_enet.c **** {
  84              		.loc 1 2659 0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              	.LVL4:
  89 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  90              		.cfi_def_cfa_offset 24
  91              		.cfi_offset 3, -24
  92              		.cfi_offset 4, -20
  93              		.cfi_offset 5, -16
  94              		.cfi_offset 6, -12
  95              		.cfi_offset 7, -8
  96              		.cfi_offset 14, -4
  97              		.loc 1 2659 0
  98 0002 0446     		mov	r4, r0
  99 0004 0D46     		mov	r5, r1
2660:../drivers/fsl_enet.c ****     assert(handle);
2661:../drivers/fsl_enet.c ****     uint32_t mask = kENET_RxFrameInterrupt | kENET_RxBufferInterrupt;
2662:../drivers/fsl_enet.c **** 
2663:../drivers/fsl_enet.c **** /* Check if the receive interrupt happen. */
2664:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2665:../drivers/fsl_enet.c ****     switch (ringId)
2666:../drivers/fsl_enet.c ****     {
2667:../drivers/fsl_enet.c ****         case kENET_Ring1:
2668:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame1Interrupt | kENET_RxBuffer1Interrupt);
2669:../drivers/fsl_enet.c ****             break;
2670:../drivers/fsl_enet.c ****         case kENET_Ring2:
2671:../drivers/fsl_enet.c ****             mask = (kENET_RxFrame2Interrupt | kENET_RxBuffer2Interrupt);
2672:../drivers/fsl_enet.c ****             break;
2673:../drivers/fsl_enet.c ****         default:
2674:../drivers/fsl_enet.c ****             break;
2675:../drivers/fsl_enet.c ****     }
2676:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2677:../drivers/fsl_enet.c **** 
2678:../drivers/fsl_enet.c ****     while (mask & base->EIR)
2679:../drivers/fsl_enet.c ****     {
2680:../drivers/fsl_enet.c ****         /* Clear the transmit interrupt event. */
2681:../drivers/fsl_enet.c ****         base->EIR = mask;
 100              		.loc 1 2681 0
 101 0006 4FF04077 		mov	r7, #50331648
 102              	.LVL5:
 103              	.L9:
2678:../drivers/fsl_enet.c ****     {
 104              		.loc 1 2678 0
 105 000a 6368     		ldr	r3, [r4, #4]
 106 000c 13F0407F 		tst	r3, #50331648
 107 0010 00D1     		bne	.L10
2682:../drivers/fsl_enet.c **** 
2683:../drivers/fsl_enet.c ****         /* Callback function. */
2684:../drivers/fsl_enet.c ****         if (handle->callback)
2685:../drivers/fsl_enet.c ****         {
2686:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2687:../drivers/fsl_enet.c ****             handle->callback(base, handle, ringId, kENET_RxEvent, handle->userData);
2688:../drivers/fsl_enet.c **** #else
2689:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_RxEvent, handle->userData);
2690:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2691:../drivers/fsl_enet.c ****         }
2692:../drivers/fsl_enet.c ****     }
2693:../drivers/fsl_enet.c **** }
 108              		.loc 1 2693 0
 109 0012 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 110              	.LVL6:
 111              	.L10:
2684:../drivers/fsl_enet.c ****         {
 112              		.loc 1 2684 0
 113 0014 EE69     		ldr	r6, [r5, #28]
2681:../drivers/fsl_enet.c **** 
 114              		.loc 1 2681 0
 115 0016 6760     		str	r7, [r4, #4]
2684:../drivers/fsl_enet.c ****         {
 116              		.loc 1 2684 0
 117 0018 002E     		cmp	r6, #0
 118 001a F6D0     		beq	.L9
2689:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 119              		.loc 1 2689 0
 120 001c 2B6A     		ldr	r3, [r5, #32]
 121 001e 0022     		movs	r2, #0
 122 0020 2946     		mov	r1, r5
 123 0022 2046     		mov	r0, r4
 124 0024 B047     		blx	r6
 125              	.LVL7:
 126 0026 F0E7     		b	.L9
 127              		.cfi_endproc
 128              	.LFE181:
 130              		.section	.text.ENET_ErrorIRQHandler,"ax",%progbits
 131              		.align	1
 132              		.global	ENET_ErrorIRQHandler
 133              		.syntax unified
 134              		.thumb
 135              		.thumb_func
 136              		.fpu fpv4-sp-d16
 138              	ENET_ErrorIRQHandler:
 139              	.LFB182:
2694:../drivers/fsl_enet.c **** 
2695:../drivers/fsl_enet.c **** void ENET_ErrorIRQHandler(ENET_Type *base, enet_handle_t *handle)
2696:../drivers/fsl_enet.c **** {
 140              		.loc 1 2696 0
 141              		.cfi_startproc
 142              		@ args = 0, pretend = 0, frame = 0
 143              		@ frame_needed = 0, uses_anonymous_args = 0
 144              	.LVL8:
 145 0000 38B5     		push	{r3, r4, r5, lr}
 146              		.cfi_def_cfa_offset 16
 147              		.cfi_offset 3, -16
 148              		.cfi_offset 4, -12
 149              		.cfi_offset 5, -8
 150              		.cfi_offset 14, -4
2697:../drivers/fsl_enet.c ****     assert(handle);
2698:../drivers/fsl_enet.c **** 
2699:../drivers/fsl_enet.c ****     uint32_t errMask = kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_Pa
2700:../drivers/fsl_enet.c ****                        kENET_LateCollisionInterrupt | kENET_RetryLimitInterrupt | kENET_UnderrunInt
2701:../drivers/fsl_enet.c **** 
2702:../drivers/fsl_enet.c ****     /* Check if the error interrupt happen. */
2703:../drivers/fsl_enet.c ****     if (kENET_WakeupInterrupt & base->EIR)
 151              		.loc 1 2703 0
 152 0002 4568     		ldr	r5, [r0, #4]
 153 0004 CC69     		ldr	r4, [r1, #28]
 154 0006 AD03     		lsls	r5, r5, #14
 155 0008 0DD5     		bpl	.L14
2704:../drivers/fsl_enet.c ****     {
2705:../drivers/fsl_enet.c ****         /* Clear the wakeup interrupt. */
2706:../drivers/fsl_enet.c ****         base->EIR = kENET_WakeupInterrupt;
 156              		.loc 1 2706 0
 157 000a 4FF40035 		mov	r5, #131072
 158 000e 4560     		str	r5, [r0, #4]
 159              	.LVL9:
 160              	.LBB42:
 161              	.LBB43:
 162              		.file 2 "../drivers/fsl_enet.h"
   1:../drivers/fsl_enet.h **** /*
   2:../drivers/fsl_enet.h ****  * The Clear BSD License
   3:../drivers/fsl_enet.h ****  * Copyright (c) 2015 - 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_enet.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_enet.h ****  * All rights reserved.
   6:../drivers/fsl_enet.h ****  *
   7:../drivers/fsl_enet.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_enet.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_enet.h ****  * that the following conditions are met:
  10:../drivers/fsl_enet.h ****  *
  11:../drivers/fsl_enet.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_enet.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_enet.h ****  *
  14:../drivers/fsl_enet.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_enet.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_enet.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_enet.h ****  *
  18:../drivers/fsl_enet.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_enet.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_enet.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_enet.h ****  *
  22:../drivers/fsl_enet.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_enet.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_enet.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_enet.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_enet.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_enet.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_enet.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_enet.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_enet.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_enet.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_enet.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_enet.h ****  */
  34:../drivers/fsl_enet.h **** #ifndef _FSL_ENET_H_
  35:../drivers/fsl_enet.h **** #define _FSL_ENET_H_
  36:../drivers/fsl_enet.h **** 
  37:../drivers/fsl_enet.h **** #include "fsl_common.h"
  38:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
  39:../drivers/fsl_enet.h **** #include "fsl_memory.h"
  40:../drivers/fsl_enet.h **** #endif
  41:../drivers/fsl_enet.h **** /*!
  42:../drivers/fsl_enet.h ****  * @addtogroup enet
  43:../drivers/fsl_enet.h ****  * @{
  44:../drivers/fsl_enet.h ****  */
  45:../drivers/fsl_enet.h **** 
  46:../drivers/fsl_enet.h **** /*******************************************************************************
  47:../drivers/fsl_enet.h ****  * Definitions
  48:../drivers/fsl_enet.h ****  ******************************************************************************/
  49:../drivers/fsl_enet.h **** 
  50:../drivers/fsl_enet.h **** /*! @name Driver version */
  51:../drivers/fsl_enet.h **** /*@{*/
  52:../drivers/fsl_enet.h **** /*! @brief Defines the driver version. */
  53:../drivers/fsl_enet.h **** #define FSL_ENET_DRIVER_VERSION (MAKE_VERSION(2, 2, 2)) /*!< Version 2.2.2. */
  54:../drivers/fsl_enet.h **** /*@}*/
  55:../drivers/fsl_enet.h **** 
  56:../drivers/fsl_enet.h **** /*! @name ENET DESCRIPTOR QUEUE */
  57:../drivers/fsl_enet.h **** /*@{*/
  58:../drivers/fsl_enet.h **** /*! @brief Defines the queue number. */
  59:../drivers/fsl_enet.h **** #ifndef FSL_FEATURE_ENET_QUEUE
  60:../drivers/fsl_enet.h **** #define FSL_FEATURE_ENET_QUEUE 1 /* Singal queue for previous IP. */
  61:../drivers/fsl_enet.h **** #endif
  62:../drivers/fsl_enet.h **** /*@}*/
  63:../drivers/fsl_enet.h **** 
  64:../drivers/fsl_enet.h **** /*! @name Control and status region bit masks of the receive buffer descriptor. */
  65:../drivers/fsl_enet.h **** /*@{*/
  66:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK 0x8000U       /*!< Empty bit mask. */
  67:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_SOFTOWNER1_MASK 0x4000U  /*!< Software owner one mask. */
  68:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_WRAP_MASK 0x2000U        /*!< Next buffer descriptor is the start ad
  69:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_SOFTOWNER2_Mask 0x1000U  /*!< Software owner two mask. */
  70:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_LAST_MASK 0x0800U        /*!< Last BD of the frame mask. */
  71:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_MISS_MASK 0x0100U        /*!< Received because of the promiscuous mo
  72:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_BROADCAST_MASK 0x0080U   /*!< Broadcast packet mask. */
  73:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_MULTICAST_MASK 0x0040U   /*!< Multicast packet mask. */
  74:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK 0x0020U /*!< Length violation mask. */
  75:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK 0x0010U     /*!< Non-octet aligned frame mask. */
  76:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_CRC_MASK 0x0004U         /*!< CRC error mask. */
  77:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK 0x0002U     /*!< FIFO overrun mask. */
  78:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK 0x0001U       /*!< Frame is truncated mask. */
  79:../drivers/fsl_enet.h **** /*@}*/
  80:../drivers/fsl_enet.h **** 
  81:../drivers/fsl_enet.h **** /*! @name Control and status bit masks of the transmit buffer descriptor. */
  82:../drivers/fsl_enet.h **** /*@{*/
  83:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_READY_MASK 0x8000U       /*!< Ready bit mask. */
  84:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_SOFTOWENER1_MASK 0x4000U /*!< Software owner one mask. */
  85:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_WRAP_MASK 0x2000U        /*!< Wrap buffer descriptor mask. */
  86:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_SOFTOWENER2_MASK 0x1000U /*!< Software owner two mask. */
  87:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_LAST_MASK 0x0800U        /*!< Last BD of the frame mask. */
  88:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_TRANMITCRC_MASK 0x0400U  /*!< Transmit CRC mask. */
  89:../drivers/fsl_enet.h **** /*@}*/
  90:../drivers/fsl_enet.h **** 
  91:../drivers/fsl_enet.h **** /* Extended control regions for enhanced buffer descriptors. */
  92:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
  93:../drivers/fsl_enet.h **** /*! @name First extended control region bit masks of the receive buffer descriptor. */
  94:../drivers/fsl_enet.h **** /*@{*/
  95:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_IPV4_MASK 0x0001U             /*!< Ipv4 frame mask. */
  96:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_IPV6_MASK 0x0002U             /*!< Ipv6 frame mask. */
  97:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_VLAN_MASK 0x0004U             /*!< VLAN frame mask. */
  98:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_PROTOCOLCHECKSUM_MASK 0x0010U /*!< Protocol checksum error mask. */
  99:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_IPHEADCHECKSUM_MASK 0x0020U   /*!< IP header checksum error mask. */
 100:../drivers/fsl_enet.h **** /*@}*/
 101:../drivers/fsl_enet.h **** 
 102:../drivers/fsl_enet.h **** /*! @name Second extended control region bit masks of the receive buffer descriptor. */
 103:../drivers/fsl_enet.h **** /*@{*/
 104:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_INTERRUPT_MASK 0x0080U /*!< BD interrupt mask. */
 105:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_UNICAST_MASK 0x0100U   /*!< Unicast frame mask. */
 106:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_COLLISION_MASK 0x0200U /*!< BD collision mask. */
 107:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK 0x0400U    /*!< PHY error mask. */
 108:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_MACERR_MASK 0x8000U    /*!< Mac error mask. */
 109:../drivers/fsl_enet.h **** /*@}*/
 110:../drivers/fsl_enet.h **** 
 111:../drivers/fsl_enet.h **** /*! @name First extended control region bit masks of the transmit buffer descriptor. */
 112:../drivers/fsl_enet.h **** /*@{*/
 113:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_ERR_MASK 0x8000U              /*!< Transmit error mask. */
 114:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_UNDERFLOWERR_MASK 0x2000U     /*!< Underflow error mask. */
 115:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_EXCCOLLISIONERR_MASK 0x1000U  /*!< Excess collision error mask. */
 116:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_FRAMEERR_MASK 0x0800U         /*!< Frame error mask. */
 117:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_LATECOLLISIONERR_MASK 0x0400U /*!< Late collision error mask. */
 118:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_OVERFLOWERR_MASK 0x0200U      /*!< Overflow error mask. */
 119:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_TIMESTAMPERR_MASK 0x0100U     /*!< Timestamp error mask. */
 120:../drivers/fsl_enet.h **** /*@}*/
 121:../drivers/fsl_enet.h **** 
 122:../drivers/fsl_enet.h **** /*! @name Second extended control region bit masks of the transmit buffer descriptor. */
 123:../drivers/fsl_enet.h **** /*@{*/
 124:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_INTERRUPT_MASK 0x4000U /*!< Interrupt mask. */
 125:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_TIMESTAMP_MASK 0x2000U /*!< Timestamp flag mask. */
 126:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 127:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_USETXLAUNCHTIME_MASK 0x0100U /*!< Use the transmit launch time. */
 128:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_FRAMETYPE_MASK 0x00F0U       /*!< Frame type mask. */
 129:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_TX_FRAMETYPE_SHIFT 4U           /*!< Frame type shift. */
 130:../drivers/fsl_enet.h **** #define ENET_BD_FTYPE(n) ((n << ENET_BUFFDESCRIPTOR_TX_FRAMETYPE_SHIFT) & ENET_BUFFDESCRIPTOR_TX_FR
 131:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 132:../drivers/fsl_enet.h **** /*@}*/
 133:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 134:../drivers/fsl_enet.h **** 
 135:../drivers/fsl_enet.h **** /*! @brief Defines the receive error status flag mask. */
 136:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_ERR_MASK                                        \
 137:../drivers/fsl_enet.h ****     (ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK | ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK | \
 138:../drivers/fsl_enet.h ****      ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK | ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK | ENET_BUFFDESCR
 139:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 140:../drivers/fsl_enet.h **** #define ENET_BUFFDESCRIPTOR_RX_EXT_ERR_MASK \
 141:../drivers/fsl_enet.h ****     (ENET_BUFFDESCRIPTOR_RX_MACERR_MASK | ENET_BUFFDESCRIPTOR_RX_PHYERR_MASK | ENET_BUFFDESCRIPTOR_
 142:../drivers/fsl_enet.h **** #endif
 143:../drivers/fsl_enet.h **** 
 144:../drivers/fsl_enet.h **** /*! @name Defines some Ethernet parameters. */
 145:../drivers/fsl_enet.h **** /*@{*/
 146:../drivers/fsl_enet.h **** #define ENET_FRAME_MAX_FRAMELEN 1518U /*!< Default maximum Ethernet frame size. */
 147:../drivers/fsl_enet.h **** 
 148:../drivers/fsl_enet.h **** #define ENET_FIFO_MIN_RX_FULL 5U    /*!< ENET minimum receive FIFO full. */
 149:../drivers/fsl_enet.h **** #define ENET_RX_MIN_BUFFERSIZE 256U /*!< ENET minimum buffer size. */
 150:../drivers/fsl_enet.h **** #define ENET_PHY_MAXADDRESS (ENET_MMFR_PA_MASK >> ENET_MMFR_PA_SHIFT)
 151:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 152:../drivers/fsl_enet.h **** #define ENET_TX_INTERRUPT                                                                          
 153:../drivers/fsl_enet.h ****     (kENET_TxFrameInterrupt | kENET_TxBufferInterrupt | kENET_TxFrame1Interrupt | kENET_TxBuffer1In
 154:../drivers/fsl_enet.h ****      kENET_TxFrame2Interrupt | kENET_TxBuffer2Interrupt)
 155:../drivers/fsl_enet.h **** #define ENET_RX_INTERRUPT                                                                          
 156:../drivers/fsl_enet.h ****     (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt | kENET_RxFrame1Interrupt | kENET_RxBuffer1In
 157:../drivers/fsl_enet.h ****      kENET_RxFrame2Interrupt | kENET_RxBuffer2Interrupt)
 158:../drivers/fsl_enet.h **** #else
 159:../drivers/fsl_enet.h **** #define ENET_TX_INTERRUPT (kENET_TxFrameInterrupt | kENET_TxBufferInterrupt)
 160:../drivers/fsl_enet.h **** #define ENET_RX_INTERRUPT (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt)
 161:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 162:../drivers/fsl_enet.h **** #define ENET_TS_INTERRUPT (kENET_TsTimerInterrupt | kENET_TsAvailInterrupt)
 163:../drivers/fsl_enet.h **** #define ENET_ERR_INTERRUPT                                                                         
 164:../drivers/fsl_enet.h ****     (kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_LateCollisionInterru
 165:../drivers/fsl_enet.h ****      kENET_RetryLimitInterrupt | kENET_UnderrunInterrupt | kENET_PayloadRxInterrupt)
 166:../drivers/fsl_enet.h **** #define ENET_ERR_INTERRUPT                                                                         
 167:../drivers/fsl_enet.h ****     (kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_LateCollisionInterru
 168:../drivers/fsl_enet.h ****      kENET_RetryLimitInterrupt | kENET_UnderrunInterrupt | kENET_PayloadRxInterrupt)
 169:../drivers/fsl_enet.h **** /*@}*/
 170:../drivers/fsl_enet.h **** 
 171:../drivers/fsl_enet.h **** /*! @brief Defines the status return codes for transaction. */
 172:../drivers/fsl_enet.h **** enum _enet_status
 173:../drivers/fsl_enet.h **** {
 174:../drivers/fsl_enet.h ****     kStatus_ENET_RxFrameError = MAKE_STATUS(kStatusGroup_ENET, 0U),   /*!< A frame received but dat
 175:../drivers/fsl_enet.h ****     kStatus_ENET_RxFrameFail = MAKE_STATUS(kStatusGroup_ENET, 1U),    /*!< Failed to receive a fram
 176:../drivers/fsl_enet.h ****     kStatus_ENET_RxFrameEmpty = MAKE_STATUS(kStatusGroup_ENET, 2U),   /*!< No frame arrive. */
 177:../drivers/fsl_enet.h ****     kStatus_ENET_TxFrameOverLen = MAKE_STATUS(kStatusGroup_ENET, 3U), /*!< Tx frame over length. */
 178:../drivers/fsl_enet.h ****     kStatus_ENET_TxFrameBusy = MAKE_STATUS(kStatusGroup_ENET, 4U),    /*!< Tx buffer descriptors ar
 179:../drivers/fsl_enet.h ****     kStatus_ENET_TxFrameFail = MAKE_STATUS(kStatusGroup_ENET, 5U)     /*!< Transmit frame fail. */
 180:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 181:../drivers/fsl_enet.h ****     ,
 182:../drivers/fsl_enet.h ****     kStatus_ENET_PtpTsRingFull = MAKE_STATUS(kStatusGroup_ENET, 6U), /*!< Timestamp ring full. */
 183:../drivers/fsl_enet.h ****     kStatus_ENET_PtpTsRingEmpty = MAKE_STATUS(kStatusGroup_ENET, 7U) /*!< Timestamp ring empty. */
 184:../drivers/fsl_enet.h **** #endif                                                               /* ENET_ENHANCEDBUFFERDESCRIPT
 185:../drivers/fsl_enet.h **** };
 186:../drivers/fsl_enet.h **** 
 187:../drivers/fsl_enet.h **** /*! @brief Defines the MII/RMII/RGMII mode for data interface between the MAC and the PHY. */
 188:../drivers/fsl_enet.h **** typedef enum _enet_mii_mode
 189:../drivers/fsl_enet.h **** {
 190:../drivers/fsl_enet.h ****     kENET_MiiMode = 0U,  /*!< MII mode for data interface. */
 191:../drivers/fsl_enet.h ****     kENET_RmiiMode = 1U, /*!< RMII mode for data interface. */
 192:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 193:../drivers/fsl_enet.h ****     kENET_RgmiiMode = 2U /*!< RGMII mode for data interface.  */
 194:../drivers/fsl_enet.h **** #endif                   /* FSL_FEATURE_ENET_HAS_AVB */
 195:../drivers/fsl_enet.h **** } enet_mii_mode_t;
 196:../drivers/fsl_enet.h **** 
 197:../drivers/fsl_enet.h **** /*! @brief Defines the 10/100/1000 Mbps speed for the MII data interface.
 198:../drivers/fsl_enet.h ****  *
 199:../drivers/fsl_enet.h ****  * Notice: "kENET_MiiSpeed1000M" only supported when mii mode is "kENET_RgmiiMode".
 200:../drivers/fsl_enet.h ****  */
 201:../drivers/fsl_enet.h **** typedef enum _enet_mii_speed
 202:../drivers/fsl_enet.h **** {
 203:../drivers/fsl_enet.h ****     kENET_MiiSpeed10M = 0U,  /*!< Speed 10 Mbps. */
 204:../drivers/fsl_enet.h ****     kENET_MiiSpeed100M = 1U, /*!< Speed 100 Mbps. */
 205:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 206:../drivers/fsl_enet.h ****     kENET_MiiSpeed1000M = 2U /*!< Speed 1000M bps. */
 207:../drivers/fsl_enet.h **** #endif                       /* FSL_FEATURE_ENET_HAS_AVB */
 208:../drivers/fsl_enet.h **** } enet_mii_speed_t;
 209:../drivers/fsl_enet.h **** 
 210:../drivers/fsl_enet.h **** /*! @brief Defines the half or full duplex for the MII data interface. */
 211:../drivers/fsl_enet.h **** typedef enum _enet_mii_duplex
 212:../drivers/fsl_enet.h **** {
 213:../drivers/fsl_enet.h ****     kENET_MiiHalfDuplex = 0U, /*!< Half duplex mode. */
 214:../drivers/fsl_enet.h ****     kENET_MiiFullDuplex       /*!< Full duplex mode. */
 215:../drivers/fsl_enet.h **** } enet_mii_duplex_t;
 216:../drivers/fsl_enet.h **** 
 217:../drivers/fsl_enet.h **** /*! @brief Define the MII opcode for normal MDIO_CLAUSES_22 Frame. */
 218:../drivers/fsl_enet.h **** typedef enum _enet_mii_write
 219:../drivers/fsl_enet.h **** {
 220:../drivers/fsl_enet.h ****     kENET_MiiWriteNoCompliant = 0U, /*!< Write frame operation, but not MII-compliant. */
 221:../drivers/fsl_enet.h ****     kENET_MiiWriteValidFrame        /*!< Write frame operation for a valid MII management frame. */
 222:../drivers/fsl_enet.h **** } enet_mii_write_t;
 223:../drivers/fsl_enet.h **** 
 224:../drivers/fsl_enet.h **** /*! @brief Defines the read operation for the MII management frame. */
 225:../drivers/fsl_enet.h **** typedef enum _enet_mii_read
 226:../drivers/fsl_enet.h **** {
 227:../drivers/fsl_enet.h ****     kENET_MiiReadValidFrame = 2U, /*!< Read frame operation for a valid MII management frame. */
 228:../drivers/fsl_enet.h ****     kENET_MiiReadNoCompliant = 3U /*!< Read frame operation, but not MII-compliant. */
 229:../drivers/fsl_enet.h **** } enet_mii_read_t;
 230:../drivers/fsl_enet.h **** 
 231:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
 232:../drivers/fsl_enet.h **** /*! @brief Define the MII opcode for extended MDIO_CLAUSES_45 Frame. */
 233:../drivers/fsl_enet.h **** typedef enum _enet_mii_extend_opcode
 234:../drivers/fsl_enet.h **** {
 235:../drivers/fsl_enet.h ****     kENET_MiiAddrWrite_C45 = 0U,  /*!< Address Write operation. */
 236:../drivers/fsl_enet.h ****     kENET_MiiWriteFrame_C45 = 1U, /*!< Write frame operation for a valid MII management frame. */
 237:../drivers/fsl_enet.h ****     kENET_MiiReadFrame_C45 = 3U   /*!< Read frame operation for a valid MII management frame. */
 238:../drivers/fsl_enet.h **** } enet_mii_extend_opcode;
 239:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */
 240:../drivers/fsl_enet.h **** 
 241:../drivers/fsl_enet.h **** /*! @brief Defines a special configuration for ENET MAC controller.
 242:../drivers/fsl_enet.h ****  *
 243:../drivers/fsl_enet.h ****  * These control flags are provided for special user requirements.
 244:../drivers/fsl_enet.h ****  * Normally, these control flags are unused for ENET initialization.
 245:../drivers/fsl_enet.h ****  * For special requirements, set the flags to
 246:../drivers/fsl_enet.h ****  * macSpecialConfig in the enet_config_t.
 247:../drivers/fsl_enet.h ****  * The kENET_ControlStoreAndFwdDisable is used to disable the FIFO store
 248:../drivers/fsl_enet.h ****  * and forward. FIFO store and forward means that the FIFO read/send is started
 249:../drivers/fsl_enet.h ****  * when a complete frame is stored in TX/RX FIFO. If this flag is set,
 250:../drivers/fsl_enet.h ****  * configure rxFifoFullThreshold and txFifoWatermark
 251:../drivers/fsl_enet.h ****  * in the enet_config_t.
 252:../drivers/fsl_enet.h ****  */
 253:../drivers/fsl_enet.h **** typedef enum _enet_special_control_flag
 254:../drivers/fsl_enet.h **** {
 255:../drivers/fsl_enet.h ****     kENET_ControlFlowControlEnable = 0x0001U,       /*!< Enable ENET flow control: pause frame. */
 256:../drivers/fsl_enet.h ****     kENET_ControlRxPayloadCheckEnable = 0x0002U,    /*!< Enable ENET receive payload length check. 
 257:../drivers/fsl_enet.h ****     kENET_ControlRxPadRemoveEnable = 0x0004U,       /*!< Padding is removed from received frames. *
 258:../drivers/fsl_enet.h ****     kENET_ControlRxBroadCastRejectEnable = 0x0008U, /*!< Enable broadcast frame reject. */
 259:../drivers/fsl_enet.h ****     kENET_ControlMacAddrInsert = 0x0010U,           /*!< Enable MAC address insert. */
 260:../drivers/fsl_enet.h ****     kENET_ControlStoreAndFwdDisable = 0x0020U,      /*!< Enable FIFO store and forward. */
 261:../drivers/fsl_enet.h ****     kENET_ControlSMIPreambleDisable = 0x0040U,      /*!< Enable SMI preamble. */
 262:../drivers/fsl_enet.h ****     kENET_ControlPromiscuousEnable = 0x0080U,       /*!< Enable promiscuous mode. */
 263:../drivers/fsl_enet.h ****     kENET_ControlMIILoopEnable = 0x0100U,           /*!< Enable ENET MII loop back. */
 264:../drivers/fsl_enet.h ****     kENET_ControlVLANTagEnable = 0x0200U,           /*!< Enable normal VLAN (single vlan tag). */
 265:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 266:../drivers/fsl_enet.h ****     kENET_ControlSVLANEnable = 0x0400U,     /*!< Enable S-VLAN. */
 267:../drivers/fsl_enet.h ****     kENET_ControlVLANUseSecondTag = 0x0800U /*!< Enable extracting the second vlan tag for further 
 268:../drivers/fsl_enet.h **** #endif                                      /* FSL_FEATURE_ENET_HAS_AVB */
 269:../drivers/fsl_enet.h **** } enet_special_control_flag_t;
 270:../drivers/fsl_enet.h **** 
 271:../drivers/fsl_enet.h **** /*! @brief List of interrupts supported by the peripheral. This
 272:../drivers/fsl_enet.h ****  * enumeration uses one-bot encoding to allow a logical OR of multiple
 273:../drivers/fsl_enet.h ****  * members. Members usually map to interrupt enable bits in one or more
 274:../drivers/fsl_enet.h ****  * peripheral registers.
 275:../drivers/fsl_enet.h ****  */
 276:../drivers/fsl_enet.h **** typedef enum _enet_interrupt_enable
 277:../drivers/fsl_enet.h **** {
 278:../drivers/fsl_enet.h ****     kENET_BabrInterrupt = ENET_EIR_BABR_MASK,        /*!< Babbling receive error interrupt source *
 279:../drivers/fsl_enet.h ****     kENET_BabtInterrupt = ENET_EIR_BABT_MASK,        /*!< Babbling transmit error interrupt source 
 280:../drivers/fsl_enet.h ****     kENET_GraceStopInterrupt = ENET_EIR_GRA_MASK,    /*!< Graceful stop complete interrupt source *
 281:../drivers/fsl_enet.h ****     kENET_TxFrameInterrupt = ENET_EIR_TXF_MASK,      /*!< TX FRAME interrupt source */
 282:../drivers/fsl_enet.h ****     kENET_TxBufferInterrupt = ENET_EIR_TXB_MASK,     /*!< TX BUFFER interrupt source */
 283:../drivers/fsl_enet.h ****     kENET_RxFrameInterrupt = ENET_EIR_RXF_MASK,      /*!< RX FRAME interrupt source */
 284:../drivers/fsl_enet.h ****     kENET_RxBufferInterrupt = ENET_EIR_RXB_MASK,     /*!< RX BUFFER interrupt source */
 285:../drivers/fsl_enet.h ****     kENET_MiiInterrupt = ENET_EIR_MII_MASK,          /*!< MII interrupt source */
 286:../drivers/fsl_enet.h ****     kENET_EBusERInterrupt = ENET_EIR_EBERR_MASK,     /*!< Ethernet bus error interrupt source */
 287:../drivers/fsl_enet.h ****     kENET_LateCollisionInterrupt = ENET_EIR_LC_MASK, /*!< Late collision interrupt source */
 288:../drivers/fsl_enet.h ****     kENET_RetryLimitInterrupt = ENET_EIR_RL_MASK,    /*!< Collision Retry Limit interrupt source */
 289:../drivers/fsl_enet.h ****     kENET_UnderrunInterrupt = ENET_EIR_UN_MASK,      /*!< Transmit FIFO underrun interrupt source *
 290:../drivers/fsl_enet.h ****     kENET_PayloadRxInterrupt = ENET_EIR_PLR_MASK,    /*!< Payload Receive error interrupt source */
 291:../drivers/fsl_enet.h ****     kENET_WakeupInterrupt = ENET_EIR_WAKEUP_MASK,    /*!< WAKEUP interrupt source */
 292:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 293:../drivers/fsl_enet.h ****     kENET_RxFlush2Interrupt = ENET_EIR_RXFLUSH_2_MASK, /*!< Rx DMA ring2 flush indication. */
 294:../drivers/fsl_enet.h ****     kENET_RxFlush1Interrupt = ENET_EIR_RXFLUSH_1_MASK, /*!< Rx DMA ring1 flush indication. */
 295:../drivers/fsl_enet.h ****     kENET_RxFlush0Interrupt = ENET_EIR_RXFLUSH_0_MASK, /*!< RX DMA ring0 flush indication. */
 296:../drivers/fsl_enet.h ****     kENET_TxFrame2Interrupt = ENET_EIR_TXF2_MASK,      /*!< Tx frame interrupt for Tx ring/class 2.
 297:../drivers/fsl_enet.h ****     kENET_TxBuffer2Interrupt = ENET_EIR_TXB2_MASK,     /*!< Tx buffer interrupt for Tx ring/class 2
 298:../drivers/fsl_enet.h ****     kENET_RxFrame2Interrupt = ENET_EIR_RXF2_MASK,      /*!< Rx frame interrupt for Rx ring/class 2.
 299:../drivers/fsl_enet.h ****     kENET_RxBuffer2Interrupt = ENET_EIR_RXB2_MASK,     /*!< Rx buffer interrupt for Rx ring/class 2
 300:../drivers/fsl_enet.h ****     kENET_TxFrame1Interrupt = ENET_EIR_TXF1_MASK,      /*!< Tx frame interrupt for Tx ring/class 1.
 301:../drivers/fsl_enet.h ****     kENET_TxBuffer1Interrupt = ENET_EIR_TXB1_MASK,     /*!< Tx buffer interrupt for Tx ring/class 1
 302:../drivers/fsl_enet.h ****     kENET_RxFrame1Interrupt = ENET_EIR_RXF1_MASK,      /*!< Rx frame interrupt for Rx ring/class 1.
 303:../drivers/fsl_enet.h ****     kENET_RxBuffer1Interrupt = ENET_EIR_RXB1_MASK,     /*!< Rx buffer interrupt for Rx ring/class 1
 304:../drivers/fsl_enet.h **** #endif                                                 /* FSL_FEATURE_ENET_QUEUE > 1 */
 305:../drivers/fsl_enet.h ****     kENET_TsAvailInterrupt = ENET_EIR_TS_AVAIL_MASK,   /*!< TS AVAIL interrupt source for PTP */
 306:../drivers/fsl_enet.h ****     kENET_TsTimerInterrupt = ENET_EIR_TS_TIMER_MASK    /*!< TS WRAP interrupt source for PTP */
 307:../drivers/fsl_enet.h **** } enet_interrupt_enable_t;
 308:../drivers/fsl_enet.h **** 
 309:../drivers/fsl_enet.h **** /*! @brief Defines the common interrupt event for callback use. */
 310:../drivers/fsl_enet.h **** typedef enum _enet_event
 311:../drivers/fsl_enet.h **** {
 312:../drivers/fsl_enet.h ****     kENET_RxEvent,            /*!< Receive event. */
 313:../drivers/fsl_enet.h ****     kENET_TxEvent,            /*!< Transmit event. */
 314:../drivers/fsl_enet.h ****     kENET_ErrEvent,           /*!< Error event: BABR/BABT/EBERR/LC/RL/UN/PLR . */
 315:../drivers/fsl_enet.h ****     kENET_WakeUpEvent,        /*!< Wake up from sleep mode event. */
 316:../drivers/fsl_enet.h ****     kENET_TimeStampEvent,     /*!< Time stamp event. */
 317:../drivers/fsl_enet.h ****     kENET_TimeStampAvailEvent /*!< Time stamp available event.*/
 318:../drivers/fsl_enet.h **** } enet_event_t;
 319:../drivers/fsl_enet.h **** 
 320:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 321:../drivers/fsl_enet.h **** /*! @brief Defines certain idle slope for bandwidth fraction. */
 322:../drivers/fsl_enet.h **** typedef enum _enet_idle_slope
 323:../drivers/fsl_enet.h **** {
 324:../drivers/fsl_enet.h ****     kENET_IdleSlope1 = 1U,       /*!< The bandwidth fraction is about 0.002. */
 325:../drivers/fsl_enet.h ****     kENET_IdleSlope2 = 2U,       /*!< The bandwidth fraction is about 0.003. */
 326:../drivers/fsl_enet.h ****     kENET_IdleSlope4 = 4U,       /*!< The bandwidth fraction is about 0.008. */
 327:../drivers/fsl_enet.h ****     kENET_IdleSlope8 = 8U,       /*!< The bandwidth fraction is about 0.02. */
 328:../drivers/fsl_enet.h ****     kENET_IdleSlope16 = 16U,     /*!< The bandwidth fraction is about 0.03. */
 329:../drivers/fsl_enet.h ****     kENET_IdleSlope32 = 32U,     /*!< The bandwidth fraction is about 0.06. */
 330:../drivers/fsl_enet.h ****     kENET_IdleSlope64 = 64U,     /*!< The bandwidth fraction is about 0.11. */
 331:../drivers/fsl_enet.h ****     kENET_IdleSlope128 = 128U,   /*!< The bandwidth fraction is about 0.20. */
 332:../drivers/fsl_enet.h ****     kENET_IdleSlope256 = 256U,   /*!< The bandwidth fraction is about 0.33. */
 333:../drivers/fsl_enet.h ****     kENET_IdleSlope384 = 384U,   /*!< The bandwidth fraction is about 0.43. */
 334:../drivers/fsl_enet.h ****     kENET_IdleSlope512 = 512U,   /*!< The bandwidth fraction is about 0.50. */
 335:../drivers/fsl_enet.h ****     kENET_IdleSlope640 = 640U,   /*!< The bandwidth fraction is about 0.56. */
 336:../drivers/fsl_enet.h ****     kENET_IdleSlope768 = 768U,   /*!< The bandwidth fraction is about 0.60. */
 337:../drivers/fsl_enet.h ****     kENET_IdleSlope896 = 896U,   /*!< The bandwidth fraction is about 0.64. */
 338:../drivers/fsl_enet.h ****     kENET_IdleSlope1024 = 1024U, /*!< The bandwidth fraction is about 0.67. */
 339:../drivers/fsl_enet.h ****     kENET_IdleSlope1152 = 1152U, /*!< The bandwidth fraction is about 0.69. */
 340:../drivers/fsl_enet.h ****     kENET_IdleSlope1280 = 1280U, /*!< The bandwidth fraction is about 0.71. */
 341:../drivers/fsl_enet.h ****     kENET_IdleSlope1408 = 1408U, /*!< The bandwidth fraction is about 0.73. */
 342:../drivers/fsl_enet.h ****     kENET_IdleSlope1536 = 1536U  /*!< The bandwidth fraction is about 0.75. */
 343:../drivers/fsl_enet.h **** } enet_idle_slope_t;
 344:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 345:../drivers/fsl_enet.h **** 
 346:../drivers/fsl_enet.h **** /*! @brief Defines the transmit accelerator configuration. */
 347:../drivers/fsl_enet.h **** typedef enum _enet_tx_accelerator
 348:../drivers/fsl_enet.h **** {
 349:../drivers/fsl_enet.h ****     kENET_TxAccelIsShift16Enabled = ENET_TACC_SHIFT16_MASK, /*!< Transmit FIFO shift-16. */
 350:../drivers/fsl_enet.h ****     kENET_TxAccelIpCheckEnabled = ENET_TACC_IPCHK_MASK,     /*!< Insert IP header checksum. */
 351:../drivers/fsl_enet.h ****     kENET_TxAccelProtoCheckEnabled = ENET_TACC_PROCHK_MASK  /*!< Insert protocol checksum. */
 352:../drivers/fsl_enet.h **** } enet_tx_accelerator_t;
 353:../drivers/fsl_enet.h **** 
 354:../drivers/fsl_enet.h **** /*! @brief Defines the receive accelerator configuration. */
 355:../drivers/fsl_enet.h **** typedef enum _enet_rx_accelerator
 356:../drivers/fsl_enet.h **** {
 357:../drivers/fsl_enet.h ****     kENET_RxAccelPadRemoveEnabled = ENET_RACC_PADREM_MASK,  /*!< Padding removal for short IP frame
 358:../drivers/fsl_enet.h ****     kENET_RxAccelIpCheckEnabled = ENET_RACC_IPDIS_MASK,     /*!< Discard with wrong IP header check
 359:../drivers/fsl_enet.h ****     kENET_RxAccelProtoCheckEnabled = ENET_RACC_PRODIS_MASK, /*!< Discard with wrong protocol checks
 360:../drivers/fsl_enet.h ****     kENET_RxAccelMacCheckEnabled = ENET_RACC_LINEDIS_MASK,  /*!< Discard with Mac layer errors. */
 361:../drivers/fsl_enet.h ****     kENET_RxAccelisShift16Enabled = ENET_RACC_SHIFT16_MASK  /*!< Receive FIFO shift-16. */
 362:../drivers/fsl_enet.h **** } enet_rx_accelerator_t;
 363:../drivers/fsl_enet.h **** 
 364:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 365:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP message related constant. */
 366:../drivers/fsl_enet.h **** typedef enum _enet_ptp_event_type
 367:../drivers/fsl_enet.h **** {
 368:../drivers/fsl_enet.h ****     kENET_PtpEventMsgType = 3U,  /*!< PTP event message type. */
 369:../drivers/fsl_enet.h ****     kENET_PtpSrcPortIdLen = 10U, /*!< PTP message sequence id length. */
 370:../drivers/fsl_enet.h ****     kENET_PtpEventPort = 319U,   /*!< PTP event port number. */
 371:../drivers/fsl_enet.h ****     kENET_PtpGnrlPort = 320U     /*!< PTP general port number. */
 372:../drivers/fsl_enet.h **** } enet_ptp_event_type_t;
 373:../drivers/fsl_enet.h **** 
 374:../drivers/fsl_enet.h **** /*! @brief Defines the IEEE 1588 PTP timer channel numbers. */
 375:../drivers/fsl_enet.h **** typedef enum _enet_ptp_timer_channel
 376:../drivers/fsl_enet.h **** {
 377:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel1 = 0U, /*!< IEEE 1588 PTP timer Channel 1. */
 378:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel2,      /*!< IEEE 1588 PTP timer Channel 2. */
 379:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel3,      /*!< IEEE 1588 PTP timer Channel 3. */
 380:../drivers/fsl_enet.h ****     kENET_PtpTimerChannel4       /*!< IEEE 1588 PTP timer Channel 4. */
 381:../drivers/fsl_enet.h **** } enet_ptp_timer_channel_t;
 382:../drivers/fsl_enet.h **** 
 383:../drivers/fsl_enet.h **** /*! @brief Defines the capture or compare mode for IEEE 1588 PTP timer channels. */
 384:../drivers/fsl_enet.h **** typedef enum _enet_ptp_timer_channel_mode
 385:../drivers/fsl_enet.h **** {
 386:../drivers/fsl_enet.h ****     kENET_PtpChannelDisable = 0U,                  /*!< Disable timer channel. */
 387:../drivers/fsl_enet.h ****     kENET_PtpChannelRisingCapture = 1U,            /*!< Input capture on rising edge. */
 388:../drivers/fsl_enet.h ****     kENET_PtpChannelFallingCapture = 2U,           /*!< Input capture on falling edge. */
 389:../drivers/fsl_enet.h ****     kENET_PtpChannelBothCapture = 3U,              /*!< Input capture on both edges. */
 390:../drivers/fsl_enet.h ****     kENET_PtpChannelSoftCompare = 4U,              /*!< Output compare software only. */
 391:../drivers/fsl_enet.h ****     kENET_PtpChannelToggleCompare = 5U,            /*!< Toggle output on compare. */
 392:../drivers/fsl_enet.h ****     kENET_PtpChannelClearCompare = 6U,             /*!< Clear output on compare. */
 393:../drivers/fsl_enet.h ****     kENET_PtpChannelSetCompare = 7U,               /*!< Set output on compare. */
 394:../drivers/fsl_enet.h ****     kENET_PtpChannelClearCompareSetOverflow = 10U, /*!< Clear output on compare, set output on over
 395:../drivers/fsl_enet.h ****     kENET_PtpChannelSetCompareClearOverflow = 11U, /*!< Set output on compare, clear output on over
 396:../drivers/fsl_enet.h ****     kENET_PtpChannelPulseLowonCompare = 14U,       /*!< Pulse output low on compare for one IEEE 15
 397:../drivers/fsl_enet.h ****     kENET_PtpChannelPulseHighonCompare = 15U       /*!< Pulse output high on compare for one IEEE 1
 398:../drivers/fsl_enet.h **** } enet_ptp_timer_channel_mode_t;
 399:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 400:../drivers/fsl_enet.h **** 
 401:../drivers/fsl_enet.h **** /*! @brief Defines the receive buffer descriptor structure for the little endian system.*/
 402:../drivers/fsl_enet.h **** typedef struct _enet_rx_bd_struct
 403:../drivers/fsl_enet.h **** {
 404:../drivers/fsl_enet.h ****     uint16_t length;  /*!< Buffer descriptor data length. */
 405:../drivers/fsl_enet.h ****     uint16_t control; /*!< Buffer descriptor control and status. */
 406:../drivers/fsl_enet.h ****     uint8_t *buffer;  /*!< Data buffer pointer. */
 407:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 408:../drivers/fsl_enet.h ****     uint16_t controlExtend0;  /*!< Extend buffer descriptor control0. */
 409:../drivers/fsl_enet.h ****     uint16_t controlExtend1;  /*!< Extend buffer descriptor control1. */
 410:../drivers/fsl_enet.h ****     uint16_t payloadCheckSum; /*!< Internal payload checksum. */
 411:../drivers/fsl_enet.h ****     uint8_t headerLength;     /*!< Header length. */
 412:../drivers/fsl_enet.h ****     uint8_t protocolTyte;     /*!< Protocol type. */
 413:../drivers/fsl_enet.h ****     uint16_t reserved0;
 414:../drivers/fsl_enet.h ****     uint16_t controlExtend2; /*!< Extend buffer descriptor control2. */
 415:../drivers/fsl_enet.h ****     uint32_t timestamp;      /*!< Timestamp. */
 416:../drivers/fsl_enet.h ****     uint16_t reserved1;
 417:../drivers/fsl_enet.h ****     uint16_t reserved2;
 418:../drivers/fsl_enet.h ****     uint16_t reserved3;
 419:../drivers/fsl_enet.h ****     uint16_t reserved4;
 420:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 421:../drivers/fsl_enet.h **** } enet_rx_bd_struct_t;
 422:../drivers/fsl_enet.h **** 
 423:../drivers/fsl_enet.h **** /*! @brief Defines the enhanced transmit buffer descriptor structure for the little endian system. 
 424:../drivers/fsl_enet.h **** typedef struct _enet_tx_bd_struct
 425:../drivers/fsl_enet.h **** {
 426:../drivers/fsl_enet.h ****     uint16_t length;  /*!< Buffer descriptor data length. */
 427:../drivers/fsl_enet.h ****     uint16_t control; /*!< Buffer descriptor control and status. */
 428:../drivers/fsl_enet.h ****     uint8_t *buffer;  /*!< Data buffer pointer. */
 429:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 430:../drivers/fsl_enet.h ****     uint16_t controlExtend0; /*!< Extend buffer descriptor control0. */
 431:../drivers/fsl_enet.h ****     uint16_t controlExtend1; /*!< Extend buffer descriptor control1. */
 432:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 433:../drivers/fsl_enet.h ****     int8_t *txLaunchTime; /*!< Transmit launch time. */
 434:../drivers/fsl_enet.h **** #else
 435:../drivers/fsl_enet.h ****     uint16_t reserved0;
 436:../drivers/fsl_enet.h ****     uint16_t reserved1;
 437:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 438:../drivers/fsl_enet.h ****     uint16_t reserved2;
 439:../drivers/fsl_enet.h ****     uint16_t controlExtend2; /*!< Extend buffer descriptor control2. */
 440:../drivers/fsl_enet.h ****     uint32_t timestamp;      /*!< Timestamp. */
 441:../drivers/fsl_enet.h ****     uint16_t reserved3;
 442:../drivers/fsl_enet.h ****     uint16_t reserved4;
 443:../drivers/fsl_enet.h ****     uint16_t reserved5;
 444:../drivers/fsl_enet.h ****     uint16_t reserved6;
 445:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 446:../drivers/fsl_enet.h **** } enet_tx_bd_struct_t;
 447:../drivers/fsl_enet.h **** 
 448:../drivers/fsl_enet.h **** /*! @brief Defines the ENET data error statistic structure. */
 449:../drivers/fsl_enet.h **** typedef struct _enet_data_error_stats
 450:../drivers/fsl_enet.h **** {
 451:../drivers/fsl_enet.h ****     uint32_t statsRxLenGreaterErr; /*!< Receive length greater than RCR[MAX_FL]. */
 452:../drivers/fsl_enet.h ****     uint32_t statsRxAlignErr;      /*!< Receive non-octet alignment/ */
 453:../drivers/fsl_enet.h ****     uint32_t statsRxFcsErr;        /*!< Receive CRC error. */
 454:../drivers/fsl_enet.h ****     uint32_t statsRxOverRunErr;    /*!< Receive over run. */
 455:../drivers/fsl_enet.h ****     uint32_t statsRxTruncateErr;   /*!< Receive truncate. */
 456:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 457:../drivers/fsl_enet.h ****     uint32_t statsRxProtocolChecksumErr; /*!< Receive protocol checksum error. */
 458:../drivers/fsl_enet.h ****     uint32_t statsRxIpHeadChecksumErr;   /*!< Receive IP header checksum error. */
 459:../drivers/fsl_enet.h ****     uint32_t statsRxMacErr;              /*!< Receive Mac error. */
 460:../drivers/fsl_enet.h ****     uint32_t statsRxPhyErr;              /*!< Receive PHY error. */
 461:../drivers/fsl_enet.h ****     uint32_t statsRxCollisionErr;        /*!< Receive collision. */
 462:../drivers/fsl_enet.h ****     uint32_t statsTxErr;                 /*!< The error happen when transmit the frame. */
 463:../drivers/fsl_enet.h ****     uint32_t statsTxFrameErr;            /*!< The transmit frame is error. */
 464:../drivers/fsl_enet.h ****     uint32_t statsTxOverFlowErr;         /*!< Transmit overflow. */
 465:../drivers/fsl_enet.h ****     uint32_t statsTxLateCollisionErr;    /*!< Transmit late collision. */
 466:../drivers/fsl_enet.h ****     uint32_t statsTxExcessCollisionErr;  /*!< Transmit excess collision.*/
 467:../drivers/fsl_enet.h ****     uint32_t statsTxUnderFlowErr;        /*!< Transmit under flow error. */
 468:../drivers/fsl_enet.h ****     uint32_t statsTxTsErr;               /*!< Transmit time stamp error. */
 469:../drivers/fsl_enet.h **** #endif                                   /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 470:../drivers/fsl_enet.h **** } enet_data_error_stats_t;
 471:../drivers/fsl_enet.h **** 
 472:../drivers/fsl_enet.h **** /*! @brief Defines the receive buffer descriptor configuration structure.
 473:../drivers/fsl_enet.h ****  *
 474:../drivers/fsl_enet.h ****  * Note that for the internal DMA requirements, the buffers have a corresponding alignment requirem
 475:../drivers/fsl_enet.h ****  * 1. The aligned receive and transmit buffer size must be evenly divisible by ENET_BUFF_ALIGNMENT.
 476:../drivers/fsl_enet.h ****  *    when the data buffers are in cacheable region when cache is enabled, all those size should be
 477:../drivers/fsl_enet.h ****  *    aligned to the maximum value of "ENET_BUFF_ALIGNMENT" and the cache line size.
 478:../drivers/fsl_enet.h ****  * 2. The aligned transmit and receive buffer descriptor start address must be at
 479:../drivers/fsl_enet.h ****  *    least 64 bit aligned. However, it's recommended to be evenly divisible by ENET_BUFF_ALIGNMENT
 480:../drivers/fsl_enet.h ****  *    buffer descriptors should be put in non-cacheable region when cache is enabled.
 481:../drivers/fsl_enet.h ****  * 3. The aligned transmit and receive data buffer start address must be evenly divisible by ENET_B
 482:../drivers/fsl_enet.h ****  *    Receive buffers should be continuous with the total size equal to "rxBdNumber * rxBuffSizeAli
 483:../drivers/fsl_enet.h ****  *    Transmit buffers should be continuous with the total size equal to "txBdNumber * txBuffSizeAl
 484:../drivers/fsl_enet.h ****  *    when the data buffers are in cacheable region when cache is enabled, all those size should be
 485:../drivers/fsl_enet.h ****  *    aligned to the maximum value of "ENET_BUFF_ALIGNMENT" and the cache line size.
 486:../drivers/fsl_enet.h ****  */
 487:../drivers/fsl_enet.h **** typedef struct _enet_buffer_config
 488:../drivers/fsl_enet.h **** {
 489:../drivers/fsl_enet.h ****     uint16_t rxBdNumber;      /*!< Receive buffer descriptor number. */
 490:../drivers/fsl_enet.h ****     uint16_t txBdNumber;      /*!< Transmit buffer descriptor number. */
 491:../drivers/fsl_enet.h ****     uint32_t rxBuffSizeAlign; /*!< Aligned receive data buffer size. */
 492:../drivers/fsl_enet.h ****     uint32_t txBuffSizeAlign; /*!< Aligned transmit data buffer size. */
 493:../drivers/fsl_enet.h ****     volatile enet_rx_bd_struct_t
 494:../drivers/fsl_enet.h ****         *rxBdStartAddrAlign; /*!< Aligned receive buffer descriptor start address: should be non-ca
 495:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 496:../drivers/fsl_enet.h ****         *txBdStartAddrAlign; /*!< Aligned transmit buffer descriptor start address: should be non-c
 497:../drivers/fsl_enet.h ****     uint8_t *rxBufferAlign;  /*!< Receive data buffer start address. */
 498:../drivers/fsl_enet.h ****     uint8_t *txBufferAlign;  /*!< Transmit data buffer start address. */
 499:../drivers/fsl_enet.h **** } enet_buffer_config_t;
 500:../drivers/fsl_enet.h **** 
 501:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 502:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP time stamp structure. */
 503:../drivers/fsl_enet.h **** typedef struct _enet_ptp_time
 504:../drivers/fsl_enet.h **** {
 505:../drivers/fsl_enet.h ****     uint64_t second;     /*!< Second. */
 506:../drivers/fsl_enet.h ****     uint32_t nanosecond; /*!< Nanosecond. */
 507:../drivers/fsl_enet.h **** } enet_ptp_time_t;
 508:../drivers/fsl_enet.h **** 
 509:../drivers/fsl_enet.h **** /*! @brief Defines the structure for the ENET PTP message data and timestamp data.*/
 510:../drivers/fsl_enet.h **** typedef struct _enet_ptp_time_data
 511:../drivers/fsl_enet.h **** {
 512:../drivers/fsl_enet.h ****     uint8_t version;                             /*!< PTP version. */
 513:../drivers/fsl_enet.h ****     uint8_t sourcePortId[kENET_PtpSrcPortIdLen]; /*!< PTP source port ID. */
 514:../drivers/fsl_enet.h ****     uint16_t sequenceId;                         /*!< PTP sequence ID. */
 515:../drivers/fsl_enet.h ****     uint8_t messageType;                         /*!< PTP message type. */
 516:../drivers/fsl_enet.h ****     enet_ptp_time_t timeStamp;                   /*!< PTP timestamp. */
 517:../drivers/fsl_enet.h **** } enet_ptp_time_data_t;
 518:../drivers/fsl_enet.h **** 
 519:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP ring buffer structure for the PTP message timestamp store.*/
 520:../drivers/fsl_enet.h **** typedef struct _enet_ptp_time_data_ring
 521:../drivers/fsl_enet.h **** {
 522:../drivers/fsl_enet.h ****     uint32_t front;                  /*!< The first index of the ring. */
 523:../drivers/fsl_enet.h ****     uint32_t end;                    /*!< The end index of the ring. */
 524:../drivers/fsl_enet.h ****     uint32_t size;                   /*!< The size of the ring. */
 525:../drivers/fsl_enet.h ****     enet_ptp_time_data_t *ptpTsData; /*!< PTP message data structure. */
 526:../drivers/fsl_enet.h **** } enet_ptp_time_data_ring_t;
 527:../drivers/fsl_enet.h **** 
 528:../drivers/fsl_enet.h **** /*! @brief Defines the ENET PTP configuration structure. */
 529:../drivers/fsl_enet.h **** typedef struct _enet_ptp_config
 530:../drivers/fsl_enet.h **** {
 531:../drivers/fsl_enet.h ****     uint8_t ptpTsRxBuffNum;            /*!< Receive 1588 timestamp buffer number*/
 532:../drivers/fsl_enet.h ****     uint8_t ptpTsTxBuffNum;            /*!< Transmit 1588 timestamp buffer number*/
 533:../drivers/fsl_enet.h ****     enet_ptp_time_data_t *rxPtpTsData; /*!< The start address of 1588 receive timestamp buffers */
 534:../drivers/fsl_enet.h ****     enet_ptp_time_data_t *txPtpTsData; /*!< The start address of 1588 transmit timestamp buffers */
 535:../drivers/fsl_enet.h ****     enet_ptp_timer_channel_t channel;  /*!< Used for ERRATA_2579: the PTP 1588 timer channel for ti
 536:../drivers/fsl_enet.h ****     uint32_t ptp1588ClockSrc_Hz;       /*!< The clock source of the PTP 1588 timer. */
 537:../drivers/fsl_enet.h **** } enet_ptp_config_t;
 538:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 539:../drivers/fsl_enet.h **** 
 540:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
 541:../drivers/fsl_enet.h **** /*! @brief Defines the interrupt coalescing configure structure. */
 542:../drivers/fsl_enet.h **** typedef struct _enet_intcoalesce_config
 543:../drivers/fsl_enet.h **** {
 544:../drivers/fsl_enet.h ****     uint8_t txCoalesceFrameCount[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit interrupt coalescing frame 
 545:../drivers/fsl_enet.h ****     uint16_t txCoalesceTimeCount[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit interrupt coalescing timer 
 546:../drivers/fsl_enet.h ****     uint8_t rxCoalesceFrameCount[FSL_FEATURE_ENET_QUEUE]; /*!< Receive interrupt coalescing frame c
 547:../drivers/fsl_enet.h ****     uint16_t rxCoalesceTimeCount[FSL_FEATURE_ENET_QUEUE]; /*!< Receive interrupt coalescing timer c
 548:../drivers/fsl_enet.h **** } enet_intcoalesce_config_t;
 549:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
 550:../drivers/fsl_enet.h **** 
 551:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 552:../drivers/fsl_enet.h **** /*! @brief Defines the ENET AVB Configure structure.
 553:../drivers/fsl_enet.h ****  *
 554:../drivers/fsl_enet.h ****  * This is used for to configure the extended ring 1 and ring 2.
 555:../drivers/fsl_enet.h ****  * 1. The classification match format is (CMP3 << 12) | (CMP2 << 8) | (CMP1 << 4) | CMP0.
 556:../drivers/fsl_enet.h ****  * composed of four 3-bit compared VLAN priority field cmp0~cmp3, cm0 ~ cmp3 are used in parallel.
 557:../drivers/fsl_enet.h ****  *
 558:../drivers/fsl_enet.h ****  * If CMP1,2,3 are not unused, please set them to the same value as CMP0.
 559:../drivers/fsl_enet.h ****  * 2. The idleSlope is used to calculate the Band Width fraction, BW fraction = 1 / (1 + 512/idleSl
 560:../drivers/fsl_enet.h ****  * For avb configuration, the BW fraction of Class 1 and Class 2 combined must not exceed 0.75.
 561:../drivers/fsl_enet.h ****  */
 562:../drivers/fsl_enet.h **** typedef struct _enet_avb_config
 563:../drivers/fsl_enet.h **** {
 564:../drivers/fsl_enet.h ****     uint16_t rxClassifyMatch[FSL_FEATURE_ENET_QUEUE - 1];    /*!< The classification match value fo
 565:../drivers/fsl_enet.h ****     enet_idle_slope_t idleSlope[FSL_FEATURE_ENET_QUEUE - 1]; /*!< The idle slope for certian bandwi
 566:../drivers/fsl_enet.h **** } enet_avb_config_t;
 567:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 568:../drivers/fsl_enet.h **** 
 569:../drivers/fsl_enet.h **** /*! @brief Defines the basic configuration structure for the ENET device.
 570:../drivers/fsl_enet.h ****  *
 571:../drivers/fsl_enet.h ****  * Note:
 572:../drivers/fsl_enet.h ****  *  1. macSpecialConfig is used for a special control configuration, A logical OR of
 573:../drivers/fsl_enet.h ****  *  "enet_special_control_flag_t". For a special configuration for MAC,
 574:../drivers/fsl_enet.h ****  *  set this parameter to 0.
 575:../drivers/fsl_enet.h ****  *  2. txWatermark is used for a cut-through operation. It is in steps of 64 bytes:
 576:../drivers/fsl_enet.h ****  *  0/1  - 64 bytes written to TX FIFO before transmission of a frame begins.
 577:../drivers/fsl_enet.h ****  *  2    - 128 bytes written to TX FIFO ....
 578:../drivers/fsl_enet.h ****  *  3    - 192 bytes written to TX FIFO ....
 579:../drivers/fsl_enet.h ****  *  The maximum of txWatermark is 0x2F   - 4032 bytes written to TX FIFO ....
 580:../drivers/fsl_enet.h ****  *  txWatermark allows minimizing the transmit latency to set the txWatermark to 0 or 1
 581:../drivers/fsl_enet.h ****  *  or for larger bus access latency 3 or larger due to contention for the system bus.
 582:../drivers/fsl_enet.h ****  *  3. rxFifoFullThreshold is similar to the txWatermark for cut-through operation in RX.
 583:../drivers/fsl_enet.h ****  *  It is in 64-bit words. The minimum is ENET_FIFO_MIN_RX_FULL and the maximum is 0xFF.
 584:../drivers/fsl_enet.h ****  *  If the end of the frame is stored in FIFO and the frame size if smaller than the
 585:../drivers/fsl_enet.h ****  *  txWatermark, the frame is still transmitted. The rule  is the
 586:../drivers/fsl_enet.h ****  *  same for rxFifoFullThreshold in the receive direction.
 587:../drivers/fsl_enet.h ****  *  4. When "kENET_ControlFlowControlEnable" is set in the macSpecialConfig, ensure
 588:../drivers/fsl_enet.h ****  *  that the pauseDuration, rxFifoEmptyThreshold, and rxFifoStatEmptyThreshold
 589:../drivers/fsl_enet.h ****  *  are set for flow control enabled case.
 590:../drivers/fsl_enet.h ****  *  5. When "kENET_ControlStoreAndFwdDisabled" is set in the macSpecialConfig, ensure
 591:../drivers/fsl_enet.h ****  *  that the rxFifoFullThreshold and txFifoWatermark are set for store and forward disable.
 592:../drivers/fsl_enet.h ****  *  6. The rxAccelerConfig and txAccelerConfig default setting with 0 - accelerator
 593:../drivers/fsl_enet.h ****  *  are disabled. The "enet_tx_accelerator_t" and "enet_rx_accelerator_t" are
 594:../drivers/fsl_enet.h ****  *  recommended to be used to enable the transmit and receive accelerator.
 595:../drivers/fsl_enet.h ****  *  After the accelerators are enabled, the store and forward feature should be enabled.
 596:../drivers/fsl_enet.h ****  *  As a result, kENET_ControlStoreAndFwdDisabled should not be set.
 597:../drivers/fsl_enet.h ****  *  7. The intCoalesceCfg can be used in the rx or tx enabled cases to decrese the CPU loading.
 598:../drivers/fsl_enet.h ****  */
 599:../drivers/fsl_enet.h **** typedef struct _enet_config
 600:../drivers/fsl_enet.h **** {
 601:../drivers/fsl_enet.h ****     uint32_t macSpecialConfig;    /*!< Mac special configuration. A logical OR of "enet_special_con
 602:../drivers/fsl_enet.h ****     uint32_t interrupt;           /*!< Mac interrupt source. A logical OR of "enet_interrupt_enable
 603:../drivers/fsl_enet.h ****     uint16_t rxMaxFrameLen;       /*!< Receive maximum frame length. */
 604:../drivers/fsl_enet.h ****     enet_mii_mode_t miiMode;      /*!< MII mode. */
 605:../drivers/fsl_enet.h ****     enet_mii_speed_t miiSpeed;    /*!< MII Speed. */
 606:../drivers/fsl_enet.h ****     enet_mii_duplex_t miiDuplex;  /*!< MII duplex. */
 607:../drivers/fsl_enet.h ****     uint8_t rxAccelerConfig;      /*!< Receive accelerator, A logical OR of "enet_rx_accelerator_t"
 608:../drivers/fsl_enet.h ****     uint8_t txAccelerConfig;      /*!< Transmit accelerator, A logical OR of "enet_rx_accelerator_t
 609:../drivers/fsl_enet.h ****     uint16_t pauseDuration;       /*!< For flow control enabled case: Pause duration. */
 610:../drivers/fsl_enet.h ****     uint8_t rxFifoEmptyThreshold; /*!< For flow control enabled case:  when RX FIFO level reaches t
 611:../drivers/fsl_enet.h ****                                      it makes MAC generate XOFF pause frame. */
 612:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_T
 613:../drivers/fsl_enet.h ****     uint8_t rxFifoStatEmptyThreshold; /*!< For flow control enabled case: number of frames in the r
 614:../drivers/fsl_enet.h ****                                     independent of size, that can be accept. If the limit is reache
 615:../drivers/fsl_enet.h ****                                     continues and a pause frame is triggered. */
 616:../drivers/fsl_enet.h **** #endif                                /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 617:../drivers/fsl_enet.h ****     uint8_t rxFifoFullThreshold;      /*!< For store and forward disable case, the data required in
 618:../drivers/fsl_enet.h ****                                       the MAC receive ready status. */
 619:../drivers/fsl_enet.h ****     uint8_t txFifoWatermark;          /*!< For store and forward disable case, the data required in
 620:../drivers/fsl_enet.h ****                                       before a frame transmit start. */
 621:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
 622:../drivers/fsl_enet.h ****     enet_intcoalesce_config_t
 623:../drivers/fsl_enet.h ****         *intCoalesceCfg; /* If the interrupt coalsecence is not required in the ring n(0,1,2), plea
 624:../drivers/fsl_enet.h ****                    to NULL. */
 625:../drivers/fsl_enet.h **** #endif                   /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
 626:../drivers/fsl_enet.h ****     uint8_t ringNum;     /*!< Number of used rings. default with 1 -- single ring. */
 627:../drivers/fsl_enet.h **** } enet_config_t;
 628:../drivers/fsl_enet.h **** 
 629:../drivers/fsl_enet.h **** /* Forward declaration of the handle typedef. */
 630:../drivers/fsl_enet.h **** typedef struct _enet_handle enet_handle_t;
 631:../drivers/fsl_enet.h **** 
 632:../drivers/fsl_enet.h **** /*! @brief ENET callback function. */
 633:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 634:../drivers/fsl_enet.h **** typedef void (*enet_callback_t)(
 635:../drivers/fsl_enet.h ****     ENET_Type *base, enet_handle_t *handle, uint32_t ringId, enet_event_t event, void *userData);
 636:../drivers/fsl_enet.h **** #else
 637:../drivers/fsl_enet.h **** typedef void (*enet_callback_t)(ENET_Type *base, enet_handle_t *handle, enet_event_t event, void *u
 638:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 639:../drivers/fsl_enet.h **** 
 640:../drivers/fsl_enet.h **** /*! @brief Defines the ENET handler structure. */
 641:../drivers/fsl_enet.h **** struct _enet_handle
 642:../drivers/fsl_enet.h **** {
 643:../drivers/fsl_enet.h ****     volatile enet_rx_bd_struct_t
 644:../drivers/fsl_enet.h ****         *rxBdBase[FSL_FEATURE_ENET_QUEUE]; /*!< Receive buffer descriptor base address pointer. */
 645:../drivers/fsl_enet.h ****     volatile enet_rx_bd_struct_t
 646:../drivers/fsl_enet.h ****         *rxBdCurrent[FSL_FEATURE_ENET_QUEUE]; /*!< The current available receive buffer descriptor 
 647:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 648:../drivers/fsl_enet.h ****         *txBdBase[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit buffer descriptor base address pointer. */
 649:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 650:../drivers/fsl_enet.h ****         *txBdCurrent[FSL_FEATURE_ENET_QUEUE];         /*!< The current available transmit buffer de
 651:../drivers/fsl_enet.h ****     uint32_t rxBuffSizeAlign[FSL_FEATURE_ENET_QUEUE]; /*!< Receive buffer size alignment. */
 652:../drivers/fsl_enet.h ****     uint32_t txBuffSizeAlign[FSL_FEATURE_ENET_QUEUE]; /*!< Transmit buffer size alignment. */
 653:../drivers/fsl_enet.h ****     uint8_t ringNum;                                  /*!< Number of used rings. */
 654:../drivers/fsl_enet.h ****     enet_callback_t callback;                         /*!< Callback function. */
 655:../drivers/fsl_enet.h ****     void *userData;                                   /*!< Callback function parameter.*/
 656:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 657:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 658:../drivers/fsl_enet.h ****         *txBdDirtyStatic[FSL_FEATURE_ENET_QUEUE]; /*!< The dirty transmit buffer descriptor for err
 659:../drivers/fsl_enet.h ****     volatile enet_tx_bd_struct_t
 660:../drivers/fsl_enet.h ****         *txBdDirtyTime[FSL_FEATURE_ENET_QUEUE]; /*!< The dirty transmit buffer descriptor for time 
 661:../drivers/fsl_enet.h ****     uint64_t msTimerSecond;                     /*!< The second for Master PTP timer .*/
 662:../drivers/fsl_enet.h ****     enet_ptp_time_data_ring_t rxPtpTsDataRing;  /*!< Receive PTP 1588 time stamp data ring buffer. 
 663:../drivers/fsl_enet.h ****     enet_ptp_time_data_ring_t txPtpTsDataRing;  /*!< Transmit PTP 1588 time stamp data ring buffer.
 664:../drivers/fsl_enet.h **** #endif                                          /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
 665:../drivers/fsl_enet.h **** };
 666:../drivers/fsl_enet.h **** 
 667:../drivers/fsl_enet.h **** /*******************************************************************************
 668:../drivers/fsl_enet.h ****  * API
 669:../drivers/fsl_enet.h ****  ******************************************************************************/
 670:../drivers/fsl_enet.h **** 
 671:../drivers/fsl_enet.h **** #if defined(__cplusplus)
 672:../drivers/fsl_enet.h **** extern "C" {
 673:../drivers/fsl_enet.h **** #endif
 674:../drivers/fsl_enet.h **** 
 675:../drivers/fsl_enet.h **** /*!
 676:../drivers/fsl_enet.h ****   * @name Initialization and De-initialization
 677:../drivers/fsl_enet.h ****   * @{
 678:../drivers/fsl_enet.h ****   */
 679:../drivers/fsl_enet.h **** 
 680:../drivers/fsl_enet.h **** /*!
 681:../drivers/fsl_enet.h ****  * @brief Gets the ENET default configuration structure.
 682:../drivers/fsl_enet.h ****  *
 683:../drivers/fsl_enet.h ****  * The purpose of this API is to get the default ENET MAC controller
 684:../drivers/fsl_enet.h ****  * configure structure for ENET_Init(). User may use the initialized
 685:../drivers/fsl_enet.h ****  * structure unchanged in ENET_Init(), or modify some fields of the
 686:../drivers/fsl_enet.h ****  * structure before calling ENET_Init().
 687:../drivers/fsl_enet.h ****  * Example:
 688:../drivers/fsl_enet.h ****    @code
 689:../drivers/fsl_enet.h ****    enet_config_t config;
 690:../drivers/fsl_enet.h ****    ENET_GetDefaultConfig(&config);
 691:../drivers/fsl_enet.h ****    @endcode
 692:../drivers/fsl_enet.h ****  * @param config The ENET mac controller configuration structure pointer.
 693:../drivers/fsl_enet.h ****  */
 694:../drivers/fsl_enet.h **** void ENET_GetDefaultConfig(enet_config_t *config);
 695:../drivers/fsl_enet.h **** 
 696:../drivers/fsl_enet.h **** /*!
 697:../drivers/fsl_enet.h ****  * @brief Initializes the ENET module.
 698:../drivers/fsl_enet.h ****  *
 699:../drivers/fsl_enet.h ****  * This function ungates the module clock and initializes it with the ENET configuration.
 700:../drivers/fsl_enet.h ****  *
 701:../drivers/fsl_enet.h ****  * @param base    ENET peripheral base address.
 702:../drivers/fsl_enet.h ****  * @param handle  ENET handler pointer.
 703:../drivers/fsl_enet.h ****  * @param config  ENET mac configuration structure pointer.
 704:../drivers/fsl_enet.h ****  *        The "enet_config_t" type mac configuration return from ENET_GetDefaultConfig
 705:../drivers/fsl_enet.h ****  *        can be used directly. It is also possible to verify the Mac configuration using other met
 706:../drivers/fsl_enet.h ****  * @param bufferConfig  ENET buffer configuration structure pointer.
 707:../drivers/fsl_enet.h ****  *        The buffer configuration should be prepared for ENET Initialization.
 708:../drivers/fsl_enet.h ****  *        It is the start address of "ringNum" enet_buffer_config structures.
 709:../drivers/fsl_enet.h ****  * @param macAddr  ENET mac address of Ethernet device. This MAC address should be
 710:../drivers/fsl_enet.h ****  *        provided.
 711:../drivers/fsl_enet.h ****  * @param srcClock_Hz The internal module clock source for MII clock.
 712:../drivers/fsl_enet.h ****  *
 713:../drivers/fsl_enet.h ****  * @note ENET has two buffer descriptors legacy buffer descriptors and
 714:../drivers/fsl_enet.h ****  * enhanced IEEE 1588 buffer descriptors. The legacy descriptor is used by default. To
 715:../drivers/fsl_enet.h ****  * use the IEEE 1588 feature, use the enhanced IEEE 1588 buffer descriptor
 716:../drivers/fsl_enet.h ****  * by defining "ENET_ENHANCEDBUFFERDESCRIPTOR_MODE" and calling ENET_Ptp1588Configure()
 717:../drivers/fsl_enet.h ****  * to configure the 1588 feature and related buffers after calling ENET_Init().
 718:../drivers/fsl_enet.h ****  */
 719:../drivers/fsl_enet.h **** void ENET_Init(ENET_Type *base,
 720:../drivers/fsl_enet.h ****                enet_handle_t *handle,
 721:../drivers/fsl_enet.h ****                const enet_config_t *config,
 722:../drivers/fsl_enet.h ****                const enet_buffer_config_t *bufferConfig,
 723:../drivers/fsl_enet.h ****                uint8_t *macAddr,
 724:../drivers/fsl_enet.h ****                uint32_t srcClock_Hz);
 725:../drivers/fsl_enet.h **** /*!
 726:../drivers/fsl_enet.h ****  * @brief Deinitializes the ENET module.
 727:../drivers/fsl_enet.h **** 
 728:../drivers/fsl_enet.h ****  * This function gates the module clock, clears ENET interrupts, and disables the ENET module.
 729:../drivers/fsl_enet.h ****  *
 730:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 731:../drivers/fsl_enet.h ****  */
 732:../drivers/fsl_enet.h **** void ENET_Deinit(ENET_Type *base);
 733:../drivers/fsl_enet.h **** 
 734:../drivers/fsl_enet.h **** /*!
 735:../drivers/fsl_enet.h ****  * @brief Resets the ENET module.
 736:../drivers/fsl_enet.h ****  *
 737:../drivers/fsl_enet.h ****  * This function restores the ENET module to reset state.
 738:../drivers/fsl_enet.h ****  * Note that this function sets all registers to
 739:../drivers/fsl_enet.h ****  * reset state. As a result, the ENET module can't work after calling this function.
 740:../drivers/fsl_enet.h ****  *
 741:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 742:../drivers/fsl_enet.h ****  */
 743:../drivers/fsl_enet.h **** static inline void ENET_Reset(ENET_Type *base)
 744:../drivers/fsl_enet.h **** {
 745:../drivers/fsl_enet.h ****     base->ECR |= ENET_ECR_RESET_MASK;
 746:../drivers/fsl_enet.h **** }
 747:../drivers/fsl_enet.h **** 
 748:../drivers/fsl_enet.h **** /* @} */
 749:../drivers/fsl_enet.h **** 
 750:../drivers/fsl_enet.h **** /*!
 751:../drivers/fsl_enet.h ****  * @name MII interface operation
 752:../drivers/fsl_enet.h ****  * @{
 753:../drivers/fsl_enet.h ****  */
 754:../drivers/fsl_enet.h **** 
 755:../drivers/fsl_enet.h **** /*!
 756:../drivers/fsl_enet.h ****  * @brief Sets the ENET MII speed and duplex.
 757:../drivers/fsl_enet.h ****  *
 758:../drivers/fsl_enet.h ****  * This API is provided to dynamically change the speed and dulpex for MAC.
 759:../drivers/fsl_enet.h ****  *
 760:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 761:../drivers/fsl_enet.h ****  * @param speed The speed of the RMII mode.
 762:../drivers/fsl_enet.h ****  * @param duplex The duplex of the RMII mode.
 763:../drivers/fsl_enet.h ****  */
 764:../drivers/fsl_enet.h **** void ENET_SetMII(ENET_Type *base, enet_mii_speed_t speed, enet_mii_duplex_t duplex);
 765:../drivers/fsl_enet.h **** 
 766:../drivers/fsl_enet.h **** /*!
 767:../drivers/fsl_enet.h ****  * @brief Sets the ENET SMI(serial management interface)- MII management interface.
 768:../drivers/fsl_enet.h ****  *
 769:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 770:../drivers/fsl_enet.h ****  * @param srcClock_Hz This is the ENET module clock frequency. Normally it's the system clock. See 
 771:../drivers/fsl_enet.h ****  * @param isPreambleDisabled The preamble disable flag.
 772:../drivers/fsl_enet.h ****  *        - true   Enables the preamble.
 773:../drivers/fsl_enet.h ****  *        - false  Disables the preamble.
 774:../drivers/fsl_enet.h ****  */
 775:../drivers/fsl_enet.h **** void ENET_SetSMI(ENET_Type *base, uint32_t srcClock_Hz, bool isPreambleDisabled);
 776:../drivers/fsl_enet.h **** 
 777:../drivers/fsl_enet.h **** /*!
 778:../drivers/fsl_enet.h ****  * @brief Gets the ENET SMI- MII management interface configuration.
 779:../drivers/fsl_enet.h ****  *
 780:../drivers/fsl_enet.h ****  * This API is used to get the SMI configuration to check whether the MII management
 781:../drivers/fsl_enet.h ****  * interface has been set.
 782:../drivers/fsl_enet.h ****  *
 783:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 784:../drivers/fsl_enet.h ****  * @return The SMI setup status true or false.
 785:../drivers/fsl_enet.h ****  */
 786:../drivers/fsl_enet.h **** static inline bool ENET_GetSMI(ENET_Type *base)
 787:../drivers/fsl_enet.h **** {
 788:../drivers/fsl_enet.h ****     return (0 != (base->MSCR & 0x7E));
 789:../drivers/fsl_enet.h **** }
 790:../drivers/fsl_enet.h **** 
 791:../drivers/fsl_enet.h **** /*!
 792:../drivers/fsl_enet.h ****  * @brief Reads data from the PHY register through an SMI interface.
 793:../drivers/fsl_enet.h ****  *
 794:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 795:../drivers/fsl_enet.h ****  * @return The data read from PHY
 796:../drivers/fsl_enet.h ****  */
 797:../drivers/fsl_enet.h **** static inline uint32_t ENET_ReadSMIData(ENET_Type *base)
 798:../drivers/fsl_enet.h **** {
 799:../drivers/fsl_enet.h ****     return (uint32_t)((base->MMFR & ENET_MMFR_DATA_MASK) >> ENET_MMFR_DATA_SHIFT);
 800:../drivers/fsl_enet.h **** }
 801:../drivers/fsl_enet.h **** 
 802:../drivers/fsl_enet.h **** /*!
 803:../drivers/fsl_enet.h ****  * @brief Starts an SMI (Serial Management Interface) read command.
 804:../drivers/fsl_enet.h ****  *
 805:../drivers/fsl_enet.h ****  * Used for standard IEEE802.3 MDIO Clause 22 format.
 806:../drivers/fsl_enet.h ****  *
 807:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 808:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 809:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. Range from 0 ~ 31.
 810:../drivers/fsl_enet.h ****  * @param operation The read operation.
 811:../drivers/fsl_enet.h ****  */
 812:../drivers/fsl_enet.h **** void ENET_StartSMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_read_t operatio
 813:../drivers/fsl_enet.h **** 
 814:../drivers/fsl_enet.h **** /*!
 815:../drivers/fsl_enet.h ****  * @brief Starts an SMI write command.
 816:../drivers/fsl_enet.h ****  *
 817:../drivers/fsl_enet.h ****  * Used for standard IEEE802.3 MDIO Clause 22 format.
 818:../drivers/fsl_enet.h ****  *
 819:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 820:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 821:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. Range from 0 ~ 31.
 822:../drivers/fsl_enet.h ****  * @param operation The write operation.
 823:../drivers/fsl_enet.h ****  * @param data The data written to PHY.
 824:../drivers/fsl_enet.h ****  */
 825:../drivers/fsl_enet.h **** void ENET_StartSMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_write_t operat
 826:../drivers/fsl_enet.h **** 
 827:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
 828:../drivers/fsl_enet.h **** /*!
 829:../drivers/fsl_enet.h ****  * @brief Starts the extended IEEE802.3 Clause 45 MDIO format SMI read command.
 830:../drivers/fsl_enet.h ****  *
 831:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 832:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 833:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. For MDIO IEEE802.3 Clause 45,
 834:../drivers/fsl_enet.h ****  *        the phyReg is a 21-bits combination of the devaddr (5 bits device address)
 835:../drivers/fsl_enet.h ****  *        and the regAddr (16 bits phy register): phyReg = (devaddr << 16) | regAddr.
 836:../drivers/fsl_enet.h ****  */
 837:../drivers/fsl_enet.h **** void ENET_StartExtC45SMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg);
 838:../drivers/fsl_enet.h **** 
 839:../drivers/fsl_enet.h **** /*!
 840:../drivers/fsl_enet.h ****  * @brief Starts the extended IEEE802.3 Clause 45 MDIO format SMI write command.
 841:../drivers/fsl_enet.h ****  *
 842:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 843:../drivers/fsl_enet.h ****  * @param phyAddr The PHY address.
 844:../drivers/fsl_enet.h ****  * @param phyReg The PHY register. For MDIO IEEE802.3 Clause 45,
 845:../drivers/fsl_enet.h ****  *        the phyReg is a 21-bits combination of the devaddr (5 bits device address)
 846:../drivers/fsl_enet.h ****  *        and the regAddr (16 bits phy register): phyReg = (devaddr << 16) | regAddr.
 847:../drivers/fsl_enet.h ****  * @param data The data written to PHY.
 848:../drivers/fsl_enet.h ****  */
 849:../drivers/fsl_enet.h **** void ENET_StartExtC45SMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data);
 850:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */
 851:../drivers/fsl_enet.h **** 
 852:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 853:../drivers/fsl_enet.h **** /*!
 854:../drivers/fsl_enet.h ****  * @brief Control the usage of the delayed tx/rx RGMII clock.
 855:../drivers/fsl_enet.h ****  *
 856:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 857:../drivers/fsl_enet.h ****  * @param txEnabled  Enable or disable to generate the delayed version of RGMII_TXC.
 858:../drivers/fsl_enet.h ****  * @param rxEnabled  Enable or disable to use the delayed version of RGMII_RXC.
 859:../drivers/fsl_enet.h ****  */
 860:../drivers/fsl_enet.h **** 
 861:../drivers/fsl_enet.h **** static inline void ENET_SetRGMIIClockDelay(ENET_Type *base, bool txEnabled, bool rxEnabled)
 862:../drivers/fsl_enet.h **** {
 863:../drivers/fsl_enet.h ****     uint32_t ecrReg = base->ECR;
 864:../drivers/fsl_enet.h **** 
 865:../drivers/fsl_enet.h ****     /* Set for transmit clock delay. */
 866:../drivers/fsl_enet.h ****     if (txEnabled)
 867:../drivers/fsl_enet.h ****     {
 868:../drivers/fsl_enet.h ****         ecrReg |= ENET_ECR_TXC_DLY_MASK;
 869:../drivers/fsl_enet.h ****     }
 870:../drivers/fsl_enet.h ****     else
 871:../drivers/fsl_enet.h ****     {
 872:../drivers/fsl_enet.h ****         ecrReg &= ~ENET_ECR_TXC_DLY_MASK;
 873:../drivers/fsl_enet.h ****     }
 874:../drivers/fsl_enet.h **** 
 875:../drivers/fsl_enet.h ****     /* Set for receive clock delay. */
 876:../drivers/fsl_enet.h ****     if (rxEnabled)
 877:../drivers/fsl_enet.h ****     {
 878:../drivers/fsl_enet.h ****         ecrReg |= ENET_ECR_RXC_DLY_MASK;
 879:../drivers/fsl_enet.h ****     }
 880:../drivers/fsl_enet.h ****     else
 881:../drivers/fsl_enet.h ****     {
 882:../drivers/fsl_enet.h ****         ecrReg &= ~ENET_ECR_RXC_DLY_MASK;
 883:../drivers/fsl_enet.h ****     }
 884:../drivers/fsl_enet.h **** }
 885:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 886:../drivers/fsl_enet.h ****        /* @} */
 887:../drivers/fsl_enet.h **** 
 888:../drivers/fsl_enet.h **** /*!
 889:../drivers/fsl_enet.h ****  * @name MAC Address Filter
 890:../drivers/fsl_enet.h ****  * @{
 891:../drivers/fsl_enet.h ****  */
 892:../drivers/fsl_enet.h **** 
 893:../drivers/fsl_enet.h **** /*!
 894:../drivers/fsl_enet.h ****  * @brief Sets the ENET module Mac address.
 895:../drivers/fsl_enet.h ****  *
 896:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 897:../drivers/fsl_enet.h ****  * @param macAddr The six-byte Mac address pointer.
 898:../drivers/fsl_enet.h ****  *        The pointer is allocated by application and input into the API.
 899:../drivers/fsl_enet.h ****  */
 900:../drivers/fsl_enet.h **** void ENET_SetMacAddr(ENET_Type *base, uint8_t *macAddr);
 901:../drivers/fsl_enet.h **** 
 902:../drivers/fsl_enet.h **** /*!
 903:../drivers/fsl_enet.h ****  * @brief Gets the ENET module Mac address.
 904:../drivers/fsl_enet.h ****  *
 905:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 906:../drivers/fsl_enet.h ****  * @param macAddr The six-byte Mac address pointer.
 907:../drivers/fsl_enet.h ****  *        The pointer is allocated by application and input into the API.
 908:../drivers/fsl_enet.h ****  */
 909:../drivers/fsl_enet.h **** void ENET_GetMacAddr(ENET_Type *base, uint8_t *macAddr);
 910:../drivers/fsl_enet.h **** 
 911:../drivers/fsl_enet.h **** /*!
 912:../drivers/fsl_enet.h ****  * @brief Adds the ENET device to a multicast group.
 913:../drivers/fsl_enet.h ****  *
 914:../drivers/fsl_enet.h ****  * @param base    ENET peripheral base address.
 915:../drivers/fsl_enet.h ****  * @param address The six-byte multicast group address which is provided by application.
 916:../drivers/fsl_enet.h ****  */
 917:../drivers/fsl_enet.h **** void ENET_AddMulticastGroup(ENET_Type *base, uint8_t *address);
 918:../drivers/fsl_enet.h **** 
 919:../drivers/fsl_enet.h **** /*!
 920:../drivers/fsl_enet.h ****  * @brief Moves the ENET device from a multicast group.
 921:../drivers/fsl_enet.h ****  *
 922:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 923:../drivers/fsl_enet.h ****  * @param address The six-byte multicast group address which is provided by application.
 924:../drivers/fsl_enet.h ****  */
 925:../drivers/fsl_enet.h **** void ENET_LeaveMulticastGroup(ENET_Type *base, uint8_t *address);
 926:../drivers/fsl_enet.h **** 
 927:../drivers/fsl_enet.h **** /* @} */
 928:../drivers/fsl_enet.h **** 
 929:../drivers/fsl_enet.h **** /*!
 930:../drivers/fsl_enet.h ****  * @name Other basic operation
 931:../drivers/fsl_enet.h ****  * @{
 932:../drivers/fsl_enet.h ****  */
 933:../drivers/fsl_enet.h **** 
 934:../drivers/fsl_enet.h **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 935:../drivers/fsl_enet.h **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 936:../drivers/fsl_enet.h **** /*!
 937:../drivers/fsl_enet.h ****  * @brief Sets the ENET AVB feature.
 938:../drivers/fsl_enet.h ****  *
 939:../drivers/fsl_enet.h ****  * ENET AVB feature configuration, set the Receive classification match and transmit
 940:../drivers/fsl_enet.h ****  * bandwidth. This API is called when the AVB feature is required.
 941:../drivers/fsl_enet.h ****  *
 942:../drivers/fsl_enet.h ****  * Note: The AVB frames transmission scheme is credit-based tx scheme and it's only supported
 943:../drivers/fsl_enet.h ****  * with the Enhanced buffer descriptors. so the AVB configuration should only done with
 944:../drivers/fsl_enet.h ****  * Enhanced buffer descriptor. so when the AVB feature is required, please make sure the
 945:../drivers/fsl_enet.h ****  * the "ENET_ENHANCEDBUFFERDESCRIPTOR_MODE" is defined.
 946:../drivers/fsl_enet.h ****  *
 947:../drivers/fsl_enet.h ****  * @param base ENET peripheral base address.
 948:../drivers/fsl_enet.h ****  * @param handle ENET handler pointer.
 949:../drivers/fsl_enet.h ****  * @param config The ENET AVB feature configuration structure.
 950:../drivers/fsl_enet.h ****  */
 951:../drivers/fsl_enet.h **** void ENET_AVBConfigure(ENET_Type *base, enet_handle_t *handle, const enet_avb_config_t *config);
 952:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_HAS_AVB */
 953:../drivers/fsl_enet.h **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE  */
 954:../drivers/fsl_enet.h **** 
 955:../drivers/fsl_enet.h **** /*!
 956:../drivers/fsl_enet.h ****  * @brief Activates ENET read or receive.
 957:../drivers/fsl_enet.h ****  *
 958:../drivers/fsl_enet.h ****  * This function is to active the enet read process. It is
 959:../drivers/fsl_enet.h ****  * used for single descriptor ring/queue.
 960:../drivers/fsl_enet.h ****  *
 961:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 962:../drivers/fsl_enet.h ****  *
 963:../drivers/fsl_enet.h ****  * @note This must be called after the MAC configuration and
 964:../drivers/fsl_enet.h ****  * state are ready. It must be called after the ENET_Init() and
 965:../drivers/fsl_enet.h ****  * ENET_Ptp1588Configure(). This should be called when the ENET receive required.
 966:../drivers/fsl_enet.h ****  */
 967:../drivers/fsl_enet.h **** static inline void ENET_ActiveRead(ENET_Type *base)
 968:../drivers/fsl_enet.h **** {
 969:../drivers/fsl_enet.h ****     base->RDAR = ENET_RDAR_RDAR_MASK;
 970:../drivers/fsl_enet.h **** }
 971:../drivers/fsl_enet.h **** 
 972:../drivers/fsl_enet.h **** #if FSL_FEATURE_ENET_QUEUE > 1
 973:../drivers/fsl_enet.h **** /*!
 974:../drivers/fsl_enet.h ****  * @brief Activates ENET read or receive for multiple-queue/ring.
 975:../drivers/fsl_enet.h ****  *
 976:../drivers/fsl_enet.h ****  * This function is to active the enet read process. It is
 977:../drivers/fsl_enet.h ****  * used for extended multiple descriptor rings/queues.
 978:../drivers/fsl_enet.h ****  *
 979:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
 980:../drivers/fsl_enet.h ****  *
 981:../drivers/fsl_enet.h ****  * @note This must be called after the MAC configuration and
 982:../drivers/fsl_enet.h ****  * state are ready. It must be called after the ENET_Init() and
 983:../drivers/fsl_enet.h ****  * ENET_Ptp1588Configure(). This should be called when the ENET receive required.
 984:../drivers/fsl_enet.h ****  */
 985:../drivers/fsl_enet.h **** static inline void ENET_ActiveReadMultiRing(ENET_Type *base)
 986:../drivers/fsl_enet.h **** {
 987:../drivers/fsl_enet.h ****     base->RDAR = ENET_RDAR_RDAR_MASK;
 988:../drivers/fsl_enet.h ****     base->RDAR1 = ENET_RDAR1_RDAR_MASK;
 989:../drivers/fsl_enet.h ****     base->RDAR2 = ENET_RDAR2_RDAR_MASK;
 990:../drivers/fsl_enet.h **** }
 991:../drivers/fsl_enet.h **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 992:../drivers/fsl_enet.h **** 
 993:../drivers/fsl_enet.h **** /*!
 994:../drivers/fsl_enet.h ****  * @brief Enables/disables the MAC to enter sleep mode.
 995:../drivers/fsl_enet.h ****  * This function is used to set the MAC enter sleep mode.
 996:../drivers/fsl_enet.h ****  * When entering sleep mode, the magic frame wakeup interrupt should be enabled
 997:../drivers/fsl_enet.h ****  * to wake up MAC from the sleep mode and reset it to normal mode.
 998:../drivers/fsl_enet.h ****  *
 999:../drivers/fsl_enet.h ****  * @param base    ENET peripheral base address.
1000:../drivers/fsl_enet.h ****  * @param enable  True enable sleep mode, false disable sleep mode.
1001:../drivers/fsl_enet.h ****  */
1002:../drivers/fsl_enet.h **** static inline void ENET_EnableSleepMode(ENET_Type *base, bool enable)
1003:../drivers/fsl_enet.h **** {
1004:../drivers/fsl_enet.h ****     if (enable)
1005:../drivers/fsl_enet.h ****     {
1006:../drivers/fsl_enet.h ****         /* When this field is set, MAC enters sleep mode. */
1007:../drivers/fsl_enet.h ****         base->ECR |= ENET_ECR_SLEEP_MASK | ENET_ECR_MAGICEN_MASK;
1008:../drivers/fsl_enet.h ****     }
1009:../drivers/fsl_enet.h ****     else
1010:../drivers/fsl_enet.h ****     { /* MAC exits sleep mode. */
1011:../drivers/fsl_enet.h ****         base->ECR &= ~(ENET_ECR_SLEEP_MASK | ENET_ECR_MAGICEN_MASK);
 163              		.loc 2 1011 0
 164 0010 456A     		ldr	r5, [r0, #36]
 165 0012 25F00C05 		bic	r5, r5, #12
 166 0016 4562     		str	r5, [r0, #36]
 167              	.LVL10:
 168              	.LBE43:
 169              	.LBE42:
2707:../drivers/fsl_enet.c ****         /* wake up and enter the normal mode. */
2708:../drivers/fsl_enet.c ****         ENET_EnableSleepMode(base, false);
2709:../drivers/fsl_enet.c ****         /* Callback function. */
2710:../drivers/fsl_enet.c ****         if (handle->callback)
 170              		.loc 1 2710 0
 171 0018 14B1     		cbz	r4, .L16
2711:../drivers/fsl_enet.c ****         {
2712:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2713:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_WakeUpEvent, handle->userData);
2714:../drivers/fsl_enet.c **** #else
2715:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_WakeUpEvent, handle->userData);
 172              		.loc 1 2715 0
 173 001a 0B6A     		ldr	r3, [r1, #32]
 174 001c 0322     		movs	r2, #3
 175              	.LVL11:
 176              	.L21:
2716:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2717:../drivers/fsl_enet.c ****         }
2718:../drivers/fsl_enet.c ****     }
2719:../drivers/fsl_enet.c ****     else
2720:../drivers/fsl_enet.c ****     {
2721:../drivers/fsl_enet.c ****         /* Clear the error interrupt event status. */
2722:../drivers/fsl_enet.c ****         errMask &= base->EIR;
2723:../drivers/fsl_enet.c ****         base->EIR = errMask;
2724:../drivers/fsl_enet.c ****         /* Callback function. */
2725:../drivers/fsl_enet.c ****         if (handle->callback)
2726:../drivers/fsl_enet.c ****         {
2727:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2728:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_ErrEvent, handle->userData);
2729:../drivers/fsl_enet.c **** #else
2730:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_ErrEvent, handle->userData);
 177              		.loc 1 2730 0
 178 001e A047     		blx	r4
 179              	.LVL12:
 180              	.L16:
 181              	.LBB44:
 182              	.LBB45:
 183              		.file 3 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 412:../CMSIS/cmsis_gcc.h **** }
 413:../CMSIS/cmsis_gcc.h **** 
 414:../CMSIS/cmsis_gcc.h **** 
 415:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 416:../CMSIS/cmsis_gcc.h **** /**
 417:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 418:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 419:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 420:../CMSIS/cmsis_gcc.h ****  */
 421:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 422:../CMSIS/cmsis_gcc.h **** {
 423:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 424:../CMSIS/cmsis_gcc.h **** }
 425:../CMSIS/cmsis_gcc.h **** #endif
 426:../CMSIS/cmsis_gcc.h **** 
 427:../CMSIS/cmsis_gcc.h **** 
 428:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 429:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 430:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 431:../CMSIS/cmsis_gcc.h **** /**
 432:../CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 433:../CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 434:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 435:../CMSIS/cmsis_gcc.h ****  */
 436:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 437:../CMSIS/cmsis_gcc.h **** {
 438:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 439:../CMSIS/cmsis_gcc.h **** }
 440:../CMSIS/cmsis_gcc.h **** 
 441:../CMSIS/cmsis_gcc.h **** 
 442:../CMSIS/cmsis_gcc.h **** /**
 443:../CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 444:../CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 445:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 446:../CMSIS/cmsis_gcc.h ****  */
 447:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 448:../CMSIS/cmsis_gcc.h **** {
 449:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 450:../CMSIS/cmsis_gcc.h **** }
 451:../CMSIS/cmsis_gcc.h **** 
 452:../CMSIS/cmsis_gcc.h **** 
 453:../CMSIS/cmsis_gcc.h **** /**
 454:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 455:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 456:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 457:../CMSIS/cmsis_gcc.h ****  */
 458:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 459:../CMSIS/cmsis_gcc.h **** {
 460:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 461:../CMSIS/cmsis_gcc.h **** 
 462:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 463:../CMSIS/cmsis_gcc.h ****   return(result);
 464:../CMSIS/cmsis_gcc.h **** }
 465:../CMSIS/cmsis_gcc.h **** 
 466:../CMSIS/cmsis_gcc.h **** 
 467:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 468:../CMSIS/cmsis_gcc.h **** /**
 469:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 470:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 471:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 472:../CMSIS/cmsis_gcc.h ****  */
 473:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 474:../CMSIS/cmsis_gcc.h **** {
 475:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 476:../CMSIS/cmsis_gcc.h **** 
 477:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 478:../CMSIS/cmsis_gcc.h ****   return(result);
 479:../CMSIS/cmsis_gcc.h **** }
 480:../CMSIS/cmsis_gcc.h **** #endif
 481:../CMSIS/cmsis_gcc.h **** 
 482:../CMSIS/cmsis_gcc.h **** 
 483:../CMSIS/cmsis_gcc.h **** /**
 484:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 485:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 486:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 487:../CMSIS/cmsis_gcc.h ****  */
 488:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 489:../CMSIS/cmsis_gcc.h **** {
 490:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 491:../CMSIS/cmsis_gcc.h **** }
 492:../CMSIS/cmsis_gcc.h **** 
 493:../CMSIS/cmsis_gcc.h **** 
 494:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 495:../CMSIS/cmsis_gcc.h **** /**
 496:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 497:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 498:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 499:../CMSIS/cmsis_gcc.h ****  */
 500:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 501:../CMSIS/cmsis_gcc.h **** {
 502:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 503:../CMSIS/cmsis_gcc.h **** }
 504:../CMSIS/cmsis_gcc.h **** #endif
 505:../CMSIS/cmsis_gcc.h **** 
 506:../CMSIS/cmsis_gcc.h **** 
 507:../CMSIS/cmsis_gcc.h **** /**
 508:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 509:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 510:../CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 511:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 512:../CMSIS/cmsis_gcc.h ****  */
 513:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 514:../CMSIS/cmsis_gcc.h **** {
 515:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 516:../CMSIS/cmsis_gcc.h **** }
 517:../CMSIS/cmsis_gcc.h **** 
 518:../CMSIS/cmsis_gcc.h **** 
 519:../CMSIS/cmsis_gcc.h **** /**
 520:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 521:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 522:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 523:../CMSIS/cmsis_gcc.h ****  */
 524:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 525:../CMSIS/cmsis_gcc.h **** {
 526:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 527:../CMSIS/cmsis_gcc.h **** 
 528:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 529:../CMSIS/cmsis_gcc.h ****   return(result);
 530:../CMSIS/cmsis_gcc.h **** }
 531:../CMSIS/cmsis_gcc.h **** 
 532:../CMSIS/cmsis_gcc.h **** 
 533:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 534:../CMSIS/cmsis_gcc.h **** /**
 535:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 536:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 537:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 538:../CMSIS/cmsis_gcc.h ****  */
 539:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 540:../CMSIS/cmsis_gcc.h **** {
 541:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 542:../CMSIS/cmsis_gcc.h **** 
 543:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 544:../CMSIS/cmsis_gcc.h ****   return(result);
 545:../CMSIS/cmsis_gcc.h **** }
 546:../CMSIS/cmsis_gcc.h **** #endif
 547:../CMSIS/cmsis_gcc.h **** 
 548:../CMSIS/cmsis_gcc.h **** 
 549:../CMSIS/cmsis_gcc.h **** /**
 550:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 551:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 552:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 553:../CMSIS/cmsis_gcc.h ****  */
 554:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 555:../CMSIS/cmsis_gcc.h **** {
 556:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 557:../CMSIS/cmsis_gcc.h **** }
 558:../CMSIS/cmsis_gcc.h **** 
 559:../CMSIS/cmsis_gcc.h **** 
 560:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 561:../CMSIS/cmsis_gcc.h **** /**
 562:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 563:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 564:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 565:../CMSIS/cmsis_gcc.h ****  */
 566:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 567:../CMSIS/cmsis_gcc.h **** {
 568:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 569:../CMSIS/cmsis_gcc.h **** }
 570:../CMSIS/cmsis_gcc.h **** #endif
 571:../CMSIS/cmsis_gcc.h **** 
 572:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 573:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 574:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 575:../CMSIS/cmsis_gcc.h **** 
 576:../CMSIS/cmsis_gcc.h **** 
 577:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 578:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 579:../CMSIS/cmsis_gcc.h **** 
 580:../CMSIS/cmsis_gcc.h **** /**
 581:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 582:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 583:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 584:../CMSIS/cmsis_gcc.h ****  */
 585:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 586:../CMSIS/cmsis_gcc.h **** {
 587:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 588:../CMSIS/cmsis_gcc.h **** 
 589:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 590:../CMSIS/cmsis_gcc.h ****   return(result);
 591:../CMSIS/cmsis_gcc.h **** }
 592:../CMSIS/cmsis_gcc.h **** 
 593:../CMSIS/cmsis_gcc.h **** 
 594:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 595:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 596:../CMSIS/cmsis_gcc.h **** /**
 597:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 598:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 599:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 600:../CMSIS/cmsis_gcc.h ****  */
 601:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 602:../CMSIS/cmsis_gcc.h **** {
 603:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 604:../CMSIS/cmsis_gcc.h **** 
 605:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 606:../CMSIS/cmsis_gcc.h ****   return(result);
 607:../CMSIS/cmsis_gcc.h **** }
 608:../CMSIS/cmsis_gcc.h **** #endif
 609:../CMSIS/cmsis_gcc.h **** 
 610:../CMSIS/cmsis_gcc.h **** 
 611:../CMSIS/cmsis_gcc.h **** /**
 612:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 613:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 614:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 615:../CMSIS/cmsis_gcc.h ****  */
 616:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 617:../CMSIS/cmsis_gcc.h **** {
 618:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 619:../CMSIS/cmsis_gcc.h **** }
 620:../CMSIS/cmsis_gcc.h **** 
 621:../CMSIS/cmsis_gcc.h **** 
 622:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 623:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 624:../CMSIS/cmsis_gcc.h **** /**
 625:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 626:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 627:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 628:../CMSIS/cmsis_gcc.h ****  */
 629:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 630:../CMSIS/cmsis_gcc.h **** {
 631:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 632:../CMSIS/cmsis_gcc.h **** }
 633:../CMSIS/cmsis_gcc.h **** #endif
 634:../CMSIS/cmsis_gcc.h **** 
 635:../CMSIS/cmsis_gcc.h **** 
 636:../CMSIS/cmsis_gcc.h **** /**
 637:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 638:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 639:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 640:../CMSIS/cmsis_gcc.h ****  */
 641:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 642:../CMSIS/cmsis_gcc.h **** {
 643:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 644:../CMSIS/cmsis_gcc.h **** 
 645:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 646:../CMSIS/cmsis_gcc.h **** 
 647:../CMSIS/cmsis_gcc.h ****   return(result);
 648:../CMSIS/cmsis_gcc.h **** }
 649:../CMSIS/cmsis_gcc.h **** 
 650:../CMSIS/cmsis_gcc.h **** 
 651:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 652:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 653:../CMSIS/cmsis_gcc.h **** /**
 654:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 655:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 656:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 657:../CMSIS/cmsis_gcc.h ****  */
 658:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 659:../CMSIS/cmsis_gcc.h **** {
 660:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 661:../CMSIS/cmsis_gcc.h **** 
 662:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 663:../CMSIS/cmsis_gcc.h ****   return(result);
 664:../CMSIS/cmsis_gcc.h **** }
 665:../CMSIS/cmsis_gcc.h **** #endif
 666:../CMSIS/cmsis_gcc.h **** 
 667:../CMSIS/cmsis_gcc.h **** 
 668:../CMSIS/cmsis_gcc.h **** /**
 669:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 670:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 671:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 672:../CMSIS/cmsis_gcc.h ****  */
 673:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 674:../CMSIS/cmsis_gcc.h **** {
 675:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 676:../CMSIS/cmsis_gcc.h **** }
 677:../CMSIS/cmsis_gcc.h **** 
 678:../CMSIS/cmsis_gcc.h **** 
 679:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 680:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 681:../CMSIS/cmsis_gcc.h **** /**
 682:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 683:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 684:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 685:../CMSIS/cmsis_gcc.h ****  */
 686:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 687:../CMSIS/cmsis_gcc.h **** {
 688:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 689:../CMSIS/cmsis_gcc.h **** }
 690:../CMSIS/cmsis_gcc.h **** #endif
 691:../CMSIS/cmsis_gcc.h **** 
 692:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 693:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 694:../CMSIS/cmsis_gcc.h **** 
 695:../CMSIS/cmsis_gcc.h **** 
 696:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 697:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 698:../CMSIS/cmsis_gcc.h **** 
 699:../CMSIS/cmsis_gcc.h **** /**
 700:../CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 701:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 702:../CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 703:../CMSIS/cmsis_gcc.h ****  */
 704:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 705:../CMSIS/cmsis_gcc.h **** {
 706:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 707:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 708:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 709:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 710:../CMSIS/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 711:../CMSIS/cmsis_gcc.h **** #else
 712:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 713:../CMSIS/cmsis_gcc.h **** 
 714:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 715:../CMSIS/cmsis_gcc.h ****   return(result);
 716:../CMSIS/cmsis_gcc.h **** #endif
 717:../CMSIS/cmsis_gcc.h **** #else
 718:../CMSIS/cmsis_gcc.h ****   return(0U);
 719:../CMSIS/cmsis_gcc.h **** #endif
 720:../CMSIS/cmsis_gcc.h **** }
 721:../CMSIS/cmsis_gcc.h **** 
 722:../CMSIS/cmsis_gcc.h **** 
 723:../CMSIS/cmsis_gcc.h **** /**
 724:../CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 725:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 726:../CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 727:../CMSIS/cmsis_gcc.h ****  */
 728:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 729:../CMSIS/cmsis_gcc.h **** {
 730:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 731:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 732:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 733:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 734:../CMSIS/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 735:../CMSIS/cmsis_gcc.h **** #else
 736:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 737:../CMSIS/cmsis_gcc.h **** #endif
 738:../CMSIS/cmsis_gcc.h **** #else
 739:../CMSIS/cmsis_gcc.h ****   (void)fpscr;
 740:../CMSIS/cmsis_gcc.h **** #endif
 741:../CMSIS/cmsis_gcc.h **** }
 742:../CMSIS/cmsis_gcc.h **** 
 743:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 744:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 745:../CMSIS/cmsis_gcc.h **** 
 746:../CMSIS/cmsis_gcc.h **** 
 747:../CMSIS/cmsis_gcc.h **** 
 748:../CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 749:../CMSIS/cmsis_gcc.h **** 
 750:../CMSIS/cmsis_gcc.h **** 
 751:../CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 752:../CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 753:../CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 754:../CMSIS/cmsis_gcc.h ****   @{
 755:../CMSIS/cmsis_gcc.h **** */
 756:../CMSIS/cmsis_gcc.h **** 
 757:../CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 758:../CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 759:../CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 760:../CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 761:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 762:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 763:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 764:../CMSIS/cmsis_gcc.h **** #else
 765:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 766:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 767:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 768:../CMSIS/cmsis_gcc.h **** #endif
 769:../CMSIS/cmsis_gcc.h **** 
 770:../CMSIS/cmsis_gcc.h **** /**
 771:../CMSIS/cmsis_gcc.h ****   \brief   No Operation
 772:../CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 773:../CMSIS/cmsis_gcc.h ****  */
 774:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 775:../CMSIS/cmsis_gcc.h **** //{
 776:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("nop");
 777:../CMSIS/cmsis_gcc.h **** //}
 778:../CMSIS/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 779:../CMSIS/cmsis_gcc.h **** 
 780:../CMSIS/cmsis_gcc.h **** /**
 781:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Interrupt
 782:../CMSIS/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 783:../CMSIS/cmsis_gcc.h ****  */
 784:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 785:../CMSIS/cmsis_gcc.h **** //{
 786:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 787:../CMSIS/cmsis_gcc.h **** //}
 788:../CMSIS/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 789:../CMSIS/cmsis_gcc.h **** 
 790:../CMSIS/cmsis_gcc.h **** 
 791:../CMSIS/cmsis_gcc.h **** /**
 792:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Event
 793:../CMSIS/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 794:../CMSIS/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 795:../CMSIS/cmsis_gcc.h ****  */
 796:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 797:../CMSIS/cmsis_gcc.h **** //{
 798:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 799:../CMSIS/cmsis_gcc.h **** //}
 800:../CMSIS/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 801:../CMSIS/cmsis_gcc.h **** 
 802:../CMSIS/cmsis_gcc.h **** 
 803:../CMSIS/cmsis_gcc.h **** /**
 804:../CMSIS/cmsis_gcc.h ****   \brief   Send Event
 805:../CMSIS/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 806:../CMSIS/cmsis_gcc.h ****  */
 807:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 808:../CMSIS/cmsis_gcc.h **** //{
 809:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("sev");
 810:../CMSIS/cmsis_gcc.h **** //}
 811:../CMSIS/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 812:../CMSIS/cmsis_gcc.h **** 
 813:../CMSIS/cmsis_gcc.h **** 
 814:../CMSIS/cmsis_gcc.h **** /**
 815:../CMSIS/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 816:../CMSIS/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 817:../CMSIS/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 818:../CMSIS/cmsis_gcc.h ****            after the instruction has been completed.
 819:../CMSIS/cmsis_gcc.h ****  */
 820:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 821:../CMSIS/cmsis_gcc.h **** {
 822:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 823:../CMSIS/cmsis_gcc.h **** }
 824:../CMSIS/cmsis_gcc.h **** 
 825:../CMSIS/cmsis_gcc.h **** 
 826:../CMSIS/cmsis_gcc.h **** /**
 827:../CMSIS/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 828:../CMSIS/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 829:../CMSIS/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 830:../CMSIS/cmsis_gcc.h ****  */
 831:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 832:../CMSIS/cmsis_gcc.h **** {
 833:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 184              		.loc 3 833 0
 185              		.syntax unified
 186              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 187 0020 BFF34F8F 		dsb 0xF
 188              	@ 0 "" 2
 189              		.thumb
 190              		.syntax unified
 191              	.LBE45:
 192              	.LBE44:
2731:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2732:../drivers/fsl_enet.c ****         }
2733:../drivers/fsl_enet.c ****     }
2734:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2735:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2736:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2737:../drivers/fsl_enet.c ****     __DSB();
2738:../drivers/fsl_enet.c **** #endif
2739:../drivers/fsl_enet.c **** }
 193              		.loc 1 2739 0
 194 0024 38BD     		pop	{r3, r4, r5, pc}
 195              	.LVL13:
 196              	.L14:
2722:../drivers/fsl_enet.c ****         base->EIR = errMask;
 197              		.loc 1 2722 0
 198 0026 4568     		ldr	r5, [r0, #4]
 199 0028 25F01F45 		bic	r5, r5, #-1627389952
 200 002c 25F40005 		bic	r5, r5, #8388608
 201 0030 AD0C     		lsrs	r5, r5, #18
 202 0032 AD04     		lsls	r5, r5, #18
 203              	.LVL14:
2723:../drivers/fsl_enet.c ****         /* Callback function. */
 204              		.loc 1 2723 0
 205 0034 4560     		str	r5, [r0, #4]
2725:../drivers/fsl_enet.c ****         {
 206              		.loc 1 2725 0
 207 0036 002C     		cmp	r4, #0
 208 0038 F2D0     		beq	.L16
2730:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
 209              		.loc 1 2730 0
 210 003a 0B6A     		ldr	r3, [r1, #32]
 211 003c 0222     		movs	r2, #2
 212 003e EEE7     		b	.L21
 213              		.cfi_endproc
 214              	.LFE182:
 216              		.section	.text.ENET_UpdateReadBuffers.constprop.3,"ax",%progbits
 217              		.align	1
 218              		.syntax unified
 219              		.thumb
 220              		.thumb_func
 221              		.fpu fpv4-sp-d16
 223              	ENET_UpdateReadBuffers.constprop.3:
 224              	.LFB194:
1285:../drivers/fsl_enet.c **** {
 225              		.loc 1 1285 0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 0, uses_anonymous_args = 0
 229              		@ link register save eliminated.
 230              	.LVL15:
1291:../drivers/fsl_enet.c ****     /* Sets the receive buffer descriptor with the empty flag. */
 231              		.loc 1 1291 0
 232 0000 4B68     		ldr	r3, [r1, #4]
 233 0002 5A88     		ldrh	r2, [r3, #2]
 234 0004 02F40052 		and	r2, r2, #8192
 235 0008 5A80     		strh	r2, [r3, #2]	@ movhi
1293:../drivers/fsl_enet.c **** 
 236              		.loc 1 1293 0
 237 000a 5A88     		ldrh	r2, [r3, #2]
 238 000c 42F40042 		orr	r2, r2, #32768
 239 0010 5A80     		strh	r2, [r3, #2]	@ movhi
1296:../drivers/fsl_enet.c ****     {
 240              		.loc 1 1296 0
 241 0012 5A88     		ldrh	r2, [r3, #2]
 242 0014 9204     		lsls	r2, r2, #18
1298:../drivers/fsl_enet.c ****     }
 243              		.loc 1 1298 0
 244 0016 4CBF     		ite	mi
 245 0018 0B68     		ldrmi	r3, [r1]
1302:../drivers/fsl_enet.c ****     }
 246              		.loc 1 1302 0
 247 001a 0833     		addpl	r3, r3, #8
 248 001c 4B60     		str	r3, [r1, #4]
1309:../drivers/fsl_enet.c ****             break;
 249              		.loc 1 1309 0
 250 001e 4FF08073 		mov	r3, #16777216
 251 0022 0361     		str	r3, [r0, #16]
1323:../drivers/fsl_enet.c **** 
 252              		.loc 1 1323 0
 253 0024 7047     		bx	lr
 254              		.cfi_endproc
 255              	.LFE194:
 257              		.section	.text.ENET_GetInstance,"ax",%progbits
 258              		.align	1
 259              		.global	ENET_GetInstance
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
 263              		.fpu fpv4-sp-d16
 265              	ENET_GetInstance:
 266              	.LFB157:
 316:../drivers/fsl_enet.c ****     uint32_t instance;
 267              		.loc 1 316 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              		@ link register save eliminated.
 272              	.LVL16:
 331:../drivers/fsl_enet.c **** 
 273              		.loc 1 331 0
 274 0000 024B     		ldr	r3, .L27
 275 0002 C01A     		subs	r0, r0, r3
 276              	.LVL17:
 277 0004 18BF     		it	ne
 278 0006 0120     		movne	r0, #1
 279              	.LVL18:
 280 0008 7047     		bx	lr
 281              	.L28:
 282 000a 00BF     		.align	2
 283              	.L27:
 284 000c 00000C40 		.word	1074528256
 285              		.cfi_endproc
 286              	.LFE157:
 288              		.section	.text.ENET_GetDefaultConfig,"ax",%progbits
 289              		.align	1
 290              		.global	ENET_GetDefaultConfig
 291              		.syntax unified
 292              		.thumb
 293              		.thumb_func
 294              		.fpu fpv4-sp-d16
 296              	ENET_GetDefaultConfig:
 297              	.LFB158:
 334:../drivers/fsl_enet.c ****     /* Checks input parameter. */
 298              		.loc 1 334 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              	.LVL19:
 339:../drivers/fsl_enet.c **** 
 303              		.loc 1 339 0
 304 0000 1822     		movs	r2, #24
 334:../drivers/fsl_enet.c ****     /* Checks input parameter. */
 305              		.loc 1 334 0
 306 0002 08B5     		push	{r3, lr}
 307              		.cfi_def_cfa_offset 8
 308              		.cfi_offset 3, -8
 309              		.cfi_offset 14, -4
 339:../drivers/fsl_enet.c **** 
 310              		.loc 1 339 0
 311 0004 0021     		movs	r1, #0
 312 0006 FFF7FEFF 		bl	memset
 313              	.LVL20:
 345:../drivers/fsl_enet.c **** #endif
 314              		.loc 1 345 0
 315 000a 0122     		movs	r2, #1
 316 000c 8272     		strb	r2, [r0, #10]
 347:../drivers/fsl_enet.c ****     config->miiDuplex = kENET_MiiFullDuplex;
 317              		.loc 1 347 0
 318 000e C272     		strb	r2, [r0, #11]
 348:../drivers/fsl_enet.c **** 
 319              		.loc 1 348 0
 320 0010 0273     		strb	r2, [r0, #12]
 350:../drivers/fsl_enet.c **** 
 321              		.loc 1 350 0
 322 0012 8275     		strb	r2, [r0, #22]
 353:../drivers/fsl_enet.c **** }
 323              		.loc 1 353 0
 324 0014 40F2EE52 		movw	r2, #1518
 325 0018 0281     		strh	r2, [r0, #8]	@ movhi
 354:../drivers/fsl_enet.c **** 
 326              		.loc 1 354 0
 327 001a 08BD     		pop	{r3, pc}
 328              		.cfi_endproc
 329              	.LFE158:
 331              		.section	.text.ENET_Deinit,"ax",%progbits
 332              		.align	1
 333              		.global	ENET_Deinit
 334              		.syntax unified
 335              		.thumb
 336              		.thumb_func
 337              		.fpu fpv4-sp-d16
 339              	ENET_Deinit:
 340              	.LFB160:
 404:../drivers/fsl_enet.c ****     /* Disable interrupt. */
 341              		.loc 1 404 0
 342              		.cfi_startproc
 343              		@ args = 0, pretend = 0, frame = 0
 344              		@ frame_needed = 0, uses_anonymous_args = 0
 345              		@ link register save eliminated.
 346              	.LVL21:
 406:../drivers/fsl_enet.c **** 
 347              		.loc 1 406 0
 348 0000 0023     		movs	r3, #0
 349 0002 8360     		str	r3, [r0, #8]
 409:../drivers/fsl_enet.c **** 
 350              		.loc 1 409 0
 351 0004 436A     		ldr	r3, [r0, #36]
 352              	.LBB48:
 353              	.LBB49:
 354              		.file 4 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  53:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  54:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  55:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  56:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  57:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  58:../drivers/fsl_clock.h ****  *
  59:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  60:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  61:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  62:../drivers/fsl_clock.h ****  * disable parameter checking.
  63:../drivers/fsl_clock.h ****  */
  64:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  65:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  66:../drivers/fsl_clock.h **** #endif
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  69:../drivers/fsl_clock.h ****  *
  70:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  71:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  72:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  73:../drivers/fsl_clock.h ****  * the driver.
  74:../drivers/fsl_clock.h ****  *
  75:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  76:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  77:../drivers/fsl_clock.h ****  */
  78:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  79:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  80:../drivers/fsl_clock.h **** #endif
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*******************************************************************************
  83:../drivers/fsl_clock.h ****  * Definitions
  84:../drivers/fsl_clock.h ****  ******************************************************************************/
  85:../drivers/fsl_clock.h **** 
  86:../drivers/fsl_clock.h **** /*! @name Driver version */
  87:../drivers/fsl_clock.h **** /*@{*/
  88:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  89:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  90:../drivers/fsl_clock.h **** /*@}*/
  91:../drivers/fsl_clock.h **** 
  92:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  93:../drivers/fsl_clock.h ****  *
  94:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  95:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  96:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  97:../drivers/fsl_clock.h ****  * @code
  98:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  99:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
 100:../drivers/fsl_clock.h ****  * @endcode
 101:../drivers/fsl_clock.h ****  *
 102:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
 103:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 104:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 105:../drivers/fsl_clock.h ****  */
 106:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 107:../drivers/fsl_clock.h **** 
 108:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 109:../drivers/fsl_clock.h ****  *
 110:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 111:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 112:../drivers/fsl_clock.h ****  *
 113:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 114:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 115:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 116:../drivers/fsl_clock.h ****  */
 117:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief IRC48M clock frequency in Hz. */
 120:../drivers/fsl_clock.h **** #define MCG_INTERNAL_IRC_48M 48000000U
 121:../drivers/fsl_clock.h **** 
 122:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 123:../drivers/fsl_clock.h **** #define OSC0 OSC
 124:../drivers/fsl_clock.h **** #endif
 125:../drivers/fsl_clock.h **** 
 126:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 127:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 128:../drivers/fsl_clock.h ****     {                  \
 129:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 130:../drivers/fsl_clock.h ****     }
 131:../drivers/fsl_clock.h **** 
 132:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 133:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 134:../drivers/fsl_clock.h ****     {               \
 135:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 136:../drivers/fsl_clock.h ****     }
 137:../drivers/fsl_clock.h **** 
 138:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ENET. */
 139:../drivers/fsl_clock.h **** #define ENET_CLOCKS  \
 140:../drivers/fsl_clock.h ****     {                \
 141:../drivers/fsl_clock.h ****         kCLOCK_Enet0 \
 142:../drivers/fsl_clock.h ****     }
 143:../drivers/fsl_clock.h **** 
 144:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 145:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 146:../drivers/fsl_clock.h ****     {                                                                        \
 147:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 148:../drivers/fsl_clock.h ****     }
 149:../drivers/fsl_clock.h **** 
 150:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 151:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 152:../drivers/fsl_clock.h ****     {               \
 153:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 154:../drivers/fsl_clock.h ****     }
 155:../drivers/fsl_clock.h **** 
 156:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXBUS. */
 157:../drivers/fsl_clock.h **** #define FLEXBUS_CLOCKS  \
 158:../drivers/fsl_clock.h ****     {                   \
 159:../drivers/fsl_clock.h ****         kCLOCK_Flexbus0 \
 160:../drivers/fsl_clock.h ****     }
 161:../drivers/fsl_clock.h **** 
 162:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EWM. */
 163:../drivers/fsl_clock.h **** #define EWM_CLOCKS  \
 164:../drivers/fsl_clock.h ****     {               \
 165:../drivers/fsl_clock.h ****         kCLOCK_Ewm0 \
 166:../drivers/fsl_clock.h ****     }
 167:../drivers/fsl_clock.h **** 
 168:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 169:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 170:../drivers/fsl_clock.h ****     {               \
 171:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 172:../drivers/fsl_clock.h ****     }
 173:../drivers/fsl_clock.h **** 
 174:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DSPI. */
 175:../drivers/fsl_clock.h **** #define DSPI_CLOCKS                           \
 176:../drivers/fsl_clock.h ****     {                                         \
 177:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1, kCLOCK_Spi2 \
 178:../drivers/fsl_clock.h ****     }
 179:../drivers/fsl_clock.h **** 
 180:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 181:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 182:../drivers/fsl_clock.h ****     {                 \
 183:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 184:../drivers/fsl_clock.h ****     }
 185:../drivers/fsl_clock.h **** 
 186:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SDHC. */
 187:../drivers/fsl_clock.h **** #define SDHC_CLOCKS  \
 188:../drivers/fsl_clock.h ****     {                \
 189:../drivers/fsl_clock.h ****         kCLOCK_Sdhc0 \
 190:../drivers/fsl_clock.h ****     }
 191:../drivers/fsl_clock.h **** 
 192:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTM. */
 193:../drivers/fsl_clock.h **** #define FTM_CLOCKS                                         \
 194:../drivers/fsl_clock.h ****     {                                                      \
 195:../drivers/fsl_clock.h ****         kCLOCK_Ftm0, kCLOCK_Ftm1, kCLOCK_Ftm2, kCLOCK_Ftm3 \
 196:../drivers/fsl_clock.h ****     }
 197:../drivers/fsl_clock.h **** 
 198:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for EDMA. */
 199:../drivers/fsl_clock.h **** #define EDMA_CLOCKS \
 200:../drivers/fsl_clock.h ****     {               \
 201:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 202:../drivers/fsl_clock.h ****     }
 203:../drivers/fsl_clock.h **** 
 204:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXCAN. */
 205:../drivers/fsl_clock.h **** #define FLEXCAN_CLOCKS  \
 206:../drivers/fsl_clock.h ****     {                   \
 207:../drivers/fsl_clock.h ****         kCLOCK_Flexcan0 \
 208:../drivers/fsl_clock.h ****     }
 209:../drivers/fsl_clock.h **** 
 210:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 211:../drivers/fsl_clock.h **** #define DAC_CLOCKS               \
 212:../drivers/fsl_clock.h ****     {                            \
 213:../drivers/fsl_clock.h ****         kCLOCK_Dac0, kCLOCK_Dac1 \
 214:../drivers/fsl_clock.h ****     }
 215:../drivers/fsl_clock.h **** 
 216:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 217:../drivers/fsl_clock.h **** #define ADC16_CLOCKS             \
 218:../drivers/fsl_clock.h ****     {                            \
 219:../drivers/fsl_clock.h ****         kCLOCK_Adc0, kCLOCK_Adc1 \
 220:../drivers/fsl_clock.h ****     }
 221:../drivers/fsl_clock.h **** 
 222:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for MPU. */
 223:../drivers/fsl_clock.h **** #define SYSMPU_CLOCKS  \
 224:../drivers/fsl_clock.h ****     {                  \
 225:../drivers/fsl_clock.h ****         kCLOCK_Sysmpu0 \
 226:../drivers/fsl_clock.h ****     }
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 229:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 230:../drivers/fsl_clock.h ****     {                \
 231:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 232:../drivers/fsl_clock.h ****     }
 233:../drivers/fsl_clock.h **** 
 234:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMT. */
 235:../drivers/fsl_clock.h **** #define CMT_CLOCKS  \
 236:../drivers/fsl_clock.h ****     {               \
 237:../drivers/fsl_clock.h ****         kCLOCK_Cmt0 \
 238:../drivers/fsl_clock.h ****     }
 239:../drivers/fsl_clock.h **** 
 240:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 241:../drivers/fsl_clock.h **** #define UART_CLOCKS                                                                        \
 242:../drivers/fsl_clock.h ****     {                                                                                      \
 243:../drivers/fsl_clock.h ****         kCLOCK_Uart0, kCLOCK_Uart1, kCLOCK_Uart2, kCLOCK_Uart3, kCLOCK_Uart4, kCLOCK_Uart5 \
 244:../drivers/fsl_clock.h ****     }
 245:../drivers/fsl_clock.h **** 
 246:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RNGA. */
 247:../drivers/fsl_clock.h **** #define RNGA_CLOCKS  \
 248:../drivers/fsl_clock.h ****     {                \
 249:../drivers/fsl_clock.h ****         kCLOCK_Rnga0 \
 250:../drivers/fsl_clock.h ****     }
 251:../drivers/fsl_clock.h **** 
 252:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CRC. */
 253:../drivers/fsl_clock.h **** #define CRC_CLOCKS  \
 254:../drivers/fsl_clock.h ****     {               \
 255:../drivers/fsl_clock.h ****         kCLOCK_Crc0 \
 256:../drivers/fsl_clock.h ****     }
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 259:../drivers/fsl_clock.h **** #define I2C_CLOCKS                            \
 260:../drivers/fsl_clock.h ****     {                                         \
 261:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1, kCLOCK_I2c2 \
 262:../drivers/fsl_clock.h ****     }
 263:../drivers/fsl_clock.h **** 
 264:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PDB. */
 265:../drivers/fsl_clock.h **** #define PDB_CLOCKS  \
 266:../drivers/fsl_clock.h ****     {               \
 267:../drivers/fsl_clock.h ****         kCLOCK_Pdb0 \
 268:../drivers/fsl_clock.h ****     }
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 271:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 272:../drivers/fsl_clock.h ****     {               \
 273:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 274:../drivers/fsl_clock.h ****     }
 275:../drivers/fsl_clock.h **** 
 276:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 277:../drivers/fsl_clock.h **** #define CMP_CLOCKS                            \
 278:../drivers/fsl_clock.h ****     {                                         \
 279:../drivers/fsl_clock.h ****         kCLOCK_Cmp0, kCLOCK_Cmp1, kCLOCK_Cmp2 \
 280:../drivers/fsl_clock.h ****     }
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** /*!
 283:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 284:../drivers/fsl_clock.h ****  */
 285:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 288:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 289:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 292:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 293:../drivers/fsl_clock.h **** #define I2C2_CLK_SRC BUS_CLK
 294:../drivers/fsl_clock.h **** #define DSPI0_CLK_SRC BUS_CLK
 295:../drivers/fsl_clock.h **** #define DSPI1_CLK_SRC BUS_CLK
 296:../drivers/fsl_clock.h **** #define DSPI2_CLK_SRC BUS_CLK
 297:../drivers/fsl_clock.h **** #define UART0_CLK_SRC SYS_CLK
 298:../drivers/fsl_clock.h **** #define UART1_CLK_SRC SYS_CLK
 299:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 300:../drivers/fsl_clock.h **** #define UART3_CLK_SRC BUS_CLK
 301:../drivers/fsl_clock.h **** #define UART4_CLK_SRC BUS_CLK
 302:../drivers/fsl_clock.h **** #define UART5_CLK_SRC BUS_CLK
 303:../drivers/fsl_clock.h **** 
 304:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 305:../drivers/fsl_clock.h **** typedef enum _clock_name
 306:../drivers/fsl_clock.h **** {
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 309:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 310:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 311:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 312:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 313:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 314:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 315:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 316:../drivers/fsl_clock.h **** 
 317:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 318:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 319:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 320:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 321:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 322:../drivers/fsl_clock.h **** 
 323:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 324:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 325:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 326:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 327:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 328:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 329:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 330:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 331:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 332:../drivers/fsl_clock.h **** 
 333:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 334:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 335:../drivers/fsl_clock.h **** 
 336:../drivers/fsl_clock.h **** } clock_name_t;
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 339:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U),   /*!< Use PLL0.      */
 342:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcIrc48M = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(3U), /*!< Use IRC48M.    */
 343:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                               /*!< Use USB_CLKIN. */
 344:../drivers/fsl_clock.h **** } clock_usb_src_t;
 345:../drivers/fsl_clock.h **** 
 346:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 347:../drivers/fsl_clock.h **** 
 348:../drivers/fsl_clock.h ****  clock_gate_t definition:
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h ****  31                              16                              0
 351:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 352:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 353:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 354:../drivers/fsl_clock.h **** 
 355:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 356:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 357:../drivers/fsl_clock.h **** 
 358:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 361:../drivers/fsl_clock.h **** 
 362:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 363:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 364:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 365:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 366:../drivers/fsl_clock.h **** 
 367:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 368:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 369:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 370:../drivers/fsl_clock.h **** 
 371:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 372:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 373:../drivers/fsl_clock.h **** 
 374:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 375:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 376:../drivers/fsl_clock.h **** {
 377:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 378:../drivers/fsl_clock.h ****     kCLOCK_I2c2 = CLK_GATE_DEFINE(0x1028U, 6U),
 379:../drivers/fsl_clock.h ****     kCLOCK_Uart4 = CLK_GATE_DEFINE(0x1028U, 10U),
 380:../drivers/fsl_clock.h ****     kCLOCK_Uart5 = CLK_GATE_DEFINE(0x1028U, 11U),
 381:../drivers/fsl_clock.h **** 
 382:../drivers/fsl_clock.h ****     kCLOCK_Enet0 = CLK_GATE_DEFINE(0x102CU, 0U),
 383:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x102CU, 12U),
 384:../drivers/fsl_clock.h ****     kCLOCK_Dac1 = CLK_GATE_DEFINE(0x102CU, 13U),
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h ****     kCLOCK_Spi2 = CLK_GATE_DEFINE(0x1030U, 12U),
 387:../drivers/fsl_clock.h ****     kCLOCK_Sdhc0 = CLK_GATE_DEFINE(0x1030U, 17U),
 388:../drivers/fsl_clock.h ****     kCLOCK_Ftm3 = CLK_GATE_DEFINE(0x1030U, 25U),
 389:../drivers/fsl_clock.h ****     kCLOCK_Adc1 = CLK_GATE_DEFINE(0x1030U, 27U),
 390:../drivers/fsl_clock.h **** 
 391:../drivers/fsl_clock.h ****     kCLOCK_Ewm0 = CLK_GATE_DEFINE(0x1034U, 1U),
 392:../drivers/fsl_clock.h ****     kCLOCK_Cmt0 = CLK_GATE_DEFINE(0x1034U, 2U),
 393:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 394:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 395:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 396:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 397:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 398:../drivers/fsl_clock.h ****     kCLOCK_Uart3 = CLK_GATE_DEFINE(0x1034U, 13U),
 399:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 400:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 401:../drivers/fsl_clock.h ****     kCLOCK_Cmp1 = CLK_GATE_DEFINE(0x1034U, 19U),
 402:../drivers/fsl_clock.h ****     kCLOCK_Cmp2 = CLK_GATE_DEFINE(0x1034U, 19U),
 403:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 404:../drivers/fsl_clock.h **** 
 405:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 406:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 407:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 408:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 409:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 410:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 411:../drivers/fsl_clock.h **** 
 412:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 413:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 414:../drivers/fsl_clock.h ****     kCLOCK_Flexcan0 = CLK_GATE_DEFINE(0x103CU, 4U),
 415:../drivers/fsl_clock.h ****     kCLOCK_Rnga0 = CLK_GATE_DEFINE(0x103CU, 9U),
 416:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x103CU, 12U),
 417:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x103CU, 13U),
 418:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 419:../drivers/fsl_clock.h ****     kCLOCK_Crc0 = CLK_GATE_DEFINE(0x103CU, 18U),
 420:../drivers/fsl_clock.h ****     kCLOCK_Usbdcd0 = CLK_GATE_DEFINE(0x103CU, 21U),
 421:../drivers/fsl_clock.h ****     kCLOCK_Pdb0 = CLK_GATE_DEFINE(0x103CU, 22U),
 422:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 423:../drivers/fsl_clock.h ****     kCLOCK_Ftm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 424:../drivers/fsl_clock.h ****     kCLOCK_Ftm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 425:../drivers/fsl_clock.h ****     kCLOCK_Ftm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 426:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 427:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 428:../drivers/fsl_clock.h **** 
 429:../drivers/fsl_clock.h ****     kCLOCK_Flexbus0 = CLK_GATE_DEFINE(0x1040U, 0U),
 430:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 1U),
 431:../drivers/fsl_clock.h ****     kCLOCK_Sysmpu0 = CLK_GATE_DEFINE(0x1040U, 2U),
 432:../drivers/fsl_clock.h **** } clock_ip_name_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 435:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 436:../drivers/fsl_clock.h **** {
 437:../drivers/fsl_clock.h ****     uint8_t pllFllSel; /*!< PLL/FLL/IRC48M selection.    */
 438:../drivers/fsl_clock.h ****     uint8_t er32kSrc;  /*!< ERCLK32K source selection.   */
 439:../drivers/fsl_clock.h ****     uint32_t clkdiv1;  /*!< SIM_CLKDIV1.                 */
 440:../drivers/fsl_clock.h **** } sim_clock_config_t;
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 443:../drivers/fsl_clock.h **** typedef enum _osc_mode
 444:../drivers/fsl_clock.h **** {
 445:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 446:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 447:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 448:../drivers/fsl_clock.h **** #else
 449:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 450:../drivers/fsl_clock.h **** #endif
 451:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 452:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 453:../drivers/fsl_clock.h ****                            |
 454:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 455:../drivers/fsl_clock.h **** #else
 456:../drivers/fsl_clock.h ****                            |
 457:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 458:../drivers/fsl_clock.h **** #endif
 459:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 460:../drivers/fsl_clock.h ****                            |
 461:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 462:../drivers/fsl_clock.h **** #else
 463:../drivers/fsl_clock.h ****                            |
 464:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 465:../drivers/fsl_clock.h **** #endif
 466:../drivers/fsl_clock.h **** } osc_mode_t;
 467:../drivers/fsl_clock.h **** 
 468:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 469:../drivers/fsl_clock.h **** enum _osc_cap_load
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 472:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 473:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 474:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 475:../drivers/fsl_clock.h **** };
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 478:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 481:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 482:../drivers/fsl_clock.h **** };
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 485:../drivers/fsl_clock.h **** typedef struct _oscer_config
 486:../drivers/fsl_clock.h **** {
 487:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 488:../drivers/fsl_clock.h **** 
 489:../drivers/fsl_clock.h **** } oscer_config_t;
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*!
 492:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 493:../drivers/fsl_clock.h ****  *
 494:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 495:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 496:../drivers/fsl_clock.h ****  * according to the board setting:
 497:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 498:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 499:../drivers/fsl_clock.h ****  */
 500:../drivers/fsl_clock.h **** typedef struct _osc_config
 501:../drivers/fsl_clock.h **** {
 502:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 503:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 504:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 505:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 506:../drivers/fsl_clock.h **** } osc_config_t;
 507:../drivers/fsl_clock.h **** 
 508:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 509:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 510:../drivers/fsl_clock.h **** {
 511:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 512:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 513:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 514:../drivers/fsl_clock.h **** 
 515:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 516:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 517:../drivers/fsl_clock.h **** {
 518:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 519:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 520:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 521:../drivers/fsl_clock.h **** 
 522:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 523:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 524:../drivers/fsl_clock.h **** {
 525:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 526:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 527:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 528:../drivers/fsl_clock.h **** 
 529:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 530:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 531:../drivers/fsl_clock.h **** {
 532:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 533:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 534:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 535:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 536:../drivers/fsl_clock.h **** } mcg_drs_t;
 537:../drivers/fsl_clock.h **** 
 538:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 539:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 540:../drivers/fsl_clock.h **** {
 541:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 542:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 543:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 544:../drivers/fsl_clock.h **** 
 545:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 546:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 547:../drivers/fsl_clock.h **** {
 548:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 549:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 550:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 551:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 552:../drivers/fsl_clock.h **** 
 553:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 554:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 555:../drivers/fsl_clock.h **** {
 556:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 557:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 558:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 559:../drivers/fsl_clock.h **** 
 560:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 561:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 562:../drivers/fsl_clock.h **** {
 563:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 564:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 565:../drivers/fsl_clock.h ****     kMCG_OscselIrc  /*!< Selects 48 MHz IRC Oscillator      */
 566:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 567:../drivers/fsl_clock.h **** 
 568:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 569:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 570:../drivers/fsl_clock.h **** {
 571:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 572:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 573:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 576:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 577:../drivers/fsl_clock.h **** {
 578:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 579:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 580:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 581:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 582:../drivers/fsl_clock.h **** 
 583:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 584:../drivers/fsl_clock.h **** enum _mcg_status
 585:../drivers/fsl_clock.h **** {
 586:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 587:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 588:../drivers/fsl_clock.h ****                                                                                function. */
 589:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 590:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 591:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 592:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 593:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 594:../drivers/fsl_clock.h ****                                                                                it is in use. */
 595:../drivers/fsl_clock.h **** };
 596:../drivers/fsl_clock.h **** 
 597:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 598:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 599:../drivers/fsl_clock.h **** {
 600:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U),   /*!< OSC0 lost.         */
 601:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U),   /*!< OSC0 crystal initialized. */
 602:../drivers/fsl_clock.h ****     kMCG_RtcOscLostFlag = (1U << 4U), /*!< RTC OSC lost.      */
 603:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U),   /*!< PLL0 lost.         */
 604:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U),   /*!< PLL0 locked.       */
 605:../drivers/fsl_clock.h **** };
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 608:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 609:../drivers/fsl_clock.h **** {
 610:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 611:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 612:../drivers/fsl_clock.h **** };
 613:../drivers/fsl_clock.h **** 
 614:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 615:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 616:../drivers/fsl_clock.h **** {
 617:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 618:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 619:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 620:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 621:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 622:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 623:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 624:../drivers/fsl_clock.h **** };
 625:../drivers/fsl_clock.h **** 
 626:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 627:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 628:../drivers/fsl_clock.h **** {
 629:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 630:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 631:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 632:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 633:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 634:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 635:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 636:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 637:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 638:../drivers/fsl_clock.h **** } mcg_mode_t;
 639:../drivers/fsl_clock.h **** 
 640:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 641:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 642:../drivers/fsl_clock.h **** {
 643:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 644:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 645:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 646:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 647:../drivers/fsl_clock.h **** 
 648:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 649:../drivers/fsl_clock.h ****  *
 650:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 651:../drivers/fsl_clock.h ****  * according to the board setting:
 652:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 653:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 654:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 655:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 656:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 657:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** typedef struct _mcg_config
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 662:../drivers/fsl_clock.h **** 
 663:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 664:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 665:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 666:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 667:../drivers/fsl_clock.h **** 
 668:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 669:../drivers/fsl_clock.h ****     uint8_t frdiv;       /*!< Divider MCG_C1[FRDIV].      */
 670:../drivers/fsl_clock.h ****     mcg_drs_t drs;       /*!< DCO range MCG_C4[DRST_DRS]. */
 671:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32;   /*!< MCG_C4[DMX32].              */
 672:../drivers/fsl_clock.h ****     mcg_oscsel_t oscsel; /*!< OSC select MCG_C7[OSCSEL].  */
 673:../drivers/fsl_clock.h **** 
 674:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 675:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 676:../drivers/fsl_clock.h **** 
 677:../drivers/fsl_clock.h **** } mcg_config_t;
 678:../drivers/fsl_clock.h **** 
 679:../drivers/fsl_clock.h **** /*******************************************************************************
 680:../drivers/fsl_clock.h ****  * API
 681:../drivers/fsl_clock.h ****  ******************************************************************************/
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 684:../drivers/fsl_clock.h **** extern "C" {
 685:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 686:../drivers/fsl_clock.h **** 
 687:../drivers/fsl_clock.h **** /*!
 688:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 689:../drivers/fsl_clock.h ****  *
 690:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 691:../drivers/fsl_clock.h ****  */
 692:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 693:../drivers/fsl_clock.h **** {
 694:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 695:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 696:../drivers/fsl_clock.h **** }
 697:../drivers/fsl_clock.h **** 
 698:../drivers/fsl_clock.h **** /*!
 699:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 700:../drivers/fsl_clock.h ****  *
 701:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 702:../drivers/fsl_clock.h ****  */
 703:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 704:../drivers/fsl_clock.h **** {
 705:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 706:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 355              		.loc 4 706 0
 356 0006 044A     		ldr	r2, .L31
 357              	.LBE49:
 358              	.LBE48:
 409:../drivers/fsl_enet.c **** 
 359              		.loc 1 409 0
 360 0008 23F00203 		bic	r3, r3, #2
 361 000c 4362     		str	r3, [r0, #36]
 362              	.LVL22:
 363              	.LBB51:
 364              	.LBB50:
 365              		.loc 4 706 0
 366 000e 1368     		ldr	r3, [r2]
 367 0010 23F00103 		bic	r3, r3, #1
 368 0014 1360     		str	r3, [r2]
 369              	.LVL23:
 370              	.LBE50:
 371              	.LBE51:
 416:../drivers/fsl_enet.c **** 
 372              		.loc 1 416 0
 373 0016 7047     		bx	lr
 374              	.L32:
 375              		.align	2
 376              	.L31:
 377 0018 2C800440 		.word	1074036780
 378              		.cfi_endproc
 379              	.LFE160:
 381              		.section	.text.ENET_SetCallback,"ax",%progbits
 382              		.align	1
 383              		.global	ENET_SetCallback
 384              		.syntax unified
 385              		.thumb
 386              		.thumb_func
 387              		.fpu fpv4-sp-d16
 389              	ENET_SetCallback:
 390              	.LFB161:
 419:../drivers/fsl_enet.c ****     assert(handle);
 391              		.loc 1 419 0
 392              		.cfi_startproc
 393              		@ args = 0, pretend = 0, frame = 0
 394              		@ frame_needed = 0, uses_anonymous_args = 0
 395              		@ link register save eliminated.
 396              	.LVL24:
 424:../drivers/fsl_enet.c **** }
 397              		.loc 1 424 0
 398 0000 C0E90712 		strd	r1, r2, [r0, #28]
 425:../drivers/fsl_enet.c **** 
 399              		.loc 1 425 0
 400 0004 7047     		bx	lr
 401              		.cfi_endproc
 402              	.LFE161:
 404              		.section	.text.ENET_SetMII,"ax",%progbits
 405              		.align	1
 406              		.global	ENET_SetMII
 407              		.syntax unified
 408              		.thumb
 409              		.thumb_func
 410              		.fpu fpv4-sp-d16
 412              	ENET_SetMII:
 413              	.LFB167:
 866:../drivers/fsl_enet.c ****     uint32_t rcr = base->RCR;
 414              		.loc 1 866 0
 415              		.cfi_startproc
 416              		@ args = 0, pretend = 0, frame = 0
 417              		@ frame_needed = 0, uses_anonymous_args = 0
 418              	.LVL25:
 419 0000 10B5     		push	{r4, lr}
 420              		.cfi_def_cfa_offset 8
 421              		.cfi_offset 4, -8
 422              		.cfi_offset 14, -4
 867:../drivers/fsl_enet.c ****     uint32_t tcr = base->TCR;
 423              		.loc 1 867 0
 424 0002 D0F88430 		ldr	r3, [r0, #132]
 425              	.LVL26:
 868:../drivers/fsl_enet.c **** 
 426              		.loc 1 868 0
 427 0006 D0F8C440 		ldr	r4, [r0, #196]
 428              	.LVL27:
 887:../drivers/fsl_enet.c ****     {
 429              		.loc 1 887 0
 430 000a 59B9     		cbnz	r1, .L35
 889:../drivers/fsl_enet.c ****     }
 431              		.loc 1 889 0
 432 000c 43F40073 		orr	r3, r3, #512
 433              	.LVL28:
 434              	.L36:
 896:../drivers/fsl_enet.c ****     {
 435              		.loc 1 896 0
 436 0010 5AB9     		cbnz	r2, .L37
 898:../drivers/fsl_enet.c ****         tcr &= ~ENET_TCR_FDEN_MASK;
 437              		.loc 1 898 0
 438 0012 43F00203 		orr	r3, r3, #2
 439              	.LVL29:
 899:../drivers/fsl_enet.c ****     }
 440              		.loc 1 899 0
 441 0016 24F00404 		bic	r4, r4, #4
 442              	.LVL30:
 443              	.L38:
 907:../drivers/fsl_enet.c ****     base->TCR = tcr;
 444              		.loc 1 907 0
 445 001a C0F88430 		str	r3, [r0, #132]
 908:../drivers/fsl_enet.c **** }
 446              		.loc 1 908 0
 447 001e C0F8C440 		str	r4, [r0, #196]
 909:../drivers/fsl_enet.c **** 
 448              		.loc 1 909 0
 449 0022 10BD     		pop	{r4, pc}
 450              	.LVL31:
 451              	.L35:
 893:../drivers/fsl_enet.c ****     }
 452              		.loc 1 893 0
 453 0024 23F40073 		bic	r3, r3, #512
 454              	.LVL32:
 455 0028 F2E7     		b	.L36
 456              	.L37:
 903:../drivers/fsl_enet.c ****         tcr |= ENET_TCR_FDEN_MASK;
 457              		.loc 1 903 0
 458 002a 23F00203 		bic	r3, r3, #2
 459              	.LVL33:
 904:../drivers/fsl_enet.c ****     }
 460              		.loc 1 904 0
 461 002e 44F00404 		orr	r4, r4, #4
 462              	.LVL34:
 463 0032 F2E7     		b	.L38
 464              		.cfi_endproc
 465              	.LFE167:
 467              		.section	.text.ENET_SetMacAddr,"ax",%progbits
 468              		.align	1
 469              		.global	ENET_SetMacAddr
 470              		.syntax unified
 471              		.thumb
 472              		.thumb_func
 473              		.fpu fpv4-sp-d16
 475              	ENET_SetMacAddr:
 476              	.LFB168:
 912:../drivers/fsl_enet.c ****     uint32_t address;
 477              		.loc 1 912 0
 478              		.cfi_startproc
 479              		@ args = 0, pretend = 0, frame = 0
 480              		@ frame_needed = 0, uses_anonymous_args = 0
 481              		@ link register save eliminated.
 482              	.LVL35:
 483 0000 0B68     		ldr	r3, [r1]	@ unaligned
 484 0002 1BBA     		rev	r3, r3
 485              	.LVL36:
 918:../drivers/fsl_enet.c ****     /* Set physical address high register. */
 486              		.loc 1 918 0
 487 0004 C0F8E430 		str	r3, [r0, #228]
 488              	.LVL37:
 921:../drivers/fsl_enet.c **** }
 489              		.loc 1 921 0
 490 0008 8B88     		ldrh	r3, [r1, #4]	@ unaligned
 491 000a 5BBA     		rev16	r3, r3
 492 000c 1B04     		lsls	r3, r3, #16
 493 000e C0F8E830 		str	r3, [r0, #232]
 494              	.LVL38:
 922:../drivers/fsl_enet.c **** 
 495              		.loc 1 922 0
 496 0012 7047     		bx	lr
 497              		.cfi_endproc
 498              	.LFE168:
 500              		.section	.text.ENET_GetMacAddr,"ax",%progbits
 501              		.align	1
 502              		.global	ENET_GetMacAddr
 503              		.syntax unified
 504              		.thumb
 505              		.thumb_func
 506              		.fpu fpv4-sp-d16
 508              	ENET_GetMacAddr:
 509              	.LFB169:
 925:../drivers/fsl_enet.c ****     assert(macAddr);
 510              		.loc 1 925 0
 511              		.cfi_startproc
 512              		@ args = 0, pretend = 0, frame = 0
 513              		@ frame_needed = 0, uses_anonymous_args = 0
 514              		@ link register save eliminated.
 515              	.LVL39:
 931:../drivers/fsl_enet.c ****     macAddr[0] = 0xFFU & (address >> 24U);
 516              		.loc 1 931 0
 517 0000 D0F8E430 		ldr	r3, [r0, #228]
 518              	.LVL40:
 935:../drivers/fsl_enet.c **** 
 519              		.loc 1 935 0
 520 0004 CB70     		strb	r3, [r1, #3]
 932:../drivers/fsl_enet.c ****     macAddr[1] = 0xFFU & (address >> 16U);
 521              		.loc 1 932 0
 522 0006 1A0E     		lsrs	r2, r3, #24
 523 0008 0A70     		strb	r2, [r1]
 933:../drivers/fsl_enet.c ****     macAddr[2] = 0xFFU & (address >> 8U);
 524              		.loc 1 933 0
 525 000a 1A0C     		lsrs	r2, r3, #16
 526 000c 4A70     		strb	r2, [r1, #1]
 934:../drivers/fsl_enet.c ****     macAddr[3] = 0xFFU & address;
 527              		.loc 1 934 0
 528 000e 1A0A     		lsrs	r2, r3, #8
 529 0010 8A70     		strb	r2, [r1, #2]
 938:../drivers/fsl_enet.c ****     macAddr[4] = 0xFFU & (address >> 8U);
 530              		.loc 1 938 0
 531 0012 D0F8E830 		ldr	r3, [r0, #232]
 532              	.LVL41:
 939:../drivers/fsl_enet.c ****     macAddr[5] = 0xFFU & address;
 533              		.loc 1 939 0
 534 0016 1A0E     		lsrs	r2, r3, #24
 938:../drivers/fsl_enet.c ****     macAddr[4] = 0xFFU & (address >> 8U);
 535              		.loc 1 938 0
 536 0018 1B0C     		lsrs	r3, r3, #16
 537              	.LVL42:
 939:../drivers/fsl_enet.c ****     macAddr[5] = 0xFFU & address;
 538              		.loc 1 939 0
 539 001a 0A71     		strb	r2, [r1, #4]
 940:../drivers/fsl_enet.c **** }
 540              		.loc 1 940 0
 541 001c 4B71     		strb	r3, [r1, #5]
 941:../drivers/fsl_enet.c **** 
 542              		.loc 1 941 0
 543 001e 7047     		bx	lr
 544              		.cfi_endproc
 545              	.LFE169:
 547              		.section	.text.ENET_SetSMI,"ax",%progbits
 548              		.align	1
 549              		.global	ENET_SetSMI
 550              		.syntax unified
 551              		.thumb
 552              		.thumb_func
 553              		.fpu fpv4-sp-d16
 555              	ENET_SetSMI:
 556              	.LFB170:
 944:../drivers/fsl_enet.c ****     assert(srcClock_Hz);
 557              		.loc 1 944 0
 558              		.cfi_startproc
 559              		@ args = 0, pretend = 0, frame = 0
 560              		@ frame_needed = 0, uses_anonymous_args = 0
 561              	.LVL43:
 562 0000 10B5     		push	{r4, lr}
 563              		.cfi_def_cfa_offset 8
 564              		.cfi_offset 4, -8
 565              		.cfi_offset 14, -4
 954:../drivers/fsl_enet.c ****     /* Build the configuration for MDC/MDIO control. */
 566              		.loc 1 954 0
 567 0002 0D4C     		ldr	r4, .L44
 568 0004 B4FBF1F4 		udiv	r4, r4, r1
 569              	.LVL44:
 570 0008 04F10903 		add	r3, r4, #9
 571 000c B3FBF4F3 		udiv	r3, r3, r4
 572 0010 013B     		subs	r3, r3, #1
 573              	.LVL45:
 956:../drivers/fsl_enet.c ****     base->MSCR = mscr;
 574              		.loc 1 956 0
 575 0012 1B02     		lsls	r3, r3, #8
 576              	.LVL46:
 952:../drivers/fsl_enet.c ****     /* Calculate the hold time on the MDIO output. */
 577              		.loc 1 952 0
 578 0014 094C     		ldr	r4, .L44+4
 579              	.LVL47:
 580 0016 B1FBF4F1 		udiv	r1, r1, r4
 581              	.LVL48:
 956:../drivers/fsl_enet.c ****     base->MSCR = mscr;
 582              		.loc 1 956 0
 583 001a 4900     		lsls	r1, r1, #1
 584              	.LVL49:
 585 001c 002A     		cmp	r2, #0
 586 001e 03F4E063 		and	r3, r3, #1792
 587 0022 01F07E01 		and	r1, r1, #126
 588 0026 43EA0103 		orr	r3, r3, r1
 589 002a 14BF     		ite	ne
 590 002c 8022     		movne	r2, #128
 591              	.LVL50:
 592 002e 0022     		moveq	r2, #0
 593 0030 1343     		orrs	r3, r3, r2
 594              	.LVL51:
 957:../drivers/fsl_enet.c **** }
 595              		.loc 1 957 0
 596 0032 4364     		str	r3, [r0, #68]
 958:../drivers/fsl_enet.c **** 
 597              		.loc 1 958 0
 598 0034 10BD     		pop	{r4, pc}
 599              	.L45:
 600 0036 00BF     		.align	2
 601              	.L44:
 602 0038 00CA9A3B 		.word	1000000000
 603 003c 404B4C00 		.word	5000000
 604              		.cfi_endproc
 605              	.LFE170:
 607              		.section	.text.ENET_Init,"ax",%progbits
 608              		.align	1
 609              		.global	ENET_Init
 610              		.syntax unified
 611              		.thumb
 612              		.thumb_func
 613              		.fpu fpv4-sp-d16
 615              	ENET_Init:
 616              	.LFB159:
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 617              		.loc 1 362 0
 618              		.cfi_startproc
 619              		@ args = 8, pretend = 0, frame = 8
 620              		@ frame_needed = 0, uses_anonymous_args = 0
 621              	.LVL52:
 622 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 623              		.cfi_def_cfa_offset 48
 624              		.cfi_offset 4, -36
 625              		.cfi_offset 5, -32
 626              		.cfi_offset 6, -28
 627              		.cfi_offset 7, -24
 628              		.cfi_offset 8, -20
 629              		.cfi_offset 9, -16
 630              		.cfi_offset 10, -12
 631              		.cfi_offset 11, -8
 632              		.cfi_offset 14, -4
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 633              		.loc 1 362 0
 634 0004 1546     		mov	r5, r2
 635              	.LVL53:
 636              	.LBB83:
 637              	.LBB84:
 695:../drivers/fsl_clock.h **** }
 638              		.loc 4 695 0
 639 0006 AA4A     		ldr	r2, .L117
 640              	.LVL54:
 641              	.LBE84:
 642              	.LBE83:
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 643              		.loc 1 362 0
 644 0008 1E46     		mov	r6, r3
 645              	.LBB86:
 646              	.LBB85:
 695:../drivers/fsl_clock.h **** }
 647              		.loc 4 695 0
 648 000a 1368     		ldr	r3, [r2]
 649              	.LVL55:
 650 000c 43F00103 		orr	r3, r3, #1
 651 0010 1360     		str	r3, [r2]
 652              	.LVL56:
 653              	.LBE85:
 654              	.LBE86:
 655              	.LBB87:
 656              	.LBB88:
 745:../drivers/fsl_enet.h **** }
 657              		.loc 2 745 0
 658 0012 436A     		ldr	r3, [r0, #36]
 659 0014 43F00103 		orr	r3, r3, #1
 660 0018 4362     		str	r3, [r0, #36]
 661              	.LVL57:
 662 001a AB7D     		ldrb	r3, [r5, #22]	@ zero_extendqisi2
 663 001c C3EBC303 		rsb	r3, r3, r3, lsl #3
 664 0020 06EB830B 		add	fp, r6, r3, lsl #2
 665              	.LBE88:
 666              	.LBE87:
 362:../drivers/fsl_enet.c ****     /* Checks input parameters. */
 667              		.loc 1 362 0
 668 0024 0446     		mov	r4, r0
 669 0026 0F46     		mov	r7, r1
 670              	.LVL58:
 671              	.LBB90:
 672              	.LBB89:
 745:../drivers/fsl_enet.h **** }
 673              		.loc 2 745 0
 674 0028 3346     		mov	r3, r6
 675              	.LBE89:
 676              	.LBE90:
 677              	.LBB91:
 678              	.LBB92:
 679              	.LBB93:
 745:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 680              		.loc 1 745 0
 681 002a 4FF48069 		mov	r9, #1024
 682              	.LVL59:
 683              	.L47:
 684              	.LBE93:
 727:../drivers/fsl_enet.c ****     {
 685              		.loc 1 727 0
 686 002e 9B45     		cmp	fp, r3
 687 0030 40F0EE80 		bne	.L53
 688              	.LVL60:
 689 0034 AB7D     		ldrb	r3, [r5, #22]	@ zero_extendqisi2
 690 0036 C3EBC303 		rsb	r3, r3, r3, lsl #3
 691 003a 06EB830A 		add	r10, r6, r3, lsl #2
 692              	.LBE92:
 693              	.LBE91:
 694              	.LBB97:
 695              	.LBB98:
 696              	.LBB99:
 816:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 697              		.loc 1 816 0
 698 003e 4FF40049 		mov	r9, #32768
 699              	.LBE99:
 700              	.LBE98:
 701              	.LBE97:
 702              	.LBB103:
 703              	.LBB95:
 727:../drivers/fsl_enet.c ****     {
 704              		.loc 1 727 0
 705 0042 3346     		mov	r3, r6
 706              	.L54:
 707              	.LVL61:
 708              	.LBE95:
 709              	.LBE103:
 710              	.LBB104:
 711              	.LBB101:
 784:../drivers/fsl_enet.c ****     {
 712              		.loc 1 784 0
 713 0044 5345     		cmp	r3, r10
 714 0046 40F00B81 		bne	.L60
 715              	.LVL62:
 716              	.LBE101:
 717              	.LBE104:
 718              	.LBB105:
 719              	.LBB106:
 492:../drivers/fsl_enet.c ****     uint32_t maxFrameLen = config->rxMaxFrameLen;
 720              		.loc 1 492 0
 721 004a 2A68     		ldr	r2, [r5]
 491:../drivers/fsl_enet.c ****     uint32_t macSpecialConfig = config->macSpecialConfig;
 722              		.loc 1 491 0
 723 004c D4F82480 		ldr	r8, [r4, #36]
 724              	.LVL63:
 493:../drivers/fsl_enet.c **** 
 725              		.loc 1 493 0
 726 0050 2989     		ldrh	r1, [r5, #8]
 727              	.LVL64:
 496:../drivers/fsl_enet.c ****     {
 728              		.loc 1 496 0
 729 0052 9305     		lsls	r3, r2, #22
 730 0054 06D5     		bpl	.L61
 498:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_AVB) && FSL_FEATURE_ENET_HAS_AVB
 731              		.loc 1 498 0
 732 0056 40F2EE50 		movw	r0, #1518
 733 005a 40F2F253 		movw	r3, #1522
 734 005e 8142     		cmp	r1, r0
 735 0060 98BF     		it	ls
 736 0062 1946     		movls	r1, r3
 737              	.LVL65:
 738              	.L61:
 511:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_CFEN_MASK : 0) |
 739              		.loc 1 511 0
 740 0064 5307     		lsls	r3, r2, #29
 512:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_FCE_MASK : 0) |
 741              		.loc 1 512 0
 742 0066 D003     		lsls	r0, r2, #15
 743 0068 80B2     		uxth	r0, r0
 511:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_CFEN_MASK : 0) |
 744              		.loc 1 511 0
 745 006a 03F08043 		and	r3, r3, #1073741824
 746 006e 0343     		orrs	r3, r3, r0
 513:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxPadRemoveEnable) ? ENET_RCR_PADEN_MASK : 0) |
 747              		.loc 1 513 0
 748 0070 5001     		lsls	r0, r2, #5
 749 0072 00F02000 		and	r0, r0, #32
 512:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlFlowControlEnable) ? ENET_RCR_FCE_MASK : 0) |
 750              		.loc 1 512 0
 751 0076 0343     		orrs	r3, r3, r0
 514:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxBroadCastRejectEnable) ? ENET_RCR_BC_REJ_MASK : 0) |
 752              		.loc 1 514 0
 753 0078 9002     		lsls	r0, r2, #10
 754 007a 00F48050 		and	r0, r0, #4096
 513:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxPadRemoveEnable) ? ENET_RCR_PADEN_MASK : 0) |
 755              		.loc 1 513 0
 756 007e 0343     		orrs	r3, r3, r0
 515:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlPromiscuousEnable) ? ENET_RCR_PROM_MASK : 0) |
 757              		.loc 1 515 0
 758 0080 5000     		lsls	r0, r2, #1
 759 0082 00F01000 		and	r0, r0, #16
 514:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlRxBroadCastRejectEnable) ? ENET_RCR_BC_REJ_MASK : 0) |
 760              		.loc 1 514 0
 761 0086 0343     		orrs	r3, r3, r0
 516:../drivers/fsl_enet.c ****           ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD_MASK;    
 762              		.loc 1 516 0
 763 0088 1009     		lsrs	r0, r2, #4
 764 008a 00F00800 		and	r0, r0, #8
 515:../drivers/fsl_enet.c ****           ((macSpecialConfig & kENET_ControlPromiscuousEnable) ? ENET_RCR_PROM_MASK : 0) |
 765              		.loc 1 515 0
 766 008e 0343     		orrs	r3, r3, r0
 517:../drivers/fsl_enet.c **** 
 767              		.loc 1 517 0
 768 0090 8848     		ldr	r0, .L117+4
 769 0092 00EA0141 		and	r1, r0, r1, lsl #16
 770              	.LVL66:
 531:../drivers/fsl_enet.c ****         {
 771              		.loc 1 531 0
 772 0096 A87A     		ldrb	r0, [r5, #10]	@ zero_extendqisi2
 516:../drivers/fsl_enet.c ****           ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD_MASK;    
 773              		.loc 1 516 0
 774 0098 0B43     		orrs	r3, r3, r1
 775              	.LVL67:
 531:../drivers/fsl_enet.c ****         {
 776              		.loc 1 531 0
 777 009a 0128     		cmp	r0, #1
 539:../drivers/fsl_enet.c ****     {
 778              		.loc 1 539 0
 779 009c E97A     		ldrb	r1, [r5, #11]	@ zero_extendqisi2
 530:../drivers/fsl_enet.c ****         if (config->miiMode == kENET_RmiiMode)
 780              		.loc 1 530 0
 781 009e 14BF     		ite	ne
 782 00a0 43F48043 		orrne	r3, r3, #16384
 783              	.LVL68:
 533:../drivers/fsl_enet.c ****         }
 784              		.loc 1 533 0
 785 00a4 43F48243 		orreq	r3, r3, #16640
 786 00a8 43F00403 		orr	r3, r3, #4
 787              	.LVL69:
 539:../drivers/fsl_enet.c ****     {
 788              		.loc 1 539 0
 789 00ac 09B9     		cbnz	r1, .L64
 541:../drivers/fsl_enet.c ****     }
 790              		.loc 1 541 0
 791 00ae 43F40073 		orr	r3, r3, #512
 792              	.LVL70:
 793              	.L64:
 551:../drivers/fsl_enet.c ****     {
 794              		.loc 1 551 0
 795 00b2 297B     		ldrb	r1, [r5, #12]	@ zero_extendqisi2
 796 00b4 09B9     		cbnz	r1, .L65
 553:../drivers/fsl_enet.c ****     }
 797              		.loc 1 553 0
 798 00b6 43F00203 		orr	r3, r3, #2
 799              	.LVL71:
 800              	.L65:
 556:../drivers/fsl_enet.c ****     {
 801              		.loc 1 556 0
 802 00ba 12F4807F 		tst	r2, #256
 803 00be 05D0     		beq	.L66
 804 00c0 0128     		cmp	r0, #1
 805              	.LVL72:
 806 00c2 1CBF     		itt	ne
 807 00c4 23F00203 		bicne	r3, r3, #2
 808              	.LVL73:
 559:../drivers/fsl_enet.c ****     }
 809              		.loc 1 559 0
 810 00c8 43F00103 		orrne	r3, r3, #1
 811              	.LVL74:
 812              	.L66:
 561:../drivers/fsl_enet.c **** 
 813              		.loc 1 561 0
 814 00cc C4F88430 		str	r3, [r4, #132]
 564:../drivers/fsl_enet.c ****     tcr |= (config->miiDuplex ? ENET_TCR_FDEN_MASK : 0) |
 815              		.loc 1 564 0
 816 00d0 D4F8C400 		ldr	r0, [r4, #196]
 566:../drivers/fsl_enet.c ****     base->TCR = tcr;
 817              		.loc 1 566 0
 818 00d4 1301     		lsls	r3, r2, #4
 819              	.LVL75:
 565:../drivers/fsl_enet.c ****            ((macSpecialConfig & kENET_ControlMacAddrInsert) ? ENET_TCR_ADDINS_MASK : 0);
 820              		.loc 1 565 0
 821 00d6 0029     		cmp	r1, #0
 564:../drivers/fsl_enet.c ****     tcr |= (config->miiDuplex ? ENET_TCR_FDEN_MASK : 0) |
 822              		.loc 1 564 0
 823 00d8 20F48270 		bic	r0, r0, #260
 824              	.LVL76:
 566:../drivers/fsl_enet.c ****     base->TCR = tcr;
 825              		.loc 1 566 0
 826 00dc 03F48073 		and	r3, r3, #256
 565:../drivers/fsl_enet.c ****            ((macSpecialConfig & kENET_ControlMacAddrInsert) ? ENET_TCR_ADDINS_MASK : 0);
 827              		.loc 1 565 0
 828 00e0 0CBF     		ite	eq
 829 00e2 0021     		moveq	r1, #0
 830 00e4 0421     		movne	r1, #4
 831 00e6 0343     		orrs	r3, r3, r0
 832 00e8 0B43     		orrs	r3, r3, r1
 833              	.LVL77:
 567:../drivers/fsl_enet.c **** 
 834              		.loc 1 567 0
 835 00ea C4F8C430 		str	r3, [r4, #196]
 836              	.LVL78:
 570:../drivers/fsl_enet.c ****     base->RACC = config->rxAccelerConfig;
 837              		.loc 1 570 0
 838 00ee A87B     		ldrb	r0, [r5, #14]	@ zero_extendqisi2
 839 00f0 C4F8C001 		str	r0, [r4, #448]
 571:../drivers/fsl_enet.c **** 
 840              		.loc 1 571 0
 841 00f4 697B     		ldrb	r1, [r5, #13]	@ zero_extendqisi2
 842 00f6 C4F8C411 		str	r1, [r4, #452]
 574:../drivers/fsl_enet.c ****     {
 843              		.loc 1 574 0
 844 00fa D307     		lsls	r3, r2, #31
 845              	.LVL79:
 846 00fc 0CD5     		bpl	.L68
 847              	.LBB107:
 577:../drivers/fsl_enet.c ****         reemReg = ENET_RSEM_RX_SECTION_EMPTY(config->rxFifoEmptyThreshold);
 848              		.loc 1 577 0
 849 00fe 2B8A     		ldrh	r3, [r5, #16]
 850 0100 C4F8EC30 		str	r3, [r4, #236]
 580:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 851              		.loc 1 580 0
 852 0104 EB7C     		ldrb	r3, [r5, #19]	@ zero_extendqisi2
 578:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_T
 853              		.loc 1 578 0
 854 0106 95F812C0 		ldrb	ip, [r5, #18]	@ zero_extendqisi2
 855              	.LVL80:
 580:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
 856              		.loc 1 580 0
 857 010a 1B04     		lsls	r3, r3, #16
 858 010c 03F4F813 		and	r3, r3, #2031616
 859 0110 43EA0C03 		orr	r3, r3, ip
 860              	.LVL81:
 582:../drivers/fsl_enet.c ****     }
 861              		.loc 1 582 0
 862 0114 C4F89431 		str	r3, [r4, #404]
 863              	.LVL82:
 864              	.L68:
 865              	.LBE107:
 586:../drivers/fsl_enet.c ****     {
 866              		.loc 1 586 0
 867 0118 12F02002 		ands	r2, r2, #32
 868              	.LVL83:
 589:../drivers/fsl_enet.c ****         /* Receive fifo full threshold settings. */
 869              		.loc 1 589 0
 870 011c 1FBF     		itttt	ne
 871 011e 6B7D     		ldrbne	r3, [r5, #21]	@ zero_extendqisi2
 872 0120 03F03F03 		andne	r3, r3, #63
 873 0124 C4F84431 		strne	r3, [r4, #324]
 591:../drivers/fsl_enet.c ****     }
 874              		.loc 1 591 0
 875 0128 2B7D     		ldrbne	r3, [r5, #20]	@ zero_extendqisi2
 876 012a 11BF     		iteee	ne
 877 012c C4F89031 		strne	r3, [r4, #400]
 596:../drivers/fsl_enet.c ****         base->RSFL = 0;
 878              		.loc 1 596 0
 879 0130 4FF48073 		moveq	r3, #256
 880 0134 C4F84431 		streq	r3, [r4, #324]
 597:../drivers/fsl_enet.c ****     }
 881              		.loc 1 597 0
 882 0138 C4F89021 		streq	r2, [r4, #400]
 601:../drivers/fsl_enet.c ****     {
 883              		.loc 1 601 0
 884 013c 10F0180F 		tst	r0, #24
 603:../drivers/fsl_enet.c ****     }
 885              		.loc 1 603 0
 886 0140 1CBF     		itt	ne
 887 0142 4FF48073 		movne	r3, #256
 888 0146 C4F84431 		strne	r3, [r4, #324]
 605:../drivers/fsl_enet.c ****     {
 889              		.loc 1 605 0
 890 014a 11F0060F 		tst	r1, #6
 607:../drivers/fsl_enet.c ****     }
 891              		.loc 1 607 0
 892 014e 1CBF     		itt	ne
 893 0150 0023     		movne	r3, #0
 894 0152 C4F89031 		strne	r3, [r4, #400]
 615:../drivers/fsl_enet.c ****     base->RDSR = (uint32_t)bufferConfig->rxBdStartAddrAlign;
 895              		.loc 1 615 0
 896 0156 3369     		ldr	r3, [r6, #16]
 897 0158 C4F88431 		str	r3, [r4, #388]
 616:../drivers/fsl_enet.c **** #endif    
 898              		.loc 1 616 0
 899 015c F368     		ldr	r3, [r6, #12]
 900 015e C4F88031 		str	r3, [r4, #384]
 618:../drivers/fsl_enet.c **** 
 901              		.loc 1 618 0
 902 0162 7368     		ldr	r3, [r6, #4]
 903 0164 C4F88831 		str	r3, [r4, #392]
 662:../drivers/fsl_enet.c **** 
 904              		.loc 1 662 0
 905 0168 0C99     		ldr	r1, [sp, #48]
 906 016a 2046     		mov	r0, r4
 907 016c FFF7FEFF 		bl	ENET_SetMacAddr
 908              	.LVL84:
 909              	.LBB108:
 910              	.LBB109:
 788:../drivers/fsl_enet.h **** }
 911              		.loc 2 788 0
 912 0170 636C     		ldr	r3, [r4, #68]
 913              	.LVL85:
 914              	.LBE109:
 915              	.LBE108:
 665:../drivers/fsl_enet.c ****     {
 916              		.loc 1 665 0
 917 0172 13F07E0F 		tst	r3, #126
 918 0176 05D1     		bne	.L73
 919              	.LVL86:
 667:../drivers/fsl_enet.c ****     }
 920              		.loc 1 667 0
 921 0178 2A68     		ldr	r2, [r5]
 922 017a 0D99     		ldr	r1, [sp, #52]
 923 017c C2F38012 		ubfx	r2, r2, #6, #1
 924 0180 FFF7FEFF 		bl	ENET_SetSMI
 925              	.LVL87:
 926              	.L73:
 927              	.LBB110:
 928              	.LBB111:
1012:../drivers/fsl_enet.h ****     }
1013:../drivers/fsl_enet.h **** }
1014:../drivers/fsl_enet.h **** 
1015:../drivers/fsl_enet.h **** /*!
1016:../drivers/fsl_enet.h ****  * @brief Gets ENET transmit and receive accelerator functions from MAC controller.
1017:../drivers/fsl_enet.h ****  *
1018:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
1019:../drivers/fsl_enet.h ****  * @param txAccelOption The transmit accelerator option. The "enet_tx_accelerator_t" is
1020:../drivers/fsl_enet.h ****  *         recommended to be used to as the mask to get the exact the accelerator option.
1021:../drivers/fsl_enet.h ****  * @param rxAccelOption The receive accelerator option. The "enet_rx_accelerator_t" is
1022:../drivers/fsl_enet.h ****  *         recommended to be used to as the mask to get the exact the accelerator option.
1023:../drivers/fsl_enet.h ****  */
1024:../drivers/fsl_enet.h **** static inline void ENET_GetAccelFunction(ENET_Type *base, uint32_t *txAccelOption, uint32_t *rxAcce
1025:../drivers/fsl_enet.h **** {
1026:../drivers/fsl_enet.h ****     assert(txAccelOption);
1027:../drivers/fsl_enet.h ****     assert(txAccelOption);
1028:../drivers/fsl_enet.h **** 
1029:../drivers/fsl_enet.h ****     *txAccelOption = base->TACC;
1030:../drivers/fsl_enet.h ****     *rxAccelOption = base->RACC;
1031:../drivers/fsl_enet.h **** }
1032:../drivers/fsl_enet.h **** 
1033:../drivers/fsl_enet.h **** /* @} */
1034:../drivers/fsl_enet.h **** 
1035:../drivers/fsl_enet.h **** /*!
1036:../drivers/fsl_enet.h ****  * @name Interrupts.
1037:../drivers/fsl_enet.h ****  * @{
1038:../drivers/fsl_enet.h ****  */
1039:../drivers/fsl_enet.h **** 
1040:../drivers/fsl_enet.h **** /*!
1041:../drivers/fsl_enet.h ****  * @brief Enables the ENET interrupt.
1042:../drivers/fsl_enet.h ****  *
1043:../drivers/fsl_enet.h ****  * This function enables the ENET interrupt according to the provided mask. The mask
1044:../drivers/fsl_enet.h ****  * is a logical OR of enumeration members. See @ref enet_interrupt_enable_t.
1045:../drivers/fsl_enet.h ****  * For example, to enable the TX frame interrupt and RX frame interrupt, do the following.
1046:../drivers/fsl_enet.h ****  * @code
1047:../drivers/fsl_enet.h ****  *     ENET_EnableInterrupts(ENET, kENET_TxFrameInterrupt | kENET_RxFrameInterrupt);
1048:../drivers/fsl_enet.h ****  * @endcode
1049:../drivers/fsl_enet.h ****  *
1050:../drivers/fsl_enet.h ****  * @param base  ENET peripheral base address.
1051:../drivers/fsl_enet.h ****  * @param mask  ENET interrupts to enable. This is a logical OR of the
1052:../drivers/fsl_enet.h ****  *             enumeration :: enet_interrupt_enable_t.
1053:../drivers/fsl_enet.h ****  */
1054:../drivers/fsl_enet.h **** static inline void ENET_EnableInterrupts(ENET_Type *base, uint32_t mask)
1055:../drivers/fsl_enet.h **** {
1056:../drivers/fsl_enet.h ****     base->EIMR |= mask;
 929              		.loc 2 1056 0
 930 0184 6A68     		ldr	r2, [r5, #4]
 931 0186 A368     		ldr	r3, [r4, #8]
 932 0188 1343     		orrs	r3, r3, r2
 933 018a A360     		str	r3, [r4, #8]
 934              	.LVL88:
 935              	.LBE111:
 936              	.LBE110:
 710:../drivers/fsl_enet.c ****     base->ECR = ecr;
 937              		.loc 1 710 0
 938 018c 48F48173 		orr	r3, r8, #258
 939              	.LVL89:
 711:../drivers/fsl_enet.c **** }
 940              		.loc 1 711 0
 941 0190 6362     		str	r3, [r4, #36]
 942              	.LVL90:
 943              	.LBE106:
 944              	.LBE105:
 945              	.LBB112:
 946              	.LBB113:
 433:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 947              		.loc 1 433 0
 948 0192 2046     		mov	r0, r4
 949              	.LVL91:
 950 0194 FFF7FEFF 		bl	ENET_GetInstance
 951              	.LVL92:
 437:../drivers/fsl_enet.c **** 
 952              		.loc 1 437 0
 953 0198 2422     		movs	r2, #36
 433:../drivers/fsl_enet.c ****     const enet_buffer_config_t *buffCfg = bufferConfig;
 954              		.loc 1 433 0
 955 019a 0446     		mov	r4, r0
 956              	.LVL93:
 437:../drivers/fsl_enet.c **** 
 957              		.loc 1 437 0
 958 019c 0021     		movs	r1, #0
 959 019e 3846     		mov	r0, r7
 960              	.LVL94:
 961 01a0 FFF7FEFF 		bl	memset
 962              	.LVL95:
 439:../drivers/fsl_enet.c ****     for (count = 0; count < handle->ringNum; count++)
 963              		.loc 1 439 0
 964 01a4 AB7D     		ldrb	r3, [r5, #22]	@ zero_extendqisi2
 965 01a6 012B     		cmp	r3, #1
 966 01a8 1A46     		mov	r2, r3
 967 01aa 28BF     		it	cs
 968 01ac 0122     		movcs	r2, #1
 969 01ae 3A76     		strb	r2, [r7, #24]
 970              	.LVL96:
 440:../drivers/fsl_enet.c ****     {
 971              		.loc 1 440 0
 972 01b0 4BB1     		cbz	r3, .L74
 442:../drivers/fsl_enet.c ****         handle->rxBdCurrent[count] = buffCfg->rxBdStartAddrAlign;
 973              		.loc 1 442 0
 974 01b2 F368     		ldr	r3, [r6, #12]
 443:../drivers/fsl_enet.c ****         handle->rxBuffSizeAlign[count] = buffCfg->rxBuffSizeAlign;
 975              		.loc 1 443 0
 976 01b4 C7E90033 		strd	r3, r3, [r7]
 444:../drivers/fsl_enet.c ****         handle->txBdBase[count] = buffCfg->txBdStartAddrAlign;
 977              		.loc 1 444 0
 978 01b8 7368     		ldr	r3, [r6, #4]
 979 01ba 3B61     		str	r3, [r7, #16]
 445:../drivers/fsl_enet.c ****         handle->txBdCurrent[count] = buffCfg->txBdStartAddrAlign;
 980              		.loc 1 445 0
 981 01bc 3369     		ldr	r3, [r6, #16]
 446:../drivers/fsl_enet.c ****         handle->txBuffSizeAlign[count] = buffCfg->txBuffSizeAlign;
 982              		.loc 1 446 0
 983 01be C7E90233 		strd	r3, r3, [r7, #8]
 447:../drivers/fsl_enet.c ****         buffCfg++;
 984              		.loc 1 447 0
 985 01c2 B368     		ldr	r3, [r6, #8]
 986 01c4 7B61     		str	r3, [r7, #20]
 987              	.LVL97:
 988              	.L74:
 452:../drivers/fsl_enet.c **** 
 989              		.loc 1 452 0
 990 01c6 3C4B     		ldr	r3, .L117+8
 991 01c8 43F82470 		str	r7, [r3, r4, lsl #2]
 455:../drivers/fsl_enet.c ****     {
 992              		.loc 1 455 0
 993 01cc 6B68     		ldr	r3, [r5, #4]
 994 01ce 13F0406F 		tst	r3, #201326592
 995 01d2 06D0     		beq	.L75
 457:../drivers/fsl_enet.c ****         EnableIRQ(s_enetTxIrqId[instance]);
 996              		.loc 1 457 0
 997 01d4 394A     		ldr	r2, .L117+12
 998 01d6 3A49     		ldr	r1, .L117+16
 999 01d8 1160     		str	r1, [r2]
 1000              	.LVL98:
 1001              	.LBB114:
 1002              	.LBB115:
 1003              	.LBB116:
 1004              		.file 5 "../CMSIS/core_cm4.h"
   1:../CMSIS/core_cm4.h **** /**************************************************************************//**
   2:../CMSIS/core_cm4.h ****  * @file     core_cm4.h
   3:../CMSIS/core_cm4.h ****  * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm4.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm4.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm4.h ****  ******************************************************************************/
   7:../CMSIS/core_cm4.h **** /*
   8:../CMSIS/core_cm4.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm4.h ****  *
  10:../CMSIS/core_cm4.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm4.h ****  *
  12:../CMSIS/core_cm4.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm4.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm4.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm4.h ****  *
  16:../CMSIS/core_cm4.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm4.h ****  *
  18:../CMSIS/core_cm4.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm4.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm4.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm4.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm4.h ****  * limitations under the License.
  23:../CMSIS/core_cm4.h ****  */
  24:../CMSIS/core_cm4.h **** 
  25:../CMSIS/core_cm4.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm4.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm4.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm4.h **** #endif
  30:../CMSIS/core_cm4.h **** 
  31:../CMSIS/core_cm4.h **** #ifndef __CORE_CM4_H_GENERIC
  32:../CMSIS/core_cm4.h **** #define __CORE_CM4_H_GENERIC
  33:../CMSIS/core_cm4.h **** 
  34:../CMSIS/core_cm4.h **** #include <stdint.h>
  35:../CMSIS/core_cm4.h **** 
  36:../CMSIS/core_cm4.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm4.h ****  extern "C" {
  38:../CMSIS/core_cm4.h **** #endif
  39:../CMSIS/core_cm4.h **** 
  40:../CMSIS/core_cm4.h **** /**
  41:../CMSIS/core_cm4.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm4.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm4.h **** 
  44:../CMSIS/core_cm4.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm4.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm4.h **** 
  47:../CMSIS/core_cm4.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm4.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm4.h **** 
  50:../CMSIS/core_cm4.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm4.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm4.h ****  */
  53:../CMSIS/core_cm4.h **** 
  54:../CMSIS/core_cm4.h **** 
  55:../CMSIS/core_cm4.h **** /*******************************************************************************
  56:../CMSIS/core_cm4.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm4.h ****  ******************************************************************************/
  58:../CMSIS/core_cm4.h **** /**
  59:../CMSIS/core_cm4.h ****   \ingroup Cortex_M4
  60:../CMSIS/core_cm4.h ****   @{
  61:../CMSIS/core_cm4.h ****  */
  62:../CMSIS/core_cm4.h **** 
  63:../CMSIS/core_cm4.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm4.h ****  
  65:../CMSIS/core_cm4.h **** /* CMSIS CM4 definitions */
  66:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:../CMSIS/core_cm4.h **** #define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm4.h ****                                     __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:../CMSIS/core_cm4.h **** 
  71:../CMSIS/core_cm4.h **** #define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
  72:../CMSIS/core_cm4.h **** 
  73:../CMSIS/core_cm4.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm4.h ****     For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and fun
  75:../CMSIS/core_cm4.h **** */
  76:../CMSIS/core_cm4.h **** #if defined ( __CC_ARM )
  77:../CMSIS/core_cm4.h ****   #if defined __TARGET_FPU_VFP
  78:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  79:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
  80:../CMSIS/core_cm4.h ****     #else
  81:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
  82:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
  83:../CMSIS/core_cm4.h ****     #endif
  84:../CMSIS/core_cm4.h ****   #else
  85:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
  86:../CMSIS/core_cm4.h ****   #endif
  87:../CMSIS/core_cm4.h **** 
  88:../CMSIS/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  89:../CMSIS/core_cm4.h ****   #if defined __ARM_PCS_VFP
  90:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  91:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
  92:../CMSIS/core_cm4.h ****     #else
  93:../CMSIS/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
  94:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
  95:../CMSIS/core_cm4.h ****     #endif
  96:../CMSIS/core_cm4.h ****   #else
  97:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
  98:../CMSIS/core_cm4.h ****   #endif
  99:../CMSIS/core_cm4.h **** 
 100:../CMSIS/core_cm4.h **** #elif defined ( __GNUC__ )
 101:../CMSIS/core_cm4.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 102:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 103:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 104:../CMSIS/core_cm4.h ****     #else
 105:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 106:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 107:../CMSIS/core_cm4.h ****     #endif
 108:../CMSIS/core_cm4.h ****   #else
 109:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 110:../CMSIS/core_cm4.h ****   #endif
 111:../CMSIS/core_cm4.h **** 
 112:../CMSIS/core_cm4.h **** #elif defined ( __ICCARM__ )
 113:../CMSIS/core_cm4.h ****   #if defined __ARMVFP__
 114:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 115:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 116:../CMSIS/core_cm4.h ****     #else
 117:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 118:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 119:../CMSIS/core_cm4.h ****     #endif
 120:../CMSIS/core_cm4.h ****   #else
 121:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 122:../CMSIS/core_cm4.h ****   #endif
 123:../CMSIS/core_cm4.h **** 
 124:../CMSIS/core_cm4.h **** #elif defined ( __TI_ARM__ )
 125:../CMSIS/core_cm4.h ****   #if defined __TI_VFP_SUPPORT__
 126:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 127:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 128:../CMSIS/core_cm4.h ****     #else
 129:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 130:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 131:../CMSIS/core_cm4.h ****     #endif
 132:../CMSIS/core_cm4.h ****   #else
 133:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 134:../CMSIS/core_cm4.h ****   #endif
 135:../CMSIS/core_cm4.h **** 
 136:../CMSIS/core_cm4.h **** #elif defined ( __TASKING__ )
 137:../CMSIS/core_cm4.h ****   #if defined __FPU_VFP__
 138:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 139:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 140:../CMSIS/core_cm4.h ****     #else
 141:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 142:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 143:../CMSIS/core_cm4.h ****     #endif
 144:../CMSIS/core_cm4.h ****   #else
 145:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 146:../CMSIS/core_cm4.h ****   #endif
 147:../CMSIS/core_cm4.h **** 
 148:../CMSIS/core_cm4.h **** #elif defined ( __CSMC__ )
 149:../CMSIS/core_cm4.h ****   #if ( __CSMC__ & 0x400U)
 150:../CMSIS/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 151:../CMSIS/core_cm4.h ****       #define __FPU_USED       1U
 152:../CMSIS/core_cm4.h ****     #else
 153:../CMSIS/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 154:../CMSIS/core_cm4.h ****       #define __FPU_USED       0U
 155:../CMSIS/core_cm4.h ****     #endif
 156:../CMSIS/core_cm4.h ****   #else
 157:../CMSIS/core_cm4.h ****     #define __FPU_USED         0U
 158:../CMSIS/core_cm4.h ****   #endif
 159:../CMSIS/core_cm4.h **** 
 160:../CMSIS/core_cm4.h **** #endif
 161:../CMSIS/core_cm4.h **** 
 162:../CMSIS/core_cm4.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 163:../CMSIS/core_cm4.h **** 
 164:../CMSIS/core_cm4.h **** 
 165:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 166:../CMSIS/core_cm4.h **** }
 167:../CMSIS/core_cm4.h **** #endif
 168:../CMSIS/core_cm4.h **** 
 169:../CMSIS/core_cm4.h **** #endif /* __CORE_CM4_H_GENERIC */
 170:../CMSIS/core_cm4.h **** 
 171:../CMSIS/core_cm4.h **** #ifndef __CMSIS_GENERIC
 172:../CMSIS/core_cm4.h **** 
 173:../CMSIS/core_cm4.h **** #ifndef __CORE_CM4_H_DEPENDANT
 174:../CMSIS/core_cm4.h **** #define __CORE_CM4_H_DEPENDANT
 175:../CMSIS/core_cm4.h **** 
 176:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 177:../CMSIS/core_cm4.h ****  extern "C" {
 178:../CMSIS/core_cm4.h **** #endif
 179:../CMSIS/core_cm4.h **** 
 180:../CMSIS/core_cm4.h **** /* check device defines and use defaults */
 181:../CMSIS/core_cm4.h **** #if defined __CHECK_DEVICE_DEFINES
 182:../CMSIS/core_cm4.h ****   #ifndef __CM4_REV
 183:../CMSIS/core_cm4.h ****     #define __CM4_REV               0x0000U
 184:../CMSIS/core_cm4.h ****     #warning "__CM4_REV not defined in device header file; using default!"
 185:../CMSIS/core_cm4.h ****   #endif
 186:../CMSIS/core_cm4.h **** 
 187:../CMSIS/core_cm4.h ****   #ifndef __FPU_PRESENT
 188:../CMSIS/core_cm4.h ****     #define __FPU_PRESENT             0U
 189:../CMSIS/core_cm4.h ****     #warning "__FPU_PRESENT not defined in device header file; using default!"
 190:../CMSIS/core_cm4.h ****   #endif
 191:../CMSIS/core_cm4.h **** 
 192:../CMSIS/core_cm4.h ****   #ifndef __MPU_PRESENT
 193:../CMSIS/core_cm4.h ****     #define __MPU_PRESENT             0U
 194:../CMSIS/core_cm4.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 195:../CMSIS/core_cm4.h ****   #endif
 196:../CMSIS/core_cm4.h **** 
 197:../CMSIS/core_cm4.h ****   #ifndef __NVIC_PRIO_BITS
 198:../CMSIS/core_cm4.h ****     #define __NVIC_PRIO_BITS          3U
 199:../CMSIS/core_cm4.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 200:../CMSIS/core_cm4.h ****   #endif
 201:../CMSIS/core_cm4.h **** 
 202:../CMSIS/core_cm4.h ****   #ifndef __Vendor_SysTickConfig
 203:../CMSIS/core_cm4.h ****     #define __Vendor_SysTickConfig    0U
 204:../CMSIS/core_cm4.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 205:../CMSIS/core_cm4.h ****   #endif
 206:../CMSIS/core_cm4.h **** #endif
 207:../CMSIS/core_cm4.h **** 
 208:../CMSIS/core_cm4.h **** /* IO definitions (access restrictions to peripheral registers) */
 209:../CMSIS/core_cm4.h **** /**
 210:../CMSIS/core_cm4.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 211:../CMSIS/core_cm4.h **** 
 212:../CMSIS/core_cm4.h ****     <strong>IO Type Qualifiers</strong> are used
 213:../CMSIS/core_cm4.h ****     \li to specify the access to peripheral variables.
 214:../CMSIS/core_cm4.h ****     \li for automatic generation of peripheral register debug information.
 215:../CMSIS/core_cm4.h **** */
 216:../CMSIS/core_cm4.h **** #ifdef __cplusplus
 217:../CMSIS/core_cm4.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 218:../CMSIS/core_cm4.h **** #else
 219:../CMSIS/core_cm4.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 220:../CMSIS/core_cm4.h **** #endif
 221:../CMSIS/core_cm4.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 222:../CMSIS/core_cm4.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 223:../CMSIS/core_cm4.h **** 
 224:../CMSIS/core_cm4.h **** /* following defines should be used for structure members */
 225:../CMSIS/core_cm4.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 226:../CMSIS/core_cm4.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 227:../CMSIS/core_cm4.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 228:../CMSIS/core_cm4.h **** 
 229:../CMSIS/core_cm4.h **** /*@} end of group Cortex_M4 */
 230:../CMSIS/core_cm4.h **** 
 231:../CMSIS/core_cm4.h **** 
 232:../CMSIS/core_cm4.h **** 
 233:../CMSIS/core_cm4.h **** /*******************************************************************************
 234:../CMSIS/core_cm4.h ****  *                 Register Abstraction
 235:../CMSIS/core_cm4.h ****   Core Register contain:
 236:../CMSIS/core_cm4.h ****   - Core Register
 237:../CMSIS/core_cm4.h ****   - Core NVIC Register
 238:../CMSIS/core_cm4.h ****   - Core SCB Register
 239:../CMSIS/core_cm4.h ****   - Core SysTick Register
 240:../CMSIS/core_cm4.h ****   - Core Debug Register
 241:../CMSIS/core_cm4.h ****   - Core MPU Register
 242:../CMSIS/core_cm4.h ****   - Core FPU Register
 243:../CMSIS/core_cm4.h ****  ******************************************************************************/
 244:../CMSIS/core_cm4.h **** /**
 245:../CMSIS/core_cm4.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 246:../CMSIS/core_cm4.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 247:../CMSIS/core_cm4.h **** */
 248:../CMSIS/core_cm4.h **** 
 249:../CMSIS/core_cm4.h **** /**
 250:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
 251:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 252:../CMSIS/core_cm4.h ****   \brief      Core Register type definitions.
 253:../CMSIS/core_cm4.h ****   @{
 254:../CMSIS/core_cm4.h ****  */
 255:../CMSIS/core_cm4.h **** 
 256:../CMSIS/core_cm4.h **** /**
 257:../CMSIS/core_cm4.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 258:../CMSIS/core_cm4.h ****  */
 259:../CMSIS/core_cm4.h **** typedef union
 260:../CMSIS/core_cm4.h **** {
 261:../CMSIS/core_cm4.h ****   struct
 262:../CMSIS/core_cm4.h ****   {
 263:../CMSIS/core_cm4.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
 264:../CMSIS/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 265:../CMSIS/core_cm4.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
 266:../CMSIS/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 267:../CMSIS/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 268:../CMSIS/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 269:../CMSIS/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 270:../CMSIS/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 271:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 272:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 273:../CMSIS/core_cm4.h **** } APSR_Type;
 274:../CMSIS/core_cm4.h **** 
 275:../CMSIS/core_cm4.h **** /* APSR Register Definitions */
 276:../CMSIS/core_cm4.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 277:../CMSIS/core_cm4.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 278:../CMSIS/core_cm4.h **** 
 279:../CMSIS/core_cm4.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 280:../CMSIS/core_cm4.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 281:../CMSIS/core_cm4.h **** 
 282:../CMSIS/core_cm4.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 283:../CMSIS/core_cm4.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 284:../CMSIS/core_cm4.h **** 
 285:../CMSIS/core_cm4.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 286:../CMSIS/core_cm4.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 287:../CMSIS/core_cm4.h **** 
 288:../CMSIS/core_cm4.h **** #define APSR_Q_Pos                         27U                                            /*!< APSR
 289:../CMSIS/core_cm4.h **** #define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR
 290:../CMSIS/core_cm4.h **** 
 291:../CMSIS/core_cm4.h **** #define APSR_GE_Pos                        16U                                            /*!< APSR
 292:../CMSIS/core_cm4.h **** #define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR
 293:../CMSIS/core_cm4.h **** 
 294:../CMSIS/core_cm4.h **** 
 295:../CMSIS/core_cm4.h **** /**
 296:../CMSIS/core_cm4.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 297:../CMSIS/core_cm4.h ****  */
 298:../CMSIS/core_cm4.h **** typedef union
 299:../CMSIS/core_cm4.h **** {
 300:../CMSIS/core_cm4.h ****   struct
 301:../CMSIS/core_cm4.h ****   {
 302:../CMSIS/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 303:../CMSIS/core_cm4.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 304:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm4.h **** } IPSR_Type;
 307:../CMSIS/core_cm4.h **** 
 308:../CMSIS/core_cm4.h **** /* IPSR Register Definitions */
 309:../CMSIS/core_cm4.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 310:../CMSIS/core_cm4.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 311:../CMSIS/core_cm4.h **** 
 312:../CMSIS/core_cm4.h **** 
 313:../CMSIS/core_cm4.h **** /**
 314:../CMSIS/core_cm4.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 315:../CMSIS/core_cm4.h ****  */
 316:../CMSIS/core_cm4.h **** typedef union
 317:../CMSIS/core_cm4.h **** {
 318:../CMSIS/core_cm4.h ****   struct
 319:../CMSIS/core_cm4.h ****   {
 320:../CMSIS/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 321:../CMSIS/core_cm4.h ****     uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
 322:../CMSIS/core_cm4.h ****     uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
 323:../CMSIS/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 324:../CMSIS/core_cm4.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
 325:../CMSIS/core_cm4.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit */
 326:../CMSIS/core_cm4.h ****     uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
 327:../CMSIS/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 328:../CMSIS/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 329:../CMSIS/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 330:../CMSIS/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 331:../CMSIS/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 332:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 333:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 334:../CMSIS/core_cm4.h **** } xPSR_Type;
 335:../CMSIS/core_cm4.h **** 
 336:../CMSIS/core_cm4.h **** /* xPSR Register Definitions */
 337:../CMSIS/core_cm4.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 338:../CMSIS/core_cm4.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 339:../CMSIS/core_cm4.h **** 
 340:../CMSIS/core_cm4.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 341:../CMSIS/core_cm4.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 342:../CMSIS/core_cm4.h **** 
 343:../CMSIS/core_cm4.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 344:../CMSIS/core_cm4.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 345:../CMSIS/core_cm4.h **** 
 346:../CMSIS/core_cm4.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 347:../CMSIS/core_cm4.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 348:../CMSIS/core_cm4.h **** 
 349:../CMSIS/core_cm4.h **** #define xPSR_Q_Pos                         27U                                            /*!< xPSR
 350:../CMSIS/core_cm4.h **** #define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR
 351:../CMSIS/core_cm4.h **** 
 352:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR
 353:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR
 354:../CMSIS/core_cm4.h **** 
 355:../CMSIS/core_cm4.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 356:../CMSIS/core_cm4.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 357:../CMSIS/core_cm4.h **** 
 358:../CMSIS/core_cm4.h **** #define xPSR_GE_Pos                        16U                                            /*!< xPSR
 359:../CMSIS/core_cm4.h **** #define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR
 360:../CMSIS/core_cm4.h **** 
 361:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR
 362:../CMSIS/core_cm4.h **** #define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR
 363:../CMSIS/core_cm4.h **** 
 364:../CMSIS/core_cm4.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 365:../CMSIS/core_cm4.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 366:../CMSIS/core_cm4.h **** 
 367:../CMSIS/core_cm4.h **** 
 368:../CMSIS/core_cm4.h **** /**
 369:../CMSIS/core_cm4.h ****   \brief  Union type to access the Control Registers (CONTROL).
 370:../CMSIS/core_cm4.h ****  */
 371:../CMSIS/core_cm4.h **** typedef union
 372:../CMSIS/core_cm4.h **** {
 373:../CMSIS/core_cm4.h ****   struct
 374:../CMSIS/core_cm4.h ****   {
 375:../CMSIS/core_cm4.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 376:../CMSIS/core_cm4.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 377:../CMSIS/core_cm4.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
 378:../CMSIS/core_cm4.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
 379:../CMSIS/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 380:../CMSIS/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 381:../CMSIS/core_cm4.h **** } CONTROL_Type;
 382:../CMSIS/core_cm4.h **** 
 383:../CMSIS/core_cm4.h **** /* CONTROL Register Definitions */
 384:../CMSIS/core_cm4.h **** #define CONTROL_FPCA_Pos                    2U                                            /*!< CONT
 385:../CMSIS/core_cm4.h **** #define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONT
 386:../CMSIS/core_cm4.h **** 
 387:../CMSIS/core_cm4.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 388:../CMSIS/core_cm4.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 389:../CMSIS/core_cm4.h **** 
 390:../CMSIS/core_cm4.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 391:../CMSIS/core_cm4.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 392:../CMSIS/core_cm4.h **** 
 393:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_CORE */
 394:../CMSIS/core_cm4.h **** 
 395:../CMSIS/core_cm4.h **** 
 396:../CMSIS/core_cm4.h **** /**
 397:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
 398:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 399:../CMSIS/core_cm4.h ****   \brief      Type definitions for the NVIC Registers
 400:../CMSIS/core_cm4.h ****   @{
 401:../CMSIS/core_cm4.h ****  */
 402:../CMSIS/core_cm4.h **** 
 403:../CMSIS/core_cm4.h **** /**
 404:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 405:../CMSIS/core_cm4.h ****  */
 406:../CMSIS/core_cm4.h **** typedef struct
 407:../CMSIS/core_cm4.h **** {
 408:../CMSIS/core_cm4.h ****   __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 409:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[24U];
 410:../CMSIS/core_cm4.h ****   __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 411:../CMSIS/core_cm4.h ****         uint32_t RSERVED1[24U];
 412:../CMSIS/core_cm4.h ****   __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 413:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[24U];
 414:../CMSIS/core_cm4.h ****   __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 415:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[24U];
 416:../CMSIS/core_cm4.h ****   __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
 417:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[56U];
 418:../CMSIS/core_cm4.h ****   __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 419:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[644U];
 420:../CMSIS/core_cm4.h ****   __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 421:../CMSIS/core_cm4.h **** }  NVIC_Type;
 422:../CMSIS/core_cm4.h **** 
 423:../CMSIS/core_cm4.h **** /* Software Triggered Interrupt Register Definitions */
 424:../CMSIS/core_cm4.h **** #define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: I
 425:../CMSIS/core_cm4.h **** #define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: I
 426:../CMSIS/core_cm4.h **** 
 427:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_NVIC */
 428:../CMSIS/core_cm4.h **** 
 429:../CMSIS/core_cm4.h **** 
 430:../CMSIS/core_cm4.h **** /**
 431:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 432:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 433:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Control Block Registers
 434:../CMSIS/core_cm4.h ****   @{
 435:../CMSIS/core_cm4.h ****  */
 436:../CMSIS/core_cm4.h **** 
 437:../CMSIS/core_cm4.h **** /**
 438:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Control Block (SCB).
 439:../CMSIS/core_cm4.h ****  */
 440:../CMSIS/core_cm4.h **** typedef struct
 441:../CMSIS/core_cm4.h **** {
 442:../CMSIS/core_cm4.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 443:../CMSIS/core_cm4.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 444:../CMSIS/core_cm4.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 445:../CMSIS/core_cm4.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 446:../CMSIS/core_cm4.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 447:../CMSIS/core_cm4.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 448:../CMSIS/core_cm4.h ****   __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 449:../CMSIS/core_cm4.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 450:../CMSIS/core_cm4.h ****   __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 451:../CMSIS/core_cm4.h ****   __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
 452:../CMSIS/core_cm4.h ****   __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
 453:../CMSIS/core_cm4.h ****   __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register
 454:../CMSIS/core_cm4.h ****   __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
 455:../CMSIS/core_cm4.h ****   __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 456:../CMSIS/core_cm4.h ****   __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
 457:../CMSIS/core_cm4.h ****   __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
 458:../CMSIS/core_cm4.h ****   __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
 459:../CMSIS/core_cm4.h ****   __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
 460:../CMSIS/core_cm4.h ****   __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Regis
 461:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[5U];
 462:../CMSIS/core_cm4.h ****   __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Regis
 463:../CMSIS/core_cm4.h **** } SCB_Type;
 464:../CMSIS/core_cm4.h **** 
 465:../CMSIS/core_cm4.h **** /* SCB CPUID Register Definitions */
 466:../CMSIS/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 467:../CMSIS/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 468:../CMSIS/core_cm4.h **** 
 469:../CMSIS/core_cm4.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 470:../CMSIS/core_cm4.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 471:../CMSIS/core_cm4.h **** 
 472:../CMSIS/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 473:../CMSIS/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 474:../CMSIS/core_cm4.h **** 
 475:../CMSIS/core_cm4.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 476:../CMSIS/core_cm4.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 477:../CMSIS/core_cm4.h **** 
 478:../CMSIS/core_cm4.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 479:../CMSIS/core_cm4.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 480:../CMSIS/core_cm4.h **** 
 481:../CMSIS/core_cm4.h **** /* SCB Interrupt Control State Register Definitions */
 482:../CMSIS/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 483:../CMSIS/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 484:../CMSIS/core_cm4.h **** 
 485:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 486:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 487:../CMSIS/core_cm4.h **** 
 488:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 489:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 490:../CMSIS/core_cm4.h **** 
 491:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 492:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 493:../CMSIS/core_cm4.h **** 
 494:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 495:../CMSIS/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 496:../CMSIS/core_cm4.h **** 
 497:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 498:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 499:../CMSIS/core_cm4.h **** 
 500:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 501:../CMSIS/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 502:../CMSIS/core_cm4.h **** 
 503:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 504:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 505:../CMSIS/core_cm4.h **** 
 506:../CMSIS/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB 
 507:../CMSIS/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 508:../CMSIS/core_cm4.h **** 
 509:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 510:../CMSIS/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 511:../CMSIS/core_cm4.h **** 
 512:../CMSIS/core_cm4.h **** /* SCB Vector Table Offset Register Definitions */
 513:../CMSIS/core_cm4.h **** #define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB 
 514:../CMSIS/core_cm4.h **** #define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB 
 515:../CMSIS/core_cm4.h **** 
 516:../CMSIS/core_cm4.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 517:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 518:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 519:../CMSIS/core_cm4.h **** 
 520:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 521:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 522:../CMSIS/core_cm4.h **** 
 523:../CMSIS/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 524:../CMSIS/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 525:../CMSIS/core_cm4.h **** 
 526:../CMSIS/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB 
 527:../CMSIS/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 528:../CMSIS/core_cm4.h **** 
 529:../CMSIS/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 530:../CMSIS/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 531:../CMSIS/core_cm4.h **** 
 532:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 533:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 534:../CMSIS/core_cm4.h **** 
 535:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB 
 536:../CMSIS/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB 
 537:../CMSIS/core_cm4.h **** 
 538:../CMSIS/core_cm4.h **** /* SCB System Control Register Definitions */
 539:../CMSIS/core_cm4.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 540:../CMSIS/core_cm4.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 541:../CMSIS/core_cm4.h **** 
 542:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 543:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 544:../CMSIS/core_cm4.h **** 
 545:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 546:../CMSIS/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 547:../CMSIS/core_cm4.h **** 
 548:../CMSIS/core_cm4.h **** /* SCB Configuration Control Register Definitions */
 549:../CMSIS/core_cm4.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 550:../CMSIS/core_cm4.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 551:../CMSIS/core_cm4.h **** 
 552:../CMSIS/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB 
 553:../CMSIS/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 554:../CMSIS/core_cm4.h **** 
 555:../CMSIS/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB 
 556:../CMSIS/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 557:../CMSIS/core_cm4.h **** 
 558:../CMSIS/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 559:../CMSIS/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 560:../CMSIS/core_cm4.h **** 
 561:../CMSIS/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB 
 562:../CMSIS/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 563:../CMSIS/core_cm4.h **** 
 564:../CMSIS/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB 
 565:../CMSIS/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB 
 566:../CMSIS/core_cm4.h **** 
 567:../CMSIS/core_cm4.h **** /* SCB System Handler Control and State Register Definitions */
 568:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB 
 569:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 570:../CMSIS/core_cm4.h **** 
 571:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB 
 572:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 573:../CMSIS/core_cm4.h **** 
 574:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB 
 575:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 576:../CMSIS/core_cm4.h **** 
 577:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 578:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 579:../CMSIS/core_cm4.h **** 
 580:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB 
 581:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 582:../CMSIS/core_cm4.h **** 
 583:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB 
 584:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 585:../CMSIS/core_cm4.h **** 
 586:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB 
 587:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 588:../CMSIS/core_cm4.h **** 
 589:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB 
 590:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 591:../CMSIS/core_cm4.h **** 
 592:../CMSIS/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB 
 593:../CMSIS/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
 594:../CMSIS/core_cm4.h **** 
 595:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB 
 596:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 597:../CMSIS/core_cm4.h **** 
 598:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB 
 599:../CMSIS/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 600:../CMSIS/core_cm4.h **** 
 601:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB 
 602:../CMSIS/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 603:../CMSIS/core_cm4.h **** 
 604:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB 
 605:../CMSIS/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 606:../CMSIS/core_cm4.h **** 
 607:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB 
 608:../CMSIS/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB 
 609:../CMSIS/core_cm4.h **** 
 610:../CMSIS/core_cm4.h **** /* SCB Configurable Fault Status Register Definitions */
 611:../CMSIS/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB 
 612:../CMSIS/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 613:../CMSIS/core_cm4.h **** 
 614:../CMSIS/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB 
 615:../CMSIS/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 616:../CMSIS/core_cm4.h **** 
 617:../CMSIS/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB 
 618:../CMSIS/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB 
 619:../CMSIS/core_cm4.h **** 
 620:../CMSIS/core_cm4.h **** /* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
 621:../CMSIS/core_cm4.h **** #define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB 
 622:../CMSIS/core_cm4.h **** #define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB 
 623:../CMSIS/core_cm4.h **** 
 624:../CMSIS/core_cm4.h **** #define SCB_CFSR_MLSPERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 5U)               /*!< SCB 
 625:../CMSIS/core_cm4.h **** #define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB 
 626:../CMSIS/core_cm4.h **** 
 627:../CMSIS/core_cm4.h **** #define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB 
 628:../CMSIS/core_cm4.h **** #define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB 
 629:../CMSIS/core_cm4.h **** 
 630:../CMSIS/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB 
 631:../CMSIS/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB 
 632:../CMSIS/core_cm4.h **** 
 633:../CMSIS/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB 
 634:../CMSIS/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB 
 635:../CMSIS/core_cm4.h **** 
 636:../CMSIS/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB 
 637:../CMSIS/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB 
 638:../CMSIS/core_cm4.h **** 
 639:../CMSIS/core_cm4.h **** /* BusFault Status Register (part of SCB Configurable Fault Status Register) */
 640:../CMSIS/core_cm4.h **** #define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB 
 641:../CMSIS/core_cm4.h **** #define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB 
 642:../CMSIS/core_cm4.h **** 
 643:../CMSIS/core_cm4.h **** #define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB 
 644:../CMSIS/core_cm4.h **** #define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB 
 645:../CMSIS/core_cm4.h **** 
 646:../CMSIS/core_cm4.h **** #define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB 
 647:../CMSIS/core_cm4.h **** #define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB 
 648:../CMSIS/core_cm4.h **** 
 649:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB 
 650:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB 
 651:../CMSIS/core_cm4.h **** 
 652:../CMSIS/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB 
 653:../CMSIS/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB 
 654:../CMSIS/core_cm4.h **** 
 655:../CMSIS/core_cm4.h **** #define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB 
 656:../CMSIS/core_cm4.h **** #define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB 
 657:../CMSIS/core_cm4.h **** 
 658:../CMSIS/core_cm4.h **** #define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB 
 659:../CMSIS/core_cm4.h **** #define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB 
 660:../CMSIS/core_cm4.h **** 
 661:../CMSIS/core_cm4.h **** /* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
 662:../CMSIS/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB 
 663:../CMSIS/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB 
 664:../CMSIS/core_cm4.h **** 
 665:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB 
 666:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB 
 667:../CMSIS/core_cm4.h **** 
 668:../CMSIS/core_cm4.h **** #define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB 
 669:../CMSIS/core_cm4.h **** #define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB 
 670:../CMSIS/core_cm4.h **** 
 671:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB 
 672:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB 
 673:../CMSIS/core_cm4.h **** 
 674:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB 
 675:../CMSIS/core_cm4.h **** #define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB 
 676:../CMSIS/core_cm4.h **** 
 677:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB 
 678:../CMSIS/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB 
 679:../CMSIS/core_cm4.h **** 
 680:../CMSIS/core_cm4.h **** /* SCB Hard Fault Status Register Definitions */
 681:../CMSIS/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB 
 682:../CMSIS/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 683:../CMSIS/core_cm4.h **** 
 684:../CMSIS/core_cm4.h **** #define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB 
 685:../CMSIS/core_cm4.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 686:../CMSIS/core_cm4.h **** 
 687:../CMSIS/core_cm4.h **** #define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB 
 688:../CMSIS/core_cm4.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 689:../CMSIS/core_cm4.h **** 
 690:../CMSIS/core_cm4.h **** /* SCB Debug Fault Status Register Definitions */
 691:../CMSIS/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB 
 692:../CMSIS/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 693:../CMSIS/core_cm4.h **** 
 694:../CMSIS/core_cm4.h **** #define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB 
 695:../CMSIS/core_cm4.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 696:../CMSIS/core_cm4.h **** 
 697:../CMSIS/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB 
 698:../CMSIS/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 699:../CMSIS/core_cm4.h **** 
 700:../CMSIS/core_cm4.h **** #define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB 
 701:../CMSIS/core_cm4.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 702:../CMSIS/core_cm4.h **** 
 703:../CMSIS/core_cm4.h **** #define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB 
 704:../CMSIS/core_cm4.h **** #define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB 
 705:../CMSIS/core_cm4.h **** 
 706:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SCB */
 707:../CMSIS/core_cm4.h **** 
 708:../CMSIS/core_cm4.h **** 
 709:../CMSIS/core_cm4.h **** /**
 710:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 711:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
 712:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Control and ID Register not in the SCB
 713:../CMSIS/core_cm4.h ****   @{
 714:../CMSIS/core_cm4.h ****  */
 715:../CMSIS/core_cm4.h **** 
 716:../CMSIS/core_cm4.h **** /**
 717:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Control and ID Register not in the SCB.
 718:../CMSIS/core_cm4.h ****  */
 719:../CMSIS/core_cm4.h **** typedef struct
 720:../CMSIS/core_cm4.h **** {
 721:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
 722:../CMSIS/core_cm4.h ****   __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Regist
 723:../CMSIS/core_cm4.h ****   __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
 724:../CMSIS/core_cm4.h **** } SCnSCB_Type;
 725:../CMSIS/core_cm4.h **** 
 726:../CMSIS/core_cm4.h **** /* Interrupt Controller Type Register Definitions */
 727:../CMSIS/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: I
 728:../CMSIS/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: I
 729:../CMSIS/core_cm4.h **** 
 730:../CMSIS/core_cm4.h **** /* Auxiliary Control Register Definitions */
 731:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: 
 732:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: 
 733:../CMSIS/core_cm4.h **** 
 734:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: 
 735:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: 
 736:../CMSIS/core_cm4.h **** 
 737:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: 
 738:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: 
 739:../CMSIS/core_cm4.h **** 
 740:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: 
 741:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: 
 742:../CMSIS/core_cm4.h **** 
 743:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: 
 744:../CMSIS/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: 
 745:../CMSIS/core_cm4.h **** 
 746:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SCnotSCB */
 747:../CMSIS/core_cm4.h **** 
 748:../CMSIS/core_cm4.h **** 
 749:../CMSIS/core_cm4.h **** /**
 750:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 751:../CMSIS/core_cm4.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 752:../CMSIS/core_cm4.h ****   \brief    Type definitions for the System Timer Registers.
 753:../CMSIS/core_cm4.h ****   @{
 754:../CMSIS/core_cm4.h ****  */
 755:../CMSIS/core_cm4.h **** 
 756:../CMSIS/core_cm4.h **** /**
 757:../CMSIS/core_cm4.h ****   \brief  Structure type to access the System Timer (SysTick).
 758:../CMSIS/core_cm4.h ****  */
 759:../CMSIS/core_cm4.h **** typedef struct
 760:../CMSIS/core_cm4.h **** {
 761:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 762:../CMSIS/core_cm4.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 763:../CMSIS/core_cm4.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 764:../CMSIS/core_cm4.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 765:../CMSIS/core_cm4.h **** } SysTick_Type;
 766:../CMSIS/core_cm4.h **** 
 767:../CMSIS/core_cm4.h **** /* SysTick Control / Status Register Definitions */
 768:../CMSIS/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 769:../CMSIS/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 770:../CMSIS/core_cm4.h **** 
 771:../CMSIS/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 772:../CMSIS/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 773:../CMSIS/core_cm4.h **** 
 774:../CMSIS/core_cm4.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 775:../CMSIS/core_cm4.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 776:../CMSIS/core_cm4.h **** 
 777:../CMSIS/core_cm4.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 778:../CMSIS/core_cm4.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 779:../CMSIS/core_cm4.h **** 
 780:../CMSIS/core_cm4.h **** /* SysTick Reload Register Definitions */
 781:../CMSIS/core_cm4.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 782:../CMSIS/core_cm4.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 783:../CMSIS/core_cm4.h **** 
 784:../CMSIS/core_cm4.h **** /* SysTick Current Register Definitions */
 785:../CMSIS/core_cm4.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 786:../CMSIS/core_cm4.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 787:../CMSIS/core_cm4.h **** 
 788:../CMSIS/core_cm4.h **** /* SysTick Calibration Register Definitions */
 789:../CMSIS/core_cm4.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 790:../CMSIS/core_cm4.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 791:../CMSIS/core_cm4.h **** 
 792:../CMSIS/core_cm4.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 793:../CMSIS/core_cm4.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 794:../CMSIS/core_cm4.h **** 
 795:../CMSIS/core_cm4.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 796:../CMSIS/core_cm4.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 797:../CMSIS/core_cm4.h **** 
 798:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_SysTick */
 799:../CMSIS/core_cm4.h **** 
 800:../CMSIS/core_cm4.h **** 
 801:../CMSIS/core_cm4.h **** /**
 802:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 803:../CMSIS/core_cm4.h ****   \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
 804:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
 805:../CMSIS/core_cm4.h ****   @{
 806:../CMSIS/core_cm4.h ****  */
 807:../CMSIS/core_cm4.h **** 
 808:../CMSIS/core_cm4.h **** /**
 809:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 810:../CMSIS/core_cm4.h ****  */
 811:../CMSIS/core_cm4.h **** typedef struct
 812:../CMSIS/core_cm4.h **** {
 813:../CMSIS/core_cm4.h ****   __OM  union
 814:../CMSIS/core_cm4.h ****   {
 815:../CMSIS/core_cm4.h ****     __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
 816:../CMSIS/core_cm4.h ****     __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
 817:../CMSIS/core_cm4.h ****     __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
 818:../CMSIS/core_cm4.h ****   }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
 819:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[864U];
 820:../CMSIS/core_cm4.h ****   __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
 821:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[15U];
 822:../CMSIS/core_cm4.h ****   __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
 823:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[15U];
 824:../CMSIS/core_cm4.h ****   __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
 825:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[29U];
 826:../CMSIS/core_cm4.h ****   __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register *
 827:../CMSIS/core_cm4.h ****   __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
 828:../CMSIS/core_cm4.h ****   __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Reg
 829:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[43U];
 830:../CMSIS/core_cm4.h ****   __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
 831:../CMSIS/core_cm4.h ****   __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
 832:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[6U];
 833:../CMSIS/core_cm4.h ****   __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Re
 834:../CMSIS/core_cm4.h ****   __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Re
 835:../CMSIS/core_cm4.h ****   __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Re
 836:../CMSIS/core_cm4.h ****   __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Re
 837:../CMSIS/core_cm4.h ****   __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Re
 838:../CMSIS/core_cm4.h ****   __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Re
 839:../CMSIS/core_cm4.h ****   __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Re
 840:../CMSIS/core_cm4.h ****   __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Re
 841:../CMSIS/core_cm4.h ****   __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Re
 842:../CMSIS/core_cm4.h ****   __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Re
 843:../CMSIS/core_cm4.h ****   __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Re
 844:../CMSIS/core_cm4.h ****   __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Re
 845:../CMSIS/core_cm4.h **** } ITM_Type;
 846:../CMSIS/core_cm4.h **** 
 847:../CMSIS/core_cm4.h **** /* ITM Trace Privilege Register Definitions */
 848:../CMSIS/core_cm4.h **** #define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM 
 849:../CMSIS/core_cm4.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM 
 850:../CMSIS/core_cm4.h **** 
 851:../CMSIS/core_cm4.h **** /* ITM Trace Control Register Definitions */
 852:../CMSIS/core_cm4.h **** #define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM 
 853:../CMSIS/core_cm4.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 854:../CMSIS/core_cm4.h **** 
 855:../CMSIS/core_cm4.h **** #define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM 
 856:../CMSIS/core_cm4.h **** #define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM 
 857:../CMSIS/core_cm4.h **** 
 858:../CMSIS/core_cm4.h **** #define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM 
 859:../CMSIS/core_cm4.h **** #define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM 
 860:../CMSIS/core_cm4.h **** 
 861:../CMSIS/core_cm4.h **** #define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM 
 862:../CMSIS/core_cm4.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 863:../CMSIS/core_cm4.h **** 
 864:../CMSIS/core_cm4.h **** #define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM 
 865:../CMSIS/core_cm4.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 866:../CMSIS/core_cm4.h **** 
 867:../CMSIS/core_cm4.h **** #define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM 
 868:../CMSIS/core_cm4.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 869:../CMSIS/core_cm4.h **** 
 870:../CMSIS/core_cm4.h **** #define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM 
 871:../CMSIS/core_cm4.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 872:../CMSIS/core_cm4.h **** 
 873:../CMSIS/core_cm4.h **** #define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM 
 874:../CMSIS/core_cm4.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 875:../CMSIS/core_cm4.h **** 
 876:../CMSIS/core_cm4.h **** #define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM 
 877:../CMSIS/core_cm4.h **** #define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM 
 878:../CMSIS/core_cm4.h **** 
 879:../CMSIS/core_cm4.h **** /* ITM Integration Write Register Definitions */
 880:../CMSIS/core_cm4.h **** #define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM 
 881:../CMSIS/core_cm4.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM 
 882:../CMSIS/core_cm4.h **** 
 883:../CMSIS/core_cm4.h **** /* ITM Integration Read Register Definitions */
 884:../CMSIS/core_cm4.h **** #define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM 
 885:../CMSIS/core_cm4.h **** #define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM 
 886:../CMSIS/core_cm4.h **** 
 887:../CMSIS/core_cm4.h **** /* ITM Integration Mode Control Register Definitions */
 888:../CMSIS/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM 
 889:../CMSIS/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM 
 890:../CMSIS/core_cm4.h **** 
 891:../CMSIS/core_cm4.h **** /* ITM Lock Status Register Definitions */
 892:../CMSIS/core_cm4.h **** #define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM 
 893:../CMSIS/core_cm4.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 894:../CMSIS/core_cm4.h **** 
 895:../CMSIS/core_cm4.h **** #define ITM_LSR_Access_Pos                  1U                                            /*!< ITM 
 896:../CMSIS/core_cm4.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 897:../CMSIS/core_cm4.h **** 
 898:../CMSIS/core_cm4.h **** #define ITM_LSR_Present_Pos                 0U                                            /*!< ITM 
 899:../CMSIS/core_cm4.h **** #define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM 
 900:../CMSIS/core_cm4.h **** 
 901:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_ITM */
 902:../CMSIS/core_cm4.h **** 
 903:../CMSIS/core_cm4.h **** 
 904:../CMSIS/core_cm4.h **** /**
 905:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
 906:../CMSIS/core_cm4.h ****   \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
 907:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Data Watchpoint and Trace (DWT)
 908:../CMSIS/core_cm4.h ****   @{
 909:../CMSIS/core_cm4.h ****  */
 910:../CMSIS/core_cm4.h **** 
 911:../CMSIS/core_cm4.h **** /**
 912:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 913:../CMSIS/core_cm4.h ****  */
 914:../CMSIS/core_cm4.h **** typedef struct
 915:../CMSIS/core_cm4.h **** {
 916:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
 917:../CMSIS/core_cm4.h ****   __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
 918:../CMSIS/core_cm4.h ****   __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
 919:../CMSIS/core_cm4.h ****   __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Registe
 920:../CMSIS/core_cm4.h ****   __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
 921:../CMSIS/core_cm4.h ****   __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
 922:../CMSIS/core_cm4.h ****   __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Registe
 923:../CMSIS/core_cm4.h ****   __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register 
 924:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
 925:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
 926:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
 927:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
 928:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
 929:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
 930:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
 931:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[1U];
 932:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
 933:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
 934:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
 935:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[1U];
 936:../CMSIS/core_cm4.h ****   __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
 937:../CMSIS/core_cm4.h ****   __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
 938:../CMSIS/core_cm4.h ****   __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
 939:../CMSIS/core_cm4.h **** } DWT_Type;
 940:../CMSIS/core_cm4.h **** 
 941:../CMSIS/core_cm4.h **** /* DWT Control Register Definitions */
 942:../CMSIS/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTR
 943:../CMSIS/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTR
 944:../CMSIS/core_cm4.h **** 
 945:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTR
 946:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTR
 947:../CMSIS/core_cm4.h **** 
 948:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTR
 949:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTR
 950:../CMSIS/core_cm4.h **** 
 951:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTR
 952:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTR
 953:../CMSIS/core_cm4.h **** 
 954:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTR
 955:../CMSIS/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTR
 956:../CMSIS/core_cm4.h **** 
 957:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTR
 958:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTR
 959:../CMSIS/core_cm4.h **** 
 960:../CMSIS/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTR
 961:../CMSIS/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTR
 962:../CMSIS/core_cm4.h **** 
 963:../CMSIS/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTR
 964:../CMSIS/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTR
 965:../CMSIS/core_cm4.h **** 
 966:../CMSIS/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTR
 967:../CMSIS/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTR
 968:../CMSIS/core_cm4.h **** 
 969:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTR
 970:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTR
 971:../CMSIS/core_cm4.h **** 
 972:../CMSIS/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTR
 973:../CMSIS/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTR
 974:../CMSIS/core_cm4.h **** 
 975:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTR
 976:../CMSIS/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTR
 977:../CMSIS/core_cm4.h **** 
 978:../CMSIS/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTR
 979:../CMSIS/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTR
 980:../CMSIS/core_cm4.h **** 
 981:../CMSIS/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTR
 982:../CMSIS/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTR
 983:../CMSIS/core_cm4.h **** 
 984:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTR
 985:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTR
 986:../CMSIS/core_cm4.h **** 
 987:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTR
 988:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTR
 989:../CMSIS/core_cm4.h **** 
 990:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTR
 991:../CMSIS/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTR
 992:../CMSIS/core_cm4.h **** 
 993:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTR
 994:../CMSIS/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTR
 995:../CMSIS/core_cm4.h **** 
 996:../CMSIS/core_cm4.h **** /* DWT CPI Count Register Definitions */
 997:../CMSIS/core_cm4.h **** #define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPI
 998:../CMSIS/core_cm4.h **** #define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPI
 999:../CMSIS/core_cm4.h **** 
1000:../CMSIS/core_cm4.h **** /* DWT Exception Overhead Count Register Definitions */
1001:../CMSIS/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXC
1002:../CMSIS/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXC
1003:../CMSIS/core_cm4.h **** 
1004:../CMSIS/core_cm4.h **** /* DWT Sleep Count Register Definitions */
1005:../CMSIS/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLE
1006:../CMSIS/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLE
1007:../CMSIS/core_cm4.h **** 
1008:../CMSIS/core_cm4.h **** /* DWT LSU Count Register Definitions */
1009:../CMSIS/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSU
1010:../CMSIS/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSU
1011:../CMSIS/core_cm4.h **** 
1012:../CMSIS/core_cm4.h **** /* DWT Folded-instruction Count Register Definitions */
1013:../CMSIS/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOL
1014:../CMSIS/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOL
1015:../CMSIS/core_cm4.h **** 
1016:../CMSIS/core_cm4.h **** /* DWT Comparator Mask Register Definitions */
1017:../CMSIS/core_cm4.h **** #define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MAS
1018:../CMSIS/core_cm4.h **** #define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MAS
1019:../CMSIS/core_cm4.h **** 
1020:../CMSIS/core_cm4.h **** /* DWT Comparator Function Register Definitions */
1021:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUN
1022:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUN
1023:../CMSIS/core_cm4.h **** 
1024:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUN
1025:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUN
1026:../CMSIS/core_cm4.h **** 
1027:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUN
1028:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUN
1029:../CMSIS/core_cm4.h **** 
1030:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUN
1031:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUN
1032:../CMSIS/core_cm4.h **** 
1033:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUN
1034:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUN
1035:../CMSIS/core_cm4.h **** 
1036:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUN
1037:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUN
1038:../CMSIS/core_cm4.h **** 
1039:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUN
1040:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUN
1041:../CMSIS/core_cm4.h **** 
1042:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUN
1043:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUN
1044:../CMSIS/core_cm4.h **** 
1045:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUN
1046:../CMSIS/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUN
1047:../CMSIS/core_cm4.h **** 
1048:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_DWT */
1049:../CMSIS/core_cm4.h **** 
1050:../CMSIS/core_cm4.h **** 
1051:../CMSIS/core_cm4.h **** /**
1052:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1053:../CMSIS/core_cm4.h ****   \defgroup CMSIS_TPI     Trace Port Interface (TPI)
1054:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Trace Port Interface (TPI)
1055:../CMSIS/core_cm4.h ****   @{
1056:../CMSIS/core_cm4.h ****  */
1057:../CMSIS/core_cm4.h **** 
1058:../CMSIS/core_cm4.h **** /**
1059:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Trace Port Interface Register (TPI).
1060:../CMSIS/core_cm4.h ****  */
1061:../CMSIS/core_cm4.h **** typedef struct
1062:../CMSIS/core_cm4.h **** {
1063:../CMSIS/core_cm4.h ****   __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Reg
1064:../CMSIS/core_cm4.h ****   __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Regis
1065:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[2U];
1066:../CMSIS/core_cm4.h ****   __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Reg
1067:../CMSIS/core_cm4.h ****         uint32_t RESERVED1[55U];
1068:../CMSIS/core_cm4.h ****   __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *
1069:../CMSIS/core_cm4.h ****         uint32_t RESERVED2[131U];
1070:../CMSIS/core_cm4.h ****   __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Regis
1071:../CMSIS/core_cm4.h ****   __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Regi
1072:../CMSIS/core_cm4.h ****   __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counte
1073:../CMSIS/core_cm4.h ****         uint32_t RESERVED3[759U];
1074:../CMSIS/core_cm4.h ****   __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
1075:../CMSIS/core_cm4.h ****   __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
1076:../CMSIS/core_cm4.h ****   __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
1077:../CMSIS/core_cm4.h ****         uint32_t RESERVED4[1U];
1078:../CMSIS/core_cm4.h ****   __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
1079:../CMSIS/core_cm4.h ****   __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
1080:../CMSIS/core_cm4.h ****   __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
1081:../CMSIS/core_cm4.h ****         uint32_t RESERVED5[39U];
1082:../CMSIS/core_cm4.h ****   __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
1083:../CMSIS/core_cm4.h ****   __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
1084:../CMSIS/core_cm4.h ****         uint32_t RESERVED7[8U];
1085:../CMSIS/core_cm4.h ****   __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
1086:../CMSIS/core_cm4.h ****   __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
1087:../CMSIS/core_cm4.h **** } TPI_Type;
1088:../CMSIS/core_cm4.h **** 
1089:../CMSIS/core_cm4.h **** /* TPI Asynchronous Clock Prescaler Register Definitions */
1090:../CMSIS/core_cm4.h **** #define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACP
1091:../CMSIS/core_cm4.h **** #define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACP
1092:../CMSIS/core_cm4.h **** 
1093:../CMSIS/core_cm4.h **** /* TPI Selected Pin Protocol Register Definitions */
1094:../CMSIS/core_cm4.h **** #define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPP
1095:../CMSIS/core_cm4.h **** #define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPP
1096:../CMSIS/core_cm4.h **** 
1097:../CMSIS/core_cm4.h **** /* TPI Formatter and Flush Status Register Definitions */
1098:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFS
1099:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFS
1100:../CMSIS/core_cm4.h **** 
1101:../CMSIS/core_cm4.h **** #define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFS
1102:../CMSIS/core_cm4.h **** #define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFS
1103:../CMSIS/core_cm4.h **** 
1104:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFS
1105:../CMSIS/core_cm4.h **** #define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFS
1106:../CMSIS/core_cm4.h **** 
1107:../CMSIS/core_cm4.h **** #define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFS
1108:../CMSIS/core_cm4.h **** #define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFS
1109:../CMSIS/core_cm4.h **** 
1110:../CMSIS/core_cm4.h **** /* TPI Formatter and Flush Control Register Definitions */
1111:../CMSIS/core_cm4.h **** #define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFC
1112:../CMSIS/core_cm4.h **** #define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFC
1113:../CMSIS/core_cm4.h **** 
1114:../CMSIS/core_cm4.h **** #define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFC
1115:../CMSIS/core_cm4.h **** #define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFC
1116:../CMSIS/core_cm4.h **** 
1117:../CMSIS/core_cm4.h **** /* TPI TRIGGER Register Definitions */
1118:../CMSIS/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRI
1119:../CMSIS/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRI
1120:../CMSIS/core_cm4.h **** 
1121:../CMSIS/core_cm4.h **** /* TPI Integration ETM Data Register Definitions (FIFO0) */
1122:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1123:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIF
1124:../CMSIS/core_cm4.h **** 
1125:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1126:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIF
1127:../CMSIS/core_cm4.h **** 
1128:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1129:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIF
1130:../CMSIS/core_cm4.h **** 
1131:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1132:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIF
1133:../CMSIS/core_cm4.h **** 
1134:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIF
1135:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIF
1136:../CMSIS/core_cm4.h **** 
1137:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIF
1138:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIF
1139:../CMSIS/core_cm4.h **** 
1140:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIF
1141:../CMSIS/core_cm4.h **** #define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIF
1142:../CMSIS/core_cm4.h **** 
1143:../CMSIS/core_cm4.h **** /* TPI ITATBCTR2 Register Definitions */
1144:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITA
1145:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITA
1146:../CMSIS/core_cm4.h **** 
1147:../CMSIS/core_cm4.h **** /* TPI Integration ITM Data Register Definitions (FIFO1) */
1148:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1149:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIF
1150:../CMSIS/core_cm4.h **** 
1151:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1152:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIF
1153:../CMSIS/core_cm4.h **** 
1154:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1155:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIF
1156:../CMSIS/core_cm4.h **** 
1157:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1158:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIF
1159:../CMSIS/core_cm4.h **** 
1160:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIF
1161:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIF
1162:../CMSIS/core_cm4.h **** 
1163:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIF
1164:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIF
1165:../CMSIS/core_cm4.h **** 
1166:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIF
1167:../CMSIS/core_cm4.h **** #define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIF
1168:../CMSIS/core_cm4.h **** 
1169:../CMSIS/core_cm4.h **** /* TPI ITATBCTR0 Register Definitions */
1170:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITA
1171:../CMSIS/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITA
1172:../CMSIS/core_cm4.h **** 
1173:../CMSIS/core_cm4.h **** /* TPI Integration Mode Control Register Definitions */
1174:../CMSIS/core_cm4.h **** #define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITC
1175:../CMSIS/core_cm4.h **** #define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITC
1176:../CMSIS/core_cm4.h **** 
1177:../CMSIS/core_cm4.h **** /* TPI DEVID Register Definitions */
1178:../CMSIS/core_cm4.h **** #define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEV
1179:../CMSIS/core_cm4.h **** #define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEV
1180:../CMSIS/core_cm4.h **** 
1181:../CMSIS/core_cm4.h **** #define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEV
1182:../CMSIS/core_cm4.h **** #define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEV
1183:../CMSIS/core_cm4.h **** 
1184:../CMSIS/core_cm4.h **** #define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEV
1185:../CMSIS/core_cm4.h **** #define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEV
1186:../CMSIS/core_cm4.h **** 
1187:../CMSIS/core_cm4.h **** #define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEV
1188:../CMSIS/core_cm4.h **** #define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEV
1189:../CMSIS/core_cm4.h **** 
1190:../CMSIS/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEV
1191:../CMSIS/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEV
1192:../CMSIS/core_cm4.h **** 
1193:../CMSIS/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEV
1194:../CMSIS/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEV
1195:../CMSIS/core_cm4.h **** 
1196:../CMSIS/core_cm4.h **** /* TPI DEVTYPE Register Definitions */
1197:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEV
1198:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEV
1199:../CMSIS/core_cm4.h **** 
1200:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEV
1201:../CMSIS/core_cm4.h **** #define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEV
1202:../CMSIS/core_cm4.h **** 
1203:../CMSIS/core_cm4.h **** /*@}*/ /* end of group CMSIS_TPI */
1204:../CMSIS/core_cm4.h **** 
1205:../CMSIS/core_cm4.h **** 
1206:../CMSIS/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1207:../CMSIS/core_cm4.h **** /**
1208:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1209:../CMSIS/core_cm4.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
1210:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
1211:../CMSIS/core_cm4.h ****   @{
1212:../CMSIS/core_cm4.h ****  */
1213:../CMSIS/core_cm4.h **** 
1214:../CMSIS/core_cm4.h **** /**
1215:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
1216:../CMSIS/core_cm4.h ****  */
1217:../CMSIS/core_cm4.h **** typedef struct
1218:../CMSIS/core_cm4.h **** {
1219:../CMSIS/core_cm4.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
1220:../CMSIS/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
1221:../CMSIS/core_cm4.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
1222:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
1223:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
1224:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
1225:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
1226:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
1227:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
1228:../CMSIS/core_cm4.h ****   __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
1229:../CMSIS/core_cm4.h ****   __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
1230:../CMSIS/core_cm4.h **** } MPU_Type;
1231:../CMSIS/core_cm4.h **** 
1232:../CMSIS/core_cm4.h **** /* MPU Type Register Definitions */
1233:../CMSIS/core_cm4.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
1234:../CMSIS/core_cm4.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
1235:../CMSIS/core_cm4.h **** 
1236:../CMSIS/core_cm4.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
1237:../CMSIS/core_cm4.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
1238:../CMSIS/core_cm4.h **** 
1239:../CMSIS/core_cm4.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
1240:../CMSIS/core_cm4.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
1241:../CMSIS/core_cm4.h **** 
1242:../CMSIS/core_cm4.h **** /* MPU Control Register Definitions */
1243:../CMSIS/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
1244:../CMSIS/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
1245:../CMSIS/core_cm4.h **** 
1246:../CMSIS/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
1247:../CMSIS/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
1248:../CMSIS/core_cm4.h **** 
1249:../CMSIS/core_cm4.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
1250:../CMSIS/core_cm4.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
1251:../CMSIS/core_cm4.h **** 
1252:../CMSIS/core_cm4.h **** /* MPU Region Number Register Definitions */
1253:../CMSIS/core_cm4.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
1254:../CMSIS/core_cm4.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
1255:../CMSIS/core_cm4.h **** 
1256:../CMSIS/core_cm4.h **** /* MPU Region Base Address Register Definitions */
1257:../CMSIS/core_cm4.h **** #define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU 
1258:../CMSIS/core_cm4.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
1259:../CMSIS/core_cm4.h **** 
1260:../CMSIS/core_cm4.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
1261:../CMSIS/core_cm4.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
1262:../CMSIS/core_cm4.h **** 
1263:../CMSIS/core_cm4.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
1264:../CMSIS/core_cm4.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
1265:../CMSIS/core_cm4.h **** 
1266:../CMSIS/core_cm4.h **** /* MPU Region Attribute and Size Register Definitions */
1267:../CMSIS/core_cm4.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
1268:../CMSIS/core_cm4.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
1269:../CMSIS/core_cm4.h **** 
1270:../CMSIS/core_cm4.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
1271:../CMSIS/core_cm4.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
1272:../CMSIS/core_cm4.h **** 
1273:../CMSIS/core_cm4.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
1274:../CMSIS/core_cm4.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
1275:../CMSIS/core_cm4.h **** 
1276:../CMSIS/core_cm4.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
1277:../CMSIS/core_cm4.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
1278:../CMSIS/core_cm4.h **** 
1279:../CMSIS/core_cm4.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
1280:../CMSIS/core_cm4.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
1281:../CMSIS/core_cm4.h **** 
1282:../CMSIS/core_cm4.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
1283:../CMSIS/core_cm4.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
1284:../CMSIS/core_cm4.h **** 
1285:../CMSIS/core_cm4.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
1286:../CMSIS/core_cm4.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
1287:../CMSIS/core_cm4.h **** 
1288:../CMSIS/core_cm4.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
1289:../CMSIS/core_cm4.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
1290:../CMSIS/core_cm4.h **** 
1291:../CMSIS/core_cm4.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
1292:../CMSIS/core_cm4.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
1293:../CMSIS/core_cm4.h **** 
1294:../CMSIS/core_cm4.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
1295:../CMSIS/core_cm4.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
1296:../CMSIS/core_cm4.h **** 
1297:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_MPU */
1298:../CMSIS/core_cm4.h **** #endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
1299:../CMSIS/core_cm4.h **** 
1300:../CMSIS/core_cm4.h **** 
1301:../CMSIS/core_cm4.h **** /**
1302:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1303:../CMSIS/core_cm4.h ****   \defgroup CMSIS_FPU     Floating Point Unit (FPU)
1304:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Floating Point Unit (FPU)
1305:../CMSIS/core_cm4.h ****   @{
1306:../CMSIS/core_cm4.h ****  */
1307:../CMSIS/core_cm4.h **** 
1308:../CMSIS/core_cm4.h **** /**
1309:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Floating Point Unit (FPU).
1310:../CMSIS/core_cm4.h ****  */
1311:../CMSIS/core_cm4.h **** typedef struct
1312:../CMSIS/core_cm4.h **** {
1313:../CMSIS/core_cm4.h ****         uint32_t RESERVED0[1U];
1314:../CMSIS/core_cm4.h ****   __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control R
1315:../CMSIS/core_cm4.h ****   __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address R
1316:../CMSIS/core_cm4.h ****   __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Co
1317:../CMSIS/core_cm4.h ****   __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 
1318:../CMSIS/core_cm4.h ****   __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 
1319:../CMSIS/core_cm4.h **** } FPU_Type;
1320:../CMSIS/core_cm4.h **** 
1321:../CMSIS/core_cm4.h **** /* Floating-Point Context Control Register Definitions */
1322:../CMSIS/core_cm4.h **** #define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCC
1323:../CMSIS/core_cm4.h **** #define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCC
1324:../CMSIS/core_cm4.h **** 
1325:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCC
1326:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCC
1327:../CMSIS/core_cm4.h **** 
1328:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCC
1329:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCC
1330:../CMSIS/core_cm4.h **** 
1331:../CMSIS/core_cm4.h **** #define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCC
1332:../CMSIS/core_cm4.h **** #define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCC
1333:../CMSIS/core_cm4.h **** 
1334:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCC
1335:../CMSIS/core_cm4.h **** #define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCC
1336:../CMSIS/core_cm4.h **** 
1337:../CMSIS/core_cm4.h **** #define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCC
1338:../CMSIS/core_cm4.h **** #define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCC
1339:../CMSIS/core_cm4.h **** 
1340:../CMSIS/core_cm4.h **** #define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCC
1341:../CMSIS/core_cm4.h **** #define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCC
1342:../CMSIS/core_cm4.h **** 
1343:../CMSIS/core_cm4.h **** #define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCC
1344:../CMSIS/core_cm4.h **** #define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCC
1345:../CMSIS/core_cm4.h **** 
1346:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCC
1347:../CMSIS/core_cm4.h **** #define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCC
1348:../CMSIS/core_cm4.h **** 
1349:../CMSIS/core_cm4.h **** /* Floating-Point Context Address Register Definitions */
1350:../CMSIS/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCA
1351:../CMSIS/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCA
1352:../CMSIS/core_cm4.h **** 
1353:../CMSIS/core_cm4.h **** /* Floating-Point Default Status Control Register Definitions */
1354:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDS
1355:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDS
1356:../CMSIS/core_cm4.h **** 
1357:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDS
1358:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDS
1359:../CMSIS/core_cm4.h **** 
1360:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDS
1361:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDS
1362:../CMSIS/core_cm4.h **** 
1363:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDS
1364:../CMSIS/core_cm4.h **** #define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDS
1365:../CMSIS/core_cm4.h **** 
1366:../CMSIS/core_cm4.h **** /* Media and FP Feature Register 0 Definitions */
1367:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR
1368:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR
1369:../CMSIS/core_cm4.h **** 
1370:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR
1371:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR
1372:../CMSIS/core_cm4.h **** 
1373:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR
1374:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR
1375:../CMSIS/core_cm4.h **** 
1376:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR
1377:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR
1378:../CMSIS/core_cm4.h **** 
1379:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR
1380:../CMSIS/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR
1381:../CMSIS/core_cm4.h **** 
1382:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR
1383:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR
1384:../CMSIS/core_cm4.h **** 
1385:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR
1386:../CMSIS/core_cm4.h **** #define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR
1387:../CMSIS/core_cm4.h **** 
1388:../CMSIS/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR
1389:../CMSIS/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR
1390:../CMSIS/core_cm4.h **** 
1391:../CMSIS/core_cm4.h **** /* Media and FP Feature Register 1 Definitions */
1392:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR
1393:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR
1394:../CMSIS/core_cm4.h **** 
1395:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR
1396:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR
1397:../CMSIS/core_cm4.h **** 
1398:../CMSIS/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR
1399:../CMSIS/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR
1400:../CMSIS/core_cm4.h **** 
1401:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR
1402:../CMSIS/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR
1403:../CMSIS/core_cm4.h **** 
1404:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_FPU */
1405:../CMSIS/core_cm4.h **** 
1406:../CMSIS/core_cm4.h **** 
1407:../CMSIS/core_cm4.h **** /**
1408:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_core_register
1409:../CMSIS/core_cm4.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
1410:../CMSIS/core_cm4.h ****   \brief    Type definitions for the Core Debug Registers
1411:../CMSIS/core_cm4.h ****   @{
1412:../CMSIS/core_cm4.h ****  */
1413:../CMSIS/core_cm4.h **** 
1414:../CMSIS/core_cm4.h **** /**
1415:../CMSIS/core_cm4.h ****   \brief  Structure type to access the Core Debug Register (CoreDebug).
1416:../CMSIS/core_cm4.h ****  */
1417:../CMSIS/core_cm4.h **** typedef struct
1418:../CMSIS/core_cm4.h **** {
1419:../CMSIS/core_cm4.h ****   __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
1420:../CMSIS/core_cm4.h ****   __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
1421:../CMSIS/core_cm4.h ****   __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
1422:../CMSIS/core_cm4.h ****   __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
1423:../CMSIS/core_cm4.h **** } CoreDebug_Type;
1424:../CMSIS/core_cm4.h **** 
1425:../CMSIS/core_cm4.h **** /* Debug Halting Control and Status Register Definitions */
1426:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< Core
1427:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
1428:../CMSIS/core_cm4.h **** 
1429:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< Core
1430:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
1431:../CMSIS/core_cm4.h **** 
1432:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< Core
1433:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
1434:../CMSIS/core_cm4.h **** 
1435:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< Core
1436:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
1437:../CMSIS/core_cm4.h **** 
1438:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< Core
1439:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
1440:../CMSIS/core_cm4.h **** 
1441:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< Core
1442:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
1443:../CMSIS/core_cm4.h **** 
1444:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< Core
1445:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
1446:../CMSIS/core_cm4.h **** 
1447:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< Core
1448:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
1449:../CMSIS/core_cm4.h **** 
1450:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< Core
1451:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
1452:../CMSIS/core_cm4.h **** 
1453:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< Core
1454:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
1455:../CMSIS/core_cm4.h **** 
1456:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< Core
1457:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
1458:../CMSIS/core_cm4.h **** 
1459:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< Core
1460:../CMSIS/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< Core
1461:../CMSIS/core_cm4.h **** 
1462:../CMSIS/core_cm4.h **** /* Debug Core Register Selector Register Definitions */
1463:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< Core
1464:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
1465:../CMSIS/core_cm4.h **** 
1466:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< Core
1467:../CMSIS/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< Core
1468:../CMSIS/core_cm4.h **** 
1469:../CMSIS/core_cm4.h **** /* Debug Exception and Monitor Control Register Definitions */
1470:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< Core
1471:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
1472:../CMSIS/core_cm4.h **** 
1473:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< Core
1474:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
1475:../CMSIS/core_cm4.h **** 
1476:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< Core
1477:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
1478:../CMSIS/core_cm4.h **** 
1479:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< Core
1480:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
1481:../CMSIS/core_cm4.h **** 
1482:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< Core
1483:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
1484:../CMSIS/core_cm4.h **** 
1485:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< Core
1486:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
1487:../CMSIS/core_cm4.h **** 
1488:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< Core
1489:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
1490:../CMSIS/core_cm4.h **** 
1491:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< Core
1492:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
1493:../CMSIS/core_cm4.h **** 
1494:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< Core
1495:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
1496:../CMSIS/core_cm4.h **** 
1497:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< Core
1498:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
1499:../CMSIS/core_cm4.h **** 
1500:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< Core
1501:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
1502:../CMSIS/core_cm4.h **** 
1503:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< Core
1504:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
1505:../CMSIS/core_cm4.h **** 
1506:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< Core
1507:../CMSIS/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< Core
1508:../CMSIS/core_cm4.h **** 
1509:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_CoreDebug */
1510:../CMSIS/core_cm4.h **** 
1511:../CMSIS/core_cm4.h **** 
1512:../CMSIS/core_cm4.h **** /**
1513:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
1514:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
1515:../CMSIS/core_cm4.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
1516:../CMSIS/core_cm4.h ****   @{
1517:../CMSIS/core_cm4.h ****  */
1518:../CMSIS/core_cm4.h **** 
1519:../CMSIS/core_cm4.h **** /**
1520:../CMSIS/core_cm4.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
1521:../CMSIS/core_cm4.h ****   \param[in] field  Name of the register bit field.
1522:../CMSIS/core_cm4.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
1523:../CMSIS/core_cm4.h ****   \return           Masked and shifted value.
1524:../CMSIS/core_cm4.h **** */
1525:../CMSIS/core_cm4.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
1526:../CMSIS/core_cm4.h **** 
1527:../CMSIS/core_cm4.h **** /**
1528:../CMSIS/core_cm4.h ****   \brief     Mask and shift a register value to extract a bit filed value.
1529:../CMSIS/core_cm4.h ****   \param[in] field  Name of the register bit field.
1530:../CMSIS/core_cm4.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
1531:../CMSIS/core_cm4.h ****   \return           Masked and shifted bit field value.
1532:../CMSIS/core_cm4.h **** */
1533:../CMSIS/core_cm4.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
1534:../CMSIS/core_cm4.h **** 
1535:../CMSIS/core_cm4.h **** /*@} end of group CMSIS_core_bitfield */
1536:../CMSIS/core_cm4.h **** 
1537:../CMSIS/core_cm4.h **** 
1538:../CMSIS/core_cm4.h **** /**
1539:../CMSIS/core_cm4.h ****   \ingroup    CMSIS_core_register
1540:../CMSIS/core_cm4.h ****   \defgroup   CMSIS_core_base     Core Definitions
1541:../CMSIS/core_cm4.h ****   \brief      Definitions for base addresses, unions, and structures.
1542:../CMSIS/core_cm4.h ****   @{
1543:../CMSIS/core_cm4.h ****  */
1544:../CMSIS/core_cm4.h **** 
1545:../CMSIS/core_cm4.h **** /* Memory mapping of Core Hardware */
1546:../CMSIS/core_cm4.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
1547:../CMSIS/core_cm4.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
1548:../CMSIS/core_cm4.h **** #define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
1549:../CMSIS/core_cm4.h **** #define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
1550:../CMSIS/core_cm4.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
1551:../CMSIS/core_cm4.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
1552:../CMSIS/core_cm4.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
1553:../CMSIS/core_cm4.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
1554:../CMSIS/core_cm4.h **** 
1555:../CMSIS/core_cm4.h **** #define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register 
1556:../CMSIS/core_cm4.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
1557:../CMSIS/core_cm4.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
1558:../CMSIS/core_cm4.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
1559:../CMSIS/core_cm4.h **** #define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct
1560:../CMSIS/core_cm4.h **** #define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct
1561:../CMSIS/core_cm4.h **** #define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct
1562:../CMSIS/core_cm4.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
1563:../CMSIS/core_cm4.h **** 
1564:../CMSIS/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1565:../CMSIS/core_cm4.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
1566:../CMSIS/core_cm4.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
1567:../CMSIS/core_cm4.h **** #endif
1568:../CMSIS/core_cm4.h **** 
1569:../CMSIS/core_cm4.h **** #define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
1570:../CMSIS/core_cm4.h **** #define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
1571:../CMSIS/core_cm4.h **** 
1572:../CMSIS/core_cm4.h **** /*@} */
1573:../CMSIS/core_cm4.h **** 
1574:../CMSIS/core_cm4.h **** 
1575:../CMSIS/core_cm4.h **** 
1576:../CMSIS/core_cm4.h **** /*******************************************************************************
1577:../CMSIS/core_cm4.h ****  *                Hardware Abstraction Layer
1578:../CMSIS/core_cm4.h ****   Core Function Interface contains:
1579:../CMSIS/core_cm4.h ****   - Core NVIC Functions
1580:../CMSIS/core_cm4.h ****   - Core SysTick Functions
1581:../CMSIS/core_cm4.h ****   - Core Debug Functions
1582:../CMSIS/core_cm4.h ****   - Core Register Access Functions
1583:../CMSIS/core_cm4.h ****  ******************************************************************************/
1584:../CMSIS/core_cm4.h **** /**
1585:../CMSIS/core_cm4.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
1586:../CMSIS/core_cm4.h **** */
1587:../CMSIS/core_cm4.h **** 
1588:../CMSIS/core_cm4.h **** 
1589:../CMSIS/core_cm4.h **** 
1590:../CMSIS/core_cm4.h **** /* ##########################   NVIC functions  #################################### */
1591:../CMSIS/core_cm4.h **** /**
1592:../CMSIS/core_cm4.h ****   \ingroup  CMSIS_Core_FunctionInterface
1593:../CMSIS/core_cm4.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
1594:../CMSIS/core_cm4.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
1595:../CMSIS/core_cm4.h ****   @{
1596:../CMSIS/core_cm4.h ****  */
1597:../CMSIS/core_cm4.h **** 
1598:../CMSIS/core_cm4.h **** #ifdef CMSIS_NVIC_VIRTUAL
1599:../CMSIS/core_cm4.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
1600:../CMSIS/core_cm4.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
1601:../CMSIS/core_cm4.h ****   #endif
1602:../CMSIS/core_cm4.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
1603:../CMSIS/core_cm4.h **** #else
1604:../CMSIS/core_cm4.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
1605:../CMSIS/core_cm4.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
1606:../CMSIS/core_cm4.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
1607:../CMSIS/core_cm4.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
1608:../CMSIS/core_cm4.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
1609:../CMSIS/core_cm4.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
1610:../CMSIS/core_cm4.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
1611:../CMSIS/core_cm4.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
1612:../CMSIS/core_cm4.h ****   #define NVIC_GetActive              __NVIC_GetActive
1613:../CMSIS/core_cm4.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
1614:../CMSIS/core_cm4.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
1615:../CMSIS/core_cm4.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
1616:../CMSIS/core_cm4.h **** #endif /* CMSIS_NVIC_VIRTUAL */
1617:../CMSIS/core_cm4.h **** 
1618:../CMSIS/core_cm4.h **** #ifdef CMSIS_VECTAB_VIRTUAL
1619:../CMSIS/core_cm4.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1620:../CMSIS/core_cm4.h ****    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
1621:../CMSIS/core_cm4.h ****   #endif
1622:../CMSIS/core_cm4.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1623:../CMSIS/core_cm4.h **** #else
1624:../CMSIS/core_cm4.h ****   #define NVIC_SetVector              __NVIC_SetVector
1625:../CMSIS/core_cm4.h ****   #define NVIC_GetVector              __NVIC_GetVector
1626:../CMSIS/core_cm4.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
1627:../CMSIS/core_cm4.h **** 
1628:../CMSIS/core_cm4.h **** #define NVIC_USER_IRQ_OFFSET          16
1629:../CMSIS/core_cm4.h **** 
1630:../CMSIS/core_cm4.h **** 
1631:../CMSIS/core_cm4.h **** 
1632:../CMSIS/core_cm4.h **** /**
1633:../CMSIS/core_cm4.h ****   \brief   Set Priority Grouping
1634:../CMSIS/core_cm4.h ****   \details Sets the priority grouping field using the required unlock sequence.
1635:../CMSIS/core_cm4.h ****            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
1636:../CMSIS/core_cm4.h ****            Only values from 0..7 are used.
1637:../CMSIS/core_cm4.h ****            In case of a conflict between priority grouping and available
1638:../CMSIS/core_cm4.h ****            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
1639:../CMSIS/core_cm4.h ****   \param [in]      PriorityGroup  Priority grouping field.
1640:../CMSIS/core_cm4.h ****  */
1641:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
1642:../CMSIS/core_cm4.h **** {
1643:../CMSIS/core_cm4.h ****   uint32_t reg_value;
1644:../CMSIS/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 a
1645:../CMSIS/core_cm4.h **** 
1646:../CMSIS/core_cm4.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
1647:../CMSIS/core_cm4.h ****   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to chan
1648:../CMSIS/core_cm4.h ****   reg_value  =  (reg_value                                   |
1649:../CMSIS/core_cm4.h ****                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
1650:../CMSIS/core_cm4.h ****                 (PriorityGroupTmp << 8U)                      );              /* Insert write key a
1651:../CMSIS/core_cm4.h ****   SCB->AIRCR =  reg_value;
1652:../CMSIS/core_cm4.h **** }
1653:../CMSIS/core_cm4.h **** 
1654:../CMSIS/core_cm4.h **** 
1655:../CMSIS/core_cm4.h **** /**
1656:../CMSIS/core_cm4.h ****   \brief   Get Priority Grouping
1657:../CMSIS/core_cm4.h ****   \details Reads the priority grouping field from the NVIC Interrupt Controller.
1658:../CMSIS/core_cm4.h ****   \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
1659:../CMSIS/core_cm4.h ****  */
1660:../CMSIS/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
1661:../CMSIS/core_cm4.h **** {
1662:../CMSIS/core_cm4.h ****   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
1663:../CMSIS/core_cm4.h **** }
1664:../CMSIS/core_cm4.h **** 
1665:../CMSIS/core_cm4.h **** 
1666:../CMSIS/core_cm4.h **** /**
1667:../CMSIS/core_cm4.h ****   \brief   Enable Interrupt
1668:../CMSIS/core_cm4.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
1669:../CMSIS/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1670:../CMSIS/core_cm4.h ****   \note    IRQn must not be negative.
1671:../CMSIS/core_cm4.h ****  */
1672:../CMSIS/core_cm4.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
1673:../CMSIS/core_cm4.h **** {
1674:../CMSIS/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1675:../CMSIS/core_cm4.h ****   {
1676:../CMSIS/core_cm4.h ****     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) &
 1005              		.loc 5 1676 0
 1006 01da 3A4A     		ldr	r2, .L117+20
 1007 01dc 4FF40021 		mov	r1, #524288
 1008 01e0 9160     		str	r1, [r2, #8]
 1009              	.LVL99:
 1010              	.L75:
 1011              	.LBE116:
 1012              	.LBE115:
 1013              	.LBE114:
 460:../drivers/fsl_enet.c ****     {
 1014              		.loc 1 460 0
 1015 01e2 13F0407F 		tst	r3, #50331648
 1016 01e6 06D0     		beq	.L76
 462:../drivers/fsl_enet.c ****         EnableIRQ(s_enetRxIrqId[instance]);
 1017              		.loc 1 462 0
 1018 01e8 374A     		ldr	r2, .L117+24
 1019 01ea 3849     		ldr	r1, .L117+28
 1020 01ec 1160     		str	r1, [r2]
 1021              	.LVL100:
 1022              	.LBB117:
 1023              	.LBB118:
 1024              	.LBB119:
 1025              		.loc 5 1676 0
 1026 01ee 354A     		ldr	r2, .L117+20
 1027 01f0 4FF48011 		mov	r1, #1048576
 1028 01f4 9160     		str	r1, [r2, #8]
 1029              	.LVL101:
 1030              	.L76:
 1031              	.LBE119:
 1032              	.LBE118:
 1033              	.LBE117:
 465:../drivers/fsl_enet.c ****     {
 1034              		.loc 1 465 0
 1035 01f6 364A     		ldr	r2, .L117+32
 1036 01f8 1342     		tst	r3, r2
 1037 01fa 06D0     		beq	.L46
 467:../drivers/fsl_enet.c ****         EnableIRQ(s_enetErrIrqId[instance]);
 1038              		.loc 1 467 0
 1039 01fc 354B     		ldr	r3, .L117+36
 1040 01fe 364A     		ldr	r2, .L117+40
 1041 0200 1A60     		str	r2, [r3]
 1042              	.LVL102:
 1043              	.LBB120:
 1044              	.LBB121:
 1045              	.LBB122:
 1046              		.loc 5 1676 0
 1047 0202 304B     		ldr	r3, .L117+20
 1048 0204 4FF40012 		mov	r2, #2097152
 1049 0208 9A60     		str	r2, [r3, #8]
 1050              	.LVL103:
 1051              	.L46:
 1052              	.LBE122:
 1053              	.LBE121:
 1054              	.LBE120:
 1055              	.LBE113:
 1056              	.LBE112:
 401:../drivers/fsl_enet.c **** 
 1057              		.loc 1 401 0
 1058 020a 03B0     		add	sp, sp, #12
 1059              		.cfi_remember_state
 1060              		.cfi_def_cfa_offset 36
 1061              		@ sp needed
 1062 020c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1063              	.LVL104:
 1064              	.L53:
 1065              		.cfi_restore_state
 1066              	.LBB123:
 1067              	.LBB96:
 729:../drivers/fsl_enet.c ****         {
 1068              		.loc 1 729 0
 1069 0210 D3F810C0 		ldr	ip, [r3, #16]
 1070 0214 BCF1000F 		cmp	ip, #0
 1071 0218 01D1     		bne	.L48
 1072              	.L49:
 764:../drivers/fsl_enet.c ****     }
 1073              		.loc 1 764 0
 1074 021a 1C33     		adds	r3, r3, #28
 1075              	.LVL105:
 1076 021c 07E7     		b	.L47
 1077              	.L48:
 729:../drivers/fsl_enet.c ****         {
 1078              		.loc 1 729 0
 1079 021e 9969     		ldr	r1, [r3, #24]
 1080 0220 0029     		cmp	r1, #0
 1081 0222 FAD0     		beq	.L49
 1082              	.LVL106:
 1083              	.LBB94:
 738:../drivers/fsl_enet.c ****             {
 1084              		.loc 1 738 0
 1085 0224 B3F80280 		ldrh	r8, [r3, #2]
 732:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1086              		.loc 1 732 0
 1087 0228 9A68     		ldr	r2, [r3, #8]
 1088 022a 0192     		str	r2, [sp, #4]
 1089              	.LVL107:
 747:../drivers/fsl_enet.c ****                 {
 1090              		.loc 1 747 0
 1091 022c 08F1FF3A 		add	r10, r8, #-1
 738:../drivers/fsl_enet.c ****             {
 1092              		.loc 1 738 0
 1093 0230 0022     		movs	r2, #0
 1094              	.LVL108:
 1095              	.L50:
 1096 0232 4245     		cmp	r2, r8
 1097 0234 0CEBC200 		add	r0, ip, r2, lsl #3
 1098              	.LVL109:
 1099 0238 EFD2     		bcs	.L49
 743:../drivers/fsl_enet.c ****                 /* Sets the crc. */
 1100              		.loc 1 743 0
 1101 023a 4FF0000E 		mov	lr, #0	@ movhi
 741:../drivers/fsl_enet.c ****                 /* Initializes data length. */
 1102              		.loc 1 741 0
 1103 023e 4160     		str	r1, [r0, #4]
 743:../drivers/fsl_enet.c ****                 /* Sets the crc. */
 1104              		.loc 1 743 0
 1105 0240 2CF832E0 		strh	lr, [ip, r2, lsl #3]	@ movhi
 747:../drivers/fsl_enet.c ****                 {
 1106              		.loc 1 747 0
 1107 0244 9245     		cmp	r10, r2
 745:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 1108              		.loc 1 745 0
 1109 0246 A0F80290 		strh	r9, [r0, #2]	@ movhi
 749:../drivers/fsl_enet.c ****                 }
 1110              		.loc 1 749 0
 1111 024a 02BF     		ittt	eq
 1112 024c B0F802E0 		ldrheq	lr, [r0, #2]
 1113 0250 4EF4005E 		orreq	lr, lr, #8192
 1114 0254 A0F802E0 		strheq	lr, [r0, #2]	@ movhi
 1115              	.LVL110:
 1116 0258 0198     		ldr	r0, [sp, #4]
 738:../drivers/fsl_enet.c ****             {
 1117              		.loc 1 738 0
 1118 025a 0132     		adds	r2, r2, #1
 1119              	.LVL111:
 1120 025c 0144     		add	r1, r1, r0
 1121 025e E8E7     		b	.L50
 1122              	.LVL112:
 1123              	.L60:
 1124              	.LBE94:
 1125              	.LBE96:
 1126              	.LBE123:
 1127              	.LBB124:
 1128              	.LBB102:
 800:../drivers/fsl_enet.c ****         {
 1129              		.loc 1 800 0
 1130 0260 D3F80CC0 		ldr	ip, [r3, #12]
 1131 0264 BCF1000F 		cmp	ip, #0
 1132 0268 01D1     		bne	.L55
 1133              	.L56:
 838:../drivers/fsl_enet.c ****     }
 1134              		.loc 1 838 0
 1135 026a 1C33     		adds	r3, r3, #28
 1136              	.LVL113:
 1137 026c EAE6     		b	.L54
 1138              	.L55:
 800:../drivers/fsl_enet.c ****         {
 1139              		.loc 1 800 0
 1140 026e 5969     		ldr	r1, [r3, #20]
 1141 0270 0029     		cmp	r1, #0
 1142 0272 FAD0     		beq	.L56
 1143              	.LVL114:
 1144              	.LBB100:
 809:../drivers/fsl_enet.c ****             {
 1145              		.loc 1 809 0
 1146 0274 B3F80080 		ldrh	r8, [r3]
 803:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1147              		.loc 1 803 0
 1148 0278 5A68     		ldr	r2, [r3, #4]
 1149 027a 0192     		str	r2, [sp, #4]
 1150              	.LVL115:
 818:../drivers/fsl_enet.c ****                 {
 1151              		.loc 1 818 0
 1152 027c 08F1FF3B 		add	fp, r8, #-1
 809:../drivers/fsl_enet.c ****             {
 1153              		.loc 1 809 0
 1154 0280 0022     		movs	r2, #0
 1155              	.LVL116:
 1156              	.L57:
 1157 0282 4245     		cmp	r2, r8
 1158 0284 0CEBC200 		add	r0, ip, r2, lsl #3
 1159              	.LVL117:
 1160 0288 EFD2     		bcs	.L56
 813:../drivers/fsl_enet.c **** 
 1161              		.loc 1 813 0
 1162 028a 4FF0000E 		mov	lr, #0	@ movhi
 812:../drivers/fsl_enet.c ****                 curBuffDescrip->length = 0;
 1163              		.loc 1 812 0
 1164 028e 4160     		str	r1, [r0, #4]
 813:../drivers/fsl_enet.c **** 
 1165              		.loc 1 813 0
 1166 0290 2CF832E0 		strh	lr, [ip, r2, lsl #3]	@ movhi
 818:../drivers/fsl_enet.c ****                 {
 1167              		.loc 1 818 0
 1168 0294 5A45     		cmp	r2, fp
 816:../drivers/fsl_enet.c ****                 /* Sets the last buffer descriptor with the wrap flag. */
 1169              		.loc 1 816 0
 1170 0296 A0F80290 		strh	r9, [r0, #2]	@ movhi
 820:../drivers/fsl_enet.c ****                 }
 1171              		.loc 1 820 0
 1172 029a 02BF     		ittt	eq
 1173 029c B0F802E0 		ldrheq	lr, [r0, #2]
 1174 02a0 4EF4005E 		orreq	lr, lr, #8192
 1175 02a4 A0F802E0 		strheq	lr, [r0, #2]	@ movhi
 1176              	.LVL118:
 1177 02a8 0198     		ldr	r0, [sp, #4]
 809:../drivers/fsl_enet.c ****             {
 1178              		.loc 1 809 0
 1179 02aa 0132     		adds	r2, r2, #1
 1180              	.LVL119:
 1181 02ac 0144     		add	r1, r1, r0
 1182 02ae E8E7     		b	.L57
 1183              	.L118:
 1184              		.align	2
 1185              	.L117:
 1186 02b0 2C800440 		.word	1074036780
 1187 02b4 0000FF3F 		.word	1073676288
 1188 02b8 00000000 		.word	.LANCHOR0
 1189 02bc 00000000 		.word	.LANCHOR1
 1190 02c0 00000000 		.word	ENET_TransmitIRQHandler
 1191 02c4 00E100E0 		.word	-536813312
 1192 02c8 00000000 		.word	.LANCHOR2
 1193 02cc 00000000 		.word	ENET_ReceiveIRQHandler
 1194 02d0 00007C60 		.word	1618739200
 1195 02d4 00000000 		.word	.LANCHOR3
 1196 02d8 00000000 		.word	ENET_ErrorIRQHandler
 1197              	.LBE100:
 1198              	.LBE102:
 1199              	.LBE124:
 1200              		.cfi_endproc
 1201              	.LFE159:
 1203              		.section	.text.ENET_StartSMIWrite,"ax",%progbits
 1204              		.align	1
 1205              		.global	ENET_StartSMIWrite
 1206              		.syntax unified
 1207              		.thumb
 1208              		.thumb_func
 1209              		.fpu fpv4-sp-d16
 1211              	ENET_StartSMIWrite:
 1212              	.LFB171:
 961:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 1213              		.loc 1 961 0
 1214              		.cfi_startproc
 1215              		@ args = 4, pretend = 0, frame = 0
 1216              		@ frame_needed = 0, uses_anonymous_args = 0
 1217              	.LVL120:
 1218 0000 10B5     		push	{r4, lr}
 1219              		.cfi_def_cfa_offset 8
 1220              		.cfi_offset 4, -8
 1221              		.cfi_offset 14, -4
 966:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 1222              		.loc 1 966 0
 1223 0002 BDF80840 		ldrh	r4, [sp, #8]
 965:../drivers/fsl_enet.c ****            (data & 0xFFFF);
 1224              		.loc 1 965 0
 1225 0006 9204     		lsls	r2, r2, #18
 1226              	.LVL121:
 1227 0008 44F08044 		orr	r4, r4, #1073741824
 1228 000c 02F4F802 		and	r2, r2, #8126464
 1229 0010 44F40034 		orr	r4, r4, #131072
 1230 0014 C905     		lsls	r1, r1, #23
 1231              	.LVL122:
 1232 0016 2243     		orrs	r2, r2, r4
 1233 0018 01F07861 		and	r1, r1, #260046848
 1234 001c 1B07     		lsls	r3, r3, #28
 1235              	.LVL123:
 1236 001e 0A43     		orrs	r2, r2, r1
 1237 0020 03F04053 		and	r3, r3, #805306368
 1238 0024 1A43     		orrs	r2, r2, r3
 1239              	.LVL124:
 967:../drivers/fsl_enet.c **** }
 1240              		.loc 1 967 0
 1241 0026 0264     		str	r2, [r0, #64]
 968:../drivers/fsl_enet.c **** 
 1242              		.loc 1 968 0
 1243 0028 10BD     		pop	{r4, pc}
 1244              		.cfi_endproc
 1245              	.LFE171:
 1247              		.section	.text.ENET_StartSMIRead,"ax",%progbits
 1248              		.align	1
 1249              		.global	ENET_StartSMIRead
 1250              		.syntax unified
 1251              		.thumb
 1252              		.thumb_func
 1253              		.fpu fpv4-sp-d16
 1255              	ENET_StartSMIRead:
 1256              	.LFB172:
 971:../drivers/fsl_enet.c ****     uint32_t mmfr = 0;
 1257              		.loc 1 971 0
 1258              		.cfi_startproc
 1259              		@ args = 0, pretend = 0, frame = 0
 1260              		@ frame_needed = 0, uses_anonymous_args = 0
 1261              		@ link register save eliminated.
 1262              	.LVL125:
 975:../drivers/fsl_enet.c ****     base->MMFR = mmfr;
 1263              		.loc 1 975 0
 1264 0000 9204     		lsls	r2, r2, #18
 1265              	.LVL126:
 1266 0002 02F4F802 		and	r2, r2, #8126464
 1267 0006 42F08042 		orr	r2, r2, #1073741824
 1268 000a C905     		lsls	r1, r1, #23
 1269              	.LVL127:
 1270 000c 42F40032 		orr	r2, r2, #131072
 1271 0010 01F07861 		and	r1, r1, #260046848
 1272 0014 1B07     		lsls	r3, r3, #28
 1273              	.LVL128:
 1274 0016 0A43     		orrs	r2, r2, r1
 1275 0018 03F04053 		and	r3, r3, #805306368
 1276 001c 1A43     		orrs	r2, r2, r3
 1277              	.LVL129:
 976:../drivers/fsl_enet.c **** }
 1278              		.loc 1 976 0
 1279 001e 0264     		str	r2, [r0, #64]
 977:../drivers/fsl_enet.c **** 
 1280              		.loc 1 977 0
 1281 0020 7047     		bx	lr
 1282              		.cfi_endproc
 1283              	.LFE172:
 1285              		.section	.text.ENET_GetRxErrBeforeReadFrame,"ax",%progbits
 1286              		.align	1
 1287              		.global	ENET_GetRxErrBeforeReadFrame
 1288              		.syntax unified
 1289              		.thumb
 1290              		.thumb_func
 1291              		.fpu fpv4-sp-d16
 1293              	ENET_GetRxErrBeforeReadFrame:
 1294              	.LFB173:
1020:../drivers/fsl_enet.c ****     assert(handle);
 1295              		.loc 1 1020 0
 1296              		.cfi_startproc
 1297              		@ args = 0, pretend = 0, frame = 0
 1298              		@ frame_needed = 0, uses_anonymous_args = 0
 1299              	.LVL130:
 1300 0000 10B5     		push	{r4, lr}
 1301              		.cfi_def_cfa_offset 8
 1302              		.cfi_offset 4, -8
 1303              		.cfi_offset 14, -4
1026:../drivers/fsl_enet.c **** 
 1304              		.loc 1 1026 0
 1305 0002 4268     		ldr	r2, [r0, #4]
 1306              	.LVL131:
 1307 0004 1346     		mov	r3, r2
 1308              	.LVL132:
 1309              	.L131:
1031:../drivers/fsl_enet.c ****         {
 1310              		.loc 1 1031 0
 1311 0006 5C88     		ldrh	r4, [r3, #2]
 1312 0008 2405     		lsls	r4, r4, #20
 1313 000a 1BD5     		bpl	.L122
1033:../drivers/fsl_enet.c ****             if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
 1314              		.loc 1 1033 0
 1315 000c 5B88     		ldrh	r3, [r3, #2]
 1316              	.LVL133:
 1317 000e 9BB2     		uxth	r3, r3
 1318              	.LVL134:
1034:../drivers/fsl_enet.c ****             {
 1319              		.loc 1 1034 0
 1320 0010 DA07     		lsls	r2, r3, #31
1037:../drivers/fsl_enet.c ****             }
 1321              		.loc 1 1037 0
 1322 0012 42BF     		ittt	mi
 1323 0014 0A69     		ldrmi	r2, [r1, #16]
 1324 0016 0132     		addmi	r2, r2, #1
 1325 0018 0A61     		strmi	r2, [r1, #16]
1039:../drivers/fsl_enet.c ****             {
 1326              		.loc 1 1039 0
 1327 001a 9C07     		lsls	r4, r3, #30
1042:../drivers/fsl_enet.c ****             }
 1328              		.loc 1 1042 0
 1329 001c 42BF     		ittt	mi
 1330 001e CA68     		ldrmi	r2, [r1, #12]
 1331 0020 0132     		addmi	r2, r2, #1
 1332 0022 CA60     		strmi	r2, [r1, #12]
1044:../drivers/fsl_enet.c ****             {
 1333              		.loc 1 1044 0
 1334 0024 9806     		lsls	r0, r3, #26
 1335              	.LVL135:
1047:../drivers/fsl_enet.c ****             }
 1336              		.loc 1 1047 0
 1337 0026 42BF     		ittt	mi
 1338 0028 0A68     		ldrmi	r2, [r1]
 1339 002a 0132     		addmi	r2, r2, #1
 1340 002c 0A60     		strmi	r2, [r1]
1049:../drivers/fsl_enet.c ****             {
 1341              		.loc 1 1049 0
 1342 002e DA06     		lsls	r2, r3, #27
1052:../drivers/fsl_enet.c ****             }
 1343              		.loc 1 1052 0
 1344 0030 42BF     		ittt	mi
 1345 0032 4A68     		ldrmi	r2, [r1, #4]
 1346 0034 0132     		addmi	r2, r2, #1
 1347 0036 4A60     		strmi	r2, [r1, #4]
1054:../drivers/fsl_enet.c ****             {
 1348              		.loc 1 1054 0
 1349 0038 5B07     		lsls	r3, r3, #29
 1350              	.LVL136:
 1351 003a 02D5     		bpl	.L121
1057:../drivers/fsl_enet.c ****             }
 1352              		.loc 1 1057 0
 1353 003c 8B68     		ldr	r3, [r1, #8]
 1354 003e 0133     		adds	r3, r3, #1
 1355 0040 8B60     		str	r3, [r1, #8]
 1356              	.L121:
1092:../drivers/fsl_enet.c **** 
 1357              		.loc 1 1092 0
 1358 0042 10BD     		pop	{r4, pc}
 1359              	.LVL137:
 1360              	.L122:
1082:../drivers/fsl_enet.c ****         {
 1361              		.loc 1 1082 0
 1362 0044 5C88     		ldrh	r4, [r3, #2]
 1363 0046 A404     		lsls	r4, r4, #18
1084:../drivers/fsl_enet.c ****         }
 1364              		.loc 1 1084 0
 1365 0048 4CBF     		ite	mi
 1366 004a 0368     		ldrmi	r3, [r0]
 1367              	.LVL138:
1088:../drivers/fsl_enet.c ****         }
 1368              		.loc 1 1088 0
 1369 004c 0833     		addpl	r3, r3, #8
 1370              	.LVL139:
1091:../drivers/fsl_enet.c **** }
 1371              		.loc 1 1091 0
 1372 004e 9342     		cmp	r3, r2
 1373 0050 D9D1     		bne	.L131
 1374 0052 F6E7     		b	.L121
 1375              		.cfi_endproc
 1376              	.LFE173:
 1378              		.section	.text.ENET_GetRxFrameSize,"ax",%progbits
 1379              		.align	1
 1380              		.global	ENET_GetRxFrameSize
 1381              		.syntax unified
 1382              		.thumb
 1383              		.thumb_func
 1384              		.fpu fpv4-sp-d16
 1386              	ENET_GetRxFrameSize:
 1387              	.LFB174:
1095:../drivers/fsl_enet.c ****     assert(handle);
 1388              		.loc 1 1095 0
 1389              		.cfi_startproc
 1390              		@ args = 0, pretend = 0, frame = 0
 1391              		@ frame_needed = 0, uses_anonymous_args = 0
 1392              	.LVL140:
1104:../drivers/fsl_enet.c **** 
 1393              		.loc 1 1104 0
 1394 0000 4268     		ldr	r2, [r0, #4]
1101:../drivers/fsl_enet.c **** 
 1395              		.loc 1 1101 0
 1396 0002 0023     		movs	r3, #0
 1397 0004 0B60     		str	r3, [r1]
 1398              	.LVL141:
1107:../drivers/fsl_enet.c ****     {
 1399              		.loc 1 1107 0
 1400 0006 5388     		ldrh	r3, [r2, #2]
1095:../drivers/fsl_enet.c ****     assert(handle);
 1401              		.loc 1 1095 0
 1402 0008 30B5     		push	{r4, r5, lr}
 1403              		.cfi_def_cfa_offset 12
 1404              		.cfi_offset 4, -12
 1405              		.cfi_offset 5, -8
 1406              		.cfi_offset 14, -4
1107:../drivers/fsl_enet.c ****     {
 1407              		.loc 1 1107 0
 1408 000a 1D04     		lsls	r5, r3, #16
 1409 000c 1AD4     		bmi	.L155
1121:../drivers/fsl_enet.c ****         {
 1410              		.loc 1 1121 0
 1411 000e 104D     		ldr	r5, .L159
 1412 0010 1346     		mov	r3, r2
 1413              	.LVL142:
 1414              	.L154:
1115:../drivers/fsl_enet.c ****         {
 1415              		.loc 1 1115 0
 1416 0012 5C88     		ldrh	r4, [r3, #2]
 1417 0014 2404     		lsls	r4, r4, #16
 1418 0016 02D4     		bmi	.L150
1115:../drivers/fsl_enet.c ****         {
 1419              		.loc 1 1115 0 is_stmt 0 discriminator 1
 1420 0018 1C88     		ldrh	r4, [r3]
 1421 001a A4B2     		uxth	r4, r4
 1422 001c ACB1     		cbz	r4, .L157
 1423              	.L150:
1121:../drivers/fsl_enet.c ****         {
 1424              		.loc 1 1121 0 is_stmt 1
 1425 001e 5C88     		ldrh	r4, [r3, #2]
 1426 0020 2C40     		ands	r4, r4, r5
 1427 0022 B4F5006F 		cmp	r4, #2048
 1428 0026 06D1     		bne	.L151
1124:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1429              		.loc 1 1124 0
 1430 0028 5888     		ldrh	r0, [r3, #2]
 1431              	.LVL143:
 1432 002a 10F03700 		ands	r0, r0, #55
 1433 002e 0CD1     		bne	.L157
1133:../drivers/fsl_enet.c ****             return kStatus_Success;
 1434              		.loc 1 1133 0
 1435 0030 1B88     		ldrh	r3, [r3]
 1436              	.LVL144:
 1437 0032 0B60     		str	r3, [r1]
 1438              	.L148:
1150:../drivers/fsl_enet.c **** 
 1439              		.loc 1 1150 0
 1440 0034 30BD     		pop	{r4, r5, pc}
 1441              	.LVL145:
 1442              	.L151:
1137:../drivers/fsl_enet.c ****         {
 1443              		.loc 1 1137 0
 1444 0036 5C88     		ldrh	r4, [r3, #2]
 1445 0038 A404     		lsls	r4, r4, #18
1139:../drivers/fsl_enet.c ****         }
 1446              		.loc 1 1139 0
 1447 003a 4CBF     		ite	mi
 1448 003c 0368     		ldrmi	r3, [r0]
 1449              	.LVL146:
1143:../drivers/fsl_enet.c ****         }
 1450              		.loc 1 1143 0
 1451 003e 0833     		addpl	r3, r3, #8
 1452              	.LVL147:
1146:../drivers/fsl_enet.c **** 
 1453              		.loc 1 1146 0
 1454 0040 9342     		cmp	r3, r2
 1455 0042 E6D1     		bne	.L154
 1456              	.LVL148:
 1457              	.L155:
1109:../drivers/fsl_enet.c ****     }
 1458              		.loc 1 1109 0
 1459 0044 40F6A270 		movw	r0, #4002
 1460              	.LVL149:
 1461 0048 F4E7     		b	.L148
 1462              	.LVL150:
 1463              	.L157:
1117:../drivers/fsl_enet.c ****         }
 1464              		.loc 1 1117 0
 1465 004a 4FF47A60 		mov	r0, #4000
 1466 004e F1E7     		b	.L148
 1467              	.L160:
 1468              		.align	2
 1469              	.L159:
 1470 0050 0088FFFF 		.word	-30720
 1471              		.cfi_endproc
 1472              	.LFE174:
 1474              		.section	.text.ENET_ReadFrame,"ax",%progbits
 1475              		.align	1
 1476              		.global	ENET_ReadFrame
 1477              		.syntax unified
 1478              		.thumb
 1479              		.thumb_func
 1480              		.fpu fpv4-sp-d16
 1482              	ENET_ReadFrame:
 1483              	.LFB175:
1153:../drivers/fsl_enet.c ****     assert(handle);
 1484              		.loc 1 1153 0
 1485              		.cfi_startproc
 1486              		@ args = 0, pretend = 0, frame = 0
 1487              		@ frame_needed = 0, uses_anonymous_args = 0
 1488              	.LVL151:
 1489 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1490              		.cfi_def_cfa_offset 32
 1491              		.cfi_offset 4, -32
 1492              		.cfi_offset 5, -28
 1493              		.cfi_offset 6, -24
 1494              		.cfi_offset 7, -20
 1495              		.cfi_offset 8, -16
 1496              		.cfi_offset 9, -12
 1497              		.cfi_offset 10, -8
 1498              		.cfi_offset 14, -4
1153:../drivers/fsl_enet.c ****     assert(handle);
 1499              		.loc 1 1153 0
 1500 0004 0646     		mov	r6, r0
 1501 0006 0D46     		mov	r5, r1
 1502 0008 9946     		mov	r9, r3
1161:../drivers/fsl_enet.c ****     status_t result = kStatus_Success;
 1503              		.loc 1 1161 0
 1504 000a 4F68     		ldr	r7, [r1, #4]
 1505              	.LVL152:
1166:../drivers/fsl_enet.c ****     {
 1506              		.loc 1 1166 0
 1507 000c 9246     		mov	r10, r2
 1508 000e 72B9     		cbnz	r2, .L170
 1509              	.LVL153:
 1510              	.L164:
1171:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
 1511              		.loc 1 1171 0
 1512 0010 6B68     		ldr	r3, [r5, #4]
 1513 0012 5C88     		ldrh	r4, [r3, #2]
1173:../drivers/fsl_enet.c **** 
 1514              		.loc 1 1173 0
 1515 0014 3046     		mov	r0, r6
1171:../drivers/fsl_enet.c ****             /* Updates the receive buffer descriptors. */
 1516              		.loc 1 1171 0
 1517 0016 A4B2     		uxth	r4, r4
 1518              	.LVL154:
1173:../drivers/fsl_enet.c **** 
 1519              		.loc 1 1173 0
 1520 0018 2946     		mov	r1, r5
 1521              	.LVL155:
 1522 001a FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1523              	.LVL156:
1176:../drivers/fsl_enet.c ****             {
 1524              		.loc 1 1176 0
 1525 001e 14F40060 		ands	r0, r4, #2048
 1526 0022 19D1     		bne	.L171
 1527              	.LVL157:
1181:../drivers/fsl_enet.c **** 
 1528              		.loc 1 1181 0
 1529 0024 6B68     		ldr	r3, [r5, #4]
 1530 0026 BB42     		cmp	r3, r7
 1531 0028 F2D1     		bne	.L164
 1532              	.LVL158:
 1533              	.L161:
1283:../drivers/fsl_enet.c **** 
 1534              		.loc 1 1283 0
 1535 002a BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1536              	.LVL159:
 1537              	.L170:
1158:../drivers/fsl_enet.c ****     uint16_t control;
 1538              		.loc 1 1158 0
 1539 002e 4FF00008 		mov	r8, #0
 1540              	.LVL160:
 1541              	.L162:
1213:../drivers/fsl_enet.c ****             {
 1542              		.loc 1 1213 0
 1543 0032 7B88     		ldrh	r3, [r7, #2]
 1544 0034 13F40064 		ands	r4, r3, #2048
 1545 0038 19D0     		beq	.L165
 1546              	.LVL161:
1217:../drivers/fsl_enet.c ****                 {
 1547              		.loc 1 1217 0
 1548 003a 3B88     		ldrh	r3, [r7]
 1549 003c 9945     		cmp	r9, r3
 1550 003e 0DD1     		bne	.L166
1220:../drivers/fsl_enet.c **** #if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
 1551              		.loc 1 1220 0
 1552 0040 3A88     		ldrh	r2, [r7]
 1553              	.LVL162:
1224:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1554              		.loc 1 1224 0
 1555 0042 7968     		ldr	r1, [r7, #4]
 1556              	.LVL163:
1226:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1557              		.loc 1 1226 0
 1558 0044 A2EB0802 		sub	r2, r2, r8
 1559              	.LVL164:
 1560 0048 0AEB0800 		add	r0, r10, r8
 1561 004c FFF7FEFF 		bl	memcpy
 1562              	.LVL165:
1238:../drivers/fsl_enet.c ****                     return result;
 1563              		.loc 1 1238 0
 1564 0050 2946     		mov	r1, r5
 1565 0052 3046     		mov	r0, r6
 1566 0054 FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1567              	.LVL166:
 1568              	.L171:
1183:../drivers/fsl_enet.c ****     }
 1569              		.loc 1 1183 0
 1570 0058 0020     		movs	r0, #0
 1571 005a E6E7     		b	.L161
 1572              	.LVL167:
 1573              	.L166:
1244:../drivers/fsl_enet.c ****                 }
 1574              		.loc 1 1244 0
 1575 005c 2946     		mov	r1, r5
 1576 005e 3046     		mov	r0, r6
 1577              	.LVL168:
 1578 0060 FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1579              	.LVL169:
1216:../drivers/fsl_enet.c ****                 if (length == curBuffDescrip->length)
 1580              		.loc 1 1216 0
 1581 0064 0124     		movs	r4, #1
 1582              	.LVL170:
 1583              	.L167:
1269:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
 1584              		.loc 1 1269 0
 1585 0066 6F68     		ldr	r7, [r5, #4]
 1586              	.LVL171:
1210:../drivers/fsl_enet.c ****         {
 1587              		.loc 1 1210 0
 1588 0068 002C     		cmp	r4, #0
 1589 006a E2D0     		beq	.L162
 1590 006c 01E0     		b	.L169
 1591              	.LVL172:
 1592              	.L165:
1252:../drivers/fsl_enet.c ****                 {
 1593              		.loc 1 1252 0
 1594 006e C145     		cmp	r9, r8
 1595 0070 02D8     		bhi	.L168
 1596              	.LVL173:
 1597              	.L169:
1282:../drivers/fsl_enet.c **** }
 1598              		.loc 1 1282 0
 1599 0072 40F6A170 		movw	r0, #4001
 1600              	.LVL174:
 1601 0076 D8E7     		b	.L161
 1602              	.LVL175:
 1603              	.L168:
1259:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1604              		.loc 1 1259 0
 1605 0078 7968     		ldr	r1, [r7, #4]
 1606              	.LVL176:
1261:../drivers/fsl_enet.c ****                 offset += handle->rxBuffSizeAlign[0];
 1607              		.loc 1 1261 0
 1608 007a 2A69     		ldr	r2, [r5, #16]
 1609 007c 0AEB0800 		add	r0, r10, r8
 1610              	.LVL177:
 1611 0080 FFF7FEFF 		bl	memcpy
 1612              	.LVL178:
1262:../drivers/fsl_enet.c **** 
 1613              		.loc 1 1262 0
 1614 0084 2B69     		ldr	r3, [r5, #16]
1265:../drivers/fsl_enet.c ****             }
 1615              		.loc 1 1265 0
 1616 0086 2946     		mov	r1, r5
 1617 0088 3046     		mov	r0, r6
1262:../drivers/fsl_enet.c **** 
 1618              		.loc 1 1262 0
 1619 008a 9844     		add	r8, r8, r3
 1620              	.LVL179:
1265:../drivers/fsl_enet.c ****             }
 1621              		.loc 1 1265 0
 1622 008c FFF7FEFF 		bl	ENET_UpdateReadBuffers.constprop.3
 1623              	.LVL180:
 1624 0090 E9E7     		b	.L167
 1625              		.cfi_endproc
 1626              	.LFE175:
 1628              		.section	.text.ENET_SendFrame,"ax",%progbits
 1629              		.align	1
 1630              		.global	ENET_SendFrame
 1631              		.syntax unified
 1632              		.thumb
 1633              		.thumb_func
 1634              		.fpu fpv4-sp-d16
 1636              	ENET_SendFrame:
 1637              	.LFB177:
1326:../drivers/fsl_enet.c ****     assert(handle);
 1638              		.loc 1 1326 0
 1639              		.cfi_startproc
 1640              		@ args = 0, pretend = 0, frame = 0
 1641              		@ frame_needed = 0, uses_anonymous_args = 0
 1642              	.LVL181:
 1643 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1644              		.cfi_def_cfa_offset 40
 1645              		.cfi_offset 3, -40
 1646              		.cfi_offset 4, -36
 1647              		.cfi_offset 5, -32
 1648              		.cfi_offset 6, -28
 1649              		.cfi_offset 7, -24
 1650              		.cfi_offset 8, -20
 1651              		.cfi_offset 9, -16
 1652              		.cfi_offset 10, -12
 1653              		.cfi_offset 11, -8
 1654              		.cfi_offset 14, -4
1326:../drivers/fsl_enet.c ****     assert(handle);
 1655              		.loc 1 1326 0
 1656 0004 1E46     		mov	r6, r3
1336:../drivers/fsl_enet.c ****     {
 1657              		.loc 1 1336 0
 1658 0006 40F2EE53 		movw	r3, #1518
 1659              	.LVL182:
 1660 000a 9E42     		cmp	r6, r3
1326:../drivers/fsl_enet.c ****     assert(handle);
 1661              		.loc 1 1326 0
 1662 000c 8046     		mov	r8, r0
 1663 000e 0D46     		mov	r5, r1
 1664 0010 9146     		mov	r9, r2
1336:../drivers/fsl_enet.c ****     {
 1665              		.loc 1 1336 0
 1666 0012 5BD8     		bhi	.L183
1342:../drivers/fsl_enet.c ****     if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
 1667              		.loc 1 1342 0
 1668 0014 CC68     		ldr	r4, [r1, #12]
 1669              	.LVL183:
1343:../drivers/fsl_enet.c ****     {
 1670              		.loc 1 1343 0
 1671 0016 6388     		ldrh	r3, [r4, #2]
 1672 0018 1804     		lsls	r0, r3, #16
 1673              	.LVL184:
 1674 001a 03D5     		bpl	.L175
 1675              	.LVL185:
 1676              	.L182:
1345:../drivers/fsl_enet.c ****     }
 1677              		.loc 1 1345 0
 1678 001c 40F6A470 		movw	r0, #4004
 1679              	.LVL186:
 1680              	.L173:
1480:../drivers/fsl_enet.c **** 
 1681              		.loc 1 1480 0
 1682 0020 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1683              	.LVL187:
 1684              	.L175:
1353:../drivers/fsl_enet.c ****     {
 1685              		.loc 1 1353 0
 1686 0024 4B69     		ldr	r3, [r1, #20]
 1687 0026 B342     		cmp	r3, r6
 1688 0028 17D3     		bcc	.L184
1361:../drivers/fsl_enet.c ****         /* Set data length. */
 1689              		.loc 1 1361 0
 1690 002a 3246     		mov	r2, r6
 1691              	.LVL188:
 1692 002c 4946     		mov	r1, r9
 1693              	.LVL189:
1359:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1694              		.loc 1 1359 0
 1695 002e 6068     		ldr	r0, [r4, #4]
 1696              	.LVL190:
1363:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1697              		.loc 1 1363 0
 1698 0030 B6B2     		uxth	r6, r6
 1699              	.LVL191:
1361:../drivers/fsl_enet.c ****         /* Set data length. */
 1700              		.loc 1 1361 0
 1701 0032 FFF7FEFF 		bl	memcpy
 1702              	.LVL192:
1363:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
 1703              		.loc 1 1363 0
 1704 0036 2680     		strh	r6, [r4]	@ movhi
1376:../drivers/fsl_enet.c **** 
 1705              		.loc 1 1376 0
 1706 0038 6388     		ldrh	r3, [r4, #2]
 1707 003a 43F40843 		orr	r3, r3, #34816
 1708 003e 6380     		strh	r3, [r4, #2]	@ movhi
1379:../drivers/fsl_enet.c ****         {
 1709              		.loc 1 1379 0
 1710 0040 6388     		ldrh	r3, [r4, #2]
 1711 0042 9904     		lsls	r1, r3, #18
1385:../drivers/fsl_enet.c ****         }
 1712              		.loc 1 1385 0
 1713 0044 56BF     		itet	pl
 1714 0046 EB68     		ldrpl	r3, [r5, #12]
1381:../drivers/fsl_enet.c ****         }
 1715              		.loc 1 1381 0
 1716 0048 AB68     		ldrmi	r3, [r5, #8]
1385:../drivers/fsl_enet.c ****         }
 1717              		.loc 1 1385 0
 1718 004a 0833     		addpl	r3, r3, #8
 1719 004c EB60     		str	r3, [r5, #12]
 1720              	.LVL193:
 1721              	.L188:
 1722              	.LBB125:
 1723              	.LBB126:
 849:../drivers/fsl_enet.c ****             break;
 1724              		.loc 1 849 0
 1725 004e 4FF08073 		mov	r3, #16777216
 1726 0052 C8F81430 		str	r3, [r8, #20]
 1727              	.LVL194:
 1728              	.LBE126:
 1729              	.LBE125:
1470:../drivers/fsl_enet.c ****             }
 1730              		.loc 1 1470 0
 1731 0056 0020     		movs	r0, #0
 1732 0058 E2E7     		b	.L173
 1733              	.LVL195:
 1734              	.L184:
1443:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
 1735              		.loc 1 1443 0
 1736 005a DFF878B0 		ldr	fp, .L189
1331:../drivers/fsl_enet.c ****     uint32_t sizeleft = 0;
 1737              		.loc 1 1331 0
 1738 005e 0027     		movs	r7, #0
 1739              	.LVL196:
 1740              	.L176:
1419:../drivers/fsl_enet.c ****             {
 1741              		.loc 1 1419 0
 1742 0060 6388     		ldrh	r3, [r4, #2]
1435:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
 1743              		.loc 1 1435 0
 1744 0062 6068     		ldr	r0, [r4, #4]
1419:../drivers/fsl_enet.c ****             {
 1745              		.loc 1 1419 0
 1746 0064 9A04     		lsls	r2, r3, #18
1425:../drivers/fsl_enet.c ****             }
 1747              		.loc 1 1425 0
 1748 0066 58BF     		it	pl
 1749 0068 EB68     		ldrpl	r3, [r5, #12]
1429:../drivers/fsl_enet.c ****             {
 1750              		.loc 1 1429 0
 1751 006a 6A69     		ldr	r2, [r5, #20]
1421:../drivers/fsl_enet.c ****             }
 1752              		.loc 1 1421 0
 1753 006c 48BF     		it	mi
 1754 006e AB68     		ldrmi	r3, [r5, #8]
1428:../drivers/fsl_enet.c ****             if (sizeleft > handle->txBuffSizeAlign[0])
 1755              		.loc 1 1428 0
 1756 0070 A6EB070A 		sub	r10, r6, r7
 1757              	.LVL197:
1425:../drivers/fsl_enet.c ****             }
 1758              		.loc 1 1425 0
 1759 0074 58BF     		it	pl
 1760 0076 0833     		addpl	r3, r3, #8
1429:../drivers/fsl_enet.c ****             {
 1761              		.loc 1 1429 0
 1762 0078 5245     		cmp	r2, r10
1425:../drivers/fsl_enet.c ****             }
 1763              		.loc 1 1425 0
 1764 007a EB60     		str	r3, [r5, #12]
 1765 007c 09EB0701 		add	r1, r9, r7
1429:../drivers/fsl_enet.c ****             {
 1766              		.loc 1 1429 0
 1767 0080 19D2     		bcs	.L181
 1768              	.LVL198:
1437:../drivers/fsl_enet.c ****                 /* Data length update. */
 1769              		.loc 1 1437 0
 1770 0082 FFF7FEFF 		bl	memcpy
 1771              	.LVL199:
1439:../drivers/fsl_enet.c ****                 len += handle->txBuffSizeAlign[0];
 1772              		.loc 1 1439 0
 1773 0086 6B69     		ldr	r3, [r5, #20]
 1774 0088 9AB2     		uxth	r2, r3
 1775 008a 2280     		strh	r2, [r4]	@ movhi
1442:../drivers/fsl_enet.c ****                 curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
 1776              		.loc 1 1442 0
 1777 008c 6288     		ldrh	r2, [r4, #2]
 1778 008e 22F40062 		bic	r2, r2, #2048
 1779 0092 1204     		lsls	r2, r2, #16
 1780 0094 120C     		lsrs	r2, r2, #16
 1781 0096 6280     		strh	r2, [r4, #2]	@ movhi
1440:../drivers/fsl_enet.c ****                 /* Sets the control flag. */
 1782              		.loc 1 1440 0
 1783 0098 1F44     		add	r7, r7, r3
 1784              	.LVL200:
1443:../drivers/fsl_enet.c ****                 /* Active the transmit buffer descriptor*/
 1785              		.loc 1 1443 0
 1786 009a 6388     		ldrh	r3, [r4, #2]
 1787 009c 4BEA0303 		orr	r3, fp, r3
 1788 00a0 9BB2     		uxth	r3, r3
 1789 00a2 6380     		strh	r3, [r4, #2]	@ movhi
 1790              	.LVL201:
 1791              	.LBB127:
 1792              	.LBB128:
 849:../drivers/fsl_enet.c ****             break;
 1793              		.loc 1 849 0
 1794 00a4 4FF08073 		mov	r3, #16777216
 1795              	.LBE128:
 1796              	.LBE127:
1474:../drivers/fsl_enet.c **** 
 1797              		.loc 1 1474 0
 1798 00a8 EC68     		ldr	r4, [r5, #12]
 1799              	.LVL202:
 1800              	.LBB130:
 1801              	.LBB129:
 849:../drivers/fsl_enet.c ****             break;
 1802              		.loc 1 849 0
 1803 00aa C8F81430 		str	r3, [r8, #20]
 1804              	.LVL203:
 1805              	.LBE129:
 1806              	.LBE130:
1476:../drivers/fsl_enet.c **** 
 1807              		.loc 1 1476 0
 1808 00ae 6388     		ldrh	r3, [r4, #2]
 1809 00b0 1B04     		lsls	r3, r3, #16
 1810 00b2 D5D5     		bpl	.L176
 1811 00b4 B2E7     		b	.L182
 1812              	.L181:
 1813              	.LVL204:
1454:../drivers/fsl_enet.c ****                 curBuffDescrip->length = sizeleft;
 1814              		.loc 1 1454 0
 1815 00b6 5246     		mov	r2, r10
 1816 00b8 FFF7FEFF 		bl	memcpy
 1817              	.LVL205:
1455:../drivers/fsl_enet.c ****                 /* Set Last buffer wrap flag. */
 1818              		.loc 1 1455 0
 1819 00bc 1FFA8AF3 		uxth	r3, r10
 1820 00c0 2380     		strh	r3, [r4]	@ movhi
1457:../drivers/fsl_enet.c **** #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
 1821              		.loc 1 1457 0
 1822 00c2 6388     		ldrh	r3, [r4, #2]
 1823 00c4 43F40843 		orr	r3, r3, #34816
 1824 00c8 6380     		strh	r3, [r4, #2]	@ movhi
 1825 00ca C0E7     		b	.L188
 1826              	.LVL206:
 1827              	.L183:
1338:../drivers/fsl_enet.c ****     }
 1828              		.loc 1 1338 0
 1829 00cc 40F6A370 		movw	r0, #4003
 1830              	.LVL207:
 1831 00d0 A6E7     		b	.L173
 1832              	.L190:
 1833 00d2 00BF     		.align	2
 1834              	.L189:
 1835 00d4 0080FFFF 		.word	-32768
 1836              		.cfi_endproc
 1837              	.LFE177:
 1839              		.section	.text.ENET_AddMulticastGroup,"ax",%progbits
 1840              		.align	1
 1841              		.global	ENET_AddMulticastGroup
 1842              		.syntax unified
 1843              		.thumb
 1844              		.thumb_func
 1845              		.fpu fpv4-sp-d16
 1847              	ENET_AddMulticastGroup:
 1848              	.LFB178:
1926:../drivers/fsl_enet.c ****     assert(address);
 1849              		.loc 1 1926 0
 1850              		.cfi_startproc
 1851              		@ args = 0, pretend = 0, frame = 0
 1852              		@ frame_needed = 0, uses_anonymous_args = 0
 1853              	.LVL208:
 1854 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1855              		.cfi_def_cfa_offset 20
 1856              		.cfi_offset 4, -20
 1857              		.cfi_offset 5, -16
 1858              		.cfi_offset 6, -12
 1859              		.cfi_offset 7, -8
 1860              		.cfi_offset 14, -4
 1861              	.LBB131:
1943:../drivers/fsl_enet.c ****             }
 1862              		.loc 1 1943 0
 1863 0002 164F     		ldr	r7, .L202
 1864 0004 4B1E     		subs	r3, r1, #1
 1865              	.LBE131:
1929:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
 1866              		.loc 1 1929 0
 1867 0006 4FF0FF32 		mov	r2, #-1
 1868 000a 0531     		adds	r1, r1, #5
 1869              	.LVL209:
 1870              	.L194:
 1871              	.LBB132:
1936:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
 1872              		.loc 1 1936 0
 1873 000c 13F8015F 		ldrb	r5, [r3, #1]!	@ zero_extendqisi2
 1874              	.LVL210:
 1875 0010 0824     		movs	r4, #8
 1876              	.LVL211:
 1877              	.L193:
1939:../drivers/fsl_enet.c ****             {
 1878              		.loc 1 1939 0
 1879 0012 85EA0206 		eor	r6, r5, r2
 1880 0016 16F0010F 		tst	r6, #1
 1881 001a 4FEA5202 		lsr	r2, r2, #1
 1882              	.LVL212:
1943:../drivers/fsl_enet.c ****             }
 1883              		.loc 1 1943 0
 1884 001e 18BF     		it	ne
 1885 0020 7A40     		eorne	r2, r2, r7
 1886              	.LVL213:
1937:../drivers/fsl_enet.c ****         {
 1887              		.loc 1 1937 0
 1888 0022 013C     		subs	r4, r4, #1
 1889              	.LVL214:
1939:../drivers/fsl_enet.c ****             {
 1890              		.loc 1 1939 0
 1891 0024 4FEA5505 		lsr	r5, r5, #1
 1892              	.LVL215:
1937:../drivers/fsl_enet.c ****         {
 1893              		.loc 1 1937 0
 1894 0028 F3D1     		bne	.L193
 1895              	.LVL216:
 1896              	.LBE132:
1934:../drivers/fsl_enet.c ****     {
 1897              		.loc 1 1934 0 discriminator 2
 1898 002a 8B42     		cmp	r3, r1
 1899 002c EED1     		bne	.L194
1954:../drivers/fsl_enet.c ****     {
 1900              		.loc 1 1954 0
 1901 002e 002A     		cmp	r2, #0
 1902 0030 4FEA9261 		lsr	r1, r2, #26
 1903              	.LVL217:
 1904 0034 4FF00103 		mov	r3, #1
 1905              	.LVL218:
 1906 0038 06DB     		blt	.L195
1956:../drivers/fsl_enet.c ****     }
 1907              		.loc 1 1956 0
 1908 003a D0F82421 		ldr	r2, [r0, #292]
 1909              	.LVL219:
 1910 003e 8B40     		lsls	r3, r3, r1
 1911 0040 1343     		orrs	r3, r3, r2
 1912 0042 C0F82431 		str	r3, [r0, #292]
 1913              	.L191:
1962:../drivers/fsl_enet.c **** 
 1914              		.loc 1 1962 0
 1915 0046 F0BD     		pop	{r4, r5, r6, r7, pc}
 1916              	.LVL220:
 1917              	.L195:
1960:../drivers/fsl_enet.c ****     }
 1918              		.loc 1 1960 0
 1919 0048 D0F82021 		ldr	r2, [r0, #288]
 1920              	.LVL221:
 1921 004c 01F01F01 		and	r1, r1, #31
 1922 0050 8B40     		lsls	r3, r3, r1
 1923 0052 1343     		orrs	r3, r3, r2
 1924 0054 C0F82031 		str	r3, [r0, #288]
1962:../drivers/fsl_enet.c **** 
 1925              		.loc 1 1962 0
 1926 0058 F5E7     		b	.L191
 1927              	.L203:
 1928 005a 00BF     		.align	2
 1929              	.L202:
 1930 005c 2083B8ED 		.word	-306674912
 1931              		.cfi_endproc
 1932              	.LFE178:
 1934              		.section	.text.ENET_LeaveMulticastGroup,"ax",%progbits
 1935              		.align	1
 1936              		.global	ENET_LeaveMulticastGroup
 1937              		.syntax unified
 1938              		.thumb
 1939              		.thumb_func
 1940              		.fpu fpv4-sp-d16
 1942              	ENET_LeaveMulticastGroup:
 1943              	.LFB179:
1965:../drivers/fsl_enet.c ****     assert(address);
 1944              		.loc 1 1965 0
 1945              		.cfi_startproc
 1946              		@ args = 0, pretend = 0, frame = 0
 1947              		@ frame_needed = 0, uses_anonymous_args = 0
 1948              	.LVL222:
 1949 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1950              		.cfi_def_cfa_offset 20
 1951              		.cfi_offset 4, -20
 1952              		.cfi_offset 5, -16
 1953              		.cfi_offset 6, -12
 1954              		.cfi_offset 7, -8
 1955              		.cfi_offset 14, -4
 1956              	.LBB133:
1982:../drivers/fsl_enet.c ****             }
 1957              		.loc 1 1982 0
 1958 0002 174F     		ldr	r7, .L215
 1959 0004 4A1E     		subs	r2, r1, #1
 1960              	.LBE133:
1968:../drivers/fsl_enet.c ****     uint32_t count1 = 0;
 1961              		.loc 1 1968 0
 1962 0006 4FF0FF33 		mov	r3, #-1
 1963 000a 0531     		adds	r1, r1, #5
 1964              	.LVL223:
 1965              	.L207:
 1966              	.LBB134:
1975:../drivers/fsl_enet.c ****         for (count2 = 0; count2 < 0x08U; count2++)
 1967              		.loc 1 1975 0
 1968 000c 12F8015F 		ldrb	r5, [r2, #1]!	@ zero_extendqisi2
 1969              	.LVL224:
 1970 0010 0824     		movs	r4, #8
 1971              	.LVL225:
 1972              	.L206:
1978:../drivers/fsl_enet.c ****             {
 1973              		.loc 1 1978 0
 1974 0012 85EA0306 		eor	r6, r5, r3
 1975 0016 16F0010F 		tst	r6, #1
 1976 001a 4FEA5303 		lsr	r3, r3, #1
 1977              	.LVL226:
1982:../drivers/fsl_enet.c ****             }
 1978              		.loc 1 1982 0
 1979 001e 18BF     		it	ne
 1980 0020 7B40     		eorne	r3, r3, r7
 1981              	.LVL227:
1976:../drivers/fsl_enet.c ****         {
 1982              		.loc 1 1976 0
 1983 0022 013C     		subs	r4, r4, #1
 1984              	.LVL228:
1978:../drivers/fsl_enet.c ****             {
 1985              		.loc 1 1978 0
 1986 0024 4FEA5505 		lsr	r5, r5, #1
 1987              	.LVL229:
1976:../drivers/fsl_enet.c ****         {
 1988              		.loc 1 1976 0
 1989 0028 F3D1     		bne	.L206
 1990              	.LVL230:
 1991              	.LBE134:
1973:../drivers/fsl_enet.c ****     {
 1992              		.loc 1 1973 0 discriminator 2
 1993 002a 8A42     		cmp	r2, r1
 1994 002c EED1     		bne	.L207
1993:../drivers/fsl_enet.c ****     {
 1995              		.loc 1 1993 0
 1996 002e 002B     		cmp	r3, #0
 1997 0030 4FEA9362 		lsr	r2, r3, #26
 1998              	.LVL231:
 1999 0034 4FF00103 		mov	r3, #1
 2000              	.LVL232:
 2001 0038 07DB     		blt	.L208
1995:../drivers/fsl_enet.c ****     }
 2002              		.loc 1 1995 0
 2003 003a D0F82411 		ldr	r1, [r0, #292]
 2004              	.LVL233:
 2005 003e 9340     		lsls	r3, r3, r2
 2006 0040 21EA0303 		bic	r3, r1, r3
 2007 0044 C0F82431 		str	r3, [r0, #292]
 2008              	.L204:
2001:../drivers/fsl_enet.c **** 
 2009              		.loc 1 2001 0
 2010 0048 F0BD     		pop	{r4, r5, r6, r7, pc}
 2011              	.LVL234:
 2012              	.L208:
1999:../drivers/fsl_enet.c ****     }
 2013              		.loc 1 1999 0
 2014 004a D0F82011 		ldr	r1, [r0, #288]
 2015 004e 02F01F02 		and	r2, r2, #31
 2016 0052 9340     		lsls	r3, r3, r2
 2017 0054 21EA0303 		bic	r3, r1, r3
 2018 0058 C0F82031 		str	r3, [r0, #288]
2001:../drivers/fsl_enet.c **** 
 2019              		.loc 1 2001 0
 2020 005c F4E7     		b	.L204
 2021              	.L216:
 2022 005e 00BF     		.align	2
 2023              	.L215:
 2024 0060 2083B8ED 		.word	-306674912
 2025              		.cfi_endproc
 2026              	.LFE179:
 2028              		.section	.text.ENET_CommonFrame0IRQHandler,"ax",%progbits
 2029              		.align	1
 2030              		.global	ENET_CommonFrame0IRQHandler
 2031              		.syntax unified
 2032              		.thumb
 2033              		.thumb_func
 2034              		.fpu fpv4-sp-d16
 2036              	ENET_CommonFrame0IRQHandler:
 2037              	.LFB183:
2740:../drivers/fsl_enet.c **** 
2741:../drivers/fsl_enet.c **** #ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
2742:../drivers/fsl_enet.c **** void ENET_Ptp1588TimerIRQHandler(ENET_Type *base, enet_handle_t *handle)
2743:../drivers/fsl_enet.c **** {
2744:../drivers/fsl_enet.c ****     assert(handle);
2745:../drivers/fsl_enet.c **** 
2746:../drivers/fsl_enet.c ****     /* Check if the PTP time stamp interrupt happen. */
2747:../drivers/fsl_enet.c ****     if (kENET_TsTimerInterrupt & base->EIR)
2748:../drivers/fsl_enet.c ****     {
2749:../drivers/fsl_enet.c ****         /* Clear the time stamp interrupt. */
2750:../drivers/fsl_enet.c ****         base->EIR = kENET_TsTimerInterrupt;
2751:../drivers/fsl_enet.c **** 
2752:../drivers/fsl_enet.c ****         /* Increase timer second counter. */
2753:../drivers/fsl_enet.c ****         handle->msTimerSecond++;
2754:../drivers/fsl_enet.c **** 
2755:../drivers/fsl_enet.c ****         /* Callback function. */
2756:../drivers/fsl_enet.c ****         if (handle->callback)
2757:../drivers/fsl_enet.c ****         {
2758:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2759:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_TimeStampEvent, handle->userData);
2760:../drivers/fsl_enet.c **** #else
2761:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_TimeStampEvent, handle->userData);
2762:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2763:../drivers/fsl_enet.c ****         }
2764:../drivers/fsl_enet.c ****     }
2765:../drivers/fsl_enet.c ****     else
2766:../drivers/fsl_enet.c ****     {
2767:../drivers/fsl_enet.c ****         /* Clear the time stamp interrupt. */
2768:../drivers/fsl_enet.c ****         base->EIR = kENET_TsAvailInterrupt;
2769:../drivers/fsl_enet.c ****         /* Callback function. */
2770:../drivers/fsl_enet.c ****         if (handle->callback)
2771:../drivers/fsl_enet.c ****         {
2772:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2773:../drivers/fsl_enet.c ****             handle->callback(base, handle, 0, kENET_TimeStampAvailEvent, handle->userData);
2774:../drivers/fsl_enet.c **** #else
2775:../drivers/fsl_enet.c ****             handle->callback(base, handle, kENET_TimeStampAvailEvent, handle->userData);
2776:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2777:../drivers/fsl_enet.c ****         }
2778:../drivers/fsl_enet.c ****     }
2779:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2780:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2781:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2782:../drivers/fsl_enet.c ****     __DSB();
2783:../drivers/fsl_enet.c **** #endif
2784:../drivers/fsl_enet.c **** }
2785:../drivers/fsl_enet.c **** #endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
2786:../drivers/fsl_enet.c **** 
2787:../drivers/fsl_enet.c **** void ENET_CommonFrame0IRQHandler(ENET_Type *base)
2788:../drivers/fsl_enet.c **** {
 2038              		.loc 1 2788 0
 2039              		.cfi_startproc
 2040              		@ args = 0, pretend = 0, frame = 0
 2041              		@ frame_needed = 0, uses_anonymous_args = 0
 2042              	.LVL235:
 2043 0000 70B5     		push	{r4, r5, r6, lr}
 2044              		.cfi_def_cfa_offset 16
 2045              		.cfi_offset 4, -16
 2046              		.cfi_offset 5, -12
 2047              		.cfi_offset 6, -8
 2048              		.cfi_offset 14, -4
2789:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
 2049              		.loc 1 2789 0
 2050 0002 4668     		ldr	r6, [r0, #4]
 2051              	.LVL236:
2788:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
 2052              		.loc 1 2788 0
 2053 0004 0446     		mov	r4, r0
2790:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 2054              		.loc 1 2790 0
 2055 0006 FFF7FEFF 		bl	ENET_GetInstance
 2056              	.LVL237:
2791:../drivers/fsl_enet.c **** 
2792:../drivers/fsl_enet.c ****     if (event & (kENET_TxBufferInterrupt | kENET_TxFrameInterrupt))
 2057              		.loc 1 2792 0
 2058 000a 16F0406F 		tst	r6, #201326592
2790:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
 2059              		.loc 1 2790 0
 2060 000e 0546     		mov	r5, r0
 2061              	.LVL238:
 2062              		.loc 1 2792 0
 2063 0010 06D0     		beq	.L218
2793:../drivers/fsl_enet.c ****     {
2794:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2795:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance], 0);
2796:../drivers/fsl_enet.c **** #else
2797:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance]);
 2064              		.loc 1 2797 0
 2065 0012 134B     		ldr	r3, .L234
 2066 0014 134A     		ldr	r2, .L234+4
 2067 0016 1B68     		ldr	r3, [r3]
 2068 0018 52F82010 		ldr	r1, [r2, r0, lsl #2]
 2069 001c 2046     		mov	r0, r4
 2070              	.LVL239:
 2071 001e 9847     		blx	r3
 2072              	.LVL240:
 2073              	.L218:
2798:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2799:../drivers/fsl_enet.c ****     }
2800:../drivers/fsl_enet.c **** 
2801:../drivers/fsl_enet.c ****     if (event & (kENET_RxBufferInterrupt | kENET_RxFrameInterrupt))
 2074              		.loc 1 2801 0
 2075 0020 16F0407F 		tst	r6, #50331648
 2076 0024 06D0     		beq	.L219
2802:../drivers/fsl_enet.c ****     {
2803:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2804:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance], 0);
2805:../drivers/fsl_enet.c **** #else
2806:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance]);
 2077              		.loc 1 2806 0
 2078 0026 104B     		ldr	r3, .L234+8
 2079 0028 0E4A     		ldr	r2, .L234+4
 2080 002a 1B68     		ldr	r3, [r3]
 2081 002c 52F82510 		ldr	r1, [r2, r5, lsl #2]
 2082 0030 2046     		mov	r0, r4
 2083 0032 9847     		blx	r3
 2084              	.LVL241:
 2085              	.L219:
2807:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2808:../drivers/fsl_enet.c ****     }
2809:../drivers/fsl_enet.c **** 
2810:../drivers/fsl_enet.c ****     if (event & ENET_TS_INTERRUPT)
 2086              		.loc 1 2810 0
 2087 0034 16F4C03F 		tst	r6, #98304
 2088 0038 05D0     		beq	.L220
2811:../drivers/fsl_enet.c ****     {
2812:../drivers/fsl_enet.c ****         s_enetTsIsr(base, s_ENETHandle[instance]);
 2089              		.loc 1 2812 0
 2090 003a 0A4B     		ldr	r3, .L234+4
 2091 003c 2046     		mov	r0, r4
 2092 003e 53F82510 		ldr	r1, [r3, r5, lsl #2]
 2093 0042 0023     		movs	r3, #0
 2094 0044 9847     		blx	r3
 2095              	.LVL242:
 2096              	.L220:
2813:../drivers/fsl_enet.c ****     }
2814:../drivers/fsl_enet.c ****     if (event & ENET_ERR_INTERRUPT)
 2097              		.loc 1 2814 0
 2098 0046 094B     		ldr	r3, .L234+12
 2099 0048 1E42     		tst	r6, r3
 2100 004a 06D0     		beq	.L221
2815:../drivers/fsl_enet.c ****     {
2816:../drivers/fsl_enet.c ****         s_enetErrIsr(base, s_ENETHandle[instance]);
 2101              		.loc 1 2816 0
 2102 004c 084B     		ldr	r3, .L234+16
 2103 004e 054A     		ldr	r2, .L234+4
 2104 0050 1B68     		ldr	r3, [r3]
 2105 0052 52F82510 		ldr	r1, [r2, r5, lsl #2]
 2106 0056 2046     		mov	r0, r4
 2107 0058 9847     		blx	r3
 2108              	.LVL243:
 2109              	.L221:
 2110              	.LBB135:
 2111              	.LBB136:
 2112              		.loc 3 833 0
 2113              		.syntax unified
 2114              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2115 005a BFF34F8F 		dsb 0xF
 2116              	@ 0 "" 2
 2117              		.thumb
 2118              		.syntax unified
 2119              	.LBE136:
 2120              	.LBE135:
2817:../drivers/fsl_enet.c ****     }
2818:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2819:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2820:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2821:../drivers/fsl_enet.c ****     __DSB();
2822:../drivers/fsl_enet.c **** #endif
2823:../drivers/fsl_enet.c **** }
 2121              		.loc 1 2823 0
 2122 005e 70BD     		pop	{r4, r5, r6, pc}
 2123              	.LVL244:
 2124              	.L235:
 2125              		.align	2
 2126              	.L234:
 2127 0060 00000000 		.word	.LANCHOR1
 2128 0064 00000000 		.word	.LANCHOR0
 2129 0068 00000000 		.word	.LANCHOR2
 2130 006c 00007C60 		.word	1618739200
 2131 0070 00000000 		.word	.LANCHOR3
 2132              		.cfi_endproc
 2133              	.LFE183:
 2135              		.section	.text.ENET_Transmit_IRQHandler,"ax",%progbits
 2136              		.align	1
 2137              		.global	ENET_Transmit_IRQHandler
 2138              		.syntax unified
 2139              		.thumb
 2140              		.thumb_func
 2141              		.fpu fpv4-sp-d16
 2143              	ENET_Transmit_IRQHandler:
 2144              	.LFB184:
2824:../drivers/fsl_enet.c **** 
2825:../drivers/fsl_enet.c **** #if FSL_FEATURE_ENET_QUEUE > 1
2826:../drivers/fsl_enet.c **** void ENET_CommonFrame1IRQHandler(ENET_Type *base)
2827:../drivers/fsl_enet.c **** {
2828:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
2829:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
2830:../drivers/fsl_enet.c **** 
2831:../drivers/fsl_enet.c ****     if (event & (kENET_TxBuffer1Interrupt | kENET_TxFrame1Interrupt))
2832:../drivers/fsl_enet.c ****     {
2833:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance], 1);
2834:../drivers/fsl_enet.c ****     }
2835:../drivers/fsl_enet.c **** 
2836:../drivers/fsl_enet.c ****     if (event & (kENET_RxBuffer1Interrupt | kENET_RxFrame1Interrupt))
2837:../drivers/fsl_enet.c ****     {
2838:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance], 1);
2839:../drivers/fsl_enet.c ****     }
2840:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2841:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2842:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2843:../drivers/fsl_enet.c ****     __DSB();
2844:../drivers/fsl_enet.c **** #endif
2845:../drivers/fsl_enet.c **** }
2846:../drivers/fsl_enet.c **** 
2847:../drivers/fsl_enet.c **** void ENET_CommonFrame2IRQHandler(ENET_Type *base)
2848:../drivers/fsl_enet.c **** {
2849:../drivers/fsl_enet.c ****     uint32_t event = base->EIR;
2850:../drivers/fsl_enet.c ****     uint32_t instance = ENET_GetInstance(base);
2851:../drivers/fsl_enet.c **** 
2852:../drivers/fsl_enet.c ****     if (event & (kENET_TxBuffer2Interrupt | kENET_TxFrame2Interrupt))
2853:../drivers/fsl_enet.c ****     {
2854:../drivers/fsl_enet.c ****         s_enetTxIsr(base, s_ENETHandle[instance], 2);
2855:../drivers/fsl_enet.c ****     }
2856:../drivers/fsl_enet.c **** 
2857:../drivers/fsl_enet.c ****     if (event & (kENET_RxBuffer2Interrupt | kENET_RxFrame2Interrupt))
2858:../drivers/fsl_enet.c ****     {
2859:../drivers/fsl_enet.c ****         s_enetRxIsr(base, s_ENETHandle[instance], 2);
2860:../drivers/fsl_enet.c ****     }
2861:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2862:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2863:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2864:../drivers/fsl_enet.c ****     __DSB();
2865:../drivers/fsl_enet.c **** #endif
2866:../drivers/fsl_enet.c **** }
2867:../drivers/fsl_enet.c **** #endif /* FSL_FEATURE_ENET_QUEUE > 1 */
2868:../drivers/fsl_enet.c **** 
2869:../drivers/fsl_enet.c **** #if defined(ENET)
2870:../drivers/fsl_enet.c **** void ENET_Transmit_IRQHandler(void)
2871:../drivers/fsl_enet.c **** {
 2145              		.loc 1 2871 0
 2146              		.cfi_startproc
 2147              		@ args = 0, pretend = 0, frame = 0
 2148              		@ frame_needed = 0, uses_anonymous_args = 0
 2149 0000 08B5     		push	{r3, lr}
 2150              		.cfi_def_cfa_offset 8
 2151              		.cfi_offset 3, -8
 2152              		.cfi_offset 14, -4
2872:../drivers/fsl_enet.c ****     s_enetTxIsr(ENET, s_ENETHandle[0]);
 2153              		.loc 1 2872 0
 2154 0002 044A     		ldr	r2, .L237
 2155 0004 044B     		ldr	r3, .L237+4
 2156 0006 1168     		ldr	r1, [r2]
 2157 0008 1B68     		ldr	r3, [r3]
 2158 000a 0448     		ldr	r0, .L237+8
 2159 000c 9847     		blx	r3
 2160              	.LVL245:
 2161              	.LBB137:
 2162              	.LBB138:
 2163              		.loc 3 833 0
 2164              		.syntax unified
 2165              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2166 000e BFF34F8F 		dsb 0xF
 2167              	@ 0 "" 2
 2168              		.thumb
 2169              		.syntax unified
 2170              	.LBE138:
 2171              	.LBE137:
2873:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2874:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2875:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2876:../drivers/fsl_enet.c ****     __DSB();
2877:../drivers/fsl_enet.c **** #endif
2878:../drivers/fsl_enet.c **** }
 2172              		.loc 1 2878 0
 2173 0012 08BD     		pop	{r3, pc}
 2174              	.L238:
 2175              		.align	2
 2176              	.L237:
 2177 0014 00000000 		.word	.LANCHOR0
 2178 0018 00000000 		.word	.LANCHOR1
 2179 001c 00000C40 		.word	1074528256
 2180              		.cfi_endproc
 2181              	.LFE184:
 2183              		.section	.text.ENET_Receive_IRQHandler,"ax",%progbits
 2184              		.align	1
 2185              		.global	ENET_Receive_IRQHandler
 2186              		.syntax unified
 2187              		.thumb
 2188              		.thumb_func
 2189              		.fpu fpv4-sp-d16
 2191              	ENET_Receive_IRQHandler:
 2192              	.LFB185:
2879:../drivers/fsl_enet.c **** 
2880:../drivers/fsl_enet.c **** void ENET_Receive_IRQHandler(void)
2881:../drivers/fsl_enet.c **** {
 2193              		.loc 1 2881 0
 2194              		.cfi_startproc
 2195              		@ args = 0, pretend = 0, frame = 0
 2196              		@ frame_needed = 0, uses_anonymous_args = 0
 2197 0000 08B5     		push	{r3, lr}
 2198              		.cfi_def_cfa_offset 8
 2199              		.cfi_offset 3, -8
 2200              		.cfi_offset 14, -4
2882:../drivers/fsl_enet.c ****     s_enetRxIsr(ENET, s_ENETHandle[0]);
 2201              		.loc 1 2882 0
 2202 0002 044A     		ldr	r2, .L240
 2203 0004 044B     		ldr	r3, .L240+4
 2204 0006 1168     		ldr	r1, [r2]
 2205 0008 1B68     		ldr	r3, [r3]
 2206 000a 0448     		ldr	r0, .L240+8
 2207 000c 9847     		blx	r3
 2208              	.LVL246:
 2209              	.LBB139:
 2210              	.LBB140:
 2211              		.loc 3 833 0
 2212              		.syntax unified
 2213              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2214 000e BFF34F8F 		dsb 0xF
 2215              	@ 0 "" 2
 2216              		.thumb
 2217              		.syntax unified
 2218              	.LBE140:
 2219              	.LBE139:
2883:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2884:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2885:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2886:../drivers/fsl_enet.c ****     __DSB();
2887:../drivers/fsl_enet.c **** #endif
2888:../drivers/fsl_enet.c **** }
 2220              		.loc 1 2888 0
 2221 0012 08BD     		pop	{r3, pc}
 2222              	.L241:
 2223              		.align	2
 2224              	.L240:
 2225 0014 00000000 		.word	.LANCHOR0
 2226 0018 00000000 		.word	.LANCHOR2
 2227 001c 00000C40 		.word	1074528256
 2228              		.cfi_endproc
 2229              	.LFE185:
 2231              		.section	.text.ENET_Error_IRQHandler,"ax",%progbits
 2232              		.align	1
 2233              		.global	ENET_Error_IRQHandler
 2234              		.syntax unified
 2235              		.thumb
 2236              		.thumb_func
 2237              		.fpu fpv4-sp-d16
 2239              	ENET_Error_IRQHandler:
 2240              	.LFB186:
2889:../drivers/fsl_enet.c **** 
2890:../drivers/fsl_enet.c **** void ENET_Error_IRQHandler(void)
2891:../drivers/fsl_enet.c **** {
 2241              		.loc 1 2891 0
 2242              		.cfi_startproc
 2243              		@ args = 0, pretend = 0, frame = 0
 2244              		@ frame_needed = 0, uses_anonymous_args = 0
 2245 0000 08B5     		push	{r3, lr}
 2246              		.cfi_def_cfa_offset 8
 2247              		.cfi_offset 3, -8
 2248              		.cfi_offset 14, -4
2892:../drivers/fsl_enet.c ****     s_enetErrIsr(ENET, s_ENETHandle[0]);
 2249              		.loc 1 2892 0
 2250 0002 044A     		ldr	r2, .L243
 2251 0004 044B     		ldr	r3, .L243+4
 2252 0006 1168     		ldr	r1, [r2]
 2253 0008 1B68     		ldr	r3, [r3]
 2254 000a 0448     		ldr	r0, .L243+8
 2255 000c 9847     		blx	r3
 2256              	.LVL247:
 2257              	.LBB141:
 2258              	.LBB142:
 2259              		.loc 3 833 0
 2260              		.syntax unified
 2261              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2262 000e BFF34F8F 		dsb 0xF
 2263              	@ 0 "" 2
 2264              		.thumb
 2265              		.syntax unified
 2266              	.LBE142:
 2267              	.LBE141:
2893:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2894:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2895:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2896:../drivers/fsl_enet.c ****     __DSB();
2897:../drivers/fsl_enet.c **** #endif
2898:../drivers/fsl_enet.c **** }
 2268              		.loc 1 2898 0
 2269 0012 08BD     		pop	{r3, pc}
 2270              	.L244:
 2271              		.align	2
 2272              	.L243:
 2273 0014 00000000 		.word	.LANCHOR0
 2274 0018 00000000 		.word	.LANCHOR3
 2275 001c 00000C40 		.word	1074528256
 2276              		.cfi_endproc
 2277              	.LFE186:
 2279              		.section	.text.ENET_1588_Timer_IRQHandler,"ax",%progbits
 2280              		.align	1
 2281              		.global	ENET_1588_Timer_IRQHandler
 2282              		.syntax unified
 2283              		.thumb
 2284              		.thumb_func
 2285              		.fpu fpv4-sp-d16
 2287              	ENET_1588_Timer_IRQHandler:
 2288              	.LFB187:
2899:../drivers/fsl_enet.c **** 
2900:../drivers/fsl_enet.c **** void ENET_1588_Timer_IRQHandler(void)
2901:../drivers/fsl_enet.c **** {
 2289              		.loc 1 2901 0
 2290              		.cfi_startproc
 2291              		@ args = 0, pretend = 0, frame = 0
 2292              		@ frame_needed = 0, uses_anonymous_args = 0
 2293 0000 08B5     		push	{r3, lr}
 2294              		.cfi_def_cfa_offset 8
 2295              		.cfi_offset 3, -8
 2296              		.cfi_offset 14, -4
2902:../drivers/fsl_enet.c ****     s_enetTsIsr(ENET, s_ENETHandle[0]);
 2297              		.loc 1 2902 0
 2298 0002 044B     		ldr	r3, .L246
 2299 0004 0448     		ldr	r0, .L246+4
 2300 0006 1968     		ldr	r1, [r3]
 2301 0008 0023     		movs	r3, #0
 2302 000a 9847     		blx	r3
 2303              	.LVL248:
 2304              	.LBB143:
 2305              	.LBB144:
 2306              		.loc 3 833 0
 2307              		.syntax unified
 2308              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2309 000c BFF34F8F 		dsb 0xF
 2310              	@ 0 "" 2
 2311              		.thumb
 2312              		.syntax unified
 2313              	.LBE144:
 2314              	.LBE143:
2903:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2904:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2905:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2906:../drivers/fsl_enet.c ****     __DSB();
2907:../drivers/fsl_enet.c **** #endif
2908:../drivers/fsl_enet.c **** }
 2315              		.loc 1 2908 0
 2316 0010 08BD     		pop	{r3, pc}
 2317              	.L247:
 2318 0012 00BF     		.align	2
 2319              	.L246:
 2320 0014 00000000 		.word	.LANCHOR0
 2321 0018 00000C40 		.word	1074528256
 2322              		.cfi_endproc
 2323              	.LFE187:
 2325              		.section	.text.ENET_DriverIRQHandler,"ax",%progbits
 2326              		.align	1
 2327              		.global	ENET_DriverIRQHandler
 2328              		.syntax unified
 2329              		.thumb
 2330              		.thumb_func
 2331              		.fpu fpv4-sp-d16
 2333              	ENET_DriverIRQHandler:
 2334              	.LFB188:
2909:../drivers/fsl_enet.c **** 
2910:../drivers/fsl_enet.c **** void ENET_DriverIRQHandler(void)
2911:../drivers/fsl_enet.c **** {
 2335              		.loc 1 2911 0
 2336              		.cfi_startproc
 2337              		@ args = 0, pretend = 0, frame = 0
 2338              		@ frame_needed = 0, uses_anonymous_args = 0
 2339 0000 08B5     		push	{r3, lr}
 2340              		.cfi_def_cfa_offset 8
 2341              		.cfi_offset 3, -8
 2342              		.cfi_offset 14, -4
2912:../drivers/fsl_enet.c ****     ENET_CommonFrame0IRQHandler(ENET);
 2343              		.loc 1 2912 0
 2344 0002 0448     		ldr	r0, .L249
 2345 0004 FFF7FEFF 		bl	ENET_CommonFrame0IRQHandler
 2346              	.LVL249:
 2347              	.LBB145:
 2348              	.LBB146:
 2349              		.loc 3 833 0
 2350              		.syntax unified
 2351              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2352 0008 BFF34F8F 		dsb 0xF
 2353              	@ 0 "" 2
 2354              		.thumb
 2355              		.syntax unified
 2356              	.LBE146:
 2357              	.LBE145:
 2358              	.LBB147:
 2359              	.LBB148:
 2360              		.syntax unified
 2361              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 2362 000c BFF34F8F 		dsb 0xF
 2363              	@ 0 "" 2
 2364              		.thumb
 2365              		.syntax unified
 2366              	.LBE148:
 2367              	.LBE147:
2913:../drivers/fsl_enet.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2914:../drivers/fsl_enet.c ****   exception return operation might vector to incorrect interrupt */
2915:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2916:../drivers/fsl_enet.c ****     __DSB();
2917:../drivers/fsl_enet.c **** #endif    
2918:../drivers/fsl_enet.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
2919:../drivers/fsl_enet.c ****       exception return operation might vector to incorrect interrupt */
2920:../drivers/fsl_enet.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
2921:../drivers/fsl_enet.c ****     __DSB();
2922:../drivers/fsl_enet.c **** #endif
2923:../drivers/fsl_enet.c **** }
 2368              		.loc 1 2923 0
 2369 0010 08BD     		pop	{r3, pc}
 2370              	.L250:
 2371 0012 00BF     		.align	2
 2372              	.L249:
 2373 0014 00000C40 		.word	1074528256
 2374              		.cfi_endproc
 2375              	.LFE188:
 2377              		.global	s_enetClock
 2378              		.section	.bss.s_ENETHandle,"aw",%nobits
 2379              		.align	2
 2380              		.set	.LANCHOR0,. + 0
 2383              	s_ENETHandle:
 2384 0000 00000000 		.space	4
 2385              		.section	.bss.s_enetErrIsr,"aw",%nobits
 2386              		.align	2
 2387              		.set	.LANCHOR3,. + 0
 2390              	s_enetErrIsr:
 2391 0000 00000000 		.space	4
 2392              		.section	.bss.s_enetRxIsr,"aw",%nobits
 2393              		.align	2
 2394              		.set	.LANCHOR2,. + 0
 2397              	s_enetRxIsr:
 2398 0000 00000000 		.space	4
 2399              		.section	.bss.s_enetTxIsr,"aw",%nobits
 2400              		.align	2
 2401              		.set	.LANCHOR1,. + 0
 2404              	s_enetTxIsr:
 2405 0000 00000000 		.space	4
 2406              		.section	.rodata.s_enetClock,"a",%progbits
 2407              		.align	2
 2410              	s_enetClock:
 2411 0000 00002C10 		.word	271319040
 2412              		.text
 2413              	.Letext0:
 2414              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 2415              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2416              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 2417              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 2418              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 2419              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 2420              		.file 12 "../CMSIS/MK64F12.h"
 2421              		.file 13 "../CMSIS/system_MK64F12.h"
 2422              		.file 14 "../drivers/fsl_common.h"
 2423              		.file 15 "<built-in>"
