   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"fsl_notifier.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.NOTIFIER_CreateHandle,"ax",%progbits
  18              		.align	1
  19              		.global	NOTIFIER_CreateHandle
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	NOTIFIER_CreateHandle:
  26              	.LFB147:
  27              		.file 1 "../utilities/fsl_notifier.c"
   1:../utilities/fsl_notifier.c **** /*
   2:../utilities/fsl_notifier.c ****  * The Clear BSD License
   3:../utilities/fsl_notifier.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../utilities/fsl_notifier.c ****  * Copyright 2016-2017 NXP
   5:../utilities/fsl_notifier.c ****  * All rights reserved.
   6:../utilities/fsl_notifier.c ****  *
   7:../utilities/fsl_notifier.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../utilities/fsl_notifier.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../utilities/fsl_notifier.c ****  * that the following conditions are met:
  10:../utilities/fsl_notifier.c ****  *
  11:../utilities/fsl_notifier.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../utilities/fsl_notifier.c ****  *   of conditions and the following disclaimer.
  13:../utilities/fsl_notifier.c ****  *
  14:../utilities/fsl_notifier.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../utilities/fsl_notifier.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../utilities/fsl_notifier.c ****  *   other materials provided with the distribution.
  17:../utilities/fsl_notifier.c ****  *
  18:../utilities/fsl_notifier.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../utilities/fsl_notifier.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../utilities/fsl_notifier.c ****  *   software without specific prior written permission.
  21:../utilities/fsl_notifier.c ****  *
  22:../utilities/fsl_notifier.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../utilities/fsl_notifier.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../utilities/fsl_notifier.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../utilities/fsl_notifier.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../utilities/fsl_notifier.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../utilities/fsl_notifier.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../utilities/fsl_notifier.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../utilities/fsl_notifier.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../utilities/fsl_notifier.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../utilities/fsl_notifier.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../utilities/fsl_notifier.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../utilities/fsl_notifier.c ****  */
  34:../utilities/fsl_notifier.c **** 
  35:../utilities/fsl_notifier.c **** #include "fsl_notifier.h"
  36:../utilities/fsl_notifier.c **** 
  37:../utilities/fsl_notifier.c **** /*******************************************************************************
  38:../utilities/fsl_notifier.c ****  * Definitions
  39:../utilities/fsl_notifier.c ****  ******************************************************************************/
  40:../utilities/fsl_notifier.c **** 
  41:../utilities/fsl_notifier.c **** /*******************************************************************************
  42:../utilities/fsl_notifier.c ****  * Prototypes
  43:../utilities/fsl_notifier.c ****  ******************************************************************************/
  44:../utilities/fsl_notifier.c **** 
  45:../utilities/fsl_notifier.c **** /*******************************************************************************
  46:../utilities/fsl_notifier.c ****  * Variables
  47:../utilities/fsl_notifier.c ****  ******************************************************************************/
  48:../utilities/fsl_notifier.c **** 
  49:../utilities/fsl_notifier.c **** /*******************************************************************************
  50:../utilities/fsl_notifier.c ****  * Code
  51:../utilities/fsl_notifier.c ****  ******************************************************************************/
  52:../utilities/fsl_notifier.c **** 
  53:../utilities/fsl_notifier.c **** status_t NOTIFIER_CreateHandle(notifier_handle_t *notifierHandle,
  54:../utilities/fsl_notifier.c ****                                notifier_user_config_t **configs,
  55:../utilities/fsl_notifier.c ****                                uint8_t configsNumber,
  56:../utilities/fsl_notifier.c ****                                notifier_callback_config_t *callbacks,
  57:../utilities/fsl_notifier.c ****                                uint8_t callbacksNumber,
  58:../utilities/fsl_notifier.c ****                                notifier_user_function_t userFunction,
  59:../utilities/fsl_notifier.c ****                                void *userData)
  60:../utilities/fsl_notifier.c **** {
  28              		.loc 1 60 0
  29              		.cfi_startproc
  30              		@ args = 12, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
  34              		.cfi_def_cfa_offset 32
  35              		.cfi_offset 3, -32
  36              		.cfi_offset 4, -28
  37              		.cfi_offset 5, -24
  38              		.cfi_offset 6, -20
  39              		.cfi_offset 7, -16
  40              		.cfi_offset 8, -12
  41              		.cfi_offset 9, -8
  42              		.cfi_offset 14, -4
  43              		.loc 1 60 0
  44 0004 099D     		ldr	r5, [sp, #36]
  45 0006 9DF82060 		ldrb	r6, [sp, #32]	@ zero_extendqisi2
  46 000a 0446     		mov	r4, r0
  47 000c 9046     		mov	r8, r2
  48 000e 1F46     		mov	r7, r3
  61:../utilities/fsl_notifier.c ****     /* Check input parameter - at least one configuration is required and userFunction must exist *
  62:../utilities/fsl_notifier.c ****     if ((configs == NULL) || (configsNumber == 0U) || (userFunction == NULL))
  49              		.loc 1 62 0
  50 0010 8946     		mov	r9, r1
  51 0012 99B1     		cbz	r1, .L6
  52              		.loc 1 62 0 is_stmt 0 discriminator 1
  53 0014 92B1     		cbz	r2, .L6
  54              		.loc 1 62 0 discriminator 2
  55 0016 8DB1     		cbz	r5, .L6
  63:../utilities/fsl_notifier.c ****     {
  64:../utilities/fsl_notifier.c ****         return kStatus_Fail;
  65:../utilities/fsl_notifier.c ****     }
  66:../utilities/fsl_notifier.c ****     /* Initialize handle structure */
  67:../utilities/fsl_notifier.c ****     memset(notifierHandle, 0, sizeof(notifier_handle_t));
  56              		.loc 1 67 0 is_stmt 1
  57 0018 1822     		movs	r2, #24
  58              	.LVL1:
  59 001a 0021     		movs	r1, #0
  60              	.LVL2:
  61 001c FFF7FEFF 		bl	memset
  62              	.LVL3:
  68:../utilities/fsl_notifier.c ****     /* Store references to user-defined configurations */
  69:../utilities/fsl_notifier.c ****     notifierHandle->configsTable = configs;
  63              		.loc 1 69 0
  64 0020 C4F80090 		str	r9, [r4]
  70:../utilities/fsl_notifier.c ****     notifierHandle->configsNumber = configsNumber;
  65              		.loc 1 70 0
  66 0024 84F80480 		strb	r8, [r4, #4]
  71:../utilities/fsl_notifier.c ****     /* Store references to user-defined callback configurations */
  72:../utilities/fsl_notifier.c ****     if (callbacks != NULL)
  67              		.loc 1 72 0
  68 0028 17B1     		cbz	r7, .L3
  73:../utilities/fsl_notifier.c ****     {
  74:../utilities/fsl_notifier.c ****         notifierHandle->callbacksTable = callbacks;
  69              		.loc 1 74 0
  70 002a A760     		str	r7, [r4, #8]
  75:../utilities/fsl_notifier.c ****         notifierHandle->callbacksNumber = callbacksNumber;
  71              		.loc 1 75 0
  72 002c 2673     		strb	r6, [r4, #12]
  76:../utilities/fsl_notifier.c ****         /* If all callbacks return success, then the errorCallbackIndex is callbacksNumber */
  77:../utilities/fsl_notifier.c ****         notifierHandle->errorCallbackIndex = callbacksNumber;
  73              		.loc 1 77 0
  74 002e 6673     		strb	r6, [r4, #13]
  75              	.L3:
  78:../utilities/fsl_notifier.c ****     }
  79:../utilities/fsl_notifier.c ****     notifierHandle->userFunction = userFunction;
  80:../utilities/fsl_notifier.c ****     notifierHandle->userData = userData;
  76              		.loc 1 80 0
  77 0030 0A9B     		ldr	r3, [sp, #40]
  79:../utilities/fsl_notifier.c ****     notifierHandle->userData = userData;
  78              		.loc 1 79 0
  79 0032 2561     		str	r5, [r4, #16]
  80              		.loc 1 80 0
  81 0034 6361     		str	r3, [r4, #20]
  81:../utilities/fsl_notifier.c **** 
  82:../utilities/fsl_notifier.c ****     return kStatus_Success;
  82              		.loc 1 82 0
  83 0036 0020     		movs	r0, #0
  84 0038 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  85              	.LVL4:
  86              	.L6:
  64:../utilities/fsl_notifier.c ****     }
  87              		.loc 1 64 0
  88 003c 0120     		movs	r0, #1
  89              	.LVL5:
  83:../utilities/fsl_notifier.c **** }
  90              		.loc 1 83 0
  91 003e BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  92              		.cfi_endproc
  93              	.LFE147:
  95              		.section	.text.NOTIFIER_SwitchConfig,"ax",%progbits
  96              		.align	1
  97              		.global	NOTIFIER_SwitchConfig
  98              		.syntax unified
  99              		.thumb
 100              		.thumb_func
 101              		.fpu fpv4-sp-d16
 103              	NOTIFIER_SwitchConfig:
 104              	.LFB148:
  84:../utilities/fsl_notifier.c **** 
  85:../utilities/fsl_notifier.c **** status_t NOTIFIER_SwitchConfig(notifier_handle_t *notifierHandle, uint8_t configIndex, notifier_pol
  86:../utilities/fsl_notifier.c **** {
 105              		.loc 1 86 0
 106              		.cfi_startproc
 107              		@ args = 0, pretend = 0, frame = 8
 108              		@ frame_needed = 0, uses_anonymous_args = 0
 109              	.LVL6:
 110 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 111              		.cfi_def_cfa_offset 48
 112              		.cfi_offset 4, -36
 113              		.cfi_offset 5, -32
 114              		.cfi_offset 6, -28
 115              		.cfi_offset 7, -24
 116              		.cfi_offset 8, -20
 117              		.cfi_offset 9, -16
 118              		.cfi_offset 10, -12
 119              		.cfi_offset 11, -8
 120              		.cfi_offset 14, -4
  87:../utilities/fsl_notifier.c ****     uint8_t currentStaticCallback = 0U;    /* Index to array of statically registered call-backs */
  88:../utilities/fsl_notifier.c ****     status_t returnCode = kStatus_Success; /* Function return */
  89:../utilities/fsl_notifier.c **** 
  90:../utilities/fsl_notifier.c ****     notifier_notification_block_t notifyBlock;  /*  Callback notification block */
  91:../utilities/fsl_notifier.c ****     notifier_callback_config_t *callbackConfig; /* Pointer to callback configuration */
  92:../utilities/fsl_notifier.c **** 
  93:../utilities/fsl_notifier.c ****     /* Set errorcallbackindex as callbacksNumber, which means no callback error now */
  94:../utilities/fsl_notifier.c ****     notifierHandle->errorCallbackIndex = notifierHandle->callbacksNumber;
 121              		.loc 1 94 0
 122 0004 037B     		ldrb	r3, [r0, #12]	@ zero_extendqisi2
 123 0006 4373     		strb	r3, [r0, #13]
  95:../utilities/fsl_notifier.c **** 
  96:../utilities/fsl_notifier.c ****     /* Requested configuration availability check */
  97:../utilities/fsl_notifier.c ****     if (configIndex >= notifierHandle->configsNumber)
 124              		.loc 1 97 0
 125 0008 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 126 000a 8B42     		cmp	r3, r1
  86:../utilities/fsl_notifier.c ****     uint8_t currentStaticCallback = 0U;    /* Index to array of statically registered call-backs */
 127              		.loc 1 86 0
 128 000c 0446     		mov	r4, r0
 129 000e 8946     		mov	r9, r1
 130 0010 1746     		mov	r7, r2
 131              		.loc 1 97 0
 132 0012 6ED9     		bls	.L23
  98:../utilities/fsl_notifier.c ****     {
  99:../utilities/fsl_notifier.c ****         return kStatus_OutOfRange;
 100:../utilities/fsl_notifier.c ****     }
 101:../utilities/fsl_notifier.c **** 
 102:../utilities/fsl_notifier.c ****     /* Initialization of local variables from the Notifier handle structure */
 103:../utilities/fsl_notifier.c **** 
 104:../utilities/fsl_notifier.c ****     notifyBlock.policy = policy;
 105:../utilities/fsl_notifier.c ****     notifyBlock.targetConfig = notifierHandle->configsTable[configIndex];
 133              		.loc 1 105 0
 134 0014 0FFA81FA 		sxth	r10, r1
 135 0018 0368     		ldr	r3, [r0]
 104:../utilities/fsl_notifier.c ****     notifyBlock.targetConfig = notifierHandle->configsTable[configIndex];
 136              		.loc 1 104 0
 137 001a 8DF80420 		strb	r2, [sp, #4]
 138              		.loc 1 105 0
 139 001e 53F82A30 		ldr	r3, [r3, r10, lsl #2]
 140 0022 0093     		str	r3, [sp]
 106:../utilities/fsl_notifier.c ****     notifyBlock.notifyType = kNOTIFIER_NotifyBefore;
 107:../utilities/fsl_notifier.c **** 
 108:../utilities/fsl_notifier.c ****     /* From all statically registered call-backs... */
 109:../utilities/fsl_notifier.c ****     for (currentStaticCallback = 0U; currentStaticCallback < notifierHandle->callbacksNumber; curre
 141              		.loc 1 109 0
 142 0024 4FF00008 		mov	r8, #0
 106:../utilities/fsl_notifier.c ****     notifyBlock.notifyType = kNOTIFIER_NotifyBefore;
 143              		.loc 1 106 0
 144 0028 0123     		movs	r3, #1
 145 002a 8DF80530 		strb	r3, [sp, #5]
  88:../utilities/fsl_notifier.c **** 
 146              		.loc 1 88 0
 147 002e 4646     		mov	r6, r8
 110:../utilities/fsl_notifier.c ****     {
 111:../utilities/fsl_notifier.c ****         callbackConfig = &(notifierHandle->callbacksTable[currentStaticCallback]);
 148              		.loc 1 111 0
 149 0030 4FF00C0B 		mov	fp, #12
 150              	.LVL7:
 151              	.L12:
 109:../utilities/fsl_notifier.c ****     {
 152              		.loc 1 109 0 discriminator 1
 153 0034 237B     		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 154 0036 5FFA88F5 		uxtb	r5, r8
 155              	.LVL8:
 156 003a AB42     		cmp	r3, r5
 157 003c 1CD8     		bhi	.L15
 158              	.LVL9:
 112:../utilities/fsl_notifier.c ****         /* ...notify only those which asked to be called before the configuration switch */
 113:../utilities/fsl_notifier.c ****         if (((uint32_t)callbackConfig->callbackType) & kNOTIFIER_CallbackBefore)
 114:../utilities/fsl_notifier.c ****         {
 115:../utilities/fsl_notifier.c ****             /* In case that call-back returned error code mark it, store the call-back handle and e
 116:../utilities/fsl_notifier.c ****             * the configuration switch */
 117:../utilities/fsl_notifier.c ****             if (callbackConfig->callback(&notifyBlock, callbackConfig->callbackData) != kStatus_Suc
 118:../utilities/fsl_notifier.c ****             {
 119:../utilities/fsl_notifier.c ****                 returnCode = kStatus_NOTIFIER_ErrorNotificationBefore;
 120:../utilities/fsl_notifier.c ****                 notifierHandle->errorCallbackIndex = currentStaticCallback;
 121:../utilities/fsl_notifier.c ****                 /* If not forcing configuration switch, call all already notified call-backs to rev
 122:../utilities/fsl_notifier.c ****                 * as the switch is canceled */
 123:../utilities/fsl_notifier.c ****                 if (policy != kNOTIFIER_PolicyForcible)
 124:../utilities/fsl_notifier.c ****                 {
 125:../utilities/fsl_notifier.c ****                     break;
 126:../utilities/fsl_notifier.c ****                 }
 127:../utilities/fsl_notifier.c ****             }
 128:../utilities/fsl_notifier.c ****         }
 129:../utilities/fsl_notifier.c ****     }
 130:../utilities/fsl_notifier.c **** 
 131:../utilities/fsl_notifier.c ****     /* Set configuration */
 132:../utilities/fsl_notifier.c **** 
 133:../utilities/fsl_notifier.c ****     /* In case that any call-back returned error code and  policy doesn't force the configuration s
 134:../utilities/fsl_notifier.c ****      * switch call-backs */
 135:../utilities/fsl_notifier.c ****     if ((policy == kNOTIFIER_PolicyForcible) || (returnCode == kStatus_Success))
 159              		.loc 1 135 0
 160 003e 012F     		cmp	r7, #1
 161 0040 01D0     		beq	.L16
 162              		.loc 1 135 0 is_stmt 0 discriminator 1
 163 0042 002E     		cmp	r6, #0
 164 0044 40D1     		bne	.L14
 165              	.L16:
 136:../utilities/fsl_notifier.c ****     {
 137:../utilities/fsl_notifier.c ****         returnCode = notifierHandle->userFunction(notifierHandle->configsTable[configIndex], notifi
 166              		.loc 1 137 0 is_stmt 1
 167 0046 2268     		ldr	r2, [r4]
 168 0048 2369     		ldr	r3, [r4, #16]
 169 004a 6169     		ldr	r1, [r4, #20]
 170 004c 52F82A00 		ldr	r0, [r2, r10, lsl #2]
 171 0050 9847     		blx	r3
 172              	.LVL10:
 138:../utilities/fsl_notifier.c ****         if (returnCode != kStatus_Success)
 173              		.loc 1 138 0
 174 0052 0646     		mov	r6, r0
 175 0054 60B9     		cbnz	r0, .L10
 139:../utilities/fsl_notifier.c ****         {
 140:../utilities/fsl_notifier.c ****             return returnCode;
 141:../utilities/fsl_notifier.c ****         }
 142:../utilities/fsl_notifier.c ****         /* Update current configuration index */
 143:../utilities/fsl_notifier.c ****         notifierHandle->currentConfigIndex = configIndex;
 144:../utilities/fsl_notifier.c ****         notifyBlock.notifyType = kNOTIFIER_NotifyAfter;
 176              		.loc 1 144 0
 177 0056 0223     		movs	r3, #2
 143:../utilities/fsl_notifier.c ****         notifyBlock.notifyType = kNOTIFIER_NotifyAfter;
 178              		.loc 1 143 0
 179 0058 84F80E90 		strb	r9, [r4, #14]
 180              		.loc 1 144 0
 181 005c 8DF80530 		strb	r3, [sp, #5]
 182              	.LVL11:
 145:../utilities/fsl_notifier.c ****         /* From all statically registered call-backs... */
 146:../utilities/fsl_notifier.c ****         for (currentStaticCallback = 0U; currentStaticCallback < notifierHandle->callbacksNumber;
 183              		.loc 1 146 0
 184 0060 8046     		mov	r8, r0
 147:../utilities/fsl_notifier.c ****              currentStaticCallback++)
 148:../utilities/fsl_notifier.c ****         {
 149:../utilities/fsl_notifier.c ****             callbackConfig = &(notifierHandle->callbacksTable[currentStaticCallback]);
 185              		.loc 1 149 0
 186 0062 4FF00C09 		mov	r9, #12
 187              	.LVL12:
 188              	.L17:
 146:../utilities/fsl_notifier.c ****              currentStaticCallback++)
 189              		.loc 1 146 0 discriminator 1
 190 0066 237B     		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 191 0068 5FFA88F5 		uxtb	r5, r8
 192              	.LVL13:
 193 006c AB42     		cmp	r3, r5
 194 006e 17D8     		bhi	.L19
 195              	.LVL14:
 196              	.L10:
 150:../utilities/fsl_notifier.c ****             /* ...notify only those which asked to be called after the configruation switch */
 151:../utilities/fsl_notifier.c ****             if (((uint32_t)callbackConfig->callbackType) & kNOTIFIER_CallbackAfter)
 152:../utilities/fsl_notifier.c ****             {
 153:../utilities/fsl_notifier.c ****                 /* In case that call-back returned error code mark it and store the call-back handl
 154:../utilities/fsl_notifier.c ****                 if (callbackConfig->callback(&notifyBlock, callbackConfig->callbackData) != kStatus
 155:../utilities/fsl_notifier.c ****                 {
 156:../utilities/fsl_notifier.c ****                     returnCode = kStatus_NOTIFIER_ErrorNotificationAfter;
 157:../utilities/fsl_notifier.c ****                     notifierHandle->errorCallbackIndex = currentStaticCallback;
 158:../utilities/fsl_notifier.c ****                     if (policy != kNOTIFIER_PolicyForcible)
 159:../utilities/fsl_notifier.c ****                     {
 160:../utilities/fsl_notifier.c ****                         break;
 161:../utilities/fsl_notifier.c ****                     }
 162:../utilities/fsl_notifier.c ****                 }
 163:../utilities/fsl_notifier.c ****             }
 164:../utilities/fsl_notifier.c ****         }
 165:../utilities/fsl_notifier.c ****     }
 166:../utilities/fsl_notifier.c ****     else
 167:../utilities/fsl_notifier.c ****     {
 168:../utilities/fsl_notifier.c ****         /* End of unsuccessful switch */
 169:../utilities/fsl_notifier.c ****         notifyBlock.notifyType = kNOTIFIER_NotifyRecover;
 170:../utilities/fsl_notifier.c ****         while (currentStaticCallback--)
 171:../utilities/fsl_notifier.c ****         {
 172:../utilities/fsl_notifier.c ****             callbackConfig = &(notifierHandle->callbacksTable[currentStaticCallback]);
 173:../utilities/fsl_notifier.c ****             if (((uint32_t)callbackConfig->callbackType) & kNOTIFIER_CallbackBefore)
 174:../utilities/fsl_notifier.c ****             {
 175:../utilities/fsl_notifier.c ****                 callbackConfig->callback(&notifyBlock, callbackConfig->callbackData);
 176:../utilities/fsl_notifier.c ****             }
 177:../utilities/fsl_notifier.c ****         }
 178:../utilities/fsl_notifier.c ****     }
 179:../utilities/fsl_notifier.c **** 
 180:../utilities/fsl_notifier.c ****     return returnCode;
 181:../utilities/fsl_notifier.c **** }
 197              		.loc 1 181 0
 198 0070 3046     		mov	r0, r6
 199 0072 03B0     		add	sp, sp, #12
 200              		.cfi_remember_state
 201              		.cfi_def_cfa_offset 36
 202              		@ sp needed
 203 0074 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 204              	.LVL15:
 205              	.L15:
 206              		.cfi_restore_state
 111:../utilities/fsl_notifier.c ****         /* ...notify only those which asked to be called before the configuration switch */
 207              		.loc 1 111 0
 208 0078 A168     		ldr	r1, [r4, #8]
 209 007a 0BFB05F2 		mul	r2, fp, r5
 210 007e 8B18     		adds	r3, r1, r2
 211              	.LVL16:
 113:../utilities/fsl_notifier.c ****         {
 212              		.loc 1 113 0
 213 0080 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 214 0082 C007     		lsls	r0, r0, #31
 215 0084 09D5     		bpl	.L13
 117:../utilities/fsl_notifier.c ****             {
 216              		.loc 1 117 0
 217 0086 8A58     		ldr	r2, [r1, r2]
 218 0088 9968     		ldr	r1, [r3, #8]
 219 008a 6846     		mov	r0, sp
 220 008c 9047     		blx	r2
 221              	.LVL17:
 222 008e 20B1     		cbz	r0, .L13
 223              	.LVL18:
 123:../utilities/fsl_notifier.c ****                 {
 224              		.loc 1 123 0
 225 0090 012F     		cmp	r7, #1
 120:../utilities/fsl_notifier.c ****                 /* If not forcing configuration switch, call all already notified call-backs to rev
 226              		.loc 1 120 0
 227 0092 6573     		strb	r5, [r4, #13]
 119:../utilities/fsl_notifier.c ****                 notifierHandle->errorCallbackIndex = currentStaticCallback;
 228              		.loc 1 119 0
 229 0094 42F24866 		movw	r6, #9800
 123:../utilities/fsl_notifier.c ****                 {
 230              		.loc 1 123 0
 231 0098 16D1     		bne	.L14
 232              	.LVL19:
 233              	.L13:
 234 009a 08F10108 		add	r8, r8, #1
 235              	.LVL20:
 236 009e C9E7     		b	.L12
 237              	.LVL21:
 238              	.L19:
 149:../utilities/fsl_notifier.c ****             /* ...notify only those which asked to be called after the configruation switch */
 239              		.loc 1 149 0
 240 00a0 A168     		ldr	r1, [r4, #8]
 241 00a2 09FB05F2 		mul	r2, r9, r5
 242 00a6 8B18     		adds	r3, r1, r2
 243              	.LVL22:
 151:../utilities/fsl_notifier.c ****             {
 244              		.loc 1 151 0
 245 00a8 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 246 00aa 8007     		lsls	r0, r0, #30
 247 00ac 09D5     		bpl	.L18
 154:../utilities/fsl_notifier.c ****                 {
 248              		.loc 1 154 0
 249 00ae 8A58     		ldr	r2, [r1, r2]
 250 00b0 9968     		ldr	r1, [r3, #8]
 251 00b2 6846     		mov	r0, sp
 252 00b4 9047     		blx	r2
 253              	.LVL23:
 254 00b6 20B1     		cbz	r0, .L18
 255              	.LVL24:
 158:../utilities/fsl_notifier.c ****                     {
 256              		.loc 1 158 0
 257 00b8 012F     		cmp	r7, #1
 157:../utilities/fsl_notifier.c ****                     if (policy != kNOTIFIER_PolicyForcible)
 258              		.loc 1 157 0
 259 00ba 6573     		strb	r5, [r4, #13]
 156:../utilities/fsl_notifier.c ****                     notifierHandle->errorCallbackIndex = currentStaticCallback;
 260              		.loc 1 156 0
 261 00bc 42F24966 		movw	r6, #9801
 158:../utilities/fsl_notifier.c ****                     {
 262              		.loc 1 158 0
 263 00c0 D6D1     		bne	.L10
 264              	.LVL25:
 265              	.L18:
 266 00c2 08F10108 		add	r8, r8, #1
 267              	.LVL26:
 268 00c6 CEE7     		b	.L17
 269              	.LVL27:
 270              	.L14:
 169:../utilities/fsl_notifier.c ****         while (currentStaticCallback--)
 271              		.loc 1 169 0
 272 00c8 0023     		movs	r3, #0
 273 00ca 8DF80530 		strb	r3, [sp, #5]
 274              	.L21:
 275 00ce 013D     		subs	r5, r5, #1
 276              	.LVL28:
 277 00d0 EDB2     		uxtb	r5, r5
 278              	.LVL29:
 170:../utilities/fsl_notifier.c ****         {
 279              		.loc 1 170 0
 280 00d2 FF2D     		cmp	r5, #255
 281 00d4 CCD0     		beq	.L10
 172:../utilities/fsl_notifier.c ****             if (((uint32_t)callbackConfig->callbackType) & kNOTIFIER_CallbackBefore)
 282              		.loc 1 172 0
 283 00d6 A268     		ldr	r2, [r4, #8]
 284 00d8 05EB4501 		add	r1, r5, r5, lsl #1
 285 00dc 02EB8103 		add	r3, r2, r1, lsl #2
 286              	.LVL30:
 173:../utilities/fsl_notifier.c ****             {
 287              		.loc 1 173 0
 288 00e0 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 289 00e2 C007     		lsls	r0, r0, #31
 290 00e4 F3D5     		bpl	.L21
 175:../utilities/fsl_notifier.c ****             }
 291              		.loc 1 175 0
 292 00e6 52F82120 		ldr	r2, [r2, r1, lsl #2]
 293 00ea 9968     		ldr	r1, [r3, #8]
 294 00ec 6846     		mov	r0, sp
 295 00ee 9047     		blx	r2
 296              	.LVL31:
 297 00f0 EDE7     		b	.L21
 298              	.LVL32:
 299              	.L23:
  99:../utilities/fsl_notifier.c ****     }
 300              		.loc 1 99 0
 301 00f2 0326     		movs	r6, #3
 302 00f4 BCE7     		b	.L10
 303              		.cfi_endproc
 304              	.LFE148:
 306              		.section	.text.NOTIFIER_GetErrorCallbackIndex,"ax",%progbits
 307              		.align	1
 308              		.global	NOTIFIER_GetErrorCallbackIndex
 309              		.syntax unified
 310              		.thumb
 311              		.thumb_func
 312              		.fpu fpv4-sp-d16
 314              	NOTIFIER_GetErrorCallbackIndex:
 315              	.LFB149:
 182:../utilities/fsl_notifier.c **** 
 183:../utilities/fsl_notifier.c **** uint8_t NOTIFIER_GetErrorCallbackIndex(notifier_handle_t *notifierHandle)
 184:../utilities/fsl_notifier.c **** {
 316              		.loc 1 184 0
 317              		.cfi_startproc
 318              		@ args = 0, pretend = 0, frame = 0
 319              		@ frame_needed = 0, uses_anonymous_args = 0
 320              		@ link register save eliminated.
 321              	.LVL33:
 185:../utilities/fsl_notifier.c ****     return notifierHandle->errorCallbackIndex;
 186:../utilities/fsl_notifier.c **** }
 322              		.loc 1 186 0
 323 0000 407B     		ldrb	r0, [r0, #13]	@ zero_extendqisi2
 324              	.LVL34:
 325 0002 7047     		bx	lr
 326              		.cfi_endproc
 327              	.LFE149:
 329              		.text
 330              	.Letext0:
 331              		.file 2 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_type
 332              		.file 3 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 333              		.file 4 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 334              		.file 5 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 335              		.file 6 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.
 336              		.file 7 "/usr/local/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 337              		.file 8 "../CMSIS/core_cm4.h"
 338              		.file 9 "../CMSIS/system_MK64F12.h"
 339              		.file 10 "../drivers/fsl_common.h"
 340              		.file 11 "../drivers/fsl_clock.h"
 341              		.file 12 "../utilities/fsl_notifier.h"
