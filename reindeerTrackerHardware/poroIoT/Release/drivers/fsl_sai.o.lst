   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_sai.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_uidiv
  16              		.section	.text.SAI_WriteNonBlocking,"ax",%progbits
  17              		.align	1
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	SAI_WriteNonBlocking:
  24              	.LFB68:
  25              		.file 1 "../drivers/fsl_sai.c"
   1:../drivers/fsl_sai.c **** /*
   2:../drivers/fsl_sai.c ****  * The Clear BSD License
   3:../drivers/fsl_sai.c ****  * Copyright (c) 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_sai.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_sai.c ****  * All rights reserved.
   6:../drivers/fsl_sai.c ****  *
   7:../drivers/fsl_sai.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_sai.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_sai.c ****  * that the following conditions are met:
  10:../drivers/fsl_sai.c ****  *
  11:../drivers/fsl_sai.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_sai.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_sai.c ****  *
  14:../drivers/fsl_sai.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_sai.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_sai.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_sai.c ****  *
  18:../drivers/fsl_sai.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_sai.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_sai.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_sai.c ****  *
  22:../drivers/fsl_sai.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_sai.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_sai.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_sai.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_sai.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_sai.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_sai.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_sai.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_sai.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_sai.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_sai.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_sai.c ****  */
  34:../drivers/fsl_sai.c **** 
  35:../drivers/fsl_sai.c **** #include "fsl_sai.h"
  36:../drivers/fsl_sai.c **** 
  37:../drivers/fsl_sai.c **** /*******************************************************************************
  38:../drivers/fsl_sai.c ****  * Definitations
  39:../drivers/fsl_sai.c ****  ******************************************************************************/
  40:../drivers/fsl_sai.c **** enum _sai_transfer_state
  41:../drivers/fsl_sai.c **** {
  42:../drivers/fsl_sai.c ****     kSAI_Busy = 0x0U, /*!< SAI is busy */
  43:../drivers/fsl_sai.c ****     kSAI_Idle,        /*!< Transfer is done. */
  44:../drivers/fsl_sai.c ****     kSAI_Error        /*!< Transfer error occured. */
  45:../drivers/fsl_sai.c **** };
  46:../drivers/fsl_sai.c **** 
  47:../drivers/fsl_sai.c **** /*! @brief Typedef for sai tx interrupt handler. */
  48:../drivers/fsl_sai.c **** typedef void (*sai_tx_isr_t)(I2S_Type *base, sai_handle_t *saiHandle);
  49:../drivers/fsl_sai.c **** 
  50:../drivers/fsl_sai.c **** /*! @brief Typedef for sai rx interrupt handler. */
  51:../drivers/fsl_sai.c **** typedef void (*sai_rx_isr_t)(I2S_Type *base, sai_handle_t *saiHandle);
  52:../drivers/fsl_sai.c **** 
  53:../drivers/fsl_sai.c **** /*******************************************************************************
  54:../drivers/fsl_sai.c ****  * Prototypes
  55:../drivers/fsl_sai.c ****  ******************************************************************************/
  56:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER) && (FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER)
  57:../drivers/fsl_sai.c **** 
  58:../drivers/fsl_sai.c **** /*!
  59:../drivers/fsl_sai.c ****  * @brief Set the master clock divider.
  60:../drivers/fsl_sai.c ****  *
  61:../drivers/fsl_sai.c ****  * This API will compute the master clock divider according to master clock frequency and master
  62:../drivers/fsl_sai.c ****  * clock source clock source frequency.
  63:../drivers/fsl_sai.c ****  *
  64:../drivers/fsl_sai.c ****  * @param base SAI base pointer.
  65:../drivers/fsl_sai.c ****  * @param mclk_Hz Mater clock frequency in Hz.
  66:../drivers/fsl_sai.c ****  * @param mclkSrcClock_Hz Master clock source frequency in Hz.
  67:../drivers/fsl_sai.c ****  */
  68:../drivers/fsl_sai.c **** static void SAI_SetMasterClockDivider(I2S_Type *base, uint32_t mclk_Hz, uint32_t mclkSrcClock_Hz);
  69:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER */
  70:../drivers/fsl_sai.c **** 
  71:../drivers/fsl_sai.c **** /*!
  72:../drivers/fsl_sai.c ****  * @brief Get the instance number for SAI.
  73:../drivers/fsl_sai.c ****  *
  74:../drivers/fsl_sai.c ****  * @param base SAI base pointer.
  75:../drivers/fsl_sai.c ****  */
  76:../drivers/fsl_sai.c **** uint32_t SAI_GetInstance(I2S_Type *base);
  77:../drivers/fsl_sai.c **** 
  78:../drivers/fsl_sai.c **** /*!
  79:../drivers/fsl_sai.c ****  * @brief sends a piece of data in non-blocking way.
  80:../drivers/fsl_sai.c ****  *
  81:../drivers/fsl_sai.c ****  * @param base SAI base pointer
  82:../drivers/fsl_sai.c ****  * @param channel Data channel used.
  83:../drivers/fsl_sai.c ****  * @param bitWidth How many bits in a audio word, usually 8/16/24/32 bits.
  84:../drivers/fsl_sai.c ****  * @param buffer Pointer to the data to be written.
  85:../drivers/fsl_sai.c ****  * @param size Bytes to be written.
  86:../drivers/fsl_sai.c ****  */
  87:../drivers/fsl_sai.c **** static void SAI_WriteNonBlocking(I2S_Type *base, uint32_t channel, uint32_t bitWidth, uint8_t *buff
  88:../drivers/fsl_sai.c **** 
  89:../drivers/fsl_sai.c **** /*!
  90:../drivers/fsl_sai.c ****  * @brief Receive a piece of data in non-blocking way.
  91:../drivers/fsl_sai.c ****  *
  92:../drivers/fsl_sai.c ****  * @param base SAI base pointer
  93:../drivers/fsl_sai.c ****  * @param channel Data channel used.
  94:../drivers/fsl_sai.c ****  * @param bitWidth How many bits in a audio word, usually 8/16/24/32 bits.
  95:../drivers/fsl_sai.c ****  * @param buffer Pointer to the data to be read.
  96:../drivers/fsl_sai.c ****  * @param size Bytes to be read.
  97:../drivers/fsl_sai.c ****  */
  98:../drivers/fsl_sai.c **** static void SAI_ReadNonBlocking(I2S_Type *base, uint32_t channel, uint32_t bitWidth, uint8_t *buffe
  99:../drivers/fsl_sai.c **** /*******************************************************************************
 100:../drivers/fsl_sai.c ****  * Variables
 101:../drivers/fsl_sai.c ****  ******************************************************************************/
 102:../drivers/fsl_sai.c **** /* Base pointer array */
 103:../drivers/fsl_sai.c **** static I2S_Type *const s_saiBases[] = I2S_BASE_PTRS;
 104:../drivers/fsl_sai.c **** /*!@brief SAI handle pointer */
 105:../drivers/fsl_sai.c **** sai_handle_t *s_saiHandle[ARRAY_SIZE(s_saiBases)][2];
 106:../drivers/fsl_sai.c **** /* IRQ number array */
 107:../drivers/fsl_sai.c **** static const IRQn_Type s_saiTxIRQ[] = I2S_TX_IRQS;
 108:../drivers/fsl_sai.c **** static const IRQn_Type s_saiRxIRQ[] = I2S_RX_IRQS;
 109:../drivers/fsl_sai.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 110:../drivers/fsl_sai.c **** /* Clock name array */
 111:../drivers/fsl_sai.c **** static const clock_ip_name_t s_saiClock[] = SAI_CLOCKS;
 112:../drivers/fsl_sai.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 113:../drivers/fsl_sai.c **** /*! @brief Pointer to tx IRQ handler for each instance. */
 114:../drivers/fsl_sai.c **** static sai_tx_isr_t s_saiTxIsr;
 115:../drivers/fsl_sai.c **** /*! @brief Pointer to tx IRQ handler for each instance. */
 116:../drivers/fsl_sai.c **** static sai_rx_isr_t s_saiRxIsr;
 117:../drivers/fsl_sai.c **** 
 118:../drivers/fsl_sai.c **** /*******************************************************************************
 119:../drivers/fsl_sai.c ****  * Code
 120:../drivers/fsl_sai.c ****  ******************************************************************************/
 121:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER) && (FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER)
 122:../drivers/fsl_sai.c **** static void SAI_SetMasterClockDivider(I2S_Type *base, uint32_t mclk_Hz, uint32_t mclkSrcClock_Hz)
 123:../drivers/fsl_sai.c **** {
 124:../drivers/fsl_sai.c ****     uint32_t freq = mclkSrcClock_Hz;
 125:../drivers/fsl_sai.c ****     uint16_t fract, divide;
 126:../drivers/fsl_sai.c ****     uint32_t remaind = 0;
 127:../drivers/fsl_sai.c ****     uint32_t current_remainder = 0xFFFFFFFFU;
 128:../drivers/fsl_sai.c ****     uint16_t current_fract = 0;
 129:../drivers/fsl_sai.c ****     uint16_t current_divide = 0;
 130:../drivers/fsl_sai.c ****     uint32_t mul_freq = 0;
 131:../drivers/fsl_sai.c ****     uint32_t max_fract = 256;
 132:../drivers/fsl_sai.c **** 
 133:../drivers/fsl_sai.c ****     /*In order to prevent overflow */
 134:../drivers/fsl_sai.c ****     freq /= 100;
 135:../drivers/fsl_sai.c ****     mclk_Hz /= 100;
 136:../drivers/fsl_sai.c **** 
 137:../drivers/fsl_sai.c ****     /* Compute the max fract number */
 138:../drivers/fsl_sai.c ****     max_fract = mclk_Hz * 4096 / freq + 1;
 139:../drivers/fsl_sai.c ****     if (max_fract > 256)
 140:../drivers/fsl_sai.c ****     {
 141:../drivers/fsl_sai.c ****         max_fract = 256;
 142:../drivers/fsl_sai.c ****     }
 143:../drivers/fsl_sai.c **** 
 144:../drivers/fsl_sai.c ****     /* Looking for the closet frequency */
 145:../drivers/fsl_sai.c ****     for (fract = 1; fract < max_fract; fract++)
 146:../drivers/fsl_sai.c ****     {
 147:../drivers/fsl_sai.c ****         mul_freq = freq * fract;
 148:../drivers/fsl_sai.c ****         remaind = mul_freq % mclk_Hz;
 149:../drivers/fsl_sai.c ****         divide = mul_freq / mclk_Hz;
 150:../drivers/fsl_sai.c **** 
 151:../drivers/fsl_sai.c ****         /* Find the exactly frequency */
 152:../drivers/fsl_sai.c ****         if (remaind == 0)
 153:../drivers/fsl_sai.c ****         {
 154:../drivers/fsl_sai.c ****             current_fract = fract;
 155:../drivers/fsl_sai.c ****             current_divide = mul_freq / mclk_Hz;
 156:../drivers/fsl_sai.c ****             break;
 157:../drivers/fsl_sai.c ****         }
 158:../drivers/fsl_sai.c **** 
 159:../drivers/fsl_sai.c ****         /* Closer to next one, set the closest to next data */
 160:../drivers/fsl_sai.c ****         if (remaind > mclk_Hz / 2)
 161:../drivers/fsl_sai.c ****         {
 162:../drivers/fsl_sai.c ****             remaind = mclk_Hz - remaind;
 163:../drivers/fsl_sai.c ****             divide += 1;
 164:../drivers/fsl_sai.c ****         }
 165:../drivers/fsl_sai.c **** 
 166:../drivers/fsl_sai.c ****         /* Update the closest div and fract */
 167:../drivers/fsl_sai.c ****         if (remaind < current_remainder)
 168:../drivers/fsl_sai.c ****         {
 169:../drivers/fsl_sai.c ****             current_fract = fract;
 170:../drivers/fsl_sai.c ****             current_divide = divide;
 171:../drivers/fsl_sai.c ****             current_remainder = remaind;
 172:../drivers/fsl_sai.c ****         }
 173:../drivers/fsl_sai.c ****     }
 174:../drivers/fsl_sai.c **** 
 175:../drivers/fsl_sai.c ****     /* Fill the computed fract and divider to registers */
 176:../drivers/fsl_sai.c ****     base->MDR = I2S_MDR_DIVIDE(current_divide - 1) | I2S_MDR_FRACT(current_fract - 1);
 177:../drivers/fsl_sai.c **** 
 178:../drivers/fsl_sai.c ****     /* Waiting for the divider updated */
 179:../drivers/fsl_sai.c ****     while (base->MCR & I2S_MCR_DUF_MASK)
 180:../drivers/fsl_sai.c ****     {
 181:../drivers/fsl_sai.c ****     }
 182:../drivers/fsl_sai.c **** }
 183:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER */
 184:../drivers/fsl_sai.c **** 
 185:../drivers/fsl_sai.c **** uint32_t SAI_GetInstance(I2S_Type *base)
 186:../drivers/fsl_sai.c **** {
 187:../drivers/fsl_sai.c ****     uint32_t instance;
 188:../drivers/fsl_sai.c **** 
 189:../drivers/fsl_sai.c ****     /* Find the instance index from base address mappings. */
 190:../drivers/fsl_sai.c ****     for (instance = 0; instance < ARRAY_SIZE(s_saiBases); instance++)
 191:../drivers/fsl_sai.c ****     {
 192:../drivers/fsl_sai.c ****         if (s_saiBases[instance] == base)
 193:../drivers/fsl_sai.c ****         {
 194:../drivers/fsl_sai.c ****             break;
 195:../drivers/fsl_sai.c ****         }
 196:../drivers/fsl_sai.c ****     }
 197:../drivers/fsl_sai.c **** 
 198:../drivers/fsl_sai.c ****     assert(instance < ARRAY_SIZE(s_saiBases));
 199:../drivers/fsl_sai.c **** 
 200:../drivers/fsl_sai.c ****     return instance;
 201:../drivers/fsl_sai.c **** }
 202:../drivers/fsl_sai.c **** 
 203:../drivers/fsl_sai.c **** static void SAI_WriteNonBlocking(I2S_Type *base, uint32_t channel, uint32_t bitWidth, uint8_t *buff
 204:../drivers/fsl_sai.c **** {
  26              		.loc 1 204 0
  27              		.cfi_startproc
  28              		@ args = 4, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  32              		.cfi_def_cfa_offset 24
  33              		.cfi_offset 3, -24
  34              		.cfi_offset 4, -20
  35              		.cfi_offset 5, -16
  36              		.cfi_offset 6, -12
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 CE46     		mov	lr, r9
  40 0004 4746     		mov	r7, r8
  41 0006 80B5     		push	{r7, lr}
  42              		.cfi_def_cfa_offset 32
  43              		.cfi_offset 8, -32
  44              		.cfi_offset 9, -28
  45 0008 8146     		mov	r9, r0
  46 000a 8846     		mov	r8, r1
  47 000c 1C00     		movs	r4, r3
  48              	.LVL1:
 205:../drivers/fsl_sai.c ****     uint32_t i = 0;
 206:../drivers/fsl_sai.c ****     uint8_t j = 0;
 207:../drivers/fsl_sai.c ****     uint8_t bytesPerWord = bitWidth / 8U;
  49              		.loc 1 207 0
  50 000e D708     		lsrs	r7, r2, #3
  51 0010 FDB2     		uxtb	r5, r7
  52              	.LVL2:
 208:../drivers/fsl_sai.c ****     uint32_t data = 0;
 209:../drivers/fsl_sai.c ****     uint32_t temp = 0;
 210:../drivers/fsl_sai.c **** 
 211:../drivers/fsl_sai.c ****     for (i = 0; i < size / bytesPerWord; i++)
  53              		.loc 1 211 0
  54 0012 0026     		movs	r6, #0
  55 0014 0EE0     		b	.L2
  56              	.LVL3:
  57              	.L3:
 212:../drivers/fsl_sai.c ****     {
 213:../drivers/fsl_sai.c ****         for (j = 0; j < bytesPerWord; j++)
 214:../drivers/fsl_sai.c ****         {
 215:../drivers/fsl_sai.c ****             temp = (uint32_t)(*buffer);
  58              		.loc 1 215 0 discriminator 3
  59 0016 2278     		ldrb	r2, [r4]
  60              	.LVL4:
 216:../drivers/fsl_sai.c ****             data |= (temp << (8U * j));
  61              		.loc 1 216 0 discriminator 3
  62 0018 D800     		lsls	r0, r3, #3
  63 001a 8240     		lsls	r2, r2, r0
  64              	.LVL5:
  65 001c 1143     		orrs	r1, r2
  66              	.LVL6:
 217:../drivers/fsl_sai.c ****             buffer++;
  67              		.loc 1 217 0 discriminator 3
  68 001e 0134     		adds	r4, r4, #1
  69              	.LVL7:
 213:../drivers/fsl_sai.c ****         {
  70              		.loc 1 213 0 discriminator 3
  71 0020 0133     		adds	r3, r3, #1
  72              	.LVL8:
  73 0022 DBB2     		uxtb	r3, r3
  74              	.LVL9:
  75              	.L4:
 213:../drivers/fsl_sai.c ****         {
  76              		.loc 1 213 0 is_stmt 0 discriminator 1
  77 0024 AB42     		cmp	r3, r5
  78 0026 F6D3     		bcc	.L3
 218:../drivers/fsl_sai.c ****         }
 219:../drivers/fsl_sai.c ****         base->TDR[channel] = data;
  79              		.loc 1 219 0 is_stmt 1 discriminator 2
  80 0028 4346     		mov	r3, r8
  81              	.LVL10:
  82 002a 0833     		adds	r3, r3, #8
  83 002c 9B00     		lsls	r3, r3, #2
  84 002e 4A46     		mov	r2, r9
  85 0030 9950     		str	r1, [r3, r2]
  86              	.LVL11:
 211:../drivers/fsl_sai.c ****     {
  87              		.loc 1 211 0 discriminator 2
  88 0032 0136     		adds	r6, r6, #1
  89              	.LVL12:
  90              	.L2:
 211:../drivers/fsl_sai.c ****     {
  91              		.loc 1 211 0 is_stmt 0 discriminator 1
  92 0034 FF21     		movs	r1, #255
  93 0036 3940     		ands	r1, r7
  94 0038 0898     		ldr	r0, [sp, #32]
  95 003a FFF7FEFF 		bl	__aeabi_uidiv
  96              	.LVL13:
  97 003e B042     		cmp	r0, r6
  98 0040 02D9     		bls	.L6
  99 0042 0021     		movs	r1, #0
 213:../drivers/fsl_sai.c ****         {
 100              		.loc 1 213 0 is_stmt 1
 101 0044 0023     		movs	r3, #0
 102 0046 EDE7     		b	.L4
 103              	.L6:
 220:../drivers/fsl_sai.c ****         data = 0;
 221:../drivers/fsl_sai.c ****     }
 222:../drivers/fsl_sai.c **** }
 104              		.loc 1 222 0
 105              		@ sp needed
 106              	.LVL14:
 107              	.LVL15:
 108              	.LVL16:
 109              	.LVL17:
 110              	.LVL18:
 111              	.LVL19:
 112 0048 0CBC     		pop	{r2, r3}
 113 004a 9046     		mov	r8, r2
 114 004c 9946     		mov	r9, r3
 115 004e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 116              		.cfi_endproc
 117              	.LFE68:
 119              		.section	.text.SAI_ReadNonBlocking,"ax",%progbits
 120              		.align	1
 121              		.syntax unified
 122              		.code	16
 123              		.thumb_func
 124              		.fpu softvfp
 126              	SAI_ReadNonBlocking:
 127              	.LFB69:
 223:../drivers/fsl_sai.c **** 
 224:../drivers/fsl_sai.c **** static void SAI_ReadNonBlocking(I2S_Type *base, uint32_t channel, uint32_t bitWidth, uint8_t *buffe
 225:../drivers/fsl_sai.c **** {
 128              		.loc 1 225 0
 129              		.cfi_startproc
 130              		@ args = 4, pretend = 0, frame = 0
 131              		@ frame_needed = 0, uses_anonymous_args = 0
 132              	.LVL20:
 133 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 134              		.cfi_def_cfa_offset 24
 135              		.cfi_offset 3, -24
 136              		.cfi_offset 4, -20
 137              		.cfi_offset 5, -16
 138              		.cfi_offset 6, -12
 139              		.cfi_offset 7, -8
 140              		.cfi_offset 14, -4
 141 0002 CE46     		mov	lr, r9
 142 0004 4746     		mov	r7, r8
 143 0006 80B5     		push	{r7, lr}
 144              		.cfi_def_cfa_offset 32
 145              		.cfi_offset 8, -32
 146              		.cfi_offset 9, -28
 147 0008 8146     		mov	r9, r0
 148 000a 8846     		mov	r8, r1
 149 000c 1C00     		movs	r4, r3
 150              	.LVL21:
 226:../drivers/fsl_sai.c ****     uint32_t i = 0;
 227:../drivers/fsl_sai.c ****     uint8_t j = 0;
 228:../drivers/fsl_sai.c ****     uint8_t bytesPerWord = bitWidth / 8U;
 151              		.loc 1 228 0
 152 000e D708     		lsrs	r7, r2, #3
 153 0010 FDB2     		uxtb	r5, r7
 154              	.LVL22:
 229:../drivers/fsl_sai.c ****     uint32_t data = 0;
 230:../drivers/fsl_sai.c **** 
 231:../drivers/fsl_sai.c ****     for (i = 0; i < size / bytesPerWord; i++)
 155              		.loc 1 231 0
 156 0012 0026     		movs	r6, #0
 157 0014 09E0     		b	.L8
 158              	.LVL23:
 159              	.L10:
 232:../drivers/fsl_sai.c ****     {
 233:../drivers/fsl_sai.c ****         data = base->RDR[channel];
 234:../drivers/fsl_sai.c ****         for (j = 0; j < bytesPerWord; j++)
 235:../drivers/fsl_sai.c ****         {
 236:../drivers/fsl_sai.c ****             *buffer = (data >> (8U * j)) & 0xFF;
 160              		.loc 1 236 0 discriminator 3
 161 0016 DA00     		lsls	r2, r3, #3
 162 0018 0800     		movs	r0, r1
 163 001a D040     		lsrs	r0, r0, r2
 164 001c 2070     		strb	r0, [r4]
 237:../drivers/fsl_sai.c ****             buffer++;
 165              		.loc 1 237 0 discriminator 3
 166 001e 0134     		adds	r4, r4, #1
 167              	.LVL24:
 234:../drivers/fsl_sai.c ****         {
 168              		.loc 1 234 0 discriminator 3
 169 0020 0133     		adds	r3, r3, #1
 170              	.LVL25:
 171 0022 DBB2     		uxtb	r3, r3
 172              	.LVL26:
 173              	.L9:
 234:../drivers/fsl_sai.c ****         {
 174              		.loc 1 234 0 is_stmt 0 discriminator 1
 175 0024 AB42     		cmp	r3, r5
 176 0026 F6D3     		bcc	.L10
 231:../drivers/fsl_sai.c ****     {
 177              		.loc 1 231 0 is_stmt 1 discriminator 2
 178 0028 0136     		adds	r6, r6, #1
 179              	.LVL27:
 180              	.L8:
 231:../drivers/fsl_sai.c ****     {
 181              		.loc 1 231 0 is_stmt 0 discriminator 1
 182 002a FF21     		movs	r1, #255
 183 002c 3940     		ands	r1, r7
 184 002e 0898     		ldr	r0, [sp, #32]
 185 0030 FFF7FEFF 		bl	__aeabi_uidiv
 186              	.LVL28:
 187 0034 B042     		cmp	r0, r6
 188 0036 06D9     		bls	.L12
 233:../drivers/fsl_sai.c ****         for (j = 0; j < bytesPerWord; j++)
 189              		.loc 1 233 0 is_stmt 1
 190 0038 4346     		mov	r3, r8
 191 003a 2833     		adds	r3, r3, #40
 192 003c 9B00     		lsls	r3, r3, #2
 193 003e 4A46     		mov	r2, r9
 194 0040 9958     		ldr	r1, [r3, r2]
 195              	.LVL29:
 234:../drivers/fsl_sai.c ****         {
 196              		.loc 1 234 0
 197 0042 0023     		movs	r3, #0
 198 0044 EEE7     		b	.L9
 199              	.LVL30:
 200              	.L12:
 238:../drivers/fsl_sai.c ****         }
 239:../drivers/fsl_sai.c ****     }
 240:../drivers/fsl_sai.c **** }
 201              		.loc 1 240 0
 202              		@ sp needed
 203              	.LVL31:
 204              	.LVL32:
 205              	.LVL33:
 206              	.LVL34:
 207              	.LVL35:
 208              	.LVL36:
 209 0046 0CBC     		pop	{r2, r3}
 210 0048 9046     		mov	r8, r2
 211 004a 9946     		mov	r9, r3
 212 004c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 213              		.cfi_endproc
 214              	.LFE69:
 216              		.section	.text.SAI_GetInstance,"ax",%progbits
 217              		.align	1
 218              		.global	SAI_GetInstance
 219              		.syntax unified
 220              		.code	16
 221              		.thumb_func
 222              		.fpu softvfp
 224              	SAI_GetInstance:
 225              	.LFB67:
 186:../drivers/fsl_sai.c ****     uint32_t instance;
 226              		.loc 1 186 0
 227              		.cfi_startproc
 228              		@ args = 0, pretend = 0, frame = 0
 229              		@ frame_needed = 0, uses_anonymous_args = 0
 230              		@ link register save eliminated.
 231              	.LVL37:
 190:../drivers/fsl_sai.c ****     {
 232              		.loc 1 190 0
 233 0000 0023     		movs	r3, #0
 234              	.LVL38:
 235              	.L14:
 190:../drivers/fsl_sai.c ****     {
 236              		.loc 1 190 0 is_stmt 0 discriminator 1
 237 0002 002B     		cmp	r3, #0
 238 0004 01D0     		beq	.L16
 239              	.L13:
 201:../drivers/fsl_sai.c **** 
 240              		.loc 1 201 0 is_stmt 1
 241 0006 1800     		movs	r0, r3
 242              	.LVL39:
 243              		@ sp needed
 244 0008 7047     		bx	lr
 245              	.LVL40:
 246              	.L16:
 192:../drivers/fsl_sai.c ****         {
 247              		.loc 1 192 0
 248 000a 024A     		ldr	r2, .L17
 249 000c 9042     		cmp	r0, r2
 250 000e FAD0     		beq	.L13
 190:../drivers/fsl_sai.c ****     {
 251              		.loc 1 190 0 discriminator 2
 252 0010 0133     		adds	r3, r3, #1
 253              	.LVL41:
 254 0012 F6E7     		b	.L14
 255              	.L18:
 256              		.align	2
 257              	.L17:
 258 0014 00F00240 		.word	1073934336
 259              		.cfi_endproc
 260              	.LFE67:
 262              		.section	.text.SAI_TxInit,"ax",%progbits
 263              		.align	1
 264              		.global	SAI_TxInit
 265              		.syntax unified
 266              		.code	16
 267              		.thumb_func
 268              		.fpu softvfp
 270              	SAI_TxInit:
 271              	.LFB70:
 241:../drivers/fsl_sai.c **** 
 242:../drivers/fsl_sai.c **** void SAI_TxInit(I2S_Type *base, const sai_config_t *config)
 243:../drivers/fsl_sai.c **** {
 272              		.loc 1 243 0
 273              		.cfi_startproc
 274              		@ args = 0, pretend = 0, frame = 0
 275              		@ frame_needed = 0, uses_anonymous_args = 0
 276              	.LVL42:
 277 0000 70B5     		push	{r4, r5, r6, lr}
 278              		.cfi_def_cfa_offset 16
 279              		.cfi_offset 4, -16
 280              		.cfi_offset 5, -12
 281              		.cfi_offset 6, -8
 282              		.cfi_offset 14, -4
 283 0002 0400     		movs	r4, r0
 284 0004 0D00     		movs	r5, r1
 285              	.LVL43:
 244:../drivers/fsl_sai.c ****     uint32_t val = 0;
 245:../drivers/fsl_sai.c **** 
 246:../drivers/fsl_sai.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 247:../drivers/fsl_sai.c ****     /* Enable the SAI clock */
 248:../drivers/fsl_sai.c ****     CLOCK_EnableClock(s_saiClock[SAI_GetInstance(base)]);
 286              		.loc 1 248 0
 287 0006 FFF7FEFF 		bl	SAI_GetInstance
 288              	.LVL44:
 289              	.LBB36:
 290              	.LBB37:
 291              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 292              		.loc 2 450 0
 293 000a 534A     		ldr	r2, .L34
 294 000c 1168     		ldr	r1, [r2]
 295 000e 8023     		movs	r3, #128
 296 0010 1B02     		lsls	r3, r3, #8
 297 0012 0B43     		orrs	r3, r1
 298 0014 1360     		str	r3, [r2]
 299              	.LVL45:
 300              	.LBE37:
 301              	.LBE36:
 249:../drivers/fsl_sai.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 250:../drivers/fsl_sai.c **** 
 251:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCR) && (FSL_FEATURE_SAI_HAS_MCR)
 252:../drivers/fsl_sai.c ****     /* Master clock source setting */
 253:../drivers/fsl_sai.c ****     val = (base->MCR & ~I2S_MCR_MICS_MASK);
 302              		.loc 1 253 0
 303 0016 8022     		movs	r2, #128
 304 0018 5200     		lsls	r2, r2, #1
 305 001a A358     		ldr	r3, [r4, r2]
 306 001c 4F49     		ldr	r1, .L34+4
 307 001e 1940     		ands	r1, r3
 308              	.LVL46:
 254:../drivers/fsl_sai.c ****     base->MCR = (val | I2S_MCR_MICS(config->mclkSource));
 309              		.loc 1 254 0
 310 0020 EB78     		ldrb	r3, [r5, #3]
 311 0022 1B06     		lsls	r3, r3, #24
 312 0024 C020     		movs	r0, #192
 313 0026 8004     		lsls	r0, r0, #18
 314 0028 0340     		ands	r3, r0
 315 002a 0B43     		orrs	r3, r1
 316 002c A350     		str	r3, [r4, r2]
 255:../drivers/fsl_sai.c **** 
 256:../drivers/fsl_sai.c ****     /* Configure Master clock output enable */
 257:../drivers/fsl_sai.c ****     val = (base->MCR & ~I2S_MCR_MOE_MASK);
 317              		.loc 1 257 0
 318 002e A358     		ldr	r3, [r4, r2]
 319 0030 4B49     		ldr	r1, .L34+8
 320              	.LVL47:
 321 0032 1940     		ands	r1, r3
 322              	.LVL48:
 258:../drivers/fsl_sai.c ****     base->MCR = (val | I2S_MCR_MOE(config->mclkOutputEnable));
 323              		.loc 1 258 0
 324 0034 AB78     		ldrb	r3, [r5, #2]
 325 0036 9B07     		lsls	r3, r3, #30
 326 0038 8020     		movs	r0, #128
 327 003a C005     		lsls	r0, r0, #23
 328 003c 0340     		ands	r3, r0
 329 003e 0B43     		orrs	r3, r1
 330 0040 A350     		str	r3, [r4, r2]
 259:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCR */
 260:../drivers/fsl_sai.c **** 
 261:../drivers/fsl_sai.c ****     /* Configure audio protocol */
 262:../drivers/fsl_sai.c ****     switch (config->protocol)
 331              		.loc 1 262 0
 332 0042 2B78     		ldrb	r3, [r5]
 333 0044 042B     		cmp	r3, #4
 334 0046 0ED8     		bhi	.L20
 335 0048 9B00     		lsls	r3, r3, #2
 336 004a 464A     		ldr	r2, .L34+12
 337 004c D358     		ldr	r3, [r2, r3]
 338 004e 9F46     		mov	pc, r3
 339              		.section	.rodata.SAI_TxInit,"a",%progbits
 340              		.align	2
 341              	.L22:
 342 0000 50000000 		.word	.L21
 343 0004 A6000000 		.word	.L23
 344 0008 BE000000 		.word	.L24
 345 000c D6000000 		.word	.L25
 346 0010 EC000000 		.word	.L26
 347              		.section	.text.SAI_TxInit
 348              	.L21:
 263:../drivers/fsl_sai.c ****     {
 264:../drivers/fsl_sai.c ****         case kSAI_BusLeftJustified:
 265:../drivers/fsl_sai.c ****             base->TCR2 |= I2S_TCR2_BCP_MASK;
 349              		.loc 1 265 0
 350 0050 A268     		ldr	r2, [r4, #8]
 351 0052 8023     		movs	r3, #128
 352 0054 9B04     		lsls	r3, r3, #18
 353 0056 1343     		orrs	r3, r2
 354 0058 A360     		str	r3, [r4, #8]
 266:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 355              		.loc 1 266 0
 356 005a E368     		ldr	r3, [r4, #12]
 357 005c 0122     		movs	r2, #1
 358 005e 9343     		bics	r3, r2
 359 0060 E360     		str	r3, [r4, #12]
 267:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(31U) | I2S_TCR4_FSE(0U) | I2S_TCR4_FSP(0U)
 360              		.loc 1 267 0
 361 0062 414B     		ldr	r3, .L34+16
 362 0064 2361     		str	r3, [r4, #16]
 363              	.L20:
 268:../drivers/fsl_sai.c ****             break;
 269:../drivers/fsl_sai.c **** 
 270:../drivers/fsl_sai.c ****         case kSAI_BusRightJustified:
 271:../drivers/fsl_sai.c ****             base->TCR2 |= I2S_TCR2_BCP_MASK;
 272:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 273:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(31U) | I2S_TCR4_FSE(0U) | I2S_TCR4_FSP(0U)
 274:../drivers/fsl_sai.c ****             break;
 275:../drivers/fsl_sai.c **** 
 276:../drivers/fsl_sai.c ****         case kSAI_BusI2S:
 277:../drivers/fsl_sai.c ****             base->TCR2 |= I2S_TCR2_BCP_MASK;
 278:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 279:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(31U) | I2S_TCR4_FSE(1U) | I2S_TCR4_FSP(1U)
 280:../drivers/fsl_sai.c ****             break;
 281:../drivers/fsl_sai.c **** 
 282:../drivers/fsl_sai.c ****         case kSAI_BusPCMA:
 283:../drivers/fsl_sai.c ****             base->TCR2 &= ~I2S_TCR2_BCP_MASK;
 284:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 285:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(0U) | I2S_TCR4_FSE(1U) | I2S_TCR4_FSP(0U) 
 286:../drivers/fsl_sai.c ****             break;
 287:../drivers/fsl_sai.c **** 
 288:../drivers/fsl_sai.c ****         case kSAI_BusPCMB:
 289:../drivers/fsl_sai.c ****             base->TCR2 &= ~I2S_TCR2_BCP_MASK;
 290:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 291:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(0U) | I2S_TCR4_FSE(0U) | I2S_TCR4_FSP(0U) 
 292:../drivers/fsl_sai.c ****             break;
 293:../drivers/fsl_sai.c **** 
 294:../drivers/fsl_sai.c ****         default:
 295:../drivers/fsl_sai.c ****             break;
 296:../drivers/fsl_sai.c ****     }
 297:../drivers/fsl_sai.c **** 
 298:../drivers/fsl_sai.c ****     /* Set master or slave */
 299:../drivers/fsl_sai.c ****     if (config->masterSlave == kSAI_Master)
 364              		.loc 1 299 0
 365 0066 6B79     		ldrb	r3, [r5, #5]
 366 0068 002B     		cmp	r3, #0
 367 006a 4AD1     		bne	.L27
 300:../drivers/fsl_sai.c ****     {
 301:../drivers/fsl_sai.c ****         base->TCR2 |= I2S_TCR2_BCD_MASK;
 368              		.loc 1 301 0
 369 006c A268     		ldr	r2, [r4, #8]
 370 006e 8023     		movs	r3, #128
 371 0070 5B04     		lsls	r3, r3, #17
 372 0072 1343     		orrs	r3, r2
 373 0074 A360     		str	r3, [r4, #8]
 302:../drivers/fsl_sai.c ****         base->TCR4 |= I2S_TCR4_FSD_MASK;
 374              		.loc 1 302 0
 375 0076 2369     		ldr	r3, [r4, #16]
 376 0078 0122     		movs	r2, #1
 377 007a 1343     		orrs	r3, r2
 378 007c 2361     		str	r3, [r4, #16]
 303:../drivers/fsl_sai.c **** 
 304:../drivers/fsl_sai.c ****         /* Bit clock source setting */
 305:../drivers/fsl_sai.c ****         val = base->TCR2 & (~I2S_TCR2_MSEL_MASK);
 379              		.loc 1 305 0
 380 007e A368     		ldr	r3, [r4, #8]
 381 0080 3A4A     		ldr	r2, .L34+20
 382 0082 1A40     		ands	r2, r3
 383              	.LVL49:
 306:../drivers/fsl_sai.c ****         base->TCR2 = (val | I2S_TCR2_MSEL(config->bclkSource));
 384              		.loc 1 306 0
 385 0084 2B79     		ldrb	r3, [r5, #4]
 386 0086 9B06     		lsls	r3, r3, #26
 387 0088 C021     		movs	r1, #192
 388 008a 0905     		lsls	r1, r1, #20
 389 008c 0B40     		ands	r3, r1
 390 008e 1343     		orrs	r3, r2
 391 0090 A360     		str	r3, [r4, #8]
 392              	.LVL50:
 393              	.L28:
 307:../drivers/fsl_sai.c ****     }
 308:../drivers/fsl_sai.c ****     else
 309:../drivers/fsl_sai.c ****     {
 310:../drivers/fsl_sai.c ****         base->TCR2 &= ~I2S_TCR2_BCD_MASK;
 311:../drivers/fsl_sai.c ****         base->TCR4 &= ~I2S_TCR4_FSD_MASK;
 312:../drivers/fsl_sai.c ****     }
 313:../drivers/fsl_sai.c **** 
 314:../drivers/fsl_sai.c ****     /* Set Sync mode */
 315:../drivers/fsl_sai.c ****     switch (config->syncMode)
 394              		.loc 1 315 0
 395 0092 6B78     		ldrb	r3, [r5, #1]
 396 0094 012B     		cmp	r3, #1
 397 0096 42D0     		beq	.L30
 398 0098 002B     		cmp	r3, #0
 399 009a 3BD0     		beq	.L31
 400 009c 022B     		cmp	r3, #2
 401 009e 4BD0     		beq	.L32
 402 00a0 032B     		cmp	r3, #3
 403 00a2 51D0     		beq	.L33
 404              	.L19:
 316:../drivers/fsl_sai.c ****     {
 317:../drivers/fsl_sai.c ****         case kSAI_ModeAsync:
 318:../drivers/fsl_sai.c ****             val = base->TCR2;
 319:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 320:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(0U));
 321:../drivers/fsl_sai.c ****             break;
 322:../drivers/fsl_sai.c ****         case kSAI_ModeSync:
 323:../drivers/fsl_sai.c ****             val = base->TCR2;
 324:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 325:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(1U));
 326:../drivers/fsl_sai.c ****             /* If sync with Rx, should set Rx to async mode */
 327:../drivers/fsl_sai.c ****             val = base->RCR2;
 328:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 329:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(0U));
 330:../drivers/fsl_sai.c ****             break;
 331:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherTx:
 332:../drivers/fsl_sai.c ****             val = base->TCR2;
 333:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 334:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(2U));
 335:../drivers/fsl_sai.c ****             break;
 336:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherRx:
 337:../drivers/fsl_sai.c ****             val = base->TCR2;
 338:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 339:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(3U));
 340:../drivers/fsl_sai.c ****             break;
 341:../drivers/fsl_sai.c ****         default:
 342:../drivers/fsl_sai.c ****             break;
 343:../drivers/fsl_sai.c ****     }
 344:../drivers/fsl_sai.c **** }
 405              		.loc 1 344 0
 406              		@ sp needed
 407              	.LVL51:
 408              	.LVL52:
 409 00a4 70BD     		pop	{r4, r5, r6, pc}
 410              	.LVL53:
 411              	.L23:
 271:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 412              		.loc 1 271 0
 413 00a6 A268     		ldr	r2, [r4, #8]
 414 00a8 8023     		movs	r3, #128
 415 00aa 9B04     		lsls	r3, r3, #18
 416 00ac 1343     		orrs	r3, r2
 417 00ae A360     		str	r3, [r4, #8]
 272:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(31U) | I2S_TCR4_FSE(0U) | I2S_TCR4_FSP(0U)
 418              		.loc 1 272 0
 419 00b0 E368     		ldr	r3, [r4, #12]
 420 00b2 0122     		movs	r2, #1
 421 00b4 9343     		bics	r3, r2
 422 00b6 E360     		str	r3, [r4, #12]
 273:../drivers/fsl_sai.c ****             break;
 423              		.loc 1 273 0
 424 00b8 2B4B     		ldr	r3, .L34+16
 425 00ba 2361     		str	r3, [r4, #16]
 274:../drivers/fsl_sai.c **** 
 426              		.loc 1 274 0
 427 00bc D3E7     		b	.L20
 428              	.L24:
 277:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 429              		.loc 1 277 0
 430 00be A268     		ldr	r2, [r4, #8]
 431 00c0 8023     		movs	r3, #128
 432 00c2 9B04     		lsls	r3, r3, #18
 433 00c4 1343     		orrs	r3, r2
 434 00c6 A360     		str	r3, [r4, #8]
 278:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(31U) | I2S_TCR4_FSE(1U) | I2S_TCR4_FSP(1U)
 435              		.loc 1 278 0
 436 00c8 E368     		ldr	r3, [r4, #12]
 437 00ca 0122     		movs	r2, #1
 438 00cc 9343     		bics	r3, r2
 439 00ce E360     		str	r3, [r4, #12]
 279:../drivers/fsl_sai.c ****             break;
 440              		.loc 1 279 0
 441 00d0 274B     		ldr	r3, .L34+24
 442 00d2 2361     		str	r3, [r4, #16]
 280:../drivers/fsl_sai.c **** 
 443              		.loc 1 280 0
 444 00d4 C7E7     		b	.L20
 445              	.L25:
 283:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 446              		.loc 1 283 0
 447 00d6 A368     		ldr	r3, [r4, #8]
 448 00d8 264A     		ldr	r2, .L34+28
 449 00da 1340     		ands	r3, r2
 450 00dc A360     		str	r3, [r4, #8]
 284:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(0U) | I2S_TCR4_FSE(1U) | I2S_TCR4_FSP(0U) 
 451              		.loc 1 284 0
 452 00de E368     		ldr	r3, [r4, #12]
 453 00e0 0122     		movs	r2, #1
 454 00e2 9343     		bics	r3, r2
 455 00e4 E360     		str	r3, [r4, #12]
 285:../drivers/fsl_sai.c ****             break;
 456              		.loc 1 285 0
 457 00e6 244B     		ldr	r3, .L34+32
 458 00e8 2361     		str	r3, [r4, #16]
 286:../drivers/fsl_sai.c **** 
 459              		.loc 1 286 0
 460 00ea BCE7     		b	.L20
 461              	.L26:
 289:../drivers/fsl_sai.c ****             base->TCR3 &= ~I2S_TCR3_WDFL_MASK;
 462              		.loc 1 289 0
 463 00ec A368     		ldr	r3, [r4, #8]
 464 00ee 214A     		ldr	r2, .L34+28
 465 00f0 1340     		ands	r3, r2
 466 00f2 A360     		str	r3, [r4, #8]
 290:../drivers/fsl_sai.c ****             base->TCR4 = I2S_TCR4_MF(1U) | I2S_TCR4_SYWD(0U) | I2S_TCR4_FSE(0U) | I2S_TCR4_FSP(0U) 
 467              		.loc 1 290 0
 468 00f4 E368     		ldr	r3, [r4, #12]
 469 00f6 0122     		movs	r2, #1
 470 00f8 9343     		bics	r3, r2
 471 00fa E360     		str	r3, [r4, #12]
 291:../drivers/fsl_sai.c ****             break;
 472              		.loc 1 291 0
 473 00fc 1F4B     		ldr	r3, .L34+36
 474 00fe 2361     		str	r3, [r4, #16]
 292:../drivers/fsl_sai.c **** 
 475              		.loc 1 292 0
 476 0100 B1E7     		b	.L20
 477              	.L27:
 310:../drivers/fsl_sai.c ****         base->TCR4 &= ~I2S_TCR4_FSD_MASK;
 478              		.loc 1 310 0
 479 0102 A368     		ldr	r3, [r4, #8]
 480 0104 1E4A     		ldr	r2, .L34+40
 481 0106 1340     		ands	r3, r2
 482 0108 A360     		str	r3, [r4, #8]
 311:../drivers/fsl_sai.c ****     }
 483              		.loc 1 311 0
 484 010a 2369     		ldr	r3, [r4, #16]
 485 010c 0122     		movs	r2, #1
 486 010e 9343     		bics	r3, r2
 487 0110 2361     		str	r3, [r4, #16]
 488 0112 BEE7     		b	.L28
 489              	.LVL54:
 490              	.L31:
 318:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 491              		.loc 1 318 0
 492 0114 A368     		ldr	r3, [r4, #8]
 493              	.LVL55:
 319:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(0U));
 494              		.loc 1 319 0
 495 0116 9B00     		lsls	r3, r3, #2
 496              	.LVL56:
 497 0118 9B08     		lsrs	r3, r3, #2
 498              	.LVL57:
 320:../drivers/fsl_sai.c ****             break;
 499              		.loc 1 320 0
 500 011a A360     		str	r3, [r4, #8]
 321:../drivers/fsl_sai.c ****         case kSAI_ModeSync:
 501              		.loc 1 321 0
 502 011c C2E7     		b	.L19
 503              	.LVL58:
 504              	.L30:
 323:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 505              		.loc 1 323 0
 506 011e A368     		ldr	r3, [r4, #8]
 507              	.LVL59:
 324:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(1U));
 508              		.loc 1 324 0
 509 0120 9B00     		lsls	r3, r3, #2
 510              	.LVL60:
 511 0122 9B08     		lsrs	r3, r3, #2
 512              	.LVL61:
 325:../drivers/fsl_sai.c ****             /* If sync with Rx, should set Rx to async mode */
 513              		.loc 1 325 0
 514 0124 8022     		movs	r2, #128
 515 0126 D205     		lsls	r2, r2, #23
 516 0128 1343     		orrs	r3, r2
 517              	.LVL62:
 518 012a A360     		str	r3, [r4, #8]
 327:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 519              		.loc 1 327 0
 520 012c 8822     		movs	r2, #136
 521 012e A358     		ldr	r3, [r4, r2]
 522              	.LVL63:
 328:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(0U));
 523              		.loc 1 328 0
 524 0130 9B00     		lsls	r3, r3, #2
 525              	.LVL64:
 526 0132 9B08     		lsrs	r3, r3, #2
 527              	.LVL65:
 329:../drivers/fsl_sai.c ****             break;
 528              		.loc 1 329 0
 529 0134 A350     		str	r3, [r4, r2]
 330:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherTx:
 530              		.loc 1 330 0
 531 0136 B5E7     		b	.L19
 532              	.LVL66:
 533              	.L32:
 332:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 534              		.loc 1 332 0
 535 0138 A368     		ldr	r3, [r4, #8]
 536              	.LVL67:
 333:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(2U));
 537              		.loc 1 333 0
 538 013a 9B00     		lsls	r3, r3, #2
 539              	.LVL68:
 540 013c 9B08     		lsrs	r3, r3, #2
 541              	.LVL69:
 334:../drivers/fsl_sai.c ****             break;
 542              		.loc 1 334 0
 543 013e 8022     		movs	r2, #128
 544 0140 1206     		lsls	r2, r2, #24
 545 0142 1343     		orrs	r3, r2
 546              	.LVL70:
 547 0144 A360     		str	r3, [r4, #8]
 335:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherRx:
 548              		.loc 1 335 0
 549 0146 ADE7     		b	.L19
 550              	.L33:
 337:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 551              		.loc 1 337 0
 552 0148 A368     		ldr	r3, [r4, #8]
 553              	.LVL71:
 338:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(3U));
 554              		.loc 1 338 0
 555 014a 9B00     		lsls	r3, r3, #2
 556              	.LVL72:
 557 014c 9B08     		lsrs	r3, r3, #2
 558              	.LVL73:
 339:../drivers/fsl_sai.c ****             break;
 559              		.loc 1 339 0
 560 014e C022     		movs	r2, #192
 561 0150 1206     		lsls	r2, r2, #24
 562 0152 1343     		orrs	r3, r2
 563              	.LVL74:
 564 0154 A360     		str	r3, [r4, #8]
 565              		.loc 1 344 0
 566 0156 A5E7     		b	.L19
 567              	.L35:
 568              		.align	2
 569              	.L34:
 570 0158 3C800440 		.word	1074036796
 571 015c FFFFFFFC 		.word	-50331649
 572 0160 FFFFFFBF 		.word	-1073741825
 573 0164 00000000 		.word	.L22
 574 0168 101F0100 		.word	73488
 575 016c FFFFFFF3 		.word	-201326593
 576 0170 1A1F0100 		.word	73498
 577 0174 FFFFFFFD 		.word	-33554433
 578 0178 18000100 		.word	65560
 579 017c 10000100 		.word	65552
 580 0180 FFFFFFFE 		.word	-16777217
 581              		.cfi_endproc
 582              	.LFE70:
 584              		.section	.text.SAI_RxInit,"ax",%progbits
 585              		.align	1
 586              		.global	SAI_RxInit
 587              		.syntax unified
 588              		.code	16
 589              		.thumb_func
 590              		.fpu softvfp
 592              	SAI_RxInit:
 593              	.LFB71:
 345:../drivers/fsl_sai.c **** 
 346:../drivers/fsl_sai.c **** void SAI_RxInit(I2S_Type *base, const sai_config_t *config)
 347:../drivers/fsl_sai.c **** {
 594              		.loc 1 347 0
 595              		.cfi_startproc
 596              		@ args = 0, pretend = 0, frame = 0
 597              		@ frame_needed = 0, uses_anonymous_args = 0
 598              	.LVL75:
 599 0000 70B5     		push	{r4, r5, r6, lr}
 600              		.cfi_def_cfa_offset 16
 601              		.cfi_offset 4, -16
 602              		.cfi_offset 5, -12
 603              		.cfi_offset 6, -8
 604              		.cfi_offset 14, -4
 605 0002 0400     		movs	r4, r0
 606 0004 0D00     		movs	r5, r1
 607              	.LVL76:
 348:../drivers/fsl_sai.c ****     uint32_t val = 0;
 349:../drivers/fsl_sai.c **** 
 350:../drivers/fsl_sai.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 351:../drivers/fsl_sai.c ****     /* Enable SAI clock first. */
 352:../drivers/fsl_sai.c ****     CLOCK_EnableClock(s_saiClock[SAI_GetInstance(base)]);
 608              		.loc 1 352 0
 609 0006 FFF7FEFF 		bl	SAI_GetInstance
 610              	.LVL77:
 611              	.LBB38:
 612              	.LBB39:
 613              		.loc 2 450 0
 614 000a 5E4A     		ldr	r2, .L51
 615 000c 1168     		ldr	r1, [r2]
 616 000e 8023     		movs	r3, #128
 617 0010 1B02     		lsls	r3, r3, #8
 618 0012 0B43     		orrs	r3, r1
 619 0014 1360     		str	r3, [r2]
 620              	.LVL78:
 621              	.LBE39:
 622              	.LBE38:
 353:../drivers/fsl_sai.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 354:../drivers/fsl_sai.c **** 
 355:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCR) && (FSL_FEATURE_SAI_HAS_MCR)
 356:../drivers/fsl_sai.c ****     /* Master clock source setting */
 357:../drivers/fsl_sai.c ****     val = (base->MCR & ~I2S_MCR_MICS_MASK);
 623              		.loc 1 357 0
 624 0016 8022     		movs	r2, #128
 625 0018 5200     		lsls	r2, r2, #1
 626 001a A358     		ldr	r3, [r4, r2]
 627 001c 5A49     		ldr	r1, .L51+4
 628 001e 1940     		ands	r1, r3
 629              	.LVL79:
 358:../drivers/fsl_sai.c ****     base->MCR = (val | I2S_MCR_MICS(config->mclkSource));
 630              		.loc 1 358 0
 631 0020 EB78     		ldrb	r3, [r5, #3]
 632 0022 1B06     		lsls	r3, r3, #24
 633 0024 C020     		movs	r0, #192
 634 0026 8004     		lsls	r0, r0, #18
 635 0028 0340     		ands	r3, r0
 636 002a 0B43     		orrs	r3, r1
 637 002c A350     		str	r3, [r4, r2]
 359:../drivers/fsl_sai.c **** 
 360:../drivers/fsl_sai.c ****     /* Configure Master clock output enable */
 361:../drivers/fsl_sai.c ****     val = (base->MCR & ~I2S_MCR_MOE_MASK);
 638              		.loc 1 361 0
 639 002e A358     		ldr	r3, [r4, r2]
 640 0030 5649     		ldr	r1, .L51+8
 641              	.LVL80:
 642 0032 1940     		ands	r1, r3
 643              	.LVL81:
 362:../drivers/fsl_sai.c ****     base->MCR = (val | I2S_MCR_MOE(config->mclkOutputEnable));
 644              		.loc 1 362 0
 645 0034 AB78     		ldrb	r3, [r5, #2]
 646 0036 9B07     		lsls	r3, r3, #30
 647 0038 8020     		movs	r0, #128
 648 003a C005     		lsls	r0, r0, #23
 649 003c 0340     		ands	r3, r0
 650 003e 0B43     		orrs	r3, r1
 651 0040 A350     		str	r3, [r4, r2]
 363:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCR */
 364:../drivers/fsl_sai.c **** 
 365:../drivers/fsl_sai.c ****     /* Configure audio protocol */
 366:../drivers/fsl_sai.c ****     switch (config->protocol)
 652              		.loc 1 366 0
 653 0042 2B78     		ldrb	r3, [r5]
 654 0044 042B     		cmp	r3, #4
 655 0046 11D8     		bhi	.L37
 656 0048 9B00     		lsls	r3, r3, #2
 657 004a 514A     		ldr	r2, .L51+12
 658 004c D358     		ldr	r3, [r2, r3]
 659 004e 9F46     		mov	pc, r3
 660              		.section	.rodata.SAI_RxInit,"a",%progbits
 661              		.align	2
 662              	.L39:
 663 0000 50000000 		.word	.L38
 664 0004 B0000000 		.word	.L40
 665 0008 CE000000 		.word	.L41
 666 000c EC000000 		.word	.L42
 667 0010 08010000 		.word	.L43
 668              		.section	.text.SAI_RxInit
 669              	.L38:
 367:../drivers/fsl_sai.c ****     {
 368:../drivers/fsl_sai.c ****         case kSAI_BusLeftJustified:
 369:../drivers/fsl_sai.c ****             base->RCR2 |= I2S_RCR2_BCP_MASK;
 670              		.loc 1 369 0
 671 0050 8822     		movs	r2, #136
 672 0052 A158     		ldr	r1, [r4, r2]
 673              	.LVL82:
 674 0054 8023     		movs	r3, #128
 675 0056 9B04     		lsls	r3, r3, #18
 676 0058 0B43     		orrs	r3, r1
 677 005a A350     		str	r3, [r4, r2]
 370:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 678              		.loc 1 370 0
 679 005c 0432     		adds	r2, r2, #4
 680 005e A358     		ldr	r3, [r4, r2]
 681 0060 0121     		movs	r1, #1
 682 0062 8B43     		bics	r3, r1
 683 0064 A350     		str	r3, [r4, r2]
 371:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(31U) | I2S_RCR4_FSE(0U) | I2S_RCR4_FSP(0U)
 684              		.loc 1 371 0
 685 0066 9023     		movs	r3, #144
 686 0068 4A4A     		ldr	r2, .L51+16
 687 006a E250     		str	r2, [r4, r3]
 688              	.L37:
 372:../drivers/fsl_sai.c ****             break;
 373:../drivers/fsl_sai.c **** 
 374:../drivers/fsl_sai.c ****         case kSAI_BusRightJustified:
 375:../drivers/fsl_sai.c ****             base->RCR2 |= I2S_RCR2_BCP_MASK;
 376:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 377:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(31U) | I2S_RCR4_FSE(0U) | I2S_RCR4_FSP(0U)
 378:../drivers/fsl_sai.c ****             break;
 379:../drivers/fsl_sai.c **** 
 380:../drivers/fsl_sai.c ****         case kSAI_BusI2S:
 381:../drivers/fsl_sai.c ****             base->RCR2 |= I2S_RCR2_BCP_MASK;
 382:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 383:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(31U) | I2S_RCR4_FSE(1U) | I2S_RCR4_FSP(1U)
 384:../drivers/fsl_sai.c ****             break;
 385:../drivers/fsl_sai.c **** 
 386:../drivers/fsl_sai.c ****         case kSAI_BusPCMA:
 387:../drivers/fsl_sai.c ****             base->RCR2 &= ~I2S_RCR2_BCP_MASK;
 388:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 389:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(0U) | I2S_RCR4_FSE(1U) | I2S_RCR4_FSP(0U) 
 390:../drivers/fsl_sai.c ****             break;
 391:../drivers/fsl_sai.c **** 
 392:../drivers/fsl_sai.c ****         case kSAI_BusPCMB:
 393:../drivers/fsl_sai.c ****             base->RCR2 &= ~I2S_RCR2_BCP_MASK;
 394:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 395:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(0U) | I2S_RCR4_FSE(0U) | I2S_RCR4_FSP(0U) 
 396:../drivers/fsl_sai.c ****             break;
 397:../drivers/fsl_sai.c **** 
 398:../drivers/fsl_sai.c ****         default:
 399:../drivers/fsl_sai.c ****             break;
 400:../drivers/fsl_sai.c ****     }
 401:../drivers/fsl_sai.c **** 
 402:../drivers/fsl_sai.c ****     /* Set master or slave */
 403:../drivers/fsl_sai.c ****     if (config->masterSlave == kSAI_Master)
 689              		.loc 1 403 0
 690 006c 6B79     		ldrb	r3, [r5, #5]
 691 006e 002B     		cmp	r3, #0
 692 0070 58D1     		bne	.L44
 404:../drivers/fsl_sai.c ****     {
 405:../drivers/fsl_sai.c ****         base->RCR2 |= I2S_RCR2_BCD_MASK;
 693              		.loc 1 405 0
 694 0072 8822     		movs	r2, #136
 695 0074 A158     		ldr	r1, [r4, r2]
 696 0076 8023     		movs	r3, #128
 697 0078 5B04     		lsls	r3, r3, #17
 698 007a 0B43     		orrs	r3, r1
 699 007c A350     		str	r3, [r4, r2]
 406:../drivers/fsl_sai.c ****         base->RCR4 |= I2S_RCR4_FSD_MASK;
 700              		.loc 1 406 0
 701 007e 9021     		movs	r1, #144
 702 0080 6358     		ldr	r3, [r4, r1]
 703 0082 0120     		movs	r0, #1
 704 0084 0343     		orrs	r3, r0
 705 0086 6350     		str	r3, [r4, r1]
 407:../drivers/fsl_sai.c **** 
 408:../drivers/fsl_sai.c ****         /* Bit clock source setting */
 409:../drivers/fsl_sai.c ****         val = base->RCR2 & (~I2S_RCR2_MSEL_MASK);
 706              		.loc 1 409 0
 707 0088 A358     		ldr	r3, [r4, r2]
 708 008a 4349     		ldr	r1, .L51+20
 709 008c 1940     		ands	r1, r3
 710              	.LVL83:
 410:../drivers/fsl_sai.c ****         base->RCR2 = (val | I2S_RCR2_MSEL(config->bclkSource));
 711              		.loc 1 410 0
 712 008e 2B79     		ldrb	r3, [r5, #4]
 713 0090 9B06     		lsls	r3, r3, #26
 714 0092 C020     		movs	r0, #192
 715 0094 0005     		lsls	r0, r0, #20
 716 0096 0340     		ands	r3, r0
 717 0098 0B43     		orrs	r3, r1
 718 009a A350     		str	r3, [r4, r2]
 719              	.LVL84:
 720              	.L45:
 411:../drivers/fsl_sai.c ****     }
 412:../drivers/fsl_sai.c ****     else
 413:../drivers/fsl_sai.c ****     {
 414:../drivers/fsl_sai.c ****         base->RCR2 &= ~I2S_RCR2_BCD_MASK;
 415:../drivers/fsl_sai.c ****         base->RCR4 &= ~I2S_RCR4_FSD_MASK;
 416:../drivers/fsl_sai.c ****     }
 417:../drivers/fsl_sai.c **** 
 418:../drivers/fsl_sai.c ****     /* Set Sync mode */
 419:../drivers/fsl_sai.c ****     switch (config->syncMode)
 721              		.loc 1 419 0
 722 009c 6B78     		ldrb	r3, [r5, #1]
 723 009e 012B     		cmp	r3, #1
 724 00a0 51D0     		beq	.L47
 725 00a2 002B     		cmp	r3, #0
 726 00a4 49D0     		beq	.L48
 727 00a6 022B     		cmp	r3, #2
 728 00a8 5AD0     		beq	.L49
 729 00aa 032B     		cmp	r3, #3
 730 00ac 61D0     		beq	.L50
 731              	.L36:
 420:../drivers/fsl_sai.c ****     {
 421:../drivers/fsl_sai.c ****         case kSAI_ModeAsync:
 422:../drivers/fsl_sai.c ****             val = base->RCR2;
 423:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 424:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(0U));
 425:../drivers/fsl_sai.c ****             break;
 426:../drivers/fsl_sai.c ****         case kSAI_ModeSync:
 427:../drivers/fsl_sai.c ****             val = base->RCR2;
 428:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 429:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(1U));
 430:../drivers/fsl_sai.c ****             /* If sync with Tx, should set Tx to async mode */
 431:../drivers/fsl_sai.c ****             val = base->TCR2;
 432:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 433:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(0U));
 434:../drivers/fsl_sai.c ****             break;
 435:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherTx:
 436:../drivers/fsl_sai.c ****             val = base->RCR2;
 437:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 438:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(2U));
 439:../drivers/fsl_sai.c ****             break;
 440:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherRx:
 441:../drivers/fsl_sai.c ****             val = base->RCR2;
 442:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 443:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(3U));
 444:../drivers/fsl_sai.c ****             break;
 445:../drivers/fsl_sai.c ****         default:
 446:../drivers/fsl_sai.c ****             break;
 447:../drivers/fsl_sai.c ****     }
 448:../drivers/fsl_sai.c **** }
 732              		.loc 1 448 0
 733              		@ sp needed
 734              	.LVL85:
 735              	.LVL86:
 736 00ae 70BD     		pop	{r4, r5, r6, pc}
 737              	.LVL87:
 738              	.L40:
 375:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 739              		.loc 1 375 0
 740 00b0 8822     		movs	r2, #136
 741 00b2 A158     		ldr	r1, [r4, r2]
 742              	.LVL88:
 743 00b4 8023     		movs	r3, #128
 744 00b6 9B04     		lsls	r3, r3, #18
 745 00b8 0B43     		orrs	r3, r1
 746 00ba A350     		str	r3, [r4, r2]
 376:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(31U) | I2S_RCR4_FSE(0U) | I2S_RCR4_FSP(0U)
 747              		.loc 1 376 0
 748 00bc 0432     		adds	r2, r2, #4
 749 00be A358     		ldr	r3, [r4, r2]
 750 00c0 0121     		movs	r1, #1
 751 00c2 8B43     		bics	r3, r1
 752 00c4 A350     		str	r3, [r4, r2]
 377:../drivers/fsl_sai.c ****             break;
 753              		.loc 1 377 0
 754 00c6 9023     		movs	r3, #144
 755 00c8 324A     		ldr	r2, .L51+16
 756 00ca E250     		str	r2, [r4, r3]
 378:../drivers/fsl_sai.c **** 
 757              		.loc 1 378 0
 758 00cc CEE7     		b	.L37
 759              	.LVL89:
 760              	.L41:
 381:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 761              		.loc 1 381 0
 762 00ce 8822     		movs	r2, #136
 763 00d0 A158     		ldr	r1, [r4, r2]
 764              	.LVL90:
 765 00d2 8023     		movs	r3, #128
 766 00d4 9B04     		lsls	r3, r3, #18
 767 00d6 0B43     		orrs	r3, r1
 768 00d8 A350     		str	r3, [r4, r2]
 382:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(31U) | I2S_RCR4_FSE(1U) | I2S_RCR4_FSP(1U)
 769              		.loc 1 382 0
 770 00da 0432     		adds	r2, r2, #4
 771 00dc A358     		ldr	r3, [r4, r2]
 772 00de 0121     		movs	r1, #1
 773 00e0 8B43     		bics	r3, r1
 774 00e2 A350     		str	r3, [r4, r2]
 383:../drivers/fsl_sai.c ****             break;
 775              		.loc 1 383 0
 776 00e4 9023     		movs	r3, #144
 777 00e6 2D4A     		ldr	r2, .L51+24
 778 00e8 E250     		str	r2, [r4, r3]
 384:../drivers/fsl_sai.c **** 
 779              		.loc 1 384 0
 780 00ea BFE7     		b	.L37
 781              	.LVL91:
 782              	.L42:
 387:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 783              		.loc 1 387 0
 784 00ec 8822     		movs	r2, #136
 785 00ee A358     		ldr	r3, [r4, r2]
 786 00f0 2B49     		ldr	r1, .L51+28
 787              	.LVL92:
 788 00f2 0B40     		ands	r3, r1
 789 00f4 A350     		str	r3, [r4, r2]
 388:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(0U) | I2S_RCR4_FSE(1U) | I2S_RCR4_FSP(0U) 
 790              		.loc 1 388 0
 791 00f6 0432     		adds	r2, r2, #4
 792 00f8 A358     		ldr	r3, [r4, r2]
 793 00fa 0121     		movs	r1, #1
 794 00fc 8B43     		bics	r3, r1
 795 00fe A350     		str	r3, [r4, r2]
 389:../drivers/fsl_sai.c ****             break;
 796              		.loc 1 389 0
 797 0100 9023     		movs	r3, #144
 798 0102 284A     		ldr	r2, .L51+32
 799 0104 E250     		str	r2, [r4, r3]
 390:../drivers/fsl_sai.c **** 
 800              		.loc 1 390 0
 801 0106 B1E7     		b	.L37
 802              	.LVL93:
 803              	.L43:
 393:../drivers/fsl_sai.c ****             base->RCR3 &= ~I2S_RCR3_WDFL_MASK;
 804              		.loc 1 393 0
 805 0108 8822     		movs	r2, #136
 806 010a A358     		ldr	r3, [r4, r2]
 807 010c 2449     		ldr	r1, .L51+28
 808              	.LVL94:
 809 010e 0B40     		ands	r3, r1
 810 0110 A350     		str	r3, [r4, r2]
 394:../drivers/fsl_sai.c ****             base->RCR4 = I2S_RCR4_MF(1U) | I2S_RCR4_SYWD(0U) | I2S_RCR4_FSE(0U) | I2S_RCR4_FSP(0U) 
 811              		.loc 1 394 0
 812 0112 0432     		adds	r2, r2, #4
 813 0114 A358     		ldr	r3, [r4, r2]
 814 0116 0121     		movs	r1, #1
 815 0118 8B43     		bics	r3, r1
 816 011a A350     		str	r3, [r4, r2]
 395:../drivers/fsl_sai.c ****             break;
 817              		.loc 1 395 0
 818 011c 9023     		movs	r3, #144
 819 011e 224A     		ldr	r2, .L51+36
 820 0120 E250     		str	r2, [r4, r3]
 396:../drivers/fsl_sai.c **** 
 821              		.loc 1 396 0
 822 0122 A3E7     		b	.L37
 823              	.L44:
 414:../drivers/fsl_sai.c ****         base->RCR4 &= ~I2S_RCR4_FSD_MASK;
 824              		.loc 1 414 0
 825 0124 8822     		movs	r2, #136
 826 0126 A358     		ldr	r3, [r4, r2]
 827 0128 2049     		ldr	r1, .L51+40
 828 012a 0B40     		ands	r3, r1
 829 012c A350     		str	r3, [r4, r2]
 415:../drivers/fsl_sai.c ****     }
 830              		.loc 1 415 0
 831 012e 0832     		adds	r2, r2, #8
 832 0130 A358     		ldr	r3, [r4, r2]
 833 0132 0121     		movs	r1, #1
 834 0134 8B43     		bics	r3, r1
 835 0136 A350     		str	r3, [r4, r2]
 836 0138 B0E7     		b	.L45
 837              	.L48:
 422:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 838              		.loc 1 422 0
 839 013a 8822     		movs	r2, #136
 840 013c A358     		ldr	r3, [r4, r2]
 841              	.LVL95:
 423:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(0U));
 842              		.loc 1 423 0
 843 013e 9B00     		lsls	r3, r3, #2
 844              	.LVL96:
 845 0140 9B08     		lsrs	r3, r3, #2
 846              	.LVL97:
 424:../drivers/fsl_sai.c ****             break;
 847              		.loc 1 424 0
 848 0142 A350     		str	r3, [r4, r2]
 425:../drivers/fsl_sai.c ****         case kSAI_ModeSync:
 849              		.loc 1 425 0
 850 0144 B3E7     		b	.L36
 851              	.LVL98:
 852              	.L47:
 427:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 853              		.loc 1 427 0
 854 0146 8821     		movs	r1, #136
 855 0148 6358     		ldr	r3, [r4, r1]
 856              	.LVL99:
 428:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(1U));
 857              		.loc 1 428 0
 858 014a 9B00     		lsls	r3, r3, #2
 859              	.LVL100:
 860 014c 9B08     		lsrs	r3, r3, #2
 861              	.LVL101:
 429:../drivers/fsl_sai.c ****             /* If sync with Tx, should set Tx to async mode */
 862              		.loc 1 429 0
 863 014e 8022     		movs	r2, #128
 864 0150 D205     		lsls	r2, r2, #23
 865 0152 1343     		orrs	r3, r2
 866              	.LVL102:
 867 0154 6350     		str	r3, [r4, r1]
 431:../drivers/fsl_sai.c ****             val &= ~I2S_TCR2_SYNC_MASK;
 868              		.loc 1 431 0
 869 0156 A368     		ldr	r3, [r4, #8]
 870              	.LVL103:
 432:../drivers/fsl_sai.c ****             base->TCR2 = (val | I2S_TCR2_SYNC(0U));
 871              		.loc 1 432 0
 872 0158 9B00     		lsls	r3, r3, #2
 873              	.LVL104:
 874 015a 9B08     		lsrs	r3, r3, #2
 875              	.LVL105:
 433:../drivers/fsl_sai.c ****             break;
 876              		.loc 1 433 0
 877 015c A360     		str	r3, [r4, #8]
 434:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherTx:
 878              		.loc 1 434 0
 879 015e A6E7     		b	.L36
 880              	.LVL106:
 881              	.L49:
 436:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 882              		.loc 1 436 0
 883 0160 8821     		movs	r1, #136
 884 0162 6358     		ldr	r3, [r4, r1]
 885              	.LVL107:
 437:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(2U));
 886              		.loc 1 437 0
 887 0164 9B00     		lsls	r3, r3, #2
 888              	.LVL108:
 889 0166 9B08     		lsrs	r3, r3, #2
 890              	.LVL109:
 438:../drivers/fsl_sai.c ****             break;
 891              		.loc 1 438 0
 892 0168 8022     		movs	r2, #128
 893 016a 1206     		lsls	r2, r2, #24
 894 016c 1343     		orrs	r3, r2
 895              	.LVL110:
 896 016e 6350     		str	r3, [r4, r1]
 439:../drivers/fsl_sai.c ****         case kSAI_ModeSyncWithOtherRx:
 897              		.loc 1 439 0
 898 0170 9DE7     		b	.L36
 899              	.L50:
 441:../drivers/fsl_sai.c ****             val &= ~I2S_RCR2_SYNC_MASK;
 900              		.loc 1 441 0
 901 0172 8821     		movs	r1, #136
 902 0174 6358     		ldr	r3, [r4, r1]
 903              	.LVL111:
 442:../drivers/fsl_sai.c ****             base->RCR2 = (val | I2S_RCR2_SYNC(3U));
 904              		.loc 1 442 0
 905 0176 9B00     		lsls	r3, r3, #2
 906              	.LVL112:
 907 0178 9B08     		lsrs	r3, r3, #2
 908              	.LVL113:
 443:../drivers/fsl_sai.c ****             break;
 909              		.loc 1 443 0
 910 017a C022     		movs	r2, #192
 911 017c 1206     		lsls	r2, r2, #24
 912 017e 1343     		orrs	r3, r2
 913              	.LVL114:
 914 0180 6350     		str	r3, [r4, r1]
 915              		.loc 1 448 0
 916 0182 94E7     		b	.L36
 917              	.L52:
 918              		.align	2
 919              	.L51:
 920 0184 3C800440 		.word	1074036796
 921 0188 FFFFFFFC 		.word	-50331649
 922 018c FFFFFFBF 		.word	-1073741825
 923 0190 00000000 		.word	.L39
 924 0194 101F0100 		.word	73488
 925 0198 FFFFFFF3 		.word	-201326593
 926 019c 1A1F0100 		.word	73498
 927 01a0 FFFFFFFD 		.word	-33554433
 928 01a4 18000100 		.word	65560
 929 01a8 10000100 		.word	65552
 930 01ac FFFFFFFE 		.word	-16777217
 931              		.cfi_endproc
 932              	.LFE71:
 934              		.section	.text.SAI_TxGetDefaultConfig,"ax",%progbits
 935              		.align	1
 936              		.global	SAI_TxGetDefaultConfig
 937              		.syntax unified
 938              		.code	16
 939              		.thumb_func
 940              		.fpu softvfp
 942              	SAI_TxGetDefaultConfig:
 943              	.LFB73:
 449:../drivers/fsl_sai.c **** 
 450:../drivers/fsl_sai.c **** void SAI_Deinit(I2S_Type *base)
 451:../drivers/fsl_sai.c **** {
 452:../drivers/fsl_sai.c ****     SAI_TxEnable(base, false);
 453:../drivers/fsl_sai.c ****     SAI_RxEnable(base, false);
 454:../drivers/fsl_sai.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 455:../drivers/fsl_sai.c ****     CLOCK_DisableClock(s_saiClock[SAI_GetInstance(base)]);
 456:../drivers/fsl_sai.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 457:../drivers/fsl_sai.c **** }
 458:../drivers/fsl_sai.c **** 
 459:../drivers/fsl_sai.c **** void SAI_TxGetDefaultConfig(sai_config_t *config)
 460:../drivers/fsl_sai.c **** {
 944              		.loc 1 460 0
 945              		.cfi_startproc
 946              		@ args = 0, pretend = 0, frame = 0
 947              		@ frame_needed = 0, uses_anonymous_args = 0
 948              		@ link register save eliminated.
 949              	.LVL115:
 461:../drivers/fsl_sai.c ****     config->bclkSource = kSAI_BclkSourceMclkDiv;
 950              		.loc 1 461 0
 951 0000 0122     		movs	r2, #1
 952 0002 0271     		strb	r2, [r0, #4]
 462:../drivers/fsl_sai.c ****     config->masterSlave = kSAI_Master;
 953              		.loc 1 462 0
 954 0004 0023     		movs	r3, #0
 955 0006 4371     		strb	r3, [r0, #5]
 463:../drivers/fsl_sai.c ****     config->mclkSource = kSAI_MclkSourceSysclk;
 956              		.loc 1 463 0
 957 0008 C370     		strb	r3, [r0, #3]
 464:../drivers/fsl_sai.c ****     config->protocol = kSAI_BusLeftJustified;
 958              		.loc 1 464 0
 959 000a 0370     		strb	r3, [r0]
 465:../drivers/fsl_sai.c ****     config->syncMode = kSAI_ModeAsync;
 960              		.loc 1 465 0
 961 000c 4370     		strb	r3, [r0, #1]
 466:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCR) && (FSL_FEATURE_SAI_HAS_MCR)
 467:../drivers/fsl_sai.c ****     config->mclkOutputEnable = true;
 962              		.loc 1 467 0
 963 000e 8270     		strb	r2, [r0, #2]
 468:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCR */
 469:../drivers/fsl_sai.c **** }
 964              		.loc 1 469 0
 965              		@ sp needed
 966 0010 7047     		bx	lr
 967              		.cfi_endproc
 968              	.LFE73:
 970              		.section	.text.SAI_RxGetDefaultConfig,"ax",%progbits
 971              		.align	1
 972              		.global	SAI_RxGetDefaultConfig
 973              		.syntax unified
 974              		.code	16
 975              		.thumb_func
 976              		.fpu softvfp
 978              	SAI_RxGetDefaultConfig:
 979              	.LFB74:
 470:../drivers/fsl_sai.c **** 
 471:../drivers/fsl_sai.c **** void SAI_RxGetDefaultConfig(sai_config_t *config)
 472:../drivers/fsl_sai.c **** {
 980              		.loc 1 472 0
 981              		.cfi_startproc
 982              		@ args = 0, pretend = 0, frame = 0
 983              		@ frame_needed = 0, uses_anonymous_args = 0
 984              		@ link register save eliminated.
 985              	.LVL116:
 473:../drivers/fsl_sai.c ****     config->bclkSource = kSAI_BclkSourceMclkDiv;
 986              		.loc 1 473 0
 987 0000 0123     		movs	r3, #1
 988 0002 0371     		strb	r3, [r0, #4]
 474:../drivers/fsl_sai.c ****     config->masterSlave = kSAI_Master;
 989              		.loc 1 474 0
 990 0004 0022     		movs	r2, #0
 991 0006 4271     		strb	r2, [r0, #5]
 475:../drivers/fsl_sai.c ****     config->mclkSource = kSAI_MclkSourceSysclk;
 992              		.loc 1 475 0
 993 0008 C270     		strb	r2, [r0, #3]
 476:../drivers/fsl_sai.c ****     config->protocol = kSAI_BusLeftJustified;
 994              		.loc 1 476 0
 995 000a 0270     		strb	r2, [r0]
 477:../drivers/fsl_sai.c ****     config->syncMode = kSAI_ModeSync;
 996              		.loc 1 477 0
 997 000c 4370     		strb	r3, [r0, #1]
 478:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCR) && (FSL_FEATURE_SAI_HAS_MCR)
 479:../drivers/fsl_sai.c ****     config->mclkOutputEnable = true;
 998              		.loc 1 479 0
 999 000e 8370     		strb	r3, [r0, #2]
 480:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCR */
 481:../drivers/fsl_sai.c **** }
 1000              		.loc 1 481 0
 1001              		@ sp needed
 1002 0010 7047     		bx	lr
 1003              		.cfi_endproc
 1004              	.LFE74:
 1006              		.section	.text.SAI_TxReset,"ax",%progbits
 1007              		.align	1
 1008              		.global	SAI_TxReset
 1009              		.syntax unified
 1010              		.code	16
 1011              		.thumb_func
 1012              		.fpu softvfp
 1014              	SAI_TxReset:
 1015              	.LFB75:
 482:../drivers/fsl_sai.c **** 
 483:../drivers/fsl_sai.c **** void SAI_TxReset(I2S_Type *base)
 484:../drivers/fsl_sai.c **** {
 1016              		.loc 1 484 0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 0
 1019              		@ frame_needed = 0, uses_anonymous_args = 0
 1020              		@ link register save eliminated.
 1021              	.LVL117:
 485:../drivers/fsl_sai.c ****     /* Set the software reset and FIFO reset to clear internal state */
 486:../drivers/fsl_sai.c ****     base->TCSR = I2S_TCSR_SR_MASK | I2S_TCSR_FR_MASK;
 1022              		.loc 1 486 0
 1023 0000 C023     		movs	r3, #192
 1024 0002 9B04     		lsls	r3, r3, #18
 1025 0004 0360     		str	r3, [r0]
 487:../drivers/fsl_sai.c **** 
 488:../drivers/fsl_sai.c ****     /* Clear software reset bit, this should be done by software */
 489:../drivers/fsl_sai.c ****     base->TCSR &= ~I2S_TCSR_SR_MASK;
 1026              		.loc 1 489 0
 1027 0006 0368     		ldr	r3, [r0]
 1028 0008 044A     		ldr	r2, .L56
 1029 000a 1340     		ands	r3, r2
 1030 000c 0360     		str	r3, [r0]
 490:../drivers/fsl_sai.c **** 
 491:../drivers/fsl_sai.c ****     /* Reset all Tx register values */
 492:../drivers/fsl_sai.c ****     base->TCR2 = 0;
 1031              		.loc 1 492 0
 1032 000e 0023     		movs	r3, #0
 1033 0010 8360     		str	r3, [r0, #8]
 493:../drivers/fsl_sai.c ****     base->TCR3 = 0;
 1034              		.loc 1 493 0
 1035 0012 C360     		str	r3, [r0, #12]
 494:../drivers/fsl_sai.c ****     base->TCR4 = 0;
 1036              		.loc 1 494 0
 1037 0014 0361     		str	r3, [r0, #16]
 495:../drivers/fsl_sai.c ****     base->TCR5 = 0;
 1038              		.loc 1 495 0
 1039 0016 4361     		str	r3, [r0, #20]
 496:../drivers/fsl_sai.c ****     base->TMR = 0;
 1040              		.loc 1 496 0
 1041 0018 0366     		str	r3, [r0, #96]
 497:../drivers/fsl_sai.c **** }
 1042              		.loc 1 497 0
 1043              		@ sp needed
 1044 001a 7047     		bx	lr
 1045              	.L57:
 1046              		.align	2
 1047              	.L56:
 1048 001c FFFFFFFE 		.word	-16777217
 1049              		.cfi_endproc
 1050              	.LFE75:
 1052              		.section	.text.SAI_RxReset,"ax",%progbits
 1053              		.align	1
 1054              		.global	SAI_RxReset
 1055              		.syntax unified
 1056              		.code	16
 1057              		.thumb_func
 1058              		.fpu softvfp
 1060              	SAI_RxReset:
 1061              	.LFB76:
 498:../drivers/fsl_sai.c **** 
 499:../drivers/fsl_sai.c **** void SAI_RxReset(I2S_Type *base)
 500:../drivers/fsl_sai.c **** {
 1062              		.loc 1 500 0
 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 0
 1065              		@ frame_needed = 0, uses_anonymous_args = 0
 1066              		@ link register save eliminated.
 1067              	.LVL118:
 501:../drivers/fsl_sai.c ****     /* Set the software reset and FIFO reset to clear internal state */
 502:../drivers/fsl_sai.c ****     base->RCSR = I2S_RCSR_SR_MASK | I2S_RCSR_FR_MASK;
 1068              		.loc 1 502 0
 1069 0000 8023     		movs	r3, #128
 1070 0002 C022     		movs	r2, #192
 1071 0004 9204     		lsls	r2, r2, #18
 1072 0006 C250     		str	r2, [r0, r3]
 503:../drivers/fsl_sai.c **** 
 504:../drivers/fsl_sai.c ****     /* Clear software reset bit, this should be done by software */
 505:../drivers/fsl_sai.c ****     base->RCSR &= ~I2S_RCSR_SR_MASK;
 1073              		.loc 1 505 0
 1074 0008 C258     		ldr	r2, [r0, r3]
 1075 000a 0749     		ldr	r1, .L59
 1076 000c 0A40     		ands	r2, r1
 1077 000e C250     		str	r2, [r0, r3]
 506:../drivers/fsl_sai.c **** 
 507:../drivers/fsl_sai.c ****     /* Reset all Rx register values */
 508:../drivers/fsl_sai.c ****     base->RCR2 = 0;
 1078              		.loc 1 508 0
 1079 0010 0023     		movs	r3, #0
 1080 0012 8822     		movs	r2, #136
 1081 0014 8350     		str	r3, [r0, r2]
 509:../drivers/fsl_sai.c ****     base->RCR3 = 0;
 1082              		.loc 1 509 0
 1083 0016 0432     		adds	r2, r2, #4
 1084 0018 8350     		str	r3, [r0, r2]
 510:../drivers/fsl_sai.c ****     base->RCR4 = 0;
 1085              		.loc 1 510 0
 1086 001a 0432     		adds	r2, r2, #4
 1087 001c 8350     		str	r3, [r0, r2]
 511:../drivers/fsl_sai.c ****     base->RCR5 = 0;
 1088              		.loc 1 511 0
 1089 001e 0432     		adds	r2, r2, #4
 1090 0020 8350     		str	r3, [r0, r2]
 512:../drivers/fsl_sai.c ****     base->RMR = 0;
 1091              		.loc 1 512 0
 1092 0022 4C32     		adds	r2, r2, #76
 1093 0024 8350     		str	r3, [r0, r2]
 513:../drivers/fsl_sai.c **** }
 1094              		.loc 1 513 0
 1095              		@ sp needed
 1096 0026 7047     		bx	lr
 1097              	.L60:
 1098              		.align	2
 1099              	.L59:
 1100 0028 FFFFFFFE 		.word	-16777217
 1101              		.cfi_endproc
 1102              	.LFE76:
 1104              		.section	.text.SAI_TxEnable,"ax",%progbits
 1105              		.align	1
 1106              		.global	SAI_TxEnable
 1107              		.syntax unified
 1108              		.code	16
 1109              		.thumb_func
 1110              		.fpu softvfp
 1112              	SAI_TxEnable:
 1113              	.LFB77:
 514:../drivers/fsl_sai.c **** 
 515:../drivers/fsl_sai.c **** void SAI_TxEnable(I2S_Type *base, bool enable)
 516:../drivers/fsl_sai.c **** {
 1114              		.loc 1 516 0
 1115              		.cfi_startproc
 1116              		@ args = 0, pretend = 0, frame = 0
 1117              		@ frame_needed = 0, uses_anonymous_args = 0
 1118              		@ link register save eliminated.
 1119              	.LVL119:
 517:../drivers/fsl_sai.c ****     if (enable)
 1120              		.loc 1 517 0
 1121 0000 0029     		cmp	r1, #0
 1122 0002 1BD0     		beq	.L62
 518:../drivers/fsl_sai.c ****     {
 519:../drivers/fsl_sai.c ****         /* If clock is sync with Rx, should enable RE bit. */
 520:../drivers/fsl_sai.c ****         if (((base->TCR2 & I2S_TCR2_SYNC_MASK) >> I2S_TCR2_SYNC_SHIFT) == 0x1U)
 1123              		.loc 1 520 0
 1124 0004 8368     		ldr	r3, [r0, #8]
 1125 0006 9B0F     		lsrs	r3, r3, #30
 1126 0008 012B     		cmp	r3, #1
 1127 000a 0ED0     		beq	.L65
 1128              	.LVL120:
 1129              	.L63:
 521:../drivers/fsl_sai.c ****         {
 522:../drivers/fsl_sai.c ****             base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | I2S_RCSR_RE_MASK);
 523:../drivers/fsl_sai.c ****         }
 524:../drivers/fsl_sai.c ****         base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | I2S_TCSR_TE_MASK);
 1130              		.loc 1 524 0
 1131 000c 0368     		ldr	r3, [r0]
 1132 000e 104A     		ldr	r2, .L66
 1133 0010 1A40     		ands	r2, r3
 1134 0012 8023     		movs	r3, #128
 1135 0014 1B06     		lsls	r3, r3, #24
 1136 0016 1343     		orrs	r3, r2
 1137 0018 0360     		str	r3, [r0]
 1138              	.LVL121:
 1139              	.LBB40:
 1140              	.LBB41:
 1141              		.file 3 "../drivers/fsl_sai.h"
   1:../drivers/fsl_sai.h **** /*
   2:../drivers/fsl_sai.h ****  * The Clear BSD License
   3:../drivers/fsl_sai.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_sai.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_sai.h ****  * All rights reserved.
   6:../drivers/fsl_sai.h ****  *
   7:../drivers/fsl_sai.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_sai.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_sai.h ****  * that the following conditions are met:
  10:../drivers/fsl_sai.h ****  *
  11:../drivers/fsl_sai.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_sai.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_sai.h ****  *
  14:../drivers/fsl_sai.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_sai.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_sai.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_sai.h ****  *
  18:../drivers/fsl_sai.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_sai.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_sai.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_sai.h ****  *
  22:../drivers/fsl_sai.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_sai.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_sai.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_sai.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_sai.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_sai.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_sai.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_sai.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_sai.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_sai.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_sai.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_sai.h ****  */
  34:../drivers/fsl_sai.h **** 
  35:../drivers/fsl_sai.h **** #ifndef _FSL_SAI_H_
  36:../drivers/fsl_sai.h **** #define _FSL_SAI_H_
  37:../drivers/fsl_sai.h **** 
  38:../drivers/fsl_sai.h **** #include "fsl_common.h"
  39:../drivers/fsl_sai.h **** 
  40:../drivers/fsl_sai.h **** /*!
  41:../drivers/fsl_sai.h ****  * @addtogroup sai
  42:../drivers/fsl_sai.h ****  * @{
  43:../drivers/fsl_sai.h ****  */
  44:../drivers/fsl_sai.h **** 
  45:../drivers/fsl_sai.h **** /*******************************************************************************
  46:../drivers/fsl_sai.h ****  * Definitions
  47:../drivers/fsl_sai.h ****  ******************************************************************************/
  48:../drivers/fsl_sai.h **** 
  49:../drivers/fsl_sai.h **** /*! @name Driver version */
  50:../drivers/fsl_sai.h **** /*@{*/
  51:../drivers/fsl_sai.h **** #define FSL_SAI_DRIVER_VERSION (MAKE_VERSION(2, 1, 3)) /*!< Version 2.1.3 */
  52:../drivers/fsl_sai.h **** /*@}*/
  53:../drivers/fsl_sai.h **** 
  54:../drivers/fsl_sai.h **** /*! @brief SAI return status*/
  55:../drivers/fsl_sai.h **** enum _sai_status_t
  56:../drivers/fsl_sai.h **** {
  57:../drivers/fsl_sai.h ****     kStatus_SAI_TxBusy = MAKE_STATUS(kStatusGroup_SAI, 0),    /*!< SAI Tx is busy. */
  58:../drivers/fsl_sai.h ****     kStatus_SAI_RxBusy = MAKE_STATUS(kStatusGroup_SAI, 1),    /*!< SAI Rx is busy. */
  59:../drivers/fsl_sai.h ****     kStatus_SAI_TxError = MAKE_STATUS(kStatusGroup_SAI, 2),   /*!< SAI Tx FIFO error. */
  60:../drivers/fsl_sai.h ****     kStatus_SAI_RxError = MAKE_STATUS(kStatusGroup_SAI, 3),   /*!< SAI Rx FIFO error. */
  61:../drivers/fsl_sai.h ****     kStatus_SAI_QueueFull = MAKE_STATUS(kStatusGroup_SAI, 4), /*!< SAI transfer queue is full. */
  62:../drivers/fsl_sai.h ****     kStatus_SAI_TxIdle = MAKE_STATUS(kStatusGroup_SAI, 5),    /*!< SAI Tx is idle */
  63:../drivers/fsl_sai.h ****     kStatus_SAI_RxIdle = MAKE_STATUS(kStatusGroup_SAI, 6)     /*!< SAI Rx is idle */
  64:../drivers/fsl_sai.h **** };
  65:../drivers/fsl_sai.h **** 
  66:../drivers/fsl_sai.h **** /*! @brief Define the SAI bus type */
  67:../drivers/fsl_sai.h **** typedef enum _sai_protocol
  68:../drivers/fsl_sai.h **** {
  69:../drivers/fsl_sai.h ****     kSAI_BusLeftJustified = 0x0U, /*!< Uses left justified format.*/
  70:../drivers/fsl_sai.h ****     kSAI_BusRightJustified,       /*!< Uses right justified format. */
  71:../drivers/fsl_sai.h ****     kSAI_BusI2S,                  /*!< Uses I2S format. */
  72:../drivers/fsl_sai.h ****     kSAI_BusPCMA,                 /*!< Uses I2S PCM A format.*/
  73:../drivers/fsl_sai.h ****     kSAI_BusPCMB                  /*!< Uses I2S PCM B format. */
  74:../drivers/fsl_sai.h **** } sai_protocol_t;
  75:../drivers/fsl_sai.h **** 
  76:../drivers/fsl_sai.h **** /*! @brief Master or slave mode */
  77:../drivers/fsl_sai.h **** typedef enum _sai_master_slave
  78:../drivers/fsl_sai.h **** {
  79:../drivers/fsl_sai.h ****     kSAI_Master = 0x0U, /*!< Master mode */
  80:../drivers/fsl_sai.h ****     kSAI_Slave = 0x1U   /*!< Slave mode */
  81:../drivers/fsl_sai.h **** } sai_master_slave_t;
  82:../drivers/fsl_sai.h **** 
  83:../drivers/fsl_sai.h **** /*! @brief Mono or stereo audio format */
  84:../drivers/fsl_sai.h **** typedef enum _sai_mono_stereo
  85:../drivers/fsl_sai.h **** {
  86:../drivers/fsl_sai.h ****     kSAI_Stereo = 0x0U, /*!< Stereo sound. */
  87:../drivers/fsl_sai.h ****     kSAI_MonoRight,     /*!< Only Right channel have sound. */
  88:../drivers/fsl_sai.h ****     kSAI_MonoLeft       /*!< Only left channel have sound. */
  89:../drivers/fsl_sai.h **** } sai_mono_stereo_t;
  90:../drivers/fsl_sai.h **** 
  91:../drivers/fsl_sai.h **** /*! @brief Synchronous or asynchronous mode */
  92:../drivers/fsl_sai.h **** typedef enum _sai_sync_mode
  93:../drivers/fsl_sai.h **** {
  94:../drivers/fsl_sai.h ****     kSAI_ModeAsync = 0x0U,    /*!< Asynchronous mode */
  95:../drivers/fsl_sai.h ****     kSAI_ModeSync,            /*!< Synchronous mode (with receiver or transmit) */
  96:../drivers/fsl_sai.h ****     kSAI_ModeSyncWithOtherTx, /*!< Synchronous with another SAI transmit */
  97:../drivers/fsl_sai.h ****     kSAI_ModeSyncWithOtherRx  /*!< Synchronous with another SAI receiver */
  98:../drivers/fsl_sai.h **** } sai_sync_mode_t;
  99:../drivers/fsl_sai.h **** 
 100:../drivers/fsl_sai.h **** /*! @brief Mater clock source */
 101:../drivers/fsl_sai.h **** typedef enum _sai_mclk_source
 102:../drivers/fsl_sai.h **** {
 103:../drivers/fsl_sai.h ****     kSAI_MclkSourceSysclk = 0x0U, /*!< Master clock from the system clock */
 104:../drivers/fsl_sai.h ****     kSAI_MclkSourceSelect1,       /*!< Master clock from source 1 */
 105:../drivers/fsl_sai.h ****     kSAI_MclkSourceSelect2,       /*!< Master clock from source 2 */
 106:../drivers/fsl_sai.h ****     kSAI_MclkSourceSelect3        /*!< Master clock from source 3 */
 107:../drivers/fsl_sai.h **** } sai_mclk_source_t;
 108:../drivers/fsl_sai.h **** 
 109:../drivers/fsl_sai.h **** /*! @brief Bit clock source */
 110:../drivers/fsl_sai.h **** typedef enum _sai_bclk_source
 111:../drivers/fsl_sai.h **** {
 112:../drivers/fsl_sai.h ****     kSAI_BclkSourceBusclk = 0x0U, /*!< Bit clock using bus clock */
 113:../drivers/fsl_sai.h ****     kSAI_BclkSourceMclkDiv,       /*!< Bit clock using master clock divider */
 114:../drivers/fsl_sai.h ****     kSAI_BclkSourceOtherSai0,     /*!< Bit clock from other SAI device  */
 115:../drivers/fsl_sai.h ****     kSAI_BclkSourceOtherSai1      /*!< Bit clock from other SAI device */
 116:../drivers/fsl_sai.h **** } sai_bclk_source_t;
 117:../drivers/fsl_sai.h **** 
 118:../drivers/fsl_sai.h **** /*! @brief The SAI interrupt enable flag */
 119:../drivers/fsl_sai.h **** enum _sai_interrupt_enable_t
 120:../drivers/fsl_sai.h **** {
 121:../drivers/fsl_sai.h ****     kSAI_WordStartInterruptEnable =
 122:../drivers/fsl_sai.h ****         I2S_TCSR_WSIE_MASK, /*!< Word start flag, means the first word in a frame detected */
 123:../drivers/fsl_sai.h ****     kSAI_SyncErrorInterruptEnable = I2S_TCSR_SEIE_MASK,   /*!< Sync error flag, means the sync erro
 124:../drivers/fsl_sai.h ****     kSAI_FIFOWarningInterruptEnable = I2S_TCSR_FWIE_MASK, /*!< FIFO warning flag, means the FIFO is
 125:../drivers/fsl_sai.h ****     kSAI_FIFOErrorInterruptEnable = I2S_TCSR_FEIE_MASK,   /*!< FIFO error flag */
 126:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 127:../drivers/fsl_sai.h ****     kSAI_FIFORequestInterruptEnable = I2S_TCSR_FRIE_MASK, /*!< FIFO request, means reached watermar
 128:../drivers/fsl_sai.h **** #endif                                                    /* FSL_FEATURE_SAI_FIFO_COUNT */
 129:../drivers/fsl_sai.h **** };
 130:../drivers/fsl_sai.h **** 
 131:../drivers/fsl_sai.h **** /*! @brief The DMA request sources */
 132:../drivers/fsl_sai.h **** enum _sai_dma_enable_t
 133:../drivers/fsl_sai.h **** {
 134:../drivers/fsl_sai.h ****     kSAI_FIFOWarningDMAEnable = I2S_TCSR_FWDE_MASK, /*!< FIFO warning caused by the DMA request */
 135:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 136:../drivers/fsl_sai.h ****     kSAI_FIFORequestDMAEnable = I2S_TCSR_FRDE_MASK, /*!< FIFO request caused by the DMA request */
 137:../drivers/fsl_sai.h **** #endif                                              /* FSL_FEATURE_SAI_FIFO_COUNT */
 138:../drivers/fsl_sai.h **** };
 139:../drivers/fsl_sai.h **** 
 140:../drivers/fsl_sai.h **** /*! @brief The SAI status flag */
 141:../drivers/fsl_sai.h **** enum _sai_flags
 142:../drivers/fsl_sai.h **** {
 143:../drivers/fsl_sai.h ****     kSAI_WordStartFlag = I2S_TCSR_WSF_MASK, /*!< Word start flag, means the first word in a frame d
 144:../drivers/fsl_sai.h ****     kSAI_SyncErrorFlag = I2S_TCSR_SEF_MASK, /*!< Sync error flag, means the sync error is detected 
 145:../drivers/fsl_sai.h ****     kSAI_FIFOErrorFlag = I2S_TCSR_FEF_MASK, /*!< FIFO error flag */
 146:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 147:../drivers/fsl_sai.h ****     kSAI_FIFORequestFlag = I2S_TCSR_FRF_MASK, /*!< FIFO request flag. */
 148:../drivers/fsl_sai.h **** #endif                                        /* FSL_FEATURE_SAI_FIFO_COUNT */
 149:../drivers/fsl_sai.h ****     kSAI_FIFOWarningFlag = I2S_TCSR_FWF_MASK, /*!< FIFO warning flag */
 150:../drivers/fsl_sai.h **** };
 151:../drivers/fsl_sai.h **** 
 152:../drivers/fsl_sai.h **** /*! @brief The reset type */
 153:../drivers/fsl_sai.h **** typedef enum _sai_reset_type
 154:../drivers/fsl_sai.h **** {
 155:../drivers/fsl_sai.h ****     kSAI_ResetTypeSoftware = I2S_TCSR_SR_MASK,          /*!< Software reset, reset the logic state 
 156:../drivers/fsl_sai.h ****     kSAI_ResetTypeFIFO = I2S_TCSR_FR_MASK,              /*!< FIFO reset, reset the FIFO read and wr
 157:../drivers/fsl_sai.h ****     kSAI_ResetAll = I2S_TCSR_SR_MASK | I2S_TCSR_FR_MASK /*!< All reset. */
 158:../drivers/fsl_sai.h **** } sai_reset_type_t;
 159:../drivers/fsl_sai.h **** 
 160:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_HAS_FIFO_PACKING) && FSL_FEATURE_SAI_HAS_FIFO_PACKING
 161:../drivers/fsl_sai.h **** /*!
 162:../drivers/fsl_sai.h ****  * @brief The SAI packing mode
 163:../drivers/fsl_sai.h ****  * The mode includes 8 bit and 16 bit packing.
 164:../drivers/fsl_sai.h ****  */
 165:../drivers/fsl_sai.h **** typedef enum _sai_fifo_packing
 166:../drivers/fsl_sai.h **** {
 167:../drivers/fsl_sai.h ****     kSAI_FifoPackingDisabled = 0x0U, /*!< Packing disabled */
 168:../drivers/fsl_sai.h ****     kSAI_FifoPacking8bit = 0x2U,     /*!< 8 bit packing enabled */
 169:../drivers/fsl_sai.h ****     kSAI_FifoPacking16bit = 0x3U     /*!< 16bit packing enabled */
 170:../drivers/fsl_sai.h **** } sai_fifo_packing_t;
 171:../drivers/fsl_sai.h **** #endif /* FSL_FEATURE_SAI_HAS_FIFO_PACKING */
 172:../drivers/fsl_sai.h **** 
 173:../drivers/fsl_sai.h **** /*! @brief SAI user configuration structure */
 174:../drivers/fsl_sai.h **** typedef struct _sai_config
 175:../drivers/fsl_sai.h **** {
 176:../drivers/fsl_sai.h ****     sai_protocol_t protocol;  /*!< Audio bus protocol in SAI */
 177:../drivers/fsl_sai.h ****     sai_sync_mode_t syncMode; /*!< SAI sync mode, control Tx/Rx clock sync */
 178:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_HAS_MCR) && (FSL_FEATURE_SAI_HAS_MCR)
 179:../drivers/fsl_sai.h ****     bool mclkOutputEnable;          /*!< Master clock output enable, true means master clock divide
 180:../drivers/fsl_sai.h **** #endif                              /* FSL_FEATURE_SAI_HAS_MCR */
 181:../drivers/fsl_sai.h ****     sai_mclk_source_t mclkSource;   /*!< Master Clock source */
 182:../drivers/fsl_sai.h ****     sai_bclk_source_t bclkSource;   /*!< Bit Clock source */
 183:../drivers/fsl_sai.h ****     sai_master_slave_t masterSlave; /*!< Master or slave */
 184:../drivers/fsl_sai.h **** } sai_config_t;
 185:../drivers/fsl_sai.h **** 
 186:../drivers/fsl_sai.h **** /*!@brief SAI transfer queue size, user can refine it according to use case. */
 187:../drivers/fsl_sai.h **** #define SAI_XFER_QUEUE_SIZE (4)
 188:../drivers/fsl_sai.h **** 
 189:../drivers/fsl_sai.h **** /*! @brief Audio sample rate */
 190:../drivers/fsl_sai.h **** typedef enum _sai_sample_rate
 191:../drivers/fsl_sai.h **** {
 192:../drivers/fsl_sai.h ****     kSAI_SampleRate8KHz = 8000U,     /*!< Sample rate 8000 Hz */
 193:../drivers/fsl_sai.h ****     kSAI_SampleRate11025Hz = 11025U, /*!< Sample rate 11025 Hz */
 194:../drivers/fsl_sai.h ****     kSAI_SampleRate12KHz = 12000U,   /*!< Sample rate 12000 Hz */
 195:../drivers/fsl_sai.h ****     kSAI_SampleRate16KHz = 16000U,   /*!< Sample rate 16000 Hz */
 196:../drivers/fsl_sai.h ****     kSAI_SampleRate22050Hz = 22050U, /*!< Sample rate 22050 Hz */
 197:../drivers/fsl_sai.h ****     kSAI_SampleRate24KHz = 24000U,   /*!< Sample rate 24000 Hz */
 198:../drivers/fsl_sai.h ****     kSAI_SampleRate32KHz = 32000U,   /*!< Sample rate 32000 Hz */
 199:../drivers/fsl_sai.h ****     kSAI_SampleRate44100Hz = 44100U, /*!< Sample rate 44100 Hz */
 200:../drivers/fsl_sai.h ****     kSAI_SampleRate48KHz = 48000U,   /*!< Sample rate 48000 Hz */
 201:../drivers/fsl_sai.h ****     kSAI_SampleRate96KHz = 96000U    /*!< Sample rate 96000 Hz */
 202:../drivers/fsl_sai.h **** } sai_sample_rate_t;
 203:../drivers/fsl_sai.h **** 
 204:../drivers/fsl_sai.h **** /*! @brief Audio word width */
 205:../drivers/fsl_sai.h **** typedef enum _sai_word_width
 206:../drivers/fsl_sai.h **** {
 207:../drivers/fsl_sai.h ****     kSAI_WordWidth8bits = 8U,   /*!< Audio data width 8 bits */
 208:../drivers/fsl_sai.h ****     kSAI_WordWidth16bits = 16U, /*!< Audio data width 16 bits */
 209:../drivers/fsl_sai.h ****     kSAI_WordWidth24bits = 24U, /*!< Audio data width 24 bits */
 210:../drivers/fsl_sai.h ****     kSAI_WordWidth32bits = 32U  /*!< Audio data width 32 bits */
 211:../drivers/fsl_sai.h **** } sai_word_width_t;
 212:../drivers/fsl_sai.h **** 
 213:../drivers/fsl_sai.h **** /*! @brief sai transfer format */
 214:../drivers/fsl_sai.h **** typedef struct _sai_transfer_format
 215:../drivers/fsl_sai.h **** {
 216:../drivers/fsl_sai.h ****     uint32_t sampleRate_Hz;   /*!< Sample rate of audio data */
 217:../drivers/fsl_sai.h ****     uint32_t bitWidth;        /*!< Data length of audio data, usually 8/16/24/32 bits */
 218:../drivers/fsl_sai.h ****     sai_mono_stereo_t stereo; /*!< Mono or stereo */
 219:../drivers/fsl_sai.h ****     uint32_t masterClockHz;   /*!< Master clock frequency in Hz */
 220:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 221:../drivers/fsl_sai.h ****     uint8_t watermark;       /*!< Watermark value */
 222:../drivers/fsl_sai.h **** #endif                       /* FSL_FEATURE_SAI_FIFO_COUNT */
 223:../drivers/fsl_sai.h ****     uint8_t channel;         /*!< Data channel used in transfer.*/
 224:../drivers/fsl_sai.h ****     sai_protocol_t protocol; /*!< Which audio protocol used */
 225:../drivers/fsl_sai.h ****     bool isFrameSyncCompact; /*!< True means Frame sync length is configurable according to bitWidt
 226:../drivers/fsl_sai.h ****                                 sync length is 64 times of bit clock. */
 227:../drivers/fsl_sai.h **** } sai_transfer_format_t;
 228:../drivers/fsl_sai.h **** 
 229:../drivers/fsl_sai.h **** /*! @brief SAI transfer structure */
 230:../drivers/fsl_sai.h **** typedef struct _sai_transfer
 231:../drivers/fsl_sai.h **** {
 232:../drivers/fsl_sai.h ****     uint8_t *data;   /*!< Data start address to transfer. */
 233:../drivers/fsl_sai.h ****     size_t dataSize; /*!< Transfer size. */
 234:../drivers/fsl_sai.h **** } sai_transfer_t;
 235:../drivers/fsl_sai.h **** 
 236:../drivers/fsl_sai.h **** typedef struct _sai_handle sai_handle_t;
 237:../drivers/fsl_sai.h **** 
 238:../drivers/fsl_sai.h **** /*! @brief SAI transfer callback prototype */
 239:../drivers/fsl_sai.h **** typedef void (*sai_transfer_callback_t)(I2S_Type *base, sai_handle_t *handle, status_t status, void
 240:../drivers/fsl_sai.h **** 
 241:../drivers/fsl_sai.h **** /*! @brief SAI handle structure */
 242:../drivers/fsl_sai.h **** struct _sai_handle
 243:../drivers/fsl_sai.h **** {
 244:../drivers/fsl_sai.h ****     uint32_t state;                               /*!< Transfer status */
 245:../drivers/fsl_sai.h ****     sai_transfer_callback_t callback;             /*!< Callback function called at transfer event*/
 246:../drivers/fsl_sai.h ****     void *userData;                               /*!< Callback parameter passed to callback functi
 247:../drivers/fsl_sai.h ****     uint8_t bitWidth;                             /*!< Bit width for transfer, 8/16/24/32 bits */
 248:../drivers/fsl_sai.h ****     uint8_t channel;                              /*!< Transfer channel */
 249:../drivers/fsl_sai.h ****     sai_transfer_t saiQueue[SAI_XFER_QUEUE_SIZE]; /*!< Transfer queue storing queued transfer */
 250:../drivers/fsl_sai.h ****     size_t transferSize[SAI_XFER_QUEUE_SIZE];     /*!< Data bytes need to transfer */
 251:../drivers/fsl_sai.h ****     volatile uint8_t queueUser;                   /*!< Index for user to queue transfer */
 252:../drivers/fsl_sai.h ****     volatile uint8_t queueDriver;                 /*!< Index for driver to get the transfer data an
 253:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 254:../drivers/fsl_sai.h ****     uint8_t watermark; /*!< Watermark value */
 255:../drivers/fsl_sai.h **** #endif
 256:../drivers/fsl_sai.h **** };
 257:../drivers/fsl_sai.h **** 
 258:../drivers/fsl_sai.h **** /*******************************************************************************
 259:../drivers/fsl_sai.h ****  * API
 260:../drivers/fsl_sai.h ****  ******************************************************************************/
 261:../drivers/fsl_sai.h **** 
 262:../drivers/fsl_sai.h **** #if defined(__cplusplus)
 263:../drivers/fsl_sai.h **** extern "C" {
 264:../drivers/fsl_sai.h **** #endif /*_cplusplus*/
 265:../drivers/fsl_sai.h **** 
 266:../drivers/fsl_sai.h **** /*!
 267:../drivers/fsl_sai.h ****  * @name Initialization and deinitialization
 268:../drivers/fsl_sai.h ****  * @{
 269:../drivers/fsl_sai.h ****  */
 270:../drivers/fsl_sai.h **** 
 271:../drivers/fsl_sai.h **** /*!
 272:../drivers/fsl_sai.h ****  * @brief Initializes the SAI Tx peripheral.
 273:../drivers/fsl_sai.h ****  *
 274:../drivers/fsl_sai.h ****  * Ungates the SAI clock, resets the module, and configures SAI Tx with a configuration structure.
 275:../drivers/fsl_sai.h ****  * The configuration structure can be custom filled or set with default values by
 276:../drivers/fsl_sai.h ****  * SAI_TxGetDefaultConfig().
 277:../drivers/fsl_sai.h ****  *
 278:../drivers/fsl_sai.h ****  * @note  This API should be called at the beginning of the application to use
 279:../drivers/fsl_sai.h ****  * the SAI driver. Otherwise, accessing the SAIM module can cause a hard fault
 280:../drivers/fsl_sai.h ****  * because the clock is not enabled.
 281:../drivers/fsl_sai.h ****  *
 282:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 283:../drivers/fsl_sai.h ****  * @param config SAI configuration structure.
 284:../drivers/fsl_sai.h **** */
 285:../drivers/fsl_sai.h **** void SAI_TxInit(I2S_Type *base, const sai_config_t *config);
 286:../drivers/fsl_sai.h **** 
 287:../drivers/fsl_sai.h **** /*!
 288:../drivers/fsl_sai.h ****  * @brief Initializes the the SAI Rx peripheral.
 289:../drivers/fsl_sai.h ****  *
 290:../drivers/fsl_sai.h ****  * Ungates the SAI clock, resets the module, and configures the SAI Rx with a configuration structu
 291:../drivers/fsl_sai.h ****  * The configuration structure can be custom filled or set with default values by
 292:../drivers/fsl_sai.h ****  * SAI_RxGetDefaultConfig().
 293:../drivers/fsl_sai.h ****  *
 294:../drivers/fsl_sai.h ****  * @note  This API should be called at the beginning of the application to use
 295:../drivers/fsl_sai.h ****  * the SAI driver. Otherwise, accessing the SAI module can cause a hard fault
 296:../drivers/fsl_sai.h ****  * because the clock is not enabled.
 297:../drivers/fsl_sai.h ****  *
 298:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 299:../drivers/fsl_sai.h ****  * @param config SAI configuration structure.
 300:../drivers/fsl_sai.h ****  */
 301:../drivers/fsl_sai.h **** void SAI_RxInit(I2S_Type *base, const sai_config_t *config);
 302:../drivers/fsl_sai.h **** 
 303:../drivers/fsl_sai.h **** /*!
 304:../drivers/fsl_sai.h ****  * @brief  Sets the SAI Tx configuration structure to default values.
 305:../drivers/fsl_sai.h ****  *
 306:../drivers/fsl_sai.h ****  * This API initializes the configuration structure for use in SAI_TxConfig().
 307:../drivers/fsl_sai.h ****  * The initialized structure can remain unchanged in SAI_TxConfig(), or it can be modified
 308:../drivers/fsl_sai.h ****  *  before calling SAI_TxConfig().
 309:../drivers/fsl_sai.h ****  * This is an example.
 310:../drivers/fsl_sai.h ****    @code
 311:../drivers/fsl_sai.h ****    sai_config_t config;
 312:../drivers/fsl_sai.h ****    SAI_TxGetDefaultConfig(&config);
 313:../drivers/fsl_sai.h ****    @endcode
 314:../drivers/fsl_sai.h ****  *
 315:../drivers/fsl_sai.h ****  * @param config pointer to master configuration structure
 316:../drivers/fsl_sai.h ****  */
 317:../drivers/fsl_sai.h **** void SAI_TxGetDefaultConfig(sai_config_t *config);
 318:../drivers/fsl_sai.h **** 
 319:../drivers/fsl_sai.h **** /*!
 320:../drivers/fsl_sai.h ****  * @brief  Sets the SAI Rx configuration structure to default values.
 321:../drivers/fsl_sai.h ****  *
 322:../drivers/fsl_sai.h ****  * This API initializes the configuration structure for use in SAI_RxConfig().
 323:../drivers/fsl_sai.h ****  * The initialized structure can remain unchanged in SAI_RxConfig() or it can be modified
 324:../drivers/fsl_sai.h ****  *  before calling SAI_RxConfig().
 325:../drivers/fsl_sai.h ****  * This is an example.
 326:../drivers/fsl_sai.h ****    @code
 327:../drivers/fsl_sai.h ****    sai_config_t config;
 328:../drivers/fsl_sai.h ****    SAI_RxGetDefaultConfig(&config);
 329:../drivers/fsl_sai.h ****    @endcode
 330:../drivers/fsl_sai.h ****  *
 331:../drivers/fsl_sai.h ****  * @param config pointer to master configuration structure
 332:../drivers/fsl_sai.h ****  */
 333:../drivers/fsl_sai.h **** void SAI_RxGetDefaultConfig(sai_config_t *config);
 334:../drivers/fsl_sai.h **** 
 335:../drivers/fsl_sai.h **** /*!
 336:../drivers/fsl_sai.h ****  * @brief De-initializes the SAI peripheral.
 337:../drivers/fsl_sai.h ****  *
 338:../drivers/fsl_sai.h ****  * This API gates the SAI clock. The SAI module can't operate unless SAI_TxInit
 339:../drivers/fsl_sai.h ****  * or SAI_RxInit is called to enable the clock.
 340:../drivers/fsl_sai.h ****  *
 341:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 342:../drivers/fsl_sai.h **** */
 343:../drivers/fsl_sai.h **** void SAI_Deinit(I2S_Type *base);
 344:../drivers/fsl_sai.h **** 
 345:../drivers/fsl_sai.h **** /*!
 346:../drivers/fsl_sai.h ****  * @brief Resets the SAI Tx.
 347:../drivers/fsl_sai.h ****  *
 348:../drivers/fsl_sai.h ****  * This function enables the software reset and FIFO reset of SAI Tx. After reset, clear the reset 
 349:../drivers/fsl_sai.h ****  *
 350:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 351:../drivers/fsl_sai.h ****  */
 352:../drivers/fsl_sai.h **** void SAI_TxReset(I2S_Type *base);
 353:../drivers/fsl_sai.h **** 
 354:../drivers/fsl_sai.h **** /*!
 355:../drivers/fsl_sai.h ****  * @brief Resets the SAI Rx.
 356:../drivers/fsl_sai.h ****  *
 357:../drivers/fsl_sai.h ****  * This function enables the software reset and FIFO reset of SAI Rx. After reset, clear the reset 
 358:../drivers/fsl_sai.h ****  *
 359:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 360:../drivers/fsl_sai.h ****  */
 361:../drivers/fsl_sai.h **** void SAI_RxReset(I2S_Type *base);
 362:../drivers/fsl_sai.h **** 
 363:../drivers/fsl_sai.h **** /*!
 364:../drivers/fsl_sai.h ****  * @brief Enables/disables the SAI Tx.
 365:../drivers/fsl_sai.h ****  *
 366:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 367:../drivers/fsl_sai.h ****  * @param enable True means enable SAI Tx, false means disable.
 368:../drivers/fsl_sai.h ****  */
 369:../drivers/fsl_sai.h **** void SAI_TxEnable(I2S_Type *base, bool enable);
 370:../drivers/fsl_sai.h **** 
 371:../drivers/fsl_sai.h **** /*!
 372:../drivers/fsl_sai.h ****  * @brief Enables/disables the SAI Rx.
 373:../drivers/fsl_sai.h ****  *
 374:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 375:../drivers/fsl_sai.h ****  * @param enable True means enable SAI Rx, false means disable.
 376:../drivers/fsl_sai.h ****  */
 377:../drivers/fsl_sai.h **** void SAI_RxEnable(I2S_Type *base, bool enable);
 378:../drivers/fsl_sai.h **** 
 379:../drivers/fsl_sai.h **** /*! @} */
 380:../drivers/fsl_sai.h **** 
 381:../drivers/fsl_sai.h **** /*!
 382:../drivers/fsl_sai.h ****  * @name Status
 383:../drivers/fsl_sai.h ****  * @{
 384:../drivers/fsl_sai.h ****  */
 385:../drivers/fsl_sai.h **** 
 386:../drivers/fsl_sai.h **** /*!
 387:../drivers/fsl_sai.h ****  * @brief Gets the SAI Tx status flag state.
 388:../drivers/fsl_sai.h ****  *
 389:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 390:../drivers/fsl_sai.h ****  * @return SAI Tx status flag value. Use the Status Mask to get the status value needed.
 391:../drivers/fsl_sai.h ****  */
 392:../drivers/fsl_sai.h **** static inline uint32_t SAI_TxGetStatusFlag(I2S_Type *base)
 393:../drivers/fsl_sai.h **** {
 394:../drivers/fsl_sai.h ****     return base->TCSR;
 395:../drivers/fsl_sai.h **** }
 396:../drivers/fsl_sai.h **** 
 397:../drivers/fsl_sai.h **** /*!
 398:../drivers/fsl_sai.h ****  * @brief Clears the SAI Tx status flag state.
 399:../drivers/fsl_sai.h ****  *
 400:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 401:../drivers/fsl_sai.h ****  * @param mask State mask. It can be a combination of the following source if defined:
 402:../drivers/fsl_sai.h ****  *        @arg kSAI_WordStartFlag
 403:../drivers/fsl_sai.h ****  *        @arg kSAI_SyncErrorFlag
 404:../drivers/fsl_sai.h ****  *        @arg kSAI_FIFOErrorFlag
 405:../drivers/fsl_sai.h ****  */
 406:../drivers/fsl_sai.h **** static inline void SAI_TxClearStatusFlags(I2S_Type *base, uint32_t mask)
 407:../drivers/fsl_sai.h **** {
 408:../drivers/fsl_sai.h ****     base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | mask);
 1142              		.loc 3 408 0
 1143 001a 0368     		ldr	r3, [r0]
 1144 001c 0D4A     		ldr	r2, .L66+4
 1145 001e 1A40     		ands	r2, r3
 1146 0020 8023     		movs	r3, #128
 1147 0022 DB02     		lsls	r3, r3, #11
 1148 0024 1343     		orrs	r3, r2
 1149 0026 0360     		str	r3, [r0]
 1150              	.LVL122:
 1151              	.L61:
 1152              	.LBE41:
 1153              	.LBE40:
 525:../drivers/fsl_sai.c ****         /* Also need to clear the FIFO error flag before start */
 526:../drivers/fsl_sai.c ****         SAI_TxClearStatusFlags(base, kSAI_FIFOErrorFlag);
 527:../drivers/fsl_sai.c ****     }
 528:../drivers/fsl_sai.c ****     else
 529:../drivers/fsl_sai.c ****     {
 530:../drivers/fsl_sai.c ****         /* If RE not sync with TE, than disable TE, otherwise, shall not disable TE */
 531:../drivers/fsl_sai.c ****         if (((base->RCR2 & I2S_RCR2_SYNC_MASK) >> I2S_RCR2_SYNC_SHIFT) != 0x1U)
 532:../drivers/fsl_sai.c ****         {
 533:../drivers/fsl_sai.c ****             /* Should not close RE even sync with Rx */
 534:../drivers/fsl_sai.c ****             base->TCSR = ((base->TCSR & 0xFFE3FFFFU) & (~I2S_TCSR_TE_MASK));
 535:../drivers/fsl_sai.c ****         }
 536:../drivers/fsl_sai.c ****     }
 537:../drivers/fsl_sai.c **** }
 1154              		.loc 1 537 0
 1155              		@ sp needed
 1156 0028 7047     		bx	lr
 1157              	.LVL123:
 1158              	.L65:
 522:../drivers/fsl_sai.c ****         }
 1159              		.loc 1 522 0
 1160 002a 8021     		movs	r1, #128
 1161              	.LVL124:
 1162 002c 4358     		ldr	r3, [r0, r1]
 1163 002e 084A     		ldr	r2, .L66
 1164 0030 1A40     		ands	r2, r3
 1165 0032 8023     		movs	r3, #128
 1166 0034 1B06     		lsls	r3, r3, #24
 1167 0036 1343     		orrs	r3, r2
 1168 0038 4350     		str	r3, [r0, r1]
 1169 003a E7E7     		b	.L63
 1170              	.LVL125:
 1171              	.L62:
 531:../drivers/fsl_sai.c ****         {
 1172              		.loc 1 531 0
 1173 003c 8823     		movs	r3, #136
 1174 003e C358     		ldr	r3, [r0, r3]
 1175 0040 9B0F     		lsrs	r3, r3, #30
 1176 0042 012B     		cmp	r3, #1
 1177 0044 F0D0     		beq	.L61
 534:../drivers/fsl_sai.c ****         }
 1178              		.loc 1 534 0
 1179 0046 0368     		ldr	r3, [r0]
 1180 0048 014A     		ldr	r2, .L66
 1181 004a 1340     		ands	r3, r2
 1182 004c 0360     		str	r3, [r0]
 1183              		.loc 1 537 0
 1184 004e EBE7     		b	.L61
 1185              	.L67:
 1186              		.align	2
 1187              	.L66:
 1188 0050 FFFFE37F 		.word	2145648639
 1189 0054 FFFFE3FF 		.word	-1835009
 1190              		.cfi_endproc
 1191              	.LFE77:
 1193              		.section	.text.SAI_RxEnable,"ax",%progbits
 1194              		.align	1
 1195              		.global	SAI_RxEnable
 1196              		.syntax unified
 1197              		.code	16
 1198              		.thumb_func
 1199              		.fpu softvfp
 1201              	SAI_RxEnable:
 1202              	.LFB78:
 538:../drivers/fsl_sai.c **** 
 539:../drivers/fsl_sai.c **** void SAI_RxEnable(I2S_Type *base, bool enable)
 540:../drivers/fsl_sai.c **** {
 1203              		.loc 1 540 0
 1204              		.cfi_startproc
 1205              		@ args = 0, pretend = 0, frame = 0
 1206              		@ frame_needed = 0, uses_anonymous_args = 0
 1207              		@ link register save eliminated.
 1208              	.LVL126:
 541:../drivers/fsl_sai.c ****     if (enable)
 1209              		.loc 1 541 0
 1210 0000 0029     		cmp	r1, #0
 1211 0002 1CD0     		beq	.L69
 542:../drivers/fsl_sai.c ****     {
 543:../drivers/fsl_sai.c ****         /* If clock is sync with Tx, should enable TE bit. */
 544:../drivers/fsl_sai.c ****         if (((base->RCR2 & I2S_RCR2_SYNC_MASK) >> I2S_RCR2_SYNC_SHIFT) == 0x1U)
 1212              		.loc 1 544 0
 1213 0004 8823     		movs	r3, #136
 1214 0006 C358     		ldr	r3, [r0, r3]
 1215 0008 9B0F     		lsrs	r3, r3, #30
 1216 000a 012B     		cmp	r3, #1
 1217 000c 0FD0     		beq	.L72
 1218              	.L70:
 545:../drivers/fsl_sai.c ****         {
 546:../drivers/fsl_sai.c ****             base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | I2S_TCSR_TE_MASK);
 547:../drivers/fsl_sai.c ****         }
 548:../drivers/fsl_sai.c ****         base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | I2S_RCSR_RE_MASK);
 1219              		.loc 1 548 0
 1220 000e 8023     		movs	r3, #128
 1221 0010 C258     		ldr	r2, [r0, r3]
 1222 0012 1049     		ldr	r1, .L73
 1223              	.LVL127:
 1224 0014 1140     		ands	r1, r2
 1225 0016 8022     		movs	r2, #128
 1226 0018 1206     		lsls	r2, r2, #24
 1227 001a 0A43     		orrs	r2, r1
 1228 001c C250     		str	r2, [r0, r3]
 1229              	.LVL128:
 1230              	.LBB42:
 1231              	.LBB43:
 409:../drivers/fsl_sai.h **** }
 410:../drivers/fsl_sai.h **** 
 411:../drivers/fsl_sai.h **** /*!
 412:../drivers/fsl_sai.h ****  * @brief Gets the SAI Tx status flag state.
 413:../drivers/fsl_sai.h ****  *
 414:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 415:../drivers/fsl_sai.h ****  * @return SAI Rx status flag value. Use the Status Mask to get the status value needed.
 416:../drivers/fsl_sai.h ****  */
 417:../drivers/fsl_sai.h **** static inline uint32_t SAI_RxGetStatusFlag(I2S_Type *base)
 418:../drivers/fsl_sai.h **** {
 419:../drivers/fsl_sai.h ****     return base->RCSR;
 420:../drivers/fsl_sai.h **** }
 421:../drivers/fsl_sai.h **** 
 422:../drivers/fsl_sai.h **** /*!
 423:../drivers/fsl_sai.h ****  * @brief Clears the SAI Rx status flag state.
 424:../drivers/fsl_sai.h ****  *
 425:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 426:../drivers/fsl_sai.h ****  * @param mask State mask. It can be a combination of the following sources if defined.
 427:../drivers/fsl_sai.h ****  *        @arg kSAI_WordStartFlag
 428:../drivers/fsl_sai.h ****  *        @arg kSAI_SyncErrorFlag
 429:../drivers/fsl_sai.h ****  *        @arg kSAI_FIFOErrorFlag
 430:../drivers/fsl_sai.h ****  */
 431:../drivers/fsl_sai.h **** static inline void SAI_RxClearStatusFlags(I2S_Type *base, uint32_t mask)
 432:../drivers/fsl_sai.h **** {
 433:../drivers/fsl_sai.h ****     base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | mask);
 1232              		.loc 3 433 0
 1233 001e C258     		ldr	r2, [r0, r3]
 1234 0020 0D49     		ldr	r1, .L73+4
 1235 0022 1140     		ands	r1, r2
 1236 0024 8022     		movs	r2, #128
 1237 0026 D202     		lsls	r2, r2, #11
 1238 0028 0A43     		orrs	r2, r1
 1239 002a C250     		str	r2, [r0, r3]
 1240              	.LVL129:
 1241              	.L68:
 1242              	.LBE43:
 1243              	.LBE42:
 549:../drivers/fsl_sai.c ****         /* Also need to clear the FIFO error flag before start */
 550:../drivers/fsl_sai.c ****         SAI_RxClearStatusFlags(base, kSAI_FIFOErrorFlag);
 551:../drivers/fsl_sai.c ****     }
 552:../drivers/fsl_sai.c ****     else
 553:../drivers/fsl_sai.c ****     {
 554:../drivers/fsl_sai.c ****         /* While TX is not sync with RX, close RX */
 555:../drivers/fsl_sai.c ****         if (((base->TCR2 & I2S_TCR2_SYNC_MASK) >> I2S_TCR2_SYNC_SHIFT) != 0x1U)
 556:../drivers/fsl_sai.c ****         {
 557:../drivers/fsl_sai.c ****             base->RCSR = ((base->RCSR & 0xFFE3FFFFU) & (~I2S_RCSR_RE_MASK));
 558:../drivers/fsl_sai.c ****         }
 559:../drivers/fsl_sai.c ****     }
 560:../drivers/fsl_sai.c **** }
 1244              		.loc 1 560 0
 1245              		@ sp needed
 1246 002c 7047     		bx	lr
 1247              	.LVL130:
 1248              	.L72:
 546:../drivers/fsl_sai.c ****         }
 1249              		.loc 1 546 0
 1250 002e 0368     		ldr	r3, [r0]
 1251 0030 084A     		ldr	r2, .L73
 1252 0032 1A40     		ands	r2, r3
 1253 0034 8023     		movs	r3, #128
 1254 0036 1B06     		lsls	r3, r3, #24
 1255 0038 1343     		orrs	r3, r2
 1256 003a 0360     		str	r3, [r0]
 1257 003c E7E7     		b	.L70
 1258              	.L69:
 555:../drivers/fsl_sai.c ****         {
 1259              		.loc 1 555 0
 1260 003e 8368     		ldr	r3, [r0, #8]
 1261 0040 9B0F     		lsrs	r3, r3, #30
 1262 0042 012B     		cmp	r3, #1
 1263 0044 F2D0     		beq	.L68
 557:../drivers/fsl_sai.c ****         }
 1264              		.loc 1 557 0
 1265 0046 8022     		movs	r2, #128
 1266 0048 8358     		ldr	r3, [r0, r2]
 1267 004a 0249     		ldr	r1, .L73
 1268              	.LVL131:
 1269 004c 0B40     		ands	r3, r1
 1270 004e 8350     		str	r3, [r0, r2]
 1271              		.loc 1 560 0
 1272 0050 ECE7     		b	.L68
 1273              	.L74:
 1274 0052 C046     		.align	2
 1275              	.L73:
 1276 0054 FFFFE37F 		.word	2145648639
 1277 0058 FFFFE3FF 		.word	-1835009
 1278              		.cfi_endproc
 1279              	.LFE78:
 1281              		.section	.text.SAI_Deinit,"ax",%progbits
 1282              		.align	1
 1283              		.global	SAI_Deinit
 1284              		.syntax unified
 1285              		.code	16
 1286              		.thumb_func
 1287              		.fpu softvfp
 1289              	SAI_Deinit:
 1290              	.LFB72:
 451:../drivers/fsl_sai.c ****     SAI_TxEnable(base, false);
 1291              		.loc 1 451 0
 1292              		.cfi_startproc
 1293              		@ args = 0, pretend = 0, frame = 0
 1294              		@ frame_needed = 0, uses_anonymous_args = 0
 1295              	.LVL132:
 1296 0000 10B5     		push	{r4, lr}
 1297              		.cfi_def_cfa_offset 8
 1298              		.cfi_offset 4, -8
 1299              		.cfi_offset 14, -4
 1300 0002 0400     		movs	r4, r0
 452:../drivers/fsl_sai.c ****     SAI_RxEnable(base, false);
 1301              		.loc 1 452 0
 1302 0004 0021     		movs	r1, #0
 1303 0006 FFF7FEFF 		bl	SAI_TxEnable
 1304              	.LVL133:
 453:../drivers/fsl_sai.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 1305              		.loc 1 453 0
 1306 000a 0021     		movs	r1, #0
 1307 000c 2000     		movs	r0, r4
 1308 000e FFF7FEFF 		bl	SAI_RxEnable
 1309              	.LVL134:
 455:../drivers/fsl_sai.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 1310              		.loc 1 455 0
 1311 0012 2000     		movs	r0, r4
 1312 0014 FFF7FEFF 		bl	SAI_GetInstance
 1313              	.LVL135:
 1314              	.LBB44:
 1315              	.LBB45:
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 1316              		.loc 2 461 0
 1317 0018 024A     		ldr	r2, .L76
 1318 001a 1368     		ldr	r3, [r2]
 1319 001c 0249     		ldr	r1, .L76+4
 1320 001e 0B40     		ands	r3, r1
 1321 0020 1360     		str	r3, [r2]
 1322              	.LVL136:
 1323              	.LBE45:
 1324              	.LBE44:
 457:../drivers/fsl_sai.c **** 
 1325              		.loc 1 457 0
 1326              		@ sp needed
 1327              	.LVL137:
 1328 0022 10BD     		pop	{r4, pc}
 1329              	.L77:
 1330              		.align	2
 1331              	.L76:
 1332 0024 3C800440 		.word	1074036796
 1333 0028 FF7FFFFF 		.word	-32769
 1334              		.cfi_endproc
 1335              	.LFE72:
 1337              		.section	.text.SAI_TxSoftwareReset,"ax",%progbits
 1338              		.align	1
 1339              		.global	SAI_TxSoftwareReset
 1340              		.syntax unified
 1341              		.code	16
 1342              		.thumb_func
 1343              		.fpu softvfp
 1345              	SAI_TxSoftwareReset:
 1346              	.LFB79:
 561:../drivers/fsl_sai.c **** 
 562:../drivers/fsl_sai.c **** void SAI_TxSoftwareReset(I2S_Type *base, sai_reset_type_t type)
 563:../drivers/fsl_sai.c **** {
 1347              		.loc 1 563 0
 1348              		.cfi_startproc
 1349              		@ args = 0, pretend = 0, frame = 0
 1350              		@ frame_needed = 0, uses_anonymous_args = 0
 1351              		@ link register save eliminated.
 1352              	.LVL138:
 564:../drivers/fsl_sai.c ****     base->TCSR |= (uint32_t)type;
 1353              		.loc 1 564 0
 1354 0000 0368     		ldr	r3, [r0]
 1355 0002 1943     		orrs	r1, r3
 1356              	.LVL139:
 1357 0004 0160     		str	r1, [r0]
 565:../drivers/fsl_sai.c **** 
 566:../drivers/fsl_sai.c ****     /* Clear the software reset */
 567:../drivers/fsl_sai.c ****     base->TCSR &= ~I2S_TCSR_SR_MASK;
 1358              		.loc 1 567 0
 1359 0006 0368     		ldr	r3, [r0]
 1360 0008 014A     		ldr	r2, .L79
 1361 000a 1340     		ands	r3, r2
 1362 000c 0360     		str	r3, [r0]
 568:../drivers/fsl_sai.c **** }
 1363              		.loc 1 568 0
 1364              		@ sp needed
 1365 000e 7047     		bx	lr
 1366              	.L80:
 1367              		.align	2
 1368              	.L79:
 1369 0010 FFFFFFFE 		.word	-16777217
 1370              		.cfi_endproc
 1371              	.LFE79:
 1373              		.section	.text.SAI_RxSoftwareReset,"ax",%progbits
 1374              		.align	1
 1375              		.global	SAI_RxSoftwareReset
 1376              		.syntax unified
 1377              		.code	16
 1378              		.thumb_func
 1379              		.fpu softvfp
 1381              	SAI_RxSoftwareReset:
 1382              	.LFB80:
 569:../drivers/fsl_sai.c **** 
 570:../drivers/fsl_sai.c **** void SAI_RxSoftwareReset(I2S_Type *base, sai_reset_type_t type)
 571:../drivers/fsl_sai.c **** {
 1383              		.loc 1 571 0
 1384              		.cfi_startproc
 1385              		@ args = 0, pretend = 0, frame = 0
 1386              		@ frame_needed = 0, uses_anonymous_args = 0
 1387              		@ link register save eliminated.
 1388              	.LVL140:
 572:../drivers/fsl_sai.c ****     base->RCSR |= (uint32_t)type;
 1389              		.loc 1 572 0
 1390 0000 8023     		movs	r3, #128
 1391 0002 C258     		ldr	r2, [r0, r3]
 1392 0004 1143     		orrs	r1, r2
 1393              	.LVL141:
 1394 0006 C150     		str	r1, [r0, r3]
 573:../drivers/fsl_sai.c **** 
 574:../drivers/fsl_sai.c ****     /* Clear the software reset */
 575:../drivers/fsl_sai.c ****     base->RCSR &= ~I2S_RCSR_SR_MASK;
 1395              		.loc 1 575 0
 1396 0008 C258     		ldr	r2, [r0, r3]
 1397 000a 0249     		ldr	r1, .L82
 1398 000c 0A40     		ands	r2, r1
 1399 000e C250     		str	r2, [r0, r3]
 576:../drivers/fsl_sai.c **** }
 1400              		.loc 1 576 0
 1401              		@ sp needed
 1402 0010 7047     		bx	lr
 1403              	.L83:
 1404 0012 C046     		.align	2
 1405              	.L82:
 1406 0014 FFFFFFFE 		.word	-16777217
 1407              		.cfi_endproc
 1408              	.LFE80:
 1410              		.section	.text.SAI_TxSetChannelFIFOMask,"ax",%progbits
 1411              		.align	1
 1412              		.global	SAI_TxSetChannelFIFOMask
 1413              		.syntax unified
 1414              		.code	16
 1415              		.thumb_func
 1416              		.fpu softvfp
 1418              	SAI_TxSetChannelFIFOMask:
 1419              	.LFB81:
 577:../drivers/fsl_sai.c **** 
 578:../drivers/fsl_sai.c **** void SAI_TxSetChannelFIFOMask(I2S_Type *base, uint8_t mask)
 579:../drivers/fsl_sai.c **** {
 1420              		.loc 1 579 0
 1421              		.cfi_startproc
 1422              		@ args = 0, pretend = 0, frame = 0
 1423              		@ frame_needed = 0, uses_anonymous_args = 0
 1424              		@ link register save eliminated.
 1425              	.LVL142:
 580:../drivers/fsl_sai.c ****     base->TCR3 &= ~I2S_TCR3_TCE_MASK;
 1426              		.loc 1 580 0
 1427 0000 C368     		ldr	r3, [r0, #12]
 1428 0002 054A     		ldr	r2, .L85
 1429 0004 1340     		ands	r3, r2
 1430 0006 C360     		str	r3, [r0, #12]
 581:../drivers/fsl_sai.c ****     base->TCR3 |= I2S_TCR3_TCE(mask);
 1431              		.loc 1 581 0
 1432 0008 C368     		ldr	r3, [r0, #12]
 1433 000a 0904     		lsls	r1, r1, #16
 1434              	.LVL143:
 1435 000c 8022     		movs	r2, #128
 1436 000e 5202     		lsls	r2, r2, #9
 1437 0010 1140     		ands	r1, r2
 1438 0012 1943     		orrs	r1, r3
 1439 0014 C160     		str	r1, [r0, #12]
 582:../drivers/fsl_sai.c **** }
 1440              		.loc 1 582 0
 1441              		@ sp needed
 1442 0016 7047     		bx	lr
 1443              	.L86:
 1444              		.align	2
 1445              	.L85:
 1446 0018 FFFFFEFF 		.word	-65537
 1447              		.cfi_endproc
 1448              	.LFE81:
 1450              		.section	.text.SAI_RxSetChannelFIFOMask,"ax",%progbits
 1451              		.align	1
 1452              		.global	SAI_RxSetChannelFIFOMask
 1453              		.syntax unified
 1454              		.code	16
 1455              		.thumb_func
 1456              		.fpu softvfp
 1458              	SAI_RxSetChannelFIFOMask:
 1459              	.LFB82:
 583:../drivers/fsl_sai.c **** 
 584:../drivers/fsl_sai.c **** void SAI_RxSetChannelFIFOMask(I2S_Type *base, uint8_t mask)
 585:../drivers/fsl_sai.c **** {
 1460              		.loc 1 585 0
 1461              		.cfi_startproc
 1462              		@ args = 0, pretend = 0, frame = 0
 1463              		@ frame_needed = 0, uses_anonymous_args = 0
 1464              	.LVL144:
 1465 0000 10B5     		push	{r4, lr}
 1466              		.cfi_def_cfa_offset 8
 1467              		.cfi_offset 4, -8
 1468              		.cfi_offset 14, -4
 586:../drivers/fsl_sai.c ****     base->RCR3 &= ~I2S_RCR3_RCE_MASK;
 1469              		.loc 1 586 0
 1470 0002 8C23     		movs	r3, #140
 1471 0004 C258     		ldr	r2, [r0, r3]
 1472 0006 054C     		ldr	r4, .L88
 1473 0008 2240     		ands	r2, r4
 1474 000a C250     		str	r2, [r0, r3]
 587:../drivers/fsl_sai.c ****     base->RCR3 |= I2S_RCR3_RCE(mask);
 1475              		.loc 1 587 0
 1476 000c C258     		ldr	r2, [r0, r3]
 1477 000e 0904     		lsls	r1, r1, #16
 1478              	.LVL145:
 1479 0010 8024     		movs	r4, #128
 1480 0012 6402     		lsls	r4, r4, #9
 1481 0014 2140     		ands	r1, r4
 1482 0016 1143     		orrs	r1, r2
 1483 0018 C150     		str	r1, [r0, r3]
 588:../drivers/fsl_sai.c **** }
 1484              		.loc 1 588 0
 1485              		@ sp needed
 1486 001a 10BD     		pop	{r4, pc}
 1487              	.L89:
 1488              		.align	2
 1489              	.L88:
 1490 001c FFFFFEFF 		.word	-65537
 1491              		.cfi_endproc
 1492              	.LFE82:
 1494              		.section	.text.SAI_TxSetFormat,"ax",%progbits
 1495              		.align	1
 1496              		.global	SAI_TxSetFormat
 1497              		.syntax unified
 1498              		.code	16
 1499              		.thumb_func
 1500              		.fpu softvfp
 1502              	SAI_TxSetFormat:
 1503              	.LFB83:
 589:../drivers/fsl_sai.c **** 
 590:../drivers/fsl_sai.c **** void SAI_TxSetFormat(I2S_Type *base,
 591:../drivers/fsl_sai.c ****                      sai_transfer_format_t *format,
 592:../drivers/fsl_sai.c ****                      uint32_t mclkSourceClockHz,
 593:../drivers/fsl_sai.c ****                      uint32_t bclkSourceClockHz)
 594:../drivers/fsl_sai.c **** {
 1504              		.loc 1 594 0
 1505              		.cfi_startproc
 1506              		@ args = 0, pretend = 0, frame = 0
 1507              		@ frame_needed = 0, uses_anonymous_args = 0
 1508              	.LVL146:
 1509 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1510              		.cfi_def_cfa_offset 24
 1511              		.cfi_offset 3, -24
 1512              		.cfi_offset 4, -20
 1513              		.cfi_offset 5, -16
 1514              		.cfi_offset 6, -12
 1515              		.cfi_offset 7, -8
 1516              		.cfi_offset 14, -4
 1517 0002 0400     		movs	r4, r0
 1518 0004 0D00     		movs	r5, r1
 1519              	.LVL147:
 595:../drivers/fsl_sai.c ****     uint32_t bclk = 0;
 596:../drivers/fsl_sai.c ****     uint32_t val = 0;
 597:../drivers/fsl_sai.c ****     uint32_t channels = 2U;
 598:../drivers/fsl_sai.c **** 
 599:../drivers/fsl_sai.c ****     if (format->stereo != kSAI_Stereo)
 1520              		.loc 1 599 0
 1521 0006 0A7A     		ldrb	r2, [r1, #8]
 1522              	.LVL148:
 1523 0008 002A     		cmp	r2, #0
 1524 000a 4BD1     		bne	.L98
 597:../drivers/fsl_sai.c **** 
 1525              		.loc 1 597 0
 1526 000c 0220     		movs	r0, #2
 1527              	.LVL149:
 1528              	.L91:
 600:../drivers/fsl_sai.c ****     {
 601:../drivers/fsl_sai.c ****         channels = 1U;
 602:../drivers/fsl_sai.c ****     }
 603:../drivers/fsl_sai.c **** 
 604:../drivers/fsl_sai.c ****     if (format->isFrameSyncCompact)
 1529              		.loc 1 604 0
 1530 000e AA7C     		ldrb	r2, [r5, #18]
 1531 0010 002A     		cmp	r2, #0
 1532 0012 49D0     		beq	.L92
 605:../drivers/fsl_sai.c ****     {
 606:../drivers/fsl_sai.c ****         bclk = format->sampleRate_Hz * format->bitWidth * channels;
 1533              		.loc 1 606 0
 1534 0014 6A68     		ldr	r2, [r5, #4]
 1535 0016 2968     		ldr	r1, [r5]
 1536              	.LVL150:
 1537 0018 5143     		muls	r1, r2
 1538 001a 4143     		muls	r1, r0
 1539              	.LVL151:
 607:../drivers/fsl_sai.c ****         val = (base->TCR4 & (~I2S_TCR4_SYWD_MASK));
 1540              		.loc 1 607 0
 1541 001c 2069     		ldr	r0, [r4, #16]
 1542              	.LVL152:
 1543 001e 2D4E     		ldr	r6, .L101
 1544 0020 3040     		ands	r0, r6
 1545              	.LVL153:
 608:../drivers/fsl_sai.c ****         val |= I2S_TCR4_SYWD(format->bitWidth - 1U);
 1546              		.loc 1 608 0
 1547 0022 013A     		subs	r2, r2, #1
 1548 0024 1202     		lsls	r2, r2, #8
 1549 0026 F826     		movs	r6, #248
 1550 0028 7601     		lsls	r6, r6, #5
 1551 002a 3240     		ands	r2, r6
 1552 002c 0243     		orrs	r2, r0
 1553              	.LVL154:
 609:../drivers/fsl_sai.c ****         base->TCR4 = val;
 1554              		.loc 1 609 0
 1555 002e 2261     		str	r2, [r4, #16]
 1556              	.LVL155:
 1557              	.L93:
 610:../drivers/fsl_sai.c ****     }
 611:../drivers/fsl_sai.c ****     else
 612:../drivers/fsl_sai.c ****     {
 613:../drivers/fsl_sai.c ****         bclk = format->sampleRate_Hz * 32U * 2U;
 614:../drivers/fsl_sai.c ****     }
 615:../drivers/fsl_sai.c **** 
 616:../drivers/fsl_sai.c **** /* Compute the mclk */
 617:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER) && (FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER)
 618:../drivers/fsl_sai.c ****     /* Check if master clock divider enabled, then set master clock divider */
 619:../drivers/fsl_sai.c ****     if (base->MCR & I2S_MCR_MOE_MASK)
 620:../drivers/fsl_sai.c ****     {
 621:../drivers/fsl_sai.c ****         SAI_SetMasterClockDivider(base, format->masterClockHz, mclkSourceClockHz);
 622:../drivers/fsl_sai.c ****     }
 623:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER */
 624:../drivers/fsl_sai.c **** 
 625:../drivers/fsl_sai.c ****     /* Set bclk if needed */
 626:../drivers/fsl_sai.c ****     if (base->TCR2 & I2S_TCR2_BCD_MASK)
 1558              		.loc 1 626 0
 1559 0030 A268     		ldr	r2, [r4, #8]
 1560 0032 D201     		lsls	r2, r2, #7
 1561 0034 0CD5     		bpl	.L94
 627:../drivers/fsl_sai.c ****     {
 628:../drivers/fsl_sai.c ****         base->TCR2 &= ~I2S_TCR2_DIV_MASK;
 1562              		.loc 1 628 0
 1563 0036 A268     		ldr	r2, [r4, #8]
 1564 0038 FF26     		movs	r6, #255
 1565 003a B243     		bics	r2, r6
 1566 003c A260     		str	r2, [r4, #8]
 629:../drivers/fsl_sai.c ****         base->TCR2 |= I2S_TCR2_DIV((bclkSourceClockHz / bclk) / 2U - 1U);
 1567              		.loc 1 629 0
 1568 003e A768     		ldr	r7, [r4, #8]
 1569 0040 1800     		movs	r0, r3
 1570 0042 FFF7FEFF 		bl	__aeabi_uidiv
 1571              	.LVL156:
 1572 0046 4008     		lsrs	r0, r0, #1
 1573 0048 0138     		subs	r0, r0, #1
 1574 004a 3040     		ands	r0, r6
 1575 004c 3843     		orrs	r0, r7
 1576 004e A060     		str	r0, [r4, #8]
 1577              	.L94:
 630:../drivers/fsl_sai.c ****     }
 631:../drivers/fsl_sai.c **** 
 632:../drivers/fsl_sai.c ****     /* Set bitWidth */
 633:../drivers/fsl_sai.c ****     val = (format->isFrameSyncCompact) ? (format->bitWidth - 1) : 31U;
 1578              		.loc 1 633 0
 1579 0050 AB7C     		ldrb	r3, [r5, #18]
 1580 0052 002B     		cmp	r3, #0
 1581 0054 2BD0     		beq	.L99
 1582              		.loc 1 633 0 is_stmt 0 discriminator 1
 1583 0056 6B68     		ldr	r3, [r5, #4]
 1584 0058 013B     		subs	r3, r3, #1
 1585              	.L95:
 1586              	.LVL157:
 634:../drivers/fsl_sai.c ****     if (format->protocol == kSAI_BusRightJustified)
 1587              		.loc 1 634 0 is_stmt 1 discriminator 4
 1588 005a 6A7C     		ldrb	r2, [r5, #17]
 1589 005c 012A     		cmp	r2, #1
 1590 005e 28D0     		beq	.L100
 635:../drivers/fsl_sai.c ****     {
 636:../drivers/fsl_sai.c ****         base->TCR5 = I2S_TCR5_WNW(val) | I2S_TCR5_W0W(val) | I2S_TCR5_FBT(val);
 637:../drivers/fsl_sai.c ****     }
 638:../drivers/fsl_sai.c ****     else
 639:../drivers/fsl_sai.c ****     {
 640:../drivers/fsl_sai.c ****         base->TCR5 = I2S_TCR5_WNW(val) | I2S_TCR5_W0W(val) | I2S_TCR5_FBT(format->bitWidth - 1);
 1591              		.loc 1 640 0
 1592 0060 1A06     		lsls	r2, r3, #24
 1593 0062 F821     		movs	r1, #248
 1594 0064 4905     		lsls	r1, r1, #21
 1595 0066 0A40     		ands	r2, r1
 1596 0068 1B04     		lsls	r3, r3, #16
 1597              	.LVL158:
 1598 006a F821     		movs	r1, #248
 1599 006c 4903     		lsls	r1, r1, #13
 1600 006e 0B40     		ands	r3, r1
 1601 0070 1343     		orrs	r3, r2
 1602 0072 6A68     		ldr	r2, [r5, #4]
 1603 0074 013A     		subs	r2, r2, #1
 1604 0076 1202     		lsls	r2, r2, #8
 1605 0078 F821     		movs	r1, #248
 1606 007a 4901     		lsls	r1, r1, #5
 1607 007c 0A40     		ands	r2, r1
 1608 007e 1343     		orrs	r3, r2
 1609 0080 6361     		str	r3, [r4, #20]
 1610              	.L97:
 641:../drivers/fsl_sai.c ****     }
 642:../drivers/fsl_sai.c **** 
 643:../drivers/fsl_sai.c ****     /* Set mono or stereo */
 644:../drivers/fsl_sai.c ****     base->TMR = (uint32_t)format->stereo;
 1611              		.loc 1 644 0
 1612 0082 2B7A     		ldrb	r3, [r5, #8]
 1613 0084 2366     		str	r3, [r4, #96]
 645:../drivers/fsl_sai.c **** 
 646:../drivers/fsl_sai.c ****     /* Set data channel */
 647:../drivers/fsl_sai.c ****     base->TCR3 &= ~I2S_TCR3_TCE_MASK;
 1614              		.loc 1 647 0
 1615 0086 E368     		ldr	r3, [r4, #12]
 1616 0088 134A     		ldr	r2, .L101+4
 1617 008a 1340     		ands	r3, r2
 1618 008c E360     		str	r3, [r4, #12]
 648:../drivers/fsl_sai.c ****     base->TCR3 |= I2S_TCR3_TCE(1U << format->channel);
 1619              		.loc 1 648 0
 1620 008e E268     		ldr	r2, [r4, #12]
 1621 0090 297C     		ldrb	r1, [r5, #16]
 1622 0092 0123     		movs	r3, #1
 1623 0094 8B40     		lsls	r3, r3, r1
 1624 0096 1B04     		lsls	r3, r3, #16
 1625 0098 8021     		movs	r1, #128
 1626 009a 4902     		lsls	r1, r1, #9
 1627 009c 0B40     		ands	r3, r1
 1628 009e 1343     		orrs	r3, r2
 1629 00a0 E360     		str	r3, [r4, #12]
 649:../drivers/fsl_sai.c **** 
 650:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 651:../drivers/fsl_sai.c ****     /* Set watermark */
 652:../drivers/fsl_sai.c ****     base->TCR1 = format->watermark;
 653:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT  */
 654:../drivers/fsl_sai.c **** }
 1630              		.loc 1 654 0
 1631              		@ sp needed
 1632              	.LVL159:
 1633              	.LVL160:
 1634 00a2 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1635              	.LVL161:
 1636              	.L98:
 601:../drivers/fsl_sai.c ****     }
 1637              		.loc 1 601 0
 1638 00a4 0120     		movs	r0, #1
 1639              	.LVL162:
 1640 00a6 B2E7     		b	.L91
 1641              	.LVL163:
 1642              	.L92:
 613:../drivers/fsl_sai.c ****     }
 1643              		.loc 1 613 0
 1644 00a8 2A68     		ldr	r2, [r5]
 1645 00aa 9101     		lsls	r1, r2, #6
 1646              	.LVL164:
 1647 00ac C0E7     		b	.L93
 1648              	.LVL165:
 1649              	.L99:
 633:../drivers/fsl_sai.c ****     if (format->protocol == kSAI_BusRightJustified)
 1650              		.loc 1 633 0
 1651 00ae 1F23     		movs	r3, #31
 1652 00b0 D3E7     		b	.L95
 1653              	.LVL166:
 1654              	.L100:
 636:../drivers/fsl_sai.c ****     }
 1655              		.loc 1 636 0
 1656 00b2 1A06     		lsls	r2, r3, #24
 1657 00b4 F821     		movs	r1, #248
 1658 00b6 4905     		lsls	r1, r1, #21
 1659 00b8 0A40     		ands	r2, r1
 1660 00ba 1904     		lsls	r1, r3, #16
 1661 00bc F820     		movs	r0, #248
 1662 00be 4003     		lsls	r0, r0, #13
 1663 00c0 0140     		ands	r1, r0
 1664 00c2 0A43     		orrs	r2, r1
 1665 00c4 1B02     		lsls	r3, r3, #8
 1666              	.LVL167:
 1667 00c6 F821     		movs	r1, #248
 1668 00c8 4901     		lsls	r1, r1, #5
 1669 00ca 0B40     		ands	r3, r1
 1670 00cc 1343     		orrs	r3, r2
 1671 00ce 6361     		str	r3, [r4, #20]
 1672 00d0 D7E7     		b	.L97
 1673              	.L102:
 1674 00d2 C046     		.align	2
 1675              	.L101:
 1676 00d4 FFE0FFFF 		.word	-7937
 1677 00d8 FFFFFEFF 		.word	-65537
 1678              		.cfi_endproc
 1679              	.LFE83:
 1681              		.section	.text.SAI_RxSetFormat,"ax",%progbits
 1682              		.align	1
 1683              		.global	SAI_RxSetFormat
 1684              		.syntax unified
 1685              		.code	16
 1686              		.thumb_func
 1687              		.fpu softvfp
 1689              	SAI_RxSetFormat:
 1690              	.LFB84:
 655:../drivers/fsl_sai.c **** 
 656:../drivers/fsl_sai.c **** void SAI_RxSetFormat(I2S_Type *base,
 657:../drivers/fsl_sai.c ****                      sai_transfer_format_t *format,
 658:../drivers/fsl_sai.c ****                      uint32_t mclkSourceClockHz,
 659:../drivers/fsl_sai.c ****                      uint32_t bclkSourceClockHz)
 660:../drivers/fsl_sai.c **** {
 1691              		.loc 1 660 0
 1692              		.cfi_startproc
 1693              		@ args = 0, pretend = 0, frame = 0
 1694              		@ frame_needed = 0, uses_anonymous_args = 0
 1695              	.LVL168:
 1696 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1697              		.cfi_def_cfa_offset 20
 1698              		.cfi_offset 4, -20
 1699              		.cfi_offset 5, -16
 1700              		.cfi_offset 6, -12
 1701              		.cfi_offset 7, -8
 1702              		.cfi_offset 14, -4
 1703 0002 C646     		mov	lr, r8
 1704 0004 00B5     		push	{lr}
 1705              		.cfi_def_cfa_offset 24
 1706              		.cfi_offset 8, -24
 1707 0006 0400     		movs	r4, r0
 1708 0008 0D00     		movs	r5, r1
 1709              	.LVL169:
 661:../drivers/fsl_sai.c ****     uint32_t bclk = 0;
 662:../drivers/fsl_sai.c ****     uint32_t val = 0;
 663:../drivers/fsl_sai.c ****     uint32_t channels = 2U;
 664:../drivers/fsl_sai.c **** 
 665:../drivers/fsl_sai.c ****     if (format->stereo != kSAI_Stereo)
 1710              		.loc 1 665 0
 1711 000a 0A7A     		ldrb	r2, [r1, #8]
 1712              	.LVL170:
 1713 000c 002A     		cmp	r2, #0
 1714 000e 55D1     		bne	.L111
 663:../drivers/fsl_sai.c **** 
 1715              		.loc 1 663 0
 1716 0010 0220     		movs	r0, #2
 1717              	.LVL171:
 1718              	.L104:
 666:../drivers/fsl_sai.c ****     {
 667:../drivers/fsl_sai.c ****         channels = 1U;
 668:../drivers/fsl_sai.c ****     }
 669:../drivers/fsl_sai.c **** 
 670:../drivers/fsl_sai.c ****     if (format->isFrameSyncCompact)
 1719              		.loc 1 670 0
 1720 0012 AA7C     		ldrb	r2, [r5, #18]
 1721 0014 002A     		cmp	r2, #0
 1722 0016 53D0     		beq	.L105
 671:../drivers/fsl_sai.c ****     {
 672:../drivers/fsl_sai.c ****         bclk = format->sampleRate_Hz * format->bitWidth * channels;
 1723              		.loc 1 672 0
 1724 0018 6A68     		ldr	r2, [r5, #4]
 1725 001a 2968     		ldr	r1, [r5]
 1726              	.LVL172:
 1727 001c 5143     		muls	r1, r2
 1728 001e 4143     		muls	r1, r0
 1729              	.LVL173:
 673:../drivers/fsl_sai.c ****         val = (base->RCR4 & (~I2S_RCR4_SYWD_MASK));
 1730              		.loc 1 673 0
 1731 0020 9026     		movs	r6, #144
 1732 0022 A059     		ldr	r0, [r4, r6]
 1733              	.LVL174:
 1734 0024 314F     		ldr	r7, .L114
 1735 0026 3840     		ands	r0, r7
 1736              	.LVL175:
 674:../drivers/fsl_sai.c ****         val |= I2S_RCR4_SYWD(format->bitWidth - 1U);
 1737              		.loc 1 674 0
 1738 0028 013A     		subs	r2, r2, #1
 1739 002a 1202     		lsls	r2, r2, #8
 1740 002c F827     		movs	r7, #248
 1741 002e 7F01     		lsls	r7, r7, #5
 1742 0030 3A40     		ands	r2, r7
 1743 0032 0243     		orrs	r2, r0
 1744              	.LVL176:
 675:../drivers/fsl_sai.c ****         base->RCR4 = val;
 1745              		.loc 1 675 0
 1746 0034 A251     		str	r2, [r4, r6]
 1747              	.LVL177:
 1748              	.L106:
 676:../drivers/fsl_sai.c ****     }
 677:../drivers/fsl_sai.c ****     else
 678:../drivers/fsl_sai.c ****     {
 679:../drivers/fsl_sai.c ****         bclk = format->sampleRate_Hz * 32U * 2U;
 680:../drivers/fsl_sai.c ****     }
 681:../drivers/fsl_sai.c **** 
 682:../drivers/fsl_sai.c **** /* Compute the mclk */
 683:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER) && (FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER)
 684:../drivers/fsl_sai.c ****     /* Check if master clock divider enabled */
 685:../drivers/fsl_sai.c ****     if (base->MCR & I2S_MCR_MOE_MASK)
 686:../drivers/fsl_sai.c ****     {
 687:../drivers/fsl_sai.c ****         SAI_SetMasterClockDivider(base, format->masterClockHz, mclkSourceClockHz);
 688:../drivers/fsl_sai.c ****     }
 689:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_HAS_MCLKDIV_REGISTER */
 690:../drivers/fsl_sai.c **** 
 691:../drivers/fsl_sai.c ****     /* Set bclk if needed */
 692:../drivers/fsl_sai.c ****     if (base->RCR2 & I2S_RCR2_BCD_MASK)
 1749              		.loc 1 692 0
 1750 0036 8822     		movs	r2, #136
 1751 0038 A258     		ldr	r2, [r4, r2]
 1752 003a D201     		lsls	r2, r2, #7
 1753 003c 0FD5     		bpl	.L107
 693:../drivers/fsl_sai.c ****     {
 694:../drivers/fsl_sai.c ****         base->RCR2 &= ~I2S_RCR2_DIV_MASK;
 1754              		.loc 1 694 0
 1755 003e 8826     		movs	r6, #136
 1756 0040 A259     		ldr	r2, [r4, r6]
 1757 0042 FF27     		movs	r7, #255
 1758 0044 BA43     		bics	r2, r7
 1759 0046 A251     		str	r2, [r4, r6]
 695:../drivers/fsl_sai.c ****         base->RCR2 |= I2S_RCR2_DIV((bclkSourceClockHz / bclk) / 2U - 1U);
 1760              		.loc 1 695 0
 1761 0048 A259     		ldr	r2, [r4, r6]
 1762 004a 9046     		mov	r8, r2
 1763 004c 1800     		movs	r0, r3
 1764 004e FFF7FEFF 		bl	__aeabi_uidiv
 1765              	.LVL178:
 1766 0052 4008     		lsrs	r0, r0, #1
 1767 0054 0138     		subs	r0, r0, #1
 1768 0056 3840     		ands	r0, r7
 1769 0058 4346     		mov	r3, r8
 1770 005a 1843     		orrs	r0, r3
 1771 005c A051     		str	r0, [r4, r6]
 1772              	.L107:
 696:../drivers/fsl_sai.c ****     }
 697:../drivers/fsl_sai.c **** 
 698:../drivers/fsl_sai.c ****     /* Set bitWidth */
 699:../drivers/fsl_sai.c ****     val = (format->isFrameSyncCompact) ? (format->bitWidth - 1) : 31U;
 1773              		.loc 1 699 0
 1774 005e AB7C     		ldrb	r3, [r5, #18]
 1775 0060 002B     		cmp	r3, #0
 1776 0062 30D0     		beq	.L112
 1777              		.loc 1 699 0 is_stmt 0 discriminator 1
 1778 0064 6B68     		ldr	r3, [r5, #4]
 1779 0066 013B     		subs	r3, r3, #1
 1780              	.L108:
 1781              	.LVL179:
 700:../drivers/fsl_sai.c ****     if (format->protocol == kSAI_BusRightJustified)
 1782              		.loc 1 700 0 is_stmt 1 discriminator 4
 1783 0068 6A7C     		ldrb	r2, [r5, #17]
 1784 006a 012A     		cmp	r2, #1
 1785 006c 2DD0     		beq	.L113
 701:../drivers/fsl_sai.c ****     {
 702:../drivers/fsl_sai.c ****         base->RCR5 = I2S_RCR5_WNW(val) | I2S_RCR5_W0W(val) | I2S_RCR5_FBT(val);
 703:../drivers/fsl_sai.c ****     }
 704:../drivers/fsl_sai.c ****     else
 705:../drivers/fsl_sai.c ****     {
 706:../drivers/fsl_sai.c ****         base->RCR5 = I2S_RCR5_WNW(val) | I2S_RCR5_W0W(val) | I2S_RCR5_FBT(format->bitWidth - 1);
 1786              		.loc 1 706 0
 1787 006e 1A06     		lsls	r2, r3, #24
 1788 0070 F821     		movs	r1, #248
 1789 0072 4905     		lsls	r1, r1, #21
 1790 0074 0A40     		ands	r2, r1
 1791 0076 1B04     		lsls	r3, r3, #16
 1792              	.LVL180:
 1793 0078 F821     		movs	r1, #248
 1794 007a 4903     		lsls	r1, r1, #13
 1795 007c 0B40     		ands	r3, r1
 1796 007e 1343     		orrs	r3, r2
 1797 0080 6A68     		ldr	r2, [r5, #4]
 1798 0082 013A     		subs	r2, r2, #1
 1799 0084 1202     		lsls	r2, r2, #8
 1800 0086 F821     		movs	r1, #248
 1801 0088 4901     		lsls	r1, r1, #5
 1802 008a 0A40     		ands	r2, r1
 1803 008c 1343     		orrs	r3, r2
 1804 008e 9422     		movs	r2, #148
 1805 0090 A350     		str	r3, [r4, r2]
 1806              	.L110:
 707:../drivers/fsl_sai.c ****     }
 708:../drivers/fsl_sai.c **** 
 709:../drivers/fsl_sai.c ****     /* Set mono or stereo */
 710:../drivers/fsl_sai.c ****     base->RMR = (uint32_t)format->stereo;
 1807              		.loc 1 710 0
 1808 0092 2A7A     		ldrb	r2, [r5, #8]
 1809 0094 E023     		movs	r3, #224
 1810 0096 E250     		str	r2, [r4, r3]
 711:../drivers/fsl_sai.c **** 
 712:../drivers/fsl_sai.c ****     /* Set data channel */
 713:../drivers/fsl_sai.c ****     base->RCR3 &= ~I2S_RCR3_RCE_MASK;
 1811              		.loc 1 713 0
 1812 0098 8C22     		movs	r2, #140
 1813 009a A358     		ldr	r3, [r4, r2]
 1814 009c 1449     		ldr	r1, .L114+4
 1815 009e 0B40     		ands	r3, r1
 1816 00a0 A350     		str	r3, [r4, r2]
 714:../drivers/fsl_sai.c ****     base->RCR3 |= I2S_RCR3_RCE(1U << format->channel);
 1817              		.loc 1 714 0
 1818 00a2 A158     		ldr	r1, [r4, r2]
 1819 00a4 287C     		ldrb	r0, [r5, #16]
 1820 00a6 0123     		movs	r3, #1
 1821 00a8 8340     		lsls	r3, r3, r0
 1822 00aa 1B04     		lsls	r3, r3, #16
 1823 00ac 8020     		movs	r0, #128
 1824 00ae 4002     		lsls	r0, r0, #9
 1825 00b0 0340     		ands	r3, r0
 1826 00b2 0B43     		orrs	r3, r1
 1827 00b4 A350     		str	r3, [r4, r2]
 715:../drivers/fsl_sai.c **** 
 716:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 717:../drivers/fsl_sai.c ****     /* Set watermark */
 718:../drivers/fsl_sai.c ****     base->RCR1 = format->watermark;
 719:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT  */
 720:../drivers/fsl_sai.c **** }
 1828              		.loc 1 720 0
 1829              		@ sp needed
 1830              	.LVL181:
 1831              	.LVL182:
 1832 00b6 04BC     		pop	{r2}
 1833 00b8 9046     		mov	r8, r2
 1834 00ba F0BD     		pop	{r4, r5, r6, r7, pc}
 1835              	.LVL183:
 1836              	.L111:
 667:../drivers/fsl_sai.c ****     }
 1837              		.loc 1 667 0
 1838 00bc 0120     		movs	r0, #1
 1839              	.LVL184:
 1840 00be A8E7     		b	.L104
 1841              	.LVL185:
 1842              	.L105:
 679:../drivers/fsl_sai.c ****     }
 1843              		.loc 1 679 0
 1844 00c0 2A68     		ldr	r2, [r5]
 1845 00c2 9101     		lsls	r1, r2, #6
 1846              	.LVL186:
 1847 00c4 B7E7     		b	.L106
 1848              	.LVL187:
 1849              	.L112:
 699:../drivers/fsl_sai.c ****     if (format->protocol == kSAI_BusRightJustified)
 1850              		.loc 1 699 0
 1851 00c6 1F23     		movs	r3, #31
 1852 00c8 CEE7     		b	.L108
 1853              	.LVL188:
 1854              	.L113:
 702:../drivers/fsl_sai.c ****     }
 1855              		.loc 1 702 0
 1856 00ca 1A06     		lsls	r2, r3, #24
 1857 00cc F821     		movs	r1, #248
 1858 00ce 4905     		lsls	r1, r1, #21
 1859 00d0 0A40     		ands	r2, r1
 1860 00d2 1904     		lsls	r1, r3, #16
 1861 00d4 F820     		movs	r0, #248
 1862 00d6 4003     		lsls	r0, r0, #13
 1863 00d8 0140     		ands	r1, r0
 1864 00da 0A43     		orrs	r2, r1
 1865 00dc 1B02     		lsls	r3, r3, #8
 1866              	.LVL189:
 1867 00de F821     		movs	r1, #248
 1868 00e0 4901     		lsls	r1, r1, #5
 1869 00e2 0B40     		ands	r3, r1
 1870 00e4 1343     		orrs	r3, r2
 1871 00e6 9422     		movs	r2, #148
 1872 00e8 A350     		str	r3, [r4, r2]
 1873 00ea D2E7     		b	.L110
 1874              	.L115:
 1875              		.align	2
 1876              	.L114:
 1877 00ec FFE0FFFF 		.word	-7937
 1878 00f0 FFFFFEFF 		.word	-65537
 1879              		.cfi_endproc
 1880              	.LFE84:
 1882              		.section	.text.SAI_WriteBlocking,"ax",%progbits
 1883              		.align	1
 1884              		.global	SAI_WriteBlocking
 1885              		.syntax unified
 1886              		.code	16
 1887              		.thumb_func
 1888              		.fpu softvfp
 1890              	SAI_WriteBlocking:
 1891              	.LFB85:
 721:../drivers/fsl_sai.c **** 
 722:../drivers/fsl_sai.c **** void SAI_WriteBlocking(I2S_Type *base, uint32_t channel, uint32_t bitWidth, uint8_t *buffer, uint32
 723:../drivers/fsl_sai.c **** {
 1892              		.loc 1 723 0
 1893              		.cfi_startproc
 1894              		@ args = 4, pretend = 0, frame = 8
 1895              		@ frame_needed = 0, uses_anonymous_args = 0
 1896              	.LVL190:
 1897 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1898              		.cfi_def_cfa_offset 20
 1899              		.cfi_offset 4, -20
 1900              		.cfi_offset 5, -16
 1901              		.cfi_offset 6, -12
 1902              		.cfi_offset 7, -8
 1903              		.cfi_offset 14, -4
 1904 0002 CE46     		mov	lr, r9
 1905 0004 4746     		mov	r7, r8
 1906 0006 80B5     		push	{r7, lr}
 1907              		.cfi_def_cfa_offset 28
 1908              		.cfi_offset 8, -28
 1909              		.cfi_offset 9, -24
 1910 0008 85B0     		sub	sp, sp, #20
 1911              		.cfi_def_cfa_offset 48
 1912 000a 0400     		movs	r4, r0
 1913 000c 0291     		str	r1, [sp, #8]
 1914 000e 0392     		str	r2, [sp, #12]
 1915 0010 1D00     		movs	r5, r3
 1916 0012 0C9B     		ldr	r3, [sp, #48]
 1917              	.LVL191:
 1918 0014 9846     		mov	r8, r3
 1919              	.LVL192:
 724:../drivers/fsl_sai.c ****     uint32_t i = 0;
 725:../drivers/fsl_sai.c ****     uint8_t bytesPerWord = bitWidth / 8U;
 1920              		.loc 1 725 0
 1921 0016 D308     		lsrs	r3, r2, #3
 1922 0018 9946     		mov	r9, r3
 1923              	.LVL193:
 724:../drivers/fsl_sai.c ****     uint32_t i = 0;
 1924              		.loc 1 724 0
 1925 001a 0027     		movs	r7, #0
 726:../drivers/fsl_sai.c **** 
 727:../drivers/fsl_sai.c ****     while (i < size)
 1926              		.loc 1 727 0
 1927 001c 0EE0     		b	.L117
 1928              	.LVL194:
 1929              	.L118:
 728:../drivers/fsl_sai.c ****     {
 729:../drivers/fsl_sai.c ****         /* Wait until it can write data */
 730:../drivers/fsl_sai.c ****         while (!(base->TCSR & I2S_TCSR_FWF_MASK))
 1930              		.loc 1 730 0 discriminator 1
 1931 001e 2368     		ldr	r3, [r4]
 1932 0020 9B03     		lsls	r3, r3, #14
 1933 0022 FCD5     		bpl	.L118
 1934 0024 FF26     		movs	r6, #255
 1935 0026 4B46     		mov	r3, r9
 1936 0028 1E40     		ands	r6, r3
 731:../drivers/fsl_sai.c ****         {
 732:../drivers/fsl_sai.c ****         }
 733:../drivers/fsl_sai.c **** 
 734:../drivers/fsl_sai.c ****         SAI_WriteNonBlocking(base, channel, bitWidth, buffer, bytesPerWord);
 1937              		.loc 1 734 0
 1938 002a 0096     		str	r6, [sp]
 1939 002c 2B00     		movs	r3, r5
 1940 002e 039A     		ldr	r2, [sp, #12]
 1941 0030 0299     		ldr	r1, [sp, #8]
 1942 0032 2000     		movs	r0, r4
 1943 0034 FFF7FEFF 		bl	SAI_WriteNonBlocking
 1944              	.LVL195:
 735:../drivers/fsl_sai.c ****         buffer += bytesPerWord;
 1945              		.loc 1 735 0
 1946 0038 AD19     		adds	r5, r5, r6
 1947              	.LVL196:
 736:../drivers/fsl_sai.c ****         i += bytesPerWord;
 1948              		.loc 1 736 0
 1949 003a BF19     		adds	r7, r7, r6
 1950              	.LVL197:
 1951              	.L117:
 727:../drivers/fsl_sai.c ****     {
 1952              		.loc 1 727 0
 1953 003c 4745     		cmp	r7, r8
 1954 003e EED3     		bcc	.L118
 1955              	.L119:
 737:../drivers/fsl_sai.c ****     }
 738:../drivers/fsl_sai.c **** 
 739:../drivers/fsl_sai.c ****     /* Wait until the last data is sent */
 740:../drivers/fsl_sai.c ****     while (!(base->TCSR & I2S_TCSR_FWF_MASK))
 1956              		.loc 1 740 0 discriminator 1
 1957 0040 2368     		ldr	r3, [r4]
 1958 0042 9B03     		lsls	r3, r3, #14
 1959 0044 FCD5     		bpl	.L119
 741:../drivers/fsl_sai.c ****     {
 742:../drivers/fsl_sai.c ****     }
 743:../drivers/fsl_sai.c **** }
 1960              		.loc 1 743 0
 1961 0046 05B0     		add	sp, sp, #20
 1962              		@ sp needed
 1963              	.LVL198:
 1964              	.LVL199:
 1965              	.LVL200:
 1966              	.LVL201:
 1967 0048 0CBC     		pop	{r2, r3}
 1968 004a 9046     		mov	r8, r2
 1969 004c 9946     		mov	r9, r3
 1970 004e F0BD     		pop	{r4, r5, r6, r7, pc}
 1971              		.cfi_endproc
 1972              	.LFE85:
 1974              		.section	.text.SAI_ReadBlocking,"ax",%progbits
 1975              		.align	1
 1976              		.global	SAI_ReadBlocking
 1977              		.syntax unified
 1978              		.code	16
 1979              		.thumb_func
 1980              		.fpu softvfp
 1982              	SAI_ReadBlocking:
 1983              	.LFB86:
 744:../drivers/fsl_sai.c **** 
 745:../drivers/fsl_sai.c **** void SAI_ReadBlocking(I2S_Type *base, uint32_t channel, uint32_t bitWidth, uint8_t *buffer, uint32_
 746:../drivers/fsl_sai.c **** {
 1984              		.loc 1 746 0
 1985              		.cfi_startproc
 1986              		@ args = 4, pretend = 0, frame = 8
 1987              		@ frame_needed = 0, uses_anonymous_args = 0
 1988              	.LVL202:
 1989 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1990              		.cfi_def_cfa_offset 20
 1991              		.cfi_offset 4, -20
 1992              		.cfi_offset 5, -16
 1993              		.cfi_offset 6, -12
 1994              		.cfi_offset 7, -8
 1995              		.cfi_offset 14, -4
 1996 0002 CE46     		mov	lr, r9
 1997 0004 4746     		mov	r7, r8
 1998 0006 80B5     		push	{r7, lr}
 1999              		.cfi_def_cfa_offset 28
 2000              		.cfi_offset 8, -28
 2001              		.cfi_offset 9, -24
 2002 0008 85B0     		sub	sp, sp, #20
 2003              		.cfi_def_cfa_offset 48
 2004 000a 0400     		movs	r4, r0
 2005 000c 0291     		str	r1, [sp, #8]
 2006 000e 0392     		str	r2, [sp, #12]
 2007 0010 1D00     		movs	r5, r3
 2008 0012 0C9B     		ldr	r3, [sp, #48]
 2009              	.LVL203:
 2010 0014 9846     		mov	r8, r3
 2011              	.LVL204:
 747:../drivers/fsl_sai.c ****     uint32_t i = 0;
 748:../drivers/fsl_sai.c ****     uint8_t bytesPerWord = bitWidth / 8U;
 2012              		.loc 1 748 0
 2013 0016 D308     		lsrs	r3, r2, #3
 2014 0018 9946     		mov	r9, r3
 2015              	.LVL205:
 747:../drivers/fsl_sai.c ****     uint32_t i = 0;
 2016              		.loc 1 747 0
 2017 001a 0027     		movs	r7, #0
 749:../drivers/fsl_sai.c **** 
 750:../drivers/fsl_sai.c ****     while (i < size)
 2018              		.loc 1 750 0
 2019 001c 0FE0     		b	.L121
 2020              	.LVL206:
 2021              	.L122:
 751:../drivers/fsl_sai.c ****     {
 752:../drivers/fsl_sai.c ****         /* Wait until data is received */
 753:../drivers/fsl_sai.c ****         while (!(base->RCSR & I2S_RCSR_FWF_MASK))
 2022              		.loc 1 753 0 discriminator 1
 2023 001e 8023     		movs	r3, #128
 2024 0020 E358     		ldr	r3, [r4, r3]
 2025 0022 9B03     		lsls	r3, r3, #14
 2026 0024 FBD5     		bpl	.L122
 2027 0026 FF26     		movs	r6, #255
 2028 0028 4B46     		mov	r3, r9
 2029 002a 1E40     		ands	r6, r3
 754:../drivers/fsl_sai.c ****         {
 755:../drivers/fsl_sai.c ****         }
 756:../drivers/fsl_sai.c **** 
 757:../drivers/fsl_sai.c ****         SAI_ReadNonBlocking(base, channel, bitWidth, buffer, bytesPerWord);
 2030              		.loc 1 757 0
 2031 002c 0096     		str	r6, [sp]
 2032 002e 2B00     		movs	r3, r5
 2033 0030 039A     		ldr	r2, [sp, #12]
 2034 0032 0299     		ldr	r1, [sp, #8]
 2035 0034 2000     		movs	r0, r4
 2036 0036 FFF7FEFF 		bl	SAI_ReadNonBlocking
 2037              	.LVL207:
 758:../drivers/fsl_sai.c ****         buffer += bytesPerWord;
 2038              		.loc 1 758 0
 2039 003a AD19     		adds	r5, r5, r6
 2040              	.LVL208:
 759:../drivers/fsl_sai.c ****         i += bytesPerWord;
 2041              		.loc 1 759 0
 2042 003c BF19     		adds	r7, r7, r6
 2043              	.LVL209:
 2044              	.L121:
 750:../drivers/fsl_sai.c ****     {
 2045              		.loc 1 750 0
 2046 003e 4745     		cmp	r7, r8
 2047 0040 EDD3     		bcc	.L122
 760:../drivers/fsl_sai.c ****     }
 761:../drivers/fsl_sai.c **** }
 2048              		.loc 1 761 0
 2049 0042 05B0     		add	sp, sp, #20
 2050              		@ sp needed
 2051              	.LVL210:
 2052              	.LVL211:
 2053              	.LVL212:
 2054              	.LVL213:
 2055 0044 0CBC     		pop	{r2, r3}
 2056 0046 9046     		mov	r8, r2
 2057 0048 9946     		mov	r9, r3
 2058 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 2059              		.cfi_endproc
 2060              	.LFE86:
 2062              		.section	.text.SAI_TransferTxCreateHandle,"ax",%progbits
 2063              		.align	1
 2064              		.global	SAI_TransferTxCreateHandle
 2065              		.syntax unified
 2066              		.code	16
 2067              		.thumb_func
 2068              		.fpu softvfp
 2070              	SAI_TransferTxCreateHandle:
 2071              	.LFB87:
 762:../drivers/fsl_sai.c **** 
 763:../drivers/fsl_sai.c **** void SAI_TransferTxCreateHandle(I2S_Type *base, sai_handle_t *handle, sai_transfer_callback_t callb
 764:../drivers/fsl_sai.c **** {
 2072              		.loc 1 764 0
 2073              		.cfi_startproc
 2074              		@ args = 0, pretend = 0, frame = 0
 2075              		@ frame_needed = 0, uses_anonymous_args = 0
 2076              	.LVL214:
 2077 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2078              		.cfi_def_cfa_offset 24
 2079              		.cfi_offset 3, -24
 2080              		.cfi_offset 4, -20
 2081              		.cfi_offset 5, -16
 2082              		.cfi_offset 6, -12
 2083              		.cfi_offset 7, -8
 2084              		.cfi_offset 14, -4
 2085 0002 0700     		movs	r7, r0
 2086 0004 0C00     		movs	r4, r1
 2087 0006 1600     		movs	r6, r2
 2088 0008 1D00     		movs	r5, r3
 765:../drivers/fsl_sai.c ****     assert(handle);
 766:../drivers/fsl_sai.c **** 
 767:../drivers/fsl_sai.c ****     /* Zero the handle */
 768:../drivers/fsl_sai.c ****     memset(handle, 0, sizeof(*handle));
 2089              		.loc 1 768 0
 2090 000a 4422     		movs	r2, #68
 2091              	.LVL215:
 2092 000c 0021     		movs	r1, #0
 2093              	.LVL216:
 2094 000e 2000     		movs	r0, r4
 2095              	.LVL217:
 2096 0010 FFF7FEFF 		bl	memset
 2097              	.LVL218:
 769:../drivers/fsl_sai.c **** 
 770:../drivers/fsl_sai.c ****     s_saiHandle[SAI_GetInstance(base)][0] = handle;
 2098              		.loc 1 770 0
 2099 0014 3800     		movs	r0, r7
 2100 0016 FFF7FEFF 		bl	SAI_GetInstance
 2101              	.LVL219:
 2102 001a C000     		lsls	r0, r0, #3
 2103 001c 054B     		ldr	r3, .L124
 2104 001e C450     		str	r4, [r0, r3]
 771:../drivers/fsl_sai.c **** 
 772:../drivers/fsl_sai.c ****     handle->callback = callback;
 2105              		.loc 1 772 0
 2106 0020 6660     		str	r6, [r4, #4]
 773:../drivers/fsl_sai.c ****     handle->userData = userData;
 2107              		.loc 1 773 0
 2108 0022 A560     		str	r5, [r4, #8]
 774:../drivers/fsl_sai.c **** 
 775:../drivers/fsl_sai.c ****     /* Set the isr pointer */
 776:../drivers/fsl_sai.c ****     s_saiTxIsr = SAI_TransferTxHandleIRQ;
 2109              		.loc 1 776 0
 2110 0024 044B     		ldr	r3, .L124+4
 2111 0026 054A     		ldr	r2, .L124+8
 2112 0028 1A60     		str	r2, [r3]
 2113              	.LVL220:
 2114              	.LBB46:
 2115              	.LBB47:
 2116              	.LBB48:
 2117              		.file 4 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 2118              		.loc 4 735 0
 2119 002a 054B     		ldr	r3, .L124+12
 2120 002c 8022     		movs	r2, #128
 2121 002e 1204     		lsls	r2, r2, #16
 2122 0030 1A60     		str	r2, [r3]
 2123              	.LVL221:
 2124              	.LBE48:
 2125              	.LBE47:
 2126              	.LBE46:
 777:../drivers/fsl_sai.c **** 
 778:../drivers/fsl_sai.c ****     /* Enable Tx irq */
 779:../drivers/fsl_sai.c ****     EnableIRQ(s_saiTxIRQ[SAI_GetInstance(base)]);
 780:../drivers/fsl_sai.c **** }
 2127              		.loc 1 780 0
 2128              		@ sp needed
 2129              	.LVL222:
 2130              	.LVL223:
 2131              	.LVL224:
 2132              	.LVL225:
 2133 0032 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2134              	.L125:
 2135              		.align	2
 2136              	.L124:
 2137 0034 00000000 		.word	s_saiHandle
 2138 0038 00000000 		.word	.LANCHOR0
 2139 003c 00000000 		.word	SAI_TransferTxHandleIRQ
 2140 0040 00E100E0 		.word	-536813312
 2141              		.cfi_endproc
 2142              	.LFE87:
 2144              		.section	.text.SAI_TransferRxCreateHandle,"ax",%progbits
 2145              		.align	1
 2146              		.global	SAI_TransferRxCreateHandle
 2147              		.syntax unified
 2148              		.code	16
 2149              		.thumb_func
 2150              		.fpu softvfp
 2152              	SAI_TransferRxCreateHandle:
 2153              	.LFB88:
 781:../drivers/fsl_sai.c **** 
 782:../drivers/fsl_sai.c **** void SAI_TransferRxCreateHandle(I2S_Type *base, sai_handle_t *handle, sai_transfer_callback_t callb
 783:../drivers/fsl_sai.c **** {
 2154              		.loc 1 783 0
 2155              		.cfi_startproc
 2156              		@ args = 0, pretend = 0, frame = 0
 2157              		@ frame_needed = 0, uses_anonymous_args = 0
 2158              	.LVL226:
 2159 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2160              		.cfi_def_cfa_offset 24
 2161              		.cfi_offset 3, -24
 2162              		.cfi_offset 4, -20
 2163              		.cfi_offset 5, -16
 2164              		.cfi_offset 6, -12
 2165              		.cfi_offset 7, -8
 2166              		.cfi_offset 14, -4
 2167 0002 0700     		movs	r7, r0
 2168 0004 0C00     		movs	r4, r1
 2169 0006 1600     		movs	r6, r2
 2170 0008 1D00     		movs	r5, r3
 784:../drivers/fsl_sai.c ****     assert(handle);
 785:../drivers/fsl_sai.c **** 
 786:../drivers/fsl_sai.c ****     /* Zero the handle */
 787:../drivers/fsl_sai.c ****     memset(handle, 0, sizeof(*handle));
 2171              		.loc 1 787 0
 2172 000a 4422     		movs	r2, #68
 2173              	.LVL227:
 2174 000c 0021     		movs	r1, #0
 2175              	.LVL228:
 2176 000e 2000     		movs	r0, r4
 2177              	.LVL229:
 2178 0010 FFF7FEFF 		bl	memset
 2179              	.LVL230:
 788:../drivers/fsl_sai.c **** 
 789:../drivers/fsl_sai.c ****     s_saiHandle[SAI_GetInstance(base)][1] = handle;
 2180              		.loc 1 789 0
 2181 0014 3800     		movs	r0, r7
 2182 0016 FFF7FEFF 		bl	SAI_GetInstance
 2183              	.LVL231:
 2184 001a C300     		lsls	r3, r0, #3
 2185 001c 0648     		ldr	r0, .L127
 2186 001e C018     		adds	r0, r0, r3
 2187 0020 4460     		str	r4, [r0, #4]
 790:../drivers/fsl_sai.c **** 
 791:../drivers/fsl_sai.c ****     handle->callback = callback;
 2188              		.loc 1 791 0
 2189 0022 6660     		str	r6, [r4, #4]
 792:../drivers/fsl_sai.c ****     handle->userData = userData;
 2190              		.loc 1 792 0
 2191 0024 A560     		str	r5, [r4, #8]
 793:../drivers/fsl_sai.c **** 
 794:../drivers/fsl_sai.c ****     /* Set the isr pointer */
 795:../drivers/fsl_sai.c ****     s_saiRxIsr = SAI_TransferRxHandleIRQ;
 2192              		.loc 1 795 0
 2193 0026 054B     		ldr	r3, .L127+4
 2194 0028 054A     		ldr	r2, .L127+8
 2195 002a 1A60     		str	r2, [r3]
 2196              	.LVL232:
 2197              	.LBB49:
 2198              	.LBB50:
 2199              	.LBB51:
 2200              		.loc 4 735 0
 2201 002c 054B     		ldr	r3, .L127+12
 2202 002e 8022     		movs	r2, #128
 2203 0030 1204     		lsls	r2, r2, #16
 2204 0032 1A60     		str	r2, [r3]
 2205              	.LVL233:
 2206              	.LBE51:
 2207              	.LBE50:
 2208              	.LBE49:
 796:../drivers/fsl_sai.c **** 
 797:../drivers/fsl_sai.c ****     /* Enable Rx irq */
 798:../drivers/fsl_sai.c ****     EnableIRQ(s_saiRxIRQ[SAI_GetInstance(base)]);
 799:../drivers/fsl_sai.c **** }
 2209              		.loc 1 799 0
 2210              		@ sp needed
 2211              	.LVL234:
 2212              	.LVL235:
 2213              	.LVL236:
 2214              	.LVL237:
 2215 0034 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2216              	.L128:
 2217 0036 C046     		.align	2
 2218              	.L127:
 2219 0038 00000000 		.word	s_saiHandle
 2220 003c 00000000 		.word	.LANCHOR1
 2221 0040 00000000 		.word	SAI_TransferRxHandleIRQ
 2222 0044 00E100E0 		.word	-536813312
 2223              		.cfi_endproc
 2224              	.LFE88:
 2226              		.section	.text.SAI_TransferTxSetFormat,"ax",%progbits
 2227              		.align	1
 2228              		.global	SAI_TransferTxSetFormat
 2229              		.syntax unified
 2230              		.code	16
 2231              		.thumb_func
 2232              		.fpu softvfp
 2234              	SAI_TransferTxSetFormat:
 2235              	.LFB89:
 800:../drivers/fsl_sai.c **** 
 801:../drivers/fsl_sai.c **** status_t SAI_TransferTxSetFormat(I2S_Type *base,
 802:../drivers/fsl_sai.c ****                                  sai_handle_t *handle,
 803:../drivers/fsl_sai.c ****                                  sai_transfer_format_t *format,
 804:../drivers/fsl_sai.c ****                                  uint32_t mclkSourceClockHz,
 805:../drivers/fsl_sai.c ****                                  uint32_t bclkSourceClockHz)
 806:../drivers/fsl_sai.c **** {
 2236              		.loc 1 806 0
 2237              		.cfi_startproc
 2238              		@ args = 4, pretend = 0, frame = 0
 2239              		@ frame_needed = 0, uses_anonymous_args = 0
 2240              	.LVL238:
 2241 0000 70B5     		push	{r4, r5, r6, lr}
 2242              		.cfi_def_cfa_offset 16
 2243              		.cfi_offset 4, -16
 2244              		.cfi_offset 5, -12
 2245              		.cfi_offset 6, -8
 2246              		.cfi_offset 14, -4
 2247 0002 1400     		movs	r4, r2
 2248 0004 1A00     		movs	r2, r3
 2249              	.LVL239:
 807:../drivers/fsl_sai.c ****     assert(handle);
 808:../drivers/fsl_sai.c **** 
 809:../drivers/fsl_sai.c ****     if ((mclkSourceClockHz < format->sampleRate_Hz) || (bclkSourceClockHz < format->sampleRate_Hz))
 2250              		.loc 1 809 0
 2251 0006 2368     		ldr	r3, [r4]
 2252              	.LVL240:
 2253 0008 9342     		cmp	r3, r2
 2254 000a 0CD8     		bhi	.L131
 2255              		.loc 1 809 0 is_stmt 0 discriminator 1
 2256 000c 049D     		ldr	r5, [sp, #16]
 2257 000e AB42     		cmp	r3, r5
 2258 0010 0BD8     		bhi	.L132
 810:../drivers/fsl_sai.c ****     {
 811:../drivers/fsl_sai.c ****         return kStatus_InvalidArgument;
 812:../drivers/fsl_sai.c ****     }
 813:../drivers/fsl_sai.c **** 
 814:../drivers/fsl_sai.c ****     /* Copy format to handle */
 815:../drivers/fsl_sai.c ****     handle->bitWidth = format->bitWidth;
 2259              		.loc 1 815 0 is_stmt 1
 2260 0012 6368     		ldr	r3, [r4, #4]
 2261 0014 0B73     		strb	r3, [r1, #12]
 816:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 817:../drivers/fsl_sai.c ****     handle->watermark = format->watermark;
 818:../drivers/fsl_sai.c **** #endif
 819:../drivers/fsl_sai.c ****     handle->channel = format->channel;
 2262              		.loc 1 819 0
 2263 0016 237C     		ldrb	r3, [r4, #16]
 2264 0018 4B73     		strb	r3, [r1, #13]
 820:../drivers/fsl_sai.c **** 
 821:../drivers/fsl_sai.c ****     SAI_TxSetFormat(base, format, mclkSourceClockHz, bclkSourceClockHz);
 2265              		.loc 1 821 0
 2266 001a 2B00     		movs	r3, r5
 2267 001c 2100     		movs	r1, r4
 2268              	.LVL241:
 2269 001e FFF7FEFF 		bl	SAI_TxSetFormat
 2270              	.LVL242:
 822:../drivers/fsl_sai.c **** 
 823:../drivers/fsl_sai.c ****     return kStatus_Success;
 2271              		.loc 1 823 0
 2272 0022 0020     		movs	r0, #0
 2273              	.L129:
 824:../drivers/fsl_sai.c **** }
 2274              		.loc 1 824 0
 2275              		@ sp needed
 2276              	.LVL243:
 2277 0024 70BD     		pop	{r4, r5, r6, pc}
 2278              	.LVL244:
 2279              	.L131:
 811:../drivers/fsl_sai.c ****     }
 2280              		.loc 1 811 0
 2281 0026 0420     		movs	r0, #4
 2282              	.LVL245:
 2283 0028 FCE7     		b	.L129
 2284              	.LVL246:
 2285              	.L132:
 2286 002a 0420     		movs	r0, #4
 2287              	.LVL247:
 2288 002c FAE7     		b	.L129
 2289              		.cfi_endproc
 2290              	.LFE89:
 2292              		.section	.text.SAI_TransferRxSetFormat,"ax",%progbits
 2293              		.align	1
 2294              		.global	SAI_TransferRxSetFormat
 2295              		.syntax unified
 2296              		.code	16
 2297              		.thumb_func
 2298              		.fpu softvfp
 2300              	SAI_TransferRxSetFormat:
 2301              	.LFB90:
 825:../drivers/fsl_sai.c **** 
 826:../drivers/fsl_sai.c **** status_t SAI_TransferRxSetFormat(I2S_Type *base,
 827:../drivers/fsl_sai.c ****                                  sai_handle_t *handle,
 828:../drivers/fsl_sai.c ****                                  sai_transfer_format_t *format,
 829:../drivers/fsl_sai.c ****                                  uint32_t mclkSourceClockHz,
 830:../drivers/fsl_sai.c ****                                  uint32_t bclkSourceClockHz)
 831:../drivers/fsl_sai.c **** {
 2302              		.loc 1 831 0
 2303              		.cfi_startproc
 2304              		@ args = 4, pretend = 0, frame = 0
 2305              		@ frame_needed = 0, uses_anonymous_args = 0
 2306              	.LVL248:
 2307 0000 70B5     		push	{r4, r5, r6, lr}
 2308              		.cfi_def_cfa_offset 16
 2309              		.cfi_offset 4, -16
 2310              		.cfi_offset 5, -12
 2311              		.cfi_offset 6, -8
 2312              		.cfi_offset 14, -4
 2313 0002 1400     		movs	r4, r2
 2314 0004 1A00     		movs	r2, r3
 2315              	.LVL249:
 832:../drivers/fsl_sai.c ****     assert(handle);
 833:../drivers/fsl_sai.c **** 
 834:../drivers/fsl_sai.c ****     if ((mclkSourceClockHz < format->sampleRate_Hz) || (bclkSourceClockHz < format->sampleRate_Hz))
 2316              		.loc 1 834 0
 2317 0006 2368     		ldr	r3, [r4]
 2318              	.LVL250:
 2319 0008 9342     		cmp	r3, r2
 2320 000a 0CD8     		bhi	.L135
 2321              		.loc 1 834 0 is_stmt 0 discriminator 1
 2322 000c 049D     		ldr	r5, [sp, #16]
 2323 000e AB42     		cmp	r3, r5
 2324 0010 0BD8     		bhi	.L136
 835:../drivers/fsl_sai.c ****     {
 836:../drivers/fsl_sai.c ****         return kStatus_InvalidArgument;
 837:../drivers/fsl_sai.c ****     }
 838:../drivers/fsl_sai.c **** 
 839:../drivers/fsl_sai.c ****     /* Copy format to handle */
 840:../drivers/fsl_sai.c ****     handle->bitWidth = format->bitWidth;
 2325              		.loc 1 840 0 is_stmt 1
 2326 0012 6368     		ldr	r3, [r4, #4]
 2327 0014 0B73     		strb	r3, [r1, #12]
 841:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 842:../drivers/fsl_sai.c ****     handle->watermark = format->watermark;
 843:../drivers/fsl_sai.c **** #endif
 844:../drivers/fsl_sai.c ****     handle->channel = format->channel;
 2328              		.loc 1 844 0
 2329 0016 237C     		ldrb	r3, [r4, #16]
 2330 0018 4B73     		strb	r3, [r1, #13]
 845:../drivers/fsl_sai.c **** 
 846:../drivers/fsl_sai.c ****     SAI_RxSetFormat(base, format, mclkSourceClockHz, bclkSourceClockHz);
 2331              		.loc 1 846 0
 2332 001a 2B00     		movs	r3, r5
 2333 001c 2100     		movs	r1, r4
 2334              	.LVL251:
 2335 001e FFF7FEFF 		bl	SAI_RxSetFormat
 2336              	.LVL252:
 847:../drivers/fsl_sai.c **** 
 848:../drivers/fsl_sai.c ****     return kStatus_Success;
 2337              		.loc 1 848 0
 2338 0022 0020     		movs	r0, #0
 2339              	.L133:
 849:../drivers/fsl_sai.c **** }
 2340              		.loc 1 849 0
 2341              		@ sp needed
 2342              	.LVL253:
 2343 0024 70BD     		pop	{r4, r5, r6, pc}
 2344              	.LVL254:
 2345              	.L135:
 836:../drivers/fsl_sai.c ****     }
 2346              		.loc 1 836 0
 2347 0026 0420     		movs	r0, #4
 2348              	.LVL255:
 2349 0028 FCE7     		b	.L133
 2350              	.LVL256:
 2351              	.L136:
 2352 002a 0420     		movs	r0, #4
 2353              	.LVL257:
 2354 002c FAE7     		b	.L133
 2355              		.cfi_endproc
 2356              	.LFE90:
 2358              		.section	.text.SAI_TransferSendNonBlocking,"ax",%progbits
 2359              		.align	1
 2360              		.global	SAI_TransferSendNonBlocking
 2361              		.syntax unified
 2362              		.code	16
 2363              		.thumb_func
 2364              		.fpu softvfp
 2366              	SAI_TransferSendNonBlocking:
 2367              	.LFB91:
 850:../drivers/fsl_sai.c **** 
 851:../drivers/fsl_sai.c **** status_t SAI_TransferSendNonBlocking(I2S_Type *base, sai_handle_t *handle, sai_transfer_t *xfer)
 852:../drivers/fsl_sai.c **** {
 2368              		.loc 1 852 0
 2369              		.cfi_startproc
 2370              		@ args = 0, pretend = 0, frame = 0
 2371              		@ frame_needed = 0, uses_anonymous_args = 0
 2372              	.LVL258:
 2373 0000 70B5     		push	{r4, r5, r6, lr}
 2374              		.cfi_def_cfa_offset 16
 2375              		.cfi_offset 4, -16
 2376              		.cfi_offset 5, -12
 2377              		.cfi_offset 6, -8
 2378              		.cfi_offset 14, -4
 853:../drivers/fsl_sai.c ****     assert(handle);
 854:../drivers/fsl_sai.c **** 
 855:../drivers/fsl_sai.c ****     /* Check if the queue is full */
 856:../drivers/fsl_sai.c ****     if (handle->saiQueue[handle->queueUser].data)
 2379              		.loc 1 856 0
 2380 0002 4023     		movs	r3, #64
 2381 0004 CB5C     		ldrb	r3, [r1, r3]
 2382 0006 0233     		adds	r3, r3, #2
 2383 0008 DB00     		lsls	r3, r3, #3
 2384 000a 5B58     		ldr	r3, [r3, r1]
 2385 000c 002B     		cmp	r3, #0
 2386 000e 02D0     		beq	.L140
 857:../drivers/fsl_sai.c ****     {
 858:../drivers/fsl_sai.c ****         return kStatus_SAI_QueueFull;
 2387              		.loc 1 858 0
 2388 0010 EE20     		movs	r0, #238
 2389              	.LVL259:
 2390 0012 C000     		lsls	r0, r0, #3
 2391              	.LVL260:
 2392              	.L137:
 859:../drivers/fsl_sai.c ****     }
 860:../drivers/fsl_sai.c **** 
 861:../drivers/fsl_sai.c ****     /* Add into queue */
 862:../drivers/fsl_sai.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 863:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 864:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 865:../drivers/fsl_sai.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 866:../drivers/fsl_sai.c **** 
 867:../drivers/fsl_sai.c ****     /* Set the state to busy */
 868:../drivers/fsl_sai.c ****     handle->state = kSAI_Busy;
 869:../drivers/fsl_sai.c **** 
 870:../drivers/fsl_sai.c **** /* Enable interrupt */
 871:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 872:../drivers/fsl_sai.c ****     /* Use FIFO request interrupt and fifo error*/
 873:../drivers/fsl_sai.c ****     SAI_TxEnableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFORequestInterruptEnable);
 874:../drivers/fsl_sai.c **** #else
 875:../drivers/fsl_sai.c ****     SAI_TxEnableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFOWarningInterruptEnable);
 876:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT */
 877:../drivers/fsl_sai.c **** 
 878:../drivers/fsl_sai.c ****     /* Enable Tx transfer */
 879:../drivers/fsl_sai.c ****     SAI_TxEnable(base, true);
 880:../drivers/fsl_sai.c **** 
 881:../drivers/fsl_sai.c ****     return kStatus_Success;
 882:../drivers/fsl_sai.c **** }
 2393              		.loc 1 882 0
 2394              		@ sp needed
 2395 0014 70BD     		pop	{r4, r5, r6, pc}
 2396              	.LVL261:
 2397              	.L140:
 862:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 2398              		.loc 1 862 0
 2399 0016 4024     		movs	r4, #64
 2400 0018 0B5D     		ldrb	r3, [r1, r4]
 2401 001a 0C33     		adds	r3, r3, #12
 2402 001c 9B00     		lsls	r3, r3, #2
 2403 001e 5568     		ldr	r5, [r2, #4]
 2404 0020 5D50     		str	r5, [r3, r1]
 863:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 2405              		.loc 1 863 0
 2406 0022 0B5D     		ldrb	r3, [r1, r4]
 2407 0024 0233     		adds	r3, r3, #2
 2408 0026 DB00     		lsls	r3, r3, #3
 2409 0028 1568     		ldr	r5, [r2]
 2410 002a 5D50     		str	r5, [r3, r1]
 864:../drivers/fsl_sai.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 2411              		.loc 1 864 0
 2412 002c 0B5D     		ldrb	r3, [r1, r4]
 2413 002e 5268     		ldr	r2, [r2, #4]
 2414              	.LVL262:
 2415 0030 0233     		adds	r3, r3, #2
 2416 0032 DB00     		lsls	r3, r3, #3
 2417 0034 CB18     		adds	r3, r1, r3
 2418 0036 5A60     		str	r2, [r3, #4]
 865:../drivers/fsl_sai.c **** 
 2419              		.loc 1 865 0
 2420 0038 0A5D     		ldrb	r2, [r1, r4]
 2421 003a 0132     		adds	r2, r2, #1
 2422 003c 0323     		movs	r3, #3
 2423 003e 1340     		ands	r3, r2
 2424 0040 0B55     		strb	r3, [r1, r4]
 868:../drivers/fsl_sai.c **** 
 2425              		.loc 1 868 0
 2426 0042 0023     		movs	r3, #0
 2427 0044 0B60     		str	r3, [r1]
 2428              	.LVL263:
 2429              	.LBB52:
 2430              	.LBB53:
 434:../drivers/fsl_sai.h **** }
 435:../drivers/fsl_sai.h **** 
 436:../drivers/fsl_sai.h **** /*!
 437:../drivers/fsl_sai.h ****  * @brief Do software reset or FIFO reset .
 438:../drivers/fsl_sai.h ****  *
 439:../drivers/fsl_sai.h ****  * FIFO reset means clear all the data in the FIFO, and make the FIFO pointer both to 0.
 440:../drivers/fsl_sai.h ****  * Software reset means claer the Tx internal logic, including the bit clock, frame count etc. But 
 441:../drivers/fsl_sai.h ****  * reset will not clear any configuration registers like TCR1~TCR5.
 442:../drivers/fsl_sai.h ****  * This function will also clear all the error flags such as FIFO error, sync error etc.
 443:../drivers/fsl_sai.h ****  *
 444:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 445:../drivers/fsl_sai.h ****  * @param type Reset type, FIFO reset or software reset
 446:../drivers/fsl_sai.h ****  */
 447:../drivers/fsl_sai.h **** void SAI_TxSoftwareReset(I2S_Type *base, sai_reset_type_t type);
 448:../drivers/fsl_sai.h **** 
 449:../drivers/fsl_sai.h **** /*!
 450:../drivers/fsl_sai.h ****  * @brief Do software reset or FIFO reset .
 451:../drivers/fsl_sai.h ****  *
 452:../drivers/fsl_sai.h ****  * FIFO reset means clear all the data in the FIFO, and make the FIFO pointer both to 0.
 453:../drivers/fsl_sai.h ****  * Software reset means claer the Rx internal logic, including the bit clock, frame count etc. But 
 454:../drivers/fsl_sai.h ****  * reset will not clear any configuration registers like RCR1~RCR5.
 455:../drivers/fsl_sai.h ****  * This function will also clear all the error flags such as FIFO error, sync error etc.
 456:../drivers/fsl_sai.h ****  *
 457:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 458:../drivers/fsl_sai.h ****  * @param type Reset type, FIFO reset or software reset
 459:../drivers/fsl_sai.h ****  */
 460:../drivers/fsl_sai.h **** void SAI_RxSoftwareReset(I2S_Type *base, sai_reset_type_t type);
 461:../drivers/fsl_sai.h **** 
 462:../drivers/fsl_sai.h **** /*!
 463:../drivers/fsl_sai.h ****  * @brief Set the Tx channel FIFO enable mask.
 464:../drivers/fsl_sai.h ****  *
 465:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 466:../drivers/fsl_sai.h ****  * @param mask Channel enable mask, 0 means all channel FIFO disabled, 1 means channel 0 enabled,
 467:../drivers/fsl_sai.h ****  * 3 means both channel 0 and channel 1 enabled.
 468:../drivers/fsl_sai.h ****  */
 469:../drivers/fsl_sai.h **** void SAI_TxSetChannelFIFOMask(I2S_Type *base, uint8_t mask);
 470:../drivers/fsl_sai.h **** 
 471:../drivers/fsl_sai.h **** /*!
 472:../drivers/fsl_sai.h ****  * @brief Set the Rx channel FIFO enable mask.
 473:../drivers/fsl_sai.h ****  *
 474:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 475:../drivers/fsl_sai.h ****  * @param mask Channel enable mask, 0 means all channel FIFO disabled, 1 means channel 0 enabled,
 476:../drivers/fsl_sai.h ****  * 3 means both channel 0 and channel 1 enabled.
 477:../drivers/fsl_sai.h ****  */
 478:../drivers/fsl_sai.h **** void SAI_RxSetChannelFIFOMask(I2S_Type *base, uint8_t mask);
 479:../drivers/fsl_sai.h **** 
 480:../drivers/fsl_sai.h **** /*! @} */
 481:../drivers/fsl_sai.h **** 
 482:../drivers/fsl_sai.h **** /*!
 483:../drivers/fsl_sai.h ****  * @name Interrupts
 484:../drivers/fsl_sai.h ****  * @{
 485:../drivers/fsl_sai.h ****  */
 486:../drivers/fsl_sai.h **** 
 487:../drivers/fsl_sai.h **** /*!
 488:../drivers/fsl_sai.h ****  * @brief Enables the SAI Tx interrupt requests.
 489:../drivers/fsl_sai.h ****  *
 490:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 491:../drivers/fsl_sai.h ****  * @param mask interrupt source
 492:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 493:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 494:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 495:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 496:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 497:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 498:../drivers/fsl_sai.h ****  */
 499:../drivers/fsl_sai.h **** static inline void SAI_TxEnableInterrupts(I2S_Type *base, uint32_t mask)
 500:../drivers/fsl_sai.h **** {
 501:../drivers/fsl_sai.h ****     base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | mask);
 2431              		.loc 3 501 0
 2432 0046 0368     		ldr	r3, [r0]
 2433 0048 054A     		ldr	r2, .L141
 2434 004a 1A40     		ands	r2, r3
 2435 004c C023     		movs	r3, #192
 2436 004e DB00     		lsls	r3, r3, #3
 2437 0050 1343     		orrs	r3, r2
 2438 0052 0360     		str	r3, [r0]
 2439              	.LVL264:
 2440              	.LBE53:
 2441              	.LBE52:
 879:../drivers/fsl_sai.c **** 
 2442              		.loc 1 879 0
 2443 0054 0121     		movs	r1, #1
 2444              	.LVL265:
 2445 0056 FFF7FEFF 		bl	SAI_TxEnable
 2446              	.LVL266:
 881:../drivers/fsl_sai.c **** }
 2447              		.loc 1 881 0
 2448 005a 0020     		movs	r0, #0
 2449 005c DAE7     		b	.L137
 2450              	.L142:
 2451 005e C046     		.align	2
 2452              	.L141:
 2453 0060 FFFFE3FF 		.word	-1835009
 2454              		.cfi_endproc
 2455              	.LFE91:
 2457              		.section	.text.SAI_TransferReceiveNonBlocking,"ax",%progbits
 2458              		.align	1
 2459              		.global	SAI_TransferReceiveNonBlocking
 2460              		.syntax unified
 2461              		.code	16
 2462              		.thumb_func
 2463              		.fpu softvfp
 2465              	SAI_TransferReceiveNonBlocking:
 2466              	.LFB92:
 883:../drivers/fsl_sai.c **** 
 884:../drivers/fsl_sai.c **** status_t SAI_TransferReceiveNonBlocking(I2S_Type *base, sai_handle_t *handle, sai_transfer_t *xfer)
 885:../drivers/fsl_sai.c **** {
 2467              		.loc 1 885 0
 2468              		.cfi_startproc
 2469              		@ args = 0, pretend = 0, frame = 0
 2470              		@ frame_needed = 0, uses_anonymous_args = 0
 2471              	.LVL267:
 2472 0000 70B5     		push	{r4, r5, r6, lr}
 2473              		.cfi_def_cfa_offset 16
 2474              		.cfi_offset 4, -16
 2475              		.cfi_offset 5, -12
 2476              		.cfi_offset 6, -8
 2477              		.cfi_offset 14, -4
 886:../drivers/fsl_sai.c ****     assert(handle);
 887:../drivers/fsl_sai.c **** 
 888:../drivers/fsl_sai.c ****     /* Check if the queue is full */
 889:../drivers/fsl_sai.c ****     if (handle->saiQueue[handle->queueUser].data)
 2478              		.loc 1 889 0
 2479 0002 4023     		movs	r3, #64
 2480 0004 CB5C     		ldrb	r3, [r1, r3]
 2481 0006 0233     		adds	r3, r3, #2
 2482 0008 DB00     		lsls	r3, r3, #3
 2483 000a 5B58     		ldr	r3, [r3, r1]
 2484 000c 002B     		cmp	r3, #0
 2485 000e 02D0     		beq	.L146
 890:../drivers/fsl_sai.c ****     {
 891:../drivers/fsl_sai.c ****         return kStatus_SAI_QueueFull;
 2486              		.loc 1 891 0
 2487 0010 EE20     		movs	r0, #238
 2488              	.LVL268:
 2489 0012 C000     		lsls	r0, r0, #3
 2490              	.LVL269:
 2491              	.L143:
 892:../drivers/fsl_sai.c ****     }
 893:../drivers/fsl_sai.c **** 
 894:../drivers/fsl_sai.c ****     /* Add into queue */
 895:../drivers/fsl_sai.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 896:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 897:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 898:../drivers/fsl_sai.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 899:../drivers/fsl_sai.c **** 
 900:../drivers/fsl_sai.c ****     /* Set state to busy */
 901:../drivers/fsl_sai.c ****     handle->state = kSAI_Busy;
 902:../drivers/fsl_sai.c **** 
 903:../drivers/fsl_sai.c **** /* Enable interrupt */
 904:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 905:../drivers/fsl_sai.c ****     /* Use FIFO request interrupt and fifo error*/
 906:../drivers/fsl_sai.c ****     SAI_RxEnableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFORequestInterruptEnable);
 907:../drivers/fsl_sai.c **** #else
 908:../drivers/fsl_sai.c ****     SAI_RxEnableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFOWarningInterruptEnable);
 909:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT */
 910:../drivers/fsl_sai.c **** 
 911:../drivers/fsl_sai.c ****     /* Enable Rx transfer */
 912:../drivers/fsl_sai.c ****     SAI_RxEnable(base, true);
 913:../drivers/fsl_sai.c **** 
 914:../drivers/fsl_sai.c ****     return kStatus_Success;
 915:../drivers/fsl_sai.c **** }
 2492              		.loc 1 915 0
 2493              		@ sp needed
 2494 0014 70BD     		pop	{r4, r5, r6, pc}
 2495              	.LVL270:
 2496              	.L146:
 895:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 2497              		.loc 1 895 0
 2498 0016 4024     		movs	r4, #64
 2499 0018 0B5D     		ldrb	r3, [r1, r4]
 2500 001a 0C33     		adds	r3, r3, #12
 2501 001c 9B00     		lsls	r3, r3, #2
 2502 001e 5568     		ldr	r5, [r2, #4]
 2503 0020 5D50     		str	r5, [r3, r1]
 896:../drivers/fsl_sai.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 2504              		.loc 1 896 0
 2505 0022 0B5D     		ldrb	r3, [r1, r4]
 2506 0024 0233     		adds	r3, r3, #2
 2507 0026 DB00     		lsls	r3, r3, #3
 2508 0028 1568     		ldr	r5, [r2]
 2509 002a 5D50     		str	r5, [r3, r1]
 897:../drivers/fsl_sai.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 2510              		.loc 1 897 0
 2511 002c 0B5D     		ldrb	r3, [r1, r4]
 2512 002e 5268     		ldr	r2, [r2, #4]
 2513              	.LVL271:
 2514 0030 0233     		adds	r3, r3, #2
 2515 0032 DB00     		lsls	r3, r3, #3
 2516 0034 CB18     		adds	r3, r1, r3
 2517 0036 5A60     		str	r2, [r3, #4]
 898:../drivers/fsl_sai.c **** 
 2518              		.loc 1 898 0
 2519 0038 0A5D     		ldrb	r2, [r1, r4]
 2520 003a 0132     		adds	r2, r2, #1
 2521 003c 0323     		movs	r3, #3
 2522 003e 1340     		ands	r3, r2
 2523 0040 0B55     		strb	r3, [r1, r4]
 901:../drivers/fsl_sai.c **** 
 2524              		.loc 1 901 0
 2525 0042 0023     		movs	r3, #0
 2526 0044 0B60     		str	r3, [r1]
 2527              	.LVL272:
 2528              	.LBB54:
 2529              	.LBB55:
 502:../drivers/fsl_sai.h **** }
 503:../drivers/fsl_sai.h **** 
 504:../drivers/fsl_sai.h **** /*!
 505:../drivers/fsl_sai.h ****  * @brief Enables the SAI Rx interrupt requests.
 506:../drivers/fsl_sai.h ****  *
 507:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 508:../drivers/fsl_sai.h ****  * @param mask interrupt source
 509:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 510:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 511:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 512:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 513:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 514:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 515:../drivers/fsl_sai.h ****  */
 516:../drivers/fsl_sai.h **** static inline void SAI_RxEnableInterrupts(I2S_Type *base, uint32_t mask)
 517:../drivers/fsl_sai.h **** {
 518:../drivers/fsl_sai.h ****     base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | mask);
 2530              		.loc 3 518 0
 2531 0046 8021     		movs	r1, #128
 2532              	.LVL273:
 2533 0048 4358     		ldr	r3, [r0, r1]
 2534 004a 054A     		ldr	r2, .L147
 2535 004c 1A40     		ands	r2, r3
 2536 004e C023     		movs	r3, #192
 2537 0050 DB00     		lsls	r3, r3, #3
 2538 0052 1343     		orrs	r3, r2
 2539 0054 4350     		str	r3, [r0, r1]
 2540              	.LVL274:
 2541              	.LBE55:
 2542              	.LBE54:
 912:../drivers/fsl_sai.c **** 
 2543              		.loc 1 912 0
 2544 0056 7F39     		subs	r1, r1, #127
 2545 0058 FFF7FEFF 		bl	SAI_RxEnable
 2546              	.LVL275:
 914:../drivers/fsl_sai.c **** }
 2547              		.loc 1 914 0
 2548 005c 0020     		movs	r0, #0
 2549 005e D9E7     		b	.L143
 2550              	.L148:
 2551              		.align	2
 2552              	.L147:
 2553 0060 FFFFE3FF 		.word	-1835009
 2554              		.cfi_endproc
 2555              	.LFE92:
 2557              		.section	.text.SAI_TransferGetSendCount,"ax",%progbits
 2558              		.align	1
 2559              		.global	SAI_TransferGetSendCount
 2560              		.syntax unified
 2561              		.code	16
 2562              		.thumb_func
 2563              		.fpu softvfp
 2565              	SAI_TransferGetSendCount:
 2566              	.LFB93:
 916:../drivers/fsl_sai.c **** 
 917:../drivers/fsl_sai.c **** status_t SAI_TransferGetSendCount(I2S_Type *base, sai_handle_t *handle, size_t *count)
 918:../drivers/fsl_sai.c **** {
 2567              		.loc 1 918 0
 2568              		.cfi_startproc
 2569              		@ args = 0, pretend = 0, frame = 0
 2570              		@ frame_needed = 0, uses_anonymous_args = 0
 2571              	.LVL276:
 2572 0000 10B5     		push	{r4, lr}
 2573              		.cfi_def_cfa_offset 8
 2574              		.cfi_offset 4, -8
 2575              		.cfi_offset 14, -4
 2576              	.LVL277:
 919:../drivers/fsl_sai.c ****     assert(handle);
 920:../drivers/fsl_sai.c **** 
 921:../drivers/fsl_sai.c ****     status_t status = kStatus_Success;
 922:../drivers/fsl_sai.c **** 
 923:../drivers/fsl_sai.c ****     if (handle->state != kSAI_Busy)
 2577              		.loc 1 923 0
 2578 0002 0B68     		ldr	r3, [r1]
 2579 0004 002B     		cmp	r3, #0
 2580 0006 0DD1     		bne	.L151
 924:../drivers/fsl_sai.c ****     {
 925:../drivers/fsl_sai.c ****         status = kStatus_NoTransferInProgress;
 926:../drivers/fsl_sai.c ****     }
 927:../drivers/fsl_sai.c ****     else
 928:../drivers/fsl_sai.c ****     {
 929:../drivers/fsl_sai.c ****         *count = (handle->transferSize[handle->queueDriver] - handle->saiQueue[handle->queueDriver]
 2581              		.loc 1 929 0
 2582 0008 4124     		movs	r4, #65
 2583 000a 0B5D     		ldrb	r3, [r1, r4]
 2584 000c 0C33     		adds	r3, r3, #12
 2585 000e 9B00     		lsls	r3, r3, #2
 2586 0010 5858     		ldr	r0, [r3, r1]
 2587              	.LVL278:
 2588 0012 0B5D     		ldrb	r3, [r1, r4]
 2589 0014 0233     		adds	r3, r3, #2
 2590 0016 DB00     		lsls	r3, r3, #3
 2591 0018 C918     		adds	r1, r1, r3
 2592              	.LVL279:
 2593 001a 4B68     		ldr	r3, [r1, #4]
 2594 001c C31A     		subs	r3, r0, r3
 2595 001e 1360     		str	r3, [r2]
 921:../drivers/fsl_sai.c **** 
 2596              		.loc 1 921 0
 2597 0020 0020     		movs	r0, #0
 2598              	.LVL280:
 2599              	.L149:
 930:../drivers/fsl_sai.c ****     }
 931:../drivers/fsl_sai.c **** 
 932:../drivers/fsl_sai.c ****     return status;
 933:../drivers/fsl_sai.c **** }
 2600              		.loc 1 933 0
 2601              		@ sp needed
 2602 0022 10BD     		pop	{r4, pc}
 2603              	.LVL281:
 2604              	.L151:
 925:../drivers/fsl_sai.c ****     }
 2605              		.loc 1 925 0
 2606 0024 0620     		movs	r0, #6
 2607              	.LVL282:
 932:../drivers/fsl_sai.c **** }
 2608              		.loc 1 932 0
 2609 0026 FCE7     		b	.L149
 2610              		.cfi_endproc
 2611              	.LFE93:
 2613              		.section	.text.SAI_TransferGetReceiveCount,"ax",%progbits
 2614              		.align	1
 2615              		.global	SAI_TransferGetReceiveCount
 2616              		.syntax unified
 2617              		.code	16
 2618              		.thumb_func
 2619              		.fpu softvfp
 2621              	SAI_TransferGetReceiveCount:
 2622              	.LFB94:
 934:../drivers/fsl_sai.c **** 
 935:../drivers/fsl_sai.c **** status_t SAI_TransferGetReceiveCount(I2S_Type *base, sai_handle_t *handle, size_t *count)
 936:../drivers/fsl_sai.c **** {
 2623              		.loc 1 936 0
 2624              		.cfi_startproc
 2625              		@ args = 0, pretend = 0, frame = 0
 2626              		@ frame_needed = 0, uses_anonymous_args = 0
 2627              	.LVL283:
 2628 0000 10B5     		push	{r4, lr}
 2629              		.cfi_def_cfa_offset 8
 2630              		.cfi_offset 4, -8
 2631              		.cfi_offset 14, -4
 2632              	.LVL284:
 937:../drivers/fsl_sai.c ****     assert(handle);
 938:../drivers/fsl_sai.c **** 
 939:../drivers/fsl_sai.c ****     status_t status = kStatus_Success;
 940:../drivers/fsl_sai.c **** 
 941:../drivers/fsl_sai.c ****     if (handle->state != kSAI_Busy)
 2633              		.loc 1 941 0
 2634 0002 0B68     		ldr	r3, [r1]
 2635 0004 002B     		cmp	r3, #0
 2636 0006 0DD1     		bne	.L154
 942:../drivers/fsl_sai.c ****     {
 943:../drivers/fsl_sai.c ****         status = kStatus_NoTransferInProgress;
 944:../drivers/fsl_sai.c ****     }
 945:../drivers/fsl_sai.c ****     else
 946:../drivers/fsl_sai.c ****     {
 947:../drivers/fsl_sai.c ****         *count = (handle->transferSize[handle->queueDriver] - handle->saiQueue[handle->queueDriver]
 2637              		.loc 1 947 0
 2638 0008 4124     		movs	r4, #65
 2639 000a 0B5D     		ldrb	r3, [r1, r4]
 2640 000c 0C33     		adds	r3, r3, #12
 2641 000e 9B00     		lsls	r3, r3, #2
 2642 0010 5858     		ldr	r0, [r3, r1]
 2643              	.LVL285:
 2644 0012 0B5D     		ldrb	r3, [r1, r4]
 2645 0014 0233     		adds	r3, r3, #2
 2646 0016 DB00     		lsls	r3, r3, #3
 2647 0018 C918     		adds	r1, r1, r3
 2648              	.LVL286:
 2649 001a 4B68     		ldr	r3, [r1, #4]
 2650 001c C31A     		subs	r3, r0, r3
 2651 001e 1360     		str	r3, [r2]
 939:../drivers/fsl_sai.c **** 
 2652              		.loc 1 939 0
 2653 0020 0020     		movs	r0, #0
 2654              	.LVL287:
 2655              	.L152:
 948:../drivers/fsl_sai.c ****     }
 949:../drivers/fsl_sai.c **** 
 950:../drivers/fsl_sai.c ****     return status;
 951:../drivers/fsl_sai.c **** }
 2656              		.loc 1 951 0
 2657              		@ sp needed
 2658 0022 10BD     		pop	{r4, pc}
 2659              	.LVL288:
 2660              	.L154:
 943:../drivers/fsl_sai.c ****     }
 2661              		.loc 1 943 0
 2662 0024 0620     		movs	r0, #6
 2663              	.LVL289:
 950:../drivers/fsl_sai.c **** }
 2664              		.loc 1 950 0
 2665 0026 FCE7     		b	.L152
 2666              		.cfi_endproc
 2667              	.LFE94:
 2669              		.section	.text.SAI_TransferAbortSend,"ax",%progbits
 2670              		.align	1
 2671              		.global	SAI_TransferAbortSend
 2672              		.syntax unified
 2673              		.code	16
 2674              		.thumb_func
 2675              		.fpu softvfp
 2677              	SAI_TransferAbortSend:
 2678              	.LFB95:
 952:../drivers/fsl_sai.c **** 
 953:../drivers/fsl_sai.c **** void SAI_TransferAbortSend(I2S_Type *base, sai_handle_t *handle)
 954:../drivers/fsl_sai.c **** {
 2679              		.loc 1 954 0
 2680              		.cfi_startproc
 2681              		@ args = 0, pretend = 0, frame = 0
 2682              		@ frame_needed = 0, uses_anonymous_args = 0
 2683              	.LVL290:
 2684 0000 70B5     		push	{r4, r5, r6, lr}
 2685              		.cfi_def_cfa_offset 16
 2686              		.cfi_offset 4, -16
 2687              		.cfi_offset 5, -12
 2688              		.cfi_offset 6, -8
 2689              		.cfi_offset 14, -4
 2690 0002 0500     		movs	r5, r0
 2691 0004 0C00     		movs	r4, r1
 955:../drivers/fsl_sai.c ****     assert(handle);
 956:../drivers/fsl_sai.c **** 
 957:../drivers/fsl_sai.c ****     /* Stop Tx transfer and disable interrupt */
 958:../drivers/fsl_sai.c ****     SAI_TxEnable(base, false);
 2692              		.loc 1 958 0
 2693 0006 0021     		movs	r1, #0
 2694              	.LVL291:
 2695 0008 FFF7FEFF 		bl	SAI_TxEnable
 2696              	.LVL292:
 2697              	.LBB56:
 2698              	.LBB57:
 519:../drivers/fsl_sai.h **** }
 520:../drivers/fsl_sai.h **** 
 521:../drivers/fsl_sai.h **** /*!
 522:../drivers/fsl_sai.h ****  * @brief Disables the SAI Tx interrupt requests.
 523:../drivers/fsl_sai.h ****  *
 524:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 525:../drivers/fsl_sai.h ****  * @param mask interrupt source
 526:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 527:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 528:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 529:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 530:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 531:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 532:../drivers/fsl_sai.h ****  */
 533:../drivers/fsl_sai.h **** static inline void SAI_TxDisableInterrupts(I2S_Type *base, uint32_t mask)
 534:../drivers/fsl_sai.h **** {
 535:../drivers/fsl_sai.h ****     base->TCSR = ((base->TCSR & 0xFFE3FFFFU) & (~mask));
 2699              		.loc 3 535 0
 2700 000c 2B68     		ldr	r3, [r5]
 2701 000e 084A     		ldr	r2, .L156
 2702 0010 1340     		ands	r3, r2
 2703 0012 2B60     		str	r3, [r5]
 2704              	.LVL293:
 2705              	.LBE57:
 2706              	.LBE56:
 959:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 960:../drivers/fsl_sai.c ****     /* Use FIFO request interrupt and fifo error */
 961:../drivers/fsl_sai.c ****     SAI_TxDisableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFORequestInterruptEnable);
 962:../drivers/fsl_sai.c **** #else
 963:../drivers/fsl_sai.c ****     SAI_TxDisableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFOWarningInterruptEnable);
 964:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT */
 965:../drivers/fsl_sai.c **** 
 966:../drivers/fsl_sai.c ****     handle->state = kSAI_Idle;
 2707              		.loc 1 966 0
 2708 0014 0123     		movs	r3, #1
 2709 0016 2360     		str	r3, [r4]
 967:../drivers/fsl_sai.c **** 
 968:../drivers/fsl_sai.c ****     /* Clear the queue */
 969:../drivers/fsl_sai.c ****     memset(handle->saiQueue, 0, sizeof(sai_transfer_t) * SAI_XFER_QUEUE_SIZE);
 2710              		.loc 1 969 0
 2711 0018 2000     		movs	r0, r4
 2712 001a 1030     		adds	r0, r0, #16
 2713 001c 2022     		movs	r2, #32
 2714 001e 0021     		movs	r1, #0
 2715 0020 FFF7FEFF 		bl	memset
 2716              	.LVL294:
 970:../drivers/fsl_sai.c ****     handle->queueDriver = 0;
 2717              		.loc 1 970 0
 2718 0024 0023     		movs	r3, #0
 2719 0026 4122     		movs	r2, #65
 2720 0028 A354     		strb	r3, [r4, r2]
 971:../drivers/fsl_sai.c ****     handle->queueUser = 0;
 2721              		.loc 1 971 0
 2722 002a 013A     		subs	r2, r2, #1
 2723 002c A354     		strb	r3, [r4, r2]
 972:../drivers/fsl_sai.c **** }
 2724              		.loc 1 972 0
 2725              		@ sp needed
 2726              	.LVL295:
 2727              	.LVL296:
 2728 002e 70BD     		pop	{r4, r5, r6, pc}
 2729              	.L157:
 2730              		.align	2
 2731              	.L156:
 2732 0030 FFF9E3FF 		.word	-1836545
 2733              		.cfi_endproc
 2734              	.LFE95:
 2736              		.section	.text.SAI_TransferTxHandleIRQ,"ax",%progbits
 2737              		.align	1
 2738              		.global	SAI_TransferTxHandleIRQ
 2739              		.syntax unified
 2740              		.code	16
 2741              		.thumb_func
 2742              		.fpu softvfp
 2744              	SAI_TransferTxHandleIRQ:
 2745              	.LFB99:
 973:../drivers/fsl_sai.c **** 
 974:../drivers/fsl_sai.c **** void SAI_TransferAbortReceive(I2S_Type *base, sai_handle_t *handle)
 975:../drivers/fsl_sai.c **** {
 976:../drivers/fsl_sai.c ****     assert(handle);
 977:../drivers/fsl_sai.c **** 
 978:../drivers/fsl_sai.c ****     /* Stop Tx transfer and disable interrupt */
 979:../drivers/fsl_sai.c ****     SAI_RxEnable(base, false);
 980:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 981:../drivers/fsl_sai.c ****     /* Use FIFO request interrupt and fifo error */
 982:../drivers/fsl_sai.c ****     SAI_RxDisableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFORequestInterruptEnable);
 983:../drivers/fsl_sai.c **** #else
 984:../drivers/fsl_sai.c ****     SAI_RxDisableInterrupts(base, kSAI_FIFOErrorInterruptEnable | kSAI_FIFOWarningInterruptEnable);
 985:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT */
 986:../drivers/fsl_sai.c **** 
 987:../drivers/fsl_sai.c ****     handle->state = kSAI_Idle;
 988:../drivers/fsl_sai.c **** 
 989:../drivers/fsl_sai.c ****     /* Clear the queue */
 990:../drivers/fsl_sai.c ****     memset(handle->saiQueue, 0, sizeof(sai_transfer_t) * SAI_XFER_QUEUE_SIZE);
 991:../drivers/fsl_sai.c ****     handle->queueDriver = 0;
 992:../drivers/fsl_sai.c ****     handle->queueUser = 0;
 993:../drivers/fsl_sai.c **** }
 994:../drivers/fsl_sai.c **** 
 995:../drivers/fsl_sai.c **** void SAI_TransferTerminateSend(I2S_Type *base, sai_handle_t *handle)
 996:../drivers/fsl_sai.c **** {
 997:../drivers/fsl_sai.c ****     assert(handle);
 998:../drivers/fsl_sai.c **** 
 999:../drivers/fsl_sai.c ****     /* Abort the current transfer */
1000:../drivers/fsl_sai.c ****     SAI_TransferAbortSend(base, handle);
1001:../drivers/fsl_sai.c **** 
1002:../drivers/fsl_sai.c ****     /* Clear all the internal information */
1003:../drivers/fsl_sai.c ****     memset(handle->saiQueue, 0U, sizeof(handle->saiQueue));
1004:../drivers/fsl_sai.c ****     memset(handle->transferSize, 0U, sizeof(handle->transferSize));
1005:../drivers/fsl_sai.c ****     handle->queueUser = 0U;
1006:../drivers/fsl_sai.c ****     handle->queueDriver = 0U;
1007:../drivers/fsl_sai.c **** }
1008:../drivers/fsl_sai.c **** 
1009:../drivers/fsl_sai.c **** void SAI_TransferTerminateReceive(I2S_Type *base, sai_handle_t *handle)
1010:../drivers/fsl_sai.c **** {
1011:../drivers/fsl_sai.c ****     assert(handle);
1012:../drivers/fsl_sai.c **** 
1013:../drivers/fsl_sai.c ****     /* Abort the current transfer */
1014:../drivers/fsl_sai.c ****     SAI_TransferAbortReceive(base, handle);
1015:../drivers/fsl_sai.c **** 
1016:../drivers/fsl_sai.c ****     /* Clear all the internal information */
1017:../drivers/fsl_sai.c ****     memset(handle->saiQueue, 0U, sizeof(handle->saiQueue));
1018:../drivers/fsl_sai.c ****     memset(handle->transferSize, 0U, sizeof(handle->transferSize));
1019:../drivers/fsl_sai.c ****     handle->queueUser = 0U;
1020:../drivers/fsl_sai.c ****     handle->queueDriver = 0U;
1021:../drivers/fsl_sai.c **** }
1022:../drivers/fsl_sai.c **** 
1023:../drivers/fsl_sai.c **** void SAI_TransferTxHandleIRQ(I2S_Type *base, sai_handle_t *handle)
1024:../drivers/fsl_sai.c **** {
 2746              		.loc 1 1024 0
 2747              		.cfi_startproc
 2748              		@ args = 0, pretend = 0, frame = 0
 2749              		@ frame_needed = 0, uses_anonymous_args = 0
 2750              	.LVL297:
 2751 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2752              		.cfi_def_cfa_offset 20
 2753              		.cfi_offset 4, -20
 2754              		.cfi_offset 5, -16
 2755              		.cfi_offset 6, -12
 2756              		.cfi_offset 7, -8
 2757              		.cfi_offset 14, -4
 2758 0002 C646     		mov	lr, r8
 2759 0004 00B5     		push	{lr}
 2760              		.cfi_def_cfa_offset 24
 2761              		.cfi_offset 8, -24
 2762 0006 82B0     		sub	sp, sp, #8
 2763              		.cfi_def_cfa_offset 32
 2764 0008 0500     		movs	r5, r0
 2765 000a 0C00     		movs	r4, r1
1025:../drivers/fsl_sai.c ****     assert(handle);
1026:../drivers/fsl_sai.c **** 
1027:../drivers/fsl_sai.c ****     uint8_t *buffer = handle->saiQueue[handle->queueDriver].data;
 2766              		.loc 1 1027 0
 2767 000c 4123     		movs	r3, #65
 2768 000e CB5C     		ldrb	r3, [r1, r3]
 2769 0010 0233     		adds	r3, r3, #2
 2770 0012 DB00     		lsls	r3, r3, #3
 2771 0014 5F58     		ldr	r7, [r3, r1]
 2772              	.LVL298:
1028:../drivers/fsl_sai.c ****     uint8_t dataSize = handle->bitWidth / 8U;
 2773              		.loc 1 1028 0
 2774 0016 0E7B     		ldrb	r6, [r1, #12]
 2775 0018 F608     		lsrs	r6, r6, #3
 2776              	.LVL299:
1029:../drivers/fsl_sai.c **** 
1030:../drivers/fsl_sai.c ****     /* Handle Error */
1031:../drivers/fsl_sai.c ****     if (base->TCSR & I2S_TCSR_FEF_MASK)
 2777              		.loc 1 1031 0
 2778 001a 0368     		ldr	r3, [r0]
 2779 001c 5B03     		lsls	r3, r3, #13
 2780 001e 39D4     		bmi	.L164
 2781              	.LVL300:
 2782              	.L159:
1032:../drivers/fsl_sai.c ****     {
1033:../drivers/fsl_sai.c ****         /* Clear FIFO error flag to continue transfer */
1034:../drivers/fsl_sai.c ****         SAI_TxClearStatusFlags(base, kSAI_FIFOErrorFlag);
1035:../drivers/fsl_sai.c **** 
1036:../drivers/fsl_sai.c ****         /* Reset FIFO for safety */
1037:../drivers/fsl_sai.c ****         SAI_TxSoftwareReset(base, kSAI_ResetTypeFIFO);
1038:../drivers/fsl_sai.c **** 
1039:../drivers/fsl_sai.c ****         /* Call the callback */
1040:../drivers/fsl_sai.c ****         if (handle->callback)
1041:../drivers/fsl_sai.c ****         {
1042:../drivers/fsl_sai.c ****             (handle->callback)(base, handle, kStatus_SAI_TxError, handle->userData);
1043:../drivers/fsl_sai.c ****         }
1044:../drivers/fsl_sai.c ****     }
1045:../drivers/fsl_sai.c **** 
1046:../drivers/fsl_sai.c **** /* Handle transfer */
1047:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
1048:../drivers/fsl_sai.c ****     if (base->TCSR & I2S_TCSR_FRF_MASK)
1049:../drivers/fsl_sai.c ****     {
1050:../drivers/fsl_sai.c ****         /* Judge if the data need to transmit is less than space */
1051:../drivers/fsl_sai.c ****         uint8_t size = MIN((handle->saiQueue[handle->queueDriver].dataSize),
1052:../drivers/fsl_sai.c ****                            (size_t)((FSL_FEATURE_SAI_FIFO_COUNT - handle->watermark) * dataSize));
1053:../drivers/fsl_sai.c **** 
1054:../drivers/fsl_sai.c ****         /* Copy the data from sai buffer to FIFO */
1055:../drivers/fsl_sai.c ****         SAI_WriteNonBlocking(base, handle->channel, handle->bitWidth, buffer, size);
1056:../drivers/fsl_sai.c **** 
1057:../drivers/fsl_sai.c ****         /* Update the internal counter */
1058:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].dataSize -= size;
1059:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].data += size;
1060:../drivers/fsl_sai.c ****     }
1061:../drivers/fsl_sai.c **** #else
1062:../drivers/fsl_sai.c ****     if (base->TCSR & I2S_TCSR_FWF_MASK)
 2783              		.loc 1 1062 0
 2784 0020 2B68     		ldr	r3, [r5]
 2785 0022 9B03     		lsls	r3, r3, #14
 2786 0024 23D5     		bpl	.L160
 2787              	.LBB58:
1063:../drivers/fsl_sai.c ****     {
1064:../drivers/fsl_sai.c ****         uint8_t size = MIN((handle->saiQueue[handle->queueDriver].dataSize), dataSize);
 2788              		.loc 1 1064 0
 2789 0026 4123     		movs	r3, #65
 2790 0028 E35C     		ldrb	r3, [r4, r3]
 2791 002a 0233     		adds	r3, r3, #2
 2792 002c DB00     		lsls	r3, r3, #3
 2793 002e E318     		adds	r3, r4, r3
 2794 0030 5B68     		ldr	r3, [r3, #4]
 2795 0032 B342     		cmp	r3, r6
 2796 0034 05D2     		bcs	.L161
 2797              		.loc 1 1064 0 is_stmt 0 discriminator 1
 2798 0036 4123     		movs	r3, #65
 2799 0038 E35C     		ldrb	r3, [r4, r3]
 2800 003a 0233     		adds	r3, r3, #2
 2801 003c DB00     		lsls	r3, r3, #3
 2802 003e E318     		adds	r3, r4, r3
 2803 0040 1E79     		ldrb	r6, [r3, #4]
 2804              	.LVL301:
 2805              	.L161:
1065:../drivers/fsl_sai.c **** 
1066:../drivers/fsl_sai.c ****         SAI_WriteNonBlocking(base, handle->channel, handle->bitWidth, buffer, size);
 2806              		.loc 1 1066 0 is_stmt 1 discriminator 4
 2807 0042 617B     		ldrb	r1, [r4, #13]
 2808 0044 227B     		ldrb	r2, [r4, #12]
 2809 0046 0096     		str	r6, [sp]
 2810 0048 3B00     		movs	r3, r7
 2811 004a 2800     		movs	r0, r5
 2812 004c FFF7FEFF 		bl	SAI_WriteNonBlocking
 2813              	.LVL302:
1067:../drivers/fsl_sai.c **** 
1068:../drivers/fsl_sai.c ****         /* Update internal counter */
1069:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].dataSize -= size;
 2814              		.loc 1 1069 0 discriminator 4
 2815 0050 4121     		movs	r1, #65
 2816 0052 635C     		ldrb	r3, [r4, r1]
 2817 0054 0233     		adds	r3, r3, #2
 2818 0056 DB00     		lsls	r3, r3, #3
 2819 0058 E318     		adds	r3, r4, r3
 2820 005a 5A68     		ldr	r2, [r3, #4]
 2821 005c 921B     		subs	r2, r2, r6
 2822 005e 5A60     		str	r2, [r3, #4]
1070:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].data += size;
 2823              		.loc 1 1070 0 discriminator 4
 2824 0060 635C     		ldrb	r3, [r4, r1]
 2825 0062 0233     		adds	r3, r3, #2
 2826 0064 DB00     		lsls	r3, r3, #3
 2827 0066 1A59     		ldr	r2, [r3, r4]
 2828 0068 9446     		mov	ip, r2
 2829 006a 6644     		add	r6, r6, ip
 2830              	.LVL303:
 2831 006c 1E51     		str	r6, [r3, r4]
 2832              	.L160:
 2833              	.LBE58:
1071:../drivers/fsl_sai.c ****     }
1072:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT */
1073:../drivers/fsl_sai.c **** 
1074:../drivers/fsl_sai.c ****     /* If finished a blcok, call the callback function */
1075:../drivers/fsl_sai.c ****     if (handle->saiQueue[handle->queueDriver].dataSize == 0U)
 2834              		.loc 1 1075 0
 2835 006e 4123     		movs	r3, #65
 2836 0070 E35C     		ldrb	r3, [r4, r3]
 2837 0072 0233     		adds	r3, r3, #2
 2838 0074 DB00     		lsls	r3, r3, #3
 2839 0076 E318     		adds	r3, r4, r3
 2840 0078 5B68     		ldr	r3, [r3, #4]
 2841 007a 002B     		cmp	r3, #0
 2842 007c 1FD0     		beq	.L165
 2843              	.L162:
1076:../drivers/fsl_sai.c ****     {
1077:../drivers/fsl_sai.c ****         memset(&handle->saiQueue[handle->queueDriver], 0, sizeof(sai_transfer_t));
1078:../drivers/fsl_sai.c ****         handle->queueDriver = (handle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
1079:../drivers/fsl_sai.c ****         if (handle->callback)
1080:../drivers/fsl_sai.c ****         {
1081:../drivers/fsl_sai.c ****             (handle->callback)(base, handle, kStatus_SAI_TxIdle, handle->userData);
1082:../drivers/fsl_sai.c ****         }
1083:../drivers/fsl_sai.c ****     }
1084:../drivers/fsl_sai.c **** 
1085:../drivers/fsl_sai.c ****     /* If all data finished, just stop the transfer */
1086:../drivers/fsl_sai.c ****     if (handle->saiQueue[handle->queueDriver].data == NULL)
 2844              		.loc 1 1086 0
 2845 007e 4123     		movs	r3, #65
 2846 0080 E35C     		ldrb	r3, [r4, r3]
 2847 0082 0233     		adds	r3, r3, #2
 2848 0084 DB00     		lsls	r3, r3, #3
 2849 0086 1B59     		ldr	r3, [r3, r4]
 2850 0088 002B     		cmp	r3, #0
 2851 008a 2FD0     		beq	.L166
 2852              	.L158:
1087:../drivers/fsl_sai.c ****     {
1088:../drivers/fsl_sai.c ****         SAI_TransferAbortSend(base, handle);
1089:../drivers/fsl_sai.c ****     }
1090:../drivers/fsl_sai.c **** }
 2853              		.loc 1 1090 0
 2854 008c 02B0     		add	sp, sp, #8
 2855              		@ sp needed
 2856              	.LVL304:
 2857              	.LVL305:
 2858              	.LVL306:
 2859 008e 04BC     		pop	{r2}
 2860 0090 9046     		mov	r8, r2
 2861 0092 F0BD     		pop	{r4, r5, r6, r7, pc}
 2862              	.LVL307:
 2863              	.L164:
 2864              	.LBB59:
 2865              	.LBB60:
 408:../drivers/fsl_sai.h **** }
 2866              		.loc 3 408 0
 2867 0094 0368     		ldr	r3, [r0]
 2868 0096 184A     		ldr	r2, .L167
 2869 0098 1A40     		ands	r2, r3
 2870 009a 8023     		movs	r3, #128
 2871 009c DB02     		lsls	r3, r3, #11
 2872 009e 1343     		orrs	r3, r2
 2873 00a0 0360     		str	r3, [r0]
 2874              	.LVL308:
 2875              	.LBE60:
 2876              	.LBE59:
1037:../drivers/fsl_sai.c **** 
 2877              		.loc 1 1037 0
 2878 00a2 8021     		movs	r1, #128
 2879              	.LVL309:
 2880 00a4 8904     		lsls	r1, r1, #18
 2881 00a6 FFF7FEFF 		bl	SAI_TxSoftwareReset
 2882              	.LVL310:
1040:../drivers/fsl_sai.c ****         {
 2883              		.loc 1 1040 0
 2884 00aa 6368     		ldr	r3, [r4, #4]
 2885 00ac 9846     		mov	r8, r3
 2886 00ae 002B     		cmp	r3, #0
 2887 00b0 B6D0     		beq	.L159
1042:../drivers/fsl_sai.c ****         }
 2888              		.loc 1 1042 0
 2889 00b2 A368     		ldr	r3, [r4, #8]
 2890 00b4 114A     		ldr	r2, .L167+4
 2891 00b6 2100     		movs	r1, r4
 2892 00b8 2800     		movs	r0, r5
 2893 00ba C047     		blx	r8
 2894              	.LVL311:
 2895 00bc B0E7     		b	.L159
 2896              	.LVL312:
 2897              	.L165:
1077:../drivers/fsl_sai.c ****         handle->queueDriver = (handle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
 2898              		.loc 1 1077 0
 2899 00be 4126     		movs	r6, #65
 2900 00c0 A05D     		ldrb	r0, [r4, r6]
 2901 00c2 0230     		adds	r0, r0, #2
 2902 00c4 C000     		lsls	r0, r0, #3
 2903 00c6 2018     		adds	r0, r4, r0
 2904 00c8 0822     		movs	r2, #8
 2905 00ca 0021     		movs	r1, #0
 2906 00cc FFF7FEFF 		bl	memset
 2907              	.LVL313:
1078:../drivers/fsl_sai.c ****         if (handle->callback)
 2908              		.loc 1 1078 0
 2909 00d0 A25D     		ldrb	r2, [r4, r6]
 2910 00d2 0132     		adds	r2, r2, #1
 2911 00d4 0323     		movs	r3, #3
 2912 00d6 1340     		ands	r3, r2
 2913 00d8 A355     		strb	r3, [r4, r6]
1079:../drivers/fsl_sai.c ****         {
 2914              		.loc 1 1079 0
 2915 00da 6668     		ldr	r6, [r4, #4]
 2916 00dc 002E     		cmp	r6, #0
 2917 00de CED0     		beq	.L162
1081:../drivers/fsl_sai.c ****         }
 2918              		.loc 1 1081 0
 2919 00e0 A368     		ldr	r3, [r4, #8]
 2920 00e2 074A     		ldr	r2, .L167+8
 2921 00e4 2100     		movs	r1, r4
 2922 00e6 2800     		movs	r0, r5
 2923 00e8 B047     		blx	r6
 2924              	.LVL314:
 2925 00ea C8E7     		b	.L162
 2926              	.L166:
1088:../drivers/fsl_sai.c ****     }
 2927              		.loc 1 1088 0
 2928 00ec 2100     		movs	r1, r4
 2929 00ee 2800     		movs	r0, r5
 2930 00f0 FFF7FEFF 		bl	SAI_TransferAbortSend
 2931              	.LVL315:
 2932              		.loc 1 1090 0
 2933 00f4 CAE7     		b	.L158
 2934              	.L168:
 2935 00f6 C046     		.align	2
 2936              	.L167:
 2937 00f8 FFFFE3FF 		.word	-1835009
 2938 00fc 6E070000 		.word	1902
 2939 0100 71070000 		.word	1905
 2940              		.cfi_endproc
 2941              	.LFE99:
 2943              		.section	.text.SAI_TransferAbortReceive,"ax",%progbits
 2944              		.align	1
 2945              		.global	SAI_TransferAbortReceive
 2946              		.syntax unified
 2947              		.code	16
 2948              		.thumb_func
 2949              		.fpu softvfp
 2951              	SAI_TransferAbortReceive:
 2952              	.LFB96:
 975:../drivers/fsl_sai.c ****     assert(handle);
 2953              		.loc 1 975 0
 2954              		.cfi_startproc
 2955              		@ args = 0, pretend = 0, frame = 0
 2956              		@ frame_needed = 0, uses_anonymous_args = 0
 2957              	.LVL316:
 2958 0000 70B5     		push	{r4, r5, r6, lr}
 2959              		.cfi_def_cfa_offset 16
 2960              		.cfi_offset 4, -16
 2961              		.cfi_offset 5, -12
 2962              		.cfi_offset 6, -8
 2963              		.cfi_offset 14, -4
 2964 0002 0500     		movs	r5, r0
 2965 0004 0C00     		movs	r4, r1
 979:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 2966              		.loc 1 979 0
 2967 0006 0021     		movs	r1, #0
 2968              	.LVL317:
 2969 0008 FFF7FEFF 		bl	SAI_RxEnable
 2970              	.LVL318:
 2971              	.LBB61:
 2972              	.LBB62:
 536:../drivers/fsl_sai.h **** }
 537:../drivers/fsl_sai.h **** 
 538:../drivers/fsl_sai.h **** /*!
 539:../drivers/fsl_sai.h ****  * @brief Disables the SAI Rx interrupt requests.
 540:../drivers/fsl_sai.h ****  *
 541:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 542:../drivers/fsl_sai.h ****  * @param mask interrupt source
 543:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 544:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 545:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 546:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 547:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 548:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 549:../drivers/fsl_sai.h ****  */
 550:../drivers/fsl_sai.h **** static inline void SAI_RxDisableInterrupts(I2S_Type *base, uint32_t mask)
 551:../drivers/fsl_sai.h **** {
 552:../drivers/fsl_sai.h ****     base->RCSR = ((base->RCSR & 0xFFE3FFFFU) & (~mask));
 2973              		.loc 3 552 0
 2974 000c 8022     		movs	r2, #128
 2975 000e AB58     		ldr	r3, [r5, r2]
 2976 0010 0849     		ldr	r1, .L170
 2977 0012 0B40     		ands	r3, r1
 2978 0014 AB50     		str	r3, [r5, r2]
 2979              	.LVL319:
 2980              	.LBE62:
 2981              	.LBE61:
 987:../drivers/fsl_sai.c **** 
 2982              		.loc 1 987 0
 2983 0016 0123     		movs	r3, #1
 2984 0018 2360     		str	r3, [r4]
 990:../drivers/fsl_sai.c ****     handle->queueDriver = 0;
 2985              		.loc 1 990 0
 2986 001a 2000     		movs	r0, r4
 2987 001c 1030     		adds	r0, r0, #16
 2988 001e 603A     		subs	r2, r2, #96
 2989 0020 0021     		movs	r1, #0
 2990 0022 FFF7FEFF 		bl	memset
 2991              	.LVL320:
 991:../drivers/fsl_sai.c ****     handle->queueUser = 0;
 2992              		.loc 1 991 0
 2993 0026 0023     		movs	r3, #0
 2994 0028 4122     		movs	r2, #65
 2995 002a A354     		strb	r3, [r4, r2]
 992:../drivers/fsl_sai.c **** }
 2996              		.loc 1 992 0
 2997 002c 013A     		subs	r2, r2, #1
 2998 002e A354     		strb	r3, [r4, r2]
 993:../drivers/fsl_sai.c **** 
 2999              		.loc 1 993 0
 3000              		@ sp needed
 3001              	.LVL321:
 3002              	.LVL322:
 3003 0030 70BD     		pop	{r4, r5, r6, pc}
 3004              	.L171:
 3005 0032 C046     		.align	2
 3006              	.L170:
 3007 0034 FFF9E3FF 		.word	-1836545
 3008              		.cfi_endproc
 3009              	.LFE96:
 3011              		.section	.text.SAI_TransferRxHandleIRQ,"ax",%progbits
 3012              		.align	1
 3013              		.global	SAI_TransferRxHandleIRQ
 3014              		.syntax unified
 3015              		.code	16
 3016              		.thumb_func
 3017              		.fpu softvfp
 3019              	SAI_TransferRxHandleIRQ:
 3020              	.LFB100:
1091:../drivers/fsl_sai.c **** 
1092:../drivers/fsl_sai.c **** void SAI_TransferRxHandleIRQ(I2S_Type *base, sai_handle_t *handle)
1093:../drivers/fsl_sai.c **** {
 3021              		.loc 1 1093 0
 3022              		.cfi_startproc
 3023              		@ args = 0, pretend = 0, frame = 0
 3024              		@ frame_needed = 0, uses_anonymous_args = 0
 3025              	.LVL323:
 3026 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3027              		.cfi_def_cfa_offset 20
 3028              		.cfi_offset 4, -20
 3029              		.cfi_offset 5, -16
 3030              		.cfi_offset 6, -12
 3031              		.cfi_offset 7, -8
 3032              		.cfi_offset 14, -4
 3033 0002 C646     		mov	lr, r8
 3034 0004 00B5     		push	{lr}
 3035              		.cfi_def_cfa_offset 24
 3036              		.cfi_offset 8, -24
 3037 0006 82B0     		sub	sp, sp, #8
 3038              		.cfi_def_cfa_offset 32
 3039 0008 0500     		movs	r5, r0
 3040 000a 0C00     		movs	r4, r1
1094:../drivers/fsl_sai.c ****     assert(handle);
1095:../drivers/fsl_sai.c **** 
1096:../drivers/fsl_sai.c ****     uint8_t *buffer = handle->saiQueue[handle->queueDriver].data;
 3041              		.loc 1 1096 0
 3042 000c 4123     		movs	r3, #65
 3043 000e CB5C     		ldrb	r3, [r1, r3]
 3044 0010 0233     		adds	r3, r3, #2
 3045 0012 DB00     		lsls	r3, r3, #3
 3046 0014 5F58     		ldr	r7, [r3, r1]
 3047              	.LVL324:
1097:../drivers/fsl_sai.c ****     uint8_t dataSize = handle->bitWidth / 8U;
 3048              		.loc 1 1097 0
 3049 0016 0E7B     		ldrb	r6, [r1, #12]
 3050 0018 F608     		lsrs	r6, r6, #3
 3051              	.LVL325:
1098:../drivers/fsl_sai.c **** 
1099:../drivers/fsl_sai.c ****     /* Handle Error */
1100:../drivers/fsl_sai.c ****     if (base->RCSR & I2S_RCSR_FEF_MASK)
 3052              		.loc 1 1100 0
 3053 001a 8023     		movs	r3, #128
 3054 001c C358     		ldr	r3, [r0, r3]
 3055 001e 5B03     		lsls	r3, r3, #13
 3056 0020 3AD4     		bmi	.L178
 3057              	.LVL326:
 3058              	.L173:
1101:../drivers/fsl_sai.c ****     {
1102:../drivers/fsl_sai.c ****         /* Clear FIFO error flag to continue transfer */
1103:../drivers/fsl_sai.c ****         SAI_RxClearStatusFlags(base, kSAI_FIFOErrorFlag);
1104:../drivers/fsl_sai.c **** 
1105:../drivers/fsl_sai.c ****         /* Reset FIFO for safety */
1106:../drivers/fsl_sai.c ****         SAI_RxSoftwareReset(base, kSAI_ResetTypeFIFO);
1107:../drivers/fsl_sai.c **** 
1108:../drivers/fsl_sai.c ****         /* Call the callback */
1109:../drivers/fsl_sai.c ****         if (handle->callback)
1110:../drivers/fsl_sai.c ****         {
1111:../drivers/fsl_sai.c ****             (handle->callback)(base, handle, kStatus_SAI_RxError, handle->userData);
1112:../drivers/fsl_sai.c ****         }
1113:../drivers/fsl_sai.c ****     }
1114:../drivers/fsl_sai.c **** 
1115:../drivers/fsl_sai.c **** /* Handle transfer */
1116:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
1117:../drivers/fsl_sai.c ****     if (base->RCSR & I2S_RCSR_FRF_MASK)
1118:../drivers/fsl_sai.c ****     {
1119:../drivers/fsl_sai.c ****         /* Judge if the data need to transmit is less than space */
1120:../drivers/fsl_sai.c ****         uint8_t size = MIN((handle->saiQueue[handle->queueDriver].dataSize), (handle->watermark * d
1121:../drivers/fsl_sai.c **** 
1122:../drivers/fsl_sai.c ****         /* Copy the data from sai buffer to FIFO */
1123:../drivers/fsl_sai.c ****         SAI_ReadNonBlocking(base, handle->channel, handle->bitWidth, buffer, size);
1124:../drivers/fsl_sai.c **** 
1125:../drivers/fsl_sai.c ****         /* Update the internal counter */
1126:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].dataSize -= size;
1127:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].data += size;
1128:../drivers/fsl_sai.c ****     }
1129:../drivers/fsl_sai.c **** #else
1130:../drivers/fsl_sai.c ****     if (base->RCSR & I2S_RCSR_FWF_MASK)
 3059              		.loc 1 1130 0
 3060 0022 8023     		movs	r3, #128
 3061 0024 EB58     		ldr	r3, [r5, r3]
 3062 0026 9B03     		lsls	r3, r3, #14
 3063 0028 23D5     		bpl	.L174
 3064              	.LBB63:
1131:../drivers/fsl_sai.c ****     {
1132:../drivers/fsl_sai.c ****         uint8_t size = MIN((handle->saiQueue[handle->queueDriver].dataSize), dataSize);
 3065              		.loc 1 1132 0
 3066 002a 4123     		movs	r3, #65
 3067 002c E35C     		ldrb	r3, [r4, r3]
 3068 002e 0233     		adds	r3, r3, #2
 3069 0030 DB00     		lsls	r3, r3, #3
 3070 0032 E318     		adds	r3, r4, r3
 3071 0034 5B68     		ldr	r3, [r3, #4]
 3072 0036 B342     		cmp	r3, r6
 3073 0038 05D2     		bcs	.L175
 3074              		.loc 1 1132 0 is_stmt 0 discriminator 1
 3075 003a 4123     		movs	r3, #65
 3076 003c E35C     		ldrb	r3, [r4, r3]
 3077 003e 0233     		adds	r3, r3, #2
 3078 0040 DB00     		lsls	r3, r3, #3
 3079 0042 E318     		adds	r3, r4, r3
 3080 0044 1E79     		ldrb	r6, [r3, #4]
 3081              	.LVL327:
 3082              	.L175:
1133:../drivers/fsl_sai.c **** 
1134:../drivers/fsl_sai.c ****         SAI_ReadNonBlocking(base, handle->channel, handle->bitWidth, buffer, size);
 3083              		.loc 1 1134 0 is_stmt 1 discriminator 4
 3084 0046 617B     		ldrb	r1, [r4, #13]
 3085 0048 227B     		ldrb	r2, [r4, #12]
 3086 004a 0096     		str	r6, [sp]
 3087 004c 3B00     		movs	r3, r7
 3088 004e 2800     		movs	r0, r5
 3089 0050 FFF7FEFF 		bl	SAI_ReadNonBlocking
 3090              	.LVL328:
1135:../drivers/fsl_sai.c **** 
1136:../drivers/fsl_sai.c ****         /* Update internal state */
1137:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].dataSize -= size;
 3091              		.loc 1 1137 0 discriminator 4
 3092 0054 4121     		movs	r1, #65
 3093 0056 635C     		ldrb	r3, [r4, r1]
 3094 0058 0233     		adds	r3, r3, #2
 3095 005a DB00     		lsls	r3, r3, #3
 3096 005c E318     		adds	r3, r4, r3
 3097 005e 5A68     		ldr	r2, [r3, #4]
 3098 0060 921B     		subs	r2, r2, r6
 3099 0062 5A60     		str	r2, [r3, #4]
1138:../drivers/fsl_sai.c ****         handle->saiQueue[handle->queueDriver].data += size;
 3100              		.loc 1 1138 0 discriminator 4
 3101 0064 635C     		ldrb	r3, [r4, r1]
 3102 0066 0233     		adds	r3, r3, #2
 3103 0068 DB00     		lsls	r3, r3, #3
 3104 006a 1A59     		ldr	r2, [r3, r4]
 3105 006c 9446     		mov	ip, r2
 3106 006e 6644     		add	r6, r6, ip
 3107              	.LVL329:
 3108 0070 1E51     		str	r6, [r3, r4]
 3109              	.L174:
 3110              	.LBE63:
1139:../drivers/fsl_sai.c ****     }
1140:../drivers/fsl_sai.c **** #endif /* FSL_FEATURE_SAI_FIFO_COUNT */
1141:../drivers/fsl_sai.c **** 
1142:../drivers/fsl_sai.c ****     /* If finished a blcok, call the callback function */
1143:../drivers/fsl_sai.c ****     if (handle->saiQueue[handle->queueDriver].dataSize == 0U)
 3111              		.loc 1 1143 0
 3112 0072 4123     		movs	r3, #65
 3113 0074 E35C     		ldrb	r3, [r4, r3]
 3114 0076 0233     		adds	r3, r3, #2
 3115 0078 DB00     		lsls	r3, r3, #3
 3116 007a E318     		adds	r3, r4, r3
 3117 007c 5B68     		ldr	r3, [r3, #4]
 3118 007e 002B     		cmp	r3, #0
 3119 0080 1FD0     		beq	.L179
 3120              	.L176:
1144:../drivers/fsl_sai.c ****     {
1145:../drivers/fsl_sai.c ****         memset(&handle->saiQueue[handle->queueDriver], 0, sizeof(sai_transfer_t));
1146:../drivers/fsl_sai.c ****         handle->queueDriver = (handle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
1147:../drivers/fsl_sai.c ****         if (handle->callback)
1148:../drivers/fsl_sai.c ****         {
1149:../drivers/fsl_sai.c ****             (handle->callback)(base, handle, kStatus_SAI_RxIdle, handle->userData);
1150:../drivers/fsl_sai.c ****         }
1151:../drivers/fsl_sai.c ****     }
1152:../drivers/fsl_sai.c **** 
1153:../drivers/fsl_sai.c ****     /* If all data finished, just stop the transfer */
1154:../drivers/fsl_sai.c ****     if (handle->saiQueue[handle->queueDriver].data == NULL)
 3121              		.loc 1 1154 0
 3122 0082 4123     		movs	r3, #65
 3123 0084 E35C     		ldrb	r3, [r4, r3]
 3124 0086 0233     		adds	r3, r3, #2
 3125 0088 DB00     		lsls	r3, r3, #3
 3126 008a 1B59     		ldr	r3, [r3, r4]
 3127 008c 002B     		cmp	r3, #0
 3128 008e 2FD0     		beq	.L180
 3129              	.L172:
1155:../drivers/fsl_sai.c ****     {
1156:../drivers/fsl_sai.c ****         SAI_TransferAbortReceive(base, handle);
1157:../drivers/fsl_sai.c ****     }
1158:../drivers/fsl_sai.c **** }
 3130              		.loc 1 1158 0
 3131 0090 02B0     		add	sp, sp, #8
 3132              		@ sp needed
 3133              	.LVL330:
 3134              	.LVL331:
 3135              	.LVL332:
 3136 0092 04BC     		pop	{r2}
 3137 0094 9046     		mov	r8, r2
 3138 0096 F0BD     		pop	{r4, r5, r6, r7, pc}
 3139              	.LVL333:
 3140              	.L178:
 3141              	.LBB64:
 3142              	.LBB65:
 433:../drivers/fsl_sai.h **** }
 3143              		.loc 3 433 0
 3144 0098 8021     		movs	r1, #128
 3145              	.LVL334:
 3146 009a 4358     		ldr	r3, [r0, r1]
 3147 009c 174A     		ldr	r2, .L181
 3148 009e 1A40     		ands	r2, r3
 3149 00a0 8023     		movs	r3, #128
 3150 00a2 DB02     		lsls	r3, r3, #11
 3151 00a4 1343     		orrs	r3, r2
 3152 00a6 4350     		str	r3, [r0, r1]
 3153              	.LVL335:
 3154              	.LBE65:
 3155              	.LBE64:
1106:../drivers/fsl_sai.c **** 
 3156              		.loc 1 1106 0
 3157 00a8 8904     		lsls	r1, r1, #18
 3158 00aa FFF7FEFF 		bl	SAI_RxSoftwareReset
 3159              	.LVL336:
1109:../drivers/fsl_sai.c ****         {
 3160              		.loc 1 1109 0
 3161 00ae 6368     		ldr	r3, [r4, #4]
 3162 00b0 9846     		mov	r8, r3
 3163 00b2 002B     		cmp	r3, #0
 3164 00b4 B5D0     		beq	.L173
1111:../drivers/fsl_sai.c ****         }
 3165              		.loc 1 1111 0
 3166 00b6 A368     		ldr	r3, [r4, #8]
 3167 00b8 114A     		ldr	r2, .L181+4
 3168 00ba 2100     		movs	r1, r4
 3169 00bc 2800     		movs	r0, r5
 3170 00be C047     		blx	r8
 3171              	.LVL337:
 3172 00c0 AFE7     		b	.L173
 3173              	.LVL338:
 3174              	.L179:
1145:../drivers/fsl_sai.c ****         handle->queueDriver = (handle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
 3175              		.loc 1 1145 0
 3176 00c2 4126     		movs	r6, #65
 3177 00c4 A05D     		ldrb	r0, [r4, r6]
 3178 00c6 0230     		adds	r0, r0, #2
 3179 00c8 C000     		lsls	r0, r0, #3
 3180 00ca 2018     		adds	r0, r4, r0
 3181 00cc 0822     		movs	r2, #8
 3182 00ce 0021     		movs	r1, #0
 3183 00d0 FFF7FEFF 		bl	memset
 3184              	.LVL339:
1146:../drivers/fsl_sai.c ****         if (handle->callback)
 3185              		.loc 1 1146 0
 3186 00d4 A25D     		ldrb	r2, [r4, r6]
 3187 00d6 0132     		adds	r2, r2, #1
 3188 00d8 0323     		movs	r3, #3
 3189 00da 1340     		ands	r3, r2
 3190 00dc A355     		strb	r3, [r4, r6]
1147:../drivers/fsl_sai.c ****         {
 3191              		.loc 1 1147 0
 3192 00de 6668     		ldr	r6, [r4, #4]
 3193 00e0 002E     		cmp	r6, #0
 3194 00e2 CED0     		beq	.L176
1149:../drivers/fsl_sai.c ****         }
 3195              		.loc 1 1149 0
 3196 00e4 A368     		ldr	r3, [r4, #8]
 3197 00e6 074A     		ldr	r2, .L181+8
 3198 00e8 2100     		movs	r1, r4
 3199 00ea 2800     		movs	r0, r5
 3200 00ec B047     		blx	r6
 3201              	.LVL340:
 3202 00ee C8E7     		b	.L176
 3203              	.L180:
1156:../drivers/fsl_sai.c ****     }
 3204              		.loc 1 1156 0
 3205 00f0 2100     		movs	r1, r4
 3206 00f2 2800     		movs	r0, r5
 3207 00f4 FFF7FEFF 		bl	SAI_TransferAbortReceive
 3208              	.LVL341:
 3209              		.loc 1 1158 0
 3210 00f8 CAE7     		b	.L172
 3211              	.L182:
 3212 00fa C046     		.align	2
 3213              	.L181:
 3214 00fc FFFFE3FF 		.word	-1835009
 3215 0100 6F070000 		.word	1903
 3216 0104 72070000 		.word	1906
 3217              		.cfi_endproc
 3218              	.LFE100:
 3220              		.section	.text.SAI_TransferTerminateSend,"ax",%progbits
 3221              		.align	1
 3222              		.global	SAI_TransferTerminateSend
 3223              		.syntax unified
 3224              		.code	16
 3225              		.thumb_func
 3226              		.fpu softvfp
 3228              	SAI_TransferTerminateSend:
 3229              	.LFB97:
 996:../drivers/fsl_sai.c ****     assert(handle);
 3230              		.loc 1 996 0
 3231              		.cfi_startproc
 3232              		@ args = 0, pretend = 0, frame = 0
 3233              		@ frame_needed = 0, uses_anonymous_args = 0
 3234              	.LVL342:
 3235 0000 10B5     		push	{r4, lr}
 3236              		.cfi_def_cfa_offset 8
 3237              		.cfi_offset 4, -8
 3238              		.cfi_offset 14, -4
 3239 0002 0C00     		movs	r4, r1
1000:../drivers/fsl_sai.c **** 
 3240              		.loc 1 1000 0
 3241 0004 FFF7FEFF 		bl	SAI_TransferAbortSend
 3242              	.LVL343:
1003:../drivers/fsl_sai.c ****     memset(handle->transferSize, 0U, sizeof(handle->transferSize));
 3243              		.loc 1 1003 0
 3244 0008 2000     		movs	r0, r4
 3245 000a 1030     		adds	r0, r0, #16
 3246 000c 2022     		movs	r2, #32
 3247 000e 0021     		movs	r1, #0
 3248 0010 FFF7FEFF 		bl	memset
 3249              	.LVL344:
1004:../drivers/fsl_sai.c ****     handle->queueUser = 0U;
 3250              		.loc 1 1004 0
 3251 0014 2000     		movs	r0, r4
 3252 0016 3030     		adds	r0, r0, #48
 3253 0018 1022     		movs	r2, #16
 3254 001a 0021     		movs	r1, #0
 3255 001c FFF7FEFF 		bl	memset
 3256              	.LVL345:
1005:../drivers/fsl_sai.c ****     handle->queueDriver = 0U;
 3257              		.loc 1 1005 0
 3258 0020 0023     		movs	r3, #0
 3259 0022 4022     		movs	r2, #64
 3260 0024 A354     		strb	r3, [r4, r2]
1006:../drivers/fsl_sai.c **** }
 3261              		.loc 1 1006 0
 3262 0026 0132     		adds	r2, r2, #1
 3263 0028 A354     		strb	r3, [r4, r2]
1007:../drivers/fsl_sai.c **** 
 3264              		.loc 1 1007 0
 3265              		@ sp needed
 3266              	.LVL346:
 3267 002a 10BD     		pop	{r4, pc}
 3268              		.cfi_endproc
 3269              	.LFE97:
 3271              		.section	.text.SAI_TransferTerminateReceive,"ax",%progbits
 3272              		.align	1
 3273              		.global	SAI_TransferTerminateReceive
 3274              		.syntax unified
 3275              		.code	16
 3276              		.thumb_func
 3277              		.fpu softvfp
 3279              	SAI_TransferTerminateReceive:
 3280              	.LFB98:
1010:../drivers/fsl_sai.c ****     assert(handle);
 3281              		.loc 1 1010 0
 3282              		.cfi_startproc
 3283              		@ args = 0, pretend = 0, frame = 0
 3284              		@ frame_needed = 0, uses_anonymous_args = 0
 3285              	.LVL347:
 3286 0000 10B5     		push	{r4, lr}
 3287              		.cfi_def_cfa_offset 8
 3288              		.cfi_offset 4, -8
 3289              		.cfi_offset 14, -4
 3290 0002 0C00     		movs	r4, r1
1014:../drivers/fsl_sai.c **** 
 3291              		.loc 1 1014 0
 3292 0004 FFF7FEFF 		bl	SAI_TransferAbortReceive
 3293              	.LVL348:
1017:../drivers/fsl_sai.c ****     memset(handle->transferSize, 0U, sizeof(handle->transferSize));
 3294              		.loc 1 1017 0
 3295 0008 2000     		movs	r0, r4
 3296 000a 1030     		adds	r0, r0, #16
 3297 000c 2022     		movs	r2, #32
 3298 000e 0021     		movs	r1, #0
 3299 0010 FFF7FEFF 		bl	memset
 3300              	.LVL349:
1018:../drivers/fsl_sai.c ****     handle->queueUser = 0U;
 3301              		.loc 1 1018 0
 3302 0014 2000     		movs	r0, r4
 3303 0016 3030     		adds	r0, r0, #48
 3304 0018 1022     		movs	r2, #16
 3305 001a 0021     		movs	r1, #0
 3306 001c FFF7FEFF 		bl	memset
 3307              	.LVL350:
1019:../drivers/fsl_sai.c ****     handle->queueDriver = 0U;
 3308              		.loc 1 1019 0
 3309 0020 0023     		movs	r3, #0
 3310 0022 4022     		movs	r2, #64
 3311 0024 A354     		strb	r3, [r4, r2]
1020:../drivers/fsl_sai.c **** }
 3312              		.loc 1 1020 0
 3313 0026 0132     		adds	r2, r2, #1
 3314 0028 A354     		strb	r3, [r4, r2]
1021:../drivers/fsl_sai.c **** 
 3315              		.loc 1 1021 0
 3316              		@ sp needed
 3317              	.LVL351:
 3318 002a 10BD     		pop	{r4, pc}
 3319              		.cfi_endproc
 3320              	.LFE98:
 3322              		.section	.text.I2S0_DriverIRQHandler,"ax",%progbits
 3323              		.align	1
 3324              		.global	I2S0_DriverIRQHandler
 3325              		.syntax unified
 3326              		.code	16
 3327              		.thumb_func
 3328              		.fpu softvfp
 3330              	I2S0_DriverIRQHandler:
 3331              	.LFB101:
1159:../drivers/fsl_sai.c **** 
1160:../drivers/fsl_sai.c **** #if defined(I2S0)
1161:../drivers/fsl_sai.c **** void I2S0_DriverIRQHandler(void)
1162:../drivers/fsl_sai.c **** {
 3332              		.loc 1 1162 0
 3333              		.cfi_startproc
 3334              		@ args = 0, pretend = 0, frame = 0
 3335              		@ frame_needed = 0, uses_anonymous_args = 0
 3336 0000 10B5     		push	{r4, lr}
 3337              		.cfi_def_cfa_offset 8
 3338              		.cfi_offset 4, -8
 3339              		.cfi_offset 14, -4
1163:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
1164:../drivers/fsl_sai.c ****     if ((s_saiHandle[0][1]) && ((I2S0->RCSR & kSAI_FIFORequestFlag) || (I2S0->RCSR & kSAI_FIFOError
1165:../drivers/fsl_sai.c ****         ((I2S0->RCSR & kSAI_FIFORequestInterruptEnable) || (I2S0->RCSR & kSAI_FIFOErrorInterruptEna
1166:../drivers/fsl_sai.c **** #else
1167:../drivers/fsl_sai.c ****     if ((s_saiHandle[0][1]) && ((I2S0->RCSR & kSAI_FIFOWarningFlag) || (I2S0->RCSR & kSAI_FIFOError
 3340              		.loc 1 1167 0
 3341 0002 1A4B     		ldr	r3, .L194
 3342 0004 5968     		ldr	r1, [r3, #4]
 3343 0006 0029     		cmp	r1, #0
 3344 0008 11D0     		beq	.L186
 3345              		.loc 1 1167 0 is_stmt 0 discriminator 1
 3346 000a 194A     		ldr	r2, .L194+4
 3347 000c 8023     		movs	r3, #128
 3348 000e D358     		ldr	r3, [r2, r3]
 3349 0010 9B03     		lsls	r3, r3, #14
 3350 0012 03D4     		bmi	.L187
 3351              		.loc 1 1167 0 discriminator 3
 3352 0014 8023     		movs	r3, #128
 3353 0016 D358     		ldr	r3, [r2, r3]
 3354 0018 5B03     		lsls	r3, r3, #13
 3355 001a 08D5     		bpl	.L186
 3356              	.L187:
1168:../drivers/fsl_sai.c ****         ((I2S0->RCSR & kSAI_FIFOWarningInterruptEnable) || (I2S0->RCSR & kSAI_FIFOErrorInterruptEna
 3357              		.loc 1 1168 0 is_stmt 1 discriminator 4
 3358 001c 144A     		ldr	r2, .L194+4
 3359 001e 8023     		movs	r3, #128
 3360 0020 D358     		ldr	r3, [r2, r3]
1167:../drivers/fsl_sai.c ****         ((I2S0->RCSR & kSAI_FIFOWarningInterruptEnable) || (I2S0->RCSR & kSAI_FIFOErrorInterruptEna
 3361              		.loc 1 1167 0 discriminator 4
 3362 0022 9B05     		lsls	r3, r3, #22
 3363 0024 18D5     		bpl	.L192
 3364              	.L188:
1169:../drivers/fsl_sai.c **** #endif
1170:../drivers/fsl_sai.c ****     {
1171:../drivers/fsl_sai.c ****         s_saiRxIsr(I2S0, s_saiHandle[0][1]);
 3365              		.loc 1 1171 0
 3366 0026 134B     		ldr	r3, .L194+8
 3367 0028 1B68     		ldr	r3, [r3]
 3368 002a 1148     		ldr	r0, .L194+4
 3369 002c 9847     		blx	r3
 3370              	.LVL352:
 3371              	.L186:
1172:../drivers/fsl_sai.c ****     }
1173:../drivers/fsl_sai.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
1174:../drivers/fsl_sai.c ****     if ((s_saiHandle[0][0]) && ((I2S0->TCSR & kSAI_FIFORequestFlag) || (I2S0->TCSR & kSAI_FIFOError
1175:../drivers/fsl_sai.c ****         ((I2S0->TCSR & kSAI_FIFORequestInterruptEnable) || (I2S0->TCSR & kSAI_FIFOErrorInterruptEna
1176:../drivers/fsl_sai.c **** #else
1177:../drivers/fsl_sai.c ****     if ((s_saiHandle[0][0]) && ((I2S0->TCSR & kSAI_FIFOWarningFlag) || (I2S0->TCSR & kSAI_FIFOError
 3372              		.loc 1 1177 0
 3373 002e 0F4B     		ldr	r3, .L194
 3374 0030 1968     		ldr	r1, [r3]
 3375 0032 0029     		cmp	r1, #0
 3376 0034 0FD0     		beq	.L185
 3377              		.loc 1 1177 0 is_stmt 0 discriminator 1
 3378 0036 0E4B     		ldr	r3, .L194+4
 3379 0038 1B68     		ldr	r3, [r3]
 3380 003a 9B03     		lsls	r3, r3, #14
 3381 003c 03D4     		bmi	.L190
 3382              		.loc 1 1177 0 discriminator 3
 3383 003e 0C4B     		ldr	r3, .L194+4
 3384 0040 1B68     		ldr	r3, [r3]
 3385 0042 5B03     		lsls	r3, r3, #13
 3386 0044 07D5     		bpl	.L185
 3387              	.L190:
1178:../drivers/fsl_sai.c ****         ((I2S0->TCSR & kSAI_FIFOWarningInterruptEnable) || (I2S0->TCSR & kSAI_FIFOErrorInterruptEna
 3388              		.loc 1 1178 0 is_stmt 1 discriminator 4
 3389 0046 0A4B     		ldr	r3, .L194+4
 3390 0048 1B68     		ldr	r3, [r3]
1177:../drivers/fsl_sai.c ****         ((I2S0->TCSR & kSAI_FIFOWarningInterruptEnable) || (I2S0->TCSR & kSAI_FIFOErrorInterruptEna
 3391              		.loc 1 1177 0 discriminator 4
 3392 004a 9B05     		lsls	r3, r3, #22
 3393 004c 09D5     		bpl	.L193
 3394              	.L191:
1179:../drivers/fsl_sai.c **** #endif
1180:../drivers/fsl_sai.c ****     {
1181:../drivers/fsl_sai.c ****         s_saiTxIsr(I2S0, s_saiHandle[0][0]);
 3395              		.loc 1 1181 0
 3396 004e 0A4B     		ldr	r3, .L194+12
 3397 0050 1B68     		ldr	r3, [r3]
 3398 0052 0748     		ldr	r0, .L194+4
 3399 0054 9847     		blx	r3
 3400              	.LVL353:
 3401              	.L185:
1182:../drivers/fsl_sai.c ****     }
1183:../drivers/fsl_sai.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1184:../drivers/fsl_sai.c ****   exception return operation might vector to incorrect interrupt */
1185:../drivers/fsl_sai.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1186:../drivers/fsl_sai.c ****     __DSB();
1187:../drivers/fsl_sai.c **** #endif
1188:../drivers/fsl_sai.c **** }
 3402              		.loc 1 1188 0
 3403              		@ sp needed
 3404 0056 10BD     		pop	{r4, pc}
 3405              	.L192:
1168:../drivers/fsl_sai.c **** #endif
 3406              		.loc 1 1168 0
 3407 0058 8023     		movs	r3, #128
 3408 005a D358     		ldr	r3, [r2, r3]
 3409 005c 5B05     		lsls	r3, r3, #21
 3410 005e E6D5     		bpl	.L186
 3411 0060 E1E7     		b	.L188
 3412              	.L193:
1178:../drivers/fsl_sai.c **** #endif
 3413              		.loc 1 1178 0
 3414 0062 034B     		ldr	r3, .L194+4
 3415 0064 1B68     		ldr	r3, [r3]
 3416 0066 5B05     		lsls	r3, r3, #21
 3417 0068 F1D4     		bmi	.L191
 3418 006a F4E7     		b	.L185
 3419              	.L195:
 3420              		.align	2
 3421              	.L194:
 3422 006c 00000000 		.word	s_saiHandle
 3423 0070 00F00240 		.word	1073934336
 3424 0074 00000000 		.word	.LANCHOR1
 3425 0078 00000000 		.word	.LANCHOR0
 3426              		.cfi_endproc
 3427              	.LFE101:
 3429              		.section	.text.I2S0_Tx_DriverIRQHandler,"ax",%progbits
 3430              		.align	1
 3431              		.global	I2S0_Tx_DriverIRQHandler
 3432              		.syntax unified
 3433              		.code	16
 3434              		.thumb_func
 3435              		.fpu softvfp
 3437              	I2S0_Tx_DriverIRQHandler:
 3438              	.LFB102:
1189:../drivers/fsl_sai.c **** 
1190:../drivers/fsl_sai.c **** void I2S0_Tx_DriverIRQHandler(void)
1191:../drivers/fsl_sai.c **** {
 3439              		.loc 1 1191 0
 3440              		.cfi_startproc
 3441              		@ args = 0, pretend = 0, frame = 0
 3442              		@ frame_needed = 0, uses_anonymous_args = 0
 3443 0000 10B5     		push	{r4, lr}
 3444              		.cfi_def_cfa_offset 8
 3445              		.cfi_offset 4, -8
 3446              		.cfi_offset 14, -4
1192:../drivers/fsl_sai.c ****     assert(s_saiHandle[0][0]);
1193:../drivers/fsl_sai.c ****     s_saiTxIsr(I2S0, s_saiHandle[0][0]);
 3447              		.loc 1 1193 0
 3448 0002 034B     		ldr	r3, .L197
 3449 0004 1968     		ldr	r1, [r3]
 3450 0006 034B     		ldr	r3, .L197+4
 3451 0008 1B68     		ldr	r3, [r3]
 3452 000a 0348     		ldr	r0, .L197+8
 3453 000c 9847     		blx	r3
 3454              	.LVL354:
1194:../drivers/fsl_sai.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1195:../drivers/fsl_sai.c ****   exception return operation might vector to incorrect interrupt */
1196:../drivers/fsl_sai.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1197:../drivers/fsl_sai.c ****     __DSB();
1198:../drivers/fsl_sai.c **** #endif
1199:../drivers/fsl_sai.c **** }
 3455              		.loc 1 1199 0
 3456              		@ sp needed
 3457 000e 10BD     		pop	{r4, pc}
 3458              	.L198:
 3459              		.align	2
 3460              	.L197:
 3461 0010 00000000 		.word	s_saiHandle
 3462 0014 00000000 		.word	.LANCHOR0
 3463 0018 00F00240 		.word	1073934336
 3464              		.cfi_endproc
 3465              	.LFE102:
 3467              		.section	.text.I2S0_Rx_DriverIRQHandler,"ax",%progbits
 3468              		.align	1
 3469              		.global	I2S0_Rx_DriverIRQHandler
 3470              		.syntax unified
 3471              		.code	16
 3472              		.thumb_func
 3473              		.fpu softvfp
 3475              	I2S0_Rx_DriverIRQHandler:
 3476              	.LFB103:
1200:../drivers/fsl_sai.c **** 
1201:../drivers/fsl_sai.c **** void I2S0_Rx_DriverIRQHandler(void)
1202:../drivers/fsl_sai.c **** {
 3477              		.loc 1 1202 0
 3478              		.cfi_startproc
 3479              		@ args = 0, pretend = 0, frame = 0
 3480              		@ frame_needed = 0, uses_anonymous_args = 0
 3481 0000 10B5     		push	{r4, lr}
 3482              		.cfi_def_cfa_offset 8
 3483              		.cfi_offset 4, -8
 3484              		.cfi_offset 14, -4
1203:../drivers/fsl_sai.c ****     assert(s_saiHandle[0][1]);
1204:../drivers/fsl_sai.c ****     s_saiRxIsr(I2S0, s_saiHandle[0][1]);
 3485              		.loc 1 1204 0
 3486 0002 034B     		ldr	r3, .L200
 3487 0004 5968     		ldr	r1, [r3, #4]
 3488 0006 034B     		ldr	r3, .L200+4
 3489 0008 1B68     		ldr	r3, [r3]
 3490 000a 0348     		ldr	r0, .L200+8
 3491 000c 9847     		blx	r3
 3492              	.LVL355:
1205:../drivers/fsl_sai.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1206:../drivers/fsl_sai.c ****   exception return operation might vector to incorrect interrupt */
1207:../drivers/fsl_sai.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1208:../drivers/fsl_sai.c ****     __DSB();
1209:../drivers/fsl_sai.c **** #endif
1210:../drivers/fsl_sai.c **** }
 3493              		.loc 1 1210 0
 3494              		@ sp needed
 3495 000e 10BD     		pop	{r4, pc}
 3496              	.L201:
 3497              		.align	2
 3498              	.L200:
 3499 0010 00000000 		.word	s_saiHandle
 3500 0014 00000000 		.word	.LANCHOR1
 3501 0018 00F00240 		.word	1073934336
 3502              		.cfi_endproc
 3503              	.LFE103:
 3505              		.comm	s_saiHandle,8,4
 3506              		.section	.bss.s_saiRxIsr,"aw",%nobits
 3507              		.align	2
 3508              		.set	.LANCHOR1,. + 0
 3511              	s_saiRxIsr:
 3512 0000 00000000 		.space	4
 3513              		.section	.bss.s_saiTxIsr,"aw",%nobits
 3514              		.align	2
 3515              		.set	.LANCHOR0,. + 0
 3518              	s_saiTxIsr:
 3519 0000 00000000 		.space	4
 3520              		.text
 3521              	.Letext0:
 3522              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 3523              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 3524              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 3525              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 3526              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 3527              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 3528              		.file 11 "../CMSIS/MKL17Z4.h"
 3529              		.file 12 "../CMSIS/system_MKL17Z4.h"
 3530              		.file 13 "../drivers/fsl_common.h"
 3531              		.file 14 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_sai.c
     /tmp/ccbjkZRl.s:17     .text.SAI_WriteNonBlocking:0000000000000000 $t
     /tmp/ccbjkZRl.s:23     .text.SAI_WriteNonBlocking:0000000000000000 SAI_WriteNonBlocking
     /tmp/ccbjkZRl.s:120    .text.SAI_ReadNonBlocking:0000000000000000 $t
     /tmp/ccbjkZRl.s:126    .text.SAI_ReadNonBlocking:0000000000000000 SAI_ReadNonBlocking
     /tmp/ccbjkZRl.s:217    .text.SAI_GetInstance:0000000000000000 $t
     /tmp/ccbjkZRl.s:224    .text.SAI_GetInstance:0000000000000000 SAI_GetInstance
     /tmp/ccbjkZRl.s:258    .text.SAI_GetInstance:0000000000000014 $d
     /tmp/ccbjkZRl.s:263    .text.SAI_TxInit:0000000000000000 $t
     /tmp/ccbjkZRl.s:270    .text.SAI_TxInit:0000000000000000 SAI_TxInit
     /tmp/ccbjkZRl.s:340    .rodata.SAI_TxInit:0000000000000000 $d
     /tmp/ccbjkZRl.s:570    .text.SAI_TxInit:0000000000000158 $d
     /tmp/ccbjkZRl.s:585    .text.SAI_RxInit:0000000000000000 $t
     /tmp/ccbjkZRl.s:592    .text.SAI_RxInit:0000000000000000 SAI_RxInit
     /tmp/ccbjkZRl.s:661    .rodata.SAI_RxInit:0000000000000000 $d
     /tmp/ccbjkZRl.s:920    .text.SAI_RxInit:0000000000000184 $d
     /tmp/ccbjkZRl.s:935    .text.SAI_TxGetDefaultConfig:0000000000000000 $t
     /tmp/ccbjkZRl.s:942    .text.SAI_TxGetDefaultConfig:0000000000000000 SAI_TxGetDefaultConfig
     /tmp/ccbjkZRl.s:971    .text.SAI_RxGetDefaultConfig:0000000000000000 $t
     /tmp/ccbjkZRl.s:978    .text.SAI_RxGetDefaultConfig:0000000000000000 SAI_RxGetDefaultConfig
     /tmp/ccbjkZRl.s:1007   .text.SAI_TxReset:0000000000000000 $t
     /tmp/ccbjkZRl.s:1014   .text.SAI_TxReset:0000000000000000 SAI_TxReset
     /tmp/ccbjkZRl.s:1048   .text.SAI_TxReset:000000000000001c $d
     /tmp/ccbjkZRl.s:1053   .text.SAI_RxReset:0000000000000000 $t
     /tmp/ccbjkZRl.s:1060   .text.SAI_RxReset:0000000000000000 SAI_RxReset
     /tmp/ccbjkZRl.s:1100   .text.SAI_RxReset:0000000000000028 $d
     /tmp/ccbjkZRl.s:1105   .text.SAI_TxEnable:0000000000000000 $t
     /tmp/ccbjkZRl.s:1112   .text.SAI_TxEnable:0000000000000000 SAI_TxEnable
     /tmp/ccbjkZRl.s:1188   .text.SAI_TxEnable:0000000000000050 $d
     /tmp/ccbjkZRl.s:1194   .text.SAI_RxEnable:0000000000000000 $t
     /tmp/ccbjkZRl.s:1201   .text.SAI_RxEnable:0000000000000000 SAI_RxEnable
     /tmp/ccbjkZRl.s:1276   .text.SAI_RxEnable:0000000000000054 $d
     /tmp/ccbjkZRl.s:1282   .text.SAI_Deinit:0000000000000000 $t
     /tmp/ccbjkZRl.s:1289   .text.SAI_Deinit:0000000000000000 SAI_Deinit
     /tmp/ccbjkZRl.s:1332   .text.SAI_Deinit:0000000000000024 $d
     /tmp/ccbjkZRl.s:1338   .text.SAI_TxSoftwareReset:0000000000000000 $t
     /tmp/ccbjkZRl.s:1345   .text.SAI_TxSoftwareReset:0000000000000000 SAI_TxSoftwareReset
     /tmp/ccbjkZRl.s:1369   .text.SAI_TxSoftwareReset:0000000000000010 $d
     /tmp/ccbjkZRl.s:1374   .text.SAI_RxSoftwareReset:0000000000000000 $t
     /tmp/ccbjkZRl.s:1381   .text.SAI_RxSoftwareReset:0000000000000000 SAI_RxSoftwareReset
     /tmp/ccbjkZRl.s:1406   .text.SAI_RxSoftwareReset:0000000000000014 $d
     /tmp/ccbjkZRl.s:1411   .text.SAI_TxSetChannelFIFOMask:0000000000000000 $t
     /tmp/ccbjkZRl.s:1418   .text.SAI_TxSetChannelFIFOMask:0000000000000000 SAI_TxSetChannelFIFOMask
     /tmp/ccbjkZRl.s:1446   .text.SAI_TxSetChannelFIFOMask:0000000000000018 $d
     /tmp/ccbjkZRl.s:1451   .text.SAI_RxSetChannelFIFOMask:0000000000000000 $t
     /tmp/ccbjkZRl.s:1458   .text.SAI_RxSetChannelFIFOMask:0000000000000000 SAI_RxSetChannelFIFOMask
     /tmp/ccbjkZRl.s:1490   .text.SAI_RxSetChannelFIFOMask:000000000000001c $d
     /tmp/ccbjkZRl.s:1495   .text.SAI_TxSetFormat:0000000000000000 $t
     /tmp/ccbjkZRl.s:1502   .text.SAI_TxSetFormat:0000000000000000 SAI_TxSetFormat
     /tmp/ccbjkZRl.s:1676   .text.SAI_TxSetFormat:00000000000000d4 $d
     /tmp/ccbjkZRl.s:1682   .text.SAI_RxSetFormat:0000000000000000 $t
     /tmp/ccbjkZRl.s:1689   .text.SAI_RxSetFormat:0000000000000000 SAI_RxSetFormat
     /tmp/ccbjkZRl.s:1877   .text.SAI_RxSetFormat:00000000000000ec $d
     /tmp/ccbjkZRl.s:1883   .text.SAI_WriteBlocking:0000000000000000 $t
     /tmp/ccbjkZRl.s:1890   .text.SAI_WriteBlocking:0000000000000000 SAI_WriteBlocking
     /tmp/ccbjkZRl.s:1975   .text.SAI_ReadBlocking:0000000000000000 $t
     /tmp/ccbjkZRl.s:1982   .text.SAI_ReadBlocking:0000000000000000 SAI_ReadBlocking
     /tmp/ccbjkZRl.s:2063   .text.SAI_TransferTxCreateHandle:0000000000000000 $t
     /tmp/ccbjkZRl.s:2070   .text.SAI_TransferTxCreateHandle:0000000000000000 SAI_TransferTxCreateHandle
     /tmp/ccbjkZRl.s:2137   .text.SAI_TransferTxCreateHandle:0000000000000034 $d
                            *COM*:0000000000000008 s_saiHandle
     /tmp/ccbjkZRl.s:2744   .text.SAI_TransferTxHandleIRQ:0000000000000000 SAI_TransferTxHandleIRQ
     /tmp/ccbjkZRl.s:2145   .text.SAI_TransferRxCreateHandle:0000000000000000 $t
     /tmp/ccbjkZRl.s:2152   .text.SAI_TransferRxCreateHandle:0000000000000000 SAI_TransferRxCreateHandle
     /tmp/ccbjkZRl.s:2219   .text.SAI_TransferRxCreateHandle:0000000000000038 $d
     /tmp/ccbjkZRl.s:3019   .text.SAI_TransferRxHandleIRQ:0000000000000000 SAI_TransferRxHandleIRQ
     /tmp/ccbjkZRl.s:2227   .text.SAI_TransferTxSetFormat:0000000000000000 $t
     /tmp/ccbjkZRl.s:2234   .text.SAI_TransferTxSetFormat:0000000000000000 SAI_TransferTxSetFormat
     /tmp/ccbjkZRl.s:2293   .text.SAI_TransferRxSetFormat:0000000000000000 $t
     /tmp/ccbjkZRl.s:2300   .text.SAI_TransferRxSetFormat:0000000000000000 SAI_TransferRxSetFormat
     /tmp/ccbjkZRl.s:2359   .text.SAI_TransferSendNonBlocking:0000000000000000 $t
     /tmp/ccbjkZRl.s:2366   .text.SAI_TransferSendNonBlocking:0000000000000000 SAI_TransferSendNonBlocking
     /tmp/ccbjkZRl.s:2453   .text.SAI_TransferSendNonBlocking:0000000000000060 $d
     /tmp/ccbjkZRl.s:2458   .text.SAI_TransferReceiveNonBlocking:0000000000000000 $t
     /tmp/ccbjkZRl.s:2465   .text.SAI_TransferReceiveNonBlocking:0000000000000000 SAI_TransferReceiveNonBlocking
     /tmp/ccbjkZRl.s:2553   .text.SAI_TransferReceiveNonBlocking:0000000000000060 $d
     /tmp/ccbjkZRl.s:2558   .text.SAI_TransferGetSendCount:0000000000000000 $t
     /tmp/ccbjkZRl.s:2565   .text.SAI_TransferGetSendCount:0000000000000000 SAI_TransferGetSendCount
     /tmp/ccbjkZRl.s:2614   .text.SAI_TransferGetReceiveCount:0000000000000000 $t
     /tmp/ccbjkZRl.s:2621   .text.SAI_TransferGetReceiveCount:0000000000000000 SAI_TransferGetReceiveCount
     /tmp/ccbjkZRl.s:2670   .text.SAI_TransferAbortSend:0000000000000000 $t
     /tmp/ccbjkZRl.s:2677   .text.SAI_TransferAbortSend:0000000000000000 SAI_TransferAbortSend
     /tmp/ccbjkZRl.s:2732   .text.SAI_TransferAbortSend:0000000000000030 $d
     /tmp/ccbjkZRl.s:2737   .text.SAI_TransferTxHandleIRQ:0000000000000000 $t
     /tmp/ccbjkZRl.s:2937   .text.SAI_TransferTxHandleIRQ:00000000000000f8 $d
     /tmp/ccbjkZRl.s:2944   .text.SAI_TransferAbortReceive:0000000000000000 $t
     /tmp/ccbjkZRl.s:2951   .text.SAI_TransferAbortReceive:0000000000000000 SAI_TransferAbortReceive
     /tmp/ccbjkZRl.s:3007   .text.SAI_TransferAbortReceive:0000000000000034 $d
     /tmp/ccbjkZRl.s:3012   .text.SAI_TransferRxHandleIRQ:0000000000000000 $t
     /tmp/ccbjkZRl.s:3214   .text.SAI_TransferRxHandleIRQ:00000000000000fc $d
     /tmp/ccbjkZRl.s:3221   .text.SAI_TransferTerminateSend:0000000000000000 $t
     /tmp/ccbjkZRl.s:3228   .text.SAI_TransferTerminateSend:0000000000000000 SAI_TransferTerminateSend
     /tmp/ccbjkZRl.s:3272   .text.SAI_TransferTerminateReceive:0000000000000000 $t
     /tmp/ccbjkZRl.s:3279   .text.SAI_TransferTerminateReceive:0000000000000000 SAI_TransferTerminateReceive
     /tmp/ccbjkZRl.s:3323   .text.I2S0_DriverIRQHandler:0000000000000000 $t
     /tmp/ccbjkZRl.s:3330   .text.I2S0_DriverIRQHandler:0000000000000000 I2S0_DriverIRQHandler
     /tmp/ccbjkZRl.s:3422   .text.I2S0_DriverIRQHandler:000000000000006c $d
     /tmp/ccbjkZRl.s:3430   .text.I2S0_Tx_DriverIRQHandler:0000000000000000 $t
     /tmp/ccbjkZRl.s:3437   .text.I2S0_Tx_DriverIRQHandler:0000000000000000 I2S0_Tx_DriverIRQHandler
     /tmp/ccbjkZRl.s:3461   .text.I2S0_Tx_DriverIRQHandler:0000000000000010 $d
     /tmp/ccbjkZRl.s:3468   .text.I2S0_Rx_DriverIRQHandler:0000000000000000 $t
     /tmp/ccbjkZRl.s:3475   .text.I2S0_Rx_DriverIRQHandler:0000000000000000 I2S0_Rx_DriverIRQHandler
     /tmp/ccbjkZRl.s:3499   .text.I2S0_Rx_DriverIRQHandler:0000000000000010 $d
     /tmp/ccbjkZRl.s:3507   .bss.s_saiRxIsr:0000000000000000 $d
     /tmp/ccbjkZRl.s:3511   .bss.s_saiRxIsr:0000000000000000 s_saiRxIsr
     /tmp/ccbjkZRl.s:3514   .bss.s_saiTxIsr:0000000000000000 $d
     /tmp/ccbjkZRl.s:3518   .bss.s_saiTxIsr:0000000000000000 s_saiTxIsr

UNDEFINED SYMBOLS
__aeabi_uidiv
memset
