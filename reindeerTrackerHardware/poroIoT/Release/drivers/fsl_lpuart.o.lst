   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_lpuart.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.LPUART_WriteNonBlocking,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	LPUART_WriteNonBlocking:
  23              	.LFB63:
  24              		.file 1 "../drivers/fsl_lpuart.c"
   1:../drivers/fsl_lpuart.c **** /*
   2:../drivers/fsl_lpuart.c ****  * The Clear BSD License
   3:../drivers/fsl_lpuart.c ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_lpuart.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_lpuart.c ****  * All rights reserved.
   6:../drivers/fsl_lpuart.c ****  *
   7:../drivers/fsl_lpuart.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_lpuart.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_lpuart.c ****  * that the following conditions are met:
  10:../drivers/fsl_lpuart.c ****  *
  11:../drivers/fsl_lpuart.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_lpuart.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_lpuart.c ****  *
  14:../drivers/fsl_lpuart.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_lpuart.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_lpuart.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_lpuart.c ****  *
  18:../drivers/fsl_lpuart.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_lpuart.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_lpuart.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_lpuart.c ****  *
  22:../drivers/fsl_lpuart.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_lpuart.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_lpuart.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_lpuart.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_lpuart.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_lpuart.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_lpuart.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_lpuart.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_lpuart.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_lpuart.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_lpuart.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_lpuart.c ****  */
  34:../drivers/fsl_lpuart.c **** 
  35:../drivers/fsl_lpuart.c **** #include "fsl_lpuart.h"
  36:../drivers/fsl_lpuart.c **** 
  37:../drivers/fsl_lpuart.c **** /*******************************************************************************
  38:../drivers/fsl_lpuart.c ****  * Definitions
  39:../drivers/fsl_lpuart.c ****  ******************************************************************************/
  40:../drivers/fsl_lpuart.c **** /* LPUART transfer state. */
  41:../drivers/fsl_lpuart.c **** enum _lpuart_transfer_states
  42:../drivers/fsl_lpuart.c **** {
  43:../drivers/fsl_lpuart.c ****     kLPUART_TxIdle, /*!< TX idle. */
  44:../drivers/fsl_lpuart.c ****     kLPUART_TxBusy, /*!< TX busy. */
  45:../drivers/fsl_lpuart.c ****     kLPUART_RxIdle, /*!< RX idle. */
  46:../drivers/fsl_lpuart.c ****     kLPUART_RxBusy  /*!< RX busy. */
  47:../drivers/fsl_lpuart.c **** };
  48:../drivers/fsl_lpuart.c **** 
  49:../drivers/fsl_lpuart.c **** /* Typedef for interrupt handler. */
  50:../drivers/fsl_lpuart.c **** typedef void (*lpuart_isr_t)(LPUART_Type *base, lpuart_handle_t *handle);
  51:../drivers/fsl_lpuart.c **** 
  52:../drivers/fsl_lpuart.c **** /*******************************************************************************
  53:../drivers/fsl_lpuart.c ****  * Prototypes
  54:../drivers/fsl_lpuart.c ****  ******************************************************************************/
  55:../drivers/fsl_lpuart.c **** /*!
  56:../drivers/fsl_lpuart.c ****  * @brief Get the LPUART instance from peripheral base address.
  57:../drivers/fsl_lpuart.c ****  *
  58:../drivers/fsl_lpuart.c ****  * @param base LPUART peripheral base address.
  59:../drivers/fsl_lpuart.c ****  * @return LPUART instance.
  60:../drivers/fsl_lpuart.c ****  */
  61:../drivers/fsl_lpuart.c **** uint32_t LPUART_GetInstance(LPUART_Type *base);
  62:../drivers/fsl_lpuart.c **** 
  63:../drivers/fsl_lpuart.c **** /*!
  64:../drivers/fsl_lpuart.c ****  * @brief Check whether the RX ring buffer is full.
  65:../drivers/fsl_lpuart.c ****  *
  66:../drivers/fsl_lpuart.c ****  * @userData handle LPUART handle pointer.
  67:../drivers/fsl_lpuart.c ****  * @retval true  RX ring buffer is full.
  68:../drivers/fsl_lpuart.c ****  * @retval false RX ring buffer is not full.
  69:../drivers/fsl_lpuart.c ****  */
  70:../drivers/fsl_lpuart.c **** static bool LPUART_TransferIsRxRingBufferFull(LPUART_Type *base, lpuart_handle_t *handle);
  71:../drivers/fsl_lpuart.c **** 
  72:../drivers/fsl_lpuart.c **** /*!
  73:../drivers/fsl_lpuart.c ****  * @brief Write to TX register using non-blocking method.
  74:../drivers/fsl_lpuart.c ****  *
  75:../drivers/fsl_lpuart.c ****  * This function writes data to the TX register directly, upper layer must make
  76:../drivers/fsl_lpuart.c ****  * sure the TX register is empty or TX FIFO has empty room before calling this function.
  77:../drivers/fsl_lpuart.c ****  *
  78:../drivers/fsl_lpuart.c ****  * @note This function does not check whether all the data has been sent out to bus,
  79:../drivers/fsl_lpuart.c ****  * so before disable TX, check kLPUART_TransmissionCompleteFlag to ensure the TX is
  80:../drivers/fsl_lpuart.c ****  * finished.
  81:../drivers/fsl_lpuart.c ****  *
  82:../drivers/fsl_lpuart.c ****  * @param base LPUART peripheral base address.
  83:../drivers/fsl_lpuart.c ****  * @param data Start addresss of the data to write.
  84:../drivers/fsl_lpuart.c ****  * @param length Size of the buffer to be sent.
  85:../drivers/fsl_lpuart.c ****  */
  86:../drivers/fsl_lpuart.c **** static void LPUART_WriteNonBlocking(LPUART_Type *base, const uint8_t *data, size_t length);
  87:../drivers/fsl_lpuart.c **** 
  88:../drivers/fsl_lpuart.c **** /*!
  89:../drivers/fsl_lpuart.c ****  * @brief Read RX register using non-blocking method.
  90:../drivers/fsl_lpuart.c ****  *
  91:../drivers/fsl_lpuart.c ****  * This function reads data from the TX register directly, upper layer must make
  92:../drivers/fsl_lpuart.c ****  * sure the RX register is full or TX FIFO has data before calling this function.
  93:../drivers/fsl_lpuart.c ****  *
  94:../drivers/fsl_lpuart.c ****  * @param base LPUART peripheral base address.
  95:../drivers/fsl_lpuart.c ****  * @param data Start addresss of the buffer to store the received data.
  96:../drivers/fsl_lpuart.c ****  * @param length Size of the buffer.
  97:../drivers/fsl_lpuart.c ****  */
  98:../drivers/fsl_lpuart.c **** static void LPUART_ReadNonBlocking(LPUART_Type *base, uint8_t *data, size_t length);
  99:../drivers/fsl_lpuart.c **** 
 100:../drivers/fsl_lpuart.c **** /*******************************************************************************
 101:../drivers/fsl_lpuart.c ****  * Variables
 102:../drivers/fsl_lpuart.c ****  ******************************************************************************/
 103:../drivers/fsl_lpuart.c **** /* Array of LPUART peripheral base address. */
 104:../drivers/fsl_lpuart.c **** static LPUART_Type *const s_lpuartBases[] = LPUART_BASE_PTRS;
 105:../drivers/fsl_lpuart.c **** /* Array of LPUART handle. */
 106:../drivers/fsl_lpuart.c **** static lpuart_handle_t *s_lpuartHandle[ARRAY_SIZE(s_lpuartBases)];
 107:../drivers/fsl_lpuart.c **** /* Array of LPUART IRQ number. */
 108:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
 109:../drivers/fsl_lpuart.c **** static const IRQn_Type s_lpuartRxIRQ[] = LPUART_RX_IRQS;
 110:../drivers/fsl_lpuart.c **** static const IRQn_Type s_lpuartTxIRQ[] = LPUART_TX_IRQS;
 111:../drivers/fsl_lpuart.c **** #else
 112:../drivers/fsl_lpuart.c **** static const IRQn_Type s_lpuartIRQ[] = LPUART_RX_TX_IRQS;
 113:../drivers/fsl_lpuart.c **** #endif
 114:../drivers/fsl_lpuart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 115:../drivers/fsl_lpuart.c **** /* Array of LPUART clock name. */
 116:../drivers/fsl_lpuart.c **** static const clock_ip_name_t s_lpuartClock[] = LPUART_CLOCKS;
 117:../drivers/fsl_lpuart.c **** 
 118:../drivers/fsl_lpuart.c **** #if defined(LPUART_PERIPH_CLOCKS)
 119:../drivers/fsl_lpuart.c **** /* Array of LPUART functional clock name. */
 120:../drivers/fsl_lpuart.c **** static const clock_ip_name_t s_lpuartPeriphClocks[] = LPUART_PERIPH_CLOCKS;
 121:../drivers/fsl_lpuart.c **** #endif
 122:../drivers/fsl_lpuart.c **** 
 123:../drivers/fsl_lpuart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 124:../drivers/fsl_lpuart.c **** 
 125:../drivers/fsl_lpuart.c **** /* LPUART ISR for transactional APIs. */
 126:../drivers/fsl_lpuart.c **** static lpuart_isr_t s_lpuartIsr;
 127:../drivers/fsl_lpuart.c **** 
 128:../drivers/fsl_lpuart.c **** /*******************************************************************************
 129:../drivers/fsl_lpuart.c ****  * Code
 130:../drivers/fsl_lpuart.c ****  ******************************************************************************/
 131:../drivers/fsl_lpuart.c **** uint32_t LPUART_GetInstance(LPUART_Type *base)
 132:../drivers/fsl_lpuart.c **** {
 133:../drivers/fsl_lpuart.c ****     uint32_t instance;
 134:../drivers/fsl_lpuart.c **** 
 135:../drivers/fsl_lpuart.c ****     /* Find the instance index from base address mappings. */
 136:../drivers/fsl_lpuart.c ****     for (instance = 0; instance < ARRAY_SIZE(s_lpuartBases); instance++)
 137:../drivers/fsl_lpuart.c ****     {
 138:../drivers/fsl_lpuart.c ****         if (s_lpuartBases[instance] == base)
 139:../drivers/fsl_lpuart.c ****         {
 140:../drivers/fsl_lpuart.c ****             break;
 141:../drivers/fsl_lpuart.c ****         }
 142:../drivers/fsl_lpuart.c ****     }
 143:../drivers/fsl_lpuart.c **** 
 144:../drivers/fsl_lpuart.c ****     assert(instance < ARRAY_SIZE(s_lpuartBases));
 145:../drivers/fsl_lpuart.c **** 
 146:../drivers/fsl_lpuart.c ****     return instance;
 147:../drivers/fsl_lpuart.c **** }
 148:../drivers/fsl_lpuart.c **** 
 149:../drivers/fsl_lpuart.c **** size_t LPUART_TransferGetRxRingBufferLength(LPUART_Type *base, lpuart_handle_t *handle)
 150:../drivers/fsl_lpuart.c **** {
 151:../drivers/fsl_lpuart.c ****     assert(handle);
 152:../drivers/fsl_lpuart.c **** 
 153:../drivers/fsl_lpuart.c ****     size_t size;
 154:../drivers/fsl_lpuart.c **** 
 155:../drivers/fsl_lpuart.c ****     if (handle->rxRingBufferTail > handle->rxRingBufferHead)
 156:../drivers/fsl_lpuart.c ****     {
 157:../drivers/fsl_lpuart.c ****         size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferT
 158:../drivers/fsl_lpuart.c ****     }
 159:../drivers/fsl_lpuart.c ****     else
 160:../drivers/fsl_lpuart.c ****     {
 161:../drivers/fsl_lpuart.c ****         size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
 162:../drivers/fsl_lpuart.c ****     }
 163:../drivers/fsl_lpuart.c **** 
 164:../drivers/fsl_lpuart.c ****     return size;
 165:../drivers/fsl_lpuart.c **** }
 166:../drivers/fsl_lpuart.c **** 
 167:../drivers/fsl_lpuart.c **** static bool LPUART_TransferIsRxRingBufferFull(LPUART_Type *base, lpuart_handle_t *handle)
 168:../drivers/fsl_lpuart.c **** {
 169:../drivers/fsl_lpuart.c ****     assert(handle);
 170:../drivers/fsl_lpuart.c **** 
 171:../drivers/fsl_lpuart.c ****     bool full;
 172:../drivers/fsl_lpuart.c **** 
 173:../drivers/fsl_lpuart.c ****     if (LPUART_TransferGetRxRingBufferLength(base, handle) == (handle->rxRingBufferSize - 1U))
 174:../drivers/fsl_lpuart.c ****     {
 175:../drivers/fsl_lpuart.c ****         full = true;
 176:../drivers/fsl_lpuart.c ****     }
 177:../drivers/fsl_lpuart.c ****     else
 178:../drivers/fsl_lpuart.c ****     {
 179:../drivers/fsl_lpuart.c ****         full = false;
 180:../drivers/fsl_lpuart.c ****     }
 181:../drivers/fsl_lpuart.c ****     return full;
 182:../drivers/fsl_lpuart.c **** }
 183:../drivers/fsl_lpuart.c **** 
 184:../drivers/fsl_lpuart.c **** static void LPUART_WriteNonBlocking(LPUART_Type *base, const uint8_t *data, size_t length)
 185:../drivers/fsl_lpuart.c **** {
  25              		.loc 1 185 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 10B5     		push	{r4, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
  34              	.LVL1:
 186:../drivers/fsl_lpuart.c ****     assert(data);
 187:../drivers/fsl_lpuart.c **** 
 188:../drivers/fsl_lpuart.c ****     size_t i;
 189:../drivers/fsl_lpuart.c **** 
 190:../drivers/fsl_lpuart.c ****     /* The Non Blocking write data API assume user have ensured there is enough space in
 191:../drivers/fsl_lpuart.c ****     peripheral to write. */
 192:../drivers/fsl_lpuart.c ****     for (i = 0; i < length; i++)
  35              		.loc 1 192 0
  36 0002 0023     		movs	r3, #0
  37 0004 02E0     		b	.L2
  38              	.LVL2:
  39              	.L3:
 193:../drivers/fsl_lpuart.c ****     {
 194:../drivers/fsl_lpuart.c ****         base->DATA = data[i];
  40              		.loc 1 194 0 discriminator 3
  41 0006 CC5C     		ldrb	r4, [r1, r3]
  42 0008 C460     		str	r4, [r0, #12]
 192:../drivers/fsl_lpuart.c ****     {
  43              		.loc 1 192 0 discriminator 3
  44 000a 0133     		adds	r3, r3, #1
  45              	.LVL3:
  46              	.L2:
 192:../drivers/fsl_lpuart.c ****     {
  47              		.loc 1 192 0 is_stmt 0 discriminator 1
  48 000c 9342     		cmp	r3, r2
  49 000e FAD3     		bcc	.L3
 195:../drivers/fsl_lpuart.c ****     }
 196:../drivers/fsl_lpuart.c **** }
  50              		.loc 1 196 0 is_stmt 1
  51              		@ sp needed
  52 0010 10BD     		pop	{r4, pc}
  53              		.cfi_endproc
  54              	.LFE63:
  56              		.section	.text.LPUART_ReadNonBlocking,"ax",%progbits
  57              		.align	1
  58              		.syntax unified
  59              		.code	16
  60              		.thumb_func
  61              		.fpu softvfp
  63              	LPUART_ReadNonBlocking:
  64              	.LFB64:
 197:../drivers/fsl_lpuart.c **** 
 198:../drivers/fsl_lpuart.c **** static void LPUART_ReadNonBlocking(LPUART_Type *base, uint8_t *data, size_t length)
 199:../drivers/fsl_lpuart.c **** {
  65              		.loc 1 199 0
  66              		.cfi_startproc
  67              		@ args = 0, pretend = 0, frame = 0
  68              		@ frame_needed = 0, uses_anonymous_args = 0
  69              	.LVL4:
  70 0000 10B5     		push	{r4, lr}
  71              		.cfi_def_cfa_offset 8
  72              		.cfi_offset 4, -8
  73              		.cfi_offset 14, -4
  74              	.LVL5:
 200:../drivers/fsl_lpuart.c ****     assert(data);
 201:../drivers/fsl_lpuart.c **** 
 202:../drivers/fsl_lpuart.c ****     size_t i;
 203:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 204:../drivers/fsl_lpuart.c ****     uint32_t ctrl = base->CTRL;
 205:../drivers/fsl_lpuart.c ****     bool isSevenDataBits =
 206:../drivers/fsl_lpuart.c ****         ((ctrl & LPUART_CTRL_M7_MASK) ||
 207:../drivers/fsl_lpuart.c ****          ((!(ctrl & LPUART_CTRL_M7_MASK)) && (!(ctrl & LPUART_CTRL_M_MASK)) && (ctrl & LPUART_CTRL_
 208:../drivers/fsl_lpuart.c **** #endif
 209:../drivers/fsl_lpuart.c **** 
 210:../drivers/fsl_lpuart.c ****     /* The Non Blocking read data API assume user have ensured there is enough space in
 211:../drivers/fsl_lpuart.c ****     peripheral to write. */
 212:../drivers/fsl_lpuart.c ****     for (i = 0; i < length; i++)
  75              		.loc 1 212 0
  76 0002 0023     		movs	r3, #0
  77 0004 02E0     		b	.L5
  78              	.LVL6:
  79              	.L6:
 213:../drivers/fsl_lpuart.c ****     {
 214:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 215:../drivers/fsl_lpuart.c ****         if (isSevenDataBits)
 216:../drivers/fsl_lpuart.c ****         {
 217:../drivers/fsl_lpuart.c ****             data[i] = (base->DATA & 0x7F);
 218:../drivers/fsl_lpuart.c ****         }
 219:../drivers/fsl_lpuart.c ****         else
 220:../drivers/fsl_lpuart.c ****         {
 221:../drivers/fsl_lpuart.c ****             data[i] = base->DATA;
 222:../drivers/fsl_lpuart.c ****         }
 223:../drivers/fsl_lpuart.c **** #else
 224:../drivers/fsl_lpuart.c ****         data[i] = base->DATA;
  80              		.loc 1 224 0 discriminator 3
  81 0006 C468     		ldr	r4, [r0, #12]
  82 0008 CC54     		strb	r4, [r1, r3]
 212:../drivers/fsl_lpuart.c ****     {
  83              		.loc 1 212 0 discriminator 3
  84 000a 0133     		adds	r3, r3, #1
  85              	.LVL7:
  86              	.L5:
 212:../drivers/fsl_lpuart.c ****     {
  87              		.loc 1 212 0 is_stmt 0 discriminator 1
  88 000c 9342     		cmp	r3, r2
  89 000e FAD3     		bcc	.L6
 225:../drivers/fsl_lpuart.c **** #endif
 226:../drivers/fsl_lpuart.c ****     }
 227:../drivers/fsl_lpuart.c **** }
  90              		.loc 1 227 0 is_stmt 1
  91              		@ sp needed
  92 0010 10BD     		pop	{r4, pc}
  93              		.cfi_endproc
  94              	.LFE64:
  96              		.section	.text.LPUART_GetInstance,"ax",%progbits
  97              		.align	1
  98              		.global	LPUART_GetInstance
  99              		.syntax unified
 100              		.code	16
 101              		.thumb_func
 102              		.fpu softvfp
 104              	LPUART_GetInstance:
 105              	.LFB60:
 132:../drivers/fsl_lpuart.c ****     uint32_t instance;
 106              		.loc 1 132 0
 107              		.cfi_startproc
 108              		@ args = 0, pretend = 0, frame = 0
 109              		@ frame_needed = 0, uses_anonymous_args = 0
 110              		@ link register save eliminated.
 111              	.LVL8:
 136:../drivers/fsl_lpuart.c ****     {
 112              		.loc 1 136 0
 113 0000 0023     		movs	r3, #0
 114              	.LVL9:
 115              	.L8:
 136:../drivers/fsl_lpuart.c ****     {
 116              		.loc 1 136 0 is_stmt 0 discriminator 1
 117 0002 012B     		cmp	r3, #1
 118 0004 06D8     		bhi	.L7
 138:../drivers/fsl_lpuart.c ****         {
 119              		.loc 1 138 0 is_stmt 1
 120 0006 9A00     		lsls	r2, r3, #2
 121 0008 0349     		ldr	r1, .L11
 122 000a 5258     		ldr	r2, [r2, r1]
 123 000c 8242     		cmp	r2, r0
 124 000e 01D0     		beq	.L7
 136:../drivers/fsl_lpuart.c ****     {
 125              		.loc 1 136 0 discriminator 2
 126 0010 0133     		adds	r3, r3, #1
 127              	.LVL10:
 128 0012 F6E7     		b	.L8
 129              	.L7:
 147:../drivers/fsl_lpuart.c **** 
 130              		.loc 1 147 0
 131 0014 1800     		movs	r0, r3
 132              	.LVL11:
 133              		@ sp needed
 134 0016 7047     		bx	lr
 135              	.L12:
 136              		.align	2
 137              	.L11:
 138 0018 00000000 		.word	.LANCHOR0
 139              		.cfi_endproc
 140              	.LFE60:
 142              		.section	.text.LPUART_TransferGetRxRingBufferLength,"ax",%progbits
 143              		.align	1
 144              		.global	LPUART_TransferGetRxRingBufferLength
 145              		.syntax unified
 146              		.code	16
 147              		.thumb_func
 148              		.fpu softvfp
 150              	LPUART_TransferGetRxRingBufferLength:
 151              	.LFB61:
 150:../drivers/fsl_lpuart.c ****     assert(handle);
 152              		.loc 1 150 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 0
 155              		@ frame_needed = 0, uses_anonymous_args = 0
 156              		@ link register save eliminated.
 157              	.LVL12:
 155:../drivers/fsl_lpuart.c ****     {
 158              		.loc 1 155 0
 159 0000 4A8C     		ldrh	r2, [r1, #34]
 160 0002 92B2     		uxth	r2, r2
 161 0004 0B8C     		ldrh	r3, [r1, #32]
 162 0006 9BB2     		uxth	r3, r3
 163 0008 9A42     		cmp	r2, r3
 164 000a 03D8     		bhi	.L16
 161:../drivers/fsl_lpuart.c ****     }
 165              		.loc 1 161 0
 166 000c 088C     		ldrh	r0, [r1, #32]
 167              	.LVL13:
 168 000e 4B8C     		ldrh	r3, [r1, #34]
 169 0010 C01A     		subs	r0, r0, r3
 170              	.LVL14:
 171              	.L13:
 165:../drivers/fsl_lpuart.c **** 
 172              		.loc 1 165 0
 173              		@ sp needed
 174 0012 7047     		bx	lr
 175              	.LVL15:
 176              	.L16:
 157:../drivers/fsl_lpuart.c ****     }
 177              		.loc 1 157 0
 178 0014 088C     		ldrh	r0, [r1, #32]
 179              	.LVL16:
 180 0016 CB69     		ldr	r3, [r1, #28]
 181 0018 9C46     		mov	ip, r3
 182 001a 6044     		add	r0, r0, ip
 183 001c 4B8C     		ldrh	r3, [r1, #34]
 184 001e C01A     		subs	r0, r0, r3
 185              	.LVL17:
 186 0020 F7E7     		b	.L13
 187              		.cfi_endproc
 188              	.LFE61:
 190              		.section	.text.LPUART_TransferIsRxRingBufferFull,"ax",%progbits
 191              		.align	1
 192              		.syntax unified
 193              		.code	16
 194              		.thumb_func
 195              		.fpu softvfp
 197              	LPUART_TransferIsRxRingBufferFull:
 198              	.LFB62:
 168:../drivers/fsl_lpuart.c ****     assert(handle);
 199              		.loc 1 168 0
 200              		.cfi_startproc
 201              		@ args = 0, pretend = 0, frame = 0
 202              		@ frame_needed = 0, uses_anonymous_args = 0
 203              	.LVL18:
 204 0000 10B5     		push	{r4, lr}
 205              		.cfi_def_cfa_offset 8
 206              		.cfi_offset 4, -8
 207              		.cfi_offset 14, -4
 208 0002 0C00     		movs	r4, r1
 173:../drivers/fsl_lpuart.c ****     {
 209              		.loc 1 173 0
 210 0004 FFF7FEFF 		bl	LPUART_TransferGetRxRingBufferLength
 211              	.LVL19:
 212 0008 E369     		ldr	r3, [r4, #28]
 213 000a 013B     		subs	r3, r3, #1
 214 000c 9842     		cmp	r0, r3
 215 000e 01D0     		beq	.L20
 179:../drivers/fsl_lpuart.c ****     }
 216              		.loc 1 179 0
 217 0010 0020     		movs	r0, #0
 218              	.L18:
 219              	.LVL20:
 182:../drivers/fsl_lpuart.c **** 
 220              		.loc 1 182 0
 221              		@ sp needed
 222              	.LVL21:
 223 0012 10BD     		pop	{r4, pc}
 224              	.LVL22:
 225              	.L20:
 175:../drivers/fsl_lpuart.c ****     }
 226              		.loc 1 175 0
 227 0014 0120     		movs	r0, #1
 228 0016 FCE7     		b	.L18
 229              		.cfi_endproc
 230              	.LFE62:
 232              		.global	__aeabi_uidiv
 233              		.section	.text.LPUART_Init,"ax",%progbits
 234              		.align	1
 235              		.global	LPUART_Init
 236              		.syntax unified
 237              		.code	16
 238              		.thumb_func
 239              		.fpu softvfp
 241              	LPUART_Init:
 242              	.LFB65:
 228:../drivers/fsl_lpuart.c **** 
 229:../drivers/fsl_lpuart.c **** status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz)
 230:../drivers/fsl_lpuart.c **** {
 243              		.loc 1 230 0
 244              		.cfi_startproc
 245              		@ args = 0, pretend = 0, frame = 16
 246              		@ frame_needed = 0, uses_anonymous_args = 0
 247              	.LVL23:
 248 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 249              		.cfi_def_cfa_offset 20
 250              		.cfi_offset 4, -20
 251              		.cfi_offset 5, -16
 252              		.cfi_offset 6, -12
 253              		.cfi_offset 7, -8
 254              		.cfi_offset 14, -4
 255 0002 DE46     		mov	lr, fp
 256 0004 5746     		mov	r7, r10
 257 0006 4646     		mov	r6, r8
 258 0008 C0B5     		push	{r6, r7, lr}
 259              		.cfi_def_cfa_offset 32
 260              		.cfi_offset 8, -32
 261              		.cfi_offset 10, -28
 262              		.cfi_offset 11, -24
 263 000a 84B0     		sub	sp, sp, #16
 264              		.cfi_def_cfa_offset 48
 265 000c 8246     		mov	r10, r0
 266 000e 8B46     		mov	fp, r1
 267 0010 0192     		str	r2, [sp, #4]
 231:../drivers/fsl_lpuart.c ****     assert(config);
 232:../drivers/fsl_lpuart.c ****     assert(config->baudRate_Bps);
 233:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 234:../drivers/fsl_lpuart.c ****     assert(FSL_FEATURE_LPUART_FIFO_SIZEn(base) >= config->txFifoWatermark);
 235:../drivers/fsl_lpuart.c ****     assert(FSL_FEATURE_LPUART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
 236:../drivers/fsl_lpuart.c **** #endif
 237:../drivers/fsl_lpuart.c **** 
 238:../drivers/fsl_lpuart.c ****     uint32_t temp;
 239:../drivers/fsl_lpuart.c ****     uint16_t sbr, sbrTemp;
 240:../drivers/fsl_lpuart.c ****     uint32_t osr, osrTemp, tempDiff, calculatedBaud, baudDiff;
 241:../drivers/fsl_lpuart.c **** 
 242:../drivers/fsl_lpuart.c ****     /* This LPUART instantiation uses a slightly different baud rate calculation
 243:../drivers/fsl_lpuart.c ****      * The idea is to use the best OSR (over-sampling rate) possible
 244:../drivers/fsl_lpuart.c ****      * Note, OSR is typically hard-set to 16 in other LPUART instantiations
 245:../drivers/fsl_lpuart.c ****      * loop to find the best OSR value possible, one that generates minimum baudDiff
 246:../drivers/fsl_lpuart.c ****      * iterate through the rest of the supported values of OSR */
 247:../drivers/fsl_lpuart.c **** 
 248:../drivers/fsl_lpuart.c ****     baudDiff = config->baudRate_Bps;
 268              		.loc 1 248 0
 269 0012 0F68     		ldr	r7, [r1]
 270              	.LVL24:
 271 0014 B846     		mov	r8, r7
 249:../drivers/fsl_lpuart.c ****     osr = 0;
 250:../drivers/fsl_lpuart.c ****     sbr = 0;
 251:../drivers/fsl_lpuart.c ****     for (osrTemp = 4; osrTemp <= 32; osrTemp++)
 272              		.loc 1 251 0
 273 0016 0425     		movs	r5, #4
 249:../drivers/fsl_lpuart.c ****     osr = 0;
 274              		.loc 1 249 0
 275 0018 0023     		movs	r3, #0
 276 001a 0293     		str	r3, [sp, #8]
 250:../drivers/fsl_lpuart.c ****     for (osrTemp = 4; osrTemp <= 32; osrTemp++)
 277              		.loc 1 250 0
 278 001c 0393     		str	r3, [sp, #12]
 279              		.loc 1 251 0
 280 001e 05E0     		b	.L22
 281              	.LVL25:
 282              	.L24:
 252:../drivers/fsl_lpuart.c ****     {
 253:../drivers/fsl_lpuart.c ****         /* calculate the temporary sbr value   */
 254:../drivers/fsl_lpuart.c ****         sbrTemp = (srcClock_Hz / (config->baudRate_Bps * osrTemp));
 255:../drivers/fsl_lpuart.c ****         /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
 256:../drivers/fsl_lpuart.c ****         if (sbrTemp == 0)
 257:../drivers/fsl_lpuart.c ****         {
 258:../drivers/fsl_lpuart.c ****             sbrTemp = 1;
 259:../drivers/fsl_lpuart.c ****         }
 260:../drivers/fsl_lpuart.c ****         /* Calculate the baud rate based on the temporary OSR and SBR values */
 261:../drivers/fsl_lpuart.c ****         calculatedBaud = (srcClock_Hz / (osrTemp * sbrTemp));
 262:../drivers/fsl_lpuart.c **** 
 263:../drivers/fsl_lpuart.c ****         tempDiff = calculatedBaud - config->baudRate_Bps;
 264:../drivers/fsl_lpuart.c **** 
 265:../drivers/fsl_lpuart.c ****         /* Select the better value between srb and (sbr + 1) */
 266:../drivers/fsl_lpuart.c ****         if (tempDiff > (config->baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)))))
 267:../drivers/fsl_lpuart.c ****         {
 268:../drivers/fsl_lpuart.c ****             tempDiff = config->baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)));
 269:../drivers/fsl_lpuart.c ****             sbrTemp++;
 270:../drivers/fsl_lpuart.c ****         }
 271:../drivers/fsl_lpuart.c **** 
 272:../drivers/fsl_lpuart.c ****         if (tempDiff <= baudDiff)
 283              		.loc 1 272 0
 284 0020 4645     		cmp	r6, r8
 285 0022 02D8     		bhi	.L25
 273:../drivers/fsl_lpuart.c ****         {
 274:../drivers/fsl_lpuart.c ****             baudDiff = tempDiff;
 286              		.loc 1 274 0
 287 0024 B046     		mov	r8, r6
 288              	.LVL26:
 275:../drivers/fsl_lpuart.c ****             osr = osrTemp; /* update and store the best OSR value calculated */
 289              		.loc 1 275 0
 290 0026 0295     		str	r5, [sp, #8]
 291              	.LVL27:
 276:../drivers/fsl_lpuart.c ****             sbr = sbrTemp; /* update store the best SBR value calculated */
 292              		.loc 1 276 0
 293 0028 0394     		str	r4, [sp, #12]
 294              	.LVL28:
 295              	.L25:
 251:../drivers/fsl_lpuart.c ****     {
 296              		.loc 1 251 0 discriminator 2
 297 002a 0135     		adds	r5, r5, #1
 298              	.LVL29:
 299              	.L22:
 251:../drivers/fsl_lpuart.c ****     {
 300              		.loc 1 251 0 is_stmt 0 discriminator 1
 301 002c 202D     		cmp	r5, #32
 302 002e 1AD8     		bhi	.L37
 254:../drivers/fsl_lpuart.c ****         /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
 303              		.loc 1 254 0 is_stmt 1
 304 0030 3900     		movs	r1, r7
 305 0032 6943     		muls	r1, r5
 306 0034 0198     		ldr	r0, [sp, #4]
 307 0036 FFF7FEFF 		bl	__aeabi_uidiv
 308              	.LVL30:
 309 003a 84B2     		uxth	r4, r0
 310              	.LVL31:
 256:../drivers/fsl_lpuart.c ****         {
 311              		.loc 1 256 0
 312 003c 002C     		cmp	r4, #0
 313 003e 00D1     		bne	.L23
 258:../drivers/fsl_lpuart.c ****         }
 314              		.loc 1 258 0
 315 0040 0134     		adds	r4, r4, #1
 316              	.LVL32:
 317              	.L23:
 261:../drivers/fsl_lpuart.c **** 
 318              		.loc 1 261 0
 319 0042 2900     		movs	r1, r5
 320 0044 6143     		muls	r1, r4
 321 0046 0198     		ldr	r0, [sp, #4]
 322 0048 FFF7FEFF 		bl	__aeabi_uidiv
 323              	.LVL33:
 263:../drivers/fsl_lpuart.c **** 
 324              		.loc 1 263 0
 325 004c C61B     		subs	r6, r0, r7
 326              	.LVL34:
 266:../drivers/fsl_lpuart.c ****         {
 327              		.loc 1 266 0
 328 004e 611C     		adds	r1, r4, #1
 329 0050 6943     		muls	r1, r5
 330 0052 0198     		ldr	r0, [sp, #4]
 331              	.LVL35:
 332 0054 FFF7FEFF 		bl	__aeabi_uidiv
 333              	.LVL36:
 334 0058 381A     		subs	r0, r7, r0
 335 005a B042     		cmp	r0, r6
 336 005c E0D2     		bcs	.L24
 337              	.LVL37:
 269:../drivers/fsl_lpuart.c ****         }
 338              		.loc 1 269 0
 339 005e 0134     		adds	r4, r4, #1
 340              	.LVL38:
 341 0060 A4B2     		uxth	r4, r4
 342              	.LVL39:
 268:../drivers/fsl_lpuart.c ****             sbrTemp++;
 343              		.loc 1 268 0
 344 0062 0600     		movs	r6, r0
 345 0064 DCE7     		b	.L24
 346              	.LVL40:
 347              	.L37:
 277:../drivers/fsl_lpuart.c ****         }
 278:../drivers/fsl_lpuart.c ****     }
 279:../drivers/fsl_lpuart.c **** 
 280:../drivers/fsl_lpuart.c ****     /* Check to see if actual baud rate is within 3% of desired baud rate
 281:../drivers/fsl_lpuart.c ****      * based on the best calculate OSR value */
 282:../drivers/fsl_lpuart.c ****     if (baudDiff > ((config->baudRate_Bps / 100) * 3))
 348              		.loc 1 282 0
 349 0066 6421     		movs	r1, #100
 350 0068 3800     		movs	r0, r7
 351 006a FFF7FEFF 		bl	__aeabi_uidiv
 352              	.LVL41:
 353 006e 4300     		lsls	r3, r0, #1
 354 0070 1818     		adds	r0, r3, r0
 355 0072 4045     		cmp	r0, r8
 356 0074 00D2     		bcs	.LCB344
 357 0076 7DE0     		b	.L35	@long jump
 358              	.LCB344:
 283:../drivers/fsl_lpuart.c ****     {
 284:../drivers/fsl_lpuart.c ****         /* Unacceptable baud rate difference of more than 3%*/
 285:../drivers/fsl_lpuart.c ****         return kStatus_LPUART_BaudrateNotSupport;
 286:../drivers/fsl_lpuart.c ****     }
 287:../drivers/fsl_lpuart.c **** 
 288:../drivers/fsl_lpuart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 289:../drivers/fsl_lpuart.c **** 
 290:../drivers/fsl_lpuart.c ****     uint32_t instance = LPUART_GetInstance(base);
 359              		.loc 1 290 0
 360 0078 5046     		mov	r0, r10
 361 007a FFF7FEFF 		bl	LPUART_GetInstance
 362              	.LVL42:
 291:../drivers/fsl_lpuart.c **** 
 292:../drivers/fsl_lpuart.c ****     /* Enable lpuart clock */
 293:../drivers/fsl_lpuart.c ****     CLOCK_EnableClock(s_lpuartClock[instance]);
 363              		.loc 1 293 0
 364 007e 8000     		lsls	r0, r0, #2
 365              	.LVL43:
 366 0080 3D4B     		ldr	r3, .L38
 367 0082 C358     		ldr	r3, [r0, r3]
 368              	.LVL44:
 369              	.LBB12:
 370              	.LBB13:
 371              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 372              		.loc 2 449 0
 373 0084 1A0C     		lsrs	r2, r3, #16
 374 0086 3D49     		ldr	r1, .L38+4
 375 0088 8C46     		mov	ip, r1
 376 008a 6244     		add	r2, r2, ip
 377              	.LVL45:
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 378              		.loc 2 450 0
 379 008c 1168     		ldr	r1, [r2]
 380 008e 1B04     		lsls	r3, r3, #16
 381              	.LVL46:
 382 0090 1B0C     		lsrs	r3, r3, #16
 383 0092 0120     		movs	r0, #1
 384              	.LVL47:
 385 0094 9840     		lsls	r0, r0, r3
 386 0096 0300     		movs	r3, r0
 387 0098 0B43     		orrs	r3, r1
 388 009a 1360     		str	r3, [r2]
 389              	.LVL48:
 390              	.LBE13:
 391              	.LBE12:
 294:../drivers/fsl_lpuart.c **** #if defined(LPUART_PERIPH_CLOCKS)
 295:../drivers/fsl_lpuart.c ****     CLOCK_EnableClock(s_lpuartPeriphClocks[instance]);
 296:../drivers/fsl_lpuart.c **** #endif
 297:../drivers/fsl_lpuart.c **** 
 298:../drivers/fsl_lpuart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 299:../drivers/fsl_lpuart.c **** 
 300:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_GLOBAL) && FSL_FEATURE_LPUART_HAS_GLOBAL
 301:../drivers/fsl_lpuart.c ****     /*Reset all internal logic and registers, except the Global Register */
 302:../drivers/fsl_lpuart.c ****     LPUART_SoftwareReset(base);
 303:../drivers/fsl_lpuart.c **** #else
 304:../drivers/fsl_lpuart.c ****     /* Disable LPUART TX RX before setting. */
 305:../drivers/fsl_lpuart.c ****     base->CTRL &= ~(LPUART_CTRL_TE_MASK | LPUART_CTRL_RE_MASK);
 392              		.loc 1 305 0
 393 009c 5346     		mov	r3, r10
 394 009e 9B68     		ldr	r3, [r3, #8]
 395 00a0 374A     		ldr	r2, .L38+8
 396 00a2 1340     		ands	r3, r2
 397 00a4 5246     		mov	r2, r10
 398 00a6 9360     		str	r3, [r2, #8]
 306:../drivers/fsl_lpuart.c **** #endif
 307:../drivers/fsl_lpuart.c **** 
 308:../drivers/fsl_lpuart.c ****     temp = base->BAUD;
 399              		.loc 1 308 0
 400 00a8 1368     		ldr	r3, [r2]
 401              	.LVL49:
 309:../drivers/fsl_lpuart.c **** 
 310:../drivers/fsl_lpuart.c ****     /* Acceptable baud rate, check if OSR is between 4x and 7x oversampling.
 311:../drivers/fsl_lpuart.c ****      * If so, then "BOTHEDGE" sampling must be turned on */
 312:../drivers/fsl_lpuart.c ****     if ((osr > 3) && (osr < 8))
 402              		.loc 1 312 0
 403 00aa 029A     		ldr	r2, [sp, #8]
 404 00ac 043A     		subs	r2, r2, #4
 405 00ae 032A     		cmp	r2, #3
 406 00b0 02D8     		bhi	.L28
 313:../drivers/fsl_lpuart.c ****     {
 314:../drivers/fsl_lpuart.c ****         temp |= LPUART_BAUD_BOTHEDGE_MASK;
 407              		.loc 1 314 0
 408 00b2 8022     		movs	r2, #128
 409 00b4 9202     		lsls	r2, r2, #10
 410 00b6 1343     		orrs	r3, r2
 411              	.LVL50:
 412              	.L28:
 315:../drivers/fsl_lpuart.c ****     }
 316:../drivers/fsl_lpuart.c **** 
 317:../drivers/fsl_lpuart.c ****     /* program the osr value (bit value is one less than actual value) */
 318:../drivers/fsl_lpuart.c ****     temp &= ~LPUART_BAUD_OSR_MASK;
 413              		.loc 1 318 0
 414 00b8 324A     		ldr	r2, .L38+12
 415 00ba 1A40     		ands	r2, r3
 416              	.LVL51:
 319:../drivers/fsl_lpuart.c ****     temp |= LPUART_BAUD_OSR(osr - 1);
 417              		.loc 1 319 0
 418 00bc 029B     		ldr	r3, [sp, #8]
 419 00be 013B     		subs	r3, r3, #1
 420 00c0 1B06     		lsls	r3, r3, #24
 421 00c2 F821     		movs	r1, #248
 422 00c4 4905     		lsls	r1, r1, #21
 423 00c6 0B40     		ands	r3, r1
 424 00c8 1343     		orrs	r3, r2
 425              	.LVL52:
 320:../drivers/fsl_lpuart.c **** 
 321:../drivers/fsl_lpuart.c ****     /* write the sbr value to the BAUD registers */
 322:../drivers/fsl_lpuart.c ****     temp &= ~LPUART_BAUD_SBR_MASK;
 426              		.loc 1 322 0
 427 00ca 5B0B     		lsrs	r3, r3, #13
 428              	.LVL53:
 429 00cc 5B03     		lsls	r3, r3, #13
 430              	.LVL54:
 323:../drivers/fsl_lpuart.c ****     base->BAUD = temp | LPUART_BAUD_SBR(sbr);
 431              		.loc 1 323 0
 432 00ce 039A     		ldr	r2, [sp, #12]
 433 00d0 D204     		lsls	r2, r2, #19
 434 00d2 D20C     		lsrs	r2, r2, #19
 435 00d4 1343     		orrs	r3, r2
 436              	.LVL55:
 437 00d6 5246     		mov	r2, r10
 438 00d8 1360     		str	r3, [r2]
 324:../drivers/fsl_lpuart.c **** 
 325:../drivers/fsl_lpuart.c ****     /* Set bit count and parity mode. */
 326:../drivers/fsl_lpuart.c ****     base->BAUD &= ~LPUART_BAUD_M10_MASK;
 439              		.loc 1 326 0
 440 00da 1368     		ldr	r3, [r2]
 441 00dc 2A4A     		ldr	r2, .L38+16
 442 00de 1340     		ands	r3, r2
 443 00e0 5246     		mov	r2, r10
 444 00e2 1360     		str	r3, [r2]
 327:../drivers/fsl_lpuart.c **** 
 328:../drivers/fsl_lpuart.c ****     temp = base->CTRL &
 445              		.loc 1 328 0
 446 00e4 9268     		ldr	r2, [r2, #8]
 447 00e6 294B     		ldr	r3, .L38+20
 448 00e8 1A40     		ands	r2, r3
 449              	.LVL56:
 329:../drivers/fsl_lpuart.c ****            ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK 
 330:../drivers/fsl_lpuart.c ****              LPUART_CTRL_IDLECFG_MASK);
 331:../drivers/fsl_lpuart.c **** 
 332:../drivers/fsl_lpuart.c ****     temp |=
 333:../drivers/fsl_lpuart.c ****         (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) | LPUART_CTRL_ILT(c
 450              		.loc 1 333 0
 451 00ea 5B46     		mov	r3, fp
 452 00ec 1C79     		ldrb	r4, [r3, #4]
 453 00ee 5B7A     		ldrb	r3, [r3, #9]
 454 00f0 1B02     		lsls	r3, r3, #8
 455 00f2 E021     		movs	r1, #224
 456 00f4 C900     		lsls	r1, r1, #3
 457 00f6 0B40     		ands	r3, r1
 458 00f8 2343     		orrs	r3, r4
 459 00fa 5946     		mov	r1, fp
 460 00fc 087A     		ldrb	r0, [r1, #8]
 461 00fe 8000     		lsls	r0, r0, #2
 462 0100 0421     		movs	r1, #4
 463 0102 0140     		ands	r1, r0
 464 0104 0B43     		orrs	r3, r1
 332:../drivers/fsl_lpuart.c ****         (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) | LPUART_CTRL_ILT(c
 465              		.loc 1 332 0
 466 0106 1343     		orrs	r3, r2
 467              	.LVL57:
 334:../drivers/fsl_lpuart.c **** 
 335:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 336:../drivers/fsl_lpuart.c ****     if (kLPUART_SevenDataBits == config->dataBitsCount)
 337:../drivers/fsl_lpuart.c ****     {
 338:../drivers/fsl_lpuart.c ****         if (kLPUART_ParityDisabled != config->parityMode)
 339:../drivers/fsl_lpuart.c ****         {
 340:../drivers/fsl_lpuart.c ****             temp &= ~LPUART_CTRL_M7_MASK; /* Seven data bits and one parity bit */
 341:../drivers/fsl_lpuart.c ****         }
 342:../drivers/fsl_lpuart.c ****         else
 343:../drivers/fsl_lpuart.c ****         {
 344:../drivers/fsl_lpuart.c ****             temp |= LPUART_CTRL_M7_MASK;
 345:../drivers/fsl_lpuart.c ****         }
 346:../drivers/fsl_lpuart.c ****     }
 347:../drivers/fsl_lpuart.c ****     else
 348:../drivers/fsl_lpuart.c **** #endif
 349:../drivers/fsl_lpuart.c ****     {
 350:../drivers/fsl_lpuart.c ****         if (kLPUART_ParityDisabled != config->parityMode)
 468              		.loc 1 350 0
 469 0108 002C     		cmp	r4, #0
 470 010a 01D0     		beq	.L29
 351:../drivers/fsl_lpuart.c ****         {
 352:../drivers/fsl_lpuart.c ****             temp |= LPUART_CTRL_M_MASK; /* Eight data bits and one parity bit */
 471              		.loc 1 352 0
 472 010c 1022     		movs	r2, #16
 473 010e 1343     		orrs	r3, r2
 474              	.LVL58:
 475              	.L29:
 353:../drivers/fsl_lpuart.c ****         }
 354:../drivers/fsl_lpuart.c ****     }
 355:../drivers/fsl_lpuart.c **** 
 356:../drivers/fsl_lpuart.c ****     base->CTRL = temp;
 476              		.loc 1 356 0
 477 0110 5246     		mov	r2, r10
 478 0112 9360     		str	r3, [r2, #8]
 357:../drivers/fsl_lpuart.c **** 
 358:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONF
 359:../drivers/fsl_lpuart.c ****     /* set stop bit per char */
 360:../drivers/fsl_lpuart.c ****     temp = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
 479              		.loc 1 360 0
 480 0114 1368     		ldr	r3, [r2]
 481              	.LVL59:
 482 0116 1E4A     		ldr	r2, .L38+24
 483              	.LVL60:
 484 0118 1A40     		ands	r2, r3
 485              	.LVL61:
 361:../drivers/fsl_lpuart.c ****     base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
 486              		.loc 1 361 0
 487 011a 5B46     		mov	r3, fp
 488 011c DB79     		ldrb	r3, [r3, #7]
 489 011e 5B03     		lsls	r3, r3, #13
 490 0120 8021     		movs	r1, #128
 491 0122 8901     		lsls	r1, r1, #6
 492 0124 0B40     		ands	r3, r1
 493 0126 1343     		orrs	r3, r2
 494 0128 5246     		mov	r2, r10
 495              	.LVL62:
 496 012a 1360     		str	r3, [r2]
 497              	.LVL63:
 362:../drivers/fsl_lpuart.c **** #endif
 363:../drivers/fsl_lpuart.c **** 
 364:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 365:../drivers/fsl_lpuart.c ****     /* Set tx/rx WATER watermark
 366:../drivers/fsl_lpuart.c ****        Note:
 367:../drivers/fsl_lpuart.c ****        Take care of the RX FIFO, RX interrupt request only assert when received bytes
 368:../drivers/fsl_lpuart.c ****        equal or more than RX water mark, there is potential issue if RX water
 369:../drivers/fsl_lpuart.c ****        mark larger than 1.
 370:../drivers/fsl_lpuart.c ****        For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
 371:../drivers/fsl_lpuart.c ****        5 bytes are received. the last byte will be saved in FIFO but not trigger
 372:../drivers/fsl_lpuart.c ****        RX interrupt because the water mark is 2.
 373:../drivers/fsl_lpuart.c ****      */
 374:../drivers/fsl_lpuart.c ****     base->WATER = (((uint32_t)(config->rxFifoWatermark) << 16) | config->txFifoWatermark);
 375:../drivers/fsl_lpuart.c **** 
 376:../drivers/fsl_lpuart.c ****     /* Enable tx/rx FIFO */
 377:../drivers/fsl_lpuart.c ****     base->FIFO |= (LPUART_FIFO_TXFE_MASK | LPUART_FIFO_RXFE_MASK);
 378:../drivers/fsl_lpuart.c **** 
 379:../drivers/fsl_lpuart.c ****     /* Flush FIFO */
 380:../drivers/fsl_lpuart.c ****     base->FIFO |= (LPUART_FIFO_TXFLUSH_MASK | LPUART_FIFO_RXFLUSH_MASK);
 381:../drivers/fsl_lpuart.c **** #endif
 382:../drivers/fsl_lpuart.c **** 
 383:../drivers/fsl_lpuart.c ****     /* Clear all status flags */
 384:../drivers/fsl_lpuart.c ****     temp = (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF
 385:../drivers/fsl_lpuart.c ****             LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
 386:../drivers/fsl_lpuart.c **** 
 387:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
 388:../drivers/fsl_lpuart.c ****     temp |= LPUART_STAT_LBKDIF_MASK;
 389:../drivers/fsl_lpuart.c **** #endif
 390:../drivers/fsl_lpuart.c **** 
 391:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
 392:../drivers/fsl_lpuart.c ****     temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
 393:../drivers/fsl_lpuart.c **** #endif
 394:../drivers/fsl_lpuart.c **** 
 395:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
 396:../drivers/fsl_lpuart.c ****     /* Set the CTS configuration/TX CTS source. */
 397:../drivers/fsl_lpuart.c ****     base->MODIR |= LPUART_MODIR_TXCTSC(config->txCtsConfig) | LPUART_MODIR_TXCTSSRC(config->txCtsSo
 398:../drivers/fsl_lpuart.c ****     if (config->enableRxRTS)
 399:../drivers/fsl_lpuart.c ****     {
 400:../drivers/fsl_lpuart.c ****         /* Enable the receiver RTS(request-to-send) function. */
 401:../drivers/fsl_lpuart.c ****         base->MODIR |= LPUART_MODIR_RXRTSE_MASK;
 402:../drivers/fsl_lpuart.c ****     }
 403:../drivers/fsl_lpuart.c ****     if (config->enableTxCTS)
 404:../drivers/fsl_lpuart.c ****     {
 405:../drivers/fsl_lpuart.c ****         /* Enable the CTS(clear-to-send) function. */
 406:../drivers/fsl_lpuart.c ****         base->MODIR |= LPUART_MODIR_TXCTSE_MASK;
 407:../drivers/fsl_lpuart.c ****     }
 408:../drivers/fsl_lpuart.c **** #endif
 409:../drivers/fsl_lpuart.c **** 
 410:../drivers/fsl_lpuart.c ****     /* Set data bits order. */
 411:../drivers/fsl_lpuart.c ****     if (config->isMsb)
 498              		.loc 1 411 0
 499 012c 5B46     		mov	r3, fp
 500 012e 9B79     		ldrb	r3, [r3, #6]
 501 0130 002B     		cmp	r3, #0
 502 0132 1DD0     		beq	.L36
 503              	.LVL64:
 412:../drivers/fsl_lpuart.c ****     {
 413:../drivers/fsl_lpuart.c ****         temp |= LPUART_STAT_MSBF_MASK;
 504              		.loc 1 413 0
 505 0134 174A     		ldr	r2, .L38+28
 506              	.LVL65:
 507              	.L30:
 414:../drivers/fsl_lpuart.c ****     }
 415:../drivers/fsl_lpuart.c ****     else
 416:../drivers/fsl_lpuart.c ****     {
 417:../drivers/fsl_lpuart.c ****         temp &= ~LPUART_STAT_MSBF_MASK;
 418:../drivers/fsl_lpuart.c ****     }
 419:../drivers/fsl_lpuart.c **** 
 420:../drivers/fsl_lpuart.c ****     base->STAT |= temp;
 508              		.loc 1 420 0
 509 0136 5346     		mov	r3, r10
 510 0138 5B68     		ldr	r3, [r3, #4]
 511 013a 1343     		orrs	r3, r2
 512 013c 5246     		mov	r2, r10
 513              	.LVL66:
 514 013e 5360     		str	r3, [r2, #4]
 421:../drivers/fsl_lpuart.c **** 
 422:../drivers/fsl_lpuart.c ****     /* Enable TX/RX base on configure structure. */
 423:../drivers/fsl_lpuart.c ****     temp = base->CTRL;
 515              		.loc 1 423 0
 516 0140 9368     		ldr	r3, [r2, #8]
 517              	.LVL67:
 424:../drivers/fsl_lpuart.c ****     if (config->enableTx)
 518              		.loc 1 424 0
 519 0142 5A46     		mov	r2, fp
 520 0144 927A     		ldrb	r2, [r2, #10]
 521 0146 002A     		cmp	r2, #0
 522 0148 02D0     		beq	.L31
 425:../drivers/fsl_lpuart.c ****     {
 426:../drivers/fsl_lpuart.c ****         temp |= LPUART_CTRL_TE_MASK;
 523              		.loc 1 426 0
 524 014a 8022     		movs	r2, #128
 525 014c 1203     		lsls	r2, r2, #12
 526 014e 1343     		orrs	r3, r2
 527              	.LVL68:
 528              	.L31:
 427:../drivers/fsl_lpuart.c ****     }
 428:../drivers/fsl_lpuart.c **** 
 429:../drivers/fsl_lpuart.c ****     if (config->enableRx)
 529              		.loc 1 429 0
 530 0150 5A46     		mov	r2, fp
 531 0152 D27A     		ldrb	r2, [r2, #11]
 532 0154 002A     		cmp	r2, #0
 533 0156 02D0     		beq	.L32
 430:../drivers/fsl_lpuart.c ****     {
 431:../drivers/fsl_lpuart.c ****         temp |= LPUART_CTRL_RE_MASK;
 534              		.loc 1 431 0
 535 0158 8022     		movs	r2, #128
 536 015a D202     		lsls	r2, r2, #11
 537 015c 1343     		orrs	r3, r2
 538              	.LVL69:
 539              	.L32:
 432:../drivers/fsl_lpuart.c ****     }
 433:../drivers/fsl_lpuart.c **** 
 434:../drivers/fsl_lpuart.c ****     base->CTRL = temp;
 540              		.loc 1 434 0
 541 015e 5246     		mov	r2, r10
 542 0160 9360     		str	r3, [r2, #8]
 435:../drivers/fsl_lpuart.c **** 
 436:../drivers/fsl_lpuart.c ****     return kStatus_Success;
 543              		.loc 1 436 0
 544 0162 0020     		movs	r0, #0
 545              	.LVL70:
 546              	.L21:
 437:../drivers/fsl_lpuart.c **** }
 547              		.loc 1 437 0
 548 0164 04B0     		add	sp, sp, #16
 549              		@ sp needed
 550              	.LVL71:
 551              	.LVL72:
 552              	.LVL73:
 553              	.LVL74:
 554 0166 1CBC     		pop	{r2, r3, r4}
 555 0168 9046     		mov	r8, r2
 556 016a 9A46     		mov	r10, r3
 557 016c A346     		mov	fp, r4
 558 016e F0BD     		pop	{r4, r5, r6, r7, pc}
 559              	.LVL75:
 560              	.L36:
 417:../drivers/fsl_lpuart.c ****     }
 561              		.loc 1 417 0
 562 0170 094A     		ldr	r2, .L38+32
 563              	.LVL76:
 564 0172 E0E7     		b	.L30
 565              	.LVL77:
 566              	.L35:
 285:../drivers/fsl_lpuart.c ****     }
 567              		.loc 1 285 0
 568 0174 0948     		ldr	r0, .L38+36
 569 0176 F5E7     		b	.L21
 570              	.L39:
 571              		.align	2
 572              	.L38:
 573 0178 00000000 		.word	.LANCHOR1
 574 017c 00700440 		.word	1074032640
 575 0180 FFFFF3FF 		.word	-786433
 576 0184 FFFFFFE0 		.word	-520093697
 577 0188 FFFFFFDF 		.word	-536870913
 578 018c E8F8FFFF 		.word	-1816
 579 0190 FFDFFFFF 		.word	-8193
 580 0194 00C01FE0 		.word	-534790144
 581 0198 00C01FC0 		.word	-1071661056
 582 019c 21050000 		.word	1313
 583              		.cfi_endproc
 584              	.LFE65:
 586              		.section	.text.LPUART_Deinit,"ax",%progbits
 587              		.align	1
 588              		.global	LPUART_Deinit
 589              		.syntax unified
 590              		.code	16
 591              		.thumb_func
 592              		.fpu softvfp
 594              	LPUART_Deinit:
 595              	.LFB66:
 438:../drivers/fsl_lpuart.c **** void LPUART_Deinit(LPUART_Type *base)
 439:../drivers/fsl_lpuart.c **** {
 596              		.loc 1 439 0
 597              		.cfi_startproc
 598              		@ args = 0, pretend = 0, frame = 0
 599              		@ frame_needed = 0, uses_anonymous_args = 0
 600              	.LVL78:
 601 0000 10B5     		push	{r4, lr}
 602              		.cfi_def_cfa_offset 8
 603              		.cfi_offset 4, -8
 604              		.cfi_offset 14, -4
 605              	.L41:
 440:../drivers/fsl_lpuart.c ****     uint32_t temp;
 441:../drivers/fsl_lpuart.c **** 
 442:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 443:../drivers/fsl_lpuart.c ****     /* Wait tx FIFO send out*/
 444:../drivers/fsl_lpuart.c ****     while (0 != ((base->WATER & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXWATER_SHIFT))
 445:../drivers/fsl_lpuart.c ****     {
 446:../drivers/fsl_lpuart.c ****     }
 447:../drivers/fsl_lpuart.c **** #endif
 448:../drivers/fsl_lpuart.c ****     /* Wait last char shoft out */
 449:../drivers/fsl_lpuart.c ****     while (0 == (base->STAT & LPUART_STAT_TC_MASK))
 606              		.loc 1 449 0 discriminator 1
 607 0002 4368     		ldr	r3, [r0, #4]
 608 0004 5B02     		lsls	r3, r3, #9
 609 0006 FCD5     		bpl	.L41
 610              	.LVL79:
 450:../drivers/fsl_lpuart.c ****     {
 451:../drivers/fsl_lpuart.c ****     }
 452:../drivers/fsl_lpuart.c **** 
 453:../drivers/fsl_lpuart.c ****     /* Clear all status flags */
 454:../drivers/fsl_lpuart.c ****     temp = (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF
 455:../drivers/fsl_lpuart.c ****             LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
 456:../drivers/fsl_lpuart.c **** 
 457:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
 458:../drivers/fsl_lpuart.c ****     temp |= LPUART_STAT_LBKDIF_MASK;
 459:../drivers/fsl_lpuart.c **** #endif
 460:../drivers/fsl_lpuart.c **** 
 461:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
 462:../drivers/fsl_lpuart.c ****     temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
 463:../drivers/fsl_lpuart.c **** #endif
 464:../drivers/fsl_lpuart.c **** 
 465:../drivers/fsl_lpuart.c ****     base->STAT |= temp;
 611              		.loc 1 465 0
 612 0008 4268     		ldr	r2, [r0, #4]
 613 000a 0B4B     		ldr	r3, .L42
 614 000c 1343     		orrs	r3, r2
 615 000e 4360     		str	r3, [r0, #4]
 466:../drivers/fsl_lpuart.c **** 
 467:../drivers/fsl_lpuart.c ****     /* Disable the module. */
 468:../drivers/fsl_lpuart.c ****     base->CTRL = 0;
 616              		.loc 1 468 0
 617 0010 0023     		movs	r3, #0
 618 0012 8360     		str	r3, [r0, #8]
 469:../drivers/fsl_lpuart.c **** 
 470:../drivers/fsl_lpuart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 471:../drivers/fsl_lpuart.c ****     uint32_t instance = LPUART_GetInstance(base);
 619              		.loc 1 471 0
 620 0014 FFF7FEFF 		bl	LPUART_GetInstance
 621              	.LVL80:
 472:../drivers/fsl_lpuart.c **** 
 473:../drivers/fsl_lpuart.c ****     /* Disable lpuart clock */
 474:../drivers/fsl_lpuart.c ****     CLOCK_DisableClock(s_lpuartClock[instance]);
 622              		.loc 1 474 0
 623 0018 8000     		lsls	r0, r0, #2
 624              	.LVL81:
 625 001a 084B     		ldr	r3, .L42+4
 626 001c C358     		ldr	r3, [r0, r3]
 627              	.LVL82:
 628              	.LBB14:
 629              	.LBB15:
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 630              		.loc 2 460 0
 631 001e 1A0C     		lsrs	r2, r3, #16
 632 0020 0749     		ldr	r1, .L42+8
 633 0022 8C46     		mov	ip, r1
 634 0024 6244     		add	r2, r2, ip
 635              	.LVL83:
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 636              		.loc 2 461 0
 637 0026 1168     		ldr	r1, [r2]
 638 0028 1B04     		lsls	r3, r3, #16
 639              	.LVL84:
 640 002a 1B0C     		lsrs	r3, r3, #16
 641 002c 0120     		movs	r0, #1
 642              	.LVL85:
 643 002e 9840     		lsls	r0, r0, r3
 644 0030 8143     		bics	r1, r0
 645 0032 1160     		str	r1, [r2]
 646              	.LVL86:
 647              	.LBE15:
 648              	.LBE14:
 475:../drivers/fsl_lpuart.c **** 
 476:../drivers/fsl_lpuart.c **** #if defined(LPUART_PERIPH_CLOCKS)
 477:../drivers/fsl_lpuart.c ****     CLOCK_DisableClock(s_lpuartPeriphClocks[instance]);
 478:../drivers/fsl_lpuart.c **** #endif
 479:../drivers/fsl_lpuart.c **** 
 480:../drivers/fsl_lpuart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 481:../drivers/fsl_lpuart.c **** }
 649              		.loc 1 481 0
 650              		@ sp needed
 651 0034 10BD     		pop	{r4, pc}
 652              	.L43:
 653 0036 C046     		.align	2
 654              	.L42:
 655 0038 00C01FC0 		.word	-1071661056
 656 003c 00000000 		.word	.LANCHOR1
 657 0040 00700440 		.word	1074032640
 658              		.cfi_endproc
 659              	.LFE66:
 661              		.section	.text.LPUART_GetDefaultConfig,"ax",%progbits
 662              		.align	1
 663              		.global	LPUART_GetDefaultConfig
 664              		.syntax unified
 665              		.code	16
 666              		.thumb_func
 667              		.fpu softvfp
 669              	LPUART_GetDefaultConfig:
 670              	.LFB67:
 482:../drivers/fsl_lpuart.c **** 
 483:../drivers/fsl_lpuart.c **** void LPUART_GetDefaultConfig(lpuart_config_t *config)
 484:../drivers/fsl_lpuart.c **** {
 671              		.loc 1 484 0
 672              		.cfi_startproc
 673              		@ args = 0, pretend = 0, frame = 0
 674              		@ frame_needed = 0, uses_anonymous_args = 0
 675              		@ link register save eliminated.
 676              	.LVL87:
 485:../drivers/fsl_lpuart.c ****     assert(config);
 486:../drivers/fsl_lpuart.c **** 
 487:../drivers/fsl_lpuart.c ****     config->baudRate_Bps = 115200U;
 677              		.loc 1 487 0
 678 0000 E123     		movs	r3, #225
 679 0002 5B02     		lsls	r3, r3, #9
 680 0004 0360     		str	r3, [r0]
 488:../drivers/fsl_lpuart.c ****     config->parityMode = kLPUART_ParityDisabled;
 681              		.loc 1 488 0
 682 0006 0023     		movs	r3, #0
 683 0008 0371     		strb	r3, [r0, #4]
 489:../drivers/fsl_lpuart.c ****     config->dataBitsCount = kLPUART_EightDataBits;
 684              		.loc 1 489 0
 685 000a 4371     		strb	r3, [r0, #5]
 490:../drivers/fsl_lpuart.c ****     config->isMsb = false;
 686              		.loc 1 490 0
 687 000c 8371     		strb	r3, [r0, #6]
 491:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONF
 492:../drivers/fsl_lpuart.c ****     config->stopBitCount = kLPUART_OneStopBit;
 688              		.loc 1 492 0
 689 000e C371     		strb	r3, [r0, #7]
 493:../drivers/fsl_lpuart.c **** #endif
 494:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 495:../drivers/fsl_lpuart.c ****     config->txFifoWatermark = 0;
 496:../drivers/fsl_lpuart.c ****     config->rxFifoWatermark = 0;
 497:../drivers/fsl_lpuart.c **** #endif
 498:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
 499:../drivers/fsl_lpuart.c ****     config->enableRxRTS = false;
 500:../drivers/fsl_lpuart.c ****     config->enableTxCTS = false;
 501:../drivers/fsl_lpuart.c ****     config->txCtsConfig = kLPUART_CtsSampleAtStart;
 502:../drivers/fsl_lpuart.c ****     config->txCtsSource = kLPUART_CtsSourcePin;
 503:../drivers/fsl_lpuart.c **** #endif
 504:../drivers/fsl_lpuart.c ****     config->rxIdleType = kLPUART_IdleTypeStartBit;
 690              		.loc 1 504 0
 691 0010 0372     		strb	r3, [r0, #8]
 505:../drivers/fsl_lpuart.c ****     config->rxIdleConfig = kLPUART_IdleCharacter1;
 692              		.loc 1 505 0
 693 0012 4372     		strb	r3, [r0, #9]
 506:../drivers/fsl_lpuart.c ****     config->enableTx = false;
 694              		.loc 1 506 0
 695 0014 8372     		strb	r3, [r0, #10]
 507:../drivers/fsl_lpuart.c ****     config->enableRx = false;
 696              		.loc 1 507 0
 697 0016 C372     		strb	r3, [r0, #11]
 508:../drivers/fsl_lpuart.c **** }
 698              		.loc 1 508 0
 699              		@ sp needed
 700 0018 7047     		bx	lr
 701              		.cfi_endproc
 702              	.LFE67:
 704              		.section	.text.LPUART_SetBaudRate,"ax",%progbits
 705              		.align	1
 706              		.global	LPUART_SetBaudRate
 707              		.syntax unified
 708              		.code	16
 709              		.thumb_func
 710              		.fpu softvfp
 712              	LPUART_SetBaudRate:
 713              	.LFB68:
 509:../drivers/fsl_lpuart.c **** 
 510:../drivers/fsl_lpuart.c **** status_t LPUART_SetBaudRate(LPUART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
 511:../drivers/fsl_lpuart.c **** {
 714              		.loc 1 511 0
 715              		.cfi_startproc
 716              		@ args = 0, pretend = 0, frame = 16
 717              		@ frame_needed = 0, uses_anonymous_args = 0
 718              	.LVL88:
 719 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 720              		.cfi_def_cfa_offset 20
 721              		.cfi_offset 4, -20
 722              		.cfi_offset 5, -16
 723              		.cfi_offset 6, -12
 724              		.cfi_offset 7, -8
 725              		.cfi_offset 14, -4
 726 0002 DE46     		mov	lr, fp
 727 0004 4746     		mov	r7, r8
 728 0006 80B5     		push	{r7, lr}
 729              		.cfi_def_cfa_offset 28
 730              		.cfi_offset 8, -28
 731              		.cfi_offset 11, -24
 732 0008 85B0     		sub	sp, sp, #20
 733              		.cfi_def_cfa_offset 48
 734 000a 8346     		mov	fp, r0
 735 000c 0E00     		movs	r6, r1
 736 000e 0192     		str	r2, [sp, #4]
 737              	.LVL89:
 512:../drivers/fsl_lpuart.c ****     assert(baudRate_Bps);
 513:../drivers/fsl_lpuart.c **** 
 514:../drivers/fsl_lpuart.c ****     uint32_t temp, oldCtrl;
 515:../drivers/fsl_lpuart.c ****     uint16_t sbr, sbrTemp;
 516:../drivers/fsl_lpuart.c ****     uint32_t osr, osrTemp, tempDiff, calculatedBaud, baudDiff;
 517:../drivers/fsl_lpuart.c **** 
 518:../drivers/fsl_lpuart.c ****     /* This LPUART instantiation uses a slightly different baud rate calculation
 519:../drivers/fsl_lpuart.c ****      * The idea is to use the best OSR (over-sampling rate) possible
 520:../drivers/fsl_lpuart.c ****      * Note, OSR is typically hard-set to 16 in other LPUART instantiations
 521:../drivers/fsl_lpuart.c ****      * loop to find the best OSR value possible, one that generates minimum baudDiff
 522:../drivers/fsl_lpuart.c ****      * iterate through the rest of the supported values of OSR */
 523:../drivers/fsl_lpuart.c **** 
 524:../drivers/fsl_lpuart.c ****     baudDiff = baudRate_Bps;
 738              		.loc 1 524 0
 739 0010 8846     		mov	r8, r1
 525:../drivers/fsl_lpuart.c ****     osr = 0;
 526:../drivers/fsl_lpuart.c ****     sbr = 0;
 527:../drivers/fsl_lpuart.c ****     for (osrTemp = 4; osrTemp <= 32; osrTemp++)
 740              		.loc 1 527 0
 741 0012 0425     		movs	r5, #4
 525:../drivers/fsl_lpuart.c ****     osr = 0;
 742              		.loc 1 525 0
 743 0014 0023     		movs	r3, #0
 744 0016 0293     		str	r3, [sp, #8]
 526:../drivers/fsl_lpuart.c ****     for (osrTemp = 4; osrTemp <= 32; osrTemp++)
 745              		.loc 1 526 0
 746 0018 0393     		str	r3, [sp, #12]
 747              		.loc 1 527 0
 748 001a 05E0     		b	.L46
 749              	.LVL90:
 750              	.L48:
 528:../drivers/fsl_lpuart.c ****     {
 529:../drivers/fsl_lpuart.c ****         /* calculate the temporary sbr value   */
 530:../drivers/fsl_lpuart.c ****         sbrTemp = (srcClock_Hz / (baudRate_Bps * osrTemp));
 531:../drivers/fsl_lpuart.c ****         /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
 532:../drivers/fsl_lpuart.c ****         if (sbrTemp == 0)
 533:../drivers/fsl_lpuart.c ****         {
 534:../drivers/fsl_lpuart.c ****             sbrTemp = 1;
 535:../drivers/fsl_lpuart.c ****         }
 536:../drivers/fsl_lpuart.c ****         /* Calculate the baud rate based on the temporary OSR and SBR values */
 537:../drivers/fsl_lpuart.c ****         calculatedBaud = (srcClock_Hz / (osrTemp * sbrTemp));
 538:../drivers/fsl_lpuart.c **** 
 539:../drivers/fsl_lpuart.c ****         tempDiff = calculatedBaud - baudRate_Bps;
 540:../drivers/fsl_lpuart.c **** 
 541:../drivers/fsl_lpuart.c ****         /* Select the better value between srb and (sbr + 1) */
 542:../drivers/fsl_lpuart.c ****         if (tempDiff > (baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)))))
 543:../drivers/fsl_lpuart.c ****         {
 544:../drivers/fsl_lpuart.c ****             tempDiff = baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)));
 545:../drivers/fsl_lpuart.c ****             sbrTemp++;
 546:../drivers/fsl_lpuart.c ****         }
 547:../drivers/fsl_lpuart.c **** 
 548:../drivers/fsl_lpuart.c ****         if (tempDiff <= baudDiff)
 751              		.loc 1 548 0
 752 001c 4745     		cmp	r7, r8
 753 001e 02D8     		bhi	.L49
 549:../drivers/fsl_lpuart.c ****         {
 550:../drivers/fsl_lpuart.c ****             baudDiff = tempDiff;
 754              		.loc 1 550 0
 755 0020 B846     		mov	r8, r7
 756              	.LVL91:
 551:../drivers/fsl_lpuart.c ****             osr = osrTemp; /* update and store the best OSR value calculated */
 757              		.loc 1 551 0
 758 0022 0295     		str	r5, [sp, #8]
 759              	.LVL92:
 552:../drivers/fsl_lpuart.c ****             sbr = sbrTemp; /* update store the best SBR value calculated */
 760              		.loc 1 552 0
 761 0024 0394     		str	r4, [sp, #12]
 762              	.LVL93:
 763              	.L49:
 527:../drivers/fsl_lpuart.c ****     {
 764              		.loc 1 527 0 discriminator 2
 765 0026 0135     		adds	r5, r5, #1
 766              	.LVL94:
 767              	.L46:
 527:../drivers/fsl_lpuart.c ****     {
 768              		.loc 1 527 0 is_stmt 0 discriminator 1
 769 0028 202D     		cmp	r5, #32
 770 002a 1AD8     		bhi	.L56
 530:../drivers/fsl_lpuart.c ****         /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
 771              		.loc 1 530 0 is_stmt 1
 772 002c 3100     		movs	r1, r6
 773 002e 6943     		muls	r1, r5
 774 0030 0198     		ldr	r0, [sp, #4]
 775 0032 FFF7FEFF 		bl	__aeabi_uidiv
 776              	.LVL95:
 777 0036 84B2     		uxth	r4, r0
 778              	.LVL96:
 532:../drivers/fsl_lpuart.c ****         {
 779              		.loc 1 532 0
 780 0038 002C     		cmp	r4, #0
 781 003a 00D1     		bne	.L47
 534:../drivers/fsl_lpuart.c ****         }
 782              		.loc 1 534 0
 783 003c 0134     		adds	r4, r4, #1
 784              	.LVL97:
 785              	.L47:
 537:../drivers/fsl_lpuart.c **** 
 786              		.loc 1 537 0
 787 003e 2900     		movs	r1, r5
 788 0040 6143     		muls	r1, r4
 789 0042 0198     		ldr	r0, [sp, #4]
 790 0044 FFF7FEFF 		bl	__aeabi_uidiv
 791              	.LVL98:
 539:../drivers/fsl_lpuart.c **** 
 792              		.loc 1 539 0
 793 0048 871B     		subs	r7, r0, r6
 794              	.LVL99:
 542:../drivers/fsl_lpuart.c ****         {
 795              		.loc 1 542 0
 796 004a 611C     		adds	r1, r4, #1
 797 004c 6943     		muls	r1, r5
 798 004e 0198     		ldr	r0, [sp, #4]
 799              	.LVL100:
 800 0050 FFF7FEFF 		bl	__aeabi_uidiv
 801              	.LVL101:
 802 0054 301A     		subs	r0, r6, r0
 803 0056 B842     		cmp	r0, r7
 804 0058 E0D2     		bcs	.L48
 805              	.LVL102:
 545:../drivers/fsl_lpuart.c ****         }
 806              		.loc 1 545 0
 807 005a 0134     		adds	r4, r4, #1
 808              	.LVL103:
 809 005c A4B2     		uxth	r4, r4
 810              	.LVL104:
 544:../drivers/fsl_lpuart.c ****             sbrTemp++;
 811              		.loc 1 544 0
 812 005e 0700     		movs	r7, r0
 813 0060 DCE7     		b	.L48
 814              	.LVL105:
 815              	.L56:
 553:../drivers/fsl_lpuart.c ****         }
 554:../drivers/fsl_lpuart.c ****     }
 555:../drivers/fsl_lpuart.c **** 
 556:../drivers/fsl_lpuart.c ****     /* Check to see if actual baud rate is within 3% of desired baud rate
 557:../drivers/fsl_lpuart.c ****      * based on the best calculate OSR value */
 558:../drivers/fsl_lpuart.c ****     if (baudDiff < ((baudRate_Bps / 100) * 3))
 816              		.loc 1 558 0
 817 0062 6421     		movs	r1, #100
 818 0064 3000     		movs	r0, r6
 819 0066 FFF7FEFF 		bl	__aeabi_uidiv
 820              	.LVL106:
 821 006a 4300     		lsls	r3, r0, #1
 822 006c 1818     		adds	r0, r3, r0
 823 006e 4045     		cmp	r0, r8
 824 0070 26D9     		bls	.L55
 559:../drivers/fsl_lpuart.c ****     {
 560:../drivers/fsl_lpuart.c ****         /* Store CTRL before disable Tx and Rx */
 561:../drivers/fsl_lpuart.c ****         oldCtrl = base->CTRL;
 825              		.loc 1 561 0
 826 0072 5B46     		mov	r3, fp
 827 0074 9968     		ldr	r1, [r3, #8]
 828              	.LVL107:
 562:../drivers/fsl_lpuart.c **** 
 563:../drivers/fsl_lpuart.c ****         /* Disable LPUART TX RX before setting. */
 564:../drivers/fsl_lpuart.c ****         base->CTRL &= ~(LPUART_CTRL_TE_MASK | LPUART_CTRL_RE_MASK);
 829              		.loc 1 564 0
 830 0076 9B68     		ldr	r3, [r3, #8]
 831 0078 124A     		ldr	r2, .L57
 832 007a 1340     		ands	r3, r2
 833 007c 5A46     		mov	r2, fp
 834 007e 9360     		str	r3, [r2, #8]
 565:../drivers/fsl_lpuart.c **** 
 566:../drivers/fsl_lpuart.c ****         temp = base->BAUD;
 835              		.loc 1 566 0
 836 0080 1368     		ldr	r3, [r2]
 837              	.LVL108:
 567:../drivers/fsl_lpuart.c **** 
 568:../drivers/fsl_lpuart.c ****         /* Acceptable baud rate, check if OSR is between 4x and 7x oversampling.
 569:../drivers/fsl_lpuart.c ****          * If so, then "BOTHEDGE" sampling must be turned on */
 570:../drivers/fsl_lpuart.c ****         if ((osr > 3) && (osr < 8))
 838              		.loc 1 570 0
 839 0082 029A     		ldr	r2, [sp, #8]
 840 0084 043A     		subs	r2, r2, #4
 841 0086 032A     		cmp	r2, #3
 842 0088 02D8     		bhi	.L52
 571:../drivers/fsl_lpuart.c ****         {
 572:../drivers/fsl_lpuart.c ****             temp |= LPUART_BAUD_BOTHEDGE_MASK;
 843              		.loc 1 572 0
 844 008a 8022     		movs	r2, #128
 845 008c 9202     		lsls	r2, r2, #10
 846 008e 1343     		orrs	r3, r2
 847              	.LVL109:
 848              	.L52:
 573:../drivers/fsl_lpuart.c ****         }
 574:../drivers/fsl_lpuart.c **** 
 575:../drivers/fsl_lpuart.c ****         /* program the osr value (bit value is one less than actual value) */
 576:../drivers/fsl_lpuart.c ****         temp &= ~LPUART_BAUD_OSR_MASK;
 849              		.loc 1 576 0
 850 0090 0D4A     		ldr	r2, .L57+4
 851 0092 1A40     		ands	r2, r3
 852              	.LVL110:
 577:../drivers/fsl_lpuart.c ****         temp |= LPUART_BAUD_OSR(osr - 1);
 853              		.loc 1 577 0
 854 0094 029B     		ldr	r3, [sp, #8]
 855 0096 013B     		subs	r3, r3, #1
 856 0098 1B06     		lsls	r3, r3, #24
 857 009a F827     		movs	r7, #248
 858 009c 7F05     		lsls	r7, r7, #21
 859 009e 3B40     		ands	r3, r7
 860 00a0 1343     		orrs	r3, r2
 861              	.LVL111:
 578:../drivers/fsl_lpuart.c **** 
 579:../drivers/fsl_lpuart.c ****         /* write the sbr value to the BAUD registers */
 580:../drivers/fsl_lpuart.c ****         temp &= ~LPUART_BAUD_SBR_MASK;
 862              		.loc 1 580 0
 863 00a2 5B0B     		lsrs	r3, r3, #13
 864              	.LVL112:
 865 00a4 5B03     		lsls	r3, r3, #13
 866              	.LVL113:
 581:../drivers/fsl_lpuart.c ****         base->BAUD = temp | LPUART_BAUD_SBR(sbr);
 867              		.loc 1 581 0
 868 00a6 039A     		ldr	r2, [sp, #12]
 869 00a8 D204     		lsls	r2, r2, #19
 870 00aa D20C     		lsrs	r2, r2, #19
 871 00ac 1343     		orrs	r3, r2
 872              	.LVL114:
 873 00ae 5A46     		mov	r2, fp
 874 00b0 1360     		str	r3, [r2]
 582:../drivers/fsl_lpuart.c **** 
 583:../drivers/fsl_lpuart.c ****         /* Restore CTRL. */
 584:../drivers/fsl_lpuart.c ****         base->CTRL = oldCtrl;
 875              		.loc 1 584 0
 876 00b2 9160     		str	r1, [r2, #8]
 585:../drivers/fsl_lpuart.c **** 
 586:../drivers/fsl_lpuart.c ****         return kStatus_Success;
 877              		.loc 1 586 0
 878 00b4 0020     		movs	r0, #0
 879              	.LVL115:
 880              	.L45:
 587:../drivers/fsl_lpuart.c ****     }
 588:../drivers/fsl_lpuart.c ****     else
 589:../drivers/fsl_lpuart.c ****     {
 590:../drivers/fsl_lpuart.c ****         /* Unacceptable baud rate difference of more than 3%*/
 591:../drivers/fsl_lpuart.c ****         return kStatus_LPUART_BaudrateNotSupport;
 592:../drivers/fsl_lpuart.c ****     }
 593:../drivers/fsl_lpuart.c **** }
 881              		.loc 1 593 0
 882 00b6 05B0     		add	sp, sp, #20
 883              		@ sp needed
 884              	.LVL116:
 885              	.LVL117:
 886              	.LVL118:
 887              	.LVL119:
 888 00b8 0CBC     		pop	{r2, r3}
 889 00ba 9046     		mov	r8, r2
 890 00bc 9B46     		mov	fp, r3
 891 00be F0BD     		pop	{r4, r5, r6, r7, pc}
 892              	.LVL120:
 893              	.L55:
 591:../drivers/fsl_lpuart.c ****     }
 894              		.loc 1 591 0
 895 00c0 0248     		ldr	r0, .L57+8
 896 00c2 F8E7     		b	.L45
 897              	.L58:
 898              		.align	2
 899              	.L57:
 900 00c4 FFFFF3FF 		.word	-786433
 901 00c8 FFFFFFE0 		.word	-520093697
 902 00cc 21050000 		.word	1313
 903              		.cfi_endproc
 904              	.LFE68:
 906              		.section	.text.LPUART_EnableInterrupts,"ax",%progbits
 907              		.align	1
 908              		.global	LPUART_EnableInterrupts
 909              		.syntax unified
 910              		.code	16
 911              		.thumb_func
 912              		.fpu softvfp
 914              	LPUART_EnableInterrupts:
 915              	.LFB69:
 594:../drivers/fsl_lpuart.c **** 
 595:../drivers/fsl_lpuart.c **** void LPUART_EnableInterrupts(LPUART_Type *base, uint32_t mask)
 596:../drivers/fsl_lpuart.c **** {
 916              		.loc 1 596 0
 917              		.cfi_startproc
 918              		@ args = 0, pretend = 0, frame = 0
 919              		@ frame_needed = 0, uses_anonymous_args = 0
 920              	.LVL121:
 921 0000 10B5     		push	{r4, lr}
 922              		.cfi_def_cfa_offset 8
 923              		.cfi_offset 4, -8
 924              		.cfi_offset 14, -4
 597:../drivers/fsl_lpuart.c ****     base->BAUD |= ((mask << 8) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
 925              		.loc 1 597 0
 926 0002 0368     		ldr	r3, [r0]
 927 0004 0A02     		lsls	r2, r1, #8
 928 0006 C024     		movs	r4, #192
 929 0008 2402     		lsls	r4, r4, #8
 930 000a 2240     		ands	r2, r4
 931 000c 1343     		orrs	r3, r2
 932 000e 0360     		str	r3, [r0]
 598:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 599:../drivers/fsl_lpuart.c ****     base->FIFO = (base->FIFO & ~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) |
 600:../drivers/fsl_lpuart.c ****                  ((mask << 8) & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK));
 601:../drivers/fsl_lpuart.c **** #endif
 602:../drivers/fsl_lpuart.c ****     mask &= 0xFFFFFF00U;
 933              		.loc 1 602 0
 934 0010 FF23     		movs	r3, #255
 935 0012 9943     		bics	r1, r3
 936              	.LVL122:
 603:../drivers/fsl_lpuart.c ****     base->CTRL |= mask;
 937              		.loc 1 603 0
 938 0014 8368     		ldr	r3, [r0, #8]
 939 0016 1943     		orrs	r1, r3
 940              	.LVL123:
 941 0018 8160     		str	r1, [r0, #8]
 604:../drivers/fsl_lpuart.c **** }
 942              		.loc 1 604 0
 943              		@ sp needed
 944 001a 10BD     		pop	{r4, pc}
 945              		.cfi_endproc
 946              	.LFE69:
 948              		.section	.text.LPUART_DisableInterrupts,"ax",%progbits
 949              		.align	1
 950              		.global	LPUART_DisableInterrupts
 951              		.syntax unified
 952              		.code	16
 953              		.thumb_func
 954              		.fpu softvfp
 956              	LPUART_DisableInterrupts:
 957              	.LFB70:
 605:../drivers/fsl_lpuart.c **** 
 606:../drivers/fsl_lpuart.c **** void LPUART_DisableInterrupts(LPUART_Type *base, uint32_t mask)
 607:../drivers/fsl_lpuart.c **** {
 958              		.loc 1 607 0
 959              		.cfi_startproc
 960              		@ args = 0, pretend = 0, frame = 0
 961              		@ frame_needed = 0, uses_anonymous_args = 0
 962              	.LVL124:
 963 0000 10B5     		push	{r4, lr}
 964              		.cfi_def_cfa_offset 8
 965              		.cfi_offset 4, -8
 966              		.cfi_offset 14, -4
 608:../drivers/fsl_lpuart.c ****     base->BAUD &= ~((mask << 8) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
 967              		.loc 1 608 0
 968 0002 0368     		ldr	r3, [r0]
 969 0004 0A02     		lsls	r2, r1, #8
 970 0006 C024     		movs	r4, #192
 971 0008 2402     		lsls	r4, r4, #8
 972 000a 2240     		ands	r2, r4
 973 000c 9343     		bics	r3, r2
 974 000e 0360     		str	r3, [r0]
 609:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 610:../drivers/fsl_lpuart.c ****     base->FIFO = (base->FIFO & ~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) &
 611:../drivers/fsl_lpuart.c ****                  ~((mask << 8) & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK));
 612:../drivers/fsl_lpuart.c **** #endif
 613:../drivers/fsl_lpuart.c ****     mask &= 0xFFFFFF00U;
 975              		.loc 1 613 0
 976 0010 FF23     		movs	r3, #255
 977 0012 9943     		bics	r1, r3
 978              	.LVL125:
 614:../drivers/fsl_lpuart.c ****     base->CTRL &= ~mask;
 979              		.loc 1 614 0
 980 0014 8368     		ldr	r3, [r0, #8]
 981 0016 8B43     		bics	r3, r1
 982 0018 8360     		str	r3, [r0, #8]
 615:../drivers/fsl_lpuart.c **** }
 983              		.loc 1 615 0
 984              		@ sp needed
 985 001a 10BD     		pop	{r4, pc}
 986              		.cfi_endproc
 987              	.LFE70:
 989              		.section	.text.LPUART_TransferHandleIRQ,"ax",%progbits
 990              		.align	1
 991              		.global	LPUART_TransferHandleIRQ
 992              		.syntax unified
 993              		.code	16
 994              		.thumb_func
 995              		.fpu softvfp
 997              	LPUART_TransferHandleIRQ:
 998              	.LFB85:
 616:../drivers/fsl_lpuart.c **** 
 617:../drivers/fsl_lpuart.c **** uint32_t LPUART_GetEnabledInterrupts(LPUART_Type *base)
 618:../drivers/fsl_lpuart.c **** {
 619:../drivers/fsl_lpuart.c ****     uint32_t temp;
 620:../drivers/fsl_lpuart.c ****     temp = (base->BAUD & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK)) >> 8;
 621:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 622:../drivers/fsl_lpuart.c ****     temp |= (base->FIFO & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK)) >> 8;
 623:../drivers/fsl_lpuart.c **** #endif
 624:../drivers/fsl_lpuart.c ****     temp |= (base->CTRL & 0xFF0C000);
 625:../drivers/fsl_lpuart.c **** 
 626:../drivers/fsl_lpuart.c ****     return temp;
 627:../drivers/fsl_lpuart.c **** }
 628:../drivers/fsl_lpuart.c **** 
 629:../drivers/fsl_lpuart.c **** uint32_t LPUART_GetStatusFlags(LPUART_Type *base)
 630:../drivers/fsl_lpuart.c **** {
 631:../drivers/fsl_lpuart.c ****     uint32_t temp;
 632:../drivers/fsl_lpuart.c ****     temp = base->STAT;
 633:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 634:../drivers/fsl_lpuart.c ****     temp |= (base->FIFO &
 635:../drivers/fsl_lpuart.c ****              (LPUART_FIFO_TXEMPT_MASK | LPUART_FIFO_RXEMPT_MASK | LPUART_FIFO_TXOF_MASK | LPUART_FI
 636:../drivers/fsl_lpuart.c ****             16;
 637:../drivers/fsl_lpuart.c **** #endif
 638:../drivers/fsl_lpuart.c ****     return temp;
 639:../drivers/fsl_lpuart.c **** }
 640:../drivers/fsl_lpuart.c **** 
 641:../drivers/fsl_lpuart.c **** status_t LPUART_ClearStatusFlags(LPUART_Type *base, uint32_t mask)
 642:../drivers/fsl_lpuart.c **** {
 643:../drivers/fsl_lpuart.c ****     uint32_t temp;
 644:../drivers/fsl_lpuart.c ****     status_t status;
 645:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 646:../drivers/fsl_lpuart.c ****     temp = (uint32_t)base->FIFO;
 647:../drivers/fsl_lpuart.c ****     temp &= (uint32_t)(~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK));
 648:../drivers/fsl_lpuart.c ****     temp |= (mask << 16) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
 649:../drivers/fsl_lpuart.c ****     base->FIFO = temp;
 650:../drivers/fsl_lpuart.c **** #endif
 651:../drivers/fsl_lpuart.c ****     temp = (uint32_t)base->STAT;
 652:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
 653:../drivers/fsl_lpuart.c ****     temp &= (uint32_t)(~(LPUART_STAT_LBKDIF_MASK));
 654:../drivers/fsl_lpuart.c ****     temp |= mask & LPUART_STAT_LBKDIF_MASK;
 655:../drivers/fsl_lpuart.c **** #endif
 656:../drivers/fsl_lpuart.c ****     temp &= (uint32_t)(~(LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | L
 657:../drivers/fsl_lpuart.c ****                          LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK));
 658:../drivers/fsl_lpuart.c ****     temp |= mask & (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART
 659:../drivers/fsl_lpuart.c ****                     LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
 660:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
 661:../drivers/fsl_lpuart.c ****     temp &= (uint32_t)(~(LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK));
 662:../drivers/fsl_lpuart.c ****     temp |= mask & (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK);
 663:../drivers/fsl_lpuart.c **** #endif
 664:../drivers/fsl_lpuart.c ****     base->STAT = temp;
 665:../drivers/fsl_lpuart.c ****     /* If some flags still pending. */
 666:../drivers/fsl_lpuart.c ****     if (mask & LPUART_GetStatusFlags(base))
 667:../drivers/fsl_lpuart.c ****     {
 668:../drivers/fsl_lpuart.c ****         /* Some flags can only clear or set by the hardware itself, these flags are: kLPUART_TxData
 669:../drivers/fsl_lpuart.c ****         kLPUART_TransmissionCompleteFlag, kLPUART_RxDataRegFullFlag, kLPUART_RxActiveFlag,
 670:../drivers/fsl_lpuart.c ****         kLPUART_NoiseErrorInRxDataRegFlag, kLPUART_ParityErrorInRxDataRegFlag,
 671:../drivers/fsl_lpuart.c ****         kLPUART_TxFifoEmptyFlag, kLPUART_RxFifoEmptyFlag. */
 672:../drivers/fsl_lpuart.c ****         status = kStatus_LPUART_FlagCannotClearManually; /* flags can not clear manually */
 673:../drivers/fsl_lpuart.c ****     }
 674:../drivers/fsl_lpuart.c ****     else
 675:../drivers/fsl_lpuart.c ****     {
 676:../drivers/fsl_lpuart.c ****         status = kStatus_Success;
 677:../drivers/fsl_lpuart.c ****     }
 678:../drivers/fsl_lpuart.c **** 
 679:../drivers/fsl_lpuart.c ****     return status;
 680:../drivers/fsl_lpuart.c **** }
 681:../drivers/fsl_lpuart.c **** 
 682:../drivers/fsl_lpuart.c **** void LPUART_WriteBlocking(LPUART_Type *base, const uint8_t *data, size_t length)
 683:../drivers/fsl_lpuart.c **** {
 684:../drivers/fsl_lpuart.c ****     assert(data);
 685:../drivers/fsl_lpuart.c **** 
 686:../drivers/fsl_lpuart.c ****     /* This API can only ensure that the data is written into the data buffer but can't
 687:../drivers/fsl_lpuart.c ****     ensure all data in the data buffer are sent into the transmit shift buffer. */
 688:../drivers/fsl_lpuart.c ****     while (length--)
 689:../drivers/fsl_lpuart.c ****     {
 690:../drivers/fsl_lpuart.c ****         while (!(base->STAT & LPUART_STAT_TDRE_MASK))
 691:../drivers/fsl_lpuart.c ****         {
 692:../drivers/fsl_lpuart.c ****         }
 693:../drivers/fsl_lpuart.c ****         base->DATA = *(data++);
 694:../drivers/fsl_lpuart.c ****     }
 695:../drivers/fsl_lpuart.c **** }
 696:../drivers/fsl_lpuart.c **** 
 697:../drivers/fsl_lpuart.c **** status_t LPUART_ReadBlocking(LPUART_Type *base, uint8_t *data, size_t length)
 698:../drivers/fsl_lpuart.c **** {
 699:../drivers/fsl_lpuart.c ****     assert(data);
 700:../drivers/fsl_lpuart.c **** 
 701:../drivers/fsl_lpuart.c ****     uint32_t statusFlag;
 702:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 703:../drivers/fsl_lpuart.c ****     uint32_t ctrl = base->CTRL;
 704:../drivers/fsl_lpuart.c ****     bool isSevenDataBits =
 705:../drivers/fsl_lpuart.c ****         ((ctrl & LPUART_CTRL_M7_MASK) ||
 706:../drivers/fsl_lpuart.c ****          ((!(ctrl & LPUART_CTRL_M7_MASK)) && (!(ctrl & LPUART_CTRL_M_MASK)) && (ctrl & LPUART_CTRL_
 707:../drivers/fsl_lpuart.c **** #endif
 708:../drivers/fsl_lpuart.c **** 
 709:../drivers/fsl_lpuart.c ****     while (length--)
 710:../drivers/fsl_lpuart.c ****     {
 711:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 712:../drivers/fsl_lpuart.c ****         while (0 == ((base->WATER & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT))
 713:../drivers/fsl_lpuart.c **** #else
 714:../drivers/fsl_lpuart.c ****         while (!(base->STAT & LPUART_STAT_RDRF_MASK))
 715:../drivers/fsl_lpuart.c **** #endif
 716:../drivers/fsl_lpuart.c ****         {
 717:../drivers/fsl_lpuart.c ****             statusFlag = LPUART_GetStatusFlags(base);
 718:../drivers/fsl_lpuart.c **** 
 719:../drivers/fsl_lpuart.c ****             if (statusFlag & kLPUART_RxOverrunFlag)
 720:../drivers/fsl_lpuart.c ****             {
 721:../drivers/fsl_lpuart.c ****                 LPUART_ClearStatusFlags(base, kLPUART_RxOverrunFlag);
 722:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_RxHardwareOverrun;
 723:../drivers/fsl_lpuart.c ****             }
 724:../drivers/fsl_lpuart.c **** 
 725:../drivers/fsl_lpuart.c ****             if (statusFlag & kLPUART_NoiseErrorFlag)
 726:../drivers/fsl_lpuart.c ****             {
 727:../drivers/fsl_lpuart.c ****                 LPUART_ClearStatusFlags(base, kLPUART_NoiseErrorFlag);
 728:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_NoiseError;
 729:../drivers/fsl_lpuart.c ****             }
 730:../drivers/fsl_lpuart.c **** 
 731:../drivers/fsl_lpuart.c ****             if (statusFlag & kLPUART_FramingErrorFlag)
 732:../drivers/fsl_lpuart.c ****             {
 733:../drivers/fsl_lpuart.c ****                 LPUART_ClearStatusFlags(base, kLPUART_FramingErrorFlag);
 734:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_FramingError;
 735:../drivers/fsl_lpuart.c ****             }
 736:../drivers/fsl_lpuart.c **** 
 737:../drivers/fsl_lpuart.c ****             if (statusFlag & kLPUART_ParityErrorFlag)
 738:../drivers/fsl_lpuart.c ****             {
 739:../drivers/fsl_lpuart.c ****                 LPUART_ClearStatusFlags(base, kLPUART_ParityErrorFlag);
 740:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_ParityError;
 741:../drivers/fsl_lpuart.c ****             }
 742:../drivers/fsl_lpuart.c ****         }
 743:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 744:../drivers/fsl_lpuart.c ****         if (isSevenDataBits)
 745:../drivers/fsl_lpuart.c ****         {
 746:../drivers/fsl_lpuart.c ****             *(data++) = (base->DATA & 0x7F);
 747:../drivers/fsl_lpuart.c ****         }
 748:../drivers/fsl_lpuart.c ****         else
 749:../drivers/fsl_lpuart.c ****         {
 750:../drivers/fsl_lpuart.c ****             *(data++) = base->DATA;
 751:../drivers/fsl_lpuart.c ****         }
 752:../drivers/fsl_lpuart.c **** #else
 753:../drivers/fsl_lpuart.c ****         *(data++) = base->DATA;
 754:../drivers/fsl_lpuart.c **** #endif
 755:../drivers/fsl_lpuart.c ****     }
 756:../drivers/fsl_lpuart.c **** 
 757:../drivers/fsl_lpuart.c ****     return kStatus_Success;
 758:../drivers/fsl_lpuart.c **** }
 759:../drivers/fsl_lpuart.c **** 
 760:../drivers/fsl_lpuart.c **** void LPUART_TransferCreateHandle(LPUART_Type *base,
 761:../drivers/fsl_lpuart.c ****                                  lpuart_handle_t *handle,
 762:../drivers/fsl_lpuart.c ****                                  lpuart_transfer_callback_t callback,
 763:../drivers/fsl_lpuart.c ****                                  void *userData)
 764:../drivers/fsl_lpuart.c **** {
 765:../drivers/fsl_lpuart.c ****     assert(handle);
 766:../drivers/fsl_lpuart.c **** 
 767:../drivers/fsl_lpuart.c ****     uint32_t instance;
 768:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 769:../drivers/fsl_lpuart.c ****     uint32_t ctrl = base->CTRL;
 770:../drivers/fsl_lpuart.c ****     bool isSevenDataBits =
 771:../drivers/fsl_lpuart.c ****         ((ctrl & LPUART_CTRL_M7_MASK) ||
 772:../drivers/fsl_lpuart.c ****          ((!(ctrl & LPUART_CTRL_M7_MASK)) && (!(ctrl & LPUART_CTRL_M_MASK)) && (ctrl & LPUART_CTRL_
 773:../drivers/fsl_lpuart.c **** #endif
 774:../drivers/fsl_lpuart.c **** 
 775:../drivers/fsl_lpuart.c ****     /* Zero the handle. */
 776:../drivers/fsl_lpuart.c ****     memset(handle, 0, sizeof(lpuart_handle_t));
 777:../drivers/fsl_lpuart.c **** 
 778:../drivers/fsl_lpuart.c ****     /* Set the TX/RX state. */
 779:../drivers/fsl_lpuart.c ****     handle->rxState = kLPUART_RxIdle;
 780:../drivers/fsl_lpuart.c ****     handle->txState = kLPUART_TxIdle;
 781:../drivers/fsl_lpuart.c **** 
 782:../drivers/fsl_lpuart.c ****     /* Set the callback and user data. */
 783:../drivers/fsl_lpuart.c ****     handle->callback = callback;
 784:../drivers/fsl_lpuart.c ****     handle->userData = userData;
 785:../drivers/fsl_lpuart.c **** 
 786:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 787:../drivers/fsl_lpuart.c ****     /* Initial seven data bits flag */
 788:../drivers/fsl_lpuart.c ****     handle->isSevenDataBits = isSevenDataBits;
 789:../drivers/fsl_lpuart.c **** #endif
 790:../drivers/fsl_lpuart.c **** 
 791:../drivers/fsl_lpuart.c ****     /* Get instance from peripheral base address. */
 792:../drivers/fsl_lpuart.c ****     instance = LPUART_GetInstance(base);
 793:../drivers/fsl_lpuart.c **** 
 794:../drivers/fsl_lpuart.c ****     /* Save the handle in global variables to support the double weak mechanism. */
 795:../drivers/fsl_lpuart.c ****     s_lpuartHandle[instance] = handle;
 796:../drivers/fsl_lpuart.c **** 
 797:../drivers/fsl_lpuart.c ****     s_lpuartIsr = LPUART_TransferHandleIRQ;
 798:../drivers/fsl_lpuart.c **** 
 799:../drivers/fsl_lpuart.c **** /* Enable interrupt in NVIC. */
 800:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
 801:../drivers/fsl_lpuart.c ****     EnableIRQ(s_lpuartRxIRQ[instance]);
 802:../drivers/fsl_lpuart.c ****     EnableIRQ(s_lpuartTxIRQ[instance]);
 803:../drivers/fsl_lpuart.c **** #else
 804:../drivers/fsl_lpuart.c ****     EnableIRQ(s_lpuartIRQ[instance]);
 805:../drivers/fsl_lpuart.c **** #endif
 806:../drivers/fsl_lpuart.c **** }
 807:../drivers/fsl_lpuart.c **** 
 808:../drivers/fsl_lpuart.c **** void LPUART_TransferStartRingBuffer(LPUART_Type *base,
 809:../drivers/fsl_lpuart.c ****                                     lpuart_handle_t *handle,
 810:../drivers/fsl_lpuart.c ****                                     uint8_t *ringBuffer,
 811:../drivers/fsl_lpuart.c ****                                     size_t ringBufferSize)
 812:../drivers/fsl_lpuart.c **** {
 813:../drivers/fsl_lpuart.c ****     assert(handle);
 814:../drivers/fsl_lpuart.c ****     assert(ringBuffer);
 815:../drivers/fsl_lpuart.c **** 
 816:../drivers/fsl_lpuart.c ****     /* Setup the ring buffer address */
 817:../drivers/fsl_lpuart.c ****     handle->rxRingBuffer = ringBuffer;
 818:../drivers/fsl_lpuart.c ****     handle->rxRingBufferSize = ringBufferSize;
 819:../drivers/fsl_lpuart.c ****     handle->rxRingBufferHead = 0U;
 820:../drivers/fsl_lpuart.c ****     handle->rxRingBufferTail = 0U;
 821:../drivers/fsl_lpuart.c **** 
 822:../drivers/fsl_lpuart.c ****     /* Enable the interrupt to accept the data when user need the ring buffer. */
 823:../drivers/fsl_lpuart.c ****     LPUART_EnableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterrupt
 824:../drivers/fsl_lpuart.c **** }
 825:../drivers/fsl_lpuart.c **** 
 826:../drivers/fsl_lpuart.c **** void LPUART_TransferStopRingBuffer(LPUART_Type *base, lpuart_handle_t *handle)
 827:../drivers/fsl_lpuart.c **** {
 828:../drivers/fsl_lpuart.c ****     assert(handle);
 829:../drivers/fsl_lpuart.c **** 
 830:../drivers/fsl_lpuart.c ****     if (handle->rxState == kLPUART_RxIdle)
 831:../drivers/fsl_lpuart.c ****     {
 832:../drivers/fsl_lpuart.c ****         LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInte
 833:../drivers/fsl_lpuart.c ****     }
 834:../drivers/fsl_lpuart.c **** 
 835:../drivers/fsl_lpuart.c ****     handle->rxRingBuffer = NULL;
 836:../drivers/fsl_lpuart.c ****     handle->rxRingBufferSize = 0U;
 837:../drivers/fsl_lpuart.c ****     handle->rxRingBufferHead = 0U;
 838:../drivers/fsl_lpuart.c ****     handle->rxRingBufferTail = 0U;
 839:../drivers/fsl_lpuart.c **** }
 840:../drivers/fsl_lpuart.c **** 
 841:../drivers/fsl_lpuart.c **** status_t LPUART_TransferSendNonBlocking(LPUART_Type *base, lpuart_handle_t *handle, lpuart_transfer
 842:../drivers/fsl_lpuart.c **** {
 843:../drivers/fsl_lpuart.c ****     assert(handle);
 844:../drivers/fsl_lpuart.c ****     assert(xfer);
 845:../drivers/fsl_lpuart.c ****     assert(xfer->data);
 846:../drivers/fsl_lpuart.c ****     assert(xfer->dataSize);
 847:../drivers/fsl_lpuart.c **** 
 848:../drivers/fsl_lpuart.c ****     status_t status;
 849:../drivers/fsl_lpuart.c **** 
 850:../drivers/fsl_lpuart.c ****     /* Return error if current TX busy. */
 851:../drivers/fsl_lpuart.c ****     if (kLPUART_TxBusy == handle->txState)
 852:../drivers/fsl_lpuart.c ****     {
 853:../drivers/fsl_lpuart.c ****         status = kStatus_LPUART_TxBusy;
 854:../drivers/fsl_lpuart.c ****     }
 855:../drivers/fsl_lpuart.c ****     else
 856:../drivers/fsl_lpuart.c ****     {
 857:../drivers/fsl_lpuart.c ****         handle->txData = xfer->data;
 858:../drivers/fsl_lpuart.c ****         handle->txDataSize = xfer->dataSize;
 859:../drivers/fsl_lpuart.c ****         handle->txDataSizeAll = xfer->dataSize;
 860:../drivers/fsl_lpuart.c ****         handle->txState = kLPUART_TxBusy;
 861:../drivers/fsl_lpuart.c **** 
 862:../drivers/fsl_lpuart.c ****         /* Enable transmiter interrupt. */
 863:../drivers/fsl_lpuart.c ****         LPUART_EnableInterrupts(base, kLPUART_TxDataRegEmptyInterruptEnable);
 864:../drivers/fsl_lpuart.c **** 
 865:../drivers/fsl_lpuart.c ****         status = kStatus_Success;
 866:../drivers/fsl_lpuart.c ****     }
 867:../drivers/fsl_lpuart.c **** 
 868:../drivers/fsl_lpuart.c ****     return status;
 869:../drivers/fsl_lpuart.c **** }
 870:../drivers/fsl_lpuart.c **** 
 871:../drivers/fsl_lpuart.c **** void LPUART_TransferAbortSend(LPUART_Type *base, lpuart_handle_t *handle)
 872:../drivers/fsl_lpuart.c **** {
 873:../drivers/fsl_lpuart.c ****     assert(handle);
 874:../drivers/fsl_lpuart.c **** 
 875:../drivers/fsl_lpuart.c ****     LPUART_DisableInterrupts(base, kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_TransmissionComp
 876:../drivers/fsl_lpuart.c **** 
 877:../drivers/fsl_lpuart.c ****     handle->txDataSize = 0;
 878:../drivers/fsl_lpuart.c ****     handle->txState = kLPUART_TxIdle;
 879:../drivers/fsl_lpuart.c **** }
 880:../drivers/fsl_lpuart.c **** 
 881:../drivers/fsl_lpuart.c **** status_t LPUART_TransferGetSendCount(LPUART_Type *base, lpuart_handle_t *handle, uint32_t *count)
 882:../drivers/fsl_lpuart.c **** {
 883:../drivers/fsl_lpuart.c ****     assert(handle);
 884:../drivers/fsl_lpuart.c ****     assert(count);
 885:../drivers/fsl_lpuart.c **** 
 886:../drivers/fsl_lpuart.c ****     if (kLPUART_TxIdle == handle->txState)
 887:../drivers/fsl_lpuart.c ****     {
 888:../drivers/fsl_lpuart.c ****         return kStatus_NoTransferInProgress;
 889:../drivers/fsl_lpuart.c ****     }
 890:../drivers/fsl_lpuart.c **** 
 891:../drivers/fsl_lpuart.c ****     *count = handle->txDataSizeAll - handle->txDataSize;
 892:../drivers/fsl_lpuart.c **** 
 893:../drivers/fsl_lpuart.c ****     return kStatus_Success;
 894:../drivers/fsl_lpuart.c **** }
 895:../drivers/fsl_lpuart.c **** 
 896:../drivers/fsl_lpuart.c **** status_t LPUART_TransferReceiveNonBlocking(LPUART_Type *base,
 897:../drivers/fsl_lpuart.c ****                                            lpuart_handle_t *handle,
 898:../drivers/fsl_lpuart.c ****                                            lpuart_transfer_t *xfer,
 899:../drivers/fsl_lpuart.c ****                                            size_t *receivedBytes)
 900:../drivers/fsl_lpuart.c **** {
 901:../drivers/fsl_lpuart.c ****     assert(handle);
 902:../drivers/fsl_lpuart.c ****     assert(xfer);
 903:../drivers/fsl_lpuart.c ****     assert(xfer->data);
 904:../drivers/fsl_lpuart.c ****     assert(xfer->dataSize);
 905:../drivers/fsl_lpuart.c **** 
 906:../drivers/fsl_lpuart.c ****     uint32_t i;
 907:../drivers/fsl_lpuart.c ****     status_t status;
 908:../drivers/fsl_lpuart.c ****     /* How many bytes to copy from ring buffer to user memory. */
 909:../drivers/fsl_lpuart.c ****     size_t bytesToCopy = 0U;
 910:../drivers/fsl_lpuart.c ****     /* How many bytes to receive. */
 911:../drivers/fsl_lpuart.c ****     size_t bytesToReceive;
 912:../drivers/fsl_lpuart.c ****     /* How many bytes currently have received. */
 913:../drivers/fsl_lpuart.c ****     size_t bytesCurrentReceived;
 914:../drivers/fsl_lpuart.c **** 
 915:../drivers/fsl_lpuart.c ****     /* How to get data:
 916:../drivers/fsl_lpuart.c ****        1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
 917:../drivers/fsl_lpuart.c ****           to lpuart handle, enable interrupt to store received data to xfer->data. When
 918:../drivers/fsl_lpuart.c ****           all data received, trigger callback.
 919:../drivers/fsl_lpuart.c ****        2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
 920:../drivers/fsl_lpuart.c ****           If there are enough data in ring buffer, copy them to xfer->data and return.
 921:../drivers/fsl_lpuart.c ****           If there are not enough data in ring buffer, copy all of them to xfer->data,
 922:../drivers/fsl_lpuart.c ****           save the xfer->data remained empty space to lpuart handle, receive data
 923:../drivers/fsl_lpuart.c ****           to this empty space and trigger callback when finished. */
 924:../drivers/fsl_lpuart.c **** 
 925:../drivers/fsl_lpuart.c ****     if (kLPUART_RxBusy == handle->rxState)
 926:../drivers/fsl_lpuart.c ****     {
 927:../drivers/fsl_lpuart.c ****         status = kStatus_LPUART_RxBusy;
 928:../drivers/fsl_lpuart.c ****     }
 929:../drivers/fsl_lpuart.c ****     else
 930:../drivers/fsl_lpuart.c ****     {
 931:../drivers/fsl_lpuart.c ****         bytesToReceive = xfer->dataSize;
 932:../drivers/fsl_lpuart.c ****         bytesCurrentReceived = 0;
 933:../drivers/fsl_lpuart.c **** 
 934:../drivers/fsl_lpuart.c ****         /* If RX ring buffer is used. */
 935:../drivers/fsl_lpuart.c ****         if (handle->rxRingBuffer)
 936:../drivers/fsl_lpuart.c ****         {
 937:../drivers/fsl_lpuart.c ****             /* Disable LPUART RX IRQ, protect ring buffer. */
 938:../drivers/fsl_lpuart.c ****             LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable);
 939:../drivers/fsl_lpuart.c **** 
 940:../drivers/fsl_lpuart.c ****             /* How many bytes in RX ring buffer currently. */
 941:../drivers/fsl_lpuart.c ****             bytesToCopy = LPUART_TransferGetRxRingBufferLength(base, handle);
 942:../drivers/fsl_lpuart.c **** 
 943:../drivers/fsl_lpuart.c ****             if (bytesToCopy)
 944:../drivers/fsl_lpuart.c ****             {
 945:../drivers/fsl_lpuart.c ****                 bytesToCopy = MIN(bytesToReceive, bytesToCopy);
 946:../drivers/fsl_lpuart.c **** 
 947:../drivers/fsl_lpuart.c ****                 bytesToReceive -= bytesToCopy;
 948:../drivers/fsl_lpuart.c **** 
 949:../drivers/fsl_lpuart.c ****                 /* Copy data from ring buffer to user memory. */
 950:../drivers/fsl_lpuart.c ****                 for (i = 0U; i < bytesToCopy; i++)
 951:../drivers/fsl_lpuart.c ****                 {
 952:../drivers/fsl_lpuart.c ****                     xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferT
 953:../drivers/fsl_lpuart.c **** 
 954:../drivers/fsl_lpuart.c ****                     /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
 955:../drivers/fsl_lpuart.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 956:../drivers/fsl_lpuart.c ****                     {
 957:../drivers/fsl_lpuart.c ****                         handle->rxRingBufferTail = 0U;
 958:../drivers/fsl_lpuart.c ****                     }
 959:../drivers/fsl_lpuart.c ****                     else
 960:../drivers/fsl_lpuart.c ****                     {
 961:../drivers/fsl_lpuart.c ****                         handle->rxRingBufferTail++;
 962:../drivers/fsl_lpuart.c ****                     }
 963:../drivers/fsl_lpuart.c ****                 }
 964:../drivers/fsl_lpuart.c ****             }
 965:../drivers/fsl_lpuart.c **** 
 966:../drivers/fsl_lpuart.c ****             /* If ring buffer does not have enough data, still need to read more data. */
 967:../drivers/fsl_lpuart.c ****             if (bytesToReceive)
 968:../drivers/fsl_lpuart.c ****             {
 969:../drivers/fsl_lpuart.c ****                 /* No data in ring buffer, save the request to LPUART handle. */
 970:../drivers/fsl_lpuart.c ****                 handle->rxData = xfer->data + bytesCurrentReceived;
 971:../drivers/fsl_lpuart.c ****                 handle->rxDataSize = bytesToReceive;
 972:../drivers/fsl_lpuart.c ****                 handle->rxDataSizeAll = bytesToReceive;
 973:../drivers/fsl_lpuart.c ****                 handle->rxState = kLPUART_RxBusy;
 974:../drivers/fsl_lpuart.c ****             }
 975:../drivers/fsl_lpuart.c ****             /* Enable LPUART RX IRQ if previously enabled. */
 976:../drivers/fsl_lpuart.c ****             LPUART_EnableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable);
 977:../drivers/fsl_lpuart.c **** 
 978:../drivers/fsl_lpuart.c ****             /* Call user callback since all data are received. */
 979:../drivers/fsl_lpuart.c ****             if (0 == bytesToReceive)
 980:../drivers/fsl_lpuart.c ****             {
 981:../drivers/fsl_lpuart.c ****                 if (handle->callback)
 982:../drivers/fsl_lpuart.c ****                 {
 983:../drivers/fsl_lpuart.c ****                     handle->callback(base, handle, kStatus_LPUART_RxIdle, handle->userData);
 984:../drivers/fsl_lpuart.c ****                 }
 985:../drivers/fsl_lpuart.c ****             }
 986:../drivers/fsl_lpuart.c ****         }
 987:../drivers/fsl_lpuart.c ****         /* Ring buffer not used. */
 988:../drivers/fsl_lpuart.c ****         else
 989:../drivers/fsl_lpuart.c ****         {
 990:../drivers/fsl_lpuart.c ****             handle->rxData = xfer->data + bytesCurrentReceived;
 991:../drivers/fsl_lpuart.c ****             handle->rxDataSize = bytesToReceive;
 992:../drivers/fsl_lpuart.c ****             handle->rxDataSizeAll = bytesToReceive;
 993:../drivers/fsl_lpuart.c ****             handle->rxState = kLPUART_RxBusy;
 994:../drivers/fsl_lpuart.c **** 
 995:../drivers/fsl_lpuart.c ****             /* Enable RX interrupt. */
 996:../drivers/fsl_lpuart.c ****             LPUART_EnableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunI
 997:../drivers/fsl_lpuart.c ****                                               kLPUART_IdleLineInterruptEnable);
 998:../drivers/fsl_lpuart.c ****         }
 999:../drivers/fsl_lpuart.c **** 
1000:../drivers/fsl_lpuart.c ****         /* Return the how many bytes have read. */
1001:../drivers/fsl_lpuart.c ****         if (receivedBytes)
1002:../drivers/fsl_lpuart.c ****         {
1003:../drivers/fsl_lpuart.c ****             *receivedBytes = bytesCurrentReceived;
1004:../drivers/fsl_lpuart.c ****         }
1005:../drivers/fsl_lpuart.c **** 
1006:../drivers/fsl_lpuart.c ****         status = kStatus_Success;
1007:../drivers/fsl_lpuart.c ****     }
1008:../drivers/fsl_lpuart.c **** 
1009:../drivers/fsl_lpuart.c ****     return status;
1010:../drivers/fsl_lpuart.c **** }
1011:../drivers/fsl_lpuart.c **** 
1012:../drivers/fsl_lpuart.c **** void LPUART_TransferAbortReceive(LPUART_Type *base, lpuart_handle_t *handle)
1013:../drivers/fsl_lpuart.c **** {
1014:../drivers/fsl_lpuart.c ****     assert(handle);
1015:../drivers/fsl_lpuart.c **** 
1016:../drivers/fsl_lpuart.c ****     /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
1017:../drivers/fsl_lpuart.c ****     if (!handle->rxRingBuffer)
1018:../drivers/fsl_lpuart.c ****     {
1019:../drivers/fsl_lpuart.c ****         /* Disable RX interrupt. */
1020:../drivers/fsl_lpuart.c ****         LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInte
1021:../drivers/fsl_lpuart.c ****                                            kLPUART_IdleLineInterruptEnable);
1022:../drivers/fsl_lpuart.c ****     }
1023:../drivers/fsl_lpuart.c **** 
1024:../drivers/fsl_lpuart.c ****     handle->rxDataSize = 0U;
1025:../drivers/fsl_lpuart.c ****     handle->rxState = kLPUART_RxIdle;
1026:../drivers/fsl_lpuart.c **** }
1027:../drivers/fsl_lpuart.c **** 
1028:../drivers/fsl_lpuart.c **** status_t LPUART_TransferGetReceiveCount(LPUART_Type *base, lpuart_handle_t *handle, uint32_t *count
1029:../drivers/fsl_lpuart.c **** {
1030:../drivers/fsl_lpuart.c ****     assert(handle);
1031:../drivers/fsl_lpuart.c ****     assert(count);
1032:../drivers/fsl_lpuart.c **** 
1033:../drivers/fsl_lpuart.c ****     if (kLPUART_RxIdle == handle->rxState)
1034:../drivers/fsl_lpuart.c ****     {
1035:../drivers/fsl_lpuart.c ****         return kStatus_NoTransferInProgress;
1036:../drivers/fsl_lpuart.c ****     }
1037:../drivers/fsl_lpuart.c **** 
1038:../drivers/fsl_lpuart.c ****     *count = handle->rxDataSizeAll - handle->rxDataSize;
1039:../drivers/fsl_lpuart.c **** 
1040:../drivers/fsl_lpuart.c ****     return kStatus_Success;
1041:../drivers/fsl_lpuart.c **** }
1042:../drivers/fsl_lpuart.c **** 
1043:../drivers/fsl_lpuart.c **** void LPUART_TransferHandleIRQ(LPUART_Type *base, lpuart_handle_t *handle)
1044:../drivers/fsl_lpuart.c **** {
 999              		.loc 1 1044 0
 1000              		.cfi_startproc
 1001              		@ args = 0, pretend = 0, frame = 0
 1002              		@ frame_needed = 0, uses_anonymous_args = 0
 1003              	.LVL126:
 1004 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1005              		.cfi_def_cfa_offset 24
 1006              		.cfi_offset 3, -24
 1007              		.cfi_offset 4, -20
 1008              		.cfi_offset 5, -16
 1009              		.cfi_offset 6, -12
 1010              		.cfi_offset 7, -8
 1011              		.cfi_offset 14, -4
 1012 0002 0500     		movs	r5, r0
 1013 0004 0C00     		movs	r4, r1
1045:../drivers/fsl_lpuart.c ****     assert(handle);
1046:../drivers/fsl_lpuart.c **** 
1047:../drivers/fsl_lpuart.c ****     uint8_t count;
1048:../drivers/fsl_lpuart.c ****     uint8_t tempCount;
1049:../drivers/fsl_lpuart.c **** 
1050:../drivers/fsl_lpuart.c ****     /* If RX overrun. */
1051:../drivers/fsl_lpuart.c ****     if (LPUART_STAT_OR_MASK & base->STAT)
 1014              		.loc 1 1051 0
 1015 0006 4368     		ldr	r3, [r0, #4]
 1016 0008 1B03     		lsls	r3, r3, #12
 1017 000a 0CD5     		bpl	.L62
1052:../drivers/fsl_lpuart.c ****     {
1053:../drivers/fsl_lpuart.c ****         /* Clear overrun flag, otherwise the RX does not work. */
1054:../drivers/fsl_lpuart.c ****         base->STAT = ((base->STAT & 0x3FE00000U) | LPUART_STAT_OR_MASK);
 1018              		.loc 1 1054 0
 1019 000c 4368     		ldr	r3, [r0, #4]
 1020 000e 624A     		ldr	r2, .L88
 1021 0010 1A40     		ands	r2, r3
 1022 0012 8023     		movs	r3, #128
 1023 0014 1B03     		lsls	r3, r3, #12
 1024 0016 1343     		orrs	r3, r2
 1025 0018 4360     		str	r3, [r0, #4]
1055:../drivers/fsl_lpuart.c **** 
1056:../drivers/fsl_lpuart.c ****         /* Trigger callback. */
1057:../drivers/fsl_lpuart.c ****         if (handle->callback)
 1026              		.loc 1 1057 0
 1027 001a 4E6A     		ldr	r6, [r1, #36]
 1028 001c 002E     		cmp	r6, #0
 1029 001e 02D0     		beq	.L62
1058:../drivers/fsl_lpuart.c ****         {
1059:../drivers/fsl_lpuart.c ****             handle->callback(base, handle, kStatus_LPUART_RxHardwareOverrun, handle->userData);
 1030              		.loc 1 1059 0
 1031 0020 8B6A     		ldr	r3, [r1, #40]
 1032 0022 5E4A     		ldr	r2, .L88+4
 1033 0024 B047     		blx	r6
 1034              	.LVL127:
 1035              	.L62:
1060:../drivers/fsl_lpuart.c ****         }
1061:../drivers/fsl_lpuart.c ****     }
1062:../drivers/fsl_lpuart.c **** 
1063:../drivers/fsl_lpuart.c ****     /* If IDLE flag is set and the IDLE interrupt is enabled. */
1064:../drivers/fsl_lpuart.c ****     if ((LPUART_STAT_IDLE_MASK & base->STAT) && (LPUART_CTRL_ILIE_MASK & base->CTRL))
 1036              		.loc 1 1064 0
 1037 0026 6B68     		ldr	r3, [r5, #4]
 1038 0028 DB02     		lsls	r3, r3, #11
 1039 002a 15D5     		bpl	.L63
 1040              		.loc 1 1064 0 is_stmt 0 discriminator 1
 1041 002c AB68     		ldr	r3, [r5, #8]
 1042 002e DB02     		lsls	r3, r3, #11
 1043 0030 12D5     		bpl	.L63
1065:../drivers/fsl_lpuart.c ****     {
1066:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
1067:../drivers/fsl_lpuart.c ****         count = ((uint8_t)((base->WATER & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT)
1068:../drivers/fsl_lpuart.c **** 
1069:../drivers/fsl_lpuart.c ****         while ((count) && (handle->rxDataSize))
1070:../drivers/fsl_lpuart.c ****         {
1071:../drivers/fsl_lpuart.c ****             tempCount = MIN(handle->rxDataSize, count);
1072:../drivers/fsl_lpuart.c **** 
1073:../drivers/fsl_lpuart.c ****             /* Using non block API to read the data from the registers. */
1074:../drivers/fsl_lpuart.c ****             LPUART_ReadNonBlocking(base, handle->rxData, tempCount);
1075:../drivers/fsl_lpuart.c ****             handle->rxData += tempCount;
1076:../drivers/fsl_lpuart.c ****             handle->rxDataSize -= tempCount;
1077:../drivers/fsl_lpuart.c ****             count -= tempCount;
1078:../drivers/fsl_lpuart.c **** 
1079:../drivers/fsl_lpuart.c ****             /* If rxDataSize is 0, disable idle line interrupt.*/
1080:../drivers/fsl_lpuart.c ****             if (!(handle->rxDataSize))
1081:../drivers/fsl_lpuart.c ****             {
1082:../drivers/fsl_lpuart.c ****                 handle->rxState = kLPUART_RxIdle;
1083:../drivers/fsl_lpuart.c **** 
1084:../drivers/fsl_lpuart.c ****                 LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOve
1085:../drivers/fsl_lpuart.c ****                 if (handle->callback)
1086:../drivers/fsl_lpuart.c ****                 {
1087:../drivers/fsl_lpuart.c ****                     handle->callback(base, handle, kStatus_LPUART_RxIdle, handle->userData);
1088:../drivers/fsl_lpuart.c ****                 }
1089:../drivers/fsl_lpuart.c ****             }
1090:../drivers/fsl_lpuart.c ****         }
1091:../drivers/fsl_lpuart.c **** #endif
1092:../drivers/fsl_lpuart.c ****         /* Clear IDLE flag.*/
1093:../drivers/fsl_lpuart.c ****         base->STAT |= LPUART_STAT_IDLE_MASK;
 1044              		.loc 1 1093 0 is_stmt 1
 1045 0032 6A68     		ldr	r2, [r5, #4]
 1046 0034 8023     		movs	r3, #128
 1047 0036 5B03     		lsls	r3, r3, #13
 1048 0038 1343     		orrs	r3, r2
 1049 003a 6B60     		str	r3, [r5, #4]
1094:../drivers/fsl_lpuart.c **** 
1095:../drivers/fsl_lpuart.c ****         /* If rxDataSize is 0, disable idle line interrupt.*/
1096:../drivers/fsl_lpuart.c ****         if (!(handle->rxDataSize))
 1050              		.loc 1 1096 0
 1051 003c 2369     		ldr	r3, [r4, #16]
 1052 003e 002B     		cmp	r3, #0
 1053 0040 40D0     		beq	.L85
 1054              	.L64:
1097:../drivers/fsl_lpuart.c ****         {
1098:../drivers/fsl_lpuart.c ****             LPUART_DisableInterrupts(base, kLPUART_IdleLineInterruptEnable);
1099:../drivers/fsl_lpuart.c ****         }
1100:../drivers/fsl_lpuart.c ****         /* If callback is not NULL and rxDataSize is not 0. */
1101:../drivers/fsl_lpuart.c ****         if ((handle->callback) && (handle->rxDataSize))
 1055              		.loc 1 1101 0
 1056 0042 666A     		ldr	r6, [r4, #36]
 1057 0044 002E     		cmp	r6, #0
 1058 0046 07D0     		beq	.L63
 1059              		.loc 1 1101 0 is_stmt 0 discriminator 1
 1060 0048 2369     		ldr	r3, [r4, #16]
 1061 004a 002B     		cmp	r3, #0
 1062 004c 04D0     		beq	.L63
1102:../drivers/fsl_lpuart.c ****         {
1103:../drivers/fsl_lpuart.c ****             handle->callback(base, handle, kStatus_LPUART_IdleLineDetected, handle->userData);
 1063              		.loc 1 1103 0 is_stmt 1
 1064 004e A36A     		ldr	r3, [r4, #40]
 1065 0050 534A     		ldr	r2, .L88+8
 1066 0052 2100     		movs	r1, r4
 1067 0054 2800     		movs	r0, r5
 1068 0056 B047     		blx	r6
 1069              	.LVL128:
 1070              	.L63:
1104:../drivers/fsl_lpuart.c ****         }
1105:../drivers/fsl_lpuart.c ****     }
1106:../drivers/fsl_lpuart.c ****     /* Receive data register full */
1107:../drivers/fsl_lpuart.c ****     if ((LPUART_STAT_RDRF_MASK & base->STAT) && (LPUART_CTRL_RIE_MASK & base->CTRL))
 1071              		.loc 1 1107 0
 1072 0058 6B68     		ldr	r3, [r5, #4]
 1073 005a 9B02     		lsls	r3, r3, #10
 1074 005c 02D5     		bpl	.L65
 1075              		.loc 1 1107 0 is_stmt 0 discriminator 1
 1076 005e AB68     		ldr	r3, [r5, #8]
 1077 0060 9B02     		lsls	r3, r3, #10
 1078 0062 35D4     		bmi	.L82
 1079              	.L65:
1108:../drivers/fsl_lpuart.c ****     {
1109:../drivers/fsl_lpuart.c **** /* Get the size that can be stored into buffer for this interrupt. */
1110:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
1111:../drivers/fsl_lpuart.c ****         count = ((uint8_t)((base->WATER & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT)
1112:../drivers/fsl_lpuart.c **** #else
1113:../drivers/fsl_lpuart.c ****         count = 1;
1114:../drivers/fsl_lpuart.c **** #endif
1115:../drivers/fsl_lpuart.c **** 
1116:../drivers/fsl_lpuart.c ****         /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
1117:../drivers/fsl_lpuart.c ****         while ((count) && (handle->rxDataSize))
1118:../drivers/fsl_lpuart.c ****         {
1119:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
1120:../drivers/fsl_lpuart.c ****             tempCount = MIN(handle->rxDataSize, count);
1121:../drivers/fsl_lpuart.c **** #else
1122:../drivers/fsl_lpuart.c ****             tempCount = 1;
1123:../drivers/fsl_lpuart.c **** #endif
1124:../drivers/fsl_lpuart.c **** 
1125:../drivers/fsl_lpuart.c ****             /* Using non block API to read the data from the registers. */
1126:../drivers/fsl_lpuart.c ****             LPUART_ReadNonBlocking(base, handle->rxData, tempCount);
1127:../drivers/fsl_lpuart.c ****             handle->rxData += tempCount;
1128:../drivers/fsl_lpuart.c ****             handle->rxDataSize -= tempCount;
1129:../drivers/fsl_lpuart.c ****             count -= tempCount;
1130:../drivers/fsl_lpuart.c **** 
1131:../drivers/fsl_lpuart.c ****             /* If all the data required for upper layer is ready, trigger callback. */
1132:../drivers/fsl_lpuart.c ****             if (!handle->rxDataSize)
1133:../drivers/fsl_lpuart.c ****             {
1134:../drivers/fsl_lpuart.c ****                 handle->rxState = kLPUART_RxIdle;
1135:../drivers/fsl_lpuart.c **** 
1136:../drivers/fsl_lpuart.c ****                 if (handle->callback)
1137:../drivers/fsl_lpuart.c ****                 {
1138:../drivers/fsl_lpuart.c ****                     handle->callback(base, handle, kStatus_LPUART_RxIdle, handle->userData);
1139:../drivers/fsl_lpuart.c ****                 }
1140:../drivers/fsl_lpuart.c ****             }
1141:../drivers/fsl_lpuart.c ****         }
1142:../drivers/fsl_lpuart.c **** 
1143:../drivers/fsl_lpuart.c ****         /* If use RX ring buffer, receive data to ring buffer. */
1144:../drivers/fsl_lpuart.c ****         if (handle->rxRingBuffer)
1145:../drivers/fsl_lpuart.c ****         {
1146:../drivers/fsl_lpuart.c ****             while (count--)
1147:../drivers/fsl_lpuart.c ****             {
1148:../drivers/fsl_lpuart.c ****                 /* If RX ring buffer is full, trigger callback to notify over run. */
1149:../drivers/fsl_lpuart.c ****                 if (LPUART_TransferIsRxRingBufferFull(base, handle))
1150:../drivers/fsl_lpuart.c ****                 {
1151:../drivers/fsl_lpuart.c ****                     if (handle->callback)
1152:../drivers/fsl_lpuart.c ****                     {
1153:../drivers/fsl_lpuart.c ****                         handle->callback(base, handle, kStatus_LPUART_RxRingBufferOverrun, handle->
1154:../drivers/fsl_lpuart.c ****                     }
1155:../drivers/fsl_lpuart.c ****                 }
1156:../drivers/fsl_lpuart.c **** 
1157:../drivers/fsl_lpuart.c ****                 /* If ring buffer is still full after callback function, the oldest data is overrid
1158:../drivers/fsl_lpuart.c ****                 if (LPUART_TransferIsRxRingBufferFull(base, handle))
1159:../drivers/fsl_lpuart.c ****                 {
1160:../drivers/fsl_lpuart.c ****                     /* Increase handle->rxRingBufferTail to make room for new data. */
1161:../drivers/fsl_lpuart.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
1162:../drivers/fsl_lpuart.c ****                     {
1163:../drivers/fsl_lpuart.c ****                         handle->rxRingBufferTail = 0U;
1164:../drivers/fsl_lpuart.c ****                     }
1165:../drivers/fsl_lpuart.c ****                     else
1166:../drivers/fsl_lpuart.c ****                     {
1167:../drivers/fsl_lpuart.c ****                         handle->rxRingBufferTail++;
1168:../drivers/fsl_lpuart.c ****                     }
1169:../drivers/fsl_lpuart.c ****                 }
1170:../drivers/fsl_lpuart.c **** 
1171:../drivers/fsl_lpuart.c **** /* Read data. */
1172:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
1173:../drivers/fsl_lpuart.c ****                 if (handle->isSevenDataBits)
1174:../drivers/fsl_lpuart.c ****                 {
1175:../drivers/fsl_lpuart.c ****                     handle->rxRingBuffer[handle->rxRingBufferHead] = (base->DATA & 0x7F);
1176:../drivers/fsl_lpuart.c ****                 }
1177:../drivers/fsl_lpuart.c ****                 else
1178:../drivers/fsl_lpuart.c ****                 {
1179:../drivers/fsl_lpuart.c ****                     handle->rxRingBuffer[handle->rxRingBufferHead] = base->DATA;
1180:../drivers/fsl_lpuart.c ****                 }
1181:../drivers/fsl_lpuart.c **** #else
1182:../drivers/fsl_lpuart.c ****                 handle->rxRingBuffer[handle->rxRingBufferHead] = base->DATA;
1183:../drivers/fsl_lpuart.c **** #endif
1184:../drivers/fsl_lpuart.c **** 
1185:../drivers/fsl_lpuart.c ****                 /* Increase handle->rxRingBufferHead. */
1186:../drivers/fsl_lpuart.c ****                 if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
1187:../drivers/fsl_lpuart.c ****                 {
1188:../drivers/fsl_lpuart.c ****                     handle->rxRingBufferHead = 0U;
1189:../drivers/fsl_lpuart.c ****                 }
1190:../drivers/fsl_lpuart.c ****                 else
1191:../drivers/fsl_lpuart.c ****                 {
1192:../drivers/fsl_lpuart.c ****                     handle->rxRingBufferHead++;
1193:../drivers/fsl_lpuart.c ****                 }
1194:../drivers/fsl_lpuart.c ****             }
1195:../drivers/fsl_lpuart.c ****         }
1196:../drivers/fsl_lpuart.c ****         /* If no receive requst pending, stop RX interrupt. */
1197:../drivers/fsl_lpuart.c ****         else if (!handle->rxDataSize)
1198:../drivers/fsl_lpuart.c ****         {
1199:../drivers/fsl_lpuart.c ****             LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrun
1200:../drivers/fsl_lpuart.c ****         }
1201:../drivers/fsl_lpuart.c ****         else
1202:../drivers/fsl_lpuart.c ****         {
1203:../drivers/fsl_lpuart.c ****         }
1204:../drivers/fsl_lpuart.c ****     }
1205:../drivers/fsl_lpuart.c **** 
1206:../drivers/fsl_lpuart.c ****     /* Send data register empty and the interrupt is enabled. */
1207:../drivers/fsl_lpuart.c ****     if ((base->STAT & LPUART_STAT_TDRE_MASK) && (base->CTRL & LPUART_CTRL_TIE_MASK))
 1080              		.loc 1 1207 0 is_stmt 1
 1081 0064 6B68     		ldr	r3, [r5, #4]
 1082 0066 1B02     		lsls	r3, r3, #8
 1083 0068 00D4     		bmi	.LCB1059
 1084 006a 94E0     		b	.L61	@long jump
 1085              	.LCB1059:
 1086              		.loc 1 1207 0 is_stmt 0 discriminator 1
 1087 006c AB68     		ldr	r3, [r5, #8]
 1088 006e 1B02     		lsls	r3, r3, #8
 1089 0070 00D4     		bmi	.LCB1064
 1090 0072 90E0     		b	.L61	@long jump
 1091              	.LCB1064:
1208:../drivers/fsl_lpuart.c ****     {
1209:../drivers/fsl_lpuart.c **** /* Get the bytes that available at this moment. */
1210:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
1211:../drivers/fsl_lpuart.c ****         count = FSL_FEATURE_LPUART_FIFO_SIZEn(base) -
1212:../drivers/fsl_lpuart.c ****                 ((base->WATER & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXCOUNT_SHIFT);
1213:../drivers/fsl_lpuart.c **** #else
1214:../drivers/fsl_lpuart.c ****         count = 1;
 1092              		.loc 1 1214 0 is_stmt 1
 1093 0074 0126     		movs	r6, #1
 1094              	.L79:
 1095              	.LVL129:
1215:../drivers/fsl_lpuart.c **** #endif
1216:../drivers/fsl_lpuart.c **** 
1217:../drivers/fsl_lpuart.c ****         while ((count) && (handle->txDataSize))
 1096              		.loc 1 1217 0
 1097 0076 002E     		cmp	r6, #0
 1098 0078 00D1     		bne	.LCB1070
 1099 007a 8CE0     		b	.L61	@long jump
 1100              	.LCB1070:
 1101              		.loc 1 1217 0 is_stmt 0 discriminator 1
 1102 007c 6368     		ldr	r3, [r4, #4]
 1103 007e 002B     		cmp	r3, #0
 1104 0080 00D1     		bne	.LCB1073
 1105 0082 88E0     		b	.L61	@long jump
 1106              	.LCB1073:
 1107              	.LVL130:
1218:../drivers/fsl_lpuart.c ****         {
1219:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
1220:../drivers/fsl_lpuart.c ****             tempCount = MIN(handle->txDataSize, count);
1221:../drivers/fsl_lpuart.c **** #else
1222:../drivers/fsl_lpuart.c ****             tempCount = 1;
1223:../drivers/fsl_lpuart.c **** #endif
1224:../drivers/fsl_lpuart.c **** 
1225:../drivers/fsl_lpuart.c ****             /* Using non block API to write the data to the registers. */
1226:../drivers/fsl_lpuart.c ****             LPUART_WriteNonBlocking(base, handle->txData, tempCount);
 1108              		.loc 1 1226 0 is_stmt 1
 1109 0084 2168     		ldr	r1, [r4]
 1110 0086 0122     		movs	r2, #1
 1111 0088 2800     		movs	r0, r5
 1112 008a FFF7FEFF 		bl	LPUART_WriteNonBlocking
 1113              	.LVL131:
1227:../drivers/fsl_lpuart.c ****             handle->txData += tempCount;
 1114              		.loc 1 1227 0
 1115 008e 2368     		ldr	r3, [r4]
 1116 0090 0133     		adds	r3, r3, #1
 1117 0092 2360     		str	r3, [r4]
1228:../drivers/fsl_lpuart.c ****             handle->txDataSize -= tempCount;
 1118              		.loc 1 1228 0
 1119 0094 6368     		ldr	r3, [r4, #4]
 1120 0096 013B     		subs	r3, r3, #1
 1121 0098 6360     		str	r3, [r4, #4]
1229:../drivers/fsl_lpuart.c ****             count -= tempCount;
 1122              		.loc 1 1229 0
 1123 009a 013E     		subs	r6, r6, #1
 1124              	.LVL132:
 1125 009c F6B2     		uxtb	r6, r6
 1126              	.LVL133:
1230:../drivers/fsl_lpuart.c **** 
1231:../drivers/fsl_lpuart.c ****             /* If all the data are written to data register, notify user with the callback, then TX
1232:../drivers/fsl_lpuart.c ****             if (!handle->txDataSize)
 1127              		.loc 1 1232 0
 1128 009e 6368     		ldr	r3, [r4, #4]
 1129 00a0 002B     		cmp	r3, #0
 1130 00a2 E8D1     		bne	.L79
1233:../drivers/fsl_lpuart.c ****             {
1234:../drivers/fsl_lpuart.c ****                 handle->txState = kLPUART_TxIdle;
 1131              		.loc 1 1234 0
 1132 00a4 2C33     		adds	r3, r3, #44
 1133 00a6 0022     		movs	r2, #0
 1134 00a8 E254     		strb	r2, [r4, r3]
1235:../drivers/fsl_lpuart.c **** 
1236:../drivers/fsl_lpuart.c ****                 /* Disable TX register empty interrupt. */
1237:../drivers/fsl_lpuart.c ****                 base->CTRL = (base->CTRL & ~LPUART_CTRL_TIE_MASK);
 1135              		.loc 1 1237 0
 1136 00aa AB68     		ldr	r3, [r5, #8]
 1137 00ac 3D4A     		ldr	r2, .L88+12
 1138 00ae 1340     		ands	r3, r2
 1139 00b0 AB60     		str	r3, [r5, #8]
1238:../drivers/fsl_lpuart.c **** 
1239:../drivers/fsl_lpuart.c ****                 /* Trigger callback. */
1240:../drivers/fsl_lpuart.c ****                 if (handle->callback)
 1140              		.loc 1 1240 0
 1141 00b2 676A     		ldr	r7, [r4, #36]
 1142 00b4 002F     		cmp	r7, #0
 1143 00b6 DED0     		beq	.L79
1241:../drivers/fsl_lpuart.c ****                 {
1242:../drivers/fsl_lpuart.c ****                     handle->callback(base, handle, kStatus_LPUART_TxIdle, handle->userData);
 1144              		.loc 1 1242 0
 1145 00b8 A36A     		ldr	r3, [r4, #40]
 1146 00ba 3B4A     		ldr	r2, .L88+16
 1147 00bc 2100     		movs	r1, r4
 1148 00be 2800     		movs	r0, r5
 1149 00c0 B847     		blx	r7
 1150              	.LVL134:
 1151 00c2 D8E7     		b	.L79
 1152              	.LVL135:
 1153              	.L85:
1098:../drivers/fsl_lpuart.c ****         }
 1154              		.loc 1 1098 0
 1155 00c4 8021     		movs	r1, #128
 1156 00c6 4903     		lsls	r1, r1, #13
 1157 00c8 2800     		movs	r0, r5
 1158 00ca FFF7FEFF 		bl	LPUART_DisableInterrupts
 1159              	.LVL136:
 1160 00ce B8E7     		b	.L64
 1161              	.L82:
1113:../drivers/fsl_lpuart.c **** #endif
 1162              		.loc 1 1113 0
 1163 00d0 0126     		movs	r6, #1
 1164              	.L66:
 1165              	.LVL137:
1117:../drivers/fsl_lpuart.c ****         {
 1166              		.loc 1 1117 0
 1167 00d2 002E     		cmp	r6, #0
 1168 00d4 1ED0     		beq	.L68
1117:../drivers/fsl_lpuart.c ****         {
 1169              		.loc 1 1117 0 is_stmt 0 discriminator 1
 1170 00d6 2369     		ldr	r3, [r4, #16]
 1171 00d8 002B     		cmp	r3, #0
 1172 00da 1BD0     		beq	.L68
 1173              	.LVL138:
1126:../drivers/fsl_lpuart.c ****             handle->rxData += tempCount;
 1174              		.loc 1 1126 0 is_stmt 1
 1175 00dc E168     		ldr	r1, [r4, #12]
 1176 00de 0122     		movs	r2, #1
 1177 00e0 2800     		movs	r0, r5
 1178 00e2 FFF7FEFF 		bl	LPUART_ReadNonBlocking
 1179              	.LVL139:
1127:../drivers/fsl_lpuart.c ****             handle->rxDataSize -= tempCount;
 1180              		.loc 1 1127 0
 1181 00e6 E368     		ldr	r3, [r4, #12]
 1182 00e8 0133     		adds	r3, r3, #1
 1183 00ea E360     		str	r3, [r4, #12]
1128:../drivers/fsl_lpuart.c ****             count -= tempCount;
 1184              		.loc 1 1128 0
 1185 00ec 2369     		ldr	r3, [r4, #16]
 1186 00ee 013B     		subs	r3, r3, #1
 1187 00f0 2361     		str	r3, [r4, #16]
1129:../drivers/fsl_lpuart.c **** 
 1188              		.loc 1 1129 0
 1189 00f2 013E     		subs	r6, r6, #1
 1190              	.LVL140:
 1191 00f4 F6B2     		uxtb	r6, r6
 1192              	.LVL141:
1132:../drivers/fsl_lpuart.c ****             {
 1193              		.loc 1 1132 0
 1194 00f6 2369     		ldr	r3, [r4, #16]
 1195 00f8 002B     		cmp	r3, #0
 1196 00fa EAD1     		bne	.L66
1134:../drivers/fsl_lpuart.c **** 
 1197              		.loc 1 1134 0
 1198 00fc 2D33     		adds	r3, r3, #45
 1199 00fe 0222     		movs	r2, #2
 1200 0100 E254     		strb	r2, [r4, r3]
1136:../drivers/fsl_lpuart.c ****                 {
 1201              		.loc 1 1136 0
 1202 0102 676A     		ldr	r7, [r4, #36]
 1203 0104 002F     		cmp	r7, #0
 1204 0106 E4D0     		beq	.L66
1138:../drivers/fsl_lpuart.c ****                 }
 1205              		.loc 1 1138 0
 1206 0108 A36A     		ldr	r3, [r4, #40]
 1207 010a 284A     		ldr	r2, .L88+20
 1208 010c 2100     		movs	r1, r4
 1209 010e 2800     		movs	r0, r5
 1210 0110 B847     		blx	r7
 1211              	.LVL142:
 1212 0112 DEE7     		b	.L66
 1213              	.LVL143:
 1214              	.L68:
1144:../drivers/fsl_lpuart.c ****         {
 1215              		.loc 1 1144 0
 1216 0114 A369     		ldr	r3, [r4, #24]
 1217 0116 002B     		cmp	r3, #0
 1218 0118 18D1     		bne	.L70
1197:../drivers/fsl_lpuart.c ****         {
 1219              		.loc 1 1197 0
 1220 011a 2369     		ldr	r3, [r4, #16]
 1221 011c 002B     		cmp	r3, #0
 1222 011e A1D1     		bne	.L65
1199:../drivers/fsl_lpuart.c ****         }
 1223              		.loc 1 1199 0
 1224 0120 8221     		movs	r1, #130
 1225 0122 0905     		lsls	r1, r1, #20
 1226 0124 2800     		movs	r0, r5
 1227 0126 FFF7FEFF 		bl	LPUART_DisableInterrupts
 1228              	.LVL144:
 1229 012a 9BE7     		b	.L65
 1230              	.LVL145:
 1231              	.L87:
1163:../drivers/fsl_lpuart.c ****                     }
 1232              		.loc 1 1163 0
 1233 012c 0023     		movs	r3, #0
 1234 012e 6384     		strh	r3, [r4, #34]
 1235              	.L73:
1182:../drivers/fsl_lpuart.c **** #endif
 1236              		.loc 1 1182 0
 1237 0130 EA68     		ldr	r2, [r5, #12]
 1238 0132 238C     		ldrh	r3, [r4, #32]
 1239 0134 A169     		ldr	r1, [r4, #24]
 1240 0136 CA54     		strb	r2, [r1, r3]
1186:../drivers/fsl_lpuart.c ****                 {
 1241              		.loc 1 1186 0
 1242 0138 238C     		ldrh	r3, [r4, #32]
 1243 013a 0133     		adds	r3, r3, #1
 1244 013c E269     		ldr	r2, [r4, #28]
 1245 013e 9342     		cmp	r3, r2
 1246 0140 26D0     		beq	.L86
1192:../drivers/fsl_lpuart.c ****                 }
 1247              		.loc 1 1192 0
 1248 0142 238C     		ldrh	r3, [r4, #32]
 1249 0144 0133     		adds	r3, r3, #1
 1250 0146 9BB2     		uxth	r3, r3
 1251 0148 2384     		strh	r3, [r4, #32]
 1252              	.L76:
1113:../drivers/fsl_lpuart.c **** #endif
 1253              		.loc 1 1113 0
 1254 014a 3E00     		movs	r6, r7
 1255              	.LVL146:
 1256              	.L70:
1146:../drivers/fsl_lpuart.c ****             {
 1257              		.loc 1 1146 0
 1258 014c 771E     		subs	r7, r6, #1
 1259 014e FFB2     		uxtb	r7, r7
 1260              	.LVL147:
 1261 0150 002E     		cmp	r6, #0
 1262 0152 87D0     		beq	.L65
1149:../drivers/fsl_lpuart.c ****                 {
 1263              		.loc 1 1149 0
 1264 0154 2100     		movs	r1, r4
 1265 0156 2800     		movs	r0, r5
 1266 0158 FFF7FEFF 		bl	LPUART_TransferIsRxRingBufferFull
 1267              	.LVL148:
 1268 015c 0028     		cmp	r0, #0
 1269 015e 07D0     		beq	.L72
1151:../drivers/fsl_lpuart.c ****                     {
 1270              		.loc 1 1151 0
 1271 0160 666A     		ldr	r6, [r4, #36]
 1272 0162 002E     		cmp	r6, #0
 1273 0164 04D0     		beq	.L72
1153:../drivers/fsl_lpuart.c ****                     }
 1274              		.loc 1 1153 0
 1275 0166 A36A     		ldr	r3, [r4, #40]
 1276 0168 114A     		ldr	r2, .L88+24
 1277 016a 2100     		movs	r1, r4
 1278 016c 2800     		movs	r0, r5
 1279 016e B047     		blx	r6
 1280              	.LVL149:
 1281              	.L72:
1158:../drivers/fsl_lpuart.c ****                 {
 1282              		.loc 1 1158 0
 1283 0170 2100     		movs	r1, r4
 1284 0172 2800     		movs	r0, r5
 1285 0174 FFF7FEFF 		bl	LPUART_TransferIsRxRingBufferFull
 1286              	.LVL150:
 1287 0178 0028     		cmp	r0, #0
 1288 017a D9D0     		beq	.L73
1161:../drivers/fsl_lpuart.c ****                     {
 1289              		.loc 1 1161 0
 1290 017c 638C     		ldrh	r3, [r4, #34]
 1291 017e 0133     		adds	r3, r3, #1
 1292 0180 E269     		ldr	r2, [r4, #28]
 1293 0182 9342     		cmp	r3, r2
 1294 0184 D2D0     		beq	.L87
1167:../drivers/fsl_lpuart.c ****                     }
 1295              		.loc 1 1167 0
 1296 0186 638C     		ldrh	r3, [r4, #34]
 1297 0188 0133     		adds	r3, r3, #1
 1298 018a 9BB2     		uxth	r3, r3
 1299 018c 6384     		strh	r3, [r4, #34]
 1300 018e CFE7     		b	.L73
 1301              	.L86:
1188:../drivers/fsl_lpuart.c ****                 }
 1302              		.loc 1 1188 0
 1303 0190 0023     		movs	r3, #0
 1304 0192 2384     		strh	r3, [r4, #32]
 1305 0194 D9E7     		b	.L76
 1306              	.LVL151:
 1307              	.L61:
1243:../drivers/fsl_lpuart.c ****                 }
1244:../drivers/fsl_lpuart.c ****             }
1245:../drivers/fsl_lpuart.c ****         }
1246:../drivers/fsl_lpuart.c ****     }
1247:../drivers/fsl_lpuart.c **** }
 1308              		.loc 1 1247 0
 1309              		@ sp needed
 1310              	.LVL152:
 1311              	.LVL153:
 1312 0196 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1313              	.L89:
 1314              		.align	2
 1315              	.L88:
 1316 0198 0000E03F 		.word	1071644672
 1317 019c 1D050000 		.word	1309
 1318 01a0 22050000 		.word	1314
 1319 01a4 FFFF7FFF 		.word	-8388609
 1320 01a8 16050000 		.word	1302
 1321 01ac 17050000 		.word	1303
 1322 01b0 1C050000 		.word	1308
 1323              		.cfi_endproc
 1324              	.LFE85:
 1326              		.section	.text.LPUART_GetEnabledInterrupts,"ax",%progbits
 1327              		.align	1
 1328              		.global	LPUART_GetEnabledInterrupts
 1329              		.syntax unified
 1330              		.code	16
 1331              		.thumb_func
 1332              		.fpu softvfp
 1334              	LPUART_GetEnabledInterrupts:
 1335              	.LFB71:
 618:../drivers/fsl_lpuart.c ****     uint32_t temp;
 1336              		.loc 1 618 0
 1337              		.cfi_startproc
 1338              		@ args = 0, pretend = 0, frame = 0
 1339              		@ frame_needed = 0, uses_anonymous_args = 0
 1340              		@ link register save eliminated.
 1341              	.LVL154:
 620:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 1342              		.loc 1 620 0
 1343 0000 0268     		ldr	r2, [r0]
 1344 0002 120A     		lsrs	r2, r2, #8
 1345 0004 C023     		movs	r3, #192
 1346 0006 1340     		ands	r3, r2
 1347              	.LVL155:
 624:../drivers/fsl_lpuart.c **** 
 1348              		.loc 1 624 0
 1349 0008 8068     		ldr	r0, [r0, #8]
 1350              	.LVL156:
 1351 000a 024A     		ldr	r2, .L91
 1352 000c 1040     		ands	r0, r2
 1353 000e 1843     		orrs	r0, r3
 1354              	.LVL157:
 627:../drivers/fsl_lpuart.c **** 
 1355              		.loc 1 627 0
 1356              		@ sp needed
 1357 0010 7047     		bx	lr
 1358              	.L92:
 1359 0012 C046     		.align	2
 1360              	.L91:
 1361 0014 00C0F00F 		.word	267436032
 1362              		.cfi_endproc
 1363              	.LFE71:
 1365              		.section	.text.LPUART_GetStatusFlags,"ax",%progbits
 1366              		.align	1
 1367              		.global	LPUART_GetStatusFlags
 1368              		.syntax unified
 1369              		.code	16
 1370              		.thumb_func
 1371              		.fpu softvfp
 1373              	LPUART_GetStatusFlags:
 1374              	.LFB72:
 630:../drivers/fsl_lpuart.c ****     uint32_t temp;
 1375              		.loc 1 630 0
 1376              		.cfi_startproc
 1377              		@ args = 0, pretend = 0, frame = 0
 1378              		@ frame_needed = 0, uses_anonymous_args = 0
 1379              		@ link register save eliminated.
 1380              	.LVL158:
 632:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 1381              		.loc 1 632 0
 1382 0000 4068     		ldr	r0, [r0, #4]
 1383              	.LVL159:
 639:../drivers/fsl_lpuart.c **** 
 1384              		.loc 1 639 0
 1385              		@ sp needed
 1386 0002 7047     		bx	lr
 1387              		.cfi_endproc
 1388              	.LFE72:
 1390              		.section	.text.LPUART_ClearStatusFlags,"ax",%progbits
 1391              		.align	1
 1392              		.global	LPUART_ClearStatusFlags
 1393              		.syntax unified
 1394              		.code	16
 1395              		.thumb_func
 1396              		.fpu softvfp
 1398              	LPUART_ClearStatusFlags:
 1399              	.LFB73:
 642:../drivers/fsl_lpuart.c ****     uint32_t temp;
 1400              		.loc 1 642 0
 1401              		.cfi_startproc
 1402              		@ args = 0, pretend = 0, frame = 0
 1403              		@ frame_needed = 0, uses_anonymous_args = 0
 1404              	.LVL160:
 1405 0000 10B5     		push	{r4, lr}
 1406              		.cfi_def_cfa_offset 8
 1407              		.cfi_offset 4, -8
 1408              		.cfi_offset 14, -4
 1409 0002 0C00     		movs	r4, r1
 651:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
 1410              		.loc 1 651 0
 1411 0004 4268     		ldr	r2, [r0, #4]
 1412              	.LVL161:
 653:../drivers/fsl_lpuart.c ****     temp |= mask & LPUART_STAT_LBKDIF_MASK;
 1413              		.loc 1 653 0
 1414 0006 5200     		lsls	r2, r2, #1
 1415              	.LVL162:
 1416 0008 5208     		lsrs	r2, r2, #1
 1417              	.LVL163:
 654:../drivers/fsl_lpuart.c **** #endif
 1418              		.loc 1 654 0
 1419 000a CB0F     		lsrs	r3, r1, #31
 1420 000c DB07     		lsls	r3, r3, #31
 1421 000e 1343     		orrs	r3, r2
 1422              	.LVL164:
 656:../drivers/fsl_lpuart.c ****                          LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK));
 1423              		.loc 1 656 0
 1424 0010 094A     		ldr	r2, .L98
 1425 0012 1A40     		ands	r2, r3
 1426              	.LVL165:
 658:../drivers/fsl_lpuart.c ****                     LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
 1427              		.loc 1 658 0
 1428 0014 094B     		ldr	r3, .L98+4
 1429 0016 0B40     		ands	r3, r1
 1430 0018 1343     		orrs	r3, r2
 1431              	.LVL166:
 661:../drivers/fsl_lpuart.c ****     temp |= mask & (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK);
 1432              		.loc 1 661 0
 1433 001a 094A     		ldr	r2, .L98+8
 1434 001c 1340     		ands	r3, r2
 1435              	.LVL167:
 662:../drivers/fsl_lpuart.c **** #endif
 1436              		.loc 1 662 0
 1437 001e C022     		movs	r2, #192
 1438 0020 1202     		lsls	r2, r2, #8
 1439 0022 0A40     		ands	r2, r1
 1440 0024 1343     		orrs	r3, r2
 1441              	.LVL168:
 664:../drivers/fsl_lpuart.c ****     /* If some flags still pending. */
 1442              		.loc 1 664 0
 1443 0026 4360     		str	r3, [r0, #4]
 666:../drivers/fsl_lpuart.c ****     {
 1444              		.loc 1 666 0
 1445 0028 FFF7FEFF 		bl	LPUART_GetStatusFlags
 1446              	.LVL169:
 1447 002c 0442     		tst	r4, r0
 1448 002e 01D1     		bne	.L97
 676:../drivers/fsl_lpuart.c ****     }
 1449              		.loc 1 676 0
 1450 0030 0020     		movs	r0, #0
 1451              	.LVL170:
 1452              	.L94:
 680:../drivers/fsl_lpuart.c **** 
 1453              		.loc 1 680 0
 1454              		@ sp needed
 1455              	.LVL171:
 1456 0032 10BD     		pop	{r4, pc}
 1457              	.LVL172:
 1458              	.L97:
 672:../drivers/fsl_lpuart.c ****     }
 1459              		.loc 1 672 0
 1460 0034 0348     		ldr	r0, .L98+12
 1461 0036 FCE7     		b	.L94
 1462              	.L99:
 1463              		.align	2
 1464              	.L98:
 1465 0038 FFFFE0BF 		.word	-1075773441
 1466 003c 00001F40 		.word	1075773440
 1467 0040 FF3FFFFF 		.word	-49153
 1468 0044 1A050000 		.word	1306
 1469              		.cfi_endproc
 1470              	.LFE73:
 1472              		.section	.text.LPUART_WriteBlocking,"ax",%progbits
 1473              		.align	1
 1474              		.global	LPUART_WriteBlocking
 1475              		.syntax unified
 1476              		.code	16
 1477              		.thumb_func
 1478              		.fpu softvfp
 1480              	LPUART_WriteBlocking:
 1481              	.LFB74:
 683:../drivers/fsl_lpuart.c ****     assert(data);
 1482              		.loc 1 683 0
 1483              		.cfi_startproc
 1484              		@ args = 0, pretend = 0, frame = 0
 1485              		@ frame_needed = 0, uses_anonymous_args = 0
 1486              	.LVL173:
 1487 0000 10B5     		push	{r4, lr}
 1488              		.cfi_def_cfa_offset 8
 1489              		.cfi_offset 4, -8
 1490              		.cfi_offset 14, -4
 688:../drivers/fsl_lpuart.c ****     {
 1491              		.loc 1 688 0
 1492 0002 06E0     		b	.L101
 1493              	.LVL174:
 1494              	.L102:
 690:../drivers/fsl_lpuart.c ****         {
 1495              		.loc 1 690 0 discriminator 1
 1496 0004 4368     		ldr	r3, [r0, #4]
 1497 0006 1B02     		lsls	r3, r3, #8
 1498 0008 FCD5     		bpl	.L102
 1499              	.LVL175:
 693:../drivers/fsl_lpuart.c ****     }
 1500              		.loc 1 693 0
 1501 000a 0B78     		ldrb	r3, [r1]
 1502 000c C360     		str	r3, [r0, #12]
 688:../drivers/fsl_lpuart.c ****     {
 1503              		.loc 1 688 0
 1504 000e 2200     		movs	r2, r4
 693:../drivers/fsl_lpuart.c ****     }
 1505              		.loc 1 693 0
 1506 0010 0131     		adds	r1, r1, #1
 1507              	.LVL176:
 1508              	.L101:
 688:../drivers/fsl_lpuart.c ****     {
 1509              		.loc 1 688 0
 1510 0012 541E     		subs	r4, r2, #1
 1511              	.LVL177:
 1512 0014 002A     		cmp	r2, #0
 1513 0016 F5D1     		bne	.L102
 695:../drivers/fsl_lpuart.c **** 
 1514              		.loc 1 695 0
 1515              		@ sp needed
 1516              	.LVL178:
 1517 0018 10BD     		pop	{r4, pc}
 1518              		.cfi_endproc
 1519              	.LFE74:
 1521              		.section	.text.LPUART_ReadBlocking,"ax",%progbits
 1522              		.align	1
 1523              		.global	LPUART_ReadBlocking
 1524              		.syntax unified
 1525              		.code	16
 1526              		.thumb_func
 1527              		.fpu softvfp
 1529              	LPUART_ReadBlocking:
 1530              	.LFB75:
 698:../drivers/fsl_lpuart.c ****     assert(data);
 1531              		.loc 1 698 0
 1532              		.cfi_startproc
 1533              		@ args = 0, pretend = 0, frame = 0
 1534              		@ frame_needed = 0, uses_anonymous_args = 0
 1535              	.LVL179:
 1536 0000 70B5     		push	{r4, r5, r6, lr}
 1537              		.cfi_def_cfa_offset 16
 1538              		.cfi_offset 4, -16
 1539              		.cfi_offset 5, -12
 1540              		.cfi_offset 6, -8
 1541              		.cfi_offset 14, -4
 1542 0002 0400     		movs	r4, r0
 1543 0004 0D00     		movs	r5, r1
 1544              	.LVL180:
 1545              	.L104:
 709:../drivers/fsl_lpuart.c ****     {
 1546              		.loc 1 709 0
 1547 0006 561E     		subs	r6, r2, #1
 1548              	.LVL181:
 1549 0008 002A     		cmp	r2, #0
 1550 000a 2FD0     		beq	.L111
 1551              	.L109:
 714:../drivers/fsl_lpuart.c **** #endif
 1552              		.loc 1 714 0
 1553 000c 6368     		ldr	r3, [r4, #4]
 1554 000e 9B02     		lsls	r3, r3, #10
 1555 0010 27D4     		bmi	.L112
 717:../drivers/fsl_lpuart.c **** 
 1556              		.loc 1 717 0
 1557 0012 2000     		movs	r0, r4
 1558 0014 FFF7FEFF 		bl	LPUART_GetStatusFlags
 1559              	.LVL182:
 719:../drivers/fsl_lpuart.c ****             {
 1560              		.loc 1 719 0
 1561 0018 0303     		lsls	r3, r0, #12
 1562 001a 0DD4     		bmi	.L113
 725:../drivers/fsl_lpuart.c ****             {
 1563              		.loc 1 725 0
 1564 001c 4303     		lsls	r3, r0, #13
 1565 001e 12D4     		bmi	.L114
 731:../drivers/fsl_lpuart.c ****             {
 1566              		.loc 1 731 0
 1567 0020 8303     		lsls	r3, r0, #14
 1568 0022 17D4     		bmi	.L115
 737:../drivers/fsl_lpuart.c ****             {
 1569              		.loc 1 737 0
 1570 0024 C303     		lsls	r3, r0, #15
 1571 0026 F1D5     		bpl	.L109
 739:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_ParityError;
 1572              		.loc 1 739 0
 1573 0028 8021     		movs	r1, #128
 1574 002a 4902     		lsls	r1, r1, #9
 1575 002c 2000     		movs	r0, r4
 1576              	.LVL183:
 1577 002e FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1578              	.LVL184:
 740:../drivers/fsl_lpuart.c ****             }
 1579              		.loc 1 740 0
 1580 0032 A420     		movs	r0, #164
 1581 0034 C000     		lsls	r0, r0, #3
 1582 0036 05E0     		b	.L103
 1583              	.LVL185:
 1584              	.L113:
 721:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_RxHardwareOverrun;
 1585              		.loc 1 721 0
 1586 0038 8021     		movs	r1, #128
 1587 003a 0903     		lsls	r1, r1, #12
 1588 003c 2000     		movs	r0, r4
 1589              	.LVL186:
 1590 003e FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1591              	.LVL187:
 722:../drivers/fsl_lpuart.c ****             }
 1592              		.loc 1 722 0
 1593 0042 0B48     		ldr	r0, .L116
 1594              	.L103:
 758:../drivers/fsl_lpuart.c **** 
 1595              		.loc 1 758 0
 1596              		@ sp needed
 1597              	.LVL188:
 1598              	.LVL189:
 1599              	.LVL190:
 1600 0044 70BD     		pop	{r4, r5, r6, pc}
 1601              	.LVL191:
 1602              	.L114:
 727:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_NoiseError;
 1603              		.loc 1 727 0
 1604 0046 8021     		movs	r1, #128
 1605 0048 C902     		lsls	r1, r1, #11
 1606 004a 2000     		movs	r0, r4
 1607              	.LVL192:
 1608 004c FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1609              	.LVL193:
 728:../drivers/fsl_lpuart.c ****             }
 1610              		.loc 1 728 0
 1611 0050 0848     		ldr	r0, .L116+4
 1612 0052 F7E7     		b	.L103
 1613              	.LVL194:
 1614              	.L115:
 733:../drivers/fsl_lpuart.c ****                 return kStatus_LPUART_FramingError;
 1615              		.loc 1 733 0
 1616 0054 8021     		movs	r1, #128
 1617 0056 8902     		lsls	r1, r1, #10
 1618 0058 2000     		movs	r0, r4
 1619              	.LVL195:
 1620 005a FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1621              	.LVL196:
 734:../drivers/fsl_lpuart.c ****             }
 1622              		.loc 1 734 0
 1623 005e 0648     		ldr	r0, .L116+8
 1624 0060 F0E7     		b	.L103
 1625              	.L112:
 753:../drivers/fsl_lpuart.c **** #endif
 1626              		.loc 1 753 0
 1627 0062 E368     		ldr	r3, [r4, #12]
 1628              	.LVL197:
 1629 0064 2B70     		strb	r3, [r5]
 709:../drivers/fsl_lpuart.c ****     {
 1630              		.loc 1 709 0
 1631 0066 3200     		movs	r2, r6
 753:../drivers/fsl_lpuart.c **** #endif
 1632              		.loc 1 753 0
 1633 0068 0135     		adds	r5, r5, #1
 1634              	.LVL198:
 1635 006a CCE7     		b	.L104
 1636              	.L111:
 757:../drivers/fsl_lpuart.c **** }
 1637              		.loc 1 757 0
 1638 006c 0020     		movs	r0, #0
 1639 006e E9E7     		b	.L103
 1640              	.L117:
 1641              		.align	2
 1642              	.L116:
 1643 0070 1D050000 		.word	1309
 1644 0074 1E050000 		.word	1310
 1645 0078 1F050000 		.word	1311
 1646              		.cfi_endproc
 1647              	.LFE75:
 1649              		.section	.text.LPUART_TransferCreateHandle,"ax",%progbits
 1650              		.align	1
 1651              		.global	LPUART_TransferCreateHandle
 1652              		.syntax unified
 1653              		.code	16
 1654              		.thumb_func
 1655              		.fpu softvfp
 1657              	LPUART_TransferCreateHandle:
 1658              	.LFB76:
 764:../drivers/fsl_lpuart.c ****     assert(handle);
 1659              		.loc 1 764 0
 1660              		.cfi_startproc
 1661              		@ args = 0, pretend = 0, frame = 0
 1662              		@ frame_needed = 0, uses_anonymous_args = 0
 1663              	.LVL199:
 1664 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1665              		.cfi_def_cfa_offset 24
 1666              		.cfi_offset 3, -24
 1667              		.cfi_offset 4, -20
 1668              		.cfi_offset 5, -16
 1669              		.cfi_offset 6, -12
 1670              		.cfi_offset 7, -8
 1671              		.cfi_offset 14, -4
 1672 0002 0500     		movs	r5, r0
 1673 0004 0C00     		movs	r4, r1
 1674 0006 1700     		movs	r7, r2
 1675 0008 1E00     		movs	r6, r3
 776:../drivers/fsl_lpuart.c **** 
 1676              		.loc 1 776 0
 1677 000a 3022     		movs	r2, #48
 1678              	.LVL200:
 1679 000c 0021     		movs	r1, #0
 1680              	.LVL201:
 1681 000e 2000     		movs	r0, r4
 1682              	.LVL202:
 1683 0010 FFF7FEFF 		bl	memset
 1684              	.LVL203:
 779:../drivers/fsl_lpuart.c ****     handle->txState = kLPUART_TxIdle;
 1685              		.loc 1 779 0
 1686 0014 2D23     		movs	r3, #45
 1687 0016 0222     		movs	r2, #2
 1688 0018 E254     		strb	r2, [r4, r3]
 780:../drivers/fsl_lpuart.c **** 
 1689              		.loc 1 780 0
 1690 001a 013B     		subs	r3, r3, #1
 1691 001c 0022     		movs	r2, #0
 1692 001e E254     		strb	r2, [r4, r3]
 783:../drivers/fsl_lpuart.c ****     handle->userData = userData;
 1693              		.loc 1 783 0
 1694 0020 6762     		str	r7, [r4, #36]
 784:../drivers/fsl_lpuart.c **** 
 1695              		.loc 1 784 0
 1696 0022 A662     		str	r6, [r4, #40]
 792:../drivers/fsl_lpuart.c **** 
 1697              		.loc 1 792 0
 1698 0024 2800     		movs	r0, r5
 1699 0026 FFF7FEFF 		bl	LPUART_GetInstance
 1700              	.LVL204:
 795:../drivers/fsl_lpuart.c **** 
 1701              		.loc 1 795 0
 1702 002a 8200     		lsls	r2, r0, #2
 1703 002c 094B     		ldr	r3, .L120
 1704 002e D450     		str	r4, [r2, r3]
 797:../drivers/fsl_lpuart.c **** 
 1705              		.loc 1 797 0
 1706 0030 094B     		ldr	r3, .L120+4
 1707 0032 0A4A     		ldr	r2, .L120+8
 1708 0034 1A60     		str	r2, [r3]
 804:../drivers/fsl_lpuart.c **** #endif
 1709              		.loc 1 804 0
 1710 0036 0A4B     		ldr	r3, .L120+12
 1711 0038 1B56     		ldrsb	r3, [r3, r0]
 1712              	.LVL205:
 1713              	.LBB16:
 1714              	.LBB17:
 1715              		.file 3 "../drivers/fsl_common.h"
   1:../drivers/fsl_common.h **** /*
   2:../drivers/fsl_common.h ****  * The Clear BSD License
   3:../drivers/fsl_common.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_common.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_common.h ****  * All rights reserved.
   6:../drivers/fsl_common.h ****  *
   7:../drivers/fsl_common.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_common.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_common.h ****  * that the following conditions are met:
  10:../drivers/fsl_common.h ****  *
  11:../drivers/fsl_common.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_common.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_common.h ****  *
  14:../drivers/fsl_common.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_common.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_common.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_common.h ****  *
  18:../drivers/fsl_common.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_common.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_common.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_common.h ****  *
  22:../drivers/fsl_common.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_common.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_common.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_common.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_common.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_common.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_common.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_common.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_common.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_common.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_common.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_common.h ****  */
  34:../drivers/fsl_common.h **** 
  35:../drivers/fsl_common.h **** #ifndef _FSL_COMMON_H_
  36:../drivers/fsl_common.h **** #define _FSL_COMMON_H_
  37:../drivers/fsl_common.h **** 
  38:../drivers/fsl_common.h **** #include <assert.h>
  39:../drivers/fsl_common.h **** #include <stdbool.h>
  40:../drivers/fsl_common.h **** #include <stdint.h>
  41:../drivers/fsl_common.h **** #include <string.h>
  42:../drivers/fsl_common.h **** 
  43:../drivers/fsl_common.h **** #if defined(__ICCARM__)
  44:../drivers/fsl_common.h **** #include <stddef.h>
  45:../drivers/fsl_common.h **** #endif
  46:../drivers/fsl_common.h **** 
  47:../drivers/fsl_common.h **** #include "fsl_device_registers.h"
  48:../drivers/fsl_common.h **** 
  49:../drivers/fsl_common.h **** /*!
  50:../drivers/fsl_common.h ****  * @addtogroup ksdk_common
  51:../drivers/fsl_common.h ****  * @{
  52:../drivers/fsl_common.h ****  */
  53:../drivers/fsl_common.h **** 
  54:../drivers/fsl_common.h **** /*******************************************************************************
  55:../drivers/fsl_common.h ****  * Definitions
  56:../drivers/fsl_common.h ****  ******************************************************************************/
  57:../drivers/fsl_common.h **** 
  58:../drivers/fsl_common.h **** /*! @brief Construct a status code value from a group and code number. */
  59:../drivers/fsl_common.h **** #define MAKE_STATUS(group, code) ((((group)*100) + (code)))
  60:../drivers/fsl_common.h **** 
  61:../drivers/fsl_common.h **** /*! @brief Construct the version number for drivers. */
  62:../drivers/fsl_common.h **** #define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
  63:../drivers/fsl_common.h **** 
  64:../drivers/fsl_common.h **** /*! @name Driver version */
  65:../drivers/fsl_common.h **** /*@{*/
  66:../drivers/fsl_common.h **** /*! @brief common driver version 2.0.0. */
  67:../drivers/fsl_common.h **** #define FSL_COMMON_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
  68:../drivers/fsl_common.h **** /*@}*/
  69:../drivers/fsl_common.h **** 
  70:../drivers/fsl_common.h **** /* Debug console type definition. */
  71:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
  72:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
  73:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
  74:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
  75:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
  76:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
  77:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_IUART 6U    /*!< Debug console base on i.MX UART. */
  78:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_VUSART 7U   /*!< Debug console base on LPC_USART. */
  79:../drivers/fsl_common.h **** 
  80:../drivers/fsl_common.h **** /*! @brief Status group numbers. */
  81:../drivers/fsl_common.h **** enum _status_groups
  82:../drivers/fsl_common.h **** {
  83:../drivers/fsl_common.h ****     kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
  84:../drivers/fsl_common.h ****     kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
  85:../drivers/fsl_common.h ****     kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
  86:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
  87:../drivers/fsl_common.h ****     kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
  88:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
  89:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
  90:../drivers/fsl_common.h ****     kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
  91:../drivers/fsl_common.h ****     kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
  92:../drivers/fsl_common.h ****     kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
  93:../drivers/fsl_common.h ****     kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
  94:../drivers/fsl_common.h ****     kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
  95:../drivers/fsl_common.h ****     kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
  96:../drivers/fsl_common.h ****     kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
  97:../drivers/fsl_common.h ****     kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
  98:../drivers/fsl_common.h ****     kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
  99:../drivers/fsl_common.h ****     kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
 100:../drivers/fsl_common.h ****     kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
 101:../drivers/fsl_common.h ****     kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
 102:../drivers/fsl_common.h ****     kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
 103:../drivers/fsl_common.h ****     kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
 104:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
 105:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_MCULCD = 24,          /*!< Group number for FLEXIO LCD status codes */
 106:../drivers/fsl_common.h ****     kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
 107:../drivers/fsl_common.h ****     kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
 108:../drivers/fsl_common.h ****     kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
 109:../drivers/fsl_common.h ****     kStatusGroup_IUART = 28,                  /*!< Group number for IUART status codes */
 110:../drivers/fsl_common.h ****     kStatusGroup_CSI = 29,                    /*!< Group number for CSI status codes */
 111:../drivers/fsl_common.h ****     kStatusGroup_MIPI_DSI = 30,               /*!< Group number for MIPI DSI status codes */
 112:../drivers/fsl_common.h ****     kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
 113:../drivers/fsl_common.h ****     kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
 114:../drivers/fsl_common.h ****     kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
 115:../drivers/fsl_common.h ****     kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
 116:../drivers/fsl_common.h ****     kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
 117:../drivers/fsl_common.h ****     kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
 118:../drivers/fsl_common.h ****     kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
 119:../drivers/fsl_common.h ****     kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
 120:../drivers/fsl_common.h ****     kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
 121:../drivers/fsl_common.h ****     kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
 122:../drivers/fsl_common.h ****     kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
 123:../drivers/fsl_common.h ****     kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
 124:../drivers/fsl_common.h ****     kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
 125:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
 126:../drivers/fsl_common.h ****     kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
 127:../drivers/fsl_common.h ****     kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
 128:../drivers/fsl_common.h ****     kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
 129:../drivers/fsl_common.h ****     kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
 130:../drivers/fsl_common.h ****     kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
 131:../drivers/fsl_common.h ****     kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
 132:../drivers/fsl_common.h ****     kStatusGroup_MCAN = 62,                   /*!< Group number for MCAN status codes. */
 133:../drivers/fsl_common.h ****     kStatusGroup_CAAM = 63,                   /*!< Group number for CAAM status codes. */
 134:../drivers/fsl_common.h ****     kStatusGroup_ECSPI = 64,                  /*!< Group number for ECSPI status codes. */
 135:../drivers/fsl_common.h ****     kStatusGroup_USDHC = 65,                  /*!< Group number for USDHC status codes.*/
 136:../drivers/fsl_common.h ****     kStatusGroup_LPC_I2C = 66,                /*!< Group number for LPC_I2C status codes.*/
 137:../drivers/fsl_common.h ****     kStatusGroup_DCP = 67,                    /*!< Group number for DCP status codes.*/
 138:../drivers/fsl_common.h ****     kStatusGroup_MSCAN = 68,                  /*!< Group number for MSCAN status codes.*/
 139:../drivers/fsl_common.h ****     kStatusGroup_ESAI = 69,                   /*!< Group number for ESAI status codes. */
 140:../drivers/fsl_common.h ****     kStatusGroup_FLEXSPI = 70,                /*!< Group number for FLEXSPI status codes. */
 141:../drivers/fsl_common.h ****     kStatusGroup_MMDC = 71,                   /*!< Group number for MMDC status codes. */
 142:../drivers/fsl_common.h ****     kStatusGroup_MICFIL = 72,                 /*!< Group number for MIC status codes. */
 143:../drivers/fsl_common.h ****     kStatusGroup_SDMA = 73,                   /*!< Group number for SDMA status codes. */
 144:../drivers/fsl_common.h ****     kStatusGroup_ICS = 74,                    /*!< Group number for ICS status codes. */
 145:../drivers/fsl_common.h ****     kStatusGroup_SPDIF = 75,                  /*!< Group number for SPDIF status codes. */
 146:../drivers/fsl_common.h ****     kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
 147:../drivers/fsl_common.h ****     kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
 148:../drivers/fsl_common.h ****     kStatusGroup_SEMC = 100,                   /*!< Group number for SEMC status codes. */    
 149:../drivers/fsl_common.h ****     kStatusGroup_ApplicationRangeStart = 101, /*!< Starting number for application groups. */
 150:../drivers/fsl_common.h **** };
 151:../drivers/fsl_common.h **** 
 152:../drivers/fsl_common.h **** /*! @brief Generic status return codes. */
 153:../drivers/fsl_common.h **** enum _generic_status
 154:../drivers/fsl_common.h **** {
 155:../drivers/fsl_common.h ****     kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
 156:../drivers/fsl_common.h ****     kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
 157:../drivers/fsl_common.h ****     kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
 158:../drivers/fsl_common.h ****     kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
 159:../drivers/fsl_common.h ****     kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
 160:../drivers/fsl_common.h ****     kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
 161:../drivers/fsl_common.h ****     kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
 162:../drivers/fsl_common.h **** };
 163:../drivers/fsl_common.h **** 
 164:../drivers/fsl_common.h **** /*! @brief Type used for all status and error return values. */
 165:../drivers/fsl_common.h **** typedef int32_t status_t;
 166:../drivers/fsl_common.h **** 
 167:../drivers/fsl_common.h **** /*
 168:../drivers/fsl_common.h ****  * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
 169:../drivers/fsl_common.h ****  * defined in previous of this file.
 170:../drivers/fsl_common.h ****  */
 171:../drivers/fsl_common.h **** #include "fsl_clock.h"
 172:../drivers/fsl_common.h **** 
 173:../drivers/fsl_common.h **** /*
 174:../drivers/fsl_common.h ****  * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a 
 175:../drivers/fsl_common.h ****  */
 176:../drivers/fsl_common.h **** #if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
 177:../drivers/fsl_common.h ****      (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
 178:../drivers/fsl_common.h **** #include "fsl_reset.h"
 179:../drivers/fsl_common.h **** #endif
 180:../drivers/fsl_common.h **** 
 181:../drivers/fsl_common.h **** /*! @name Min/max macros */
 182:../drivers/fsl_common.h **** /* @{ */
 183:../drivers/fsl_common.h **** #if !defined(MIN)
 184:../drivers/fsl_common.h **** #define MIN(a, b) ((a) < (b) ? (a) : (b))
 185:../drivers/fsl_common.h **** #endif
 186:../drivers/fsl_common.h **** 
 187:../drivers/fsl_common.h **** #if !defined(MAX)
 188:../drivers/fsl_common.h **** #define MAX(a, b) ((a) > (b) ? (a) : (b))
 189:../drivers/fsl_common.h **** #endif
 190:../drivers/fsl_common.h **** /* @} */
 191:../drivers/fsl_common.h **** 
 192:../drivers/fsl_common.h **** /*! @brief Computes the number of elements in an array. */
 193:../drivers/fsl_common.h **** #if !defined(ARRAY_SIZE)
 194:../drivers/fsl_common.h **** #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 195:../drivers/fsl_common.h **** #endif
 196:../drivers/fsl_common.h **** 
 197:../drivers/fsl_common.h **** /*! @name UINT16_MAX/UINT32_MAX value */
 198:../drivers/fsl_common.h **** /* @{ */
 199:../drivers/fsl_common.h **** #if !defined(UINT16_MAX)
 200:../drivers/fsl_common.h **** #define UINT16_MAX ((uint16_t)-1)
 201:../drivers/fsl_common.h **** #endif
 202:../drivers/fsl_common.h **** 
 203:../drivers/fsl_common.h **** #if !defined(UINT32_MAX)
 204:../drivers/fsl_common.h **** #define UINT32_MAX ((uint32_t)-1)
 205:../drivers/fsl_common.h **** #endif
 206:../drivers/fsl_common.h **** /* @} */
 207:../drivers/fsl_common.h **** 
 208:../drivers/fsl_common.h **** /*! @name Timer utilities */
 209:../drivers/fsl_common.h **** /* @{ */
 210:../drivers/fsl_common.h **** /*! Macro to convert a microsecond period to raw count value */
 211:../drivers/fsl_common.h **** #define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
 212:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to microsecond */
 213:../drivers/fsl_common.h **** #define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
 214:../drivers/fsl_common.h **** 
 215:../drivers/fsl_common.h **** /*! Macro to convert a millisecond period to raw count value */
 216:../drivers/fsl_common.h **** #define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
 217:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to millisecond */
 218:../drivers/fsl_common.h **** #define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
 219:../drivers/fsl_common.h **** /* @} */
 220:../drivers/fsl_common.h **** 
 221:../drivers/fsl_common.h **** /*! @name Alignment variable definition macros */
 222:../drivers/fsl_common.h **** /* @{ */
 223:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 224:../drivers/fsl_common.h **** /**
 225:../drivers/fsl_common.h ****  * Workaround to disable MISRA C message suppress warnings for IAR compiler.
 226:../drivers/fsl_common.h ****  * http://supp.iar.com/Support/?note=24725
 227:../drivers/fsl_common.h ****  */
 228:../drivers/fsl_common.h **** _Pragma("diag_suppress=Pm120")
 229:../drivers/fsl_common.h **** #define SDK_PRAGMA(x) _Pragma(#x)
 230:../drivers/fsl_common.h ****     _Pragma("diag_error=Pm120")
 231:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 232:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 233:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 234:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 235:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 236:../drivers/fsl_common.h **** #endif
 237:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 238:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 239:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 240:../drivers/fsl_common.h **** #endif
 241:../drivers/fsl_common.h **** #elif defined(__ARMCC_VERSION)
 242:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 243:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) __align(alignbytes) var
 244:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 245:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 246:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) __align(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 247:../drivers/fsl_common.h **** #endif
 248:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 249:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 250:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) __align(FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 251:../drivers/fsl_common.h **** #endif
 252:../drivers/fsl_common.h **** #elif defined(__GNUC__)
 253:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 254:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 255:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 256:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 257:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)))
 258:../drivers/fsl_common.h **** #endif
 259:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 260:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 261:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)))
 262:../drivers/fsl_common.h **** #endif
 263:../drivers/fsl_common.h **** #else
 264:../drivers/fsl_common.h **** #error Toolchain not supported
 265:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var
 266:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 267:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var
 268:../drivers/fsl_common.h **** #endif
 269:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 270:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var
 271:../drivers/fsl_common.h **** #endif
 272:../drivers/fsl_common.h **** #endif
 273:../drivers/fsl_common.h **** 
 274:../drivers/fsl_common.h **** /*! Macro to change a value to a given size aligned value */
 275:../drivers/fsl_common.h **** #define SDK_SIZEALIGN(var, alignbytes) \
 276:../drivers/fsl_common.h ****     ((unsigned int)((var) + ((alignbytes)-1)) & (unsigned int)(~(unsigned int)((alignbytes)-1)))
 277:../drivers/fsl_common.h **** /* @} */
 278:../drivers/fsl_common.h **** 
 279:../drivers/fsl_common.h **** /*! @name Non-cacheable region definition macros */
 280:../drivers/fsl_common.h **** /* For initialized non-zero non-cacheable variables, please using "AT_NONCACHEABLE_SECTION_INIT(var
 281:../drivers/fsl_common.h ****  * "AT_NONCACHEABLE_SECTION_ALIGN_INIT(var) ={xx};" in your projects to define them, for zero-inite
 282:../drivers/fsl_common.h ****  * please using "AT_NONCACHEABLE_SECTION(var);" or "AT_NONCACHEABLE_SECTION_ALIGN(var);" to define 
 283:../drivers/fsl_common.h ****  * will be initialized to zero in system startup.
 284:../drivers/fsl_common.h ****  */
 285:../drivers/fsl_common.h **** /* @{ */
 286:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 287:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 288:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var @"NonCacheable"
 289:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var 
 290:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var @"NonCacheable.init"
 291:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 292:../drivers/fsl_common.h **** #else
 293:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 294:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 295:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 296:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 297:../drivers/fsl_common.h **** #endif
 298:../drivers/fsl_common.h **** #elif(defined(__ARMCC_VERSION))
 299:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 300:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable"), zero_init)) var
 301:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 302:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable"), zero_init)) __align(alignbytes) var
 303:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 304:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 305:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) __align(alignbytes) var
 306:../drivers/fsl_common.h **** #else
 307:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 308:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) __align(alignbytes) var
 309:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 310:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) __align(alignbytes) var
 311:../drivers/fsl_common.h **** #endif
 312:../drivers/fsl_common.h **** #elif(defined(__GNUC__))
 313:../drivers/fsl_common.h **** /* For GCC, when the non-cacheable section is required, please define "__STARTUP_INITIALIZE_NONCACH
 314:../drivers/fsl_common.h ****  * in your projects to make sure the non-cacheable section variables will be initialized in system 
 315:../drivers/fsl_common.h ****  */
 316:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 317:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 318:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 319:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) var __attribute__((aligned(alignbytes)))
 320:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var
 321:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 322:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var __attribute__((aligned(alignbytes
 323:../drivers/fsl_common.h **** #else
 324:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 325:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 326:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 327:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var __attribute__((aligned(alignbytes))
 328:../drivers/fsl_common.h **** #endif
 329:../drivers/fsl_common.h **** #else
 330:../drivers/fsl_common.h **** #error Toolchain not supported.
 331:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 332:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var
 333:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 334:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var
 335:../drivers/fsl_common.h **** #endif
 336:../drivers/fsl_common.h **** /* @} */
 337:../drivers/fsl_common.h **** 
 338:../drivers/fsl_common.h **** /*******************************************************************************
 339:../drivers/fsl_common.h ****  * API
 340:../drivers/fsl_common.h ****  ******************************************************************************/
 341:../drivers/fsl_common.h **** 
 342:../drivers/fsl_common.h **** #if defined(__cplusplus)
 343:../drivers/fsl_common.h ****         extern "C"
 344:../drivers/fsl_common.h **** {
 345:../drivers/fsl_common.h **** #endif
 346:../drivers/fsl_common.h **** 
 347:../drivers/fsl_common.h ****     /*!
 348:../drivers/fsl_common.h ****      * @brief Enable specific interrupt.
 349:../drivers/fsl_common.h ****      *
 350:../drivers/fsl_common.h ****      * Enable LEVEL1 interrupt. For some devices, there might be multiple interrupt
 351:../drivers/fsl_common.h ****      * levels. For example, there are NVIC and intmux. Here the interrupts connected
 352:../drivers/fsl_common.h ****      * to NVIC are the LEVEL1 interrupts, because they are routed to the core directly.
 353:../drivers/fsl_common.h ****      * The interrupts connected to intmux are the LEVEL2 interrupts, they are routed
 354:../drivers/fsl_common.h ****      * to NVIC first then routed to core.
 355:../drivers/fsl_common.h ****      *
 356:../drivers/fsl_common.h ****      * This function only enables the LEVEL1 interrupts. The number of LEVEL1 interrupts
 357:../drivers/fsl_common.h ****      * is indicated by the feature macro FSL_FEATURE_NUMBER_OF_LEVEL1_INT_VECTORS.
 358:../drivers/fsl_common.h ****      *
 359:../drivers/fsl_common.h ****      * @param interrupt The IRQ number.
 360:../drivers/fsl_common.h ****      * @retval kStatus_Success Interrupt enabled successfully
 361:../drivers/fsl_common.h ****      * @retval kStatus_Fail Failed to enable the interrupt
 362:../drivers/fsl_common.h ****      */
 363:../drivers/fsl_common.h ****     static inline status_t EnableIRQ(IRQn_Type interrupt)
 364:../drivers/fsl_common.h ****     {
 365:../drivers/fsl_common.h ****         if (NotAvail_IRQn == interrupt)
 1716              		.loc 3 365 0
 1717 003a 1A00     		movs	r2, r3
 1718 003c 8032     		adds	r2, r2, #128
 1719 003e 08D0     		beq	.L118
 1720              	.LVL206:
 1721              	.LBB18:
 1722              	.LBB19:
 1723              		.file 4 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 1724              		.loc 4 733 0
 1725 0040 002B     		cmp	r3, #0
 1726 0042 06DB     		blt	.L118
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 1727              		.loc 4 735 0
 1728 0044 1F22     		movs	r2, #31
 1729 0046 1340     		ands	r3, r2
 1730              	.LVL207:
 1731 0048 1E3A     		subs	r2, r2, #30
 1732 004a 9A40     		lsls	r2, r2, r3
 1733 004c 1300     		movs	r3, r2
 1734 004e 054A     		ldr	r2, .L120+16
 1735 0050 1360     		str	r3, [r2]
 1736              	.LVL208:
 1737              	.L118:
 1738              	.LBE19:
 1739              	.LBE18:
 1740              	.LBE17:
 1741              	.LBE16:
 806:../drivers/fsl_lpuart.c **** 
 1742              		.loc 1 806 0
 1743              		@ sp needed
 1744              	.LVL209:
 1745              	.LVL210:
 1746              	.LVL211:
 1747              	.LVL212:
 1748 0052 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1749              	.L121:
 1750              		.align	2
 1751              	.L120:
 1752 0054 00000000 		.word	.LANCHOR2
 1753 0058 00000000 		.word	.LANCHOR3
 1754 005c 00000000 		.word	LPUART_TransferHandleIRQ
 1755 0060 00000000 		.word	.LANCHOR4
 1756 0064 00E100E0 		.word	-536813312
 1757              		.cfi_endproc
 1758              	.LFE76:
 1760              		.section	.text.LPUART_TransferStartRingBuffer,"ax",%progbits
 1761              		.align	1
 1762              		.global	LPUART_TransferStartRingBuffer
 1763              		.syntax unified
 1764              		.code	16
 1765              		.thumb_func
 1766              		.fpu softvfp
 1768              	LPUART_TransferStartRingBuffer:
 1769              	.LFB77:
 812:../drivers/fsl_lpuart.c ****     assert(handle);
 1770              		.loc 1 812 0
 1771              		.cfi_startproc
 1772              		@ args = 0, pretend = 0, frame = 0
 1773              		@ frame_needed = 0, uses_anonymous_args = 0
 1774              	.LVL213:
 1775 0000 10B5     		push	{r4, lr}
 1776              		.cfi_def_cfa_offset 8
 1777              		.cfi_offset 4, -8
 1778              		.cfi_offset 14, -4
 817:../drivers/fsl_lpuart.c ****     handle->rxRingBufferSize = ringBufferSize;
 1779              		.loc 1 817 0
 1780 0002 8A61     		str	r2, [r1, #24]
 818:../drivers/fsl_lpuart.c ****     handle->rxRingBufferHead = 0U;
 1781              		.loc 1 818 0
 1782 0004 CB61     		str	r3, [r1, #28]
 819:../drivers/fsl_lpuart.c ****     handle->rxRingBufferTail = 0U;
 1783              		.loc 1 819 0
 1784 0006 0023     		movs	r3, #0
 1785              	.LVL214:
 1786 0008 0B84     		strh	r3, [r1, #32]
 820:../drivers/fsl_lpuart.c **** 
 1787              		.loc 1 820 0
 1788 000a 4B84     		strh	r3, [r1, #34]
 823:../drivers/fsl_lpuart.c **** }
 1789              		.loc 1 823 0
 1790 000c 8221     		movs	r1, #130
 1791              	.LVL215:
 1792 000e 0905     		lsls	r1, r1, #20
 1793 0010 FFF7FEFF 		bl	LPUART_EnableInterrupts
 1794              	.LVL216:
 824:../drivers/fsl_lpuart.c **** 
 1795              		.loc 1 824 0
 1796              		@ sp needed
 1797 0014 10BD     		pop	{r4, pc}
 1798              		.cfi_endproc
 1799              	.LFE77:
 1801              		.section	.text.LPUART_TransferStopRingBuffer,"ax",%progbits
 1802              		.align	1
 1803              		.global	LPUART_TransferStopRingBuffer
 1804              		.syntax unified
 1805              		.code	16
 1806              		.thumb_func
 1807              		.fpu softvfp
 1809              	LPUART_TransferStopRingBuffer:
 1810              	.LFB78:
 827:../drivers/fsl_lpuart.c ****     assert(handle);
 1811              		.loc 1 827 0
 1812              		.cfi_startproc
 1813              		@ args = 0, pretend = 0, frame = 0
 1814              		@ frame_needed = 0, uses_anonymous_args = 0
 1815              	.LVL217:
 1816 0000 10B5     		push	{r4, lr}
 1817              		.cfi_def_cfa_offset 8
 1818              		.cfi_offset 4, -8
 1819              		.cfi_offset 14, -4
 1820 0002 0C00     		movs	r4, r1
 830:../drivers/fsl_lpuart.c ****     {
 1821              		.loc 1 830 0
 1822 0004 2D23     		movs	r3, #45
 1823 0006 CB5C     		ldrb	r3, [r1, r3]
 1824 0008 022B     		cmp	r3, #2
 1825 000a 05D0     		beq	.L125
 1826              	.LVL218:
 1827              	.L124:
 835:../drivers/fsl_lpuart.c ****     handle->rxRingBufferSize = 0U;
 1828              		.loc 1 835 0
 1829 000c 0023     		movs	r3, #0
 1830 000e A361     		str	r3, [r4, #24]
 836:../drivers/fsl_lpuart.c ****     handle->rxRingBufferHead = 0U;
 1831              		.loc 1 836 0
 1832 0010 E361     		str	r3, [r4, #28]
 837:../drivers/fsl_lpuart.c ****     handle->rxRingBufferTail = 0U;
 1833              		.loc 1 837 0
 1834 0012 2384     		strh	r3, [r4, #32]
 838:../drivers/fsl_lpuart.c **** }
 1835              		.loc 1 838 0
 1836 0014 6384     		strh	r3, [r4, #34]
 839:../drivers/fsl_lpuart.c **** 
 1837              		.loc 1 839 0
 1838              		@ sp needed
 1839              	.LVL219:
 1840 0016 10BD     		pop	{r4, pc}
 1841              	.LVL220:
 1842              	.L125:
 832:../drivers/fsl_lpuart.c ****     }
 1843              		.loc 1 832 0
 1844 0018 8221     		movs	r1, #130
 1845              	.LVL221:
 1846 001a 0905     		lsls	r1, r1, #20
 1847 001c FFF7FEFF 		bl	LPUART_DisableInterrupts
 1848              	.LVL222:
 1849 0020 F4E7     		b	.L124
 1850              		.cfi_endproc
 1851              	.LFE78:
 1853              		.section	.text.LPUART_TransferSendNonBlocking,"ax",%progbits
 1854              		.align	1
 1855              		.global	LPUART_TransferSendNonBlocking
 1856              		.syntax unified
 1857              		.code	16
 1858              		.thumb_func
 1859              		.fpu softvfp
 1861              	LPUART_TransferSendNonBlocking:
 1862              	.LFB79:
 842:../drivers/fsl_lpuart.c ****     assert(handle);
 1863              		.loc 1 842 0
 1864              		.cfi_startproc
 1865              		@ args = 0, pretend = 0, frame = 0
 1866              		@ frame_needed = 0, uses_anonymous_args = 0
 1867              	.LVL223:
 1868 0000 10B5     		push	{r4, lr}
 1869              		.cfi_def_cfa_offset 8
 1870              		.cfi_offset 4, -8
 1871              		.cfi_offset 14, -4
 851:../drivers/fsl_lpuart.c ****     {
 1872              		.loc 1 851 0
 1873 0002 2C23     		movs	r3, #44
 1874 0004 CB5C     		ldrb	r3, [r1, r3]
 1875 0006 012B     		cmp	r3, #1
 1876 0008 0ED0     		beq	.L128
 857:../drivers/fsl_lpuart.c ****         handle->txDataSize = xfer->dataSize;
 1877              		.loc 1 857 0
 1878 000a 1368     		ldr	r3, [r2]
 1879 000c 0B60     		str	r3, [r1]
 858:../drivers/fsl_lpuart.c ****         handle->txDataSizeAll = xfer->dataSize;
 1880              		.loc 1 858 0
 1881 000e 5368     		ldr	r3, [r2, #4]
 1882 0010 4B60     		str	r3, [r1, #4]
 859:../drivers/fsl_lpuart.c ****         handle->txState = kLPUART_TxBusy;
 1883              		.loc 1 859 0
 1884 0012 5368     		ldr	r3, [r2, #4]
 1885 0014 8B60     		str	r3, [r1, #8]
 860:../drivers/fsl_lpuart.c **** 
 1886              		.loc 1 860 0
 1887 0016 2C23     		movs	r3, #44
 1888 0018 0122     		movs	r2, #1
 1889              	.LVL224:
 1890 001a CA54     		strb	r2, [r1, r3]
 863:../drivers/fsl_lpuart.c **** 
 1891              		.loc 1 863 0
 1892 001c 8021     		movs	r1, #128
 1893              	.LVL225:
 1894 001e 0904     		lsls	r1, r1, #16
 1895 0020 FFF7FEFF 		bl	LPUART_EnableInterrupts
 1896              	.LVL226:
 865:../drivers/fsl_lpuart.c ****     }
 1897              		.loc 1 865 0
 1898 0024 0020     		movs	r0, #0
 1899              	.LVL227:
 1900              	.L126:
 869:../drivers/fsl_lpuart.c **** 
 1901              		.loc 1 869 0
 1902              		@ sp needed
 1903 0026 10BD     		pop	{r4, pc}
 1904              	.LVL228:
 1905              	.L128:
 853:../drivers/fsl_lpuart.c ****     }
 1906              		.loc 1 853 0
 1907 0028 0048     		ldr	r0, .L129
 1908              	.LVL229:
 868:../drivers/fsl_lpuart.c **** }
 1909              		.loc 1 868 0
 1910 002a FCE7     		b	.L126
 1911              	.L130:
 1912              		.align	2
 1913              	.L129:
 1914 002c 14050000 		.word	1300
 1915              		.cfi_endproc
 1916              	.LFE79:
 1918              		.section	.text.LPUART_TransferAbortSend,"ax",%progbits
 1919              		.align	1
 1920              		.global	LPUART_TransferAbortSend
 1921              		.syntax unified
 1922              		.code	16
 1923              		.thumb_func
 1924              		.fpu softvfp
 1926              	LPUART_TransferAbortSend:
 1927              	.LFB80:
 872:../drivers/fsl_lpuart.c ****     assert(handle);
 1928              		.loc 1 872 0
 1929              		.cfi_startproc
 1930              		@ args = 0, pretend = 0, frame = 0
 1931              		@ frame_needed = 0, uses_anonymous_args = 0
 1932              	.LVL230:
 1933 0000 10B5     		push	{r4, lr}
 1934              		.cfi_def_cfa_offset 8
 1935              		.cfi_offset 4, -8
 1936              		.cfi_offset 14, -4
 1937 0002 0C00     		movs	r4, r1
 875:../drivers/fsl_lpuart.c **** 
 1938              		.loc 1 875 0
 1939 0004 C021     		movs	r1, #192
 1940              	.LVL231:
 1941 0006 0904     		lsls	r1, r1, #16
 1942 0008 FFF7FEFF 		bl	LPUART_DisableInterrupts
 1943              	.LVL232:
 877:../drivers/fsl_lpuart.c ****     handle->txState = kLPUART_TxIdle;
 1944              		.loc 1 877 0
 1945 000c 0023     		movs	r3, #0
 1946 000e 6360     		str	r3, [r4, #4]
 878:../drivers/fsl_lpuart.c **** }
 1947              		.loc 1 878 0
 1948 0010 2C22     		movs	r2, #44
 1949 0012 A354     		strb	r3, [r4, r2]
 879:../drivers/fsl_lpuart.c **** 
 1950              		.loc 1 879 0
 1951              		@ sp needed
 1952              	.LVL233:
 1953 0014 10BD     		pop	{r4, pc}
 1954              		.cfi_endproc
 1955              	.LFE80:
 1957              		.section	.text.LPUART_TransferGetSendCount,"ax",%progbits
 1958              		.align	1
 1959              		.global	LPUART_TransferGetSendCount
 1960              		.syntax unified
 1961              		.code	16
 1962              		.thumb_func
 1963              		.fpu softvfp
 1965              	LPUART_TransferGetSendCount:
 1966              	.LFB81:
 882:../drivers/fsl_lpuart.c ****     assert(handle);
 1967              		.loc 1 882 0
 1968              		.cfi_startproc
 1969              		@ args = 0, pretend = 0, frame = 0
 1970              		@ frame_needed = 0, uses_anonymous_args = 0
 1971              		@ link register save eliminated.
 1972              	.LVL234:
 886:../drivers/fsl_lpuart.c ****     {
 1973              		.loc 1 886 0
 1974 0000 2C23     		movs	r3, #44
 1975 0002 CB5C     		ldrb	r3, [r1, r3]
 1976 0004 002B     		cmp	r3, #0
 1977 0006 05D0     		beq	.L134
 891:../drivers/fsl_lpuart.c **** 
 1978              		.loc 1 891 0
 1979 0008 8B68     		ldr	r3, [r1, #8]
 1980 000a 4968     		ldr	r1, [r1, #4]
 1981              	.LVL235:
 1982 000c 5B1A     		subs	r3, r3, r1
 1983 000e 1360     		str	r3, [r2]
 893:../drivers/fsl_lpuart.c **** }
 1984              		.loc 1 893 0
 1985 0010 0020     		movs	r0, #0
 1986              	.LVL236:
 1987              	.L132:
 894:../drivers/fsl_lpuart.c **** 
 1988              		.loc 1 894 0
 1989              		@ sp needed
 1990 0012 7047     		bx	lr
 1991              	.LVL237:
 1992              	.L134:
 888:../drivers/fsl_lpuart.c ****     }
 1993              		.loc 1 888 0
 1994 0014 0620     		movs	r0, #6
 1995              	.LVL238:
 1996 0016 FCE7     		b	.L132
 1997              		.cfi_endproc
 1998              	.LFE81:
 2000              		.section	.text.LPUART_TransferReceiveNonBlocking,"ax",%progbits
 2001              		.align	1
 2002              		.global	LPUART_TransferReceiveNonBlocking
 2003              		.syntax unified
 2004              		.code	16
 2005              		.thumb_func
 2006              		.fpu softvfp
 2008              	LPUART_TransferReceiveNonBlocking:
 2009              	.LFB82:
 900:../drivers/fsl_lpuart.c ****     assert(handle);
 2010              		.loc 1 900 0
 2011              		.cfi_startproc
 2012              		@ args = 0, pretend = 0, frame = 8
 2013              		@ frame_needed = 0, uses_anonymous_args = 0
 2014              	.LVL239:
 2015 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2016              		.cfi_def_cfa_offset 20
 2017              		.cfi_offset 4, -20
 2018              		.cfi_offset 5, -16
 2019              		.cfi_offset 6, -12
 2020              		.cfi_offset 7, -8
 2021              		.cfi_offset 14, -4
 2022 0002 C646     		mov	lr, r8
 2023 0004 00B5     		push	{lr}
 2024              		.cfi_def_cfa_offset 24
 2025              		.cfi_offset 8, -24
 2026 0006 82B0     		sub	sp, sp, #8
 2027              		.cfi_def_cfa_offset 32
 2028 0008 0500     		movs	r5, r0
 2029 000a 0190     		str	r0, [sp, #4]
 2030 000c 0C00     		movs	r4, r1
 2031 000e 1600     		movs	r6, r2
 2032 0010 9846     		mov	r8, r3
 2033              	.LVL240:
 925:../drivers/fsl_lpuart.c ****     {
 2034              		.loc 1 925 0
 2035 0012 2D23     		movs	r3, #45
 2036              	.LVL241:
 2037 0014 CB5C     		ldrb	r3, [r1, r3]
 2038 0016 032B     		cmp	r3, #3
 2039 0018 5BD0     		beq	.L146
 931:../drivers/fsl_lpuart.c ****         bytesCurrentReceived = 0;
 2040              		.loc 1 931 0
 2041 001a 5768     		ldr	r7, [r2, #4]
 2042              	.LVL242:
 935:../drivers/fsl_lpuart.c ****         {
 2043              		.loc 1 935 0
 2044 001c 8B69     		ldr	r3, [r1, #24]
 2045 001e 002B     		cmp	r3, #0
 2046 0020 49D0     		beq	.L137
 938:../drivers/fsl_lpuart.c **** 
 2047              		.loc 1 938 0
 2048 0022 8021     		movs	r1, #128
 2049              	.LVL243:
 2050 0024 8903     		lsls	r1, r1, #14
 2051 0026 FFF7FEFF 		bl	LPUART_DisableInterrupts
 2052              	.LVL244:
 941:../drivers/fsl_lpuart.c **** 
 2053              		.loc 1 941 0
 2054 002a 2100     		movs	r1, r4
 2055 002c 2800     		movs	r0, r5
 2056 002e FFF7FEFF 		bl	LPUART_TransferGetRxRingBufferLength
 2057              	.LVL245:
 2058 0032 051E     		subs	r5, r0, #0
 2059              	.LVL246:
 943:../drivers/fsl_lpuart.c ****             {
 2060              		.loc 1 943 0
 2061 0034 1CD0     		beq	.L138
 945:../drivers/fsl_lpuart.c **** 
 2062              		.loc 1 945 0
 2063 0036 3A00     		movs	r2, r7
 2064 0038 8742     		cmp	r7, r0
 2065 003a 00D9     		bls	.L139
 2066 003c 0200     		movs	r2, r0
 2067              	.L139:
 2068              	.LVL247:
 947:../drivers/fsl_lpuart.c **** 
 2069              		.loc 1 947 0
 2070 003e BF1A     		subs	r7, r7, r2
 2071              	.LVL248:
 950:../drivers/fsl_lpuart.c ****                 {
 2072              		.loc 1 950 0
 2073 0040 0025     		movs	r5, #0
 2074 0042 02E0     		b	.L140
 2075              	.LVL249:
 2076              	.L148:
 957:../drivers/fsl_lpuart.c ****                     }
 2077              		.loc 1 957 0
 2078 0044 0023     		movs	r3, #0
 2079 0046 6384     		strh	r3, [r4, #34]
 2080              	.L142:
 900:../drivers/fsl_lpuart.c ****     assert(handle);
 2081              		.loc 1 900 0 discriminator 1
 2082 0048 0D00     		movs	r5, r1
 2083              	.LVL250:
 2084              	.L140:
 950:../drivers/fsl_lpuart.c ****                 {
 2085              		.loc 1 950 0 discriminator 1
 2086 004a 9542     		cmp	r5, r2
 2087 004c 10D2     		bcs	.L138
 952:../drivers/fsl_lpuart.c **** 
 2088              		.loc 1 952 0
 2089 004e 638C     		ldrh	r3, [r4, #34]
 2090 0050 9BB2     		uxth	r3, r3
 2091 0052 691C     		adds	r1, r5, #1
 2092              	.LVL251:
 2093 0054 A069     		ldr	r0, [r4, #24]
 2094 0056 C35C     		ldrb	r3, [r0, r3]
 2095 0058 3068     		ldr	r0, [r6]
 2096 005a 4355     		strb	r3, [r0, r5]
 955:../drivers/fsl_lpuart.c ****                     {
 2097              		.loc 1 955 0
 2098 005c 638C     		ldrh	r3, [r4, #34]
 2099 005e 0133     		adds	r3, r3, #1
 2100 0060 E069     		ldr	r0, [r4, #28]
 2101 0062 8342     		cmp	r3, r0
 2102 0064 EED0     		beq	.L148
 961:../drivers/fsl_lpuart.c ****                     }
 2103              		.loc 1 961 0
 2104 0066 638C     		ldrh	r3, [r4, #34]
 2105 0068 0133     		adds	r3, r3, #1
 2106 006a 9BB2     		uxth	r3, r3
 2107 006c 6384     		strh	r3, [r4, #34]
 2108 006e EBE7     		b	.L142
 2109              	.LVL252:
 2110              	.L138:
 967:../drivers/fsl_lpuart.c ****             {
 2111              		.loc 1 967 0
 2112 0070 002F     		cmp	r7, #0
 2113 0072 07D0     		beq	.L144
 970:../drivers/fsl_lpuart.c ****                 handle->rxDataSize = bytesToReceive;
 2114              		.loc 1 970 0
 2115 0074 3368     		ldr	r3, [r6]
 2116 0076 5B19     		adds	r3, r3, r5
 2117 0078 E360     		str	r3, [r4, #12]
 971:../drivers/fsl_lpuart.c ****                 handle->rxDataSizeAll = bytesToReceive;
 2118              		.loc 1 971 0
 2119 007a 2761     		str	r7, [r4, #16]
 972:../drivers/fsl_lpuart.c ****                 handle->rxState = kLPUART_RxBusy;
 2120              		.loc 1 972 0
 2121 007c 6761     		str	r7, [r4, #20]
 973:../drivers/fsl_lpuart.c ****             }
 2122              		.loc 1 973 0
 2123 007e 2D23     		movs	r3, #45
 2124 0080 0322     		movs	r2, #3
 2125 0082 E254     		strb	r2, [r4, r3]
 2126              	.L144:
 976:../drivers/fsl_lpuart.c **** 
 2127              		.loc 1 976 0
 2128 0084 8021     		movs	r1, #128
 2129 0086 8903     		lsls	r1, r1, #14
 2130 0088 019E     		ldr	r6, [sp, #4]
 2131              	.LVL253:
 2132 008a 3000     		movs	r0, r6
 2133 008c FFF7FEFF 		bl	LPUART_EnableInterrupts
 2134              	.LVL254:
 979:../drivers/fsl_lpuart.c ****             {
 2135              		.loc 1 979 0
 2136 0090 002F     		cmp	r7, #0
 2137 0092 07D1     		bne	.L145
 981:../drivers/fsl_lpuart.c ****                 {
 2138              		.loc 1 981 0
 2139 0094 676A     		ldr	r7, [r4, #36]
 2140              	.LVL255:
 2141 0096 002F     		cmp	r7, #0
 2142 0098 04D0     		beq	.L145
 983:../drivers/fsl_lpuart.c ****                 }
 2143              		.loc 1 983 0
 2144 009a A36A     		ldr	r3, [r4, #40]
 2145 009c 0F4A     		ldr	r2, .L149
 2146 009e 2100     		movs	r1, r4
 2147 00a0 3000     		movs	r0, r6
 2148 00a2 B847     		blx	r7
 2149              	.LVL256:
 2150              	.L145:
1001:../drivers/fsl_lpuart.c ****         {
 2151              		.loc 1 1001 0
 2152 00a4 4346     		mov	r3, r8
 2153 00a6 002B     		cmp	r3, #0
 2154 00a8 15D0     		beq	.L147
 2155              	.LVL257:
1003:../drivers/fsl_lpuart.c ****         }
 2156              		.loc 1 1003 0
 2157 00aa 1D60     		str	r5, [r3]
1006:../drivers/fsl_lpuart.c ****     }
 2158              		.loc 1 1006 0
 2159 00ac 0020     		movs	r0, #0
 2160              	.LVL258:
 2161              	.L135:
1010:../drivers/fsl_lpuart.c **** 
 2162              		.loc 1 1010 0
 2163 00ae 02B0     		add	sp, sp, #8
 2164              		@ sp needed
 2165              	.LVL259:
 2166              	.LVL260:
 2167 00b0 04BC     		pop	{r2}
 2168 00b2 9046     		mov	r8, r2
 2169 00b4 F0BD     		pop	{r4, r5, r6, r7, pc}
 2170              	.LVL261:
 2171              	.L137:
 990:../drivers/fsl_lpuart.c ****             handle->rxDataSize = bytesToReceive;
 2172              		.loc 1 990 0
 2173 00b6 1368     		ldr	r3, [r2]
 2174 00b8 CB60     		str	r3, [r1, #12]
 991:../drivers/fsl_lpuart.c ****             handle->rxDataSizeAll = bytesToReceive;
 2175              		.loc 1 991 0
 2176 00ba 0F61     		str	r7, [r1, #16]
 992:../drivers/fsl_lpuart.c ****             handle->rxState = kLPUART_RxBusy;
 2177              		.loc 1 992 0
 2178 00bc 4F61     		str	r7, [r1, #20]
 993:../drivers/fsl_lpuart.c **** 
 2179              		.loc 1 993 0
 2180 00be 2D23     		movs	r3, #45
 2181 00c0 0322     		movs	r2, #3
 2182              	.LVL262:
 2183 00c2 CA54     		strb	r2, [r1, r3]
 996:../drivers/fsl_lpuart.c ****                                               kLPUART_IdleLineInterruptEnable);
 2184              		.loc 1 996 0
 2185 00c4 8321     		movs	r1, #131
 2186              	.LVL263:
 2187 00c6 0905     		lsls	r1, r1, #20
 2188 00c8 0198     		ldr	r0, [sp, #4]
 2189              	.LVL264:
 2190 00ca FFF7FEFF 		bl	LPUART_EnableInterrupts
 2191              	.LVL265:
 932:../drivers/fsl_lpuart.c **** 
 2192              		.loc 1 932 0
 2193 00ce 0025     		movs	r5, #0
 2194              	.LVL266:
 2195 00d0 E8E7     		b	.L145
 2196              	.LVL267:
 2197              	.L146:
 927:../drivers/fsl_lpuart.c ****     }
 2198              		.loc 1 927 0
 2199 00d2 0348     		ldr	r0, .L149+4
 2200              	.LVL268:
 2201 00d4 EBE7     		b	.L135
 2202              	.LVL269:
 2203              	.L147:
1006:../drivers/fsl_lpuart.c ****     }
 2204              		.loc 1 1006 0
 2205 00d6 0020     		movs	r0, #0
 2206              	.LVL270:
1009:../drivers/fsl_lpuart.c **** }
 2207              		.loc 1 1009 0
 2208 00d8 E9E7     		b	.L135
 2209              	.L150:
 2210 00da C046     		.align	2
 2211              	.L149:
 2212 00dc 17050000 		.word	1303
 2213 00e0 15050000 		.word	1301
 2214              		.cfi_endproc
 2215              	.LFE82:
 2217              		.section	.text.LPUART_TransferAbortReceive,"ax",%progbits
 2218              		.align	1
 2219              		.global	LPUART_TransferAbortReceive
 2220              		.syntax unified
 2221              		.code	16
 2222              		.thumb_func
 2223              		.fpu softvfp
 2225              	LPUART_TransferAbortReceive:
 2226              	.LFB83:
1013:../drivers/fsl_lpuart.c ****     assert(handle);
 2227              		.loc 1 1013 0
 2228              		.cfi_startproc
 2229              		@ args = 0, pretend = 0, frame = 0
 2230              		@ frame_needed = 0, uses_anonymous_args = 0
 2231              	.LVL271:
 2232 0000 10B5     		push	{r4, lr}
 2233              		.cfi_def_cfa_offset 8
 2234              		.cfi_offset 4, -8
 2235              		.cfi_offset 14, -4
 2236 0002 0C00     		movs	r4, r1
1017:../drivers/fsl_lpuart.c ****     {
 2237              		.loc 1 1017 0
 2238 0004 8B69     		ldr	r3, [r1, #24]
 2239 0006 002B     		cmp	r3, #0
 2240 0008 05D0     		beq	.L153
 2241              	.LVL272:
 2242              	.L152:
1024:../drivers/fsl_lpuart.c ****     handle->rxState = kLPUART_RxIdle;
 2243              		.loc 1 1024 0
 2244 000a 0023     		movs	r3, #0
 2245 000c 2361     		str	r3, [r4, #16]
1025:../drivers/fsl_lpuart.c **** }
 2246              		.loc 1 1025 0
 2247 000e 2D33     		adds	r3, r3, #45
 2248 0010 0222     		movs	r2, #2
 2249 0012 E254     		strb	r2, [r4, r3]
1026:../drivers/fsl_lpuart.c **** 
 2250              		.loc 1 1026 0
 2251              		@ sp needed
 2252              	.LVL273:
 2253 0014 10BD     		pop	{r4, pc}
 2254              	.LVL274:
 2255              	.L153:
1020:../drivers/fsl_lpuart.c ****                                            kLPUART_IdleLineInterruptEnable);
 2256              		.loc 1 1020 0
 2257 0016 8321     		movs	r1, #131
 2258              	.LVL275:
 2259 0018 0905     		lsls	r1, r1, #20
 2260 001a FFF7FEFF 		bl	LPUART_DisableInterrupts
 2261              	.LVL276:
 2262 001e F4E7     		b	.L152
 2263              		.cfi_endproc
 2264              	.LFE83:
 2266              		.section	.text.LPUART_TransferGetReceiveCount,"ax",%progbits
 2267              		.align	1
 2268              		.global	LPUART_TransferGetReceiveCount
 2269              		.syntax unified
 2270              		.code	16
 2271              		.thumb_func
 2272              		.fpu softvfp
 2274              	LPUART_TransferGetReceiveCount:
 2275              	.LFB84:
1029:../drivers/fsl_lpuart.c ****     assert(handle);
 2276              		.loc 1 1029 0
 2277              		.cfi_startproc
 2278              		@ args = 0, pretend = 0, frame = 0
 2279              		@ frame_needed = 0, uses_anonymous_args = 0
 2280              		@ link register save eliminated.
 2281              	.LVL277:
1033:../drivers/fsl_lpuart.c ****     {
 2282              		.loc 1 1033 0
 2283 0000 2D23     		movs	r3, #45
 2284 0002 CB5C     		ldrb	r3, [r1, r3]
 2285 0004 022B     		cmp	r3, #2
 2286 0006 05D0     		beq	.L156
1038:../drivers/fsl_lpuart.c **** 
 2287              		.loc 1 1038 0
 2288 0008 4B69     		ldr	r3, [r1, #20]
 2289 000a 0969     		ldr	r1, [r1, #16]
 2290              	.LVL278:
 2291 000c 5B1A     		subs	r3, r3, r1
 2292 000e 1360     		str	r3, [r2]
1040:../drivers/fsl_lpuart.c **** }
 2293              		.loc 1 1040 0
 2294 0010 0020     		movs	r0, #0
 2295              	.LVL279:
 2296              	.L154:
1041:../drivers/fsl_lpuart.c **** 
 2297              		.loc 1 1041 0
 2298              		@ sp needed
 2299 0012 7047     		bx	lr
 2300              	.LVL280:
 2301              	.L156:
1035:../drivers/fsl_lpuart.c ****     }
 2302              		.loc 1 1035 0
 2303 0014 0620     		movs	r0, #6
 2304              	.LVL281:
 2305 0016 FCE7     		b	.L154
 2306              		.cfi_endproc
 2307              	.LFE84:
 2309              		.section	.text.LPUART_TransferHandleErrorIRQ,"ax",%progbits
 2310              		.align	1
 2311              		.global	LPUART_TransferHandleErrorIRQ
 2312              		.syntax unified
 2313              		.code	16
 2314              		.thumb_func
 2315              		.fpu softvfp
 2317              	LPUART_TransferHandleErrorIRQ:
 2318              	.LFB86:
1248:../drivers/fsl_lpuart.c **** 
1249:../drivers/fsl_lpuart.c **** void LPUART_TransferHandleErrorIRQ(LPUART_Type *base, lpuart_handle_t *handle)
1250:../drivers/fsl_lpuart.c **** {
 2319              		.loc 1 1250 0
 2320              		.cfi_startproc
 2321              		@ args = 0, pretend = 0, frame = 0
 2322              		@ frame_needed = 0, uses_anonymous_args = 0
 2323              		@ link register save eliminated.
 2324              	.LVL282:
1251:../drivers/fsl_lpuart.c ****     /* To be implemented by User. */
1252:../drivers/fsl_lpuart.c **** }
 2325              		.loc 1 1252 0
 2326              		@ sp needed
 2327 0000 7047     		bx	lr
 2328              		.cfi_endproc
 2329              	.LFE86:
 2331              		.section	.text.LPUART0_DriverIRQHandler,"ax",%progbits
 2332              		.align	1
 2333              		.global	LPUART0_DriverIRQHandler
 2334              		.syntax unified
 2335              		.code	16
 2336              		.thumb_func
 2337              		.fpu softvfp
 2339              	LPUART0_DriverIRQHandler:
 2340              	.LFB87:
1253:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1) && FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1
1254:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
1255:../drivers/fsl_lpuart.c **** void LPUART0_LPUART1_RX_DriverIRQHandler(void)
1256:../drivers/fsl_lpuart.c **** {
1257:../drivers/fsl_lpuart.c ****     if (CLOCK_isEnabledClock(s_lpuartClock[0]))
1258:../drivers/fsl_lpuart.c ****     {
1259:../drivers/fsl_lpuart.c ****         if ((LPUART_STAT_OR_MASK & LPUART0->STAT) ||
1260:../drivers/fsl_lpuart.c ****             ((LPUART_STAT_RDRF_MASK & LPUART0->STAT) && (LPUART_CTRL_RIE_MASK & LPUART0->CTRL)))
1261:../drivers/fsl_lpuart.c ****         {
1262:../drivers/fsl_lpuart.c ****             s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
1263:../drivers/fsl_lpuart.c ****         }
1264:../drivers/fsl_lpuart.c ****     }
1265:../drivers/fsl_lpuart.c ****     if (CLOCK_isEnabledClock(s_lpuartClock[1]))
1266:../drivers/fsl_lpuart.c ****     {
1267:../drivers/fsl_lpuart.c ****         if ((LPUART_STAT_OR_MASK & LPUART1->STAT) ||
1268:../drivers/fsl_lpuart.c ****             ((LPUART_STAT_RDRF_MASK & LPUART1->STAT) && (LPUART_CTRL_RIE_MASK & LPUART1->CTRL)))
1269:../drivers/fsl_lpuart.c ****         {
1270:../drivers/fsl_lpuart.c ****             s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
1271:../drivers/fsl_lpuart.c ****         }
1272:../drivers/fsl_lpuart.c ****     }
1273:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1274:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1275:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1276:../drivers/fsl_lpuart.c ****     __DSB();
1277:../drivers/fsl_lpuart.c **** #endif
1278:../drivers/fsl_lpuart.c **** }
1279:../drivers/fsl_lpuart.c **** void LPUART0_LPUART1_TX_DriverIRQHandler(void)
1280:../drivers/fsl_lpuart.c **** {
1281:../drivers/fsl_lpuart.c ****     if (CLOCK_isEnabledClock(s_lpuartClock[0]))
1282:../drivers/fsl_lpuart.c ****     {
1283:../drivers/fsl_lpuart.c ****         if ((LPUART_STAT_OR_MASK & LPUART0->STAT) ||
1284:../drivers/fsl_lpuart.c ****             ((LPUART0->STAT & LPUART_STAT_TDRE_MASK) && (LPUART0->CTRL & LPUART_CTRL_TIE_MASK)))
1285:../drivers/fsl_lpuart.c ****         {
1286:../drivers/fsl_lpuart.c ****             s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
1287:../drivers/fsl_lpuart.c ****         }
1288:../drivers/fsl_lpuart.c ****     }
1289:../drivers/fsl_lpuart.c ****     if (CLOCK_isEnabledClock(s_lpuartClock[1]))
1290:../drivers/fsl_lpuart.c ****     {
1291:../drivers/fsl_lpuart.c ****         if ((LPUART_STAT_OR_MASK & LPUART1->STAT) ||
1292:../drivers/fsl_lpuart.c ****             ((LPUART1->STAT & LPUART_STAT_TDRE_MASK) && (LPUART1->CTRL & LPUART_CTRL_TIE_MASK)))
1293:../drivers/fsl_lpuart.c ****         {
1294:../drivers/fsl_lpuart.c ****             s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
1295:../drivers/fsl_lpuart.c ****         }
1296:../drivers/fsl_lpuart.c ****     }
1297:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1298:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1299:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1300:../drivers/fsl_lpuart.c ****     __DSB();
1301:../drivers/fsl_lpuart.c **** #endif
1302:../drivers/fsl_lpuart.c **** }
1303:../drivers/fsl_lpuart.c **** #else
1304:../drivers/fsl_lpuart.c **** void LPUART0_LPUART1_DriverIRQHandler(void)
1305:../drivers/fsl_lpuart.c **** {
1306:../drivers/fsl_lpuart.c ****     if (CLOCK_isEnabledClock(s_lpuartClock[0]))
1307:../drivers/fsl_lpuart.c ****     {
1308:../drivers/fsl_lpuart.c ****         if ((LPUART_STAT_OR_MASK & LPUART0->STAT) ||
1309:../drivers/fsl_lpuart.c ****             ((LPUART_STAT_RDRF_MASK & LPUART0->STAT) && (LPUART_CTRL_RIE_MASK & LPUART0->CTRL)) ||
1310:../drivers/fsl_lpuart.c ****             ((LPUART0->STAT & LPUART_STAT_TDRE_MASK) && (LPUART0->CTRL & LPUART_CTRL_TIE_MASK)))
1311:../drivers/fsl_lpuart.c ****         {
1312:../drivers/fsl_lpuart.c ****             s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
1313:../drivers/fsl_lpuart.c ****         }
1314:../drivers/fsl_lpuart.c ****     }
1315:../drivers/fsl_lpuart.c ****     if (CLOCK_isEnabledClock(s_lpuartClock[1]))
1316:../drivers/fsl_lpuart.c ****     {
1317:../drivers/fsl_lpuart.c ****         if ((LPUART_STAT_OR_MASK & LPUART1->STAT) ||
1318:../drivers/fsl_lpuart.c ****             ((LPUART_STAT_RDRF_MASK & LPUART1->STAT) && (LPUART_CTRL_RIE_MASK & LPUART1->CTRL)) ||
1319:../drivers/fsl_lpuart.c ****             ((LPUART1->STAT & LPUART_STAT_TDRE_MASK) && (LPUART1->CTRL & LPUART_CTRL_TIE_MASK)))
1320:../drivers/fsl_lpuart.c ****         {
1321:../drivers/fsl_lpuart.c ****             s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
1322:../drivers/fsl_lpuart.c ****         }
1323:../drivers/fsl_lpuart.c ****     }
1324:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1325:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1326:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1327:../drivers/fsl_lpuart.c ****     __DSB();
1328:../drivers/fsl_lpuart.c **** #endif
1329:../drivers/fsl_lpuart.c **** }
1330:../drivers/fsl_lpuart.c **** #endif
1331:../drivers/fsl_lpuart.c **** #endif
1332:../drivers/fsl_lpuart.c **** 
1333:../drivers/fsl_lpuart.c **** #if defined(LPUART0)
1334:../drivers/fsl_lpuart.c **** #if !(defined(FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1) && FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1)
1335:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
1336:../drivers/fsl_lpuart.c **** void LPUART0_TX_DriverIRQHandler(void)
1337:../drivers/fsl_lpuart.c **** {
1338:../drivers/fsl_lpuart.c ****     s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
1339:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1340:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1341:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1342:../drivers/fsl_lpuart.c ****     __DSB();
1343:../drivers/fsl_lpuart.c **** #endif
1344:../drivers/fsl_lpuart.c **** }
1345:../drivers/fsl_lpuart.c **** void LPUART0_RX_DriverIRQHandler(void)
1346:../drivers/fsl_lpuart.c **** {
1347:../drivers/fsl_lpuart.c ****     s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
1348:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1349:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1350:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1351:../drivers/fsl_lpuart.c ****     __DSB();
1352:../drivers/fsl_lpuart.c **** #endif
1353:../drivers/fsl_lpuart.c **** }
1354:../drivers/fsl_lpuart.c **** #else
1355:../drivers/fsl_lpuart.c **** void LPUART0_DriverIRQHandler(void)
1356:../drivers/fsl_lpuart.c **** {
 2341              		.loc 1 1356 0
 2342              		.cfi_startproc
 2343              		@ args = 0, pretend = 0, frame = 0
 2344              		@ frame_needed = 0, uses_anonymous_args = 0
 2345 0000 10B5     		push	{r4, lr}
 2346              		.cfi_def_cfa_offset 8
 2347              		.cfi_offset 4, -8
 2348              		.cfi_offset 14, -4
1357:../drivers/fsl_lpuart.c ****     s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
 2349              		.loc 1 1357 0
 2350 0002 034B     		ldr	r3, .L159
 2351 0004 1968     		ldr	r1, [r3]
 2352 0006 034B     		ldr	r3, .L159+4
 2353 0008 1B68     		ldr	r3, [r3]
 2354 000a 0348     		ldr	r0, .L159+8
 2355 000c 9847     		blx	r3
 2356              	.LVL283:
1358:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1359:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1360:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1361:../drivers/fsl_lpuart.c ****     __DSB();
1362:../drivers/fsl_lpuart.c **** #endif
1363:../drivers/fsl_lpuart.c **** }
 2357              		.loc 1 1363 0
 2358              		@ sp needed
 2359 000e 10BD     		pop	{r4, pc}
 2360              	.L160:
 2361              		.align	2
 2362              	.L159:
 2363 0010 00000000 		.word	.LANCHOR2
 2364 0014 00000000 		.word	.LANCHOR3
 2365 0018 00400540 		.word	1074085888
 2366              		.cfi_endproc
 2367              	.LFE87:
 2369              		.section	.text.LPUART1_DriverIRQHandler,"ax",%progbits
 2370              		.align	1
 2371              		.global	LPUART1_DriverIRQHandler
 2372              		.syntax unified
 2373              		.code	16
 2374              		.thumb_func
 2375              		.fpu softvfp
 2377              	LPUART1_DriverIRQHandler:
 2378              	.LFB88:
1364:../drivers/fsl_lpuart.c **** #endif
1365:../drivers/fsl_lpuart.c **** #endif
1366:../drivers/fsl_lpuart.c **** #endif
1367:../drivers/fsl_lpuart.c **** 
1368:../drivers/fsl_lpuart.c **** #if defined(LPUART1)
1369:../drivers/fsl_lpuart.c **** #if !(defined(FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1) && FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1)
1370:../drivers/fsl_lpuart.c **** #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
1371:../drivers/fsl_lpuart.c **** void LPUART1_TX_DriverIRQHandler(void)
1372:../drivers/fsl_lpuart.c **** {
1373:../drivers/fsl_lpuart.c ****     s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
1374:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1375:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1376:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1377:../drivers/fsl_lpuart.c ****     __DSB();
1378:../drivers/fsl_lpuart.c **** #endif
1379:../drivers/fsl_lpuart.c **** }
1380:../drivers/fsl_lpuart.c **** void LPUART1_RX_DriverIRQHandler(void)
1381:../drivers/fsl_lpuart.c **** {
1382:../drivers/fsl_lpuart.c ****     s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
1383:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1384:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1385:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1386:../drivers/fsl_lpuart.c ****     __DSB();
1387:../drivers/fsl_lpuart.c **** #endif
1388:../drivers/fsl_lpuart.c **** }
1389:../drivers/fsl_lpuart.c **** #else
1390:../drivers/fsl_lpuart.c **** void LPUART1_DriverIRQHandler(void)
1391:../drivers/fsl_lpuart.c **** {
 2379              		.loc 1 1391 0
 2380              		.cfi_startproc
 2381              		@ args = 0, pretend = 0, frame = 0
 2382              		@ frame_needed = 0, uses_anonymous_args = 0
 2383 0000 10B5     		push	{r4, lr}
 2384              		.cfi_def_cfa_offset 8
 2385              		.cfi_offset 4, -8
 2386              		.cfi_offset 14, -4
1392:../drivers/fsl_lpuart.c ****     s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
 2387              		.loc 1 1392 0
 2388 0002 034B     		ldr	r3, .L162
 2389 0004 5968     		ldr	r1, [r3, #4]
 2390 0006 034B     		ldr	r3, .L162+4
 2391 0008 1B68     		ldr	r3, [r3]
 2392 000a 0348     		ldr	r0, .L162+8
 2393 000c 9847     		blx	r3
 2394              	.LVL284:
1393:../drivers/fsl_lpuart.c **** /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1394:../drivers/fsl_lpuart.c ****   exception return operation might vector to incorrect interrupt */
1395:../drivers/fsl_lpuart.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1396:../drivers/fsl_lpuart.c ****     __DSB();
1397:../drivers/fsl_lpuart.c **** #endif
1398:../drivers/fsl_lpuart.c **** }
 2395              		.loc 1 1398 0
 2396              		@ sp needed
 2397 000e 10BD     		pop	{r4, pc}
 2398              	.L163:
 2399              		.align	2
 2400              	.L162:
 2401 0010 00000000 		.word	.LANCHOR2
 2402 0014 00000000 		.word	.LANCHOR3
 2403 0018 00500540 		.word	1074089984
 2404              		.cfi_endproc
 2405              	.LFE88:
 2407              		.section	.bss.s_lpuartHandle,"aw",%nobits
 2408              		.align	2
 2409              		.set	.LANCHOR2,. + 0
 2412              	s_lpuartHandle:
 2413 0000 00000000 		.space	8
 2413      00000000 
 2414              		.section	.bss.s_lpuartIsr,"aw",%nobits
 2415              		.align	2
 2416              		.set	.LANCHOR3,. + 0
 2419              	s_lpuartIsr:
 2420 0000 00000000 		.space	4
 2421              		.section	.rodata.s_lpuartBases,"a",%progbits
 2422              		.align	2
 2423              		.set	.LANCHOR0,. + 0
 2426              	s_lpuartBases:
 2427 0000 00400540 		.word	1074085888
 2428 0004 00500540 		.word	1074089984
 2429              		.section	.rodata.s_lpuartClock,"a",%progbits
 2430              		.align	2
 2431              		.set	.LANCHOR1,. + 0
 2434              	s_lpuartClock:
 2435 0000 14003810 		.word	272105492
 2436 0004 15003810 		.word	272105493
 2437              		.section	.rodata.s_lpuartIRQ,"a",%progbits
 2438              		.align	2
 2439              		.set	.LANCHOR4,. + 0
 2442              	s_lpuartIRQ:
 2443 0000 0C       		.byte	12
 2444 0001 0D       		.byte	13
 2445              		.text
 2446              	.Letext0:
 2447              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 2448              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2449              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 2450              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 2451              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 2452              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 2453              		.file 11 "../CMSIS/MKL17Z4.h"
 2454              		.file 12 "../CMSIS/system_MKL17Z4.h"
 2455              		.file 13 "../drivers/fsl_lpuart.h"
 2456              		.file 14 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_lpuart.c
     /tmp/ccHVOscU.s:16     .text.LPUART_WriteNonBlocking:0000000000000000 $t
     /tmp/ccHVOscU.s:22     .text.LPUART_WriteNonBlocking:0000000000000000 LPUART_WriteNonBlocking
     /tmp/ccHVOscU.s:57     .text.LPUART_ReadNonBlocking:0000000000000000 $t
     /tmp/ccHVOscU.s:63     .text.LPUART_ReadNonBlocking:0000000000000000 LPUART_ReadNonBlocking
     /tmp/ccHVOscU.s:97     .text.LPUART_GetInstance:0000000000000000 $t
     /tmp/ccHVOscU.s:104    .text.LPUART_GetInstance:0000000000000000 LPUART_GetInstance
     /tmp/ccHVOscU.s:138    .text.LPUART_GetInstance:0000000000000018 $d
     /tmp/ccHVOscU.s:143    .text.LPUART_TransferGetRxRingBufferLength:0000000000000000 $t
     /tmp/ccHVOscU.s:150    .text.LPUART_TransferGetRxRingBufferLength:0000000000000000 LPUART_TransferGetRxRingBufferLength
     /tmp/ccHVOscU.s:191    .text.LPUART_TransferIsRxRingBufferFull:0000000000000000 $t
     /tmp/ccHVOscU.s:197    .text.LPUART_TransferIsRxRingBufferFull:0000000000000000 LPUART_TransferIsRxRingBufferFull
     /tmp/ccHVOscU.s:234    .text.LPUART_Init:0000000000000000 $t
     /tmp/ccHVOscU.s:241    .text.LPUART_Init:0000000000000000 LPUART_Init
     /tmp/ccHVOscU.s:573    .text.LPUART_Init:0000000000000178 $d
     /tmp/ccHVOscU.s:587    .text.LPUART_Deinit:0000000000000000 $t
     /tmp/ccHVOscU.s:594    .text.LPUART_Deinit:0000000000000000 LPUART_Deinit
     /tmp/ccHVOscU.s:655    .text.LPUART_Deinit:0000000000000038 $d
     /tmp/ccHVOscU.s:662    .text.LPUART_GetDefaultConfig:0000000000000000 $t
     /tmp/ccHVOscU.s:669    .text.LPUART_GetDefaultConfig:0000000000000000 LPUART_GetDefaultConfig
     /tmp/ccHVOscU.s:705    .text.LPUART_SetBaudRate:0000000000000000 $t
     /tmp/ccHVOscU.s:712    .text.LPUART_SetBaudRate:0000000000000000 LPUART_SetBaudRate
     /tmp/ccHVOscU.s:900    .text.LPUART_SetBaudRate:00000000000000c4 $d
     /tmp/ccHVOscU.s:907    .text.LPUART_EnableInterrupts:0000000000000000 $t
     /tmp/ccHVOscU.s:914    .text.LPUART_EnableInterrupts:0000000000000000 LPUART_EnableInterrupts
     /tmp/ccHVOscU.s:949    .text.LPUART_DisableInterrupts:0000000000000000 $t
     /tmp/ccHVOscU.s:956    .text.LPUART_DisableInterrupts:0000000000000000 LPUART_DisableInterrupts
     /tmp/ccHVOscU.s:990    .text.LPUART_TransferHandleIRQ:0000000000000000 $t
     /tmp/ccHVOscU.s:997    .text.LPUART_TransferHandleIRQ:0000000000000000 LPUART_TransferHandleIRQ
     /tmp/ccHVOscU.s:1316   .text.LPUART_TransferHandleIRQ:0000000000000198 $d
     /tmp/ccHVOscU.s:1327   .text.LPUART_GetEnabledInterrupts:0000000000000000 $t
     /tmp/ccHVOscU.s:1334   .text.LPUART_GetEnabledInterrupts:0000000000000000 LPUART_GetEnabledInterrupts
     /tmp/ccHVOscU.s:1361   .text.LPUART_GetEnabledInterrupts:0000000000000014 $d
     /tmp/ccHVOscU.s:1366   .text.LPUART_GetStatusFlags:0000000000000000 $t
     /tmp/ccHVOscU.s:1373   .text.LPUART_GetStatusFlags:0000000000000000 LPUART_GetStatusFlags
     /tmp/ccHVOscU.s:1391   .text.LPUART_ClearStatusFlags:0000000000000000 $t
     /tmp/ccHVOscU.s:1398   .text.LPUART_ClearStatusFlags:0000000000000000 LPUART_ClearStatusFlags
     /tmp/ccHVOscU.s:1465   .text.LPUART_ClearStatusFlags:0000000000000038 $d
     /tmp/ccHVOscU.s:1473   .text.LPUART_WriteBlocking:0000000000000000 $t
     /tmp/ccHVOscU.s:1480   .text.LPUART_WriteBlocking:0000000000000000 LPUART_WriteBlocking
     /tmp/ccHVOscU.s:1522   .text.LPUART_ReadBlocking:0000000000000000 $t
     /tmp/ccHVOscU.s:1529   .text.LPUART_ReadBlocking:0000000000000000 LPUART_ReadBlocking
     /tmp/ccHVOscU.s:1643   .text.LPUART_ReadBlocking:0000000000000070 $d
     /tmp/ccHVOscU.s:1650   .text.LPUART_TransferCreateHandle:0000000000000000 $t
     /tmp/ccHVOscU.s:1657   .text.LPUART_TransferCreateHandle:0000000000000000 LPUART_TransferCreateHandle
     /tmp/ccHVOscU.s:1752   .text.LPUART_TransferCreateHandle:0000000000000054 $d
     /tmp/ccHVOscU.s:1761   .text.LPUART_TransferStartRingBuffer:0000000000000000 $t
     /tmp/ccHVOscU.s:1768   .text.LPUART_TransferStartRingBuffer:0000000000000000 LPUART_TransferStartRingBuffer
     /tmp/ccHVOscU.s:1802   .text.LPUART_TransferStopRingBuffer:0000000000000000 $t
     /tmp/ccHVOscU.s:1809   .text.LPUART_TransferStopRingBuffer:0000000000000000 LPUART_TransferStopRingBuffer
     /tmp/ccHVOscU.s:1854   .text.LPUART_TransferSendNonBlocking:0000000000000000 $t
     /tmp/ccHVOscU.s:1861   .text.LPUART_TransferSendNonBlocking:0000000000000000 LPUART_TransferSendNonBlocking
     /tmp/ccHVOscU.s:1914   .text.LPUART_TransferSendNonBlocking:000000000000002c $d
     /tmp/ccHVOscU.s:1919   .text.LPUART_TransferAbortSend:0000000000000000 $t
     /tmp/ccHVOscU.s:1926   .text.LPUART_TransferAbortSend:0000000000000000 LPUART_TransferAbortSend
     /tmp/ccHVOscU.s:1958   .text.LPUART_TransferGetSendCount:0000000000000000 $t
     /tmp/ccHVOscU.s:1965   .text.LPUART_TransferGetSendCount:0000000000000000 LPUART_TransferGetSendCount
     /tmp/ccHVOscU.s:2001   .text.LPUART_TransferReceiveNonBlocking:0000000000000000 $t
     /tmp/ccHVOscU.s:2008   .text.LPUART_TransferReceiveNonBlocking:0000000000000000 LPUART_TransferReceiveNonBlocking
     /tmp/ccHVOscU.s:2212   .text.LPUART_TransferReceiveNonBlocking:00000000000000dc $d
     /tmp/ccHVOscU.s:2218   .text.LPUART_TransferAbortReceive:0000000000000000 $t
     /tmp/ccHVOscU.s:2225   .text.LPUART_TransferAbortReceive:0000000000000000 LPUART_TransferAbortReceive
     /tmp/ccHVOscU.s:2267   .text.LPUART_TransferGetReceiveCount:0000000000000000 $t
     /tmp/ccHVOscU.s:2274   .text.LPUART_TransferGetReceiveCount:0000000000000000 LPUART_TransferGetReceiveCount
     /tmp/ccHVOscU.s:2310   .text.LPUART_TransferHandleErrorIRQ:0000000000000000 $t
     /tmp/ccHVOscU.s:2317   .text.LPUART_TransferHandleErrorIRQ:0000000000000000 LPUART_TransferHandleErrorIRQ
     /tmp/ccHVOscU.s:2332   .text.LPUART0_DriverIRQHandler:0000000000000000 $t
     /tmp/ccHVOscU.s:2339   .text.LPUART0_DriverIRQHandler:0000000000000000 LPUART0_DriverIRQHandler
     /tmp/ccHVOscU.s:2363   .text.LPUART0_DriverIRQHandler:0000000000000010 $d
     /tmp/ccHVOscU.s:2370   .text.LPUART1_DriverIRQHandler:0000000000000000 $t
     /tmp/ccHVOscU.s:2377   .text.LPUART1_DriverIRQHandler:0000000000000000 LPUART1_DriverIRQHandler
     /tmp/ccHVOscU.s:2401   .text.LPUART1_DriverIRQHandler:0000000000000010 $d
     /tmp/ccHVOscU.s:2408   .bss.s_lpuartHandle:0000000000000000 $d
     /tmp/ccHVOscU.s:2412   .bss.s_lpuartHandle:0000000000000000 s_lpuartHandle
     /tmp/ccHVOscU.s:2415   .bss.s_lpuartIsr:0000000000000000 $d
     /tmp/ccHVOscU.s:2419   .bss.s_lpuartIsr:0000000000000000 s_lpuartIsr
     /tmp/ccHVOscU.s:2422   .rodata.s_lpuartBases:0000000000000000 $d
     /tmp/ccHVOscU.s:2426   .rodata.s_lpuartBases:0000000000000000 s_lpuartBases
     /tmp/ccHVOscU.s:2430   .rodata.s_lpuartClock:0000000000000000 $d
     /tmp/ccHVOscU.s:2434   .rodata.s_lpuartClock:0000000000000000 s_lpuartClock
     /tmp/ccHVOscU.s:2438   .rodata.s_lpuartIRQ:0000000000000000 $d
     /tmp/ccHVOscU.s:2442   .rodata.s_lpuartIRQ:0000000000000000 s_lpuartIRQ

UNDEFINED SYMBOLS
__aeabi_uidiv
memset
