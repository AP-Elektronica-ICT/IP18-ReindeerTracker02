   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_i2c.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_uidiv
  16              		.section	.text.I2C_SetHoldTime,"ax",%progbits
  17              		.align	1
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	I2C_SetHoldTime:
  24              	.LFB60:
  25              		.file 1 "../drivers/fsl_i2c.c"
   1:../drivers/fsl_i2c.c **** /*
   2:../drivers/fsl_i2c.c ****  * The Clear BSD License
   3:../drivers/fsl_i2c.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_i2c.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_i2c.c ****  * All rights reserved.
   6:../drivers/fsl_i2c.c ****  *
   7:../drivers/fsl_i2c.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_i2c.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_i2c.c ****  * that the following conditions are met:
  10:../drivers/fsl_i2c.c ****  *
  11:../drivers/fsl_i2c.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_i2c.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_i2c.c ****  *
  14:../drivers/fsl_i2c.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_i2c.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_i2c.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_i2c.c ****  *
  18:../drivers/fsl_i2c.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_i2c.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_i2c.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_i2c.c ****  *
  22:../drivers/fsl_i2c.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_i2c.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_i2c.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_i2c.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_i2c.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_i2c.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_i2c.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_i2c.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_i2c.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_i2c.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_i2c.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_i2c.c ****  */
  34:../drivers/fsl_i2c.c **** #include "fsl_i2c.h"
  35:../drivers/fsl_i2c.c **** 
  36:../drivers/fsl_i2c.c **** /*******************************************************************************
  37:../drivers/fsl_i2c.c ****  * Definitions
  38:../drivers/fsl_i2c.c ****  ******************************************************************************/
  39:../drivers/fsl_i2c.c **** 
  40:../drivers/fsl_i2c.c **** /*! @brief i2c transfer state. */
  41:../drivers/fsl_i2c.c **** enum _i2c_transfer_states
  42:../drivers/fsl_i2c.c **** {
  43:../drivers/fsl_i2c.c ****     kIdleState = 0x0U,             /*!< I2C bus idle. */
  44:../drivers/fsl_i2c.c ****     kCheckAddressState = 0x1U,     /*!< 7-bit address check state. */
  45:../drivers/fsl_i2c.c ****     kSendCommandState = 0x2U,      /*!< Send command byte phase. */
  46:../drivers/fsl_i2c.c ****     kSendDataState = 0x3U,         /*!< Send data transfer phase. */
  47:../drivers/fsl_i2c.c ****     kReceiveDataBeginState = 0x4U, /*!< Receive data transfer phase begin. */
  48:../drivers/fsl_i2c.c ****     kReceiveDataState = 0x5U,      /*!< Receive data transfer phase. */
  49:../drivers/fsl_i2c.c **** };
  50:../drivers/fsl_i2c.c **** 
  51:../drivers/fsl_i2c.c **** /*! @brief Common sets of flags used by the driver. */
  52:../drivers/fsl_i2c.c **** enum _i2c_flag_constants
  53:../drivers/fsl_i2c.c **** {
  54:../drivers/fsl_i2c.c **** /*! All flags which are cleared by the driver upon starting a transfer. */
  55:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
  56:../drivers/fsl_i2c.c ****     kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StartDetectFlag | kI2C_Stop
  57:../drivers/fsl_i2c.c ****     kIrqFlags = kI2C_GlobalInterruptEnable | kI2C_StartStopDetectInterruptEnable,
  58:../drivers/fsl_i2c.c **** #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
  59:../drivers/fsl_i2c.c ****     kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StopDetectFlag,
  60:../drivers/fsl_i2c.c ****     kIrqFlags = kI2C_GlobalInterruptEnable | kI2C_StopDetectInterruptEnable,
  61:../drivers/fsl_i2c.c **** #else
  62:../drivers/fsl_i2c.c ****     kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag,
  63:../drivers/fsl_i2c.c ****     kIrqFlags = kI2C_GlobalInterruptEnable,
  64:../drivers/fsl_i2c.c **** #endif
  65:../drivers/fsl_i2c.c **** 
  66:../drivers/fsl_i2c.c **** };
  67:../drivers/fsl_i2c.c **** 
  68:../drivers/fsl_i2c.c **** /*! @brief Typedef for interrupt handler. */
  69:../drivers/fsl_i2c.c **** typedef void (*i2c_isr_t)(I2C_Type *base, void *i2cHandle);
  70:../drivers/fsl_i2c.c **** 
  71:../drivers/fsl_i2c.c **** /*******************************************************************************
  72:../drivers/fsl_i2c.c ****  * Prototypes
  73:../drivers/fsl_i2c.c ****  ******************************************************************************/
  74:../drivers/fsl_i2c.c **** 
  75:../drivers/fsl_i2c.c **** /*!
  76:../drivers/fsl_i2c.c ****  * @brief Get instance number for I2C module.
  77:../drivers/fsl_i2c.c ****  *
  78:../drivers/fsl_i2c.c ****  * @param base I2C peripheral base address.
  79:../drivers/fsl_i2c.c ****  */
  80:../drivers/fsl_i2c.c **** uint32_t I2C_GetInstance(I2C_Type *base);
  81:../drivers/fsl_i2c.c **** 
  82:../drivers/fsl_i2c.c **** /*!
  83:../drivers/fsl_i2c.c **** * @brief Set SCL/SDA hold time, this API receives SCL stop hold time, calculate the
  84:../drivers/fsl_i2c.c **** * closest SCL divider and MULT value for the SDA hold time, SCL start and SCL stop
  85:../drivers/fsl_i2c.c **** * hold time. To reduce the ROM size, SDA/SCL hold value mapping table is not provided,
  86:../drivers/fsl_i2c.c **** * assume SCL divider = SCL stop hold value *2 to get the closest SCL divider value and MULT
  87:../drivers/fsl_i2c.c **** * value, then the related SDA hold time, SCL start and SCL stop hold time is used.
  88:../drivers/fsl_i2c.c **** *
  89:../drivers/fsl_i2c.c **** * @param base I2C peripheral base address.
  90:../drivers/fsl_i2c.c **** * @param sourceClock_Hz I2C functional clock frequency in Hertz.
  91:../drivers/fsl_i2c.c **** * @param sclStopHoldTime_ns SCL stop hold time in ns.
  92:../drivers/fsl_i2c.c **** */
  93:../drivers/fsl_i2c.c **** static void I2C_SetHoldTime(I2C_Type *base, uint32_t sclStopHoldTime_ns, uint32_t sourceClock_Hz);
  94:../drivers/fsl_i2c.c **** 
  95:../drivers/fsl_i2c.c **** /*!
  96:../drivers/fsl_i2c.c ****  * @brief Set up master transfer, send slave address and decide the initial
  97:../drivers/fsl_i2c.c ****  * transfer state.
  98:../drivers/fsl_i2c.c ****  *
  99:../drivers/fsl_i2c.c ****  * @param base I2C peripheral base address.
 100:../drivers/fsl_i2c.c ****  * @param handle pointer to i2c_master_handle_t structure which stores the transfer state.
 101:../drivers/fsl_i2c.c ****  * @param xfer pointer to i2c_master_transfer_t structure.
 102:../drivers/fsl_i2c.c ****  */
 103:../drivers/fsl_i2c.c **** static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_maste
 104:../drivers/fsl_i2c.c **** 
 105:../drivers/fsl_i2c.c **** /*!
 106:../drivers/fsl_i2c.c ****  * @brief Check and clear status operation.
 107:../drivers/fsl_i2c.c ****  *
 108:../drivers/fsl_i2c.c ****  * @param base I2C peripheral base address.
 109:../drivers/fsl_i2c.c ****  * @param status current i2c hardware status.
 110:../drivers/fsl_i2c.c ****  * @retval kStatus_Success No error found.
 111:../drivers/fsl_i2c.c ****  * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
 112:../drivers/fsl_i2c.c ****  * @retval kStatus_I2C_Nak Received Nak error.
 113:../drivers/fsl_i2c.c ****  */
 114:../drivers/fsl_i2c.c **** static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status);
 115:../drivers/fsl_i2c.c **** 
 116:../drivers/fsl_i2c.c **** /*!
 117:../drivers/fsl_i2c.c ****  * @brief Master run transfer state machine to perform a byte of transfer.
 118:../drivers/fsl_i2c.c ****  *
 119:../drivers/fsl_i2c.c ****  * @param base I2C peripheral base address.
 120:../drivers/fsl_i2c.c ****  * @param handle pointer to i2c_master_handle_t structure which stores the transfer state
 121:../drivers/fsl_i2c.c ****  * @param isDone input param to get whether the thing is done, true is done
 122:../drivers/fsl_i2c.c ****  * @retval kStatus_Success No error found.
 123:../drivers/fsl_i2c.c ****  * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
 124:../drivers/fsl_i2c.c ****  * @retval kStatus_I2C_Nak Received Nak error.
 125:../drivers/fsl_i2c.c ****  * @retval kStatus_I2C_Timeout Transfer error, wait signal timeout.
 126:../drivers/fsl_i2c.c ****  */
 127:../drivers/fsl_i2c.c **** static status_t I2C_MasterTransferRunStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool
 128:../drivers/fsl_i2c.c **** 
 129:../drivers/fsl_i2c.c **** /*!
 130:../drivers/fsl_i2c.c ****  * @brief I2C common interrupt handler.
 131:../drivers/fsl_i2c.c ****  *
 132:../drivers/fsl_i2c.c ****  * @param base I2C peripheral base address.
 133:../drivers/fsl_i2c.c ****  * @param handle pointer to i2c_master_handle_t structure which stores the transfer state
 134:../drivers/fsl_i2c.c ****  */
 135:../drivers/fsl_i2c.c **** static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle);
 136:../drivers/fsl_i2c.c **** 
 137:../drivers/fsl_i2c.c **** /*******************************************************************************
 138:../drivers/fsl_i2c.c ****  * Variables
 139:../drivers/fsl_i2c.c ****  ******************************************************************************/
 140:../drivers/fsl_i2c.c **** 
 141:../drivers/fsl_i2c.c **** /*! @brief Pointers to i2c handles for each instance. */
 142:../drivers/fsl_i2c.c **** static void *s_i2cHandle[FSL_FEATURE_SOC_I2C_COUNT] = {NULL};
 143:../drivers/fsl_i2c.c **** 
 144:../drivers/fsl_i2c.c **** /*! @brief SCL clock divider used to calculate baudrate. */
 145:../drivers/fsl_i2c.c **** static const uint16_t s_i2cDividerTable[] = {
 146:../drivers/fsl_i2c.c ****     20,  22,  24,  26,   28,   30,   34,   40,   28,   32,   36,   40,   44,   48,   56,   68,
 147:../drivers/fsl_i2c.c ****     48,  56,  64,  72,   80,   88,   104,  128,  80,   96,   112,  128,  144,  160,  192,  240,
 148:../drivers/fsl_i2c.c ****     160, 192, 224, 256,  288,  320,  384,  480,  320,  384,  448,  512,  576,  640,  768,  960,
 149:../drivers/fsl_i2c.c ****     640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840};
 150:../drivers/fsl_i2c.c **** 
 151:../drivers/fsl_i2c.c **** /*! @brief Pointers to i2c bases for each instance. */
 152:../drivers/fsl_i2c.c **** static I2C_Type *const s_i2cBases[] = I2C_BASE_PTRS;
 153:../drivers/fsl_i2c.c **** 
 154:../drivers/fsl_i2c.c **** /*! @brief Pointers to i2c IRQ number for each instance. */
 155:../drivers/fsl_i2c.c **** static const IRQn_Type s_i2cIrqs[] = I2C_IRQS;
 156:../drivers/fsl_i2c.c **** 
 157:../drivers/fsl_i2c.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 158:../drivers/fsl_i2c.c **** /*! @brief Pointers to i2c clocks for each instance. */
 159:../drivers/fsl_i2c.c **** static const clock_ip_name_t s_i2cClocks[] = I2C_CLOCKS;
 160:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 161:../drivers/fsl_i2c.c **** 
 162:../drivers/fsl_i2c.c **** /*! @brief Pointer to master IRQ handler for each instance. */
 163:../drivers/fsl_i2c.c **** static i2c_isr_t s_i2cMasterIsr;
 164:../drivers/fsl_i2c.c **** 
 165:../drivers/fsl_i2c.c **** /*! @brief Pointer to slave IRQ handler for each instance. */
 166:../drivers/fsl_i2c.c **** static i2c_isr_t s_i2cSlaveIsr;
 167:../drivers/fsl_i2c.c **** 
 168:../drivers/fsl_i2c.c **** /*******************************************************************************
 169:../drivers/fsl_i2c.c ****  * Codes
 170:../drivers/fsl_i2c.c ****  ******************************************************************************/
 171:../drivers/fsl_i2c.c **** 
 172:../drivers/fsl_i2c.c **** uint32_t I2C_GetInstance(I2C_Type *base)
 173:../drivers/fsl_i2c.c **** {
 174:../drivers/fsl_i2c.c ****     uint32_t instance;
 175:../drivers/fsl_i2c.c **** 
 176:../drivers/fsl_i2c.c ****     /* Find the instance index from base address mappings. */
 177:../drivers/fsl_i2c.c ****     for (instance = 0; instance < ARRAY_SIZE(s_i2cBases); instance++)
 178:../drivers/fsl_i2c.c ****     {
 179:../drivers/fsl_i2c.c ****         if (s_i2cBases[instance] == base)
 180:../drivers/fsl_i2c.c ****         {
 181:../drivers/fsl_i2c.c ****             break;
 182:../drivers/fsl_i2c.c ****         }
 183:../drivers/fsl_i2c.c ****     }
 184:../drivers/fsl_i2c.c **** 
 185:../drivers/fsl_i2c.c ****     assert(instance < ARRAY_SIZE(s_i2cBases));
 186:../drivers/fsl_i2c.c **** 
 187:../drivers/fsl_i2c.c ****     return instance;
 188:../drivers/fsl_i2c.c **** }
 189:../drivers/fsl_i2c.c **** 
 190:../drivers/fsl_i2c.c **** static void I2C_SetHoldTime(I2C_Type *base, uint32_t sclStopHoldTime_ns, uint32_t sourceClock_Hz)
 191:../drivers/fsl_i2c.c **** {
  26              		.loc 1 191 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 16
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  32              		.cfi_def_cfa_offset 20
  33              		.cfi_offset 4, -20
  34              		.cfi_offset 5, -16
  35              		.cfi_offset 6, -12
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 C646     		mov	lr, r8
  39 0004 00B5     		push	{lr}
  40              		.cfi_def_cfa_offset 24
  41              		.cfi_offset 8, -24
  42 0006 84B0     		sub	sp, sp, #16
  43              		.cfi_def_cfa_offset 40
  44 0008 8046     		mov	r8, r0
  45 000a 0F00     		movs	r7, r1
  46 000c 0092     		str	r2, [sp]
  47              	.LVL1:
 192:../drivers/fsl_i2c.c ****     uint32_t multiplier;
 193:../drivers/fsl_i2c.c ****     uint32_t computedSclHoldTime;
 194:../drivers/fsl_i2c.c ****     uint32_t absError;
 195:../drivers/fsl_i2c.c ****     uint32_t bestError = UINT32_MAX;
 196:../drivers/fsl_i2c.c ****     uint32_t bestMult = 0u;
 197:../drivers/fsl_i2c.c ****     uint32_t bestIcr = 0u;
 198:../drivers/fsl_i2c.c ****     uint8_t mult;
 199:../drivers/fsl_i2c.c ****     uint8_t i;
 200:../drivers/fsl_i2c.c **** 
 201:../drivers/fsl_i2c.c ****     /* Search for the settings with the lowest error. Mult is the MULT field of the I2C_F register,
 202:../drivers/fsl_i2c.c ****      * and ranges from 0-2. It selects the multiplier factor for the divider. */
 203:../drivers/fsl_i2c.c ****     /* SDA hold time = bus period (s) * mul * SDA hold value. */
 204:../drivers/fsl_i2c.c ****     /* SCL start hold time = bus period (s) * mul * SCL start hold value. */
 205:../drivers/fsl_i2c.c ****     /* SCL stop hold time = bus period (s) * mul * SCL stop hold value. */
 206:../drivers/fsl_i2c.c **** 
 207:../drivers/fsl_i2c.c ****     for (mult = 0u; (mult <= 2u) && (bestError != 0); ++mult)
  48              		.loc 1 207 0
  49 000e 0023     		movs	r3, #0
  50 0010 0193     		str	r3, [sp, #4]
 197:../drivers/fsl_i2c.c ****     uint8_t mult;
  51              		.loc 1 197 0
  52 0012 0393     		str	r3, [sp, #12]
 196:../drivers/fsl_i2c.c ****     uint32_t bestIcr = 0u;
  53              		.loc 1 196 0
  54 0014 0293     		str	r3, [sp, #8]
 195:../drivers/fsl_i2c.c ****     uint32_t bestMult = 0u;
  55              		.loc 1 195 0
  56 0016 0126     		movs	r6, #1
  57 0018 7642     		rsbs	r6, r6, #0
  58              		.loc 1 207 0
  59 001a 20E0     		b	.L2
  60              	.LVL2:
  61              	.L4:
 208:../drivers/fsl_i2c.c ****     {
 209:../drivers/fsl_i2c.c ****         multiplier = 1u << mult;
 210:../drivers/fsl_i2c.c **** 
 211:../drivers/fsl_i2c.c ****         /* Scan table to find best match. */
 212:../drivers/fsl_i2c.c ****         for (i = 0u; i < sizeof(s_i2cDividerTable) / sizeof(s_i2cDividerTable[0]); ++i)
 213:../drivers/fsl_i2c.c ****         {
 214:../drivers/fsl_i2c.c ****             /* Assume SCL hold(stop) value = s_i2cDividerTable[i]/2. */
 215:../drivers/fsl_i2c.c ****             computedSclHoldTime = ((multiplier * s_i2cDividerTable[i]) * 500000000U) / sourceClock_
 216:../drivers/fsl_i2c.c ****             absError = sclStopHoldTime_ns > computedSclHoldTime ? (sclStopHoldTime_ns - computedScl
  62              		.loc 1 216 0 discriminator 2
  63 001c C01B     		subs	r0, r0, r7
  64              	.LVL3:
  65 001e 0FE0     		b	.L5
  66              	.LVL4:
  67              	.L6:
 212:../drivers/fsl_i2c.c ****         {
  68              		.loc 1 212 0 discriminator 2
  69 0020 0134     		adds	r4, r4, #1
  70              	.LVL5:
  71 0022 E4B2     		uxtb	r4, r4
  72              	.LVL6:
  73              	.L3:
 212:../drivers/fsl_i2c.c ****         {
  74              		.loc 1 212 0 is_stmt 0 discriminator 1
  75 0024 3F2C     		cmp	r4, #63
  76 0026 14D8     		bhi	.L11
 215:../drivers/fsl_i2c.c ****             absError = sclStopHoldTime_ns > computedSclHoldTime ? (sclStopHoldTime_ns - computedScl
  77              		.loc 1 215 0 is_stmt 1
  78 0028 6300     		lsls	r3, r4, #1
  79 002a 184A     		ldr	r2, .L12
  80 002c 9B5A     		ldrh	r3, [r3, r2]
  81 002e AB40     		lsls	r3, r3, r5
  82 0030 1748     		ldr	r0, .L12+4
  83 0032 5843     		muls	r0, r3
  84 0034 0099     		ldr	r1, [sp]
  85 0036 FFF7FEFF 		bl	__aeabi_uidiv
  86              	.LVL7:
  87              		.loc 1 216 0
  88 003a B842     		cmp	r0, r7
  89 003c EED2     		bcs	.L4
  90              		.loc 1 216 0 is_stmt 0 discriminator 1
  91 003e 381A     		subs	r0, r7, r0
  92              	.LVL8:
  93              	.L5:
 217:../drivers/fsl_i2c.c ****                                                                   (computedSclHoldTime - sclStopHol
 218:../drivers/fsl_i2c.c **** 
 219:../drivers/fsl_i2c.c ****             if (absError < bestError)
  94              		.loc 1 219 0 is_stmt 1 discriminator 4
  95 0040 8642     		cmp	r6, r0
  96 0042 EDD9     		bls	.L6
 220:../drivers/fsl_i2c.c ****             {
 221:../drivers/fsl_i2c.c ****                 bestMult = mult;
  97              		.loc 1 221 0
  98 0044 019B     		ldr	r3, [sp, #4]
  99 0046 0293     		str	r3, [sp, #8]
 100              	.LVL9:
 222:../drivers/fsl_i2c.c ****                 bestIcr = i;
 101              		.loc 1 222 0
 102 0048 0394     		str	r4, [sp, #12]
 103              	.LVL10:
 223:../drivers/fsl_i2c.c ****                 bestError = absError;
 224:../drivers/fsl_i2c.c **** 
 225:../drivers/fsl_i2c.c ****                 /* If the error is 0, then we can stop searching because we won't find a better mat
 226:../drivers/fsl_i2c.c ****                 if (absError == 0)
 104              		.loc 1 226 0
 105 004a 0028     		cmp	r0, #0
 106 004c 02D0     		beq	.L7
 107              	.LVL11:
 223:../drivers/fsl_i2c.c ****                 bestError = absError;
 108              		.loc 1 223 0
 109 004e 0600     		movs	r6, r0
 110 0050 E6E7     		b	.L6
 111              	.LVL12:
 112              	.L11:
 113 0052 3000     		movs	r0, r6
 114              	.LVL13:
 115              	.L7:
 207:../drivers/fsl_i2c.c ****     {
 116              		.loc 1 207 0 discriminator 2
 117 0054 019D     		ldr	r5, [sp, #4]
 118              	.LVL14:
 119 0056 0135     		adds	r5, r5, #1
 120 0058 EBB2     		uxtb	r3, r5
 121 005a 0193     		str	r3, [sp, #4]
 122              	.LVL15:
 123 005c 0600     		movs	r6, r0
 124              	.LVL16:
 125              	.L2:
 207:../drivers/fsl_i2c.c ****     {
 126              		.loc 1 207 0 is_stmt 0 discriminator 1
 127 005e 019B     		ldr	r3, [sp, #4]
 128 0060 022B     		cmp	r3, #2
 129 0062 04D8     		bhi	.L9
 207:../drivers/fsl_i2c.c ****     {
 130              		.loc 1 207 0 discriminator 3
 131 0064 002E     		cmp	r6, #0
 132 0066 02D0     		beq	.L9
 209:../drivers/fsl_i2c.c **** 
 133              		.loc 1 209 0 is_stmt 1
 134 0068 019D     		ldr	r5, [sp, #4]
 135              	.LVL17:
 212:../drivers/fsl_i2c.c ****         {
 136              		.loc 1 212 0
 137 006a 0024     		movs	r4, #0
 138 006c DAE7     		b	.L3
 139              	.LVL18:
 140              	.L9:
 227:../drivers/fsl_i2c.c ****                 {
 228:../drivers/fsl_i2c.c ****                     break;
 229:../drivers/fsl_i2c.c ****                 }
 230:../drivers/fsl_i2c.c ****             }
 231:../drivers/fsl_i2c.c ****         }
 232:../drivers/fsl_i2c.c ****     }
 233:../drivers/fsl_i2c.c **** 
 234:../drivers/fsl_i2c.c ****     /* Set frequency register based on best settings. */
 235:../drivers/fsl_i2c.c ****     base->F = I2C_F_MULT(bestMult) | I2C_F_ICR(bestIcr);
 141              		.loc 1 235 0
 142 006e 6B46     		mov	r3, sp
 143 0070 1E7A     		ldrb	r6, [r3, #8]
 144              	.LVL19:
 145 0072 B601     		lsls	r6, r6, #6
 146 0074 F6B2     		uxtb	r6, r6
 147 0076 3F22     		movs	r2, #63
 148 0078 039F     		ldr	r7, [sp, #12]
 149              	.LVL20:
 150 007a 1740     		ands	r7, r2
 151 007c 3743     		orrs	r7, r6
 152 007e 4346     		mov	r3, r8
 153 0080 5F70     		strb	r7, [r3, #1]
 236:../drivers/fsl_i2c.c **** }
 154              		.loc 1 236 0
 155 0082 04B0     		add	sp, sp, #16
 156              	.LVL21:
 157              		@ sp needed
 158              	.LVL22:
 159 0084 04BC     		pop	{r2}
 160 0086 9046     		mov	r8, r2
 161 0088 F0BD     		pop	{r4, r5, r6, r7, pc}
 162              	.L13:
 163 008a C046     		.align	2
 164              	.L12:
 165 008c 00000000 		.word	s_i2cDividerTable
 166 0090 0065CD1D 		.word	500000000
 167              		.cfi_endproc
 168              	.LFE60:
 170              		.section	.text.I2C_CheckAndClearError,"ax",%progbits
 171              		.align	1
 172              		.syntax unified
 173              		.code	16
 174              		.thumb_func
 175              		.fpu softvfp
 177              	I2C_CheckAndClearError:
 178              	.LFB62:
 237:../drivers/fsl_i2c.c **** 
 238:../drivers/fsl_i2c.c **** static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_maste
 239:../drivers/fsl_i2c.c **** {
 240:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 241:../drivers/fsl_i2c.c ****     i2c_direction_t direction = xfer->direction;
 242:../drivers/fsl_i2c.c **** 
 243:../drivers/fsl_i2c.c ****     /* Initialize the handle transfer information. */
 244:../drivers/fsl_i2c.c ****     handle->transfer = *xfer;
 245:../drivers/fsl_i2c.c **** 
 246:../drivers/fsl_i2c.c ****     /* Save total transfer size. */
 247:../drivers/fsl_i2c.c ****     handle->transferSize = xfer->dataSize;
 248:../drivers/fsl_i2c.c **** 
 249:../drivers/fsl_i2c.c ****     /* Initial transfer state. */
 250:../drivers/fsl_i2c.c ****     if (handle->transfer.subaddressSize > 0)
 251:../drivers/fsl_i2c.c ****     {
 252:../drivers/fsl_i2c.c ****         if (xfer->direction == kI2C_Read)
 253:../drivers/fsl_i2c.c ****         {
 254:../drivers/fsl_i2c.c ****             direction = kI2C_Write;
 255:../drivers/fsl_i2c.c ****         }
 256:../drivers/fsl_i2c.c ****     }
 257:../drivers/fsl_i2c.c **** 
 258:../drivers/fsl_i2c.c ****     handle->state = kCheckAddressState;
 259:../drivers/fsl_i2c.c **** 
 260:../drivers/fsl_i2c.c ****     /* Clear all status before transfer. */
 261:../drivers/fsl_i2c.c ****     I2C_MasterClearStatusFlags(base, kClearFlags);
 262:../drivers/fsl_i2c.c **** 
 263:../drivers/fsl_i2c.c ****     /* Handle no start option. */
 264:../drivers/fsl_i2c.c ****     if (handle->transfer.flags & kI2C_TransferNoStartFlag)
 265:../drivers/fsl_i2c.c ****     {
 266:../drivers/fsl_i2c.c ****         /* No need to send start flag, directly go to send command or data */
 267:../drivers/fsl_i2c.c ****         if (handle->transfer.subaddressSize > 0)
 268:../drivers/fsl_i2c.c ****         {
 269:../drivers/fsl_i2c.c ****             handle->state = kSendCommandState;
 270:../drivers/fsl_i2c.c ****         }
 271:../drivers/fsl_i2c.c ****         else
 272:../drivers/fsl_i2c.c ****         {
 273:../drivers/fsl_i2c.c ****             if (direction == kI2C_Write)
 274:../drivers/fsl_i2c.c ****             {
 275:../drivers/fsl_i2c.c ****                 /* Next state, send data. */
 276:../drivers/fsl_i2c.c ****                 handle->state = kSendDataState;
 277:../drivers/fsl_i2c.c ****             }
 278:../drivers/fsl_i2c.c ****             else
 279:../drivers/fsl_i2c.c ****             {
 280:../drivers/fsl_i2c.c ****                 /* Only support write with no stop signal. */
 281:../drivers/fsl_i2c.c ****                 return kStatus_InvalidArgument;
 282:../drivers/fsl_i2c.c ****             }
 283:../drivers/fsl_i2c.c ****         }
 284:../drivers/fsl_i2c.c **** 
 285:../drivers/fsl_i2c.c ****         /* Wait for TCF bit and manually trigger tx interrupt. */
 286:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_TransferCompleteFlag))
 287:../drivers/fsl_i2c.c ****         {
 288:../drivers/fsl_i2c.c ****         }
 289:../drivers/fsl_i2c.c ****         I2C_MasterTransferHandleIRQ(base, handle);
 290:../drivers/fsl_i2c.c ****     }
 291:../drivers/fsl_i2c.c ****     /* If repeated start is requested, send repeated start. */
 292:../drivers/fsl_i2c.c ****     else if (handle->transfer.flags & kI2C_TransferRepeatedStartFlag)
 293:../drivers/fsl_i2c.c ****     {
 294:../drivers/fsl_i2c.c ****         result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, direction);
 295:../drivers/fsl_i2c.c ****     }
 296:../drivers/fsl_i2c.c ****     else /* For normal transfer, send start. */
 297:../drivers/fsl_i2c.c ****     {
 298:../drivers/fsl_i2c.c ****         result = I2C_MasterStart(base, handle->transfer.slaveAddress, direction);
 299:../drivers/fsl_i2c.c ****     }
 300:../drivers/fsl_i2c.c **** 
 301:../drivers/fsl_i2c.c ****     return result;
 302:../drivers/fsl_i2c.c **** }
 303:../drivers/fsl_i2c.c **** 
 304:../drivers/fsl_i2c.c **** static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status)
 305:../drivers/fsl_i2c.c **** {
 179              		.loc 1 305 0
 180              		.cfi_startproc
 181              		@ args = 0, pretend = 0, frame = 0
 182              		@ frame_needed = 0, uses_anonymous_args = 0
 183              		@ link register save eliminated.
 184              	.LVL23:
 306:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 307:../drivers/fsl_i2c.c **** 
 308:../drivers/fsl_i2c.c ****     /* Check arbitration lost. */
 309:../drivers/fsl_i2c.c ****     if (status & kI2C_ArbitrationLostFlag)
 185              		.loc 1 309 0
 186 0000 CB06     		lsls	r3, r1, #27
 187 0002 03D4     		bmi	.L18
 310:../drivers/fsl_i2c.c ****     {
 311:../drivers/fsl_i2c.c ****         /* Clear arbitration lost flag. */
 312:../drivers/fsl_i2c.c ****         base->S = kI2C_ArbitrationLostFlag;
 313:../drivers/fsl_i2c.c ****         result = kStatus_I2C_ArbitrationLost;
 314:../drivers/fsl_i2c.c ****     }
 315:../drivers/fsl_i2c.c ****     /* Check NAK */
 316:../drivers/fsl_i2c.c ****     else if (status & kI2C_ReceiveNakFlag)
 188              		.loc 1 316 0
 189 0004 CB07     		lsls	r3, r1, #31
 190 0006 05D4     		bmi	.L17
 306:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 191              		.loc 1 306 0
 192 0008 0020     		movs	r0, #0
 193              	.LVL24:
 194              	.L14:
 317:../drivers/fsl_i2c.c ****     {
 318:../drivers/fsl_i2c.c ****         result = kStatus_I2C_Nak;
 319:../drivers/fsl_i2c.c ****     }
 320:../drivers/fsl_i2c.c ****     else
 321:../drivers/fsl_i2c.c ****     {
 322:../drivers/fsl_i2c.c ****     }
 323:../drivers/fsl_i2c.c **** 
 324:../drivers/fsl_i2c.c ****     return result;
 325:../drivers/fsl_i2c.c **** }
 195              		.loc 1 325 0
 196              		@ sp needed
 197 000a 7047     		bx	lr
 198              	.LVL25:
 199              	.L18:
 312:../drivers/fsl_i2c.c ****         result = kStatus_I2C_ArbitrationLost;
 200              		.loc 1 312 0
 201 000c 1023     		movs	r3, #16
 202 000e C370     		strb	r3, [r0, #3]
 203              	.LVL26:
 313:../drivers/fsl_i2c.c ****     }
 204              		.loc 1 313 0
 205 0010 0148     		ldr	r0, .L19
 206              	.LVL27:
 207 0012 FAE7     		b	.L14
 208              	.LVL28:
 209              	.L17:
 318:../drivers/fsl_i2c.c ****     }
 210              		.loc 1 318 0
 211 0014 0148     		ldr	r0, .L19+4
 212              	.LVL29:
 324:../drivers/fsl_i2c.c **** }
 213              		.loc 1 324 0
 214 0016 F8E7     		b	.L14
 215              	.L20:
 216              		.align	2
 217              	.L19:
 218 0018 4F040000 		.word	1103
 219 001c 4E040000 		.word	1102
 220              		.cfi_endproc
 221              	.LFE62:
 223              		.section	.text.I2C_TransferCommonIRQHandler,"ax",%progbits
 224              		.align	1
 225              		.syntax unified
 226              		.code	16
 227              		.thumb_func
 228              		.fpu softvfp
 230              	I2C_TransferCommonIRQHandler:
 231              	.LFB64:
 326:../drivers/fsl_i2c.c **** 
 327:../drivers/fsl_i2c.c **** static status_t I2C_MasterTransferRunStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool
 328:../drivers/fsl_i2c.c **** {
 329:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 330:../drivers/fsl_i2c.c ****     uint32_t statusFlags = base->S;
 331:../drivers/fsl_i2c.c ****     *isDone = false;
 332:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
 333:../drivers/fsl_i2c.c ****     bool ignoreNak = ((handle->state == kSendDataState) && (handle->transfer.dataSize == 0U)) ||
 334:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 335:../drivers/fsl_i2c.c **** 
 336:../drivers/fsl_i2c.c ****     /* Add this to avoid build warning. */
 337:../drivers/fsl_i2c.c ****     dummy++;
 338:../drivers/fsl_i2c.c **** 
 339:../drivers/fsl_i2c.c ****     /* Check & clear error flags. */
 340:../drivers/fsl_i2c.c ****     result = I2C_CheckAndClearError(base, statusFlags);
 341:../drivers/fsl_i2c.c **** 
 342:../drivers/fsl_i2c.c ****     /* Ignore Nak when it's appeared for last byte. */
 343:../drivers/fsl_i2c.c ****     if ((result == kStatus_I2C_Nak) && ignoreNak)
 344:../drivers/fsl_i2c.c ****     {
 345:../drivers/fsl_i2c.c ****         result = kStatus_Success;
 346:../drivers/fsl_i2c.c ****     }
 347:../drivers/fsl_i2c.c **** 
 348:../drivers/fsl_i2c.c ****     /* Handle Check address state to check the slave address is Acked in slave
 349:../drivers/fsl_i2c.c ****        probe application. */
 350:../drivers/fsl_i2c.c ****     if (handle->state == kCheckAddressState)
 351:../drivers/fsl_i2c.c ****     {
 352:../drivers/fsl_i2c.c ****         if (statusFlags & kI2C_ReceiveNakFlag)
 353:../drivers/fsl_i2c.c ****         {
 354:../drivers/fsl_i2c.c ****             result = kStatus_I2C_Addr_Nak;
 355:../drivers/fsl_i2c.c ****         }
 356:../drivers/fsl_i2c.c ****         else
 357:../drivers/fsl_i2c.c ****         {
 358:../drivers/fsl_i2c.c ****             if (handle->transfer.subaddressSize > 0)
 359:../drivers/fsl_i2c.c ****             {
 360:../drivers/fsl_i2c.c ****                 handle->state = kSendCommandState;
 361:../drivers/fsl_i2c.c ****             }
 362:../drivers/fsl_i2c.c ****             else
 363:../drivers/fsl_i2c.c ****             {
 364:../drivers/fsl_i2c.c ****                 if (handle->transfer.direction == kI2C_Write)
 365:../drivers/fsl_i2c.c ****                 {
 366:../drivers/fsl_i2c.c ****                     /* Next state, send data. */
 367:../drivers/fsl_i2c.c ****                     handle->state = kSendDataState;
 368:../drivers/fsl_i2c.c ****                 }
 369:../drivers/fsl_i2c.c ****                 else
 370:../drivers/fsl_i2c.c ****                 {
 371:../drivers/fsl_i2c.c ****                     /* Next state, receive data begin. */
 372:../drivers/fsl_i2c.c ****                     handle->state = kReceiveDataBeginState;
 373:../drivers/fsl_i2c.c ****                 }
 374:../drivers/fsl_i2c.c ****             }
 375:../drivers/fsl_i2c.c ****         }
 376:../drivers/fsl_i2c.c ****     }
 377:../drivers/fsl_i2c.c **** 
 378:../drivers/fsl_i2c.c ****     if (result)
 379:../drivers/fsl_i2c.c ****     {
 380:../drivers/fsl_i2c.c ****         return result;
 381:../drivers/fsl_i2c.c ****     }
 382:../drivers/fsl_i2c.c **** 
 383:../drivers/fsl_i2c.c ****     /* Run state machine. */
 384:../drivers/fsl_i2c.c ****     switch (handle->state)
 385:../drivers/fsl_i2c.c ****     {
 386:../drivers/fsl_i2c.c ****         /* Send I2C command. */
 387:../drivers/fsl_i2c.c ****         case kSendCommandState:
 388:../drivers/fsl_i2c.c ****             if (handle->transfer.subaddressSize)
 389:../drivers/fsl_i2c.c ****             {
 390:../drivers/fsl_i2c.c ****                 handle->transfer.subaddressSize--;
 391:../drivers/fsl_i2c.c ****                 base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
 392:../drivers/fsl_i2c.c ****             }
 393:../drivers/fsl_i2c.c ****             else
 394:../drivers/fsl_i2c.c ****             {
 395:../drivers/fsl_i2c.c ****                 if (handle->transfer.direction == kI2C_Write)
 396:../drivers/fsl_i2c.c ****                 {
 397:../drivers/fsl_i2c.c ****                     /* Next state, send data. */
 398:../drivers/fsl_i2c.c ****                     handle->state = kSendDataState;
 399:../drivers/fsl_i2c.c **** 
 400:../drivers/fsl_i2c.c ****                     /* Send first byte of data. */
 401:../drivers/fsl_i2c.c ****                     if (handle->transfer.dataSize > 0)
 402:../drivers/fsl_i2c.c ****                     {
 403:../drivers/fsl_i2c.c ****                         base->D = *handle->transfer.data;
 404:../drivers/fsl_i2c.c ****                         handle->transfer.data++;
 405:../drivers/fsl_i2c.c ****                         handle->transfer.dataSize--;
 406:../drivers/fsl_i2c.c ****                     }
 407:../drivers/fsl_i2c.c ****                 }
 408:../drivers/fsl_i2c.c ****                 else
 409:../drivers/fsl_i2c.c ****                 {
 410:../drivers/fsl_i2c.c ****                     /* Send repeated start and slave address. */
 411:../drivers/fsl_i2c.c ****                     result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, kI2C_Read
 412:../drivers/fsl_i2c.c **** 
 413:../drivers/fsl_i2c.c ****                     /* Next state, receive data begin. */
 414:../drivers/fsl_i2c.c ****                     handle->state = kReceiveDataBeginState;
 415:../drivers/fsl_i2c.c ****                 }
 416:../drivers/fsl_i2c.c ****             }
 417:../drivers/fsl_i2c.c ****             break;
 418:../drivers/fsl_i2c.c **** 
 419:../drivers/fsl_i2c.c ****         /* Send I2C data. */
 420:../drivers/fsl_i2c.c ****         case kSendDataState:
 421:../drivers/fsl_i2c.c ****             /* Send one byte of data. */
 422:../drivers/fsl_i2c.c ****             if (handle->transfer.dataSize > 0)
 423:../drivers/fsl_i2c.c ****             {
 424:../drivers/fsl_i2c.c ****                 base->D = *handle->transfer.data;
 425:../drivers/fsl_i2c.c ****                 handle->transfer.data++;
 426:../drivers/fsl_i2c.c ****                 handle->transfer.dataSize--;
 427:../drivers/fsl_i2c.c ****             }
 428:../drivers/fsl_i2c.c ****             else
 429:../drivers/fsl_i2c.c ****             {
 430:../drivers/fsl_i2c.c ****                 *isDone = true;
 431:../drivers/fsl_i2c.c ****             }
 432:../drivers/fsl_i2c.c ****             break;
 433:../drivers/fsl_i2c.c **** 
 434:../drivers/fsl_i2c.c ****         /* Start I2C data receive. */
 435:../drivers/fsl_i2c.c ****         case kReceiveDataBeginState:
 436:../drivers/fsl_i2c.c ****             base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
 437:../drivers/fsl_i2c.c **** 
 438:../drivers/fsl_i2c.c ****             /* Send nak at the last receive byte. */
 439:../drivers/fsl_i2c.c ****             if (handle->transfer.dataSize == 1)
 440:../drivers/fsl_i2c.c ****             {
 441:../drivers/fsl_i2c.c ****                 base->C1 |= I2C_C1_TXAK_MASK;
 442:../drivers/fsl_i2c.c ****             }
 443:../drivers/fsl_i2c.c **** 
 444:../drivers/fsl_i2c.c ****             /* Read dummy to release the bus. */
 445:../drivers/fsl_i2c.c ****             dummy = base->D;
 446:../drivers/fsl_i2c.c **** 
 447:../drivers/fsl_i2c.c ****             /* Next state, receive data. */
 448:../drivers/fsl_i2c.c ****             handle->state = kReceiveDataState;
 449:../drivers/fsl_i2c.c ****             break;
 450:../drivers/fsl_i2c.c **** 
 451:../drivers/fsl_i2c.c ****         /* Receive I2C data. */
 452:../drivers/fsl_i2c.c ****         case kReceiveDataState:
 453:../drivers/fsl_i2c.c ****             /* Receive one byte of data. */
 454:../drivers/fsl_i2c.c ****             if (handle->transfer.dataSize--)
 455:../drivers/fsl_i2c.c ****             {
 456:../drivers/fsl_i2c.c ****                 if (handle->transfer.dataSize == 0)
 457:../drivers/fsl_i2c.c ****                 {
 458:../drivers/fsl_i2c.c ****                     *isDone = true;
 459:../drivers/fsl_i2c.c **** 
 460:../drivers/fsl_i2c.c ****                     /* Send stop if kI2C_TransferNoStop is not asserted. */
 461:../drivers/fsl_i2c.c ****                     if (!(handle->transfer.flags & kI2C_TransferNoStopFlag))
 462:../drivers/fsl_i2c.c ****                     {
 463:../drivers/fsl_i2c.c ****                         result = I2C_MasterStop(base);
 464:../drivers/fsl_i2c.c ****                     }
 465:../drivers/fsl_i2c.c ****                     else
 466:../drivers/fsl_i2c.c ****                     {
 467:../drivers/fsl_i2c.c ****                         base->C1 |= I2C_C1_TX_MASK;
 468:../drivers/fsl_i2c.c ****                     }
 469:../drivers/fsl_i2c.c ****                 }
 470:../drivers/fsl_i2c.c **** 
 471:../drivers/fsl_i2c.c ****                 /* Send NAK at the last receive byte. */
 472:../drivers/fsl_i2c.c ****                 if (handle->transfer.dataSize == 1)
 473:../drivers/fsl_i2c.c ****                 {
 474:../drivers/fsl_i2c.c ****                     base->C1 |= I2C_C1_TXAK_MASK;
 475:../drivers/fsl_i2c.c ****                 }
 476:../drivers/fsl_i2c.c **** 
 477:../drivers/fsl_i2c.c ****                 /* Read the data byte into the transfer buffer. */
 478:../drivers/fsl_i2c.c ****                 *handle->transfer.data = base->D;
 479:../drivers/fsl_i2c.c ****                 handle->transfer.data++;
 480:../drivers/fsl_i2c.c ****             }
 481:../drivers/fsl_i2c.c ****             break;
 482:../drivers/fsl_i2c.c **** 
 483:../drivers/fsl_i2c.c ****         default:
 484:../drivers/fsl_i2c.c ****             break;
 485:../drivers/fsl_i2c.c ****     }
 486:../drivers/fsl_i2c.c **** 
 487:../drivers/fsl_i2c.c ****     return result;
 488:../drivers/fsl_i2c.c **** }
 489:../drivers/fsl_i2c.c **** 
 490:../drivers/fsl_i2c.c **** static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle)
 491:../drivers/fsl_i2c.c **** {
 232              		.loc 1 491 0
 233              		.cfi_startproc
 234              		@ args = 0, pretend = 0, frame = 0
 235              		@ frame_needed = 0, uses_anonymous_args = 0
 236              	.LVL30:
 237 0000 10B5     		push	{r4, lr}
 238              		.cfi_def_cfa_offset 8
 239              		.cfi_offset 4, -8
 240              		.cfi_offset 14, -4
 492:../drivers/fsl_i2c.c ****     /* Check if master interrupt. */
 493:../drivers/fsl_i2c.c ****     if ((base->S & kI2C_ArbitrationLostFlag) || (base->C1 & I2C_C1_MST_MASK))
 241              		.loc 1 493 0
 242 0002 C378     		ldrb	r3, [r0, #3]
 243 0004 DB06     		lsls	r3, r3, #27
 244 0006 05D5     		bpl	.L25
 245              	.L22:
 494:../drivers/fsl_i2c.c ****     {
 495:../drivers/fsl_i2c.c ****         s_i2cMasterIsr(base, handle);
 246              		.loc 1 495 0
 247 0008 064B     		ldr	r3, .L26
 248 000a 1B68     		ldr	r3, [r3]
 249 000c 9847     		blx	r3
 250              	.LVL31:
 251              	.L24:
 252              	.LBB45:
 253              	.LBB46:
 254              		.file 2 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 412:../CMSIS/cmsis_gcc.h **** }
 413:../CMSIS/cmsis_gcc.h **** 
 414:../CMSIS/cmsis_gcc.h **** 
 415:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 416:../CMSIS/cmsis_gcc.h **** /**
 417:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 418:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 419:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 420:../CMSIS/cmsis_gcc.h ****  */
 421:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 422:../CMSIS/cmsis_gcc.h **** {
 423:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 424:../CMSIS/cmsis_gcc.h **** }
 425:../CMSIS/cmsis_gcc.h **** #endif
 426:../CMSIS/cmsis_gcc.h **** 
 427:../CMSIS/cmsis_gcc.h **** 
 428:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 429:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 430:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 431:../CMSIS/cmsis_gcc.h **** /**
 432:../CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 433:../CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 434:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 435:../CMSIS/cmsis_gcc.h ****  */
 436:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 437:../CMSIS/cmsis_gcc.h **** {
 438:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 439:../CMSIS/cmsis_gcc.h **** }
 440:../CMSIS/cmsis_gcc.h **** 
 441:../CMSIS/cmsis_gcc.h **** 
 442:../CMSIS/cmsis_gcc.h **** /**
 443:../CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 444:../CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 445:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 446:../CMSIS/cmsis_gcc.h ****  */
 447:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 448:../CMSIS/cmsis_gcc.h **** {
 449:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 450:../CMSIS/cmsis_gcc.h **** }
 451:../CMSIS/cmsis_gcc.h **** 
 452:../CMSIS/cmsis_gcc.h **** 
 453:../CMSIS/cmsis_gcc.h **** /**
 454:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 455:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 456:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 457:../CMSIS/cmsis_gcc.h ****  */
 458:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 459:../CMSIS/cmsis_gcc.h **** {
 460:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 461:../CMSIS/cmsis_gcc.h **** 
 462:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 463:../CMSIS/cmsis_gcc.h ****   return(result);
 464:../CMSIS/cmsis_gcc.h **** }
 465:../CMSIS/cmsis_gcc.h **** 
 466:../CMSIS/cmsis_gcc.h **** 
 467:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 468:../CMSIS/cmsis_gcc.h **** /**
 469:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 470:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 471:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 472:../CMSIS/cmsis_gcc.h ****  */
 473:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 474:../CMSIS/cmsis_gcc.h **** {
 475:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 476:../CMSIS/cmsis_gcc.h **** 
 477:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 478:../CMSIS/cmsis_gcc.h ****   return(result);
 479:../CMSIS/cmsis_gcc.h **** }
 480:../CMSIS/cmsis_gcc.h **** #endif
 481:../CMSIS/cmsis_gcc.h **** 
 482:../CMSIS/cmsis_gcc.h **** 
 483:../CMSIS/cmsis_gcc.h **** /**
 484:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 485:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 486:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 487:../CMSIS/cmsis_gcc.h ****  */
 488:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 489:../CMSIS/cmsis_gcc.h **** {
 490:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 491:../CMSIS/cmsis_gcc.h **** }
 492:../CMSIS/cmsis_gcc.h **** 
 493:../CMSIS/cmsis_gcc.h **** 
 494:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 495:../CMSIS/cmsis_gcc.h **** /**
 496:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 497:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 498:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 499:../CMSIS/cmsis_gcc.h ****  */
 500:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 501:../CMSIS/cmsis_gcc.h **** {
 502:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 503:../CMSIS/cmsis_gcc.h **** }
 504:../CMSIS/cmsis_gcc.h **** #endif
 505:../CMSIS/cmsis_gcc.h **** 
 506:../CMSIS/cmsis_gcc.h **** 
 507:../CMSIS/cmsis_gcc.h **** /**
 508:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 509:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 510:../CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 511:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 512:../CMSIS/cmsis_gcc.h ****  */
 513:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 514:../CMSIS/cmsis_gcc.h **** {
 515:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 516:../CMSIS/cmsis_gcc.h **** }
 517:../CMSIS/cmsis_gcc.h **** 
 518:../CMSIS/cmsis_gcc.h **** 
 519:../CMSIS/cmsis_gcc.h **** /**
 520:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 521:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 522:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 523:../CMSIS/cmsis_gcc.h ****  */
 524:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 525:../CMSIS/cmsis_gcc.h **** {
 526:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 527:../CMSIS/cmsis_gcc.h **** 
 528:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 529:../CMSIS/cmsis_gcc.h ****   return(result);
 530:../CMSIS/cmsis_gcc.h **** }
 531:../CMSIS/cmsis_gcc.h **** 
 532:../CMSIS/cmsis_gcc.h **** 
 533:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 534:../CMSIS/cmsis_gcc.h **** /**
 535:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 536:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 537:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 538:../CMSIS/cmsis_gcc.h ****  */
 539:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 540:../CMSIS/cmsis_gcc.h **** {
 541:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 542:../CMSIS/cmsis_gcc.h **** 
 543:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 544:../CMSIS/cmsis_gcc.h ****   return(result);
 545:../CMSIS/cmsis_gcc.h **** }
 546:../CMSIS/cmsis_gcc.h **** #endif
 547:../CMSIS/cmsis_gcc.h **** 
 548:../CMSIS/cmsis_gcc.h **** 
 549:../CMSIS/cmsis_gcc.h **** /**
 550:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 551:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 552:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 553:../CMSIS/cmsis_gcc.h ****  */
 554:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 555:../CMSIS/cmsis_gcc.h **** {
 556:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 557:../CMSIS/cmsis_gcc.h **** }
 558:../CMSIS/cmsis_gcc.h **** 
 559:../CMSIS/cmsis_gcc.h **** 
 560:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 561:../CMSIS/cmsis_gcc.h **** /**
 562:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 563:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 564:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 565:../CMSIS/cmsis_gcc.h ****  */
 566:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 567:../CMSIS/cmsis_gcc.h **** {
 568:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 569:../CMSIS/cmsis_gcc.h **** }
 570:../CMSIS/cmsis_gcc.h **** #endif
 571:../CMSIS/cmsis_gcc.h **** 
 572:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 573:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 574:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 575:../CMSIS/cmsis_gcc.h **** 
 576:../CMSIS/cmsis_gcc.h **** 
 577:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 578:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 579:../CMSIS/cmsis_gcc.h **** 
 580:../CMSIS/cmsis_gcc.h **** /**
 581:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 582:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 583:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 584:../CMSIS/cmsis_gcc.h ****  */
 585:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 586:../CMSIS/cmsis_gcc.h **** {
 587:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 588:../CMSIS/cmsis_gcc.h **** 
 589:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 590:../CMSIS/cmsis_gcc.h ****   return(result);
 591:../CMSIS/cmsis_gcc.h **** }
 592:../CMSIS/cmsis_gcc.h **** 
 593:../CMSIS/cmsis_gcc.h **** 
 594:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 595:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 596:../CMSIS/cmsis_gcc.h **** /**
 597:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 598:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 599:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 600:../CMSIS/cmsis_gcc.h ****  */
 601:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 602:../CMSIS/cmsis_gcc.h **** {
 603:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 604:../CMSIS/cmsis_gcc.h **** 
 605:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 606:../CMSIS/cmsis_gcc.h ****   return(result);
 607:../CMSIS/cmsis_gcc.h **** }
 608:../CMSIS/cmsis_gcc.h **** #endif
 609:../CMSIS/cmsis_gcc.h **** 
 610:../CMSIS/cmsis_gcc.h **** 
 611:../CMSIS/cmsis_gcc.h **** /**
 612:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 613:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 614:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 615:../CMSIS/cmsis_gcc.h ****  */
 616:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 617:../CMSIS/cmsis_gcc.h **** {
 618:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 619:../CMSIS/cmsis_gcc.h **** }
 620:../CMSIS/cmsis_gcc.h **** 
 621:../CMSIS/cmsis_gcc.h **** 
 622:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 623:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 624:../CMSIS/cmsis_gcc.h **** /**
 625:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 626:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 627:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 628:../CMSIS/cmsis_gcc.h ****  */
 629:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 630:../CMSIS/cmsis_gcc.h **** {
 631:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 632:../CMSIS/cmsis_gcc.h **** }
 633:../CMSIS/cmsis_gcc.h **** #endif
 634:../CMSIS/cmsis_gcc.h **** 
 635:../CMSIS/cmsis_gcc.h **** 
 636:../CMSIS/cmsis_gcc.h **** /**
 637:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 638:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 639:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 640:../CMSIS/cmsis_gcc.h ****  */
 641:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 642:../CMSIS/cmsis_gcc.h **** {
 643:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 644:../CMSIS/cmsis_gcc.h **** 
 645:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 646:../CMSIS/cmsis_gcc.h **** 
 647:../CMSIS/cmsis_gcc.h ****   return(result);
 648:../CMSIS/cmsis_gcc.h **** }
 649:../CMSIS/cmsis_gcc.h **** 
 650:../CMSIS/cmsis_gcc.h **** 
 651:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 652:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 653:../CMSIS/cmsis_gcc.h **** /**
 654:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 655:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 656:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 657:../CMSIS/cmsis_gcc.h ****  */
 658:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 659:../CMSIS/cmsis_gcc.h **** {
 660:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 661:../CMSIS/cmsis_gcc.h **** 
 662:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 663:../CMSIS/cmsis_gcc.h ****   return(result);
 664:../CMSIS/cmsis_gcc.h **** }
 665:../CMSIS/cmsis_gcc.h **** #endif
 666:../CMSIS/cmsis_gcc.h **** 
 667:../CMSIS/cmsis_gcc.h **** 
 668:../CMSIS/cmsis_gcc.h **** /**
 669:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 670:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 671:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 672:../CMSIS/cmsis_gcc.h ****  */
 673:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 674:../CMSIS/cmsis_gcc.h **** {
 675:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 676:../CMSIS/cmsis_gcc.h **** }
 677:../CMSIS/cmsis_gcc.h **** 
 678:../CMSIS/cmsis_gcc.h **** 
 679:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 680:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 681:../CMSIS/cmsis_gcc.h **** /**
 682:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 683:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 684:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 685:../CMSIS/cmsis_gcc.h ****  */
 686:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 687:../CMSIS/cmsis_gcc.h **** {
 688:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 689:../CMSIS/cmsis_gcc.h **** }
 690:../CMSIS/cmsis_gcc.h **** #endif
 691:../CMSIS/cmsis_gcc.h **** 
 692:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 693:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 694:../CMSIS/cmsis_gcc.h **** 
 695:../CMSIS/cmsis_gcc.h **** 
 696:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 697:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 698:../CMSIS/cmsis_gcc.h **** 
 699:../CMSIS/cmsis_gcc.h **** /**
 700:../CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 701:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 702:../CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 703:../CMSIS/cmsis_gcc.h ****  */
 704:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 705:../CMSIS/cmsis_gcc.h **** {
 706:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 707:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 708:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 709:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 710:../CMSIS/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 711:../CMSIS/cmsis_gcc.h **** #else
 712:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 713:../CMSIS/cmsis_gcc.h **** 
 714:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 715:../CMSIS/cmsis_gcc.h ****   return(result);
 716:../CMSIS/cmsis_gcc.h **** #endif
 717:../CMSIS/cmsis_gcc.h **** #else
 718:../CMSIS/cmsis_gcc.h ****   return(0U);
 719:../CMSIS/cmsis_gcc.h **** #endif
 720:../CMSIS/cmsis_gcc.h **** }
 721:../CMSIS/cmsis_gcc.h **** 
 722:../CMSIS/cmsis_gcc.h **** 
 723:../CMSIS/cmsis_gcc.h **** /**
 724:../CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 725:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 726:../CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 727:../CMSIS/cmsis_gcc.h ****  */
 728:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 729:../CMSIS/cmsis_gcc.h **** {
 730:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 731:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 732:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 733:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 734:../CMSIS/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 735:../CMSIS/cmsis_gcc.h **** #else
 736:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 737:../CMSIS/cmsis_gcc.h **** #endif
 738:../CMSIS/cmsis_gcc.h **** #else
 739:../CMSIS/cmsis_gcc.h ****   (void)fpscr;
 740:../CMSIS/cmsis_gcc.h **** #endif
 741:../CMSIS/cmsis_gcc.h **** }
 742:../CMSIS/cmsis_gcc.h **** 
 743:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 744:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 745:../CMSIS/cmsis_gcc.h **** 
 746:../CMSIS/cmsis_gcc.h **** 
 747:../CMSIS/cmsis_gcc.h **** 
 748:../CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 749:../CMSIS/cmsis_gcc.h **** 
 750:../CMSIS/cmsis_gcc.h **** 
 751:../CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 752:../CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 753:../CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 754:../CMSIS/cmsis_gcc.h ****   @{
 755:../CMSIS/cmsis_gcc.h **** */
 756:../CMSIS/cmsis_gcc.h **** 
 757:../CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 758:../CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 759:../CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 760:../CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 761:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 762:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 763:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 764:../CMSIS/cmsis_gcc.h **** #else
 765:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 766:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 767:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 768:../CMSIS/cmsis_gcc.h **** #endif
 769:../CMSIS/cmsis_gcc.h **** 
 770:../CMSIS/cmsis_gcc.h **** /**
 771:../CMSIS/cmsis_gcc.h ****   \brief   No Operation
 772:../CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 773:../CMSIS/cmsis_gcc.h ****  */
 774:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 775:../CMSIS/cmsis_gcc.h **** //{
 776:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("nop");
 777:../CMSIS/cmsis_gcc.h **** //}
 778:../CMSIS/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 779:../CMSIS/cmsis_gcc.h **** 
 780:../CMSIS/cmsis_gcc.h **** /**
 781:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Interrupt
 782:../CMSIS/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 783:../CMSIS/cmsis_gcc.h ****  */
 784:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 785:../CMSIS/cmsis_gcc.h **** //{
 786:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 787:../CMSIS/cmsis_gcc.h **** //}
 788:../CMSIS/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 789:../CMSIS/cmsis_gcc.h **** 
 790:../CMSIS/cmsis_gcc.h **** 
 791:../CMSIS/cmsis_gcc.h **** /**
 792:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Event
 793:../CMSIS/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 794:../CMSIS/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 795:../CMSIS/cmsis_gcc.h ****  */
 796:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 797:../CMSIS/cmsis_gcc.h **** //{
 798:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 799:../CMSIS/cmsis_gcc.h **** //}
 800:../CMSIS/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 801:../CMSIS/cmsis_gcc.h **** 
 802:../CMSIS/cmsis_gcc.h **** 
 803:../CMSIS/cmsis_gcc.h **** /**
 804:../CMSIS/cmsis_gcc.h ****   \brief   Send Event
 805:../CMSIS/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 806:../CMSIS/cmsis_gcc.h ****  */
 807:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 808:../CMSIS/cmsis_gcc.h **** //{
 809:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("sev");
 810:../CMSIS/cmsis_gcc.h **** //}
 811:../CMSIS/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 812:../CMSIS/cmsis_gcc.h **** 
 813:../CMSIS/cmsis_gcc.h **** 
 814:../CMSIS/cmsis_gcc.h **** /**
 815:../CMSIS/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 816:../CMSIS/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 817:../CMSIS/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 818:../CMSIS/cmsis_gcc.h ****            after the instruction has been completed.
 819:../CMSIS/cmsis_gcc.h ****  */
 820:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 821:../CMSIS/cmsis_gcc.h **** {
 822:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 823:../CMSIS/cmsis_gcc.h **** }
 824:../CMSIS/cmsis_gcc.h **** 
 825:../CMSIS/cmsis_gcc.h **** 
 826:../CMSIS/cmsis_gcc.h **** /**
 827:../CMSIS/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 828:../CMSIS/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 829:../CMSIS/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 830:../CMSIS/cmsis_gcc.h ****  */
 831:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 832:../CMSIS/cmsis_gcc.h **** {
 833:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 255              		.loc 2 833 0
 256              		.syntax divided
 257              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 258 000e BFF34F8F 		dsb 0xF
 259              	@ 0 "" 2
 260              		.thumb
 261              		.syntax unified
 262              	.LBE46:
 263              	.LBE45:
 496:../drivers/fsl_i2c.c ****     }
 497:../drivers/fsl_i2c.c ****     else
 498:../drivers/fsl_i2c.c ****     {
 499:../drivers/fsl_i2c.c ****         s_i2cSlaveIsr(base, handle);
 500:../drivers/fsl_i2c.c ****     }
 501:../drivers/fsl_i2c.c ****     __DSB();
 502:../drivers/fsl_i2c.c **** }
 264              		.loc 1 502 0
 265              		@ sp needed
 266 0012 10BD     		pop	{r4, pc}
 267              	.LVL32:
 268              	.L25:
 493:../drivers/fsl_i2c.c ****     {
 269              		.loc 1 493 0 discriminator 1
 270 0014 8378     		ldrb	r3, [r0, #2]
 271 0016 9B06     		lsls	r3, r3, #26
 272 0018 F6D4     		bmi	.L22
 499:../drivers/fsl_i2c.c ****     }
 273              		.loc 1 499 0
 274 001a 034B     		ldr	r3, .L26+4
 275 001c 1B68     		ldr	r3, [r3]
 276 001e 9847     		blx	r3
 277              	.LVL33:
 278 0020 F5E7     		b	.L24
 279              	.L27:
 280 0022 C046     		.align	2
 281              	.L26:
 282 0024 00000000 		.word	.LANCHOR0
 283 0028 00000000 		.word	.LANCHOR1
 284              		.cfi_endproc
 285              	.LFE64:
 287              		.section	.text.I2C_GetInstance,"ax",%progbits
 288              		.align	1
 289              		.global	I2C_GetInstance
 290              		.syntax unified
 291              		.code	16
 292              		.thumb_func
 293              		.fpu softvfp
 295              	I2C_GetInstance:
 296              	.LFB59:
 173:../drivers/fsl_i2c.c ****     uint32_t instance;
 297              		.loc 1 173 0
 298              		.cfi_startproc
 299              		@ args = 0, pretend = 0, frame = 0
 300              		@ frame_needed = 0, uses_anonymous_args = 0
 301              		@ link register save eliminated.
 302              	.LVL34:
 177:../drivers/fsl_i2c.c ****     {
 303              		.loc 1 177 0
 304 0000 0023     		movs	r3, #0
 305              	.LVL35:
 306              	.L29:
 177:../drivers/fsl_i2c.c ****     {
 307              		.loc 1 177 0 is_stmt 0 discriminator 1
 308 0002 012B     		cmp	r3, #1
 309 0004 06D8     		bhi	.L28
 179:../drivers/fsl_i2c.c ****         {
 310              		.loc 1 179 0 is_stmt 1
 311 0006 9A00     		lsls	r2, r3, #2
 312 0008 0349     		ldr	r1, .L32
 313 000a 5258     		ldr	r2, [r2, r1]
 314 000c 8242     		cmp	r2, r0
 315 000e 01D0     		beq	.L28
 177:../drivers/fsl_i2c.c ****     {
 316              		.loc 1 177 0 discriminator 2
 317 0010 0133     		adds	r3, r3, #1
 318              	.LVL36:
 319 0012 F6E7     		b	.L29
 320              	.L28:
 188:../drivers/fsl_i2c.c **** 
 321              		.loc 1 188 0
 322 0014 1800     		movs	r0, r3
 323              	.LVL37:
 324              		@ sp needed
 325 0016 7047     		bx	lr
 326              	.L33:
 327              		.align	2
 328              	.L32:
 329 0018 00000000 		.word	.LANCHOR2
 330              		.cfi_endproc
 331              	.LFE59:
 333              		.section	.text.I2C_MasterDeinit,"ax",%progbits
 334              		.align	1
 335              		.global	I2C_MasterDeinit
 336              		.syntax unified
 337              		.code	16
 338              		.thumb_func
 339              		.fpu softvfp
 341              	I2C_MasterDeinit:
 342              	.LFB66:
 503:../drivers/fsl_i2c.c **** 
 504:../drivers/fsl_i2c.c **** void I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz)
 505:../drivers/fsl_i2c.c **** {
 506:../drivers/fsl_i2c.c ****     assert(masterConfig && srcClock_Hz);
 507:../drivers/fsl_i2c.c **** 
 508:../drivers/fsl_i2c.c ****     /* Temporary register for filter read. */
 509:../drivers/fsl_i2c.c ****     uint8_t fltReg;
 510:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 511:../drivers/fsl_i2c.c ****     uint8_t s2Reg;
 512:../drivers/fsl_i2c.c **** #endif
 513:../drivers/fsl_i2c.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 514:../drivers/fsl_i2c.c ****     /* Enable I2C clock. */
 515:../drivers/fsl_i2c.c ****     CLOCK_EnableClock(s_i2cClocks[I2C_GetInstance(base)]);
 516:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 517:../drivers/fsl_i2c.c **** 
 518:../drivers/fsl_i2c.c ****     /* Reset the module. */
 519:../drivers/fsl_i2c.c ****     base->A1 = 0;
 520:../drivers/fsl_i2c.c ****     base->F = 0;
 521:../drivers/fsl_i2c.c ****     base->C1 = 0;
 522:../drivers/fsl_i2c.c ****     base->S = 0xFFU;
 523:../drivers/fsl_i2c.c ****     base->C2 = 0;
 524:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 525:../drivers/fsl_i2c.c ****     base->FLT = 0x50U;
 526:../drivers/fsl_i2c.c **** #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 527:../drivers/fsl_i2c.c ****     base->FLT = 0x40U;
 528:../drivers/fsl_i2c.c **** #endif
 529:../drivers/fsl_i2c.c ****     base->RA = 0;
 530:../drivers/fsl_i2c.c **** 
 531:../drivers/fsl_i2c.c ****     /* Disable I2C prior to configuring it. */
 532:../drivers/fsl_i2c.c ****     base->C1 &= ~(I2C_C1_IICEN_MASK);
 533:../drivers/fsl_i2c.c **** 
 534:../drivers/fsl_i2c.c ****     /* Clear all flags. */
 535:../drivers/fsl_i2c.c ****     I2C_MasterClearStatusFlags(base, kClearFlags);
 536:../drivers/fsl_i2c.c **** 
 537:../drivers/fsl_i2c.c ****     /* Configure baud rate. */
 538:../drivers/fsl_i2c.c ****     I2C_MasterSetBaudRate(base, masterConfig->baudRate_Bps, srcClock_Hz);
 539:../drivers/fsl_i2c.c **** 
 540:../drivers/fsl_i2c.c ****     /* Read out the FLT register. */
 541:../drivers/fsl_i2c.c ****     fltReg = base->FLT;
 542:../drivers/fsl_i2c.c **** 
 543:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
 544:../drivers/fsl_i2c.c ****     /* Configure the stop / hold enable. */
 545:../drivers/fsl_i2c.c ****     fltReg &= ~(I2C_FLT_SHEN_MASK);
 546:../drivers/fsl_i2c.c ****     fltReg |= I2C_FLT_SHEN(masterConfig->enableStopHold);
 547:../drivers/fsl_i2c.c **** #endif
 548:../drivers/fsl_i2c.c **** 
 549:../drivers/fsl_i2c.c ****     /* Configure the glitch filter value. */
 550:../drivers/fsl_i2c.c ****     fltReg &= ~(I2C_FLT_FLT_MASK);
 551:../drivers/fsl_i2c.c ****     fltReg |= I2C_FLT_FLT(masterConfig->glitchFilterWidth);
 552:../drivers/fsl_i2c.c **** 
 553:../drivers/fsl_i2c.c ****     /* Write the register value back to the filter register. */
 554:../drivers/fsl_i2c.c ****     base->FLT = fltReg;
 555:../drivers/fsl_i2c.c **** 
 556:../drivers/fsl_i2c.c **** /* Enable/Disable double buffering. */
 557:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 558:../drivers/fsl_i2c.c ****     s2Reg = base->S2 & (~I2C_S2_DFEN_MASK);
 559:../drivers/fsl_i2c.c ****     base->S2 = s2Reg | I2C_S2_DFEN(masterConfig->enableDoubleBuffering);
 560:../drivers/fsl_i2c.c **** #endif
 561:../drivers/fsl_i2c.c **** 
 562:../drivers/fsl_i2c.c ****     /* Enable the I2C peripheral based on the configuration. */
 563:../drivers/fsl_i2c.c ****     base->C1 = I2C_C1_IICEN(masterConfig->enableMaster);
 564:../drivers/fsl_i2c.c **** }
 565:../drivers/fsl_i2c.c **** 
 566:../drivers/fsl_i2c.c **** void I2C_MasterDeinit(I2C_Type *base)
 567:../drivers/fsl_i2c.c **** {
 343              		.loc 1 567 0
 344              		.cfi_startproc
 345              		@ args = 0, pretend = 0, frame = 0
 346              		@ frame_needed = 0, uses_anonymous_args = 0
 347              	.LVL38:
 348 0000 10B5     		push	{r4, lr}
 349              		.cfi_def_cfa_offset 8
 350              		.cfi_offset 4, -8
 351              		.cfi_offset 14, -4
 352              	.LVL39:
 353              	.LBB47:
 354              	.LBB48:
 355              		.file 3 "../drivers/fsl_i2c.h"
   1:../drivers/fsl_i2c.h **** /*
   2:../drivers/fsl_i2c.h ****  * The Clear BSD License
   3:../drivers/fsl_i2c.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_i2c.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_i2c.h ****  * All rights reserved.
   6:../drivers/fsl_i2c.h ****  *
   7:../drivers/fsl_i2c.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_i2c.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_i2c.h ****  * that the following conditions are met:
  10:../drivers/fsl_i2c.h ****  *
  11:../drivers/fsl_i2c.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_i2c.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_i2c.h ****  *
  14:../drivers/fsl_i2c.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_i2c.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_i2c.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_i2c.h ****  *
  18:../drivers/fsl_i2c.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_i2c.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_i2c.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_i2c.h ****  *
  22:../drivers/fsl_i2c.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_i2c.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_i2c.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_i2c.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_i2c.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_i2c.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_i2c.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_i2c.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_i2c.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_i2c.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_i2c.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_i2c.h ****  */
  34:../drivers/fsl_i2c.h **** #ifndef _FSL_I2C_H_
  35:../drivers/fsl_i2c.h **** #define _FSL_I2C_H_
  36:../drivers/fsl_i2c.h **** 
  37:../drivers/fsl_i2c.h **** #include "fsl_common.h"
  38:../drivers/fsl_i2c.h **** 
  39:../drivers/fsl_i2c.h **** /*!
  40:../drivers/fsl_i2c.h ****  * @addtogroup i2c_driver
  41:../drivers/fsl_i2c.h ****  * @{
  42:../drivers/fsl_i2c.h ****  */
  43:../drivers/fsl_i2c.h **** 
  44:../drivers/fsl_i2c.h **** /*******************************************************************************
  45:../drivers/fsl_i2c.h ****  * Definitions
  46:../drivers/fsl_i2c.h ****  ******************************************************************************/
  47:../drivers/fsl_i2c.h **** 
  48:../drivers/fsl_i2c.h **** /*! @name Driver version */
  49:../drivers/fsl_i2c.h **** /*@{*/
  50:../drivers/fsl_i2c.h **** /*! @brief I2C driver version 2.0.5. */
  51:../drivers/fsl_i2c.h **** #define FSL_I2C_DRIVER_VERSION (MAKE_VERSION(2, 0, 5))
  52:../drivers/fsl_i2c.h **** /*@}*/
  53:../drivers/fsl_i2c.h **** 
  54:../drivers/fsl_i2c.h **** /*! @brief Timeout times for waiting flag. */
  55:../drivers/fsl_i2c.h **** #ifndef I2C_WAIT_TIMEOUT
  56:../drivers/fsl_i2c.h **** #define I2C_WAIT_TIMEOUT 0U /* Define to zero means keep waiting until the flag is assert/deassert.
  57:../drivers/fsl_i2c.h **** #endif
  58:../drivers/fsl_i2c.h **** 
  59:../drivers/fsl_i2c.h **** #if (defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT || \
  60:../drivers/fsl_i2c.h ****      defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT)
  61:../drivers/fsl_i2c.h **** #define I2C_HAS_STOP_DETECT
  62:../drivers/fsl_i2c.h **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT / FSL_FEATURE_I2C_HAS_STOP_DETECT */
  63:../drivers/fsl_i2c.h **** 
  64:../drivers/fsl_i2c.h **** /*! @brief  I2C status return codes. */
  65:../drivers/fsl_i2c.h **** enum _i2c_status
  66:../drivers/fsl_i2c.h **** {
  67:../drivers/fsl_i2c.h ****     kStatus_I2C_Busy = MAKE_STATUS(kStatusGroup_I2C, 0),            /*!< I2C is busy with current t
  68:../drivers/fsl_i2c.h ****     kStatus_I2C_Idle = MAKE_STATUS(kStatusGroup_I2C, 1),            /*!< Bus is Idle. */
  69:../drivers/fsl_i2c.h ****     kStatus_I2C_Nak = MAKE_STATUS(kStatusGroup_I2C, 2),             /*!< NAK received during transf
  70:../drivers/fsl_i2c.h ****     kStatus_I2C_ArbitrationLost = MAKE_STATUS(kStatusGroup_I2C, 3), /*!< Arbitration lost during tr
  71:../drivers/fsl_i2c.h ****     kStatus_I2C_Timeout = MAKE_STATUS(kStatusGroup_I2C, 4),         /*!< Timeout poling status flag
  72:../drivers/fsl_i2c.h ****     kStatus_I2C_Addr_Nak = MAKE_STATUS(kStatusGroup_I2C, 5),        /*!< NAK received during the ad
  73:../drivers/fsl_i2c.h **** };
  74:../drivers/fsl_i2c.h **** 
  75:../drivers/fsl_i2c.h **** /*!
  76:../drivers/fsl_i2c.h ****  * @brief I2C peripheral flags
  77:../drivers/fsl_i2c.h ****  *
  78:../drivers/fsl_i2c.h ****  * The following status register flags can be cleared:
  79:../drivers/fsl_i2c.h ****  * - #kI2C_ArbitrationLostFlag
  80:../drivers/fsl_i2c.h ****  * - #kI2C_IntPendingFlag
  81:../drivers/fsl_i2c.h ****  * - #kI2C_StartDetectFlag
  82:../drivers/fsl_i2c.h ****  * - #kI2C_StopDetectFlag
  83:../drivers/fsl_i2c.h ****  *
  84:../drivers/fsl_i2c.h ****  * @note These enumerations are meant to be OR'd together to form a bit mask.
  85:../drivers/fsl_i2c.h ****  *
  86:../drivers/fsl_i2c.h ****  */
  87:../drivers/fsl_i2c.h **** enum _i2c_flags
  88:../drivers/fsl_i2c.h **** {
  89:../drivers/fsl_i2c.h ****     kI2C_ReceiveNakFlag = I2C_S_RXAK_MASK,       /*!< I2C receive NAK flag. */
  90:../drivers/fsl_i2c.h ****     kI2C_IntPendingFlag = I2C_S_IICIF_MASK,      /*!< I2C interrupt pending flag. */
  91:../drivers/fsl_i2c.h ****     kI2C_TransferDirectionFlag = I2C_S_SRW_MASK, /*!< I2C transfer direction flag. */
  92:../drivers/fsl_i2c.h ****     kI2C_RangeAddressMatchFlag = I2C_S_RAM_MASK, /*!< I2C range address match flag. */
  93:../drivers/fsl_i2c.h ****     kI2C_ArbitrationLostFlag = I2C_S_ARBL_MASK,  /*!< I2C arbitration lost flag. */
  94:../drivers/fsl_i2c.h ****     kI2C_BusBusyFlag = I2C_S_BUSY_MASK,          /*!< I2C bus busy flag. */
  95:../drivers/fsl_i2c.h ****     kI2C_AddressMatchFlag = I2C_S_IAAS_MASK,     /*!< I2C address match flag. */
  96:../drivers/fsl_i2c.h ****     kI2C_TransferCompleteFlag = I2C_S_TCF_MASK,  /*!< I2C transfer complete flag. */
  97:../drivers/fsl_i2c.h **** #ifdef I2C_HAS_STOP_DETECT
  98:../drivers/fsl_i2c.h ****     kI2C_StopDetectFlag = I2C_FLT_STOPF_MASK << 8, /*!< I2C stop detect flag. */
  99:../drivers/fsl_i2c.h **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT / FSL_FEATURE_I2C_HAS_STOP_DETECT */
 100:../drivers/fsl_i2c.h **** 
 101:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 102:../drivers/fsl_i2c.h ****     kI2C_StartDetectFlag = I2C_FLT_STARTF_MASK << 8, /*!< I2C start detect flag. */
 103:../drivers/fsl_i2c.h **** #endif                                               /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 104:../drivers/fsl_i2c.h **** };
 105:../drivers/fsl_i2c.h **** 
 106:../drivers/fsl_i2c.h **** /*! @brief I2C feature interrupt source. */
 107:../drivers/fsl_i2c.h **** enum _i2c_interrupt_enable
 108:../drivers/fsl_i2c.h **** {
 109:../drivers/fsl_i2c.h ****     kI2C_GlobalInterruptEnable = I2C_C1_IICIE_MASK, /*!< I2C global interrupt. */
 110:../drivers/fsl_i2c.h **** 
 111:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 112:../drivers/fsl_i2c.h ****     kI2C_StopDetectInterruptEnable = I2C_FLT_STOPIE_MASK, /*!< I2C stop detect interrupt. */
 113:../drivers/fsl_i2c.h **** #endif                                                    /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
 114:../drivers/fsl_i2c.h **** 
 115:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 116:../drivers/fsl_i2c.h ****     kI2C_StartStopDetectInterruptEnable = I2C_FLT_SSIE_MASK, /*!< I2C start&stop detect interrupt. 
 117:../drivers/fsl_i2c.h **** #endif                                                       /* FSL_FEATURE_I2C_HAS_START_STOP_DETE
 118:../drivers/fsl_i2c.h **** };
 119:../drivers/fsl_i2c.h **** 
 120:../drivers/fsl_i2c.h **** /*! @brief The direction of master and slave transfers. */
 121:../drivers/fsl_i2c.h **** typedef enum _i2c_direction
 122:../drivers/fsl_i2c.h **** {
 123:../drivers/fsl_i2c.h ****     kI2C_Write = 0x0U, /*!< Master transmits to the slave. */
 124:../drivers/fsl_i2c.h ****     kI2C_Read = 0x1U,  /*!< Master receives from the slave. */
 125:../drivers/fsl_i2c.h **** } i2c_direction_t;
 126:../drivers/fsl_i2c.h **** 
 127:../drivers/fsl_i2c.h **** /*! @brief Addressing mode. */
 128:../drivers/fsl_i2c.h **** typedef enum _i2c_slave_address_mode
 129:../drivers/fsl_i2c.h **** {
 130:../drivers/fsl_i2c.h ****     kI2C_Address7bit = 0x0U, /*!< 7-bit addressing mode. */
 131:../drivers/fsl_i2c.h ****     kI2C_RangeMatch = 0X2U,  /*!< Range address match addressing mode. */
 132:../drivers/fsl_i2c.h **** } i2c_slave_address_mode_t;
 133:../drivers/fsl_i2c.h **** 
 134:../drivers/fsl_i2c.h **** /*! @brief I2C transfer control flag. */
 135:../drivers/fsl_i2c.h **** enum _i2c_master_transfer_flags
 136:../drivers/fsl_i2c.h **** {
 137:../drivers/fsl_i2c.h ****     kI2C_TransferDefaultFlag = 0x0U,       /*!< A transfer starts with a start signal, stops with a
 138:../drivers/fsl_i2c.h ****     kI2C_TransferNoStartFlag = 0x1U,       /*!< A transfer starts without a start signal, only supp
 139:../drivers/fsl_i2c.h ****                                         write+read with no start flag, do not support read only wit
 140:../drivers/fsl_i2c.h ****     kI2C_TransferRepeatedStartFlag = 0x2U, /*!< A transfer starts with a repeated start signal. */
 141:../drivers/fsl_i2c.h ****     kI2C_TransferNoStopFlag = 0x4U,        /*!< A transfer ends without a stop signal. */
 142:../drivers/fsl_i2c.h **** };
 143:../drivers/fsl_i2c.h **** 
 144:../drivers/fsl_i2c.h **** /*!
 145:../drivers/fsl_i2c.h ****  * @brief Set of events sent to the callback for nonblocking slave transfers.
 146:../drivers/fsl_i2c.h ****  *
 147:../drivers/fsl_i2c.h ****  * These event enumerations are used for two related purposes. First, a bit mask created by OR'ing 
 148:../drivers/fsl_i2c.h ****  * events is passed to I2C_SlaveTransferNonBlocking() to specify which events to enable.
 149:../drivers/fsl_i2c.h ****  * Then, when the slave callback is invoked, it is passed the current event through its @a transfer
 150:../drivers/fsl_i2c.h ****  * parameter.
 151:../drivers/fsl_i2c.h ****  *
 152:../drivers/fsl_i2c.h ****  * @note These enumerations are meant to be OR'd together to form a bit mask of events.
 153:../drivers/fsl_i2c.h ****  */
 154:../drivers/fsl_i2c.h **** typedef enum _i2c_slave_transfer_event
 155:../drivers/fsl_i2c.h **** {
 156:../drivers/fsl_i2c.h ****     kI2C_SlaveAddressMatchEvent = 0x01U, /*!< Received the slave address after a start or repeated 
 157:../drivers/fsl_i2c.h ****     kI2C_SlaveTransmitEvent = 0x02U,     /*!< A callback is requested to provide data to transmit
 158:../drivers/fsl_i2c.h ****                                                 (slave-transmitter role). */
 159:../drivers/fsl_i2c.h ****     kI2C_SlaveReceiveEvent = 0x04U,      /*!< A callback is requested to provide a buffer in which 
 160:../drivers/fsl_i2c.h ****                                                  data (slave-receiver role). */
 161:../drivers/fsl_i2c.h ****     kI2C_SlaveTransmitAckEvent = 0x08U,  /*!< A callback needs to either transmit an ACK or NACK. *
 162:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 163:../drivers/fsl_i2c.h ****     kI2C_SlaveStartEvent = 0x10U, /*!< A start/repeated start was detected. */
 164:../drivers/fsl_i2c.h **** #endif
 165:../drivers/fsl_i2c.h ****     kI2C_SlaveCompletionEvent = 0x20U,  /*!< A stop was detected or finished transfer, completing t
 166:../drivers/fsl_i2c.h ****     kI2C_SlaveGenaralcallEvent = 0x40U, /*!< Received the general call address after a start or rep
 167:../drivers/fsl_i2c.h **** 
 168:../drivers/fsl_i2c.h ****     /*! A bit mask of all available events. */
 169:../drivers/fsl_i2c.h ****     kI2C_SlaveAllEvents = kI2C_SlaveAddressMatchEvent | kI2C_SlaveTransmitEvent | kI2C_SlaveReceive
 170:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 171:../drivers/fsl_i2c.h ****                           kI2C_SlaveStartEvent |
 172:../drivers/fsl_i2c.h **** #endif
 173:../drivers/fsl_i2c.h ****                           kI2C_SlaveCompletionEvent | kI2C_SlaveGenaralcallEvent,
 174:../drivers/fsl_i2c.h **** } i2c_slave_transfer_event_t;
 175:../drivers/fsl_i2c.h **** 
 176:../drivers/fsl_i2c.h **** /*! @brief I2C master user configuration. */
 177:../drivers/fsl_i2c.h **** typedef struct _i2c_master_config
 178:../drivers/fsl_i2c.h **** {
 179:../drivers/fsl_i2c.h ****     bool enableMaster; /*!< Enables the I2C peripheral at initialization time. */
 180:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
 181:../drivers/fsl_i2c.h ****     bool enableStopHold; /*!< Controls the stop hold enable. */
 182:../drivers/fsl_i2c.h **** #endif
 183:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 184:../drivers/fsl_i2c.h ****     bool enableDoubleBuffering; /*!< Controls double buffer enable; notice that
 185:../drivers/fsl_i2c.h ****                                      enabling the double buffer disables the clock stretch. */
 186:../drivers/fsl_i2c.h **** #endif
 187:../drivers/fsl_i2c.h ****     uint32_t baudRate_Bps;     /*!< Baud rate configuration of I2C peripheral. */
 188:../drivers/fsl_i2c.h ****     uint8_t glitchFilterWidth; /*!< Controls the width of the glitch. */
 189:../drivers/fsl_i2c.h **** } i2c_master_config_t;
 190:../drivers/fsl_i2c.h **** 
 191:../drivers/fsl_i2c.h **** /*! @brief I2C slave user configuration. */
 192:../drivers/fsl_i2c.h **** typedef struct _i2c_slave_config
 193:../drivers/fsl_i2c.h **** {
 194:../drivers/fsl_i2c.h ****     bool enableSlave;       /*!< Enables the I2C peripheral at initialization time. */
 195:../drivers/fsl_i2c.h ****     bool enableGeneralCall; /*!< Enables the general call addressing mode. */
 196:../drivers/fsl_i2c.h ****     bool enableWakeUp;      /*!< Enables/disables waking up MCU from low-power mode. */
 197:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 198:../drivers/fsl_i2c.h ****     bool enableDoubleBuffering; /*!< Controls a double buffer enable; notice that
 199:../drivers/fsl_i2c.h ****                                      enabling the double buffer disables the clock stretch. */
 200:../drivers/fsl_i2c.h **** #endif
 201:../drivers/fsl_i2c.h ****     bool enableBaudRateCtl; /*!< Enables/disables independent slave baud rate on SCL in very fast I
 202:../drivers/fsl_i2c.h ****     uint16_t slaveAddress;  /*!< A slave address configuration. */
 203:../drivers/fsl_i2c.h ****     uint16_t upperAddress;  /*!< A maximum boundary slave address used in a range matching mode. */
 204:../drivers/fsl_i2c.h ****     i2c_slave_address_mode_t
 205:../drivers/fsl_i2c.h ****         addressingMode;          /*!< An addressing mode configuration of i2c_slave_address_mode_co
 206:../drivers/fsl_i2c.h ****     uint32_t sclStopHoldTime_ns; /*!< the delay from the rising edge of SCL (I2C clock) to the risi
 207:../drivers/fsl_i2c.h ****                                     data) while SCL is high (stop condition), SDA hold time and SCL
 208:../drivers/fsl_i2c.h ****                                     are also configured according to the SCL stop hold time. */
 209:../drivers/fsl_i2c.h **** } i2c_slave_config_t;
 210:../drivers/fsl_i2c.h **** 
 211:../drivers/fsl_i2c.h **** /*! @brief I2C master handle typedef. */
 212:../drivers/fsl_i2c.h **** typedef struct _i2c_master_handle i2c_master_handle_t;
 213:../drivers/fsl_i2c.h **** 
 214:../drivers/fsl_i2c.h **** /*! @brief I2C master transfer callback typedef. */
 215:../drivers/fsl_i2c.h **** typedef void (*i2c_master_transfer_callback_t)(I2C_Type *base,
 216:../drivers/fsl_i2c.h ****                                                i2c_master_handle_t *handle,
 217:../drivers/fsl_i2c.h ****                                                status_t status,
 218:../drivers/fsl_i2c.h ****                                                void *userData);
 219:../drivers/fsl_i2c.h **** 
 220:../drivers/fsl_i2c.h **** /*! @brief I2C slave handle typedef. */
 221:../drivers/fsl_i2c.h **** typedef struct _i2c_slave_handle i2c_slave_handle_t;
 222:../drivers/fsl_i2c.h **** 
 223:../drivers/fsl_i2c.h **** /*! @brief I2C master transfer structure. */
 224:../drivers/fsl_i2c.h **** typedef struct _i2c_master_transfer
 225:../drivers/fsl_i2c.h **** {
 226:../drivers/fsl_i2c.h ****     uint32_t flags;            /*!< A transfer flag which controls the transfer. */
 227:../drivers/fsl_i2c.h ****     uint8_t slaveAddress;      /*!< 7-bit slave address. */
 228:../drivers/fsl_i2c.h ****     i2c_direction_t direction; /*!< A transfer direction, read or write. */
 229:../drivers/fsl_i2c.h ****     uint32_t subaddress;       /*!< A sub address. Transferred MSB first. */
 230:../drivers/fsl_i2c.h ****     uint8_t subaddressSize;    /*!< A size of the command buffer. */
 231:../drivers/fsl_i2c.h ****     uint8_t *volatile data;    /*!< A transfer buffer. */
 232:../drivers/fsl_i2c.h ****     volatile size_t dataSize;  /*!< A transfer size. */
 233:../drivers/fsl_i2c.h **** } i2c_master_transfer_t;
 234:../drivers/fsl_i2c.h **** 
 235:../drivers/fsl_i2c.h **** /*! @brief I2C master handle structure. */
 236:../drivers/fsl_i2c.h **** struct _i2c_master_handle
 237:../drivers/fsl_i2c.h **** {
 238:../drivers/fsl_i2c.h ****     i2c_master_transfer_t transfer;                    /*!< I2C master transfer copy. */
 239:../drivers/fsl_i2c.h ****     size_t transferSize;                               /*!< Total bytes to be transferred. */
 240:../drivers/fsl_i2c.h ****     uint8_t state;                                     /*!< A transfer state maintained during tran
 241:../drivers/fsl_i2c.h ****     i2c_master_transfer_callback_t completionCallback; /*!< A callback function called when the tra
 242:../drivers/fsl_i2c.h ****     void *userData;                                    /*!< A callback parameter passed to the call
 243:../drivers/fsl_i2c.h **** };
 244:../drivers/fsl_i2c.h **** 
 245:../drivers/fsl_i2c.h **** /*! @brief I2C slave transfer structure. */
 246:../drivers/fsl_i2c.h **** typedef struct _i2c_slave_transfer
 247:../drivers/fsl_i2c.h **** {
 248:../drivers/fsl_i2c.h ****     i2c_slave_transfer_event_t event; /*!< A reason that the callback is invoked. */
 249:../drivers/fsl_i2c.h ****     uint8_t *volatile data;           /*!< A transfer buffer. */
 250:../drivers/fsl_i2c.h ****     volatile size_t dataSize;         /*!< A transfer size. */
 251:../drivers/fsl_i2c.h ****     status_t completionStatus;        /*!< Success or error code describing how the transfer comple
 252:../drivers/fsl_i2c.h ****                                          #kI2C_SlaveCompletionEvent. */
 253:../drivers/fsl_i2c.h ****     size_t transferredCount; /*!< A number of bytes actually transferred since the start or since t
 254:../drivers/fsl_i2c.h ****                                 start. */
 255:../drivers/fsl_i2c.h **** } i2c_slave_transfer_t;
 256:../drivers/fsl_i2c.h **** 
 257:../drivers/fsl_i2c.h **** /*! @brief I2C slave transfer callback typedef. */
 258:../drivers/fsl_i2c.h **** typedef void (*i2c_slave_transfer_callback_t)(I2C_Type *base, i2c_slave_transfer_t *xfer, void *use
 259:../drivers/fsl_i2c.h **** 
 260:../drivers/fsl_i2c.h **** /*! @brief I2C slave handle structure. */
 261:../drivers/fsl_i2c.h **** struct _i2c_slave_handle
 262:../drivers/fsl_i2c.h **** {
 263:../drivers/fsl_i2c.h ****     volatile bool isBusy;                   /*!< Indicates whether a transfer is busy. */
 264:../drivers/fsl_i2c.h ****     i2c_slave_transfer_t transfer;          /*!< I2C slave transfer copy. */
 265:../drivers/fsl_i2c.h ****     uint32_t eventMask;                     /*!< A mask of enabled events. */
 266:../drivers/fsl_i2c.h ****     i2c_slave_transfer_callback_t callback; /*!< A callback function called at the transfer event. 
 267:../drivers/fsl_i2c.h ****     void *userData;                         /*!< A callback parameter passed to the callback. */
 268:../drivers/fsl_i2c.h **** };
 269:../drivers/fsl_i2c.h **** 
 270:../drivers/fsl_i2c.h **** /*******************************************************************************
 271:../drivers/fsl_i2c.h ****  * API
 272:../drivers/fsl_i2c.h ****  ******************************************************************************/
 273:../drivers/fsl_i2c.h **** 
 274:../drivers/fsl_i2c.h **** #if defined(__cplusplus)
 275:../drivers/fsl_i2c.h **** extern "C" {
 276:../drivers/fsl_i2c.h **** #endif /*_cplusplus. */
 277:../drivers/fsl_i2c.h **** 
 278:../drivers/fsl_i2c.h **** /*!
 279:../drivers/fsl_i2c.h ****  * @name Initialization and deinitialization
 280:../drivers/fsl_i2c.h ****  * @{
 281:../drivers/fsl_i2c.h ****  */
 282:../drivers/fsl_i2c.h **** 
 283:../drivers/fsl_i2c.h **** /*!
 284:../drivers/fsl_i2c.h ****  * @brief Initializes the I2C peripheral. Call this API to ungate the I2C clock
 285:../drivers/fsl_i2c.h ****  * and configure the I2C with master configuration.
 286:../drivers/fsl_i2c.h ****  *
 287:../drivers/fsl_i2c.h ****  * @note This API should be called at the beginning of the application.
 288:../drivers/fsl_i2c.h ****  * Otherwise, any operation to the I2C module can cause a hard fault
 289:../drivers/fsl_i2c.h ****  * because the clock is not enabled. The configuration structure can be custom filled
 290:../drivers/fsl_i2c.h ****  * or it can be set with default values by using the I2C_MasterGetDefaultConfig().
 291:../drivers/fsl_i2c.h ****  * After calling this API, the master is ready to transfer.
 292:../drivers/fsl_i2c.h ****  * This is an example.
 293:../drivers/fsl_i2c.h ****  * @code
 294:../drivers/fsl_i2c.h ****  * i2c_master_config_t config = {
 295:../drivers/fsl_i2c.h ****  * .enableMaster = true,
 296:../drivers/fsl_i2c.h ****  * .enableStopHold = false,
 297:../drivers/fsl_i2c.h ****  * .highDrive = false,
 298:../drivers/fsl_i2c.h ****  * .baudRate_Bps = 100000,
 299:../drivers/fsl_i2c.h ****  * .glitchFilterWidth = 0
 300:../drivers/fsl_i2c.h ****  * };
 301:../drivers/fsl_i2c.h ****  * I2C_MasterInit(I2C0, &config, 12000000U);
 302:../drivers/fsl_i2c.h ****  * @endcode
 303:../drivers/fsl_i2c.h ****  *
 304:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 305:../drivers/fsl_i2c.h ****  * @param masterConfig A pointer to the master configuration structure
 306:../drivers/fsl_i2c.h ****  * @param srcClock_Hz I2C peripheral clock frequency in Hz
 307:../drivers/fsl_i2c.h ****  */
 308:../drivers/fsl_i2c.h **** void I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz);
 309:../drivers/fsl_i2c.h **** 
 310:../drivers/fsl_i2c.h **** /*!
 311:../drivers/fsl_i2c.h ****  * @brief Initializes the I2C peripheral. Call this API to ungate the I2C clock
 312:../drivers/fsl_i2c.h ****  * and initialize the I2C with the slave configuration.
 313:../drivers/fsl_i2c.h ****  *
 314:../drivers/fsl_i2c.h ****  * @note This API should be called at the beginning of the application.
 315:../drivers/fsl_i2c.h ****  * Otherwise, any operation to the I2C module can cause a hard fault
 316:../drivers/fsl_i2c.h ****  * because the clock is not enabled. The configuration structure can partly be set
 317:../drivers/fsl_i2c.h ****  * with default values by I2C_SlaveGetDefaultConfig() or it can be custom filled by the user.
 318:../drivers/fsl_i2c.h ****  * This is an example.
 319:../drivers/fsl_i2c.h ****  * @code
 320:../drivers/fsl_i2c.h ****  * i2c_slave_config_t config = {
 321:../drivers/fsl_i2c.h ****  * .enableSlave = true,
 322:../drivers/fsl_i2c.h ****  * .enableGeneralCall = false,
 323:../drivers/fsl_i2c.h ****  * .addressingMode = kI2C_Address7bit,
 324:../drivers/fsl_i2c.h ****  * .slaveAddress = 0x1DU,
 325:../drivers/fsl_i2c.h ****  * .enableWakeUp = false,
 326:../drivers/fsl_i2c.h ****  * .enablehighDrive = false,
 327:../drivers/fsl_i2c.h ****  * .enableBaudRateCtl = false,
 328:../drivers/fsl_i2c.h ****  * .sclStopHoldTime_ns = 4000
 329:../drivers/fsl_i2c.h ****  * };
 330:../drivers/fsl_i2c.h ****  * I2C_SlaveInit(I2C0, &config, 12000000U);
 331:../drivers/fsl_i2c.h ****  * @endcode
 332:../drivers/fsl_i2c.h ****  *
 333:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 334:../drivers/fsl_i2c.h ****  * @param slaveConfig A pointer to the slave configuration structure
 335:../drivers/fsl_i2c.h ****  * @param srcClock_Hz I2C peripheral clock frequency in Hz
 336:../drivers/fsl_i2c.h ****  */
 337:../drivers/fsl_i2c.h **** void I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig, uint32_t srcClock_Hz);
 338:../drivers/fsl_i2c.h **** 
 339:../drivers/fsl_i2c.h **** /*!
 340:../drivers/fsl_i2c.h ****  * @brief De-initializes the I2C master peripheral. Call this API to gate the I2C clock.
 341:../drivers/fsl_i2c.h ****  * The I2C master module can't work unless the I2C_MasterInit is called.
 342:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 343:../drivers/fsl_i2c.h ****  */
 344:../drivers/fsl_i2c.h **** void I2C_MasterDeinit(I2C_Type *base);
 345:../drivers/fsl_i2c.h **** 
 346:../drivers/fsl_i2c.h **** /*!
 347:../drivers/fsl_i2c.h ****  * @brief De-initializes the I2C slave peripheral. Calling this API gates the I2C clock.
 348:../drivers/fsl_i2c.h ****  * The I2C slave module can't work unless the I2C_SlaveInit is called to enable the clock.
 349:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 350:../drivers/fsl_i2c.h ****  */
 351:../drivers/fsl_i2c.h **** void I2C_SlaveDeinit(I2C_Type *base);
 352:../drivers/fsl_i2c.h **** 
 353:../drivers/fsl_i2c.h **** /*!
 354:../drivers/fsl_i2c.h ****  * @brief  Sets the I2C master configuration structure to default values.
 355:../drivers/fsl_i2c.h ****  *
 356:../drivers/fsl_i2c.h ****  * The purpose of this API is to get the configuration structure initialized for use in the I2C_Mas
 357:../drivers/fsl_i2c.h ****  * Use the initialized structure unchanged in the I2C_MasterConfigure() or modify
 358:../drivers/fsl_i2c.h ****  * the structure before calling the I2C_MasterConfigure().
 359:../drivers/fsl_i2c.h ****  * This is an example.
 360:../drivers/fsl_i2c.h ****  * @code
 361:../drivers/fsl_i2c.h ****  * i2c_master_config_t config;
 362:../drivers/fsl_i2c.h ****  * I2C_MasterGetDefaultConfig(&config);
 363:../drivers/fsl_i2c.h ****  * @endcode
 364:../drivers/fsl_i2c.h ****  * @param masterConfig A pointer to the master configuration structure.
 365:../drivers/fsl_i2c.h **** */
 366:../drivers/fsl_i2c.h **** void I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig);
 367:../drivers/fsl_i2c.h **** 
 368:../drivers/fsl_i2c.h **** /*!
 369:../drivers/fsl_i2c.h ****  * @brief  Sets the I2C slave configuration structure to default values.
 370:../drivers/fsl_i2c.h ****  *
 371:../drivers/fsl_i2c.h ****  * The purpose of this API is to get the configuration structure initialized for use in the I2C_Sla
 372:../drivers/fsl_i2c.h ****  * Modify fields of the structure before calling the I2C_SlaveConfigure().
 373:../drivers/fsl_i2c.h ****  * This is an example.
 374:../drivers/fsl_i2c.h ****  * @code
 375:../drivers/fsl_i2c.h ****  * i2c_slave_config_t config;
 376:../drivers/fsl_i2c.h ****  * I2C_SlaveGetDefaultConfig(&config);
 377:../drivers/fsl_i2c.h ****  * @endcode
 378:../drivers/fsl_i2c.h ****  * @param slaveConfig A pointer to the slave configuration structure.
 379:../drivers/fsl_i2c.h ****  */
 380:../drivers/fsl_i2c.h **** void I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig);
 381:../drivers/fsl_i2c.h **** 
 382:../drivers/fsl_i2c.h **** /*!
 383:../drivers/fsl_i2c.h ****  * @brief Enables or disabless the I2C peripheral operation.
 384:../drivers/fsl_i2c.h ****  *
 385:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 386:../drivers/fsl_i2c.h ****  * @param enable Pass true to enable and false to disable the module.
 387:../drivers/fsl_i2c.h ****  */
 388:../drivers/fsl_i2c.h **** static inline void I2C_Enable(I2C_Type *base, bool enable)
 389:../drivers/fsl_i2c.h **** {
 390:../drivers/fsl_i2c.h ****     if (enable)
 391:../drivers/fsl_i2c.h ****     {
 392:../drivers/fsl_i2c.h ****         base->C1 |= I2C_C1_IICEN_MASK;
 393:../drivers/fsl_i2c.h ****     }
 394:../drivers/fsl_i2c.h ****     else
 395:../drivers/fsl_i2c.h ****     {
 396:../drivers/fsl_i2c.h ****         base->C1 &= ~I2C_C1_IICEN_MASK;
 356              		.loc 3 396 0
 357 0002 8378     		ldrb	r3, [r0, #2]
 358 0004 7F22     		movs	r2, #127
 359 0006 1340     		ands	r3, r2
 360 0008 8370     		strb	r3, [r0, #2]
 361              	.LVL40:
 362              	.LBE48:
 363              	.LBE47:
 568:../drivers/fsl_i2c.c ****     /* Disable I2C module. */
 569:../drivers/fsl_i2c.c ****     I2C_Enable(base, false);
 570:../drivers/fsl_i2c.c **** 
 571:../drivers/fsl_i2c.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 572:../drivers/fsl_i2c.c ****     /* Disable I2C clock. */
 573:../drivers/fsl_i2c.c ****     CLOCK_DisableClock(s_i2cClocks[I2C_GetInstance(base)]);
 364              		.loc 1 573 0
 365 000a FFF7FEFF 		bl	I2C_GetInstance
 366              	.LVL41:
 367 000e 8000     		lsls	r0, r0, #2
 368 0010 064B     		ldr	r3, .L35
 369 0012 C358     		ldr	r3, [r0, r3]
 370              	.LVL42:
 371              	.LBB49:
 372              	.LBB50:
 373              		.file 4 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 374              		.loc 4 460 0
 375 0014 1A0C     		lsrs	r2, r3, #16
 376 0016 0649     		ldr	r1, .L35+4
 377 0018 8C46     		mov	ip, r1
 378 001a 6244     		add	r2, r2, ip
 379              	.LVL43:
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 380              		.loc 4 461 0
 381 001c 1168     		ldr	r1, [r2]
 382 001e 1B04     		lsls	r3, r3, #16
 383              	.LVL44:
 384 0020 1B0C     		lsrs	r3, r3, #16
 385 0022 0120     		movs	r0, #1
 386              	.LVL45:
 387 0024 9840     		lsls	r0, r0, r3
 388 0026 8143     		bics	r1, r0
 389 0028 1160     		str	r1, [r2]
 390              	.LVL46:
 391              	.LBE50:
 392              	.LBE49:
 574:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 575:../drivers/fsl_i2c.c **** }
 393              		.loc 1 575 0
 394              		@ sp needed
 395 002a 10BD     		pop	{r4, pc}
 396              	.L36:
 397              		.align	2
 398              	.L35:
 399 002c 00000000 		.word	.LANCHOR3
 400 0030 00700440 		.word	1074032640
 401              		.cfi_endproc
 402              	.LFE66:
 404              		.section	.text.I2C_MasterGetDefaultConfig,"ax",%progbits
 405              		.align	1
 406              		.global	I2C_MasterGetDefaultConfig
 407              		.syntax unified
 408              		.code	16
 409              		.thumb_func
 410              		.fpu softvfp
 412              	I2C_MasterGetDefaultConfig:
 413              	.LFB67:
 576:../drivers/fsl_i2c.c **** 
 577:../drivers/fsl_i2c.c **** void I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig)
 578:../drivers/fsl_i2c.c **** {
 414              		.loc 1 578 0
 415              		.cfi_startproc
 416              		@ args = 0, pretend = 0, frame = 0
 417              		@ frame_needed = 0, uses_anonymous_args = 0
 418              		@ link register save eliminated.
 419              	.LVL47:
 579:../drivers/fsl_i2c.c ****     assert(masterConfig);
 580:../drivers/fsl_i2c.c **** 
 581:../drivers/fsl_i2c.c ****     /* Default baud rate at 100kbps. */
 582:../drivers/fsl_i2c.c ****     masterConfig->baudRate_Bps = 100000U;
 420              		.loc 1 582 0
 421 0000 034B     		ldr	r3, .L38
 422 0002 4360     		str	r3, [r0, #4]
 583:../drivers/fsl_i2c.c **** 
 584:../drivers/fsl_i2c.c **** /* Default stop hold enable is disabled. */
 585:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
 586:../drivers/fsl_i2c.c ****     masterConfig->enableStopHold = false;
 423              		.loc 1 586 0
 424 0004 0023     		movs	r3, #0
 425 0006 4370     		strb	r3, [r0, #1]
 587:../drivers/fsl_i2c.c **** #endif
 588:../drivers/fsl_i2c.c **** 
 589:../drivers/fsl_i2c.c ****     /* Default glitch filter value is no filter. */
 590:../drivers/fsl_i2c.c ****     masterConfig->glitchFilterWidth = 0U;
 426              		.loc 1 590 0
 427 0008 0372     		strb	r3, [r0, #8]
 591:../drivers/fsl_i2c.c **** 
 592:../drivers/fsl_i2c.c **** /* Default enable double buffering. */
 593:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
 594:../drivers/fsl_i2c.c ****     masterConfig->enableDoubleBuffering = true;
 595:../drivers/fsl_i2c.c **** #endif
 596:../drivers/fsl_i2c.c **** 
 597:../drivers/fsl_i2c.c ****     /* Enable the I2C peripheral. */
 598:../drivers/fsl_i2c.c ****     masterConfig->enableMaster = true;
 428              		.loc 1 598 0
 429 000a 0133     		adds	r3, r3, #1
 430 000c 0370     		strb	r3, [r0]
 599:../drivers/fsl_i2c.c **** }
 431              		.loc 1 599 0
 432              		@ sp needed
 433 000e 7047     		bx	lr
 434              	.L39:
 435              		.align	2
 436              	.L38:
 437 0010 A0860100 		.word	100000
 438              		.cfi_endproc
 439              	.LFE67:
 441              		.section	.text.I2C_EnableInterrupts,"ax",%progbits
 442              		.align	1
 443              		.global	I2C_EnableInterrupts
 444              		.syntax unified
 445              		.code	16
 446              		.thumb_func
 447              		.fpu softvfp
 449              	I2C_EnableInterrupts:
 450              	.LFB68:
 600:../drivers/fsl_i2c.c **** 
 601:../drivers/fsl_i2c.c **** void I2C_EnableInterrupts(I2C_Type *base, uint32_t mask)
 602:../drivers/fsl_i2c.c **** {
 451              		.loc 1 602 0
 452              		.cfi_startproc
 453              		@ args = 0, pretend = 0, frame = 0
 454              		@ frame_needed = 0, uses_anonymous_args = 0
 455              		@ link register save eliminated.
 456              	.LVL48:
 603:../drivers/fsl_i2c.c **** #ifdef I2C_HAS_STOP_DETECT
 604:../drivers/fsl_i2c.c ****     uint8_t fltReg;
 605:../drivers/fsl_i2c.c **** #endif
 606:../drivers/fsl_i2c.c **** 
 607:../drivers/fsl_i2c.c ****     if (mask & kI2C_GlobalInterruptEnable)
 457              		.loc 1 607 0
 458 0000 4B06     		lsls	r3, r1, #25
 459 0002 03D5     		bpl	.L41
 608:../drivers/fsl_i2c.c ****     {
 609:../drivers/fsl_i2c.c ****         base->C1 |= I2C_C1_IICIE_MASK;
 460              		.loc 1 609 0
 461 0004 8378     		ldrb	r3, [r0, #2]
 462 0006 4022     		movs	r2, #64
 463 0008 1343     		orrs	r3, r2
 464 000a 8370     		strb	r3, [r0, #2]
 465              	.L41:
 610:../drivers/fsl_i2c.c ****     }
 611:../drivers/fsl_i2c.c **** 
 612:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 613:../drivers/fsl_i2c.c ****     if (mask & kI2C_StopDetectInterruptEnable)
 614:../drivers/fsl_i2c.c ****     {
 615:../drivers/fsl_i2c.c ****         fltReg = base->FLT;
 616:../drivers/fsl_i2c.c **** 
 617:../drivers/fsl_i2c.c ****         /* Keep STOPF flag. */
 618:../drivers/fsl_i2c.c ****         fltReg &= ~I2C_FLT_STOPF_MASK;
 619:../drivers/fsl_i2c.c **** 
 620:../drivers/fsl_i2c.c ****         /* Stop detect enable. */
 621:../drivers/fsl_i2c.c ****         fltReg |= I2C_FLT_STOPIE_MASK;
 622:../drivers/fsl_i2c.c ****         base->FLT = fltReg;
 623:../drivers/fsl_i2c.c ****     }
 624:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
 625:../drivers/fsl_i2c.c **** 
 626:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 627:../drivers/fsl_i2c.c ****     if (mask & kI2C_StartStopDetectInterruptEnable)
 466              		.loc 1 627 0
 467 000c 8B06     		lsls	r3, r1, #26
 468 000e 05D5     		bpl	.L40
 628:../drivers/fsl_i2c.c ****     {
 629:../drivers/fsl_i2c.c ****         fltReg = base->FLT;
 469              		.loc 1 629 0
 470 0010 8379     		ldrb	r3, [r0, #6]
 471              	.LVL49:
 630:../drivers/fsl_i2c.c **** 
 631:../drivers/fsl_i2c.c ****         /* Keep STARTF and STOPF flags. */
 632:../drivers/fsl_i2c.c ****         fltReg &= ~(I2C_FLT_STOPF_MASK | I2C_FLT_STARTF_MASK);
 472              		.loc 1 632 0
 473 0012 5022     		movs	r2, #80
 474 0014 9343     		bics	r3, r2
 475              	.LVL50:
 633:../drivers/fsl_i2c.c **** 
 634:../drivers/fsl_i2c.c ****         /* Start and stop detect enable. */
 635:../drivers/fsl_i2c.c ****         fltReg |= I2C_FLT_SSIE_MASK;
 476              		.loc 1 635 0
 477 0016 2022     		movs	r2, #32
 478 0018 1343     		orrs	r3, r2
 479              	.LVL51:
 636:../drivers/fsl_i2c.c ****         base->FLT = fltReg;
 480              		.loc 1 636 0
 481 001a 8371     		strb	r3, [r0, #6]
 482              	.LVL52:
 483              	.L40:
 637:../drivers/fsl_i2c.c ****     }
 638:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 639:../drivers/fsl_i2c.c **** }
 484              		.loc 1 639 0
 485              		@ sp needed
 486 001c 7047     		bx	lr
 487              		.cfi_endproc
 488              	.LFE68:
 490              		.section	.text.I2C_DisableInterrupts,"ax",%progbits
 491              		.align	1
 492              		.global	I2C_DisableInterrupts
 493              		.syntax unified
 494              		.code	16
 495              		.thumb_func
 496              		.fpu softvfp
 498              	I2C_DisableInterrupts:
 499              	.LFB69:
 640:../drivers/fsl_i2c.c **** 
 641:../drivers/fsl_i2c.c **** void I2C_DisableInterrupts(I2C_Type *base, uint32_t mask)
 642:../drivers/fsl_i2c.c **** {
 500              		.loc 1 642 0
 501              		.cfi_startproc
 502              		@ args = 0, pretend = 0, frame = 0
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              		@ link register save eliminated.
 505              	.LVL53:
 643:../drivers/fsl_i2c.c ****     if (mask & kI2C_GlobalInterruptEnable)
 506              		.loc 1 643 0
 507 0000 4B06     		lsls	r3, r1, #25
 508 0002 03D5     		bpl	.L44
 644:../drivers/fsl_i2c.c ****     {
 645:../drivers/fsl_i2c.c ****         base->C1 &= ~I2C_C1_IICIE_MASK;
 509              		.loc 1 645 0
 510 0004 8378     		ldrb	r3, [r0, #2]
 511 0006 4022     		movs	r2, #64
 512 0008 9343     		bics	r3, r2
 513 000a 8370     		strb	r3, [r0, #2]
 514              	.L44:
 646:../drivers/fsl_i2c.c ****     }
 647:../drivers/fsl_i2c.c **** 
 648:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 649:../drivers/fsl_i2c.c ****     if (mask & kI2C_StopDetectInterruptEnable)
 650:../drivers/fsl_i2c.c ****     {
 651:../drivers/fsl_i2c.c ****         base->FLT &= ~(I2C_FLT_STOPIE_MASK | I2C_FLT_STOPF_MASK);
 652:../drivers/fsl_i2c.c ****     }
 653:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
 654:../drivers/fsl_i2c.c **** 
 655:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 656:../drivers/fsl_i2c.c ****     if (mask & kI2C_StartStopDetectInterruptEnable)
 515              		.loc 1 656 0
 516 000c 8B06     		lsls	r3, r1, #26
 517 000e 03D5     		bpl	.L43
 657:../drivers/fsl_i2c.c ****     {
 658:../drivers/fsl_i2c.c ****         base->FLT &= ~(I2C_FLT_SSIE_MASK | I2C_FLT_STOPF_MASK | I2C_FLT_STARTF_MASK);
 518              		.loc 1 658 0
 519 0010 8379     		ldrb	r3, [r0, #6]
 520 0012 7022     		movs	r2, #112
 521 0014 9343     		bics	r3, r2
 522 0016 8371     		strb	r3, [r0, #6]
 523              	.L43:
 659:../drivers/fsl_i2c.c ****     }
 660:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 661:../drivers/fsl_i2c.c **** }
 524              		.loc 1 661 0
 525              		@ sp needed
 526 0018 7047     		bx	lr
 527              		.cfi_endproc
 528              	.LFE69:
 530              		.section	.text.I2C_MasterSetBaudRate,"ax",%progbits
 531              		.align	1
 532              		.global	I2C_MasterSetBaudRate
 533              		.syntax unified
 534              		.code	16
 535              		.thumb_func
 536              		.fpu softvfp
 538              	I2C_MasterSetBaudRate:
 539              	.LFB70:
 662:../drivers/fsl_i2c.c **** 
 663:../drivers/fsl_i2c.c **** void I2C_MasterSetBaudRate(I2C_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
 664:../drivers/fsl_i2c.c **** {
 540              		.loc 1 664 0
 541              		.cfi_startproc
 542              		@ args = 0, pretend = 0, frame = 16
 543              		@ frame_needed = 0, uses_anonymous_args = 0
 544              	.LVL54:
 545 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 546              		.cfi_def_cfa_offset 20
 547              		.cfi_offset 4, -20
 548              		.cfi_offset 5, -16
 549              		.cfi_offset 6, -12
 550              		.cfi_offset 7, -8
 551              		.cfi_offset 14, -4
 552 0002 C646     		mov	lr, r8
 553 0004 00B5     		push	{lr}
 554              		.cfi_def_cfa_offset 24
 555              		.cfi_offset 8, -24
 556 0006 84B0     		sub	sp, sp, #16
 557              		.cfi_def_cfa_offset 40
 558 0008 8046     		mov	r8, r0
 559 000a 0F00     		movs	r7, r1
 560 000c 0092     		str	r2, [sp]
 561              	.LVL55:
 665:../drivers/fsl_i2c.c ****     uint32_t multiplier;
 666:../drivers/fsl_i2c.c ****     uint32_t computedRate;
 667:../drivers/fsl_i2c.c ****     uint32_t absError;
 668:../drivers/fsl_i2c.c ****     uint32_t bestError = UINT32_MAX;
 669:../drivers/fsl_i2c.c ****     uint32_t bestMult = 0u;
 670:../drivers/fsl_i2c.c ****     uint32_t bestIcr = 0u;
 671:../drivers/fsl_i2c.c ****     uint8_t mult;
 672:../drivers/fsl_i2c.c ****     uint8_t i;
 673:../drivers/fsl_i2c.c **** 
 674:../drivers/fsl_i2c.c ****     /* Search for the settings with the lowest error. Mult is the MULT field of the I2C_F register,
 675:../drivers/fsl_i2c.c ****      * and ranges from 0-2. It selects the multiplier factor for the divider. */
 676:../drivers/fsl_i2c.c ****     for (mult = 0u; (mult <= 2u) && (bestError != 0); ++mult)
 562              		.loc 1 676 0
 563 000e 0023     		movs	r3, #0
 564 0010 0193     		str	r3, [sp, #4]
 670:../drivers/fsl_i2c.c ****     uint8_t mult;
 565              		.loc 1 670 0
 566 0012 0393     		str	r3, [sp, #12]
 669:../drivers/fsl_i2c.c ****     uint32_t bestIcr = 0u;
 567              		.loc 1 669 0
 568 0014 0293     		str	r3, [sp, #8]
 668:../drivers/fsl_i2c.c ****     uint32_t bestMult = 0u;
 569              		.loc 1 668 0
 570 0016 0126     		movs	r6, #1
 571 0018 7642     		rsbs	r6, r6, #0
 572              		.loc 1 676 0
 573 001a 1EE0     		b	.L47
 574              	.LVL56:
 575              	.L49:
 677:../drivers/fsl_i2c.c ****     {
 678:../drivers/fsl_i2c.c ****         multiplier = 1u << mult;
 679:../drivers/fsl_i2c.c **** 
 680:../drivers/fsl_i2c.c ****         /* Scan table to find best match. */
 681:../drivers/fsl_i2c.c ****         for (i = 0u; i < sizeof(s_i2cDividerTable) / sizeof(uint16_t); ++i)
 682:../drivers/fsl_i2c.c ****         {
 683:../drivers/fsl_i2c.c ****             computedRate = srcClock_Hz / (multiplier * s_i2cDividerTable[i]);
 684:../drivers/fsl_i2c.c ****             absError = baudRate_Bps > computedRate ? (baudRate_Bps - computedRate) : (computedRate 
 576              		.loc 1 684 0 discriminator 2
 577 001c C01B     		subs	r0, r0, r7
 578              	.LVL57:
 579 001e 0DE0     		b	.L50
 580              	.LVL58:
 581              	.L51:
 681:../drivers/fsl_i2c.c ****         {
 582              		.loc 1 681 0 discriminator 2
 583 0020 0134     		adds	r4, r4, #1
 584              	.LVL59:
 585 0022 E4B2     		uxtb	r4, r4
 586              	.LVL60:
 587              	.L48:
 681:../drivers/fsl_i2c.c ****         {
 588              		.loc 1 681 0 is_stmt 0 discriminator 1
 589 0024 3F2C     		cmp	r4, #63
 590 0026 12D8     		bhi	.L56
 683:../drivers/fsl_i2c.c ****             absError = baudRate_Bps > computedRate ? (baudRate_Bps - computedRate) : (computedRate 
 591              		.loc 1 683 0 is_stmt 1
 592 0028 6300     		lsls	r3, r4, #1
 593 002a 174A     		ldr	r2, .L57
 594 002c 995A     		ldrh	r1, [r3, r2]
 595 002e A940     		lsls	r1, r1, r5
 596 0030 0098     		ldr	r0, [sp]
 597 0032 FFF7FEFF 		bl	__aeabi_uidiv
 598              	.LVL61:
 599              		.loc 1 684 0
 600 0036 B842     		cmp	r0, r7
 601 0038 F0D2     		bcs	.L49
 602              		.loc 1 684 0 is_stmt 0 discriminator 1
 603 003a 381A     		subs	r0, r7, r0
 604              	.LVL62:
 605              	.L50:
 685:../drivers/fsl_i2c.c **** 
 686:../drivers/fsl_i2c.c ****             if (absError < bestError)
 606              		.loc 1 686 0 is_stmt 1 discriminator 4
 607 003c 8642     		cmp	r6, r0
 608 003e EFD9     		bls	.L51
 687:../drivers/fsl_i2c.c ****             {
 688:../drivers/fsl_i2c.c ****                 bestMult = mult;
 609              		.loc 1 688 0
 610 0040 019B     		ldr	r3, [sp, #4]
 611 0042 0293     		str	r3, [sp, #8]
 612              	.LVL63:
 689:../drivers/fsl_i2c.c ****                 bestIcr = i;
 613              		.loc 1 689 0
 614 0044 0394     		str	r4, [sp, #12]
 615              	.LVL64:
 690:../drivers/fsl_i2c.c ****                 bestError = absError;
 691:../drivers/fsl_i2c.c **** 
 692:../drivers/fsl_i2c.c ****                 /* If the error is 0, then we can stop searching because we won't find a better mat
 693:../drivers/fsl_i2c.c ****                 if (absError == 0)
 616              		.loc 1 693 0
 617 0046 0028     		cmp	r0, #0
 618 0048 02D0     		beq	.L52
 619              	.LVL65:
 690:../drivers/fsl_i2c.c ****                 bestError = absError;
 620              		.loc 1 690 0
 621 004a 0600     		movs	r6, r0
 622 004c E8E7     		b	.L51
 623              	.LVL66:
 624              	.L56:
 625 004e 3000     		movs	r0, r6
 626              	.LVL67:
 627              	.L52:
 676:../drivers/fsl_i2c.c ****     {
 628              		.loc 1 676 0 discriminator 2
 629 0050 019D     		ldr	r5, [sp, #4]
 630              	.LVL68:
 631 0052 0135     		adds	r5, r5, #1
 632 0054 EBB2     		uxtb	r3, r5
 633 0056 0193     		str	r3, [sp, #4]
 634              	.LVL69:
 635 0058 0600     		movs	r6, r0
 636              	.LVL70:
 637              	.L47:
 676:../drivers/fsl_i2c.c ****     {
 638              		.loc 1 676 0 is_stmt 0 discriminator 1
 639 005a 019B     		ldr	r3, [sp, #4]
 640 005c 022B     		cmp	r3, #2
 641 005e 04D8     		bhi	.L54
 676:../drivers/fsl_i2c.c ****     {
 642              		.loc 1 676 0 discriminator 3
 643 0060 002E     		cmp	r6, #0
 644 0062 02D0     		beq	.L54
 678:../drivers/fsl_i2c.c **** 
 645              		.loc 1 678 0 is_stmt 1
 646 0064 019D     		ldr	r5, [sp, #4]
 647              	.LVL71:
 681:../drivers/fsl_i2c.c ****         {
 648              		.loc 1 681 0
 649 0066 0024     		movs	r4, #0
 650 0068 DCE7     		b	.L48
 651              	.LVL72:
 652              	.L54:
 694:../drivers/fsl_i2c.c ****                 {
 695:../drivers/fsl_i2c.c ****                     break;
 696:../drivers/fsl_i2c.c ****                 }
 697:../drivers/fsl_i2c.c ****             }
 698:../drivers/fsl_i2c.c ****         }
 699:../drivers/fsl_i2c.c ****     }
 700:../drivers/fsl_i2c.c **** 
 701:../drivers/fsl_i2c.c ****     /* Set frequency register based on best settings. */
 702:../drivers/fsl_i2c.c ****     base->F = I2C_F_MULT(bestMult) | I2C_F_ICR(bestIcr);
 653              		.loc 1 702 0
 654 006a 6B46     		mov	r3, sp
 655 006c 1E7A     		ldrb	r6, [r3, #8]
 656              	.LVL73:
 657 006e B601     		lsls	r6, r6, #6
 658 0070 F6B2     		uxtb	r6, r6
 659 0072 3F22     		movs	r2, #63
 660 0074 039F     		ldr	r7, [sp, #12]
 661              	.LVL74:
 662 0076 1740     		ands	r7, r2
 663 0078 3743     		orrs	r7, r6
 664 007a 4346     		mov	r3, r8
 665 007c 5F70     		strb	r7, [r3, #1]
 703:../drivers/fsl_i2c.c **** }
 666              		.loc 1 703 0
 667 007e 04B0     		add	sp, sp, #16
 668              	.LVL75:
 669              		@ sp needed
 670              	.LVL76:
 671 0080 04BC     		pop	{r2}
 672 0082 9046     		mov	r8, r2
 673 0084 F0BD     		pop	{r4, r5, r6, r7, pc}
 674              	.L58:
 675 0086 C046     		.align	2
 676              	.L57:
 677 0088 00000000 		.word	s_i2cDividerTable
 678              		.cfi_endproc
 679              	.LFE70:
 681              		.section	.text.I2C_MasterInit,"ax",%progbits
 682              		.align	1
 683              		.global	I2C_MasterInit
 684              		.syntax unified
 685              		.code	16
 686              		.thumb_func
 687              		.fpu softvfp
 689              	I2C_MasterInit:
 690              	.LFB65:
 505:../drivers/fsl_i2c.c ****     assert(masterConfig && srcClock_Hz);
 691              		.loc 1 505 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 0
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              	.LVL77:
 696 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 697              		.cfi_def_cfa_offset 24
 698              		.cfi_offset 3, -24
 699              		.cfi_offset 4, -20
 700              		.cfi_offset 5, -16
 701              		.cfi_offset 6, -12
 702              		.cfi_offset 7, -8
 703              		.cfi_offset 14, -4
 704 0002 0400     		movs	r4, r0
 705 0004 0D00     		movs	r5, r1
 706 0006 1600     		movs	r6, r2
 515:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 707              		.loc 1 515 0
 708 0008 FFF7FEFF 		bl	I2C_GetInstance
 709              	.LVL78:
 710 000c 8000     		lsls	r0, r0, #2
 711 000e 1D4B     		ldr	r3, .L60
 712 0010 C358     		ldr	r3, [r0, r3]
 713              	.LVL79:
 714              	.LBB51:
 715              	.LBB52:
 449:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 716              		.loc 4 449 0
 717 0012 1A0C     		lsrs	r2, r3, #16
 718 0014 1C49     		ldr	r1, .L60+4
 719 0016 8C46     		mov	ip, r1
 720 0018 6244     		add	r2, r2, ip
 721              	.LVL80:
 450:../drivers/fsl_clock.h **** }
 722              		.loc 4 450 0
 723 001a 1168     		ldr	r1, [r2]
 724 001c 1B04     		lsls	r3, r3, #16
 725              	.LVL81:
 726 001e 1B0C     		lsrs	r3, r3, #16
 727 0020 0120     		movs	r0, #1
 728              	.LVL82:
 729 0022 9840     		lsls	r0, r0, r3
 730 0024 0300     		movs	r3, r0
 731 0026 0B43     		orrs	r3, r1
 732 0028 1360     		str	r3, [r2]
 733              	.LVL83:
 734              	.LBE52:
 735              	.LBE51:
 519:../drivers/fsl_i2c.c ****     base->F = 0;
 736              		.loc 1 519 0
 737 002a 0023     		movs	r3, #0
 738 002c 2370     		strb	r3, [r4]
 520:../drivers/fsl_i2c.c ****     base->C1 = 0;
 739              		.loc 1 520 0
 740 002e 6370     		strb	r3, [r4, #1]
 521:../drivers/fsl_i2c.c ****     base->S = 0xFFU;
 741              		.loc 1 521 0
 742 0030 A370     		strb	r3, [r4, #2]
 522:../drivers/fsl_i2c.c ****     base->C2 = 0;
 743              		.loc 1 522 0
 744 0032 FF22     		movs	r2, #255
 745 0034 E270     		strb	r2, [r4, #3]
 523:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 746              		.loc 1 523 0
 747 0036 6371     		strb	r3, [r4, #5]
 525:../drivers/fsl_i2c.c **** #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 748              		.loc 1 525 0
 749 0038 5021     		movs	r1, #80
 750 003a AF3A     		subs	r2, r2, #175
 751 003c A271     		strb	r2, [r4, #6]
 529:../drivers/fsl_i2c.c **** 
 752              		.loc 1 529 0
 753 003e E371     		strb	r3, [r4, #7]
 532:../drivers/fsl_i2c.c **** 
 754              		.loc 1 532 0
 755 0040 A278     		ldrb	r2, [r4, #2]
 756 0042 7F27     		movs	r7, #127
 757 0044 3A40     		ands	r2, r7
 758 0046 A270     		strb	r2, [r4, #2]
 759              	.LVL84:
 760              	.LBB53:
 761              	.LBB54:
 397:../drivers/fsl_i2c.h ****     }
 398:../drivers/fsl_i2c.h **** }
 399:../drivers/fsl_i2c.h **** 
 400:../drivers/fsl_i2c.h **** /* @} */
 401:../drivers/fsl_i2c.h **** 
 402:../drivers/fsl_i2c.h **** /*!
 403:../drivers/fsl_i2c.h ****  * @name Status
 404:../drivers/fsl_i2c.h ****  * @{
 405:../drivers/fsl_i2c.h ****  */
 406:../drivers/fsl_i2c.h **** 
 407:../drivers/fsl_i2c.h **** /*!
 408:../drivers/fsl_i2c.h ****  * @brief Gets the I2C status flags.
 409:../drivers/fsl_i2c.h ****  *
 410:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 411:../drivers/fsl_i2c.h ****  * @return status flag, use status flag to AND #_i2c_flags to get the related status.
 412:../drivers/fsl_i2c.h ****  */
 413:../drivers/fsl_i2c.h **** uint32_t I2C_MasterGetStatusFlags(I2C_Type *base);
 414:../drivers/fsl_i2c.h **** 
 415:../drivers/fsl_i2c.h **** /*!
 416:../drivers/fsl_i2c.h ****  * @brief Gets the I2C status flags.
 417:../drivers/fsl_i2c.h ****  *
 418:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 419:../drivers/fsl_i2c.h ****  * @return status flag, use status flag to AND #_i2c_flags to get the related status.
 420:../drivers/fsl_i2c.h ****  */
 421:../drivers/fsl_i2c.h **** static inline uint32_t I2C_SlaveGetStatusFlags(I2C_Type *base)
 422:../drivers/fsl_i2c.h **** {
 423:../drivers/fsl_i2c.h ****     return I2C_MasterGetStatusFlags(base);
 424:../drivers/fsl_i2c.h **** }
 425:../drivers/fsl_i2c.h **** 
 426:../drivers/fsl_i2c.h **** /*!
 427:../drivers/fsl_i2c.h ****  * @brief Clears the I2C status flag state.
 428:../drivers/fsl_i2c.h ****  *
 429:../drivers/fsl_i2c.h ****  * The following status register flags can be cleared kI2C_ArbitrationLostFlag and kI2C_IntPendingF
 430:../drivers/fsl_i2c.h ****  *
 431:../drivers/fsl_i2c.h ****  * @param base I2C base pointer
 432:../drivers/fsl_i2c.h ****  * @param statusMask The status flag mask, defined in type i2c_status_flag_t.
 433:../drivers/fsl_i2c.h ****  *      The parameter can be any combination of the following values:
 434:../drivers/fsl_i2c.h ****  *          @arg kI2C_StartDetectFlag (if available)
 435:../drivers/fsl_i2c.h ****  *          @arg kI2C_StopDetectFlag (if available)
 436:../drivers/fsl_i2c.h ****  *          @arg kI2C_ArbitrationLostFlag
 437:../drivers/fsl_i2c.h ****  *          @arg kI2C_IntPendingFlagFlag
 438:../drivers/fsl_i2c.h ****  */
 439:../drivers/fsl_i2c.h **** static inline void I2C_MasterClearStatusFlags(I2C_Type *base, uint32_t statusMask)
 440:../drivers/fsl_i2c.h **** {
 441:../drivers/fsl_i2c.h **** /* Must clear the STARTF / STOPF bits prior to clearing IICIF */
 442:../drivers/fsl_i2c.h **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 443:../drivers/fsl_i2c.h ****     if (statusMask & kI2C_StartDetectFlag)
 444:../drivers/fsl_i2c.h ****     {
 445:../drivers/fsl_i2c.h ****         /* Shift the odd-ball flags back into place. */
 446:../drivers/fsl_i2c.h ****         base->FLT |= (uint8_t)(statusMask >> 8U);
 762              		.loc 3 446 0
 763 0048 A279     		ldrb	r2, [r4, #6]
 764 004a 0A43     		orrs	r2, r1
 765 004c A271     		strb	r2, [r4, #6]
 447:../drivers/fsl_i2c.h ****     }
 448:../drivers/fsl_i2c.h **** #endif
 449:../drivers/fsl_i2c.h **** 
 450:../drivers/fsl_i2c.h **** #ifdef I2C_HAS_STOP_DETECT
 451:../drivers/fsl_i2c.h ****     if (statusMask & kI2C_StopDetectFlag)
 452:../drivers/fsl_i2c.h ****     {
 453:../drivers/fsl_i2c.h ****         /* Shift the odd-ball flags back into place. */
 454:../drivers/fsl_i2c.h ****         base->FLT |= (uint8_t)(statusMask >> 8U);
 766              		.loc 3 454 0
 767 004e A379     		ldrb	r3, [r4, #6]
 768 0050 0B43     		orrs	r3, r1
 769 0052 A371     		strb	r3, [r4, #6]
 455:../drivers/fsl_i2c.h ****     }
 456:../drivers/fsl_i2c.h **** #endif
 457:../drivers/fsl_i2c.h **** 
 458:../drivers/fsl_i2c.h ****     base->S = (uint8_t)statusMask;
 770              		.loc 3 458 0
 771 0054 1223     		movs	r3, #18
 772 0056 E370     		strb	r3, [r4, #3]
 773              	.LVL85:
 774              	.LBE54:
 775              	.LBE53:
 538:../drivers/fsl_i2c.c **** 
 776              		.loc 1 538 0
 777 0058 3200     		movs	r2, r6
 778 005a 6968     		ldr	r1, [r5, #4]
 779 005c 2000     		movs	r0, r4
 780 005e FFF7FEFF 		bl	I2C_MasterSetBaudRate
 781              	.LVL86:
 541:../drivers/fsl_i2c.c **** 
 782              		.loc 1 541 0
 783 0062 A379     		ldrb	r3, [r4, #6]
 784              	.LVL87:
 545:../drivers/fsl_i2c.c ****     fltReg |= I2C_FLT_SHEN(masterConfig->enableStopHold);
 785              		.loc 1 545 0
 786 0064 1F40     		ands	r7, r3
 787              	.LVL88:
 546:../drivers/fsl_i2c.c **** #endif
 788              		.loc 1 546 0
 789 0066 6B78     		ldrb	r3, [r5, #1]
 790 0068 DB01     		lsls	r3, r3, #7
 791 006a DBB2     		uxtb	r3, r3
 792 006c 3B43     		orrs	r3, r7
 793              	.LVL89:
 550:../drivers/fsl_i2c.c ****     fltReg |= I2C_FLT_FLT(masterConfig->glitchFilterWidth);
 794              		.loc 1 550 0
 795 006e 0F22     		movs	r2, #15
 796 0070 9343     		bics	r3, r2
 797              	.LVL90:
 551:../drivers/fsl_i2c.c **** 
 798              		.loc 1 551 0
 799 0072 297A     		ldrb	r1, [r5, #8]
 800 0074 0A40     		ands	r2, r1
 801 0076 1343     		orrs	r3, r2
 802              	.LVL91:
 554:../drivers/fsl_i2c.c **** 
 803              		.loc 1 554 0
 804 0078 A371     		strb	r3, [r4, #6]
 563:../drivers/fsl_i2c.c **** }
 805              		.loc 1 563 0
 806 007a 2B78     		ldrb	r3, [r5]
 807              	.LVL92:
 808 007c DB01     		lsls	r3, r3, #7
 809 007e DBB2     		uxtb	r3, r3
 810 0080 A370     		strb	r3, [r4, #2]
 811              	.LVL93:
 564:../drivers/fsl_i2c.c **** 
 812              		.loc 1 564 0
 813              		@ sp needed
 814              	.LVL94:
 815              	.LVL95:
 816              	.LVL96:
 817 0082 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 818              	.L61:
 819              		.align	2
 820              	.L60:
 821 0084 00000000 		.word	.LANCHOR3
 822 0088 00700440 		.word	1074032640
 823              		.cfi_endproc
 824              	.LFE65:
 826              		.section	.text.I2C_MasterStop,"ax",%progbits
 827              		.align	1
 828              		.global	I2C_MasterStop
 829              		.syntax unified
 830              		.code	16
 831              		.thumb_func
 832              		.fpu softvfp
 834              	I2C_MasterStop:
 835              	.LFB73:
 704:../drivers/fsl_i2c.c **** 
 705:../drivers/fsl_i2c.c **** status_t I2C_MasterStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
 706:../drivers/fsl_i2c.c **** {
 707:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 708:../drivers/fsl_i2c.c ****     uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
 709:../drivers/fsl_i2c.c **** 
 710:../drivers/fsl_i2c.c ****     /* Return an error if the bus is already in use. */
 711:../drivers/fsl_i2c.c ****     if (statusFlags & kI2C_BusBusyFlag)
 712:../drivers/fsl_i2c.c ****     {
 713:../drivers/fsl_i2c.c ****         result = kStatus_I2C_Busy;
 714:../drivers/fsl_i2c.c ****     }
 715:../drivers/fsl_i2c.c ****     else
 716:../drivers/fsl_i2c.c ****     {
 717:../drivers/fsl_i2c.c ****         /* Send the START signal. */
 718:../drivers/fsl_i2c.c ****         base->C1 |= I2C_C1_MST_MASK | I2C_C1_TX_MASK;
 719:../drivers/fsl_i2c.c **** 
 720:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING
 721:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 722:../drivers/fsl_i2c.c ****         uint32_t waitTimes = I2C_WAIT_TIMEOUT;
 723:../drivers/fsl_i2c.c ****         while ((!(base->S2 & I2C_S2_EMPTY_MASK)) && (--waitTimes))
 724:../drivers/fsl_i2c.c ****         {
 725:../drivers/fsl_i2c.c ****         }
 726:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
 727:../drivers/fsl_i2c.c ****         {
 728:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
 729:../drivers/fsl_i2c.c ****         }
 730:../drivers/fsl_i2c.c **** #else
 731:../drivers/fsl_i2c.c ****         while (!(base->S2 & I2C_S2_EMPTY_MASK))
 732:../drivers/fsl_i2c.c ****         {
 733:../drivers/fsl_i2c.c ****         }
 734:../drivers/fsl_i2c.c **** #endif
 735:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING */
 736:../drivers/fsl_i2c.c **** 
 737:../drivers/fsl_i2c.c ****         base->D = (((uint32_t)address) << 1U | ((direction == kI2C_Read) ? 1U : 0U));
 738:../drivers/fsl_i2c.c ****     }
 739:../drivers/fsl_i2c.c **** 
 740:../drivers/fsl_i2c.c ****     return result;
 741:../drivers/fsl_i2c.c **** }
 742:../drivers/fsl_i2c.c **** 
 743:../drivers/fsl_i2c.c **** status_t I2C_MasterRepeatedStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
 744:../drivers/fsl_i2c.c **** {
 745:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 746:../drivers/fsl_i2c.c ****     uint8_t savedMult;
 747:../drivers/fsl_i2c.c ****     uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
 748:../drivers/fsl_i2c.c ****     uint8_t timeDelay = 6;
 749:../drivers/fsl_i2c.c **** 
 750:../drivers/fsl_i2c.c ****     /* Return an error if the bus is already in use, but not by us. */
 751:../drivers/fsl_i2c.c ****     if ((statusFlags & kI2C_BusBusyFlag) && ((base->C1 & I2C_C1_MST_MASK) == 0))
 752:../drivers/fsl_i2c.c ****     {
 753:../drivers/fsl_i2c.c ****         result = kStatus_I2C_Busy;
 754:../drivers/fsl_i2c.c ****     }
 755:../drivers/fsl_i2c.c ****     else
 756:../drivers/fsl_i2c.c ****     {
 757:../drivers/fsl_i2c.c ****         savedMult = base->F;
 758:../drivers/fsl_i2c.c ****         base->F = savedMult & (~I2C_F_MULT_MASK);
 759:../drivers/fsl_i2c.c **** 
 760:../drivers/fsl_i2c.c ****         /* We are already in a transfer, so send a repeated start. */
 761:../drivers/fsl_i2c.c ****         base->C1 |= I2C_C1_RSTA_MASK | I2C_C1_TX_MASK;
 762:../drivers/fsl_i2c.c **** 
 763:../drivers/fsl_i2c.c ****         /* Restore the multiplier factor. */
 764:../drivers/fsl_i2c.c ****         base->F = savedMult;
 765:../drivers/fsl_i2c.c **** 
 766:../drivers/fsl_i2c.c ****         /* Add some delay to wait the Re-Start signal. */
 767:../drivers/fsl_i2c.c ****         while (timeDelay--)
 768:../drivers/fsl_i2c.c ****         {
 769:../drivers/fsl_i2c.c ****             __NOP();
 770:../drivers/fsl_i2c.c ****         }
 771:../drivers/fsl_i2c.c **** 
 772:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING
 773:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 774:../drivers/fsl_i2c.c ****         uint32_t waitTimes = I2C_WAIT_TIMEOUT;
 775:../drivers/fsl_i2c.c ****         while ((!(base->S2 & I2C_S2_EMPTY_MASK)) && (--waitTimes))
 776:../drivers/fsl_i2c.c ****         {
 777:../drivers/fsl_i2c.c ****         }
 778:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
 779:../drivers/fsl_i2c.c ****         {
 780:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
 781:../drivers/fsl_i2c.c ****         }
 782:../drivers/fsl_i2c.c **** #else
 783:../drivers/fsl_i2c.c ****         while (!(base->S2 & I2C_S2_EMPTY_MASK))
 784:../drivers/fsl_i2c.c ****         {
 785:../drivers/fsl_i2c.c ****         }
 786:../drivers/fsl_i2c.c **** #endif
 787:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING */
 788:../drivers/fsl_i2c.c **** 
 789:../drivers/fsl_i2c.c ****         base->D = (((uint32_t)address) << 1U | ((direction == kI2C_Read) ? 1U : 0U));
 790:../drivers/fsl_i2c.c ****     }
 791:../drivers/fsl_i2c.c **** 
 792:../drivers/fsl_i2c.c ****     return result;
 793:../drivers/fsl_i2c.c **** }
 794:../drivers/fsl_i2c.c **** 
 795:../drivers/fsl_i2c.c **** status_t I2C_MasterStop(I2C_Type *base)
 796:../drivers/fsl_i2c.c **** {
 836              		.loc 1 796 0
 837              		.cfi_startproc
 838              		@ args = 0, pretend = 0, frame = 0
 839              		@ frame_needed = 0, uses_anonymous_args = 0
 840              		@ link register save eliminated.
 841              	.LVL97:
 797:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 798:../drivers/fsl_i2c.c **** 
 799:../drivers/fsl_i2c.c ****     /* Issue the STOP command on the bus. */
 800:../drivers/fsl_i2c.c ****     base->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
 842              		.loc 1 800 0
 843 0000 8378     		ldrb	r3, [r0, #2]
 844 0002 3822     		movs	r2, #56
 845 0004 9343     		bics	r3, r2
 846 0006 8370     		strb	r3, [r0, #2]
 847              	.L63:
 801:../drivers/fsl_i2c.c **** 
 802:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 803:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
 804:../drivers/fsl_i2c.c ****     /* Wait until bus not busy. */
 805:../drivers/fsl_i2c.c ****     while ((base->S & kI2C_BusBusyFlag) && (--waitTimes))
 806:../drivers/fsl_i2c.c ****     {
 807:../drivers/fsl_i2c.c ****     }
 808:../drivers/fsl_i2c.c **** 
 809:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
 810:../drivers/fsl_i2c.c ****     {
 811:../drivers/fsl_i2c.c ****         result = kStatus_I2C_Timeout;
 812:../drivers/fsl_i2c.c ****     }
 813:../drivers/fsl_i2c.c **** #else
 814:../drivers/fsl_i2c.c ****     /* Wait until data transfer complete. */
 815:../drivers/fsl_i2c.c ****     while (base->S & kI2C_BusBusyFlag)
 848              		.loc 1 815 0 discriminator 1
 849 0008 C378     		ldrb	r3, [r0, #3]
 850 000a 9B06     		lsls	r3, r3, #26
 851 000c FCD4     		bmi	.L63
 816:../drivers/fsl_i2c.c ****     {
 817:../drivers/fsl_i2c.c ****     }
 818:../drivers/fsl_i2c.c **** #endif
 819:../drivers/fsl_i2c.c **** 
 820:../drivers/fsl_i2c.c ****     return result;
 821:../drivers/fsl_i2c.c **** }
 852              		.loc 1 821 0
 853 000e 0020     		movs	r0, #0
 854              	.LVL98:
 855              		@ sp needed
 856 0010 7047     		bx	lr
 857              		.cfi_endproc
 858              	.LFE73:
 860              		.section	.text.I2C_MasterGetStatusFlags,"ax",%progbits
 861              		.align	1
 862              		.global	I2C_MasterGetStatusFlags
 863              		.syntax unified
 864              		.code	16
 865              		.thumb_func
 866              		.fpu softvfp
 868              	I2C_MasterGetStatusFlags:
 869              	.LFB74:
 822:../drivers/fsl_i2c.c **** 
 823:../drivers/fsl_i2c.c **** uint32_t I2C_MasterGetStatusFlags(I2C_Type *base)
 824:../drivers/fsl_i2c.c **** {
 870              		.loc 1 824 0
 871              		.cfi_startproc
 872              		@ args = 0, pretend = 0, frame = 0
 873              		@ frame_needed = 0, uses_anonymous_args = 0
 874              		@ link register save eliminated.
 875              	.LVL99:
 825:../drivers/fsl_i2c.c ****     uint32_t statusFlags = base->S;
 876              		.loc 1 825 0
 877 0000 C378     		ldrb	r3, [r0, #3]
 878 0002 DBB2     		uxtb	r3, r3
 879              	.LVL100:
 826:../drivers/fsl_i2c.c **** 
 827:../drivers/fsl_i2c.c **** #ifdef I2C_HAS_STOP_DETECT
 828:../drivers/fsl_i2c.c ****     /* Look up the STOPF bit from the filter register. */
 829:../drivers/fsl_i2c.c ****     if (base->FLT & I2C_FLT_STOPF_MASK)
 880              		.loc 1 829 0
 881 0004 8279     		ldrb	r2, [r0, #6]
 882 0006 5206     		lsls	r2, r2, #25
 883 0008 02D5     		bpl	.L65
 830:../drivers/fsl_i2c.c ****     {
 831:../drivers/fsl_i2c.c ****         statusFlags |= kI2C_StopDetectFlag;
 884              		.loc 1 831 0
 885 000a 8022     		movs	r2, #128
 886 000c D201     		lsls	r2, r2, #7
 887 000e 1343     		orrs	r3, r2
 888              	.LVL101:
 889              	.L65:
 832:../drivers/fsl_i2c.c ****     }
 833:../drivers/fsl_i2c.c **** #endif
 834:../drivers/fsl_i2c.c **** 
 835:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 836:../drivers/fsl_i2c.c ****     /* Look up the STARTF bit from the filter register. */
 837:../drivers/fsl_i2c.c ****     if (base->FLT & I2C_FLT_STARTF_MASK)
 890              		.loc 1 837 0
 891 0010 8279     		ldrb	r2, [r0, #6]
 892 0012 D206     		lsls	r2, r2, #27
 893 0014 02D5     		bpl	.L64
 838:../drivers/fsl_i2c.c ****     {
 839:../drivers/fsl_i2c.c ****         statusFlags |= kI2C_StartDetectFlag;
 894              		.loc 1 839 0
 895 0016 8022     		movs	r2, #128
 896 0018 5201     		lsls	r2, r2, #5
 897 001a 1343     		orrs	r3, r2
 898              	.LVL102:
 899              	.L64:
 840:../drivers/fsl_i2c.c ****     }
 841:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 842:../drivers/fsl_i2c.c **** 
 843:../drivers/fsl_i2c.c ****     return statusFlags;
 844:../drivers/fsl_i2c.c **** }
 900              		.loc 1 844 0
 901 001c 1800     		movs	r0, r3
 902              	.LVL103:
 903              		@ sp needed
 904 001e 7047     		bx	lr
 905              		.cfi_endproc
 906              	.LFE74:
 908              		.section	.text.I2C_MasterStart,"ax",%progbits
 909              		.align	1
 910              		.global	I2C_MasterStart
 911              		.syntax unified
 912              		.code	16
 913              		.thumb_func
 914              		.fpu softvfp
 916              	I2C_MasterStart:
 917              	.LFB71:
 706:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 918              		.loc 1 706 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 0
 921              		@ frame_needed = 0, uses_anonymous_args = 0
 922              	.LVL104:
 923 0000 70B5     		push	{r4, r5, r6, lr}
 924              		.cfi_def_cfa_offset 16
 925              		.cfi_offset 4, -16
 926              		.cfi_offset 5, -12
 927              		.cfi_offset 6, -8
 928              		.cfi_offset 14, -4
 929 0002 0400     		movs	r4, r0
 930 0004 0D00     		movs	r5, r1
 931 0006 1600     		movs	r6, r2
 932              	.LVL105:
 708:../drivers/fsl_i2c.c **** 
 933              		.loc 1 708 0
 934 0008 FFF7FEFF 		bl	I2C_MasterGetStatusFlags
 935              	.LVL106:
 711:../drivers/fsl_i2c.c ****     {
 936              		.loc 1 711 0
 937 000c 8306     		lsls	r3, r0, #26
 938 000e 11D4     		bmi	.L71
 718:../drivers/fsl_i2c.c **** 
 939              		.loc 1 718 0
 940 0010 A378     		ldrb	r3, [r4, #2]
 941 0012 3022     		movs	r2, #48
 942 0014 1343     		orrs	r3, r2
 943 0016 A370     		strb	r3, [r4, #2]
 944              	.L69:
 731:../drivers/fsl_i2c.c ****         {
 945              		.loc 1 731 0 discriminator 1
 946 0018 237B     		ldrb	r3, [r4, #12]
 947 001a DB07     		lsls	r3, r3, #31
 948 001c FCD5     		bpl	.L69
 737:../drivers/fsl_i2c.c ****     }
 949              		.loc 1 737 0
 950 001e 6D00     		lsls	r5, r5, #1
 951 0020 EDB2     		uxtb	r5, r5
 952 0022 012E     		cmp	r6, #1
 953 0024 04D0     		beq	.L73
 954 0026 0023     		movs	r3, #0
 955              	.L70:
 737:../drivers/fsl_i2c.c ****     }
 956              		.loc 1 737 0 is_stmt 0 discriminator 4
 957 0028 1D43     		orrs	r5, r3
 958 002a 2571     		strb	r5, [r4, #4]
 707:../drivers/fsl_i2c.c ****     uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
 959              		.loc 1 707 0 is_stmt 1 discriminator 4
 960 002c 0020     		movs	r0, #0
 961              	.LVL107:
 962              	.L67:
 741:../drivers/fsl_i2c.c **** 
 963              		.loc 1 741 0
 964              		@ sp needed
 965              	.LVL108:
 966 002e 70BD     		pop	{r4, r5, r6, pc}
 967              	.LVL109:
 968              	.L73:
 737:../drivers/fsl_i2c.c ****     }
 969              		.loc 1 737 0
 970 0030 0123     		movs	r3, #1
 971 0032 F9E7     		b	.L70
 972              	.L71:
 713:../drivers/fsl_i2c.c ****     }
 973              		.loc 1 713 0
 974 0034 0048     		ldr	r0, .L74
 975              	.LVL110:
 740:../drivers/fsl_i2c.c **** }
 976              		.loc 1 740 0
 977 0036 FAE7     		b	.L67
 978              	.L75:
 979              		.align	2
 980              	.L74:
 981 0038 4C040000 		.word	1100
 982              		.cfi_endproc
 983              	.LFE71:
 985              		.section	.text.I2C_MasterRepeatedStart,"ax",%progbits
 986              		.align	1
 987              		.global	I2C_MasterRepeatedStart
 988              		.syntax unified
 989              		.code	16
 990              		.thumb_func
 991              		.fpu softvfp
 993              	I2C_MasterRepeatedStart:
 994              	.LFB72:
 744:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 995              		.loc 1 744 0
 996              		.cfi_startproc
 997              		@ args = 0, pretend = 0, frame = 0
 998              		@ frame_needed = 0, uses_anonymous_args = 0
 999              	.LVL111:
 1000 0000 70B5     		push	{r4, r5, r6, lr}
 1001              		.cfi_def_cfa_offset 16
 1002              		.cfi_offset 4, -16
 1003              		.cfi_offset 5, -12
 1004              		.cfi_offset 6, -8
 1005              		.cfi_offset 14, -4
 1006 0002 0400     		movs	r4, r0
 1007 0004 0D00     		movs	r5, r1
 1008 0006 1600     		movs	r6, r2
 1009              	.LVL112:
 747:../drivers/fsl_i2c.c ****     uint8_t timeDelay = 6;
 1010              		.loc 1 747 0
 1011 0008 FFF7FEFF 		bl	I2C_MasterGetStatusFlags
 1012              	.LVL113:
 751:../drivers/fsl_i2c.c ****     {
 1013              		.loc 1 751 0
 1014 000c 8306     		lsls	r3, r0, #26
 1015 000e 02D5     		bpl	.L77
 751:../drivers/fsl_i2c.c ****     {
 1016              		.loc 1 751 0 is_stmt 0 discriminator 1
 1017 0010 A378     		ldrb	r3, [r4, #2]
 1018 0012 9B06     		lsls	r3, r3, #26
 1019 0014 1FD5     		bpl	.L83
 1020              	.L77:
 757:../drivers/fsl_i2c.c ****         base->F = savedMult & (~I2C_F_MULT_MASK);
 1021              		.loc 1 757 0 is_stmt 1
 1022 0016 6378     		ldrb	r3, [r4, #1]
 1023 0018 DBB2     		uxtb	r3, r3
 1024              	.LVL114:
 758:../drivers/fsl_i2c.c **** 
 1025              		.loc 1 758 0
 1026 001a 3F22     		movs	r2, #63
 1027 001c 1A40     		ands	r2, r3
 1028 001e 6270     		strb	r2, [r4, #1]
 761:../drivers/fsl_i2c.c **** 
 1029              		.loc 1 761 0
 1030 0020 A278     		ldrb	r2, [r4, #2]
 1031 0022 1421     		movs	r1, #20
 1032 0024 0A43     		orrs	r2, r1
 1033 0026 A270     		strb	r2, [r4, #2]
 764:../drivers/fsl_i2c.c **** 
 1034              		.loc 1 764 0
 1035 0028 6370     		strb	r3, [r4, #1]
 748:../drivers/fsl_i2c.c **** 
 1036              		.loc 1 748 0
 1037 002a 0622     		movs	r2, #6
 767:../drivers/fsl_i2c.c ****         {
 1038              		.loc 1 767 0
 1039 002c 01E0     		b	.L79
 1040              	.LVL115:
 1041              	.L80:
 769:../drivers/fsl_i2c.c ****         }
 1042              		.loc 1 769 0
 1043              		.syntax divided
 1044              	@ 769 "../drivers/fsl_i2c.c" 1
 1045 002e C046     		nop
 1046              	@ 0 "" 2
 767:../drivers/fsl_i2c.c ****         {
 1047              		.loc 1 767 0
 1048              		.thumb
 1049              		.syntax unified
 1050 0030 1A00     		movs	r2, r3
 1051              	.LVL116:
 1052              	.L79:
 1053 0032 531E     		subs	r3, r2, #1
 1054 0034 DBB2     		uxtb	r3, r3
 1055              	.LVL117:
 1056 0036 002A     		cmp	r2, #0
 1057 0038 F9D1     		bne	.L80
 1058              	.LVL118:
 1059              	.L81:
 783:../drivers/fsl_i2c.c ****         {
 1060              		.loc 1 783 0 discriminator 1
 1061 003a 237B     		ldrb	r3, [r4, #12]
 1062 003c DB07     		lsls	r3, r3, #31
 1063 003e FCD5     		bpl	.L81
 789:../drivers/fsl_i2c.c ****     }
 1064              		.loc 1 789 0
 1065 0040 6D00     		lsls	r5, r5, #1
 1066 0042 EDB2     		uxtb	r5, r5
 1067 0044 012E     		cmp	r6, #1
 1068 0046 04D0     		beq	.L85
 1069 0048 0023     		movs	r3, #0
 1070              	.L82:
 789:../drivers/fsl_i2c.c ****     }
 1071              		.loc 1 789 0 is_stmt 0 discriminator 4
 1072 004a 1D43     		orrs	r5, r3
 1073 004c 2571     		strb	r5, [r4, #4]
 1074              	.LVL119:
 745:../drivers/fsl_i2c.c ****     uint8_t savedMult;
 1075              		.loc 1 745 0 is_stmt 1 discriminator 4
 1076 004e 0020     		movs	r0, #0
 1077              	.LVL120:
 1078              	.L76:
 793:../drivers/fsl_i2c.c **** 
 1079              		.loc 1 793 0
 1080              		@ sp needed
 1081              	.LVL121:
 1082 0050 70BD     		pop	{r4, r5, r6, pc}
 1083              	.LVL122:
 1084              	.L85:
 789:../drivers/fsl_i2c.c ****     }
 1085              		.loc 1 789 0
 1086 0052 0123     		movs	r3, #1
 1087 0054 F9E7     		b	.L82
 1088              	.LVL123:
 1089              	.L83:
 753:../drivers/fsl_i2c.c ****     }
 1090              		.loc 1 753 0
 1091 0056 0148     		ldr	r0, .L86
 1092              	.LVL124:
 792:../drivers/fsl_i2c.c **** }
 1093              		.loc 1 792 0
 1094 0058 FAE7     		b	.L76
 1095              	.L87:
 1096 005a C046     		.align	2
 1097              	.L86:
 1098 005c 4C040000 		.word	1100
 1099              		.cfi_endproc
 1100              	.LFE72:
 1102              		.section	.text.I2C_MasterTransferRunStateMachine,"ax",%progbits
 1103              		.align	1
 1104              		.syntax unified
 1105              		.code	16
 1106              		.thumb_func
 1107              		.fpu softvfp
 1109              	I2C_MasterTransferRunStateMachine:
 1110              	.LFB63:
 328:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 1111              		.loc 1 328 0
 1112              		.cfi_startproc
 1113              		@ args = 0, pretend = 0, frame = 8
 1114              		@ frame_needed = 0, uses_anonymous_args = 0
 1115              	.LVL125:
 1116 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1117              		.cfi_def_cfa_offset 20
 1118              		.cfi_offset 4, -20
 1119              		.cfi_offset 5, -16
 1120              		.cfi_offset 6, -12
 1121              		.cfi_offset 7, -8
 1122              		.cfi_offset 14, -4
 1123 0002 C646     		mov	lr, r8
 1124 0004 00B5     		push	{lr}
 1125              		.cfi_def_cfa_offset 24
 1126              		.cfi_offset 8, -24
 1127 0006 82B0     		sub	sp, sp, #8
 1128              		.cfi_def_cfa_offset 32
 1129 0008 0700     		movs	r7, r0
 1130 000a 0C00     		movs	r4, r1
 1131 000c 9046     		mov	r8, r2
 1132              	.LVL126:
 330:../drivers/fsl_i2c.c ****     *isDone = false;
 1133              		.loc 1 330 0
 1134 000e C678     		ldrb	r6, [r0, #3]
 1135 0010 F6B2     		uxtb	r6, r6
 1136              	.LVL127:
 331:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
 1137              		.loc 1 331 0
 1138 0012 0023     		movs	r3, #0
 1139 0014 1370     		strb	r3, [r2]
 332:../drivers/fsl_i2c.c ****     bool ignoreNak = ((handle->state == kSendDataState) && (handle->transfer.dataSize == 0U)) ||
 1140              		.loc 1 332 0
 1141 0016 6A46     		mov	r2, sp
 1142              	.LVL128:
 1143 0018 D371     		strb	r3, [r2, #7]
 333:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 1144              		.loc 1 333 0
 1145 001a 0B7F     		ldrb	r3, [r1, #28]
 1146 001c 032B     		cmp	r3, #3
 1147 001e 3BD0     		beq	.L113
 1148              	.L89:
 333:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 1149              		.loc 1 333 0 is_stmt 0 discriminator 4
 1150 0020 052B     		cmp	r3, #5
 1151 0022 3ED0     		beq	.L114
 333:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 1152              		.loc 1 333 0
 1153 0024 0025     		movs	r5, #0
 1154              	.L90:
 1155              	.LVL129:
 337:../drivers/fsl_i2c.c **** 
 1156              		.loc 1 337 0 is_stmt 1 discriminator 7
 1157 0026 6B46     		mov	r3, sp
 1158 0028 DA1D     		adds	r2, r3, #7
 1159 002a DB79     		ldrb	r3, [r3, #7]
 1160 002c 0133     		adds	r3, r3, #1
 1161 002e DBB2     		uxtb	r3, r3
 1162 0030 1370     		strb	r3, [r2]
 340:../drivers/fsl_i2c.c **** 
 1163              		.loc 1 340 0 discriminator 7
 1164 0032 3100     		movs	r1, r6
 1165              	.LVL130:
 1166 0034 3800     		movs	r0, r7
 1167              	.LVL131:
 1168 0036 FFF7FEFF 		bl	I2C_CheckAndClearError
 1169              	.LVL132:
 343:../drivers/fsl_i2c.c ****     {
 1170              		.loc 1 343 0 discriminator 7
 1171 003a 554B     		ldr	r3, .L122
 1172 003c 9842     		cmp	r0, r3
 1173 003e 37D0     		beq	.L115
 1174              	.LVL133:
 1175              	.L91:
 350:../drivers/fsl_i2c.c ****     {
 1176              		.loc 1 350 0
 1177 0040 237F     		ldrb	r3, [r4, #28]
 1178 0042 012B     		cmp	r3, #1
 1179 0044 38D0     		beq	.L116
 1180              	.L92:
 378:../drivers/fsl_i2c.c ****     {
 1181              		.loc 1 378 0
 1182 0046 0028     		cmp	r0, #0
 1183 0048 00D0     		beq	.LCB1247
 1184 004a 9CE0     		b	.L88	@long jump
 1185              	.LCB1247:
 384:../drivers/fsl_i2c.c ****     {
 1186              		.loc 1 384 0
 1187 004c 237F     		ldrb	r3, [r4, #28]
 1188 004e 032B     		cmp	r3, #3
 1189 0050 6BD0     		beq	.L96
 1190 0052 42D9     		bls	.L117
 1191 0054 042B     		cmp	r3, #4
 1192 0056 79D0     		beq	.L99
 1193 0058 052B     		cmp	r3, #5
 1194 005a 00D0     		beq	.LCB1256
 1195 005c 93E0     		b	.L88	@long jump
 1196              	.LCB1256:
 454:../drivers/fsl_i2c.c ****             {
 1197              		.loc 1 454 0
 1198 005e 6369     		ldr	r3, [r4, #20]
 1199 0060 5A1E     		subs	r2, r3, #1
 1200 0062 6261     		str	r2, [r4, #20]
 1201 0064 002B     		cmp	r3, #0
 1202 0066 00D1     		bne	.LCB1261
 1203 0068 8DE0     		b	.L88	@long jump
 1204              	.LCB1261:
 456:../drivers/fsl_i2c.c ****                 {
 1205              		.loc 1 456 0
 1206 006a 6369     		ldr	r3, [r4, #20]
 1207 006c 002B     		cmp	r3, #0
 1208 006e 09D1     		bne	.L105
 458:../drivers/fsl_i2c.c **** 
 1209              		.loc 1 458 0
 1210 0070 0133     		adds	r3, r3, #1
 1211 0072 4246     		mov	r2, r8
 1212 0074 1370     		strb	r3, [r2]
 461:../drivers/fsl_i2c.c ****                     {
 1213              		.loc 1 461 0
 1214 0076 2368     		ldr	r3, [r4]
 1215 0078 5B07     		lsls	r3, r3, #29
 1216 007a 7AD5     		bpl	.L118
 1217              	.LVL134:
 467:../drivers/fsl_i2c.c ****                     }
 1218              		.loc 1 467 0
 1219 007c BB78     		ldrb	r3, [r7, #2]
 1220 007e 1022     		movs	r2, #16
 1221              	.LVL135:
 1222 0080 1343     		orrs	r3, r2
 1223 0082 BB70     		strb	r3, [r7, #2]
 1224              	.L105:
 472:../drivers/fsl_i2c.c ****                 {
 1225              		.loc 1 472 0
 1226 0084 6369     		ldr	r3, [r4, #20]
 1227 0086 012B     		cmp	r3, #1
 1228 0088 77D0     		beq	.L119
 1229              	.L107:
 478:../drivers/fsl_i2c.c ****                 handle->transfer.data++;
 1230              		.loc 1 478 0
 1231 008a 2369     		ldr	r3, [r4, #16]
 1232 008c 3A79     		ldrb	r2, [r7, #4]
 1233 008e 1A70     		strb	r2, [r3]
 479:../drivers/fsl_i2c.c ****             }
 1234              		.loc 1 479 0
 1235 0090 2369     		ldr	r3, [r4, #16]
 1236 0092 0133     		adds	r3, r3, #1
 1237 0094 2361     		str	r3, [r4, #16]
 1238 0096 76E0     		b	.L88
 1239              	.LVL136:
 1240              	.L113:
 333:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 1241              		.loc 1 333 0 discriminator 1
 1242 0098 4A69     		ldr	r2, [r1, #20]
 1243 009a 002A     		cmp	r2, #0
 1244 009c C0D1     		bne	.L89
 333:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 1245              		.loc 1 333 0 is_stmt 0
 1246 009e 0125     		movs	r5, #1
 1247 00a0 C1E7     		b	.L90
 1248              	.L114:
 334:../drivers/fsl_i2c.c **** 
 1249              		.loc 1 334 0 is_stmt 1
 1250 00a2 6369     		ldr	r3, [r4, #20]
 1251 00a4 012B     		cmp	r3, #1
 1252 00a6 01D0     		beq	.L110
 333:../drivers/fsl_i2c.c ****                      ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
 1253              		.loc 1 333 0
 1254 00a8 0025     		movs	r5, #0
 1255 00aa BCE7     		b	.L90
 1256              	.L110:
 1257 00ac 0125     		movs	r5, #1
 1258 00ae BAE7     		b	.L90
 1259              	.LVL137:
 1260              	.L115:
 343:../drivers/fsl_i2c.c ****     {
 1261              		.loc 1 343 0 discriminator 1
 1262 00b0 002D     		cmp	r5, #0
 1263 00b2 C5D0     		beq	.L91
 345:../drivers/fsl_i2c.c ****     }
 1264              		.loc 1 345 0
 1265 00b4 0020     		movs	r0, #0
 1266              	.LVL138:
 1267 00b6 C3E7     		b	.L91
 1268              	.LVL139:
 1269              	.L116:
 352:../drivers/fsl_i2c.c ****         {
 1270              		.loc 1 352 0
 1271 00b8 F307     		lsls	r3, r6, #31
 1272 00ba 63D4     		bmi	.L112
 358:../drivers/fsl_i2c.c ****             {
 1273              		.loc 1 358 0
 1274 00bc 237B     		ldrb	r3, [r4, #12]
 1275 00be 002B     		cmp	r3, #0
 1276 00c0 02D0     		beq	.L94
 360:../drivers/fsl_i2c.c ****             }
 1277              		.loc 1 360 0
 1278 00c2 0223     		movs	r3, #2
 1279 00c4 2377     		strb	r3, [r4, #28]
 1280 00c6 BEE7     		b	.L92
 1281              	.L94:
 364:../drivers/fsl_i2c.c ****                 {
 1282              		.loc 1 364 0
 1283 00c8 6379     		ldrb	r3, [r4, #5]
 1284 00ca 002B     		cmp	r3, #0
 1285 00cc 02D1     		bne	.L95
 367:../drivers/fsl_i2c.c ****                 }
 1286              		.loc 1 367 0
 1287 00ce 0333     		adds	r3, r3, #3
 1288 00d0 2377     		strb	r3, [r4, #28]
 1289 00d2 B8E7     		b	.L92
 1290              	.L95:
 372:../drivers/fsl_i2c.c ****                 }
 1291              		.loc 1 372 0
 1292 00d4 0423     		movs	r3, #4
 1293 00d6 2377     		strb	r3, [r4, #28]
 1294 00d8 B5E7     		b	.L92
 1295              	.L117:
 384:../drivers/fsl_i2c.c ****     {
 1296              		.loc 1 384 0
 1297 00da 022B     		cmp	r3, #2
 1298 00dc 53D1     		bne	.L88
 388:../drivers/fsl_i2c.c ****             {
 1299              		.loc 1 388 0
 1300 00de 237B     		ldrb	r3, [r4, #12]
 1301 00e0 002B     		cmp	r3, #0
 1302 00e2 11D1     		bne	.L120
 395:../drivers/fsl_i2c.c ****                 {
 1303              		.loc 1 395 0
 1304 00e4 6379     		ldrb	r3, [r4, #5]
 1305 00e6 002B     		cmp	r3, #0
 1306 00e8 17D1     		bne	.L102
 398:../drivers/fsl_i2c.c **** 
 1307              		.loc 1 398 0
 1308 00ea 0333     		adds	r3, r3, #3
 1309 00ec 2377     		strb	r3, [r4, #28]
 401:../drivers/fsl_i2c.c ****                     {
 1310              		.loc 1 401 0
 1311 00ee 6369     		ldr	r3, [r4, #20]
 1312 00f0 002B     		cmp	r3, #0
 1313 00f2 48D0     		beq	.L88
 403:../drivers/fsl_i2c.c ****                         handle->transfer.data++;
 1314              		.loc 1 403 0
 1315 00f4 2369     		ldr	r3, [r4, #16]
 1316 00f6 1B78     		ldrb	r3, [r3]
 1317 00f8 3B71     		strb	r3, [r7, #4]
 404:../drivers/fsl_i2c.c ****                         handle->transfer.dataSize--;
 1318              		.loc 1 404 0
 1319 00fa 2369     		ldr	r3, [r4, #16]
 1320 00fc 0133     		adds	r3, r3, #1
 1321 00fe 2361     		str	r3, [r4, #16]
 405:../drivers/fsl_i2c.c ****                     }
 1322              		.loc 1 405 0
 1323 0100 6369     		ldr	r3, [r4, #20]
 1324 0102 013B     		subs	r3, r3, #1
 1325 0104 6361     		str	r3, [r4, #20]
 1326 0106 3EE0     		b	.L88
 1327              	.L120:
 390:../drivers/fsl_i2c.c ****                 base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
 1328              		.loc 1 390 0
 1329 0108 013B     		subs	r3, r3, #1
 1330 010a DBB2     		uxtb	r3, r3
 1331 010c 2373     		strb	r3, [r4, #12]
 391:../drivers/fsl_i2c.c ****             }
 1332              		.loc 1 391 0
 1333 010e A268     		ldr	r2, [r4, #8]
 1334 0110 DB00     		lsls	r3, r3, #3
 1335 0112 DA40     		lsrs	r2, r2, r3
 1336 0114 D3B2     		uxtb	r3, r2
 1337 0116 3B71     		strb	r3, [r7, #4]
 1338 0118 35E0     		b	.L88
 1339              	.L102:
 411:../drivers/fsl_i2c.c **** 
 1340              		.loc 1 411 0
 1341 011a 2179     		ldrb	r1, [r4, #4]
 1342 011c 0122     		movs	r2, #1
 1343 011e 3800     		movs	r0, r7
 1344              	.LVL140:
 1345 0120 FFF7FEFF 		bl	I2C_MasterRepeatedStart
 1346              	.LVL141:
 414:../drivers/fsl_i2c.c ****                 }
 1347              		.loc 1 414 0
 1348 0124 0423     		movs	r3, #4
 1349 0126 2377     		strb	r3, [r4, #28]
 1350 0128 2DE0     		b	.L88
 1351              	.L96:
 422:../drivers/fsl_i2c.c ****             {
 1352              		.loc 1 422 0
 1353 012a 6369     		ldr	r3, [r4, #20]
 1354 012c 002B     		cmp	r3, #0
 1355 012e 09D0     		beq	.L103
 424:../drivers/fsl_i2c.c ****                 handle->transfer.data++;
 1356              		.loc 1 424 0
 1357 0130 2369     		ldr	r3, [r4, #16]
 1358 0132 1B78     		ldrb	r3, [r3]
 1359 0134 3B71     		strb	r3, [r7, #4]
 425:../drivers/fsl_i2c.c ****                 handle->transfer.dataSize--;
 1360              		.loc 1 425 0
 1361 0136 2369     		ldr	r3, [r4, #16]
 1362 0138 0133     		adds	r3, r3, #1
 1363 013a 2361     		str	r3, [r4, #16]
 426:../drivers/fsl_i2c.c ****             }
 1364              		.loc 1 426 0
 1365 013c 6369     		ldr	r3, [r4, #20]
 1366 013e 013B     		subs	r3, r3, #1
 1367 0140 6361     		str	r3, [r4, #20]
 1368 0142 20E0     		b	.L88
 1369              	.L103:
 430:../drivers/fsl_i2c.c ****             }
 1370              		.loc 1 430 0
 1371 0144 0123     		movs	r3, #1
 1372 0146 4246     		mov	r2, r8
 1373 0148 1370     		strb	r3, [r2]
 1374 014a 1CE0     		b	.L88
 1375              	.L99:
 436:../drivers/fsl_i2c.c **** 
 1376              		.loc 1 436 0
 1377 014c BB78     		ldrb	r3, [r7, #2]
 1378 014e 1822     		movs	r2, #24
 1379 0150 9343     		bics	r3, r2
 1380 0152 BB70     		strb	r3, [r7, #2]
 439:../drivers/fsl_i2c.c ****             {
 1381              		.loc 1 439 0
 1382 0154 6369     		ldr	r3, [r4, #20]
 1383 0156 012B     		cmp	r3, #1
 1384 0158 06D0     		beq	.L121
 1385              	.L104:
 445:../drivers/fsl_i2c.c **** 
 1386              		.loc 1 445 0
 1387 015a 3B79     		ldrb	r3, [r7, #4]
 1388 015c DBB2     		uxtb	r3, r3
 1389 015e 6A46     		mov	r2, sp
 1390 0160 D371     		strb	r3, [r2, #7]
 448:../drivers/fsl_i2c.c ****             break;
 1391              		.loc 1 448 0
 1392 0162 0523     		movs	r3, #5
 1393 0164 2377     		strb	r3, [r4, #28]
 449:../drivers/fsl_i2c.c **** 
 1394              		.loc 1 449 0
 1395 0166 0EE0     		b	.L88
 1396              	.L121:
 441:../drivers/fsl_i2c.c ****             }
 1397              		.loc 1 441 0
 1398 0168 BB78     		ldrb	r3, [r7, #2]
 1399 016a 0822     		movs	r2, #8
 1400 016c 1343     		orrs	r3, r2
 1401 016e BB70     		strb	r3, [r7, #2]
 1402 0170 F3E7     		b	.L104
 1403              	.LVL142:
 1404              	.L118:
 463:../drivers/fsl_i2c.c ****                     }
 1405              		.loc 1 463 0
 1406 0172 3800     		movs	r0, r7
 1407              	.LVL143:
 1408 0174 FFF7FEFF 		bl	I2C_MasterStop
 1409              	.LVL144:
 1410 0178 84E7     		b	.L105
 1411              	.L119:
 474:../drivers/fsl_i2c.c ****                 }
 1412              		.loc 1 474 0
 1413 017a BB78     		ldrb	r3, [r7, #2]
 1414 017c 0822     		movs	r2, #8
 1415 017e 1343     		orrs	r3, r2
 1416 0180 BB70     		strb	r3, [r7, #2]
 1417 0182 82E7     		b	.L107
 1418              	.L112:
 354:../drivers/fsl_i2c.c ****         }
 1419              		.loc 1 354 0
 1420 0184 0348     		ldr	r0, .L122+4
 1421              	.LVL145:
 1422              	.L88:
 488:../drivers/fsl_i2c.c **** 
 1423              		.loc 1 488 0
 1424 0186 02B0     		add	sp, sp, #8
 1425              		@ sp needed
 1426              	.LVL146:
 1427              	.LVL147:
 1428              	.LVL148:
 1429              	.LVL149:
 1430              	.LVL150:
 1431 0188 04BC     		pop	{r2}
 1432 018a 9046     		mov	r8, r2
 1433 018c F0BD     		pop	{r4, r5, r6, r7, pc}
 1434              	.L123:
 1435 018e C046     		.align	2
 1436              	.L122:
 1437 0190 4E040000 		.word	1102
 1438 0194 51040000 		.word	1105
 1439              		.cfi_endproc
 1440              	.LFE63:
 1442              		.section	.text.I2C_MasterTransferHandleIRQ,"ax",%progbits
 1443              		.align	1
 1444              		.global	I2C_MasterTransferHandleIRQ
 1445              		.syntax unified
 1446              		.code	16
 1447              		.thumb_func
 1448              		.fpu softvfp
 1450              	I2C_MasterTransferHandleIRQ:
 1451              	.LFB82:
 845:../drivers/fsl_i2c.c **** 
 846:../drivers/fsl_i2c.c **** status_t I2C_MasterWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize, uint32_t fla
 847:../drivers/fsl_i2c.c **** {
 848:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 849:../drivers/fsl_i2c.c ****     uint8_t statusFlags = 0;
 850:../drivers/fsl_i2c.c **** 
 851:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 852:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
 853:../drivers/fsl_i2c.c ****     /* Wait until the data register is ready for transmit. */
 854:../drivers/fsl_i2c.c ****     while ((!(base->S & kI2C_TransferCompleteFlag)) && (--waitTimes))
 855:../drivers/fsl_i2c.c ****     {
 856:../drivers/fsl_i2c.c ****     }
 857:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
 858:../drivers/fsl_i2c.c ****     {
 859:../drivers/fsl_i2c.c ****         return kStatus_I2C_Timeout;
 860:../drivers/fsl_i2c.c ****     }
 861:../drivers/fsl_i2c.c **** #else
 862:../drivers/fsl_i2c.c ****     /* Wait until the data register is ready for transmit. */
 863:../drivers/fsl_i2c.c ****     while (!(base->S & kI2C_TransferCompleteFlag))
 864:../drivers/fsl_i2c.c ****     {
 865:../drivers/fsl_i2c.c ****     }
 866:../drivers/fsl_i2c.c **** #endif
 867:../drivers/fsl_i2c.c **** 
 868:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
 869:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
 870:../drivers/fsl_i2c.c **** 
 871:../drivers/fsl_i2c.c ****     /* Setup the I2C peripheral to transmit data. */
 872:../drivers/fsl_i2c.c ****     base->C1 |= I2C_C1_TX_MASK;
 873:../drivers/fsl_i2c.c **** 
 874:../drivers/fsl_i2c.c ****     while (txSize--)
 875:../drivers/fsl_i2c.c ****     {
 876:../drivers/fsl_i2c.c ****         /* Send a byte of data. */
 877:../drivers/fsl_i2c.c ****         base->D = *txBuff++;
 878:../drivers/fsl_i2c.c **** 
 879:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 880:../drivers/fsl_i2c.c ****         waitTimes = I2C_WAIT_TIMEOUT;
 881:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
 882:../drivers/fsl_i2c.c ****         while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
 883:../drivers/fsl_i2c.c ****         {
 884:../drivers/fsl_i2c.c ****         }
 885:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
 886:../drivers/fsl_i2c.c ****         {
 887:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
 888:../drivers/fsl_i2c.c ****         }
 889:../drivers/fsl_i2c.c **** #else
 890:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
 891:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_IntPendingFlag))
 892:../drivers/fsl_i2c.c ****         {
 893:../drivers/fsl_i2c.c ****         }
 894:../drivers/fsl_i2c.c **** #endif
 895:../drivers/fsl_i2c.c ****         statusFlags = base->S;
 896:../drivers/fsl_i2c.c **** 
 897:../drivers/fsl_i2c.c ****         /* Clear the IICIF flag. */
 898:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
 899:../drivers/fsl_i2c.c **** 
 900:../drivers/fsl_i2c.c ****         /* Check if arbitration lost or no acknowledgement (NAK), return failure status. */
 901:../drivers/fsl_i2c.c ****         if (statusFlags & kI2C_ArbitrationLostFlag)
 902:../drivers/fsl_i2c.c ****         {
 903:../drivers/fsl_i2c.c ****             base->S = kI2C_ArbitrationLostFlag;
 904:../drivers/fsl_i2c.c ****             result = kStatus_I2C_ArbitrationLost;
 905:../drivers/fsl_i2c.c ****         }
 906:../drivers/fsl_i2c.c **** 
 907:../drivers/fsl_i2c.c ****         if ((statusFlags & kI2C_ReceiveNakFlag) && txSize)
 908:../drivers/fsl_i2c.c ****         {
 909:../drivers/fsl_i2c.c ****             base->S = kI2C_ReceiveNakFlag;
 910:../drivers/fsl_i2c.c ****             result = kStatus_I2C_Nak;
 911:../drivers/fsl_i2c.c ****         }
 912:../drivers/fsl_i2c.c **** 
 913:../drivers/fsl_i2c.c ****         if (result != kStatus_Success)
 914:../drivers/fsl_i2c.c ****         {
 915:../drivers/fsl_i2c.c ****             /* Breaking out of the send loop. */
 916:../drivers/fsl_i2c.c ****             break;
 917:../drivers/fsl_i2c.c ****         }
 918:../drivers/fsl_i2c.c ****     }
 919:../drivers/fsl_i2c.c **** 
 920:../drivers/fsl_i2c.c ****     if (((result == kStatus_Success) && (!(flags & kI2C_TransferNoStopFlag))) || (result == kStatus
 921:../drivers/fsl_i2c.c ****     {
 922:../drivers/fsl_i2c.c ****         /* Clear the IICIF flag. */
 923:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
 924:../drivers/fsl_i2c.c **** 
 925:../drivers/fsl_i2c.c ****         /* Send stop. */
 926:../drivers/fsl_i2c.c ****         result = I2C_MasterStop(base);
 927:../drivers/fsl_i2c.c ****     }
 928:../drivers/fsl_i2c.c **** 
 929:../drivers/fsl_i2c.c ****     return result;
 930:../drivers/fsl_i2c.c **** }
 931:../drivers/fsl_i2c.c **** 
 932:../drivers/fsl_i2c.c **** status_t I2C_MasterReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize, uint32_t flags)
 933:../drivers/fsl_i2c.c **** {
 934:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 935:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
 936:../drivers/fsl_i2c.c **** 
 937:../drivers/fsl_i2c.c ****     /* Add this to avoid build warning. */
 938:../drivers/fsl_i2c.c ****     dummy++;
 939:../drivers/fsl_i2c.c **** 
 940:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 941:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
 942:../drivers/fsl_i2c.c ****     /* Wait until the data register is ready for transmit. */
 943:../drivers/fsl_i2c.c ****     while ((!(base->S & kI2C_TransferCompleteFlag)) && (--waitTimes))
 944:../drivers/fsl_i2c.c ****     {
 945:../drivers/fsl_i2c.c ****     }
 946:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
 947:../drivers/fsl_i2c.c ****     {
 948:../drivers/fsl_i2c.c ****         return kStatus_I2C_Timeout;
 949:../drivers/fsl_i2c.c ****     }
 950:../drivers/fsl_i2c.c **** #else
 951:../drivers/fsl_i2c.c ****     /* Wait until the data register is ready for transmit. */
 952:../drivers/fsl_i2c.c ****     while (!(base->S & kI2C_TransferCompleteFlag))
 953:../drivers/fsl_i2c.c ****     {
 954:../drivers/fsl_i2c.c ****     }
 955:../drivers/fsl_i2c.c **** #endif
 956:../drivers/fsl_i2c.c **** 
 957:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
 958:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
 959:../drivers/fsl_i2c.c **** 
 960:../drivers/fsl_i2c.c ****     /* Setup the I2C peripheral to receive data. */
 961:../drivers/fsl_i2c.c ****     base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
 962:../drivers/fsl_i2c.c **** 
 963:../drivers/fsl_i2c.c ****     /* If rxSize equals 1, configure to send NAK. */
 964:../drivers/fsl_i2c.c ****     if (rxSize == 1)
 965:../drivers/fsl_i2c.c ****     {
 966:../drivers/fsl_i2c.c ****         /* Issue NACK on read. */
 967:../drivers/fsl_i2c.c ****         base->C1 |= I2C_C1_TXAK_MASK;
 968:../drivers/fsl_i2c.c ****     }
 969:../drivers/fsl_i2c.c **** 
 970:../drivers/fsl_i2c.c ****     /* Do dummy read. */
 971:../drivers/fsl_i2c.c ****     dummy = base->D;
 972:../drivers/fsl_i2c.c **** 
 973:../drivers/fsl_i2c.c ****     while ((rxSize--))
 974:../drivers/fsl_i2c.c ****     {
 975:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 976:../drivers/fsl_i2c.c ****         waitTimes = I2C_WAIT_TIMEOUT;
 977:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
 978:../drivers/fsl_i2c.c ****         while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
 979:../drivers/fsl_i2c.c ****         {
 980:../drivers/fsl_i2c.c ****         }
 981:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
 982:../drivers/fsl_i2c.c ****         {
 983:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
 984:../drivers/fsl_i2c.c ****         }
 985:../drivers/fsl_i2c.c **** #else
 986:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
 987:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_IntPendingFlag))
 988:../drivers/fsl_i2c.c ****         {
 989:../drivers/fsl_i2c.c ****         }
 990:../drivers/fsl_i2c.c **** #endif
 991:../drivers/fsl_i2c.c ****         /* Clear the IICIF flag. */
 992:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
 993:../drivers/fsl_i2c.c **** 
 994:../drivers/fsl_i2c.c ****         /* Single byte use case. */
 995:../drivers/fsl_i2c.c ****         if (rxSize == 0)
 996:../drivers/fsl_i2c.c ****         {
 997:../drivers/fsl_i2c.c ****             if (!(flags & kI2C_TransferNoStopFlag))
 998:../drivers/fsl_i2c.c ****             {
 999:../drivers/fsl_i2c.c ****                 /* Issue STOP command before reading last byte. */
1000:../drivers/fsl_i2c.c ****                 result = I2C_MasterStop(base);
1001:../drivers/fsl_i2c.c ****             }
1002:../drivers/fsl_i2c.c ****             else
1003:../drivers/fsl_i2c.c ****             {
1004:../drivers/fsl_i2c.c ****                 /* Change direction to Tx to avoid extra clocks. */
1005:../drivers/fsl_i2c.c ****                 base->C1 |= I2C_C1_TX_MASK;
1006:../drivers/fsl_i2c.c ****             }
1007:../drivers/fsl_i2c.c ****         }
1008:../drivers/fsl_i2c.c **** 
1009:../drivers/fsl_i2c.c ****         if (rxSize == 1)
1010:../drivers/fsl_i2c.c ****         {
1011:../drivers/fsl_i2c.c ****             /* Issue NACK on read. */
1012:../drivers/fsl_i2c.c ****             base->C1 |= I2C_C1_TXAK_MASK;
1013:../drivers/fsl_i2c.c ****         }
1014:../drivers/fsl_i2c.c **** 
1015:../drivers/fsl_i2c.c ****         /* Read from the data register. */
1016:../drivers/fsl_i2c.c ****         *rxBuff++ = base->D;
1017:../drivers/fsl_i2c.c ****     }
1018:../drivers/fsl_i2c.c **** 
1019:../drivers/fsl_i2c.c ****     return result;
1020:../drivers/fsl_i2c.c **** }
1021:../drivers/fsl_i2c.c **** 
1022:../drivers/fsl_i2c.c **** status_t I2C_MasterTransferBlocking(I2C_Type *base, i2c_master_transfer_t *xfer)
1023:../drivers/fsl_i2c.c **** {
1024:../drivers/fsl_i2c.c ****     assert(xfer);
1025:../drivers/fsl_i2c.c **** 
1026:../drivers/fsl_i2c.c ****     i2c_direction_t direction = xfer->direction;
1027:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
1028:../drivers/fsl_i2c.c **** 
1029:../drivers/fsl_i2c.c ****     /* Clear all status before transfer. */
1030:../drivers/fsl_i2c.c ****     I2C_MasterClearStatusFlags(base, kClearFlags);
1031:../drivers/fsl_i2c.c **** 
1032:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1033:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
1034:../drivers/fsl_i2c.c ****     /* Wait until the data register is ready for transmit. */
1035:../drivers/fsl_i2c.c ****     while ((!(base->S & kI2C_TransferCompleteFlag)) && (--waitTimes))
1036:../drivers/fsl_i2c.c ****     {
1037:../drivers/fsl_i2c.c ****     }
1038:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
1039:../drivers/fsl_i2c.c ****     {
1040:../drivers/fsl_i2c.c ****         return kStatus_I2C_Timeout;
1041:../drivers/fsl_i2c.c ****     }
1042:../drivers/fsl_i2c.c **** #else
1043:../drivers/fsl_i2c.c ****     /* Wait until the data register is ready for transmit. */
1044:../drivers/fsl_i2c.c ****     while (!(base->S & kI2C_TransferCompleteFlag))
1045:../drivers/fsl_i2c.c ****     {
1046:../drivers/fsl_i2c.c ****     }
1047:../drivers/fsl_i2c.c **** #endif
1048:../drivers/fsl_i2c.c **** 
1049:../drivers/fsl_i2c.c ****     /* Change to send write address when it's a read operation with command. */
1050:../drivers/fsl_i2c.c ****     if ((xfer->subaddressSize > 0) && (xfer->direction == kI2C_Read))
1051:../drivers/fsl_i2c.c ****     {
1052:../drivers/fsl_i2c.c ****         direction = kI2C_Write;
1053:../drivers/fsl_i2c.c ****     }
1054:../drivers/fsl_i2c.c **** 
1055:../drivers/fsl_i2c.c ****     /* Handle no start option, only support write with no start signal. */
1056:../drivers/fsl_i2c.c ****     if (xfer->flags & kI2C_TransferNoStartFlag)
1057:../drivers/fsl_i2c.c ****     {
1058:../drivers/fsl_i2c.c ****         if (direction == kI2C_Read)
1059:../drivers/fsl_i2c.c ****         {
1060:../drivers/fsl_i2c.c ****             return kStatus_InvalidArgument;
1061:../drivers/fsl_i2c.c ****         }
1062:../drivers/fsl_i2c.c ****     }
1063:../drivers/fsl_i2c.c ****     /* If repeated start is requested, send repeated start. */
1064:../drivers/fsl_i2c.c ****     else if (xfer->flags & kI2C_TransferRepeatedStartFlag)
1065:../drivers/fsl_i2c.c ****     {
1066:../drivers/fsl_i2c.c ****         result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, direction);
1067:../drivers/fsl_i2c.c ****     }
1068:../drivers/fsl_i2c.c ****     else /* For normal transfer, send start. */
1069:../drivers/fsl_i2c.c ****     {
1070:../drivers/fsl_i2c.c ****         result = I2C_MasterStart(base, xfer->slaveAddress, direction);
1071:../drivers/fsl_i2c.c ****     }
1072:../drivers/fsl_i2c.c **** 
1073:../drivers/fsl_i2c.c ****     if (!(xfer->flags & kI2C_TransferNoStartFlag))
1074:../drivers/fsl_i2c.c ****     {
1075:../drivers/fsl_i2c.c ****         /* Return if error. */
1076:../drivers/fsl_i2c.c ****         if (result)
1077:../drivers/fsl_i2c.c ****         {
1078:../drivers/fsl_i2c.c ****             return result;
1079:../drivers/fsl_i2c.c ****         }
1080:../drivers/fsl_i2c.c **** 
1081:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1082:../drivers/fsl_i2c.c ****         waitTimes = I2C_WAIT_TIMEOUT;
1083:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1084:../drivers/fsl_i2c.c ****         while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1085:../drivers/fsl_i2c.c ****         {
1086:../drivers/fsl_i2c.c ****         }
1087:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
1088:../drivers/fsl_i2c.c ****         {
1089:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
1090:../drivers/fsl_i2c.c ****         }
1091:../drivers/fsl_i2c.c **** #else
1092:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1093:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_IntPendingFlag))
1094:../drivers/fsl_i2c.c ****         {
1095:../drivers/fsl_i2c.c ****         }
1096:../drivers/fsl_i2c.c **** #endif
1097:../drivers/fsl_i2c.c ****         /* Check if there's transfer error. */
1098:../drivers/fsl_i2c.c ****         result = I2C_CheckAndClearError(base, base->S);
1099:../drivers/fsl_i2c.c **** 
1100:../drivers/fsl_i2c.c ****         /* Return if error. */
1101:../drivers/fsl_i2c.c ****         if (result)
1102:../drivers/fsl_i2c.c ****         {
1103:../drivers/fsl_i2c.c ****             if (result == kStatus_I2C_Nak)
1104:../drivers/fsl_i2c.c ****             {
1105:../drivers/fsl_i2c.c ****                 result = kStatus_I2C_Addr_Nak;
1106:../drivers/fsl_i2c.c **** 
1107:../drivers/fsl_i2c.c ****                 I2C_MasterStop(base);
1108:../drivers/fsl_i2c.c ****             }
1109:../drivers/fsl_i2c.c **** 
1110:../drivers/fsl_i2c.c ****             return result;
1111:../drivers/fsl_i2c.c ****         }
1112:../drivers/fsl_i2c.c ****     }
1113:../drivers/fsl_i2c.c **** 
1114:../drivers/fsl_i2c.c ****     /* Send subaddress. */
1115:../drivers/fsl_i2c.c ****     if (xfer->subaddressSize)
1116:../drivers/fsl_i2c.c ****     {
1117:../drivers/fsl_i2c.c ****         do
1118:../drivers/fsl_i2c.c ****         {
1119:../drivers/fsl_i2c.c ****             /* Clear interrupt pending flag. */
1120:../drivers/fsl_i2c.c ****             base->S = kI2C_IntPendingFlag;
1121:../drivers/fsl_i2c.c **** 
1122:../drivers/fsl_i2c.c ****             xfer->subaddressSize--;
1123:../drivers/fsl_i2c.c ****             base->D = ((xfer->subaddress) >> (8 * xfer->subaddressSize));
1124:../drivers/fsl_i2c.c **** 
1125:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1126:../drivers/fsl_i2c.c ****             waitTimes = I2C_WAIT_TIMEOUT;
1127:../drivers/fsl_i2c.c ****             /* Wait until data transfer complete. */
1128:../drivers/fsl_i2c.c ****             while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1129:../drivers/fsl_i2c.c ****             {
1130:../drivers/fsl_i2c.c ****             }
1131:../drivers/fsl_i2c.c ****             if (waitTimes == 0)
1132:../drivers/fsl_i2c.c ****             {
1133:../drivers/fsl_i2c.c ****                 return kStatus_I2C_Timeout;
1134:../drivers/fsl_i2c.c ****             }
1135:../drivers/fsl_i2c.c **** #else
1136:../drivers/fsl_i2c.c ****             /* Wait until data transfer complete. */
1137:../drivers/fsl_i2c.c ****             while (!(base->S & kI2C_IntPendingFlag))
1138:../drivers/fsl_i2c.c ****             {
1139:../drivers/fsl_i2c.c ****             }
1140:../drivers/fsl_i2c.c **** #endif
1141:../drivers/fsl_i2c.c **** 
1142:../drivers/fsl_i2c.c ****             /* Check if there's transfer error. */
1143:../drivers/fsl_i2c.c ****             result = I2C_CheckAndClearError(base, base->S);
1144:../drivers/fsl_i2c.c **** 
1145:../drivers/fsl_i2c.c ****             if (result)
1146:../drivers/fsl_i2c.c ****             {
1147:../drivers/fsl_i2c.c ****                 if (result == kStatus_I2C_Nak)
1148:../drivers/fsl_i2c.c ****                 {
1149:../drivers/fsl_i2c.c ****                     I2C_MasterStop(base);
1150:../drivers/fsl_i2c.c ****                 }
1151:../drivers/fsl_i2c.c **** 
1152:../drivers/fsl_i2c.c ****                 return result;
1153:../drivers/fsl_i2c.c ****             }
1154:../drivers/fsl_i2c.c **** 
1155:../drivers/fsl_i2c.c ****         } while ((xfer->subaddressSize > 0) && (result == kStatus_Success));
1156:../drivers/fsl_i2c.c **** 
1157:../drivers/fsl_i2c.c ****         if (xfer->direction == kI2C_Read)
1158:../drivers/fsl_i2c.c ****         {
1159:../drivers/fsl_i2c.c ****             /* Clear pending flag. */
1160:../drivers/fsl_i2c.c ****             base->S = kI2C_IntPendingFlag;
1161:../drivers/fsl_i2c.c **** 
1162:../drivers/fsl_i2c.c ****             /* Send repeated start and slave address. */
1163:../drivers/fsl_i2c.c ****             result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, kI2C_Read);
1164:../drivers/fsl_i2c.c **** 
1165:../drivers/fsl_i2c.c ****             /* Return if error. */
1166:../drivers/fsl_i2c.c ****             if (result)
1167:../drivers/fsl_i2c.c ****             {
1168:../drivers/fsl_i2c.c ****                 return result;
1169:../drivers/fsl_i2c.c ****             }
1170:../drivers/fsl_i2c.c **** 
1171:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1172:../drivers/fsl_i2c.c ****             waitTimes = I2C_WAIT_TIMEOUT;
1173:../drivers/fsl_i2c.c ****             /* Wait until data transfer complete. */
1174:../drivers/fsl_i2c.c ****             while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1175:../drivers/fsl_i2c.c ****             {
1176:../drivers/fsl_i2c.c ****             }
1177:../drivers/fsl_i2c.c ****             if (waitTimes == 0)
1178:../drivers/fsl_i2c.c ****             {
1179:../drivers/fsl_i2c.c ****                 return kStatus_I2C_Timeout;
1180:../drivers/fsl_i2c.c ****             }
1181:../drivers/fsl_i2c.c **** #else
1182:../drivers/fsl_i2c.c ****             /* Wait until data transfer complete. */
1183:../drivers/fsl_i2c.c ****             while (!(base->S & kI2C_IntPendingFlag))
1184:../drivers/fsl_i2c.c ****             {
1185:../drivers/fsl_i2c.c ****             }
1186:../drivers/fsl_i2c.c **** #endif
1187:../drivers/fsl_i2c.c **** 
1188:../drivers/fsl_i2c.c ****             /* Check if there's transfer error. */
1189:../drivers/fsl_i2c.c ****             result = I2C_CheckAndClearError(base, base->S);
1190:../drivers/fsl_i2c.c **** 
1191:../drivers/fsl_i2c.c ****             if (result)
1192:../drivers/fsl_i2c.c ****             {
1193:../drivers/fsl_i2c.c ****                 if (result == kStatus_I2C_Nak)
1194:../drivers/fsl_i2c.c ****                 {
1195:../drivers/fsl_i2c.c ****                     result = kStatus_I2C_Addr_Nak;
1196:../drivers/fsl_i2c.c **** 
1197:../drivers/fsl_i2c.c ****                     I2C_MasterStop(base);
1198:../drivers/fsl_i2c.c ****                 }
1199:../drivers/fsl_i2c.c **** 
1200:../drivers/fsl_i2c.c ****                 return result;
1201:../drivers/fsl_i2c.c ****             }
1202:../drivers/fsl_i2c.c ****         }
1203:../drivers/fsl_i2c.c ****     }
1204:../drivers/fsl_i2c.c **** 
1205:../drivers/fsl_i2c.c ****     /* Transmit data. */
1206:../drivers/fsl_i2c.c ****     if ((xfer->direction == kI2C_Write) && (xfer->dataSize > 0))
1207:../drivers/fsl_i2c.c ****     {
1208:../drivers/fsl_i2c.c ****         /* Send Data. */
1209:../drivers/fsl_i2c.c ****         result = I2C_MasterWriteBlocking(base, xfer->data, xfer->dataSize, xfer->flags);
1210:../drivers/fsl_i2c.c ****     }
1211:../drivers/fsl_i2c.c **** 
1212:../drivers/fsl_i2c.c ****     /* Receive Data. */
1213:../drivers/fsl_i2c.c ****     if ((xfer->direction == kI2C_Read) && (xfer->dataSize > 0))
1214:../drivers/fsl_i2c.c ****     {
1215:../drivers/fsl_i2c.c ****         result = I2C_MasterReadBlocking(base, xfer->data, xfer->dataSize, xfer->flags);
1216:../drivers/fsl_i2c.c ****     }
1217:../drivers/fsl_i2c.c **** 
1218:../drivers/fsl_i2c.c ****     return result;
1219:../drivers/fsl_i2c.c **** }
1220:../drivers/fsl_i2c.c **** 
1221:../drivers/fsl_i2c.c **** void I2C_MasterTransferCreateHandle(I2C_Type *base,
1222:../drivers/fsl_i2c.c ****                                     i2c_master_handle_t *handle,
1223:../drivers/fsl_i2c.c ****                                     i2c_master_transfer_callback_t callback,
1224:../drivers/fsl_i2c.c ****                                     void *userData)
1225:../drivers/fsl_i2c.c **** {
1226:../drivers/fsl_i2c.c ****     assert(handle);
1227:../drivers/fsl_i2c.c **** 
1228:../drivers/fsl_i2c.c ****     uint32_t instance = I2C_GetInstance(base);
1229:../drivers/fsl_i2c.c **** 
1230:../drivers/fsl_i2c.c ****     /* Zero handle. */
1231:../drivers/fsl_i2c.c ****     memset(handle, 0, sizeof(*handle));
1232:../drivers/fsl_i2c.c **** 
1233:../drivers/fsl_i2c.c ****     /* Set callback and userData. */
1234:../drivers/fsl_i2c.c ****     handle->completionCallback = callback;
1235:../drivers/fsl_i2c.c ****     handle->userData = userData;
1236:../drivers/fsl_i2c.c **** 
1237:../drivers/fsl_i2c.c ****     /* Save the context in global variables to support the double weak mechanism. */
1238:../drivers/fsl_i2c.c ****     s_i2cHandle[instance] = handle;
1239:../drivers/fsl_i2c.c **** 
1240:../drivers/fsl_i2c.c ****     /* Save master interrupt handler. */
1241:../drivers/fsl_i2c.c ****     s_i2cMasterIsr = I2C_MasterTransferHandleIRQ;
1242:../drivers/fsl_i2c.c **** 
1243:../drivers/fsl_i2c.c ****     /* Enable NVIC interrupt. */
1244:../drivers/fsl_i2c.c ****     EnableIRQ(s_i2cIrqs[instance]);
1245:../drivers/fsl_i2c.c **** }
1246:../drivers/fsl_i2c.c **** 
1247:../drivers/fsl_i2c.c **** status_t I2C_MasterTransferNonBlocking(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_tran
1248:../drivers/fsl_i2c.c **** {
1249:../drivers/fsl_i2c.c ****     assert(handle);
1250:../drivers/fsl_i2c.c ****     assert(xfer);
1251:../drivers/fsl_i2c.c **** 
1252:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
1253:../drivers/fsl_i2c.c **** 
1254:../drivers/fsl_i2c.c ****     /* Check if the I2C bus is idle - if not return busy status. */
1255:../drivers/fsl_i2c.c ****     if (handle->state != kIdleState)
1256:../drivers/fsl_i2c.c ****     {
1257:../drivers/fsl_i2c.c ****         result = kStatus_I2C_Busy;
1258:../drivers/fsl_i2c.c ****     }
1259:../drivers/fsl_i2c.c ****     else
1260:../drivers/fsl_i2c.c ****     {
1261:../drivers/fsl_i2c.c ****         /* Start up the master transfer state machine. */
1262:../drivers/fsl_i2c.c ****         result = I2C_InitTransferStateMachine(base, handle, xfer);
1263:../drivers/fsl_i2c.c **** 
1264:../drivers/fsl_i2c.c ****         if (result == kStatus_Success)
1265:../drivers/fsl_i2c.c ****         {
1266:../drivers/fsl_i2c.c ****             /* Enable the I2C interrupts. */
1267:../drivers/fsl_i2c.c ****             I2C_EnableInterrupts(base, kI2C_GlobalInterruptEnable);
1268:../drivers/fsl_i2c.c ****         }
1269:../drivers/fsl_i2c.c ****     }
1270:../drivers/fsl_i2c.c **** 
1271:../drivers/fsl_i2c.c ****     return result;
1272:../drivers/fsl_i2c.c **** }
1273:../drivers/fsl_i2c.c **** 
1274:../drivers/fsl_i2c.c **** status_t I2C_MasterTransferAbort(I2C_Type *base, i2c_master_handle_t *handle)
1275:../drivers/fsl_i2c.c **** {
1276:../drivers/fsl_i2c.c ****     assert(handle);
1277:../drivers/fsl_i2c.c **** 
1278:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
1279:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1280:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
1281:../drivers/fsl_i2c.c **** #endif
1282:../drivers/fsl_i2c.c **** 
1283:../drivers/fsl_i2c.c ****     /* Add this to avoid build warning. */
1284:../drivers/fsl_i2c.c ****     dummy++;
1285:../drivers/fsl_i2c.c **** 
1286:../drivers/fsl_i2c.c ****     /* Disable interrupt. */
1287:../drivers/fsl_i2c.c ****     I2C_DisableInterrupts(base, kI2C_GlobalInterruptEnable);
1288:../drivers/fsl_i2c.c **** 
1289:../drivers/fsl_i2c.c ****     /* Reset the state to idle. */
1290:../drivers/fsl_i2c.c ****     handle->state = kIdleState;
1291:../drivers/fsl_i2c.c **** 
1292:../drivers/fsl_i2c.c ****     /* If the bus is already in use, but not by us */
1293:../drivers/fsl_i2c.c ****     if (!(base->C1 & I2C_C1_MST_MASK))
1294:../drivers/fsl_i2c.c ****     {
1295:../drivers/fsl_i2c.c ****         return kStatus_I2C_Busy;
1296:../drivers/fsl_i2c.c ****     }
1297:../drivers/fsl_i2c.c **** 
1298:../drivers/fsl_i2c.c ****     /* Send STOP signal. */
1299:../drivers/fsl_i2c.c ****     if (handle->transfer.direction == kI2C_Read)
1300:../drivers/fsl_i2c.c ****     {
1301:../drivers/fsl_i2c.c ****         base->C1 |= I2C_C1_TXAK_MASK;
1302:../drivers/fsl_i2c.c **** 
1303:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1304:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1305:../drivers/fsl_i2c.c ****         while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1306:../drivers/fsl_i2c.c ****         {
1307:../drivers/fsl_i2c.c ****         }
1308:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
1309:../drivers/fsl_i2c.c ****         {
1310:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
1311:../drivers/fsl_i2c.c ****         }
1312:../drivers/fsl_i2c.c **** #else
1313:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1314:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_IntPendingFlag))
1315:../drivers/fsl_i2c.c ****         {
1316:../drivers/fsl_i2c.c ****         }
1317:../drivers/fsl_i2c.c **** #endif
1318:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
1319:../drivers/fsl_i2c.c **** 
1320:../drivers/fsl_i2c.c ****         base->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
1321:../drivers/fsl_i2c.c ****         dummy = base->D;
1322:../drivers/fsl_i2c.c ****     }
1323:../drivers/fsl_i2c.c ****     else
1324:../drivers/fsl_i2c.c ****     {
1325:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1326:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1327:../drivers/fsl_i2c.c ****         while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1328:../drivers/fsl_i2c.c ****         {
1329:../drivers/fsl_i2c.c ****         }
1330:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
1331:../drivers/fsl_i2c.c ****         {
1332:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
1333:../drivers/fsl_i2c.c ****         }
1334:../drivers/fsl_i2c.c **** #else
1335:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1336:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_IntPendingFlag))
1337:../drivers/fsl_i2c.c ****         {
1338:../drivers/fsl_i2c.c ****         }
1339:../drivers/fsl_i2c.c **** #endif
1340:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
1341:../drivers/fsl_i2c.c ****         base->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
1342:../drivers/fsl_i2c.c ****     }
1343:../drivers/fsl_i2c.c **** 
1344:../drivers/fsl_i2c.c ****     return kStatus_Success;
1345:../drivers/fsl_i2c.c **** }
1346:../drivers/fsl_i2c.c **** 
1347:../drivers/fsl_i2c.c **** status_t I2C_MasterTransferGetCount(I2C_Type *base, i2c_master_handle_t *handle, size_t *count)
1348:../drivers/fsl_i2c.c **** {
1349:../drivers/fsl_i2c.c ****     assert(handle);
1350:../drivers/fsl_i2c.c **** 
1351:../drivers/fsl_i2c.c ****     if (!count)
1352:../drivers/fsl_i2c.c ****     {
1353:../drivers/fsl_i2c.c ****         return kStatus_InvalidArgument;
1354:../drivers/fsl_i2c.c ****     }
1355:../drivers/fsl_i2c.c **** 
1356:../drivers/fsl_i2c.c ****     *count = handle->transferSize - handle->transfer.dataSize;
1357:../drivers/fsl_i2c.c **** 
1358:../drivers/fsl_i2c.c ****     return kStatus_Success;
1359:../drivers/fsl_i2c.c **** }
1360:../drivers/fsl_i2c.c **** 
1361:../drivers/fsl_i2c.c **** void I2C_MasterTransferHandleIRQ(I2C_Type *base, void *i2cHandle)
1362:../drivers/fsl_i2c.c **** {
 1452              		.loc 1 1362 0
 1453              		.cfi_startproc
 1454              		@ args = 0, pretend = 0, frame = 8
 1455              		@ frame_needed = 0, uses_anonymous_args = 0
 1456              	.LVL151:
 1457 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1458              		.cfi_def_cfa_offset 20
 1459              		.cfi_offset 4, -20
 1460              		.cfi_offset 5, -16
 1461              		.cfi_offset 6, -12
 1462              		.cfi_offset 7, -8
 1463              		.cfi_offset 14, -4
 1464 0002 83B0     		sub	sp, sp, #12
 1465              		.cfi_def_cfa_offset 32
 1466 0004 0500     		movs	r5, r0
 1467 0006 0C00     		movs	r4, r1
 1468              	.LVL152:
1363:../drivers/fsl_i2c.c ****     assert(i2cHandle);
1364:../drivers/fsl_i2c.c **** 
1365:../drivers/fsl_i2c.c ****     i2c_master_handle_t *handle = (i2c_master_handle_t *)i2cHandle;
1366:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
1367:../drivers/fsl_i2c.c ****     bool isDone;
1368:../drivers/fsl_i2c.c **** 
1369:../drivers/fsl_i2c.c ****     /* Clear the interrupt flag. */
1370:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
 1469              		.loc 1 1370 0
 1470 0008 0223     		movs	r3, #2
 1471 000a C370     		strb	r3, [r0, #3]
1371:../drivers/fsl_i2c.c **** 
1372:../drivers/fsl_i2c.c ****     /* Check transfer complete flag. */
1373:../drivers/fsl_i2c.c ****     result = I2C_MasterTransferRunStateMachine(base, handle, &isDone);
 1472              		.loc 1 1373 0
 1473 000c 6B46     		mov	r3, sp
 1474 000e DE1D     		adds	r6, r3, #7
 1475 0010 3200     		movs	r2, r6
 1476 0012 FFF7FEFF 		bl	I2C_MasterTransferRunStateMachine
 1477              	.LVL153:
 1478 0016 0700     		movs	r7, r0
 1479              	.LVL154:
1374:../drivers/fsl_i2c.c **** 
1375:../drivers/fsl_i2c.c ****     if (isDone || result)
 1480              		.loc 1 1375 0
 1481 0018 3378     		ldrb	r3, [r6]
 1482 001a 002B     		cmp	r3, #0
 1483 001c 01D1     		bne	.L125
 1484              		.loc 1 1375 0 is_stmt 0 discriminator 1
 1485 001e 0028     		cmp	r0, #0
 1486 0020 19D0     		beq	.L124
 1487              	.L125:
1376:../drivers/fsl_i2c.c ****     {
1377:../drivers/fsl_i2c.c ****         /* Send stop command if transfer done or received Nak. */
1378:../drivers/fsl_i2c.c ****         if ((!(handle->transfer.flags & kI2C_TransferNoStopFlag)) || (result == kStatus_I2C_Nak) ||
 1488              		.loc 1 1378 0 is_stmt 1
 1489 0022 2368     		ldr	r3, [r4]
 1490 0024 5B07     		lsls	r3, r3, #29
 1491 0026 05D5     		bpl	.L127
 1492              		.loc 1 1378 0 is_stmt 0 discriminator 1
 1493 0028 104B     		ldr	r3, .L131
 1494 002a 9F42     		cmp	r7, r3
 1495 002c 02D0     		beq	.L127
 1496              		.loc 1 1378 0 discriminator 2
 1497 002e 104B     		ldr	r3, .L131+4
 1498 0030 9F42     		cmp	r7, r3
 1499 0032 02D1     		bne	.L128
 1500              	.L127:
1379:../drivers/fsl_i2c.c ****             (result == kStatus_I2C_Addr_Nak))
1380:../drivers/fsl_i2c.c ****         {
1381:../drivers/fsl_i2c.c ****             /* Ensure stop command is a need. */
1382:../drivers/fsl_i2c.c ****             if ((base->C1 & I2C_C1_MST_MASK))
 1501              		.loc 1 1382 0 is_stmt 1
 1502 0034 AB78     		ldrb	r3, [r5, #2]
 1503 0036 9B06     		lsls	r3, r3, #26
 1504 0038 0FD4     		bmi	.L130
 1505              	.LVL155:
 1506              	.L128:
1383:../drivers/fsl_i2c.c ****             {
1384:../drivers/fsl_i2c.c ****                 if (I2C_MasterStop(base) != kStatus_Success)
1385:../drivers/fsl_i2c.c ****                 {
1386:../drivers/fsl_i2c.c ****                     result = kStatus_I2C_Timeout;
1387:../drivers/fsl_i2c.c ****                 }
1388:../drivers/fsl_i2c.c ****             }
1389:../drivers/fsl_i2c.c ****         }
1390:../drivers/fsl_i2c.c **** 
1391:../drivers/fsl_i2c.c ****         /* Restore handle to idle state. */
1392:../drivers/fsl_i2c.c ****         handle->state = kIdleState;
 1507              		.loc 1 1392 0
 1508 003a 0023     		movs	r3, #0
 1509 003c 2377     		strb	r3, [r4, #28]
1393:../drivers/fsl_i2c.c **** 
1394:../drivers/fsl_i2c.c ****         /* Disable interrupt. */
1395:../drivers/fsl_i2c.c ****         I2C_DisableInterrupts(base, kI2C_GlobalInterruptEnable);
 1510              		.loc 1 1395 0
 1511 003e 4021     		movs	r1, #64
 1512 0040 2800     		movs	r0, r5
 1513 0042 FFF7FEFF 		bl	I2C_DisableInterrupts
 1514              	.LVL156:
1396:../drivers/fsl_i2c.c **** 
1397:../drivers/fsl_i2c.c ****         /* Call the callback function after the function has completed. */
1398:../drivers/fsl_i2c.c ****         if (handle->completionCallback)
 1515              		.loc 1 1398 0
 1516 0046 266A     		ldr	r6, [r4, #32]
 1517 0048 002E     		cmp	r6, #0
 1518 004a 04D0     		beq	.L124
1399:../drivers/fsl_i2c.c ****         {
1400:../drivers/fsl_i2c.c ****             handle->completionCallback(base, handle, result, handle->userData);
 1519              		.loc 1 1400 0
 1520 004c 636A     		ldr	r3, [r4, #36]
 1521 004e 3A00     		movs	r2, r7
 1522 0050 2100     		movs	r1, r4
 1523 0052 2800     		movs	r0, r5
 1524 0054 B047     		blx	r6
 1525              	.LVL157:
 1526              	.L124:
1401:../drivers/fsl_i2c.c ****         }
1402:../drivers/fsl_i2c.c ****     }
1403:../drivers/fsl_i2c.c **** }
 1527              		.loc 1 1403 0
 1528 0056 03B0     		add	sp, sp, #12
 1529              		@ sp needed
 1530              	.LVL158:
 1531              	.LVL159:
 1532              	.LVL160:
 1533 0058 F0BD     		pop	{r4, r5, r6, r7, pc}
 1534              	.LVL161:
 1535              	.L130:
1384:../drivers/fsl_i2c.c ****                 {
 1536              		.loc 1 1384 0
 1537 005a 2800     		movs	r0, r5
 1538              	.LVL162:
 1539 005c FFF7FEFF 		bl	I2C_MasterStop
 1540              	.LVL163:
 1541 0060 0028     		cmp	r0, #0
 1542 0062 EAD0     		beq	.L128
1386:../drivers/fsl_i2c.c ****                 }
 1543              		.loc 1 1386 0
 1544 0064 8A27     		movs	r7, #138
 1545              	.LVL164:
 1546 0066 FF00     		lsls	r7, r7, #3
 1547 0068 E7E7     		b	.L128
 1548              	.L132:
 1549 006a C046     		.align	2
 1550              	.L131:
 1551 006c 4E040000 		.word	1102
 1552 0070 51040000 		.word	1105
 1553              		.cfi_endproc
 1554              	.LFE82:
 1556              		.section	.text.I2C_InitTransferStateMachine,"ax",%progbits
 1557              		.align	1
 1558              		.syntax unified
 1559              		.code	16
 1560              		.thumb_func
 1561              		.fpu softvfp
 1563              	I2C_InitTransferStateMachine:
 1564              	.LFB61:
 239:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 1565              		.loc 1 239 0
 1566              		.cfi_startproc
 1567              		@ args = 0, pretend = 0, frame = 0
 1568              		@ frame_needed = 0, uses_anonymous_args = 0
 1569              	.LVL165:
 1570 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1571              		.cfi_def_cfa_offset 24
 1572              		.cfi_offset 3, -24
 1573              		.cfi_offset 4, -20
 1574              		.cfi_offset 5, -16
 1575              		.cfi_offset 6, -12
 1576              		.cfi_offset 7, -8
 1577              		.cfi_offset 14, -4
 1578              	.LVL166:
 241:../drivers/fsl_i2c.c **** 
 1579              		.loc 1 241 0
 1580 0002 5379     		ldrb	r3, [r2, #5]
 1581 0004 9C46     		mov	ip, r3
 1582              	.LVL167:
 244:../drivers/fsl_i2c.c **** 
 1583              		.loc 1 244 0
 1584 0006 0B00     		movs	r3, r1
 1585 0008 1400     		movs	r4, r2
 1586 000a E0CC     		ldmia	r4!, {r5, r6, r7}
 1587 000c E0C3     		stmia	r3!, {r5, r6, r7}
 1588 000e E0CC     		ldmia	r4!, {r5, r6, r7}
 1589 0010 E0C3     		stmia	r3!, {r5, r6, r7}
 247:../drivers/fsl_i2c.c **** 
 1590              		.loc 1 247 0
 1591 0012 5369     		ldr	r3, [r2, #20]
 1592 0014 8B61     		str	r3, [r1, #24]
 250:../drivers/fsl_i2c.c ****     {
 1593              		.loc 1 250 0
 1594 0016 0B7B     		ldrb	r3, [r1, #12]
 1595 0018 002B     		cmp	r3, #0
 1596 001a 02D0     		beq	.L134
 252:../drivers/fsl_i2c.c ****         {
 1597              		.loc 1 252 0
 1598 001c 5379     		ldrb	r3, [r2, #5]
 1599 001e 012B     		cmp	r3, #1
 1600 0020 1AD0     		beq	.L143
 1601              	.LVL168:
 1602              	.L134:
 258:../drivers/fsl_i2c.c **** 
 1603              		.loc 1 258 0
 1604 0022 0125     		movs	r5, #1
 1605 0024 0D77     		strb	r5, [r1, #28]
 1606              	.LVL169:
 1607              	.LBB55:
 1608              	.LBB56:
 446:../drivers/fsl_i2c.h ****     }
 1609              		.loc 3 446 0
 1610 0026 8479     		ldrb	r4, [r0, #6]
 1611 0028 5026     		movs	r6, #80
 1612 002a 3443     		orrs	r4, r6
 1613 002c 8471     		strb	r4, [r0, #6]
 454:../drivers/fsl_i2c.h ****     }
 1614              		.loc 3 454 0
 1615 002e 8379     		ldrb	r3, [r0, #6]
 1616 0030 3343     		orrs	r3, r6
 1617 0032 8371     		strb	r3, [r0, #6]
 1618              		.loc 3 458 0
 1619 0034 1223     		movs	r3, #18
 1620 0036 C370     		strb	r3, [r0, #3]
 1621              	.LVL170:
 1622              	.LBE56:
 1623              	.LBE55:
 264:../drivers/fsl_i2c.c ****     {
 1624              		.loc 1 264 0
 1625 0038 0B68     		ldr	r3, [r1]
 1626 003a 1D42     		tst	r5, r3
 1627 003c 15D0     		beq	.L135
 267:../drivers/fsl_i2c.c ****         {
 1628              		.loc 1 267 0
 1629 003e 0B7B     		ldrb	r3, [r1, #12]
 1630 0040 002B     		cmp	r3, #0
 1631 0042 0CD0     		beq	.L136
 269:../drivers/fsl_i2c.c ****         }
 1632              		.loc 1 269 0
 1633 0044 0223     		movs	r3, #2
 1634 0046 0B77     		strb	r3, [r1, #28]
 1635              	.L139:
 286:../drivers/fsl_i2c.c ****         {
 1636              		.loc 1 286 0 discriminator 1
 1637 0048 C378     		ldrb	r3, [r0, #3]
 1638 004a 5BB2     		sxtb	r3, r3
 1639 004c 002B     		cmp	r3, #0
 1640 004e FBDA     		bge	.L139
 289:../drivers/fsl_i2c.c ****     }
 1641              		.loc 1 289 0
 1642 0050 FFF7FEFF 		bl	I2C_MasterTransferHandleIRQ
 1643              	.LVL171:
 240:../drivers/fsl_i2c.c ****     i2c_direction_t direction = xfer->direction;
 1644              		.loc 1 240 0
 1645 0054 0020     		movs	r0, #0
 1646              	.LVL172:
 1647              	.L133:
 302:../drivers/fsl_i2c.c **** 
 1648              		.loc 1 302 0
 1649              		@ sp needed
 1650 0056 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1651              	.LVL173:
 1652              	.L143:
 254:../drivers/fsl_i2c.c ****         }
 1653              		.loc 1 254 0
 1654 0058 0023     		movs	r3, #0
 1655 005a 9C46     		mov	ip, r3
 1656              	.LVL174:
 1657 005c E1E7     		b	.L134
 1658              	.LVL175:
 1659              	.L136:
 273:../drivers/fsl_i2c.c ****             {
 1660              		.loc 1 273 0
 1661 005e 6346     		mov	r3, ip
 1662 0060 002B     		cmp	r3, #0
 1663 0062 0ED1     		bne	.L142
 276:../drivers/fsl_i2c.c ****             }
 1664              		.loc 1 276 0
 1665 0064 0333     		adds	r3, r3, #3
 1666 0066 0B77     		strb	r3, [r1, #28]
 1667 0068 EEE7     		b	.L139
 1668              	.L135:
 292:../drivers/fsl_i2c.c ****     {
 1669              		.loc 1 292 0
 1670 006a 9B07     		lsls	r3, r3, #30
 1671 006c 04D4     		bmi	.L144
 298:../drivers/fsl_i2c.c ****     }
 1672              		.loc 1 298 0
 1673 006e 0979     		ldrb	r1, [r1, #4]
 1674              	.LVL176:
 1675 0070 6246     		mov	r2, ip
 1676              	.LVL177:
 1677 0072 FFF7FEFF 		bl	I2C_MasterStart
 1678              	.LVL178:
 1679 0076 EEE7     		b	.L133
 1680              	.LVL179:
 1681              	.L144:
 294:../drivers/fsl_i2c.c ****     }
 1682              		.loc 1 294 0
 1683 0078 0979     		ldrb	r1, [r1, #4]
 1684              	.LVL180:
 1685 007a 6246     		mov	r2, ip
 1686              	.LVL181:
 1687 007c FFF7FEFF 		bl	I2C_MasterRepeatedStart
 1688              	.LVL182:
 1689 0080 E9E7     		b	.L133
 1690              	.LVL183:
 1691              	.L142:
 281:../drivers/fsl_i2c.c ****             }
 1692              		.loc 1 281 0
 1693 0082 0420     		movs	r0, #4
 1694              	.LVL184:
 1695 0084 E7E7     		b	.L133
 1696              		.cfi_endproc
 1697              	.LFE61:
 1699              		.section	.text.I2C_SlaveTransferHandleIRQ,"ax",%progbits
 1700              		.align	1
 1701              		.global	I2C_SlaveTransferHandleIRQ
 1702              		.syntax unified
 1703              		.code	16
 1704              		.thumb_func
 1705              		.fpu softvfp
 1707              	I2C_SlaveTransferHandleIRQ:
 1708              	.LFB92:
1404:../drivers/fsl_i2c.c **** 
1405:../drivers/fsl_i2c.c **** void I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig, uint32_t srcClock_Hz)
1406:../drivers/fsl_i2c.c **** {
1407:../drivers/fsl_i2c.c ****     assert(slaveConfig);
1408:../drivers/fsl_i2c.c **** 
1409:../drivers/fsl_i2c.c ****     uint8_t tmpReg;
1410:../drivers/fsl_i2c.c **** 
1411:../drivers/fsl_i2c.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
1412:../drivers/fsl_i2c.c ****     CLOCK_EnableClock(s_i2cClocks[I2C_GetInstance(base)]);
1413:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
1414:../drivers/fsl_i2c.c **** 
1415:../drivers/fsl_i2c.c ****     /* Reset the module. */
1416:../drivers/fsl_i2c.c ****     base->A1 = 0;
1417:../drivers/fsl_i2c.c ****     base->F = 0;
1418:../drivers/fsl_i2c.c ****     base->C1 = 0;
1419:../drivers/fsl_i2c.c ****     base->S = 0xFFU;
1420:../drivers/fsl_i2c.c ****     base->C2 = 0;
1421:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
1422:../drivers/fsl_i2c.c ****     base->FLT = 0x50U;
1423:../drivers/fsl_i2c.c **** #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
1424:../drivers/fsl_i2c.c ****     base->FLT = 0x40U;
1425:../drivers/fsl_i2c.c **** #endif
1426:../drivers/fsl_i2c.c ****     base->RA = 0;
1427:../drivers/fsl_i2c.c **** 
1428:../drivers/fsl_i2c.c ****     /* Configure addressing mode. */
1429:../drivers/fsl_i2c.c ****     switch (slaveConfig->addressingMode)
1430:../drivers/fsl_i2c.c ****     {
1431:../drivers/fsl_i2c.c ****         case kI2C_Address7bit:
1432:../drivers/fsl_i2c.c ****             base->A1 = ((uint32_t)(slaveConfig->slaveAddress)) << 1U;
1433:../drivers/fsl_i2c.c ****             break;
1434:../drivers/fsl_i2c.c **** 
1435:../drivers/fsl_i2c.c ****         case kI2C_RangeMatch:
1436:../drivers/fsl_i2c.c ****             assert(slaveConfig->slaveAddress < slaveConfig->upperAddress);
1437:../drivers/fsl_i2c.c ****             base->A1 = ((uint32_t)(slaveConfig->slaveAddress)) << 1U;
1438:../drivers/fsl_i2c.c ****             base->RA = ((uint32_t)(slaveConfig->upperAddress)) << 1U;
1439:../drivers/fsl_i2c.c ****             base->C2 |= I2C_C2_RMEN_MASK;
1440:../drivers/fsl_i2c.c ****             break;
1441:../drivers/fsl_i2c.c **** 
1442:../drivers/fsl_i2c.c ****         default:
1443:../drivers/fsl_i2c.c ****             break;
1444:../drivers/fsl_i2c.c ****     }
1445:../drivers/fsl_i2c.c **** 
1446:../drivers/fsl_i2c.c ****     /* Configure low power wake up feature. */
1447:../drivers/fsl_i2c.c ****     tmpReg = base->C1;
1448:../drivers/fsl_i2c.c ****     tmpReg &= ~I2C_C1_WUEN_MASK;
1449:../drivers/fsl_i2c.c ****     base->C1 = tmpReg | I2C_C1_WUEN(slaveConfig->enableWakeUp) | I2C_C1_IICEN(slaveConfig->enableSl
1450:../drivers/fsl_i2c.c **** 
1451:../drivers/fsl_i2c.c ****     /* Configure general call & baud rate control. */
1452:../drivers/fsl_i2c.c ****     tmpReg = base->C2;
1453:../drivers/fsl_i2c.c ****     tmpReg &= ~(I2C_C2_SBRC_MASK | I2C_C2_GCAEN_MASK);
1454:../drivers/fsl_i2c.c ****     tmpReg |= I2C_C2_SBRC(slaveConfig->enableBaudRateCtl) | I2C_C2_GCAEN(slaveConfig->enableGeneral
1455:../drivers/fsl_i2c.c ****     base->C2 = tmpReg;
1456:../drivers/fsl_i2c.c **** 
1457:../drivers/fsl_i2c.c **** /* Enable/Disable double buffering. */
1458:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
1459:../drivers/fsl_i2c.c ****     tmpReg = base->S2 & (~I2C_S2_DFEN_MASK);
1460:../drivers/fsl_i2c.c ****     base->S2 = tmpReg | I2C_S2_DFEN(slaveConfig->enableDoubleBuffering);
1461:../drivers/fsl_i2c.c **** #endif
1462:../drivers/fsl_i2c.c **** 
1463:../drivers/fsl_i2c.c ****     /* Set hold time. */
1464:../drivers/fsl_i2c.c ****     I2C_SetHoldTime(base, slaveConfig->sclStopHoldTime_ns, srcClock_Hz);
1465:../drivers/fsl_i2c.c **** }
1466:../drivers/fsl_i2c.c **** 
1467:../drivers/fsl_i2c.c **** void I2C_SlaveDeinit(I2C_Type *base)
1468:../drivers/fsl_i2c.c **** {
1469:../drivers/fsl_i2c.c ****     /* Disable I2C module. */
1470:../drivers/fsl_i2c.c ****     I2C_Enable(base, false);
1471:../drivers/fsl_i2c.c **** 
1472:../drivers/fsl_i2c.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
1473:../drivers/fsl_i2c.c ****     /* Disable I2C clock. */
1474:../drivers/fsl_i2c.c ****     CLOCK_DisableClock(s_i2cClocks[I2C_GetInstance(base)]);
1475:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
1476:../drivers/fsl_i2c.c **** }
1477:../drivers/fsl_i2c.c **** 
1478:../drivers/fsl_i2c.c **** void I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig)
1479:../drivers/fsl_i2c.c **** {
1480:../drivers/fsl_i2c.c ****     assert(slaveConfig);
1481:../drivers/fsl_i2c.c **** 
1482:../drivers/fsl_i2c.c ****     /* By default slave is addressed with 7-bit address. */
1483:../drivers/fsl_i2c.c ****     slaveConfig->addressingMode = kI2C_Address7bit;
1484:../drivers/fsl_i2c.c **** 
1485:../drivers/fsl_i2c.c ****     /* General call mode is disabled by default. */
1486:../drivers/fsl_i2c.c ****     slaveConfig->enableGeneralCall = false;
1487:../drivers/fsl_i2c.c **** 
1488:../drivers/fsl_i2c.c ****     /* Slave address match waking up MCU from low power mode is disabled. */
1489:../drivers/fsl_i2c.c ****     slaveConfig->enableWakeUp = false;
1490:../drivers/fsl_i2c.c **** 
1491:../drivers/fsl_i2c.c ****     /* Independent slave mode baud rate at maximum frequency is disabled. */
1492:../drivers/fsl_i2c.c ****     slaveConfig->enableBaudRateCtl = false;
1493:../drivers/fsl_i2c.c **** 
1494:../drivers/fsl_i2c.c **** /* Default enable double buffering. */
1495:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE
1496:../drivers/fsl_i2c.c ****     slaveConfig->enableDoubleBuffering = true;
1497:../drivers/fsl_i2c.c **** #endif
1498:../drivers/fsl_i2c.c **** 
1499:../drivers/fsl_i2c.c ****     /* Set default SCL stop hold time to 4us which is minimum requirement in I2C spec. */
1500:../drivers/fsl_i2c.c ****     slaveConfig->sclStopHoldTime_ns = 4000;
1501:../drivers/fsl_i2c.c **** 
1502:../drivers/fsl_i2c.c ****     /* Enable the I2C peripheral. */
1503:../drivers/fsl_i2c.c ****     slaveConfig->enableSlave = true;
1504:../drivers/fsl_i2c.c **** }
1505:../drivers/fsl_i2c.c **** 
1506:../drivers/fsl_i2c.c **** status_t I2C_SlaveWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize)
1507:../drivers/fsl_i2c.c **** {
1508:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
1509:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
1510:../drivers/fsl_i2c.c **** 
1511:../drivers/fsl_i2c.c ****     /* Add this to avoid build warning. */
1512:../drivers/fsl_i2c.c ****     dummy++;
1513:../drivers/fsl_i2c.c **** 
1514:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
1515:../drivers/fsl_i2c.c ****     /* Check start flag. */
1516:../drivers/fsl_i2c.c ****     while (!(base->FLT & I2C_FLT_STARTF_MASK))
1517:../drivers/fsl_i2c.c ****     {
1518:../drivers/fsl_i2c.c ****     }
1519:../drivers/fsl_i2c.c ****     /* Clear STARTF flag. */
1520:../drivers/fsl_i2c.c ****     base->FLT |= I2C_FLT_STARTF_MASK;
1521:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
1522:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
1523:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
1524:../drivers/fsl_i2c.c **** 
1525:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1526:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
1527:../drivers/fsl_i2c.c ****     /* Wait until data transfer complete. */
1528:../drivers/fsl_i2c.c ****     while ((!(base->S & kI2C_AddressMatchFlag)) && (--waitTimes))
1529:../drivers/fsl_i2c.c ****     {
1530:../drivers/fsl_i2c.c ****     }
1531:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
1532:../drivers/fsl_i2c.c ****     {
1533:../drivers/fsl_i2c.c ****         return kStatus_I2C_Timeout;
1534:../drivers/fsl_i2c.c ****     }
1535:../drivers/fsl_i2c.c **** #else
1536:../drivers/fsl_i2c.c ****     /* Wait for address match flag. */
1537:../drivers/fsl_i2c.c ****     while (!(base->S & kI2C_AddressMatchFlag))
1538:../drivers/fsl_i2c.c ****     {
1539:../drivers/fsl_i2c.c ****     }
1540:../drivers/fsl_i2c.c **** #endif
1541:../drivers/fsl_i2c.c ****     /* Read dummy to release bus. */
1542:../drivers/fsl_i2c.c ****     dummy = base->D;
1543:../drivers/fsl_i2c.c **** 
1544:../drivers/fsl_i2c.c ****     result = I2C_MasterWriteBlocking(base, txBuff, txSize, kI2C_TransferDefaultFlag);
1545:../drivers/fsl_i2c.c **** 
1546:../drivers/fsl_i2c.c ****     /* Switch to receive mode. */
1547:../drivers/fsl_i2c.c ****     base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
1548:../drivers/fsl_i2c.c **** 
1549:../drivers/fsl_i2c.c ****     /* Read dummy to release bus. */
1550:../drivers/fsl_i2c.c ****     dummy = base->D;
1551:../drivers/fsl_i2c.c **** 
1552:../drivers/fsl_i2c.c ****     return result;
1553:../drivers/fsl_i2c.c **** }
1554:../drivers/fsl_i2c.c **** 
1555:../drivers/fsl_i2c.c **** status_t I2C_SlaveReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize)
1556:../drivers/fsl_i2c.c **** {
1557:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
1558:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
1559:../drivers/fsl_i2c.c **** 
1560:../drivers/fsl_i2c.c ****     /* Add this to avoid build warning. */
1561:../drivers/fsl_i2c.c ****     dummy++;
1562:../drivers/fsl_i2c.c **** 
1563:../drivers/fsl_i2c.c **** /* Wait until address match. */
1564:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
1565:../drivers/fsl_i2c.c ****     /* Check start flag. */
1566:../drivers/fsl_i2c.c ****     while (!(base->FLT & I2C_FLT_STARTF_MASK))
1567:../drivers/fsl_i2c.c ****     {
1568:../drivers/fsl_i2c.c ****     }
1569:../drivers/fsl_i2c.c ****     /* Clear STARTF flag. */
1570:../drivers/fsl_i2c.c ****     base->FLT |= I2C_FLT_STARTF_MASK;
1571:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
1572:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
1573:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
1574:../drivers/fsl_i2c.c **** 
1575:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1576:../drivers/fsl_i2c.c ****     uint32_t waitTimes = I2C_WAIT_TIMEOUT;
1577:../drivers/fsl_i2c.c ****     /* Wait for address match and int pending flag. */
1578:../drivers/fsl_i2c.c ****     while ((!(base->S & kI2C_AddressMatchFlag)) && (--waitTimes))
1579:../drivers/fsl_i2c.c ****     {
1580:../drivers/fsl_i2c.c ****     }
1581:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
1582:../drivers/fsl_i2c.c ****     {
1583:../drivers/fsl_i2c.c ****         return kStatus_I2C_Timeout;
1584:../drivers/fsl_i2c.c ****     }
1585:../drivers/fsl_i2c.c **** 
1586:../drivers/fsl_i2c.c ****     waitTimes = I2C_WAIT_TIMEOUT;
1587:../drivers/fsl_i2c.c ****     while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1588:../drivers/fsl_i2c.c ****     {
1589:../drivers/fsl_i2c.c ****     }
1590:../drivers/fsl_i2c.c ****     if (waitTimes == 0)
1591:../drivers/fsl_i2c.c ****     {
1592:../drivers/fsl_i2c.c ****         return kStatus_I2C_Timeout;
1593:../drivers/fsl_i2c.c ****     }
1594:../drivers/fsl_i2c.c **** #else
1595:../drivers/fsl_i2c.c ****     /* Wait for address match and int pending flag. */
1596:../drivers/fsl_i2c.c ****     while (!(base->S & kI2C_AddressMatchFlag))
1597:../drivers/fsl_i2c.c ****     {
1598:../drivers/fsl_i2c.c ****     }
1599:../drivers/fsl_i2c.c ****     while (!(base->S & kI2C_IntPendingFlag))
1600:../drivers/fsl_i2c.c ****     {
1601:../drivers/fsl_i2c.c ****     }
1602:../drivers/fsl_i2c.c **** #endif
1603:../drivers/fsl_i2c.c **** 
1604:../drivers/fsl_i2c.c ****     /* Read dummy to release bus. */
1605:../drivers/fsl_i2c.c ****     dummy = base->D;
1606:../drivers/fsl_i2c.c **** 
1607:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
1608:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
1609:../drivers/fsl_i2c.c **** 
1610:../drivers/fsl_i2c.c ****     /* Setup the I2C peripheral to receive data. */
1611:../drivers/fsl_i2c.c ****     base->C1 &= ~(I2C_C1_TX_MASK);
1612:../drivers/fsl_i2c.c **** 
1613:../drivers/fsl_i2c.c ****     while (rxSize--)
1614:../drivers/fsl_i2c.c ****     {
1615:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
1616:../drivers/fsl_i2c.c ****         waitTimes = I2C_WAIT_TIMEOUT;
1617:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1618:../drivers/fsl_i2c.c ****         while ((!(base->S & kI2C_IntPendingFlag)) && (--waitTimes))
1619:../drivers/fsl_i2c.c ****         {
1620:../drivers/fsl_i2c.c ****         }
1621:../drivers/fsl_i2c.c ****         if (waitTimes == 0)
1622:../drivers/fsl_i2c.c ****         {
1623:../drivers/fsl_i2c.c ****             return kStatus_I2C_Timeout;
1624:../drivers/fsl_i2c.c ****         }
1625:../drivers/fsl_i2c.c **** #else
1626:../drivers/fsl_i2c.c ****         /* Wait until data transfer complete. */
1627:../drivers/fsl_i2c.c ****         while (!(base->S & kI2C_IntPendingFlag))
1628:../drivers/fsl_i2c.c ****         {
1629:../drivers/fsl_i2c.c ****         }
1630:../drivers/fsl_i2c.c **** #endif
1631:../drivers/fsl_i2c.c ****         /* Clear the IICIF flag. */
1632:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
1633:../drivers/fsl_i2c.c **** 
1634:../drivers/fsl_i2c.c ****         /* Read from the data register. */
1635:../drivers/fsl_i2c.c ****         *rxBuff++ = base->D;
1636:../drivers/fsl_i2c.c ****     }
1637:../drivers/fsl_i2c.c **** 
1638:../drivers/fsl_i2c.c ****     return result;
1639:../drivers/fsl_i2c.c **** }
1640:../drivers/fsl_i2c.c **** 
1641:../drivers/fsl_i2c.c **** void I2C_SlaveTransferCreateHandle(I2C_Type *base,
1642:../drivers/fsl_i2c.c ****                                    i2c_slave_handle_t *handle,
1643:../drivers/fsl_i2c.c ****                                    i2c_slave_transfer_callback_t callback,
1644:../drivers/fsl_i2c.c ****                                    void *userData)
1645:../drivers/fsl_i2c.c **** {
1646:../drivers/fsl_i2c.c ****     assert(handle);
1647:../drivers/fsl_i2c.c **** 
1648:../drivers/fsl_i2c.c ****     uint32_t instance = I2C_GetInstance(base);
1649:../drivers/fsl_i2c.c **** 
1650:../drivers/fsl_i2c.c ****     /* Zero handle. */
1651:../drivers/fsl_i2c.c ****     memset(handle, 0, sizeof(*handle));
1652:../drivers/fsl_i2c.c **** 
1653:../drivers/fsl_i2c.c ****     /* Set callback and userData. */
1654:../drivers/fsl_i2c.c ****     handle->callback = callback;
1655:../drivers/fsl_i2c.c ****     handle->userData = userData;
1656:../drivers/fsl_i2c.c **** 
1657:../drivers/fsl_i2c.c ****     /* Save the context in global variables to support the double weak mechanism. */
1658:../drivers/fsl_i2c.c ****     s_i2cHandle[instance] = handle;
1659:../drivers/fsl_i2c.c **** 
1660:../drivers/fsl_i2c.c ****     /* Save slave interrupt handler. */
1661:../drivers/fsl_i2c.c ****     s_i2cSlaveIsr = I2C_SlaveTransferHandleIRQ;
1662:../drivers/fsl_i2c.c **** 
1663:../drivers/fsl_i2c.c ****     /* Enable NVIC interrupt. */
1664:../drivers/fsl_i2c.c ****     EnableIRQ(s_i2cIrqs[instance]);
1665:../drivers/fsl_i2c.c **** }
1666:../drivers/fsl_i2c.c **** 
1667:../drivers/fsl_i2c.c **** status_t I2C_SlaveTransferNonBlocking(I2C_Type *base, i2c_slave_handle_t *handle, uint32_t eventMas
1668:../drivers/fsl_i2c.c **** {
1669:../drivers/fsl_i2c.c ****     assert(handle);
1670:../drivers/fsl_i2c.c **** 
1671:../drivers/fsl_i2c.c ****     /* Check if the I2C bus is idle - if not return busy status. */
1672:../drivers/fsl_i2c.c ****     if (handle->isBusy)
1673:../drivers/fsl_i2c.c ****     {
1674:../drivers/fsl_i2c.c ****         return kStatus_I2C_Busy;
1675:../drivers/fsl_i2c.c ****     }
1676:../drivers/fsl_i2c.c ****     else
1677:../drivers/fsl_i2c.c ****     {
1678:../drivers/fsl_i2c.c ****         /* Disable LPI2C IRQ sources while we configure stuff. */
1679:../drivers/fsl_i2c.c ****         I2C_DisableInterrupts(base, kIrqFlags);
1680:../drivers/fsl_i2c.c **** 
1681:../drivers/fsl_i2c.c ****         /* Clear transfer in handle. */
1682:../drivers/fsl_i2c.c ****         memset(&handle->transfer, 0, sizeof(handle->transfer));
1683:../drivers/fsl_i2c.c **** 
1684:../drivers/fsl_i2c.c ****         /* Record that we're busy. */
1685:../drivers/fsl_i2c.c ****         handle->isBusy = true;
1686:../drivers/fsl_i2c.c **** 
1687:../drivers/fsl_i2c.c ****         /* Set up event mask. tx and rx are always enabled. */
1688:../drivers/fsl_i2c.c ****         handle->eventMask = eventMask | kI2C_SlaveTransmitEvent | kI2C_SlaveReceiveEvent | kI2C_Sla
1689:../drivers/fsl_i2c.c **** 
1690:../drivers/fsl_i2c.c ****         /* Clear all flags. */
1691:../drivers/fsl_i2c.c ****         I2C_SlaveClearStatusFlags(base, kClearFlags);
1692:../drivers/fsl_i2c.c **** 
1693:../drivers/fsl_i2c.c ****         /* Enable I2C internal IRQ sources. NVIC IRQ was enabled in CreateHandle() */
1694:../drivers/fsl_i2c.c ****         I2C_EnableInterrupts(base, kIrqFlags);
1695:../drivers/fsl_i2c.c ****     }
1696:../drivers/fsl_i2c.c **** 
1697:../drivers/fsl_i2c.c ****     return kStatus_Success;
1698:../drivers/fsl_i2c.c **** }
1699:../drivers/fsl_i2c.c **** 
1700:../drivers/fsl_i2c.c **** void I2C_SlaveTransferAbort(I2C_Type *base, i2c_slave_handle_t *handle)
1701:../drivers/fsl_i2c.c **** {
1702:../drivers/fsl_i2c.c ****     assert(handle);
1703:../drivers/fsl_i2c.c **** 
1704:../drivers/fsl_i2c.c ****     if (handle->isBusy)
1705:../drivers/fsl_i2c.c ****     {
1706:../drivers/fsl_i2c.c ****         /* Disable interrupts. */
1707:../drivers/fsl_i2c.c ****         I2C_DisableInterrupts(base, kIrqFlags);
1708:../drivers/fsl_i2c.c **** 
1709:../drivers/fsl_i2c.c ****         /* Reset transfer info. */
1710:../drivers/fsl_i2c.c ****         memset(&handle->transfer, 0, sizeof(handle->transfer));
1711:../drivers/fsl_i2c.c **** 
1712:../drivers/fsl_i2c.c ****         /* Reset the state to idle. */
1713:../drivers/fsl_i2c.c ****         handle->isBusy = false;
1714:../drivers/fsl_i2c.c ****     }
1715:../drivers/fsl_i2c.c **** }
1716:../drivers/fsl_i2c.c **** 
1717:../drivers/fsl_i2c.c **** status_t I2C_SlaveTransferGetCount(I2C_Type *base, i2c_slave_handle_t *handle, size_t *count)
1718:../drivers/fsl_i2c.c **** {
1719:../drivers/fsl_i2c.c ****     assert(handle);
1720:../drivers/fsl_i2c.c **** 
1721:../drivers/fsl_i2c.c ****     if (!count)
1722:../drivers/fsl_i2c.c ****     {
1723:../drivers/fsl_i2c.c ****         return kStatus_InvalidArgument;
1724:../drivers/fsl_i2c.c ****     }
1725:../drivers/fsl_i2c.c **** 
1726:../drivers/fsl_i2c.c ****     /* Catch when there is not an active transfer. */
1727:../drivers/fsl_i2c.c ****     if (!handle->isBusy)
1728:../drivers/fsl_i2c.c ****     {
1729:../drivers/fsl_i2c.c ****         *count = 0;
1730:../drivers/fsl_i2c.c ****         return kStatus_NoTransferInProgress;
1731:../drivers/fsl_i2c.c ****     }
1732:../drivers/fsl_i2c.c **** 
1733:../drivers/fsl_i2c.c ****     /* For an active transfer, just return the count from the handle. */
1734:../drivers/fsl_i2c.c ****     *count = handle->transfer.transferredCount;
1735:../drivers/fsl_i2c.c **** 
1736:../drivers/fsl_i2c.c ****     return kStatus_Success;
1737:../drivers/fsl_i2c.c **** }
1738:../drivers/fsl_i2c.c **** 
1739:../drivers/fsl_i2c.c **** void I2C_SlaveTransferHandleIRQ(I2C_Type *base, void *i2cHandle)
1740:../drivers/fsl_i2c.c **** {
 1709              		.loc 1 1740 0
 1710              		.cfi_startproc
 1711              		@ args = 0, pretend = 0, frame = 8
 1712              		@ frame_needed = 0, uses_anonymous_args = 0
 1713              	.LVL185:
 1714 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1715              		.cfi_def_cfa_offset 20
 1716              		.cfi_offset 4, -20
 1717              		.cfi_offset 5, -16
 1718              		.cfi_offset 6, -12
 1719              		.cfi_offset 7, -8
 1720              		.cfi_offset 14, -4
 1721 0002 83B0     		sub	sp, sp, #12
 1722              		.cfi_def_cfa_offset 32
 1723 0004 0500     		movs	r5, r0
 1724 0006 0E00     		movs	r6, r1
 1725              	.LVL186:
1741:../drivers/fsl_i2c.c ****     assert(i2cHandle);
1742:../drivers/fsl_i2c.c **** 
1743:../drivers/fsl_i2c.c ****     uint16_t status;
1744:../drivers/fsl_i2c.c ****     bool doTransmit = false;
1745:../drivers/fsl_i2c.c ****     i2c_slave_handle_t *handle = (i2c_slave_handle_t *)i2cHandle;
1746:../drivers/fsl_i2c.c ****     i2c_slave_transfer_t *xfer;
1747:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
 1726              		.loc 1 1747 0
 1727 0008 6B46     		mov	r3, sp
 1728 000a DA1D     		adds	r2, r3, #7
 1729 000c 0023     		movs	r3, #0
 1730 000e 1370     		strb	r3, [r2]
1748:../drivers/fsl_i2c.c **** 
1749:../drivers/fsl_i2c.c ****     /* Add this to avoid build warning. */
1750:../drivers/fsl_i2c.c ****     dummy++;
 1731              		.loc 1 1750 0
 1732 0010 1378     		ldrb	r3, [r2]
 1733 0012 0133     		adds	r3, r3, #1
 1734 0014 DBB2     		uxtb	r3, r3
 1735 0016 1370     		strb	r3, [r2]
 1736              	.LVL187:
 1737              	.LBB57:
 1738              	.LBB58:
 423:../drivers/fsl_i2c.h **** }
 1739              		.loc 3 423 0
 1740 0018 FFF7FEFF 		bl	I2C_MasterGetStatusFlags
 1741              	.LVL188:
 1742              	.LBE58:
 1743              	.LBE57:
1751:../drivers/fsl_i2c.c **** 
1752:../drivers/fsl_i2c.c ****     status = I2C_SlaveGetStatusFlags(base);
1753:../drivers/fsl_i2c.c ****     xfer = &(handle->transfer);
 1744              		.loc 1 1753 0
 1745 001c 371D     		adds	r7, r6, #4
 1746              	.LVL189:
1754:../drivers/fsl_i2c.c **** 
1755:../drivers/fsl_i2c.c **** #ifdef I2C_HAS_STOP_DETECT
1756:../drivers/fsl_i2c.c ****     /* Check stop flag. */
1757:../drivers/fsl_i2c.c ****     if (status & kI2C_StopDetectFlag)
 1747              		.loc 1 1757 0
 1748 001e 0404     		lsls	r4, r0, #16
 1749 0020 240C     		lsrs	r4, r4, #16
 1750 0022 6304     		lsls	r3, r4, #17
 1751 0024 1BD5     		bpl	.L146
 1752              	.LVL190:
 1753              	.LBB59:
 1754              	.LBB60:
 454:../drivers/fsl_i2c.h ****     }
 1755              		.loc 3 454 0
 1756 0026 AB79     		ldrb	r3, [r5, #6]
 1757 0028 4022     		movs	r2, #64
 1758 002a 1343     		orrs	r3, r2
 1759 002c AB71     		strb	r3, [r5, #6]
 1760              		.loc 3 458 0
 1761 002e 0023     		movs	r3, #0
 1762 0030 EB70     		strb	r3, [r5, #3]
 1763              	.LVL191:
 1764              	.LBE60:
 1765              	.LBE59:
1758:../drivers/fsl_i2c.c ****     {
1759:../drivers/fsl_i2c.c ****         I2C_MasterClearStatusFlags(base, kI2C_StopDetectFlag);
1760:../drivers/fsl_i2c.c **** 
1761:../drivers/fsl_i2c.c ****         /* Clear the interrupt flag. */
1762:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
 1766              		.loc 1 1762 0
 1767 0032 0233     		adds	r3, r3, #2
 1768 0034 EB70     		strb	r3, [r5, #3]
1763:../drivers/fsl_i2c.c **** 
1764:../drivers/fsl_i2c.c ****         /* Call slave callback if this is the STOP of the transfer. */
1765:../drivers/fsl_i2c.c ****         if (handle->isBusy)
 1769              		.loc 1 1765 0
 1770 0036 3378     		ldrb	r3, [r6]
 1771 0038 002B     		cmp	r3, #0
 1772 003a 0ED0     		beq	.L147
1766:../drivers/fsl_i2c.c ****         {
1767:../drivers/fsl_i2c.c ****             xfer->event = kI2C_SlaveCompletionEvent;
 1773              		.loc 1 1767 0
 1774 003c 2023     		movs	r3, #32
 1775 003e 3371     		strb	r3, [r6, #4]
1768:../drivers/fsl_i2c.c ****             xfer->completionStatus = kStatus_Success;
 1776              		.loc 1 1768 0
 1777 0040 0022     		movs	r2, #0
 1778 0042 3261     		str	r2, [r6, #16]
1769:../drivers/fsl_i2c.c ****             handle->isBusy = false;
 1779              		.loc 1 1769 0
 1780 0044 3270     		strb	r2, [r6]
1770:../drivers/fsl_i2c.c **** 
1771:../drivers/fsl_i2c.c ****             if ((handle->eventMask & xfer->event) && (handle->callback))
 1781              		.loc 1 1771 0
 1782 0046 B269     		ldr	r2, [r6, #24]
 1783 0048 1342     		tst	r3, r2
 1784 004a 06D0     		beq	.L147
 1785              		.loc 1 1771 0 is_stmt 0 discriminator 1
 1786 004c F369     		ldr	r3, [r6, #28]
 1787 004e 002B     		cmp	r3, #0
 1788 0050 03D0     		beq	.L147
1772:../drivers/fsl_i2c.c ****             {
1773:../drivers/fsl_i2c.c ****                 handle->callback(base, xfer, handle->userData);
 1789              		.loc 1 1773 0 is_stmt 1
 1790 0052 326A     		ldr	r2, [r6, #32]
 1791 0054 3900     		movs	r1, r7
 1792 0056 2800     		movs	r0, r5
 1793              	.LVL192:
 1794 0058 9847     		blx	r3
 1795              	.LVL193:
 1796              	.L147:
1774:../drivers/fsl_i2c.c ****             }
1775:../drivers/fsl_i2c.c ****         }
1776:../drivers/fsl_i2c.c **** 
1777:../drivers/fsl_i2c.c ****         if (!(status & kI2C_AddressMatchFlag))
 1797              		.loc 1 1777 0
 1798 005a 6306     		lsls	r3, r4, #25
 1799 005c 36D5     		bpl	.L145
 1800              	.L146:
1778:../drivers/fsl_i2c.c ****         {
1779:../drivers/fsl_i2c.c ****             return;
1780:../drivers/fsl_i2c.c ****         }
1781:../drivers/fsl_i2c.c ****     }
1782:../drivers/fsl_i2c.c **** #endif /* I2C_HAS_STOP_DETECT */
1783:../drivers/fsl_i2c.c **** 
1784:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
1785:../drivers/fsl_i2c.c ****     /* Check start flag. */
1786:../drivers/fsl_i2c.c ****     if (status & kI2C_StartDetectFlag)
 1801              		.loc 1 1786 0
 1802 005e E304     		lsls	r3, r4, #19
 1803 0060 15D5     		bpl	.L149
 1804              	.LVL194:
 1805              	.LBB61:
 1806              	.LBB62:
 446:../drivers/fsl_i2c.h ****     }
 1807              		.loc 3 446 0
 1808 0062 AB79     		ldrb	r3, [r5, #6]
 1809 0064 1022     		movs	r2, #16
 1810 0066 1021     		movs	r1, #16
 1811 0068 0B43     		orrs	r3, r1
 1812 006a AB71     		strb	r3, [r5, #6]
 1813              		.loc 3 458 0
 1814 006c 0023     		movs	r3, #0
 1815 006e EB70     		strb	r3, [r5, #3]
 1816              	.LVL195:
 1817              	.LBE62:
 1818              	.LBE61:
1787:../drivers/fsl_i2c.c ****     {
1788:../drivers/fsl_i2c.c ****         I2C_MasterClearStatusFlags(base, kI2C_StartDetectFlag);
1789:../drivers/fsl_i2c.c **** 
1790:../drivers/fsl_i2c.c ****         /* Clear the interrupt flag. */
1791:../drivers/fsl_i2c.c ****         base->S = kI2C_IntPendingFlag;
 1819              		.loc 1 1791 0
 1820 0070 0233     		adds	r3, r3, #2
 1821 0072 EB70     		strb	r3, [r5, #3]
1792:../drivers/fsl_i2c.c **** 
1793:../drivers/fsl_i2c.c ****         xfer->event = kI2C_SlaveStartEvent;
 1822              		.loc 1 1793 0
 1823 0074 3271     		strb	r2, [r6, #4]
1794:../drivers/fsl_i2c.c **** 
1795:../drivers/fsl_i2c.c ****         if ((handle->eventMask & xfer->event) && (handle->callback))
 1824              		.loc 1 1795 0
 1825 0076 B369     		ldr	r3, [r6, #24]
 1826 0078 1A42     		tst	r2, r3
 1827 007a 06D0     		beq	.L150
 1828              		.loc 1 1795 0 is_stmt 0 discriminator 1
 1829 007c F369     		ldr	r3, [r6, #28]
 1830 007e 002B     		cmp	r3, #0
 1831 0080 03D0     		beq	.L150
1796:../drivers/fsl_i2c.c ****         {
1797:../drivers/fsl_i2c.c ****             handle->callback(base, xfer, handle->userData);
 1832              		.loc 1 1797 0 is_stmt 1
 1833 0082 326A     		ldr	r2, [r6, #32]
 1834 0084 3900     		movs	r1, r7
 1835 0086 2800     		movs	r0, r5
 1836 0088 9847     		blx	r3
 1837              	.LVL196:
 1838              	.L150:
1798:../drivers/fsl_i2c.c ****         }
1799:../drivers/fsl_i2c.c **** 
1800:../drivers/fsl_i2c.c ****         if (!(status & kI2C_AddressMatchFlag))
 1839              		.loc 1 1800 0
 1840 008a 6306     		lsls	r3, r4, #25
 1841 008c 1ED5     		bpl	.L145
 1842              	.L149:
1801:../drivers/fsl_i2c.c ****         {
1802:../drivers/fsl_i2c.c ****             return;
1803:../drivers/fsl_i2c.c ****         }
1804:../drivers/fsl_i2c.c ****     }
1805:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
1806:../drivers/fsl_i2c.c **** 
1807:../drivers/fsl_i2c.c ****     /* Clear the interrupt flag. */
1808:../drivers/fsl_i2c.c ****     base->S = kI2C_IntPendingFlag;
 1843              		.loc 1 1808 0
 1844 008e 0223     		movs	r3, #2
 1845 0090 EB70     		strb	r3, [r5, #3]
1809:../drivers/fsl_i2c.c **** 
1810:../drivers/fsl_i2c.c ****     /* Check NAK */
1811:../drivers/fsl_i2c.c ****     if (status & kI2C_ReceiveNakFlag)
 1846              		.loc 1 1811 0
 1847 0092 E307     		lsls	r3, r4, #31
 1848 0094 1CD5     		bpl	.L151
1812:../drivers/fsl_i2c.c ****     {
1813:../drivers/fsl_i2c.c ****         /* Set receive mode. */
1814:../drivers/fsl_i2c.c ****         base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
 1849              		.loc 1 1814 0
 1850 0096 AB78     		ldrb	r3, [r5, #2]
 1851 0098 1822     		movs	r2, #24
 1852 009a 9343     		bics	r3, r2
 1853 009c AB70     		strb	r3, [r5, #2]
1815:../drivers/fsl_i2c.c **** 
1816:../drivers/fsl_i2c.c ****         /* Read dummy. */
1817:../drivers/fsl_i2c.c ****         dummy = base->D;
 1854              		.loc 1 1817 0
 1855 009e 2B79     		ldrb	r3, [r5, #4]
 1856 00a0 DBB2     		uxtb	r3, r3
 1857 00a2 6A46     		mov	r2, sp
 1858 00a4 D371     		strb	r3, [r2, #7]
1818:../drivers/fsl_i2c.c **** 
1819:../drivers/fsl_i2c.c ****         if (handle->transfer.dataSize != 0)
 1859              		.loc 1 1819 0
 1860 00a6 F368     		ldr	r3, [r6, #12]
 1861 00a8 002B     		cmp	r3, #0
 1862 00aa 0FD0     		beq	.L145
1820:../drivers/fsl_i2c.c ****         {
1821:../drivers/fsl_i2c.c ****             xfer->event = kI2C_SlaveCompletionEvent;
 1863              		.loc 1 1821 0
 1864 00ac 2023     		movs	r3, #32
 1865 00ae 3371     		strb	r3, [r6, #4]
1822:../drivers/fsl_i2c.c ****             xfer->completionStatus = kStatus_I2C_Nak;
 1866              		.loc 1 1822 0
 1867 00b0 464A     		ldr	r2, .L167
 1868 00b2 3261     		str	r2, [r6, #16]
1823:../drivers/fsl_i2c.c ****             handle->isBusy = false;
 1869              		.loc 1 1823 0
 1870 00b4 0022     		movs	r2, #0
 1871 00b6 3270     		strb	r2, [r6]
1824:../drivers/fsl_i2c.c **** 
1825:../drivers/fsl_i2c.c ****             if ((handle->eventMask & xfer->event) && (handle->callback))
 1872              		.loc 1 1825 0
 1873 00b8 B269     		ldr	r2, [r6, #24]
 1874 00ba 1342     		tst	r3, r2
 1875 00bc 06D0     		beq	.L145
 1876              		.loc 1 1825 0 is_stmt 0 discriminator 1
 1877 00be F369     		ldr	r3, [r6, #28]
 1878 00c0 002B     		cmp	r3, #0
 1879 00c2 03D0     		beq	.L145
1826:../drivers/fsl_i2c.c ****             {
1827:../drivers/fsl_i2c.c ****                 handle->callback(base, xfer, handle->userData);
 1880              		.loc 1 1827 0 is_stmt 1
 1881 00c4 326A     		ldr	r2, [r6, #32]
 1882 00c6 3900     		movs	r1, r7
 1883 00c8 2800     		movs	r0, r5
 1884 00ca 9847     		blx	r3
 1885              	.LVL197:
 1886              	.L145:
1828:../drivers/fsl_i2c.c ****             }
1829:../drivers/fsl_i2c.c ****         }
1830:../drivers/fsl_i2c.c ****         else
1831:../drivers/fsl_i2c.c ****         {
1832:../drivers/fsl_i2c.c **** #ifndef I2C_HAS_STOP_DETECT
1833:../drivers/fsl_i2c.c ****             xfer->event = kI2C_SlaveCompletionEvent;
1834:../drivers/fsl_i2c.c ****             xfer->completionStatus = kStatus_Success;
1835:../drivers/fsl_i2c.c ****             handle->isBusy = false;
1836:../drivers/fsl_i2c.c **** 
1837:../drivers/fsl_i2c.c ****             if ((handle->eventMask & xfer->event) && (handle->callback))
1838:../drivers/fsl_i2c.c ****             {
1839:../drivers/fsl_i2c.c ****                 handle->callback(base, xfer, handle->userData);
1840:../drivers/fsl_i2c.c ****             }
1841:../drivers/fsl_i2c.c **** #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
1842:../drivers/fsl_i2c.c ****         }
1843:../drivers/fsl_i2c.c ****     }
1844:../drivers/fsl_i2c.c ****     /* Check address match. */
1845:../drivers/fsl_i2c.c ****     else if (status & kI2C_AddressMatchFlag)
1846:../drivers/fsl_i2c.c ****     {
1847:../drivers/fsl_i2c.c ****         handle->isBusy = true;
1848:../drivers/fsl_i2c.c ****         xfer->event = kI2C_SlaveAddressMatchEvent;
1849:../drivers/fsl_i2c.c **** 
1850:../drivers/fsl_i2c.c ****         /* Slave transmit, master reading from slave. */
1851:../drivers/fsl_i2c.c ****         if (status & kI2C_TransferDirectionFlag)
1852:../drivers/fsl_i2c.c ****         {
1853:../drivers/fsl_i2c.c ****             /* Change direction to send data. */
1854:../drivers/fsl_i2c.c ****             base->C1 |= I2C_C1_TX_MASK;
1855:../drivers/fsl_i2c.c **** 
1856:../drivers/fsl_i2c.c ****             doTransmit = true;
1857:../drivers/fsl_i2c.c ****         }
1858:../drivers/fsl_i2c.c ****         else
1859:../drivers/fsl_i2c.c ****         {
1860:../drivers/fsl_i2c.c ****             /* Slave receive, master writing to slave. */
1861:../drivers/fsl_i2c.c ****             base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
1862:../drivers/fsl_i2c.c **** 
1863:../drivers/fsl_i2c.c ****             /* Read dummy to release the bus. */
1864:../drivers/fsl_i2c.c ****             dummy = base->D;
1865:../drivers/fsl_i2c.c **** 
1866:../drivers/fsl_i2c.c ****             if (dummy == 0)
1867:../drivers/fsl_i2c.c ****             {
1868:../drivers/fsl_i2c.c ****                 xfer->event = kI2C_SlaveGenaralcallEvent;
1869:../drivers/fsl_i2c.c ****             }
1870:../drivers/fsl_i2c.c ****         }
1871:../drivers/fsl_i2c.c **** 
1872:../drivers/fsl_i2c.c ****         if ((handle->eventMask & xfer->event) && (handle->callback))
1873:../drivers/fsl_i2c.c ****         {
1874:../drivers/fsl_i2c.c ****             handle->callback(base, xfer, handle->userData);
1875:../drivers/fsl_i2c.c ****         }
1876:../drivers/fsl_i2c.c ****     }
1877:../drivers/fsl_i2c.c ****     /* Check transfer complete flag. */
1878:../drivers/fsl_i2c.c ****     else if (status & kI2C_TransferCompleteFlag)
1879:../drivers/fsl_i2c.c ****     {
1880:../drivers/fsl_i2c.c ****         /* Slave transmit, master reading from slave. */
1881:../drivers/fsl_i2c.c ****         if (status & kI2C_TransferDirectionFlag)
1882:../drivers/fsl_i2c.c ****         {
1883:../drivers/fsl_i2c.c ****             doTransmit = true;
1884:../drivers/fsl_i2c.c ****         }
1885:../drivers/fsl_i2c.c ****         else
1886:../drivers/fsl_i2c.c ****         {
1887:../drivers/fsl_i2c.c ****             /* If we're out of data, invoke callback to get more. */
1888:../drivers/fsl_i2c.c ****             if ((!xfer->data) || (!xfer->dataSize))
1889:../drivers/fsl_i2c.c ****             {
1890:../drivers/fsl_i2c.c ****                 xfer->event = kI2C_SlaveReceiveEvent;
1891:../drivers/fsl_i2c.c **** 
1892:../drivers/fsl_i2c.c ****                 if (handle->callback)
1893:../drivers/fsl_i2c.c ****                 {
1894:../drivers/fsl_i2c.c ****                     handle->callback(base, xfer, handle->userData);
1895:../drivers/fsl_i2c.c ****                 }
1896:../drivers/fsl_i2c.c **** 
1897:../drivers/fsl_i2c.c ****                 /* Clear the transferred count now that we have a new buffer. */
1898:../drivers/fsl_i2c.c ****                 xfer->transferredCount = 0;
1899:../drivers/fsl_i2c.c ****             }
1900:../drivers/fsl_i2c.c **** 
1901:../drivers/fsl_i2c.c ****             /* Slave receive, master writing to slave. */
1902:../drivers/fsl_i2c.c ****             uint8_t data = base->D;
1903:../drivers/fsl_i2c.c **** 
1904:../drivers/fsl_i2c.c ****             if (handle->transfer.dataSize)
1905:../drivers/fsl_i2c.c ****             {
1906:../drivers/fsl_i2c.c ****                 /* Receive data. */
1907:../drivers/fsl_i2c.c ****                 *handle->transfer.data++ = data;
1908:../drivers/fsl_i2c.c ****                 handle->transfer.dataSize--;
1909:../drivers/fsl_i2c.c ****                 xfer->transferredCount++;
1910:../drivers/fsl_i2c.c ****                 if (!handle->transfer.dataSize)
1911:../drivers/fsl_i2c.c ****                 {
1912:../drivers/fsl_i2c.c **** #ifndef I2C_HAS_STOP_DETECT
1913:../drivers/fsl_i2c.c ****                     xfer->event = kI2C_SlaveCompletionEvent;
1914:../drivers/fsl_i2c.c ****                     xfer->completionStatus = kStatus_Success;
1915:../drivers/fsl_i2c.c ****                     handle->isBusy = false;
1916:../drivers/fsl_i2c.c **** 
1917:../drivers/fsl_i2c.c ****                     /* Proceed receive complete event. */
1918:../drivers/fsl_i2c.c ****                     if ((handle->eventMask & xfer->event) && (handle->callback))
1919:../drivers/fsl_i2c.c ****                     {
1920:../drivers/fsl_i2c.c ****                         handle->callback(base, xfer, handle->userData);
1921:../drivers/fsl_i2c.c ****                     }
1922:../drivers/fsl_i2c.c **** #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
1923:../drivers/fsl_i2c.c ****                 }
1924:../drivers/fsl_i2c.c ****             }
1925:../drivers/fsl_i2c.c ****         }
1926:../drivers/fsl_i2c.c ****     }
1927:../drivers/fsl_i2c.c ****     else
1928:../drivers/fsl_i2c.c ****     {
1929:../drivers/fsl_i2c.c ****         /* Read dummy to release bus. */
1930:../drivers/fsl_i2c.c ****         dummy = base->D;
1931:../drivers/fsl_i2c.c ****     }
1932:../drivers/fsl_i2c.c **** 
1933:../drivers/fsl_i2c.c ****     /* Send data if there is the need. */
1934:../drivers/fsl_i2c.c ****     if (doTransmit)
1935:../drivers/fsl_i2c.c ****     {
1936:../drivers/fsl_i2c.c ****         /* If we're out of data, invoke callback to get more. */
1937:../drivers/fsl_i2c.c ****         if ((!xfer->data) || (!xfer->dataSize))
1938:../drivers/fsl_i2c.c ****         {
1939:../drivers/fsl_i2c.c ****             xfer->event = kI2C_SlaveTransmitEvent;
1940:../drivers/fsl_i2c.c **** 
1941:../drivers/fsl_i2c.c ****             if (handle->callback)
1942:../drivers/fsl_i2c.c ****             {
1943:../drivers/fsl_i2c.c ****                 handle->callback(base, xfer, handle->userData);
1944:../drivers/fsl_i2c.c ****             }
1945:../drivers/fsl_i2c.c **** 
1946:../drivers/fsl_i2c.c ****             /* Clear the transferred count now that we have a new buffer. */
1947:../drivers/fsl_i2c.c ****             xfer->transferredCount = 0;
1948:../drivers/fsl_i2c.c ****         }
1949:../drivers/fsl_i2c.c **** 
1950:../drivers/fsl_i2c.c ****         if (handle->transfer.dataSize)
1951:../drivers/fsl_i2c.c ****         {
1952:../drivers/fsl_i2c.c ****             /* Send data. */
1953:../drivers/fsl_i2c.c ****             base->D = *handle->transfer.data++;
1954:../drivers/fsl_i2c.c ****             handle->transfer.dataSize--;
1955:../drivers/fsl_i2c.c ****             xfer->transferredCount++;
1956:../drivers/fsl_i2c.c ****         }
1957:../drivers/fsl_i2c.c ****         else
1958:../drivers/fsl_i2c.c ****         {
1959:../drivers/fsl_i2c.c ****             /* Switch to receive mode. */
1960:../drivers/fsl_i2c.c ****             base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
1961:../drivers/fsl_i2c.c **** 
1962:../drivers/fsl_i2c.c ****             /* Read dummy to release bus. */
1963:../drivers/fsl_i2c.c ****             dummy = base->D;
1964:../drivers/fsl_i2c.c **** 
1965:../drivers/fsl_i2c.c **** #ifndef I2C_HAS_STOP_DETECT
1966:../drivers/fsl_i2c.c ****             xfer->event = kI2C_SlaveCompletionEvent;
1967:../drivers/fsl_i2c.c ****             xfer->completionStatus = kStatus_Success;
1968:../drivers/fsl_i2c.c ****             handle->isBusy = false;
1969:../drivers/fsl_i2c.c **** 
1970:../drivers/fsl_i2c.c ****             /* Proceed txdone event. */
1971:../drivers/fsl_i2c.c ****             if ((handle->eventMask & xfer->event) && (handle->callback))
1972:../drivers/fsl_i2c.c ****             {
1973:../drivers/fsl_i2c.c ****                 handle->callback(base, xfer, handle->userData);
1974:../drivers/fsl_i2c.c ****             }
1975:../drivers/fsl_i2c.c **** #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
1976:../drivers/fsl_i2c.c ****         }
1977:../drivers/fsl_i2c.c ****     }
1978:../drivers/fsl_i2c.c **** }
 1887              		.loc 1 1978 0
 1888 00cc 03B0     		add	sp, sp, #12
 1889              		@ sp needed
 1890              	.LVL198:
 1891              	.LVL199:
 1892              	.LVL200:
 1893 00ce F0BD     		pop	{r4, r5, r6, r7, pc}
 1894              	.LVL201:
 1895              	.L151:
1845:../drivers/fsl_i2c.c ****     {
 1896              		.loc 1 1845 0
 1897 00d0 6306     		lsls	r3, r4, #25
 1898 00d2 44D5     		bpl	.L152
1847:../drivers/fsl_i2c.c ****         xfer->event = kI2C_SlaveAddressMatchEvent;
 1899              		.loc 1 1847 0
 1900 00d4 0123     		movs	r3, #1
 1901 00d6 3370     		strb	r3, [r6]
1848:../drivers/fsl_i2c.c **** 
 1902              		.loc 1 1848 0
 1903 00d8 3371     		strb	r3, [r6, #4]
1851:../drivers/fsl_i2c.c ****         {
 1904              		.loc 1 1851 0
 1905 00da 6307     		lsls	r3, r4, #29
 1906 00dc 2ED5     		bpl	.L153
1854:../drivers/fsl_i2c.c **** 
 1907              		.loc 1 1854 0
 1908 00de AB78     		ldrb	r3, [r5, #2]
 1909 00e0 1022     		movs	r2, #16
 1910 00e2 1343     		orrs	r3, r2
 1911 00e4 AB70     		strb	r3, [r5, #2]
 1912              	.LVL202:
1856:../drivers/fsl_i2c.c ****         }
 1913              		.loc 1 1856 0
 1914 00e6 0124     		movs	r4, #1
 1915              	.LVL203:
 1916              	.L154:
1872:../drivers/fsl_i2c.c ****         {
 1917              		.loc 1 1872 0
 1918 00e8 3379     		ldrb	r3, [r6, #4]
 1919 00ea B269     		ldr	r2, [r6, #24]
 1920 00ec 1342     		tst	r3, r2
 1921 00ee 06D0     		beq	.L155
1872:../drivers/fsl_i2c.c ****         {
 1922              		.loc 1 1872 0 is_stmt 0 discriminator 1
 1923 00f0 F369     		ldr	r3, [r6, #28]
 1924 00f2 002B     		cmp	r3, #0
 1925 00f4 03D0     		beq	.L155
1874:../drivers/fsl_i2c.c ****         }
 1926              		.loc 1 1874 0 is_stmt 1
 1927 00f6 326A     		ldr	r2, [r6, #32]
 1928 00f8 3900     		movs	r1, r7
 1929 00fa 2800     		movs	r0, r5
 1930 00fc 9847     		blx	r3
 1931              	.LVL204:
 1932              	.L155:
1934:../drivers/fsl_i2c.c ****     {
 1933              		.loc 1 1934 0
 1934 00fe 002C     		cmp	r4, #0
 1935 0100 E4D0     		beq	.L145
 1936              	.LVL205:
 1937              	.L157:
1937:../drivers/fsl_i2c.c ****         {
 1938              		.loc 1 1937 0
 1939 0102 B368     		ldr	r3, [r6, #8]
 1940 0104 002B     		cmp	r3, #0
 1941 0106 02D0     		beq	.L161
1937:../drivers/fsl_i2c.c ****         {
 1942              		.loc 1 1937 0 is_stmt 0 discriminator 1
 1943 0108 F368     		ldr	r3, [r6, #12]
 1944 010a 002B     		cmp	r3, #0
 1945 010c 0AD1     		bne	.L162
 1946              	.L161:
1939:../drivers/fsl_i2c.c **** 
 1947              		.loc 1 1939 0 is_stmt 1
 1948 010e 0223     		movs	r3, #2
 1949 0110 3371     		strb	r3, [r6, #4]
1941:../drivers/fsl_i2c.c ****             {
 1950              		.loc 1 1941 0
 1951 0112 F369     		ldr	r3, [r6, #28]
 1952 0114 002B     		cmp	r3, #0
 1953 0116 03D0     		beq	.L163
1943:../drivers/fsl_i2c.c ****             }
 1954              		.loc 1 1943 0
 1955 0118 326A     		ldr	r2, [r6, #32]
 1956 011a 3900     		movs	r1, r7
 1957 011c 2800     		movs	r0, r5
 1958 011e 9847     		blx	r3
 1959              	.LVL206:
 1960              	.L163:
1947:../drivers/fsl_i2c.c ****         }
 1961              		.loc 1 1947 0
 1962 0120 0023     		movs	r3, #0
 1963 0122 7361     		str	r3, [r6, #20]
 1964              	.L162:
1950:../drivers/fsl_i2c.c ****         {
 1965              		.loc 1 1950 0
 1966 0124 F368     		ldr	r3, [r6, #12]
 1967 0126 002B     		cmp	r3, #0
 1968 0128 44D1     		bne	.L166
1960:../drivers/fsl_i2c.c **** 
 1969              		.loc 1 1960 0
 1970 012a AB78     		ldrb	r3, [r5, #2]
 1971 012c 1822     		movs	r2, #24
 1972 012e 9343     		bics	r3, r2
 1973 0130 AB70     		strb	r3, [r5, #2]
1963:../drivers/fsl_i2c.c **** 
 1974              		.loc 1 1963 0
 1975 0132 2B79     		ldrb	r3, [r5, #4]
 1976 0134 DBB2     		uxtb	r3, r3
 1977 0136 6A46     		mov	r2, sp
 1978 0138 D371     		strb	r3, [r2, #7]
 1979 013a C7E7     		b	.L145
 1980              	.LVL207:
 1981              	.L153:
1861:../drivers/fsl_i2c.c **** 
 1982              		.loc 1 1861 0
 1983 013c AB78     		ldrb	r3, [r5, #2]
 1984 013e 1822     		movs	r2, #24
 1985 0140 9343     		bics	r3, r2
 1986 0142 AB70     		strb	r3, [r5, #2]
1864:../drivers/fsl_i2c.c **** 
 1987              		.loc 1 1864 0
 1988 0144 2B79     		ldrb	r3, [r5, #4]
 1989 0146 DBB2     		uxtb	r3, r3
 1990 0148 6A46     		mov	r2, sp
 1991 014a D371     		strb	r3, [r2, #7]
1866:../drivers/fsl_i2c.c ****             {
 1992              		.loc 1 1866 0
 1993 014c D379     		ldrb	r3, [r2, #7]
 1994 014e 002B     		cmp	r3, #0
 1995 0150 03D1     		bne	.L165
1868:../drivers/fsl_i2c.c ****             }
 1996              		.loc 1 1868 0
 1997 0152 4033     		adds	r3, r3, #64
 1998 0154 3371     		strb	r3, [r6, #4]
1744:../drivers/fsl_i2c.c ****     i2c_slave_handle_t *handle = (i2c_slave_handle_t *)i2cHandle;
 1999              		.loc 1 1744 0
 2000 0156 0024     		movs	r4, #0
 2001 0158 C6E7     		b	.L154
 2002              	.L165:
 2003 015a 0024     		movs	r4, #0
 2004 015c C4E7     		b	.L154
 2005              	.L152:
1878:../drivers/fsl_i2c.c ****     {
 2006              		.loc 1 1878 0
 2007 015e 2306     		lsls	r3, r4, #24
 2008 0160 23D5     		bpl	.L156
1881:../drivers/fsl_i2c.c ****         {
 2009              		.loc 1 1881 0
 2010 0162 6307     		lsls	r3, r4, #29
 2011 0164 CDD4     		bmi	.L157
 2012              	.LBB63:
1888:../drivers/fsl_i2c.c ****             {
 2013              		.loc 1 1888 0
 2014 0166 B368     		ldr	r3, [r6, #8]
 2015 0168 002B     		cmp	r3, #0
 2016 016a 02D0     		beq	.L158
1888:../drivers/fsl_i2c.c ****             {
 2017              		.loc 1 1888 0 is_stmt 0 discriminator 1
 2018 016c F368     		ldr	r3, [r6, #12]
 2019 016e 002B     		cmp	r3, #0
 2020 0170 0AD1     		bne	.L159
 2021              	.L158:
1890:../drivers/fsl_i2c.c **** 
 2022              		.loc 1 1890 0 is_stmt 1
 2023 0172 0423     		movs	r3, #4
 2024 0174 3371     		strb	r3, [r6, #4]
1892:../drivers/fsl_i2c.c ****                 {
 2025              		.loc 1 1892 0
 2026 0176 F369     		ldr	r3, [r6, #28]
 2027 0178 002B     		cmp	r3, #0
 2028 017a 03D0     		beq	.L160
1894:../drivers/fsl_i2c.c ****                 }
 2029              		.loc 1 1894 0
 2030 017c 326A     		ldr	r2, [r6, #32]
 2031 017e 3900     		movs	r1, r7
 2032 0180 2800     		movs	r0, r5
 2033 0182 9847     		blx	r3
 2034              	.LVL208:
 2035              	.L160:
1898:../drivers/fsl_i2c.c ****             }
 2036              		.loc 1 1898 0
 2037 0184 0023     		movs	r3, #0
 2038 0186 7361     		str	r3, [r6, #20]
 2039              	.L159:
1902:../drivers/fsl_i2c.c **** 
 2040              		.loc 1 1902 0
 2041 0188 2B79     		ldrb	r3, [r5, #4]
 2042 018a DBB2     		uxtb	r3, r3
 2043              	.LVL209:
1904:../drivers/fsl_i2c.c ****             {
 2044              		.loc 1 1904 0
 2045 018c F268     		ldr	r2, [r6, #12]
 2046 018e 002A     		cmp	r2, #0
 2047 0190 9CD0     		beq	.L145
1907:../drivers/fsl_i2c.c ****                 handle->transfer.dataSize--;
 2048              		.loc 1 1907 0
 2049 0192 B268     		ldr	r2, [r6, #8]
 2050 0194 511C     		adds	r1, r2, #1
 2051 0196 B160     		str	r1, [r6, #8]
 2052 0198 1370     		strb	r3, [r2]
1908:../drivers/fsl_i2c.c ****                 xfer->transferredCount++;
 2053              		.loc 1 1908 0
 2054 019a F368     		ldr	r3, [r6, #12]
 2055              	.LVL210:
 2056 019c 013B     		subs	r3, r3, #1
 2057 019e F360     		str	r3, [r6, #12]
 2058              	.LVL211:
1909:../drivers/fsl_i2c.c ****                 if (!handle->transfer.dataSize)
 2059              		.loc 1 1909 0
 2060 01a0 7369     		ldr	r3, [r6, #20]
 2061 01a2 0133     		adds	r3, r3, #1
 2062 01a4 7361     		str	r3, [r6, #20]
1910:../drivers/fsl_i2c.c ****                 {
 2063              		.loc 1 1910 0
 2064 01a6 F368     		ldr	r3, [r6, #12]
 2065 01a8 90E7     		b	.L145
 2066              	.L156:
 2067              	.LBE63:
1930:../drivers/fsl_i2c.c ****     }
 2068              		.loc 1 1930 0
 2069 01aa 2B79     		ldrb	r3, [r5, #4]
 2070 01ac DBB2     		uxtb	r3, r3
 2071 01ae 6A46     		mov	r2, sp
 2072 01b0 D371     		strb	r3, [r2, #7]
 2073 01b2 8BE7     		b	.L145
 2074              	.LVL212:
 2075              	.L166:
1953:../drivers/fsl_i2c.c ****             handle->transfer.dataSize--;
 2076              		.loc 1 1953 0
 2077 01b4 B368     		ldr	r3, [r6, #8]
 2078 01b6 5A1C     		adds	r2, r3, #1
 2079 01b8 B260     		str	r2, [r6, #8]
 2080 01ba 1B78     		ldrb	r3, [r3]
 2081 01bc 2B71     		strb	r3, [r5, #4]
1954:../drivers/fsl_i2c.c ****             xfer->transferredCount++;
 2082              		.loc 1 1954 0
 2083 01be F368     		ldr	r3, [r6, #12]
 2084 01c0 013B     		subs	r3, r3, #1
 2085 01c2 F360     		str	r3, [r6, #12]
1955:../drivers/fsl_i2c.c ****         }
 2086              		.loc 1 1955 0
 2087 01c4 7369     		ldr	r3, [r6, #20]
 2088 01c6 0133     		adds	r3, r3, #1
 2089 01c8 7361     		str	r3, [r6, #20]
 2090 01ca 7FE7     		b	.L145
 2091              	.L168:
 2092              		.align	2
 2093              	.L167:
 2094 01cc 4E040000 		.word	1102
 2095              		.cfi_endproc
 2096              	.LFE92:
 2098              		.section	.text.I2C_MasterWriteBlocking,"ax",%progbits
 2099              		.align	1
 2100              		.global	I2C_MasterWriteBlocking
 2101              		.syntax unified
 2102              		.code	16
 2103              		.thumb_func
 2104              		.fpu softvfp
 2106              	I2C_MasterWriteBlocking:
 2107              	.LFB75:
 847:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 2108              		.loc 1 847 0
 2109              		.cfi_startproc
 2110              		@ args = 0, pretend = 0, frame = 0
 2111              		@ frame_needed = 0, uses_anonymous_args = 0
 2112              	.LVL213:
 2113 0000 70B5     		push	{r4, r5, r6, lr}
 2114              		.cfi_def_cfa_offset 16
 2115              		.cfi_offset 4, -16
 2116              		.cfi_offset 5, -12
 2117              		.cfi_offset 6, -8
 2118              		.cfi_offset 14, -4
 2119              	.L170:
 863:../drivers/fsl_i2c.c ****     {
 2120              		.loc 1 863 0 discriminator 1
 2121 0002 C478     		ldrb	r4, [r0, #3]
 2122 0004 64B2     		sxtb	r4, r4
 2123 0006 002C     		cmp	r4, #0
 2124 0008 FBDA     		bge	.L170
 869:../drivers/fsl_i2c.c **** 
 2125              		.loc 1 869 0
 2126 000a 0224     		movs	r4, #2
 2127 000c C470     		strb	r4, [r0, #3]
 872:../drivers/fsl_i2c.c **** 
 2128              		.loc 1 872 0
 2129 000e 8478     		ldrb	r4, [r0, #2]
 2130 0010 1025     		movs	r5, #16
 2131 0012 2C43     		orrs	r4, r5
 2132 0014 8470     		strb	r4, [r0, #2]
 848:../drivers/fsl_i2c.c ****     uint8_t statusFlags = 0;
 2133              		.loc 1 848 0
 2134 0016 0025     		movs	r5, #0
 874:../drivers/fsl_i2c.c ****     {
 2135              		.loc 1 874 0
 2136 0018 03E0     		b	.L171
 2137              	.LVL214:
 2138              	.L174:
 2139 001a 2200     		movs	r2, r4
 913:../drivers/fsl_i2c.c ****         {
 2140              		.loc 1 913 0
 2141 001c 002D     		cmp	r5, #0
 2142 001e 19D1     		bne	.L175
 2143              	.LVL215:
 877:../drivers/fsl_i2c.c **** 
 2144              		.loc 1 877 0
 2145 0020 3100     		movs	r1, r6
 2146              	.LVL216:
 2147              	.L171:
 874:../drivers/fsl_i2c.c ****     {
 2148              		.loc 1 874 0
 2149 0022 541E     		subs	r4, r2, #1
 2150              	.LVL217:
 2151 0024 002A     		cmp	r2, #0
 2152 0026 15D0     		beq	.L175
 877:../drivers/fsl_i2c.c **** 
 2153              		.loc 1 877 0
 2154 0028 4E1C     		adds	r6, r1, #1
 2155              	.LVL218:
 2156 002a 0A78     		ldrb	r2, [r1]
 2157 002c 0271     		strb	r2, [r0, #4]
 2158              	.L172:
 891:../drivers/fsl_i2c.c ****         {
 2159              		.loc 1 891 0 discriminator 1
 2160 002e C278     		ldrb	r2, [r0, #3]
 2161 0030 9207     		lsls	r2, r2, #30
 2162 0032 FCD5     		bpl	.L172
 895:../drivers/fsl_i2c.c **** 
 2163              		.loc 1 895 0
 2164 0034 C278     		ldrb	r2, [r0, #3]
 2165 0036 D2B2     		uxtb	r2, r2
 2166              	.LVL219:
 898:../drivers/fsl_i2c.c **** 
 2167              		.loc 1 898 0
 2168 0038 0221     		movs	r1, #2
 2169 003a C170     		strb	r1, [r0, #3]
 901:../drivers/fsl_i2c.c ****         {
 2170              		.loc 1 901 0
 2171 003c D106     		lsls	r1, r2, #27
 2172 003e 02D5     		bpl	.L173
 903:../drivers/fsl_i2c.c ****             result = kStatus_I2C_ArbitrationLost;
 2173              		.loc 1 903 0
 2174 0040 1021     		movs	r1, #16
 2175 0042 C170     		strb	r1, [r0, #3]
 2176              	.LVL220:
 904:../drivers/fsl_i2c.c ****         }
 2177              		.loc 1 904 0
 2178 0044 0A4D     		ldr	r5, .L180
 2179              	.LVL221:
 2180              	.L173:
 907:../drivers/fsl_i2c.c ****         {
 2181              		.loc 1 907 0
 2182 0046 D207     		lsls	r2, r2, #31
 2183 0048 E7D5     		bpl	.L174
 2184              	.LVL222:
 907:../drivers/fsl_i2c.c ****         {
 2185              		.loc 1 907 0 is_stmt 0 discriminator 1
 2186 004a 002C     		cmp	r4, #0
 2187 004c E5D0     		beq	.L174
 909:../drivers/fsl_i2c.c ****             result = kStatus_I2C_Nak;
 2188              		.loc 1 909 0 is_stmt 1
 2189 004e 0122     		movs	r2, #1
 2190 0050 C270     		strb	r2, [r0, #3]
 2191              	.LVL223:
 910:../drivers/fsl_i2c.c ****         }
 2192              		.loc 1 910 0
 2193 0052 084D     		ldr	r5, .L180+4
 2194              	.LVL224:
 2195              	.L175:
 920:../drivers/fsl_i2c.c ****     {
 2196              		.loc 1 920 0
 2197 0054 002D     		cmp	r5, #0
 2198 0056 01D1     		bne	.L177
 920:../drivers/fsl_i2c.c ****     {
 2199              		.loc 1 920 0 is_stmt 0 discriminator 1
 2200 0058 5B07     		lsls	r3, r3, #29
 2201 005a 02D5     		bpl	.L178
 2202              	.LVL225:
 2203              	.L177:
 920:../drivers/fsl_i2c.c ****     {
 2204              		.loc 1 920 0 discriminator 3
 2205 005c 054B     		ldr	r3, .L180+4
 2206 005e 9D42     		cmp	r5, r3
 2207 0060 04D1     		bne	.L169
 2208              	.L178:
 923:../drivers/fsl_i2c.c **** 
 2209              		.loc 1 923 0 is_stmt 1
 2210 0062 0223     		movs	r3, #2
 2211 0064 C370     		strb	r3, [r0, #3]
 926:../drivers/fsl_i2c.c ****     }
 2212              		.loc 1 926 0
 2213 0066 FFF7FEFF 		bl	I2C_MasterStop
 2214              	.LVL226:
 2215 006a 0500     		movs	r5, r0
 2216              	.LVL227:
 2217              	.L169:
 930:../drivers/fsl_i2c.c **** 
 2218              		.loc 1 930 0
 2219 006c 2800     		movs	r0, r5
 2220              		@ sp needed
 2221              	.LVL228:
 2222              	.LVL229:
 2223 006e 70BD     		pop	{r4, r5, r6, pc}
 2224              	.L181:
 2225              		.align	2
 2226              	.L180:
 2227 0070 4F040000 		.word	1103
 2228 0074 4E040000 		.word	1102
 2229              		.cfi_endproc
 2230              	.LFE75:
 2232              		.section	.text.I2C_MasterReadBlocking,"ax",%progbits
 2233              		.align	1
 2234              		.global	I2C_MasterReadBlocking
 2235              		.syntax unified
 2236              		.code	16
 2237              		.thumb_func
 2238              		.fpu softvfp
 2240              	I2C_MasterReadBlocking:
 2241              	.LFB76:
 933:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 2242              		.loc 1 933 0
 2243              		.cfi_startproc
 2244              		@ args = 0, pretend = 0, frame = 8
 2245              		@ frame_needed = 0, uses_anonymous_args = 0
 2246              	.LVL230:
 2247 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2248              		.cfi_def_cfa_offset 20
 2249              		.cfi_offset 4, -20
 2250              		.cfi_offset 5, -16
 2251              		.cfi_offset 6, -12
 2252              		.cfi_offset 7, -8
 2253              		.cfi_offset 14, -4
 2254 0002 83B0     		sub	sp, sp, #12
 2255              		.cfi_def_cfa_offset 32
 2256 0004 0400     		movs	r4, r0
 2257 0006 0F00     		movs	r7, r1
 2258 0008 1D00     		movs	r5, r3
 2259              	.LVL231:
 935:../drivers/fsl_i2c.c **** 
 2260              		.loc 1 935 0
 2261 000a 6B46     		mov	r3, sp
 2262              	.LVL232:
 2263 000c D91D     		adds	r1, r3, #7
 2264              	.LVL233:
 2265 000e 0023     		movs	r3, #0
 2266 0010 0B70     		strb	r3, [r1]
 938:../drivers/fsl_i2c.c **** 
 2267              		.loc 1 938 0
 2268 0012 0B78     		ldrb	r3, [r1]
 2269 0014 0133     		adds	r3, r3, #1
 2270 0016 DBB2     		uxtb	r3, r3
 2271 0018 0B70     		strb	r3, [r1]
 2272              	.L183:
 952:../drivers/fsl_i2c.c ****     {
 2273              		.loc 1 952 0 discriminator 1
 2274 001a E378     		ldrb	r3, [r4, #3]
 2275 001c 5BB2     		sxtb	r3, r3
 2276 001e 002B     		cmp	r3, #0
 2277 0020 FBDA     		bge	.L183
 958:../drivers/fsl_i2c.c **** 
 2278              		.loc 1 958 0
 2279 0022 0223     		movs	r3, #2
 2280 0024 E370     		strb	r3, [r4, #3]
 961:../drivers/fsl_i2c.c **** 
 2281              		.loc 1 961 0
 2282 0026 A378     		ldrb	r3, [r4, #2]
 2283 0028 1821     		movs	r1, #24
 2284 002a 8B43     		bics	r3, r1
 2285 002c A370     		strb	r3, [r4, #2]
 964:../drivers/fsl_i2c.c ****     {
 2286              		.loc 1 964 0
 2287 002e 012A     		cmp	r2, #1
 2288 0030 05D0     		beq	.L190
 2289              	.L184:
 971:../drivers/fsl_i2c.c **** 
 2290              		.loc 1 971 0
 2291 0032 2379     		ldrb	r3, [r4, #4]
 2292 0034 DBB2     		uxtb	r3, r3
 2293 0036 6946     		mov	r1, sp
 2294 0038 CB71     		strb	r3, [r1, #7]
 934:../drivers/fsl_i2c.c ****     volatile uint8_t dummy = 0;
 2295              		.loc 1 934 0
 2296 003a 0020     		movs	r0, #0
 2297              	.LVL234:
 973:../drivers/fsl_i2c.c ****     {
 2298              		.loc 1 973 0
 2299 003c 0DE0     		b	.L185
 2300              	.LVL235:
 2301              	.L190:
 967:../drivers/fsl_i2c.c ****     }
 2302              		.loc 1 967 0
 2303 003e A378     		ldrb	r3, [r4, #2]
 2304 0040 0821     		movs	r1, #8
 2305 0042 0B43     		orrs	r3, r1
 2306 0044 A370     		strb	r3, [r4, #2]
 2307 0046 F4E7     		b	.L184
 2308              	.LVL236:
 2309              	.L193:
1000:../drivers/fsl_i2c.c ****             }
 2310              		.loc 1 1000 0
 2311 0048 2000     		movs	r0, r4
 2312              	.LVL237:
 2313 004a FFF7FEFF 		bl	I2C_MasterStop
 2314              	.LVL238:
 2315              	.L187:
1009:../drivers/fsl_i2c.c ****         {
 2316              		.loc 1 1009 0
 2317 004e 012E     		cmp	r6, #1
 2318 0050 14D0     		beq	.L191
 2319              	.L189:
 2320              	.LVL239:
1016:../drivers/fsl_i2c.c ****     }
 2321              		.loc 1 1016 0
 2322 0052 2379     		ldrb	r3, [r4, #4]
 2323 0054 3B70     		strb	r3, [r7]
 973:../drivers/fsl_i2c.c ****     {
 2324              		.loc 1 973 0
 2325 0056 3200     		movs	r2, r6
1016:../drivers/fsl_i2c.c ****     }
 2326              		.loc 1 1016 0
 2327 0058 0137     		adds	r7, r7, #1
 2328              	.LVL240:
 2329              	.L185:
 973:../drivers/fsl_i2c.c ****     {
 2330              		.loc 1 973 0
 2331 005a 561E     		subs	r6, r2, #1
 2332              	.LVL241:
 2333 005c 002A     		cmp	r2, #0
 2334 005e 12D0     		beq	.L192
 2335              	.L186:
 987:../drivers/fsl_i2c.c ****         {
 2336              		.loc 1 987 0 discriminator 1
 2337 0060 E378     		ldrb	r3, [r4, #3]
 2338 0062 9B07     		lsls	r3, r3, #30
 2339 0064 FCD5     		bpl	.L186
 992:../drivers/fsl_i2c.c **** 
 2340              		.loc 1 992 0
 2341 0066 0223     		movs	r3, #2
 2342 0068 E370     		strb	r3, [r4, #3]
 995:../drivers/fsl_i2c.c ****         {
 2343              		.loc 1 995 0
 2344 006a 002E     		cmp	r6, #0
 2345 006c EFD1     		bne	.L187
 997:../drivers/fsl_i2c.c ****             {
 2346              		.loc 1 997 0
 2347 006e 6B07     		lsls	r3, r5, #29
 2348 0070 EAD5     		bpl	.L193
1005:../drivers/fsl_i2c.c ****             }
 2349              		.loc 1 1005 0
 2350 0072 A378     		ldrb	r3, [r4, #2]
 2351 0074 1022     		movs	r2, #16
 2352 0076 1343     		orrs	r3, r2
 2353 0078 A370     		strb	r3, [r4, #2]
 2354 007a E8E7     		b	.L187
 2355              	.L191:
1012:../drivers/fsl_i2c.c ****         }
 2356              		.loc 1 1012 0
 2357 007c A378     		ldrb	r3, [r4, #2]
 2358 007e 0822     		movs	r2, #8
 2359 0080 1343     		orrs	r3, r2
 2360 0082 A370     		strb	r3, [r4, #2]
 2361 0084 E5E7     		b	.L189
 2362              	.L192:
1020:../drivers/fsl_i2c.c **** 
 2363              		.loc 1 1020 0
 2364 0086 03B0     		add	sp, sp, #12
 2365              		@ sp needed
 2366              	.LVL242:
 2367              	.LVL243:
 2368              	.LVL244:
 2369              	.LVL245:
 2370 0088 F0BD     		pop	{r4, r5, r6, r7, pc}
 2371              		.cfi_endproc
 2372              	.LFE76:
 2374              		.section	.text.I2C_MasterTransferBlocking,"ax",%progbits
 2375              		.align	1
 2376              		.global	I2C_MasterTransferBlocking
 2377              		.syntax unified
 2378              		.code	16
 2379              		.thumb_func
 2380              		.fpu softvfp
 2382              	I2C_MasterTransferBlocking:
 2383              	.LFB77:
1023:../drivers/fsl_i2c.c ****     assert(xfer);
 2384              		.loc 1 1023 0
 2385              		.cfi_startproc
 2386              		@ args = 0, pretend = 0, frame = 0
 2387              		@ frame_needed = 0, uses_anonymous_args = 0
 2388              	.LVL246:
 2389 0000 70B5     		push	{r4, r5, r6, lr}
 2390              		.cfi_def_cfa_offset 16
 2391              		.cfi_offset 4, -16
 2392              		.cfi_offset 5, -12
 2393              		.cfi_offset 6, -8
 2394              		.cfi_offset 14, -4
 2395 0002 0400     		movs	r4, r0
 2396 0004 0D00     		movs	r5, r1
1026:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 2397              		.loc 1 1026 0
 2398 0006 4A79     		ldrb	r2, [r1, #5]
 2399              	.LVL247:
 2400              	.LBB64:
 2401              	.LBB65:
 446:../drivers/fsl_i2c.h ****     }
 2402              		.loc 3 446 0
 2403 0008 8179     		ldrb	r1, [r0, #6]
 2404              	.LVL248:
 2405 000a 5020     		movs	r0, #80
 2406              	.LVL249:
 2407 000c 0143     		orrs	r1, r0
 2408 000e A171     		strb	r1, [r4, #6]
 454:../drivers/fsl_i2c.h ****     }
 2409              		.loc 3 454 0
 2410 0010 A379     		ldrb	r3, [r4, #6]
 2411 0012 0343     		orrs	r3, r0
 2412 0014 A371     		strb	r3, [r4, #6]
 2413              		.loc 3 458 0
 2414 0016 1223     		movs	r3, #18
 2415 0018 E370     		strb	r3, [r4, #3]
 2416              	.L195:
 2417              	.LBE65:
 2418              	.LBE64:
1044:../drivers/fsl_i2c.c ****     {
 2419              		.loc 1 1044 0 discriminator 1
 2420 001a E378     		ldrb	r3, [r4, #3]
 2421 001c 5BB2     		sxtb	r3, r3
 2422 001e 002B     		cmp	r3, #0
 2423 0020 FBDA     		bge	.L195
1050:../drivers/fsl_i2c.c ****     {
 2424              		.loc 1 1050 0
 2425 0022 2B7B     		ldrb	r3, [r5, #12]
 2426 0024 002B     		cmp	r3, #0
 2427 0026 02D0     		beq	.L196
1050:../drivers/fsl_i2c.c ****     {
 2428              		.loc 1 1050 0 is_stmt 0 discriminator 1
 2429 0028 6B79     		ldrb	r3, [r5, #5]
 2430 002a 012B     		cmp	r3, #1
 2431 002c 1DD0     		beq	.L211
 2432              	.LVL250:
 2433              	.L196:
1056:../drivers/fsl_i2c.c ****     {
 2434              		.loc 1 1056 0 is_stmt 1
 2435 002e 2B68     		ldr	r3, [r5]
 2436 0030 D907     		lsls	r1, r3, #31
 2437 0032 1CD5     		bpl	.L197
1058:../drivers/fsl_i2c.c ****         {
 2438              		.loc 1 1058 0
 2439 0034 012A     		cmp	r2, #1
 2440 0036 00D1     		bne	.LCB2659
 2441 0038 85E0     		b	.L210	@long jump
 2442              	.LCB2659:
1027:../drivers/fsl_i2c.c **** 
 2443              		.loc 1 1027 0
 2444 003a 0026     		movs	r6, #0
 2445              	.LVL251:
 2446              	.L199:
1073:../drivers/fsl_i2c.c ****     {
 2447              		.loc 1 1073 0
 2448 003c 2B68     		ldr	r3, [r5]
 2449 003e DB07     		lsls	r3, r3, #31
 2450 0040 23D4     		bmi	.L201
1076:../drivers/fsl_i2c.c ****         {
 2451              		.loc 1 1076 0
 2452 0042 002E     		cmp	r6, #0
 2453 0044 48D1     		bne	.L194
 2454              	.L202:
1093:../drivers/fsl_i2c.c ****         {
 2455              		.loc 1 1093 0 discriminator 1
 2456 0046 E378     		ldrb	r3, [r4, #3]
 2457 0048 9B07     		lsls	r3, r3, #30
 2458 004a FCD5     		bpl	.L202
1098:../drivers/fsl_i2c.c **** 
 2459              		.loc 1 1098 0
 2460 004c E178     		ldrb	r1, [r4, #3]
 2461 004e C9B2     		uxtb	r1, r1
 2462 0050 2000     		movs	r0, r4
 2463 0052 FFF7FEFF 		bl	I2C_CheckAndClearError
 2464              	.LVL252:
 2465 0056 061E     		subs	r6, r0, #0
 2466              	.LVL253:
1101:../drivers/fsl_i2c.c ****         {
 2467              		.loc 1 1101 0
 2468 0058 17D0     		beq	.L201
1103:../drivers/fsl_i2c.c ****             {
 2469              		.loc 1 1103 0
 2470 005a 3C4B     		ldr	r3, .L216
 2471 005c 9842     		cmp	r0, r3
 2472 005e 3BD1     		bne	.L194
 2473              	.LVL254:
1107:../drivers/fsl_i2c.c ****             }
 2474              		.loc 1 1107 0
 2475 0060 2000     		movs	r0, r4
 2476 0062 FFF7FEFF 		bl	I2C_MasterStop
 2477              	.LVL255:
1105:../drivers/fsl_i2c.c **** 
 2478              		.loc 1 1105 0
 2479 0066 3A4E     		ldr	r6, .L216+4
 2480 0068 36E0     		b	.L194
 2481              	.LVL256:
 2482              	.L211:
1052:../drivers/fsl_i2c.c ****     }
 2483              		.loc 1 1052 0
 2484 006a 0022     		movs	r2, #0
 2485              	.LVL257:
 2486 006c DFE7     		b	.L196
 2487              	.LVL258:
 2488              	.L197:
1064:../drivers/fsl_i2c.c ****     {
 2489              		.loc 1 1064 0
 2490 006e 9B07     		lsls	r3, r3, #30
 2491 0070 05D5     		bpl	.L200
1066:../drivers/fsl_i2c.c ****     }
 2492              		.loc 1 1066 0
 2493 0072 2979     		ldrb	r1, [r5, #4]
 2494 0074 2000     		movs	r0, r4
 2495 0076 FFF7FEFF 		bl	I2C_MasterRepeatedStart
 2496              	.LVL259:
 2497 007a 0600     		movs	r6, r0
 2498              	.LVL260:
 2499 007c DEE7     		b	.L199
 2500              	.LVL261:
 2501              	.L200:
1070:../drivers/fsl_i2c.c ****     }
 2502              		.loc 1 1070 0
 2503 007e 2979     		ldrb	r1, [r5, #4]
 2504 0080 2000     		movs	r0, r4
 2505 0082 FFF7FEFF 		bl	I2C_MasterStart
 2506              	.LVL262:
 2507 0086 0600     		movs	r6, r0
 2508              	.LVL263:
 2509 0088 D8E7     		b	.L199
 2510              	.LVL264:
 2511              	.L201:
1115:../drivers/fsl_i2c.c ****     {
 2512              		.loc 1 1115 0
 2513 008a 2B7B     		ldrb	r3, [r5, #12]
 2514 008c 002B     		cmp	r3, #0
 2515 008e 1AD0     		beq	.L203
 2516              	.L206:
1120:../drivers/fsl_i2c.c **** 
 2517              		.loc 1 1120 0
 2518 0090 0223     		movs	r3, #2
 2519 0092 E370     		strb	r3, [r4, #3]
1122:../drivers/fsl_i2c.c ****             base->D = ((xfer->subaddress) >> (8 * xfer->subaddressSize));
 2520              		.loc 1 1122 0
 2521 0094 2B7B     		ldrb	r3, [r5, #12]
 2522 0096 013B     		subs	r3, r3, #1
 2523 0098 DBB2     		uxtb	r3, r3
 2524 009a 2B73     		strb	r3, [r5, #12]
1123:../drivers/fsl_i2c.c **** 
 2525              		.loc 1 1123 0
 2526 009c DB00     		lsls	r3, r3, #3
 2527 009e AA68     		ldr	r2, [r5, #8]
 2528 00a0 DA40     		lsrs	r2, r2, r3
 2529 00a2 D3B2     		uxtb	r3, r2
 2530 00a4 2371     		strb	r3, [r4, #4]
 2531              	.L204:
1137:../drivers/fsl_i2c.c ****             {
 2532              		.loc 1 1137 0 discriminator 1
 2533 00a6 E378     		ldrb	r3, [r4, #3]
 2534 00a8 9B07     		lsls	r3, r3, #30
 2535 00aa FCD5     		bpl	.L204
1143:../drivers/fsl_i2c.c **** 
 2536              		.loc 1 1143 0
 2537 00ac E178     		ldrb	r1, [r4, #3]
 2538 00ae C9B2     		uxtb	r1, r1
 2539 00b0 2000     		movs	r0, r4
 2540 00b2 FFF7FEFF 		bl	I2C_CheckAndClearError
 2541              	.LVL265:
 2542 00b6 061E     		subs	r6, r0, #0
 2543              	.LVL266:
1145:../drivers/fsl_i2c.c ****             {
 2544              		.loc 1 1145 0
 2545 00b8 10D1     		bne	.L212
1155:../drivers/fsl_i2c.c **** 
 2546              		.loc 1 1155 0
 2547 00ba 2B7B     		ldrb	r3, [r5, #12]
 2548 00bc 002B     		cmp	r3, #0
 2549 00be E7D1     		bne	.L206
1157:../drivers/fsl_i2c.c ****         {
 2550              		.loc 1 1157 0
 2551 00c0 6B79     		ldrb	r3, [r5, #5]
 2552 00c2 012B     		cmp	r3, #1
 2553 00c4 11D0     		beq	.L213
 2554              	.LVL267:
 2555              	.L203:
1206:../drivers/fsl_i2c.c ****     {
 2556              		.loc 1 1206 0
 2557 00c6 6B79     		ldrb	r3, [r5, #5]
 2558 00c8 002B     		cmp	r3, #0
 2559 00ca 02D1     		bne	.L208
1206:../drivers/fsl_i2c.c ****     {
 2560              		.loc 1 1206 0 is_stmt 0 discriminator 1
 2561 00cc 6B69     		ldr	r3, [r5, #20]
 2562 00ce 002B     		cmp	r3, #0
 2563 00d0 26D1     		bne	.L214
 2564              	.L208:
1213:../drivers/fsl_i2c.c ****     {
 2565              		.loc 1 1213 0 is_stmt 1
 2566 00d2 6B79     		ldrb	r3, [r5, #5]
 2567 00d4 012B     		cmp	r3, #1
 2568 00d6 2BD0     		beq	.L215
 2569              	.LVL268:
 2570              	.L194:
1219:../drivers/fsl_i2c.c **** 
 2571              		.loc 1 1219 0
 2572 00d8 3000     		movs	r0, r6
 2573              		@ sp needed
 2574              	.LVL269:
 2575              	.LVL270:
 2576 00da 70BD     		pop	{r4, r5, r6, pc}
 2577              	.LVL271:
 2578              	.L212:
1147:../drivers/fsl_i2c.c ****                 {
 2579              		.loc 1 1147 0
 2580 00dc 1B4B     		ldr	r3, .L216
 2581 00de 9842     		cmp	r0, r3
 2582 00e0 FAD1     		bne	.L194
1149:../drivers/fsl_i2c.c ****                 }
 2583              		.loc 1 1149 0
 2584 00e2 2000     		movs	r0, r4
 2585              	.LVL272:
 2586 00e4 FFF7FEFF 		bl	I2C_MasterStop
 2587              	.LVL273:
 2588 00e8 F6E7     		b	.L194
 2589              	.LVL274:
 2590              	.L213:
1160:../drivers/fsl_i2c.c **** 
 2591              		.loc 1 1160 0
 2592 00ea 0133     		adds	r3, r3, #1
 2593 00ec E370     		strb	r3, [r4, #3]
1163:../drivers/fsl_i2c.c **** 
 2594              		.loc 1 1163 0
 2595 00ee 2979     		ldrb	r1, [r5, #4]
 2596 00f0 0122     		movs	r2, #1
 2597 00f2 2000     		movs	r0, r4
 2598              	.LVL275:
 2599 00f4 FFF7FEFF 		bl	I2C_MasterRepeatedStart
 2600              	.LVL276:
 2601 00f8 061E     		subs	r6, r0, #0
 2602              	.LVL277:
1166:../drivers/fsl_i2c.c ****             {
 2603              		.loc 1 1166 0
 2604 00fa EDD1     		bne	.L194
 2605              	.L207:
1183:../drivers/fsl_i2c.c ****             {
 2606              		.loc 1 1183 0 discriminator 1
 2607 00fc E378     		ldrb	r3, [r4, #3]
 2608 00fe 9B07     		lsls	r3, r3, #30
 2609 0100 FCD5     		bpl	.L207
1189:../drivers/fsl_i2c.c **** 
 2610              		.loc 1 1189 0
 2611 0102 E178     		ldrb	r1, [r4, #3]
 2612 0104 C9B2     		uxtb	r1, r1
 2613 0106 2000     		movs	r0, r4
 2614              	.LVL278:
 2615 0108 FFF7FEFF 		bl	I2C_CheckAndClearError
 2616              	.LVL279:
 2617 010c 061E     		subs	r6, r0, #0
 2618              	.LVL280:
1191:../drivers/fsl_i2c.c ****             {
 2619              		.loc 1 1191 0
 2620 010e DAD0     		beq	.L203
1193:../drivers/fsl_i2c.c ****                 {
 2621              		.loc 1 1193 0
 2622 0110 0E4B     		ldr	r3, .L216
 2623 0112 9842     		cmp	r0, r3
 2624 0114 E0D1     		bne	.L194
 2625              	.LVL281:
1197:../drivers/fsl_i2c.c ****                 }
 2626              		.loc 1 1197 0
 2627 0116 2000     		movs	r0, r4
 2628 0118 FFF7FEFF 		bl	I2C_MasterStop
 2629              	.LVL282:
1195:../drivers/fsl_i2c.c **** 
 2630              		.loc 1 1195 0
 2631 011c 0C4E     		ldr	r6, .L216+4
 2632 011e DBE7     		b	.L194
 2633              	.LVL283:
 2634              	.L214:
1209:../drivers/fsl_i2c.c ****     }
 2635              		.loc 1 1209 0
 2636 0120 2969     		ldr	r1, [r5, #16]
 2637 0122 6A69     		ldr	r2, [r5, #20]
 2638 0124 2B68     		ldr	r3, [r5]
 2639 0126 2000     		movs	r0, r4
 2640 0128 FFF7FEFF 		bl	I2C_MasterWriteBlocking
 2641              	.LVL284:
 2642 012c 0600     		movs	r6, r0
 2643              	.LVL285:
 2644 012e D0E7     		b	.L208
 2645              	.LVL286:
 2646              	.L215:
1213:../drivers/fsl_i2c.c ****     {
 2647              		.loc 1 1213 0 discriminator 1
 2648 0130 6B69     		ldr	r3, [r5, #20]
 2649 0132 002B     		cmp	r3, #0
 2650 0134 D0D0     		beq	.L194
1215:../drivers/fsl_i2c.c ****     }
 2651              		.loc 1 1215 0
 2652 0136 2969     		ldr	r1, [r5, #16]
 2653 0138 6A69     		ldr	r2, [r5, #20]
 2654 013a 2B68     		ldr	r3, [r5]
 2655 013c 2000     		movs	r0, r4
 2656 013e FFF7FEFF 		bl	I2C_MasterReadBlocking
 2657              	.LVL287:
 2658 0142 0600     		movs	r6, r0
 2659              	.LVL288:
 2660 0144 C8E7     		b	.L194
 2661              	.LVL289:
 2662              	.L210:
1060:../drivers/fsl_i2c.c ****         }
 2663              		.loc 1 1060 0
 2664 0146 0426     		movs	r6, #4
 2665 0148 C6E7     		b	.L194
 2666              	.L217:
 2667 014a C046     		.align	2
 2668              	.L216:
 2669 014c 4E040000 		.word	1102
 2670 0150 51040000 		.word	1105
 2671              		.cfi_endproc
 2672              	.LFE77:
 2674              		.section	.text.I2C_MasterTransferCreateHandle,"ax",%progbits
 2675              		.align	1
 2676              		.global	I2C_MasterTransferCreateHandle
 2677              		.syntax unified
 2678              		.code	16
 2679              		.thumb_func
 2680              		.fpu softvfp
 2682              	I2C_MasterTransferCreateHandle:
 2683              	.LFB78:
1225:../drivers/fsl_i2c.c ****     assert(handle);
 2684              		.loc 1 1225 0
 2685              		.cfi_startproc
 2686              		@ args = 0, pretend = 0, frame = 0
 2687              		@ frame_needed = 0, uses_anonymous_args = 0
 2688              	.LVL290:
 2689 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2690              		.cfi_def_cfa_offset 24
 2691              		.cfi_offset 3, -24
 2692              		.cfi_offset 4, -20
 2693              		.cfi_offset 5, -16
 2694              		.cfi_offset 6, -12
 2695              		.cfi_offset 7, -8
 2696              		.cfi_offset 14, -4
 2697 0002 0C00     		movs	r4, r1
 2698 0004 1700     		movs	r7, r2
 2699 0006 1E00     		movs	r6, r3
1228:../drivers/fsl_i2c.c **** 
 2700              		.loc 1 1228 0
 2701 0008 FFF7FEFF 		bl	I2C_GetInstance
 2702              	.LVL291:
 2703 000c 0500     		movs	r5, r0
 2704              	.LVL292:
1231:../drivers/fsl_i2c.c **** 
 2705              		.loc 1 1231 0
 2706 000e 2022     		movs	r2, #32
 2707 0010 0021     		movs	r1, #0
 2708 0012 2000     		movs	r0, r4
 2709              	.LVL293:
 2710 0014 FFF7FEFF 		bl	memset
 2711              	.LVL294:
1234:../drivers/fsl_i2c.c ****     handle->userData = userData;
 2712              		.loc 1 1234 0
 2713 0018 2762     		str	r7, [r4, #32]
1235:../drivers/fsl_i2c.c **** 
 2714              		.loc 1 1235 0
 2715 001a 6662     		str	r6, [r4, #36]
1238:../drivers/fsl_i2c.c **** 
 2716              		.loc 1 1238 0
 2717 001c AA00     		lsls	r2, r5, #2
 2718 001e 0A4B     		ldr	r3, .L220
 2719 0020 D450     		str	r4, [r2, r3]
1241:../drivers/fsl_i2c.c **** 
 2720              		.loc 1 1241 0
 2721 0022 0A4B     		ldr	r3, .L220+4
 2722 0024 0A4A     		ldr	r2, .L220+8
 2723 0026 1A60     		str	r2, [r3]
1244:../drivers/fsl_i2c.c **** }
 2724              		.loc 1 1244 0
 2725 0028 0A4B     		ldr	r3, .L220+12
 2726 002a 5B57     		ldrsb	r3, [r3, r5]
 2727              	.LVL295:
 2728              	.LBB66:
 2729              	.LBB67:
 2730              		.file 5 "../drivers/fsl_common.h"
   1:../drivers/fsl_common.h **** /*
   2:../drivers/fsl_common.h ****  * The Clear BSD License
   3:../drivers/fsl_common.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_common.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_common.h ****  * All rights reserved.
   6:../drivers/fsl_common.h ****  *
   7:../drivers/fsl_common.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_common.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_common.h ****  * that the following conditions are met:
  10:../drivers/fsl_common.h ****  *
  11:../drivers/fsl_common.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_common.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_common.h ****  *
  14:../drivers/fsl_common.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_common.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_common.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_common.h ****  *
  18:../drivers/fsl_common.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_common.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_common.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_common.h ****  *
  22:../drivers/fsl_common.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_common.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_common.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_common.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_common.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_common.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_common.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_common.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_common.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_common.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_common.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_common.h ****  */
  34:../drivers/fsl_common.h **** 
  35:../drivers/fsl_common.h **** #ifndef _FSL_COMMON_H_
  36:../drivers/fsl_common.h **** #define _FSL_COMMON_H_
  37:../drivers/fsl_common.h **** 
  38:../drivers/fsl_common.h **** #include <assert.h>
  39:../drivers/fsl_common.h **** #include <stdbool.h>
  40:../drivers/fsl_common.h **** #include <stdint.h>
  41:../drivers/fsl_common.h **** #include <string.h>
  42:../drivers/fsl_common.h **** 
  43:../drivers/fsl_common.h **** #if defined(__ICCARM__)
  44:../drivers/fsl_common.h **** #include <stddef.h>
  45:../drivers/fsl_common.h **** #endif
  46:../drivers/fsl_common.h **** 
  47:../drivers/fsl_common.h **** #include "fsl_device_registers.h"
  48:../drivers/fsl_common.h **** 
  49:../drivers/fsl_common.h **** /*!
  50:../drivers/fsl_common.h ****  * @addtogroup ksdk_common
  51:../drivers/fsl_common.h ****  * @{
  52:../drivers/fsl_common.h ****  */
  53:../drivers/fsl_common.h **** 
  54:../drivers/fsl_common.h **** /*******************************************************************************
  55:../drivers/fsl_common.h ****  * Definitions
  56:../drivers/fsl_common.h ****  ******************************************************************************/
  57:../drivers/fsl_common.h **** 
  58:../drivers/fsl_common.h **** /*! @brief Construct a status code value from a group and code number. */
  59:../drivers/fsl_common.h **** #define MAKE_STATUS(group, code) ((((group)*100) + (code)))
  60:../drivers/fsl_common.h **** 
  61:../drivers/fsl_common.h **** /*! @brief Construct the version number for drivers. */
  62:../drivers/fsl_common.h **** #define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
  63:../drivers/fsl_common.h **** 
  64:../drivers/fsl_common.h **** /*! @name Driver version */
  65:../drivers/fsl_common.h **** /*@{*/
  66:../drivers/fsl_common.h **** /*! @brief common driver version 2.0.0. */
  67:../drivers/fsl_common.h **** #define FSL_COMMON_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
  68:../drivers/fsl_common.h **** /*@}*/
  69:../drivers/fsl_common.h **** 
  70:../drivers/fsl_common.h **** /* Debug console type definition. */
  71:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
  72:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
  73:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
  74:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
  75:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
  76:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
  77:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_IUART 6U    /*!< Debug console base on i.MX UART. */
  78:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_VUSART 7U   /*!< Debug console base on LPC_USART. */
  79:../drivers/fsl_common.h **** 
  80:../drivers/fsl_common.h **** /*! @brief Status group numbers. */
  81:../drivers/fsl_common.h **** enum _status_groups
  82:../drivers/fsl_common.h **** {
  83:../drivers/fsl_common.h ****     kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
  84:../drivers/fsl_common.h ****     kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
  85:../drivers/fsl_common.h ****     kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
  86:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
  87:../drivers/fsl_common.h ****     kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
  88:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
  89:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
  90:../drivers/fsl_common.h ****     kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
  91:../drivers/fsl_common.h ****     kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
  92:../drivers/fsl_common.h ****     kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
  93:../drivers/fsl_common.h ****     kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
  94:../drivers/fsl_common.h ****     kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
  95:../drivers/fsl_common.h ****     kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
  96:../drivers/fsl_common.h ****     kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
  97:../drivers/fsl_common.h ****     kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
  98:../drivers/fsl_common.h ****     kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
  99:../drivers/fsl_common.h ****     kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
 100:../drivers/fsl_common.h ****     kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
 101:../drivers/fsl_common.h ****     kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
 102:../drivers/fsl_common.h ****     kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
 103:../drivers/fsl_common.h ****     kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
 104:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
 105:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_MCULCD = 24,          /*!< Group number for FLEXIO LCD status codes */
 106:../drivers/fsl_common.h ****     kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
 107:../drivers/fsl_common.h ****     kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
 108:../drivers/fsl_common.h ****     kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
 109:../drivers/fsl_common.h ****     kStatusGroup_IUART = 28,                  /*!< Group number for IUART status codes */
 110:../drivers/fsl_common.h ****     kStatusGroup_CSI = 29,                    /*!< Group number for CSI status codes */
 111:../drivers/fsl_common.h ****     kStatusGroup_MIPI_DSI = 30,               /*!< Group number for MIPI DSI status codes */
 112:../drivers/fsl_common.h ****     kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
 113:../drivers/fsl_common.h ****     kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
 114:../drivers/fsl_common.h ****     kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
 115:../drivers/fsl_common.h ****     kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
 116:../drivers/fsl_common.h ****     kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
 117:../drivers/fsl_common.h ****     kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
 118:../drivers/fsl_common.h ****     kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
 119:../drivers/fsl_common.h ****     kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
 120:../drivers/fsl_common.h ****     kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
 121:../drivers/fsl_common.h ****     kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
 122:../drivers/fsl_common.h ****     kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
 123:../drivers/fsl_common.h ****     kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
 124:../drivers/fsl_common.h ****     kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
 125:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
 126:../drivers/fsl_common.h ****     kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
 127:../drivers/fsl_common.h ****     kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
 128:../drivers/fsl_common.h ****     kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
 129:../drivers/fsl_common.h ****     kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
 130:../drivers/fsl_common.h ****     kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
 131:../drivers/fsl_common.h ****     kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
 132:../drivers/fsl_common.h ****     kStatusGroup_MCAN = 62,                   /*!< Group number for MCAN status codes. */
 133:../drivers/fsl_common.h ****     kStatusGroup_CAAM = 63,                   /*!< Group number for CAAM status codes. */
 134:../drivers/fsl_common.h ****     kStatusGroup_ECSPI = 64,                  /*!< Group number for ECSPI status codes. */
 135:../drivers/fsl_common.h ****     kStatusGroup_USDHC = 65,                  /*!< Group number for USDHC status codes.*/
 136:../drivers/fsl_common.h ****     kStatusGroup_LPC_I2C = 66,                /*!< Group number for LPC_I2C status codes.*/
 137:../drivers/fsl_common.h ****     kStatusGroup_DCP = 67,                    /*!< Group number for DCP status codes.*/
 138:../drivers/fsl_common.h ****     kStatusGroup_MSCAN = 68,                  /*!< Group number for MSCAN status codes.*/
 139:../drivers/fsl_common.h ****     kStatusGroup_ESAI = 69,                   /*!< Group number for ESAI status codes. */
 140:../drivers/fsl_common.h ****     kStatusGroup_FLEXSPI = 70,                /*!< Group number for FLEXSPI status codes. */
 141:../drivers/fsl_common.h ****     kStatusGroup_MMDC = 71,                   /*!< Group number for MMDC status codes. */
 142:../drivers/fsl_common.h ****     kStatusGroup_MICFIL = 72,                 /*!< Group number for MIC status codes. */
 143:../drivers/fsl_common.h ****     kStatusGroup_SDMA = 73,                   /*!< Group number for SDMA status codes. */
 144:../drivers/fsl_common.h ****     kStatusGroup_ICS = 74,                    /*!< Group number for ICS status codes. */
 145:../drivers/fsl_common.h ****     kStatusGroup_SPDIF = 75,                  /*!< Group number for SPDIF status codes. */
 146:../drivers/fsl_common.h ****     kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
 147:../drivers/fsl_common.h ****     kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
 148:../drivers/fsl_common.h ****     kStatusGroup_SEMC = 100,                   /*!< Group number for SEMC status codes. */    
 149:../drivers/fsl_common.h ****     kStatusGroup_ApplicationRangeStart = 101, /*!< Starting number for application groups. */
 150:../drivers/fsl_common.h **** };
 151:../drivers/fsl_common.h **** 
 152:../drivers/fsl_common.h **** /*! @brief Generic status return codes. */
 153:../drivers/fsl_common.h **** enum _generic_status
 154:../drivers/fsl_common.h **** {
 155:../drivers/fsl_common.h ****     kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
 156:../drivers/fsl_common.h ****     kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
 157:../drivers/fsl_common.h ****     kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
 158:../drivers/fsl_common.h ****     kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
 159:../drivers/fsl_common.h ****     kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
 160:../drivers/fsl_common.h ****     kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
 161:../drivers/fsl_common.h ****     kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
 162:../drivers/fsl_common.h **** };
 163:../drivers/fsl_common.h **** 
 164:../drivers/fsl_common.h **** /*! @brief Type used for all status and error return values. */
 165:../drivers/fsl_common.h **** typedef int32_t status_t;
 166:../drivers/fsl_common.h **** 
 167:../drivers/fsl_common.h **** /*
 168:../drivers/fsl_common.h ****  * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
 169:../drivers/fsl_common.h ****  * defined in previous of this file.
 170:../drivers/fsl_common.h ****  */
 171:../drivers/fsl_common.h **** #include "fsl_clock.h"
 172:../drivers/fsl_common.h **** 
 173:../drivers/fsl_common.h **** /*
 174:../drivers/fsl_common.h ****  * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a 
 175:../drivers/fsl_common.h ****  */
 176:../drivers/fsl_common.h **** #if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
 177:../drivers/fsl_common.h ****      (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
 178:../drivers/fsl_common.h **** #include "fsl_reset.h"
 179:../drivers/fsl_common.h **** #endif
 180:../drivers/fsl_common.h **** 
 181:../drivers/fsl_common.h **** /*! @name Min/max macros */
 182:../drivers/fsl_common.h **** /* @{ */
 183:../drivers/fsl_common.h **** #if !defined(MIN)
 184:../drivers/fsl_common.h **** #define MIN(a, b) ((a) < (b) ? (a) : (b))
 185:../drivers/fsl_common.h **** #endif
 186:../drivers/fsl_common.h **** 
 187:../drivers/fsl_common.h **** #if !defined(MAX)
 188:../drivers/fsl_common.h **** #define MAX(a, b) ((a) > (b) ? (a) : (b))
 189:../drivers/fsl_common.h **** #endif
 190:../drivers/fsl_common.h **** /* @} */
 191:../drivers/fsl_common.h **** 
 192:../drivers/fsl_common.h **** /*! @brief Computes the number of elements in an array. */
 193:../drivers/fsl_common.h **** #if !defined(ARRAY_SIZE)
 194:../drivers/fsl_common.h **** #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 195:../drivers/fsl_common.h **** #endif
 196:../drivers/fsl_common.h **** 
 197:../drivers/fsl_common.h **** /*! @name UINT16_MAX/UINT32_MAX value */
 198:../drivers/fsl_common.h **** /* @{ */
 199:../drivers/fsl_common.h **** #if !defined(UINT16_MAX)
 200:../drivers/fsl_common.h **** #define UINT16_MAX ((uint16_t)-1)
 201:../drivers/fsl_common.h **** #endif
 202:../drivers/fsl_common.h **** 
 203:../drivers/fsl_common.h **** #if !defined(UINT32_MAX)
 204:../drivers/fsl_common.h **** #define UINT32_MAX ((uint32_t)-1)
 205:../drivers/fsl_common.h **** #endif
 206:../drivers/fsl_common.h **** /* @} */
 207:../drivers/fsl_common.h **** 
 208:../drivers/fsl_common.h **** /*! @name Timer utilities */
 209:../drivers/fsl_common.h **** /* @{ */
 210:../drivers/fsl_common.h **** /*! Macro to convert a microsecond period to raw count value */
 211:../drivers/fsl_common.h **** #define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
 212:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to microsecond */
 213:../drivers/fsl_common.h **** #define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
 214:../drivers/fsl_common.h **** 
 215:../drivers/fsl_common.h **** /*! Macro to convert a millisecond period to raw count value */
 216:../drivers/fsl_common.h **** #define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
 217:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to millisecond */
 218:../drivers/fsl_common.h **** #define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
 219:../drivers/fsl_common.h **** /* @} */
 220:../drivers/fsl_common.h **** 
 221:../drivers/fsl_common.h **** /*! @name Alignment variable definition macros */
 222:../drivers/fsl_common.h **** /* @{ */
 223:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 224:../drivers/fsl_common.h **** /**
 225:../drivers/fsl_common.h ****  * Workaround to disable MISRA C message suppress warnings for IAR compiler.
 226:../drivers/fsl_common.h ****  * http://supp.iar.com/Support/?note=24725
 227:../drivers/fsl_common.h ****  */
 228:../drivers/fsl_common.h **** _Pragma("diag_suppress=Pm120")
 229:../drivers/fsl_common.h **** #define SDK_PRAGMA(x) _Pragma(#x)
 230:../drivers/fsl_common.h ****     _Pragma("diag_error=Pm120")
 231:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 232:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 233:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 234:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 235:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 236:../drivers/fsl_common.h **** #endif
 237:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 238:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 239:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 240:../drivers/fsl_common.h **** #endif
 241:../drivers/fsl_common.h **** #elif defined(__ARMCC_VERSION)
 242:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 243:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) __align(alignbytes) var
 244:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 245:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 246:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) __align(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 247:../drivers/fsl_common.h **** #endif
 248:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 249:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 250:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) __align(FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 251:../drivers/fsl_common.h **** #endif
 252:../drivers/fsl_common.h **** #elif defined(__GNUC__)
 253:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 254:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 255:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 256:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 257:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)))
 258:../drivers/fsl_common.h **** #endif
 259:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 260:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 261:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)))
 262:../drivers/fsl_common.h **** #endif
 263:../drivers/fsl_common.h **** #else
 264:../drivers/fsl_common.h **** #error Toolchain not supported
 265:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var
 266:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 267:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var
 268:../drivers/fsl_common.h **** #endif
 269:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 270:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var
 271:../drivers/fsl_common.h **** #endif
 272:../drivers/fsl_common.h **** #endif
 273:../drivers/fsl_common.h **** 
 274:../drivers/fsl_common.h **** /*! Macro to change a value to a given size aligned value */
 275:../drivers/fsl_common.h **** #define SDK_SIZEALIGN(var, alignbytes) \
 276:../drivers/fsl_common.h ****     ((unsigned int)((var) + ((alignbytes)-1)) & (unsigned int)(~(unsigned int)((alignbytes)-1)))
 277:../drivers/fsl_common.h **** /* @} */
 278:../drivers/fsl_common.h **** 
 279:../drivers/fsl_common.h **** /*! @name Non-cacheable region definition macros */
 280:../drivers/fsl_common.h **** /* For initialized non-zero non-cacheable variables, please using "AT_NONCACHEABLE_SECTION_INIT(var
 281:../drivers/fsl_common.h ****  * "AT_NONCACHEABLE_SECTION_ALIGN_INIT(var) ={xx};" in your projects to define them, for zero-inite
 282:../drivers/fsl_common.h ****  * please using "AT_NONCACHEABLE_SECTION(var);" or "AT_NONCACHEABLE_SECTION_ALIGN(var);" to define 
 283:../drivers/fsl_common.h ****  * will be initialized to zero in system startup.
 284:../drivers/fsl_common.h ****  */
 285:../drivers/fsl_common.h **** /* @{ */
 286:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 287:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 288:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var @"NonCacheable"
 289:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var 
 290:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var @"NonCacheable.init"
 291:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 292:../drivers/fsl_common.h **** #else
 293:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 294:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 295:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 296:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 297:../drivers/fsl_common.h **** #endif
 298:../drivers/fsl_common.h **** #elif(defined(__ARMCC_VERSION))
 299:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 300:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable"), zero_init)) var
 301:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 302:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable"), zero_init)) __align(alignbytes) var
 303:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 304:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 305:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) __align(alignbytes) var
 306:../drivers/fsl_common.h **** #else
 307:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 308:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) __align(alignbytes) var
 309:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 310:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) __align(alignbytes) var
 311:../drivers/fsl_common.h **** #endif
 312:../drivers/fsl_common.h **** #elif(defined(__GNUC__))
 313:../drivers/fsl_common.h **** /* For GCC, when the non-cacheable section is required, please define "__STARTUP_INITIALIZE_NONCACH
 314:../drivers/fsl_common.h ****  * in your projects to make sure the non-cacheable section variables will be initialized in system 
 315:../drivers/fsl_common.h ****  */
 316:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 317:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 318:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 319:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) var __attribute__((aligned(alignbytes)))
 320:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var
 321:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 322:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var __attribute__((aligned(alignbytes
 323:../drivers/fsl_common.h **** #else
 324:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 325:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 326:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 327:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var __attribute__((aligned(alignbytes))
 328:../drivers/fsl_common.h **** #endif
 329:../drivers/fsl_common.h **** #else
 330:../drivers/fsl_common.h **** #error Toolchain not supported.
 331:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 332:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var
 333:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 334:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var
 335:../drivers/fsl_common.h **** #endif
 336:../drivers/fsl_common.h **** /* @} */
 337:../drivers/fsl_common.h **** 
 338:../drivers/fsl_common.h **** /*******************************************************************************
 339:../drivers/fsl_common.h ****  * API
 340:../drivers/fsl_common.h ****  ******************************************************************************/
 341:../drivers/fsl_common.h **** 
 342:../drivers/fsl_common.h **** #if defined(__cplusplus)
 343:../drivers/fsl_common.h ****         extern "C"
 344:../drivers/fsl_common.h **** {
 345:../drivers/fsl_common.h **** #endif
 346:../drivers/fsl_common.h **** 
 347:../drivers/fsl_common.h ****     /*!
 348:../drivers/fsl_common.h ****      * @brief Enable specific interrupt.
 349:../drivers/fsl_common.h ****      *
 350:../drivers/fsl_common.h ****      * Enable LEVEL1 interrupt. For some devices, there might be multiple interrupt
 351:../drivers/fsl_common.h ****      * levels. For example, there are NVIC and intmux. Here the interrupts connected
 352:../drivers/fsl_common.h ****      * to NVIC are the LEVEL1 interrupts, because they are routed to the core directly.
 353:../drivers/fsl_common.h ****      * The interrupts connected to intmux are the LEVEL2 interrupts, they are routed
 354:../drivers/fsl_common.h ****      * to NVIC first then routed to core.
 355:../drivers/fsl_common.h ****      *
 356:../drivers/fsl_common.h ****      * This function only enables the LEVEL1 interrupts. The number of LEVEL1 interrupts
 357:../drivers/fsl_common.h ****      * is indicated by the feature macro FSL_FEATURE_NUMBER_OF_LEVEL1_INT_VECTORS.
 358:../drivers/fsl_common.h ****      *
 359:../drivers/fsl_common.h ****      * @param interrupt The IRQ number.
 360:../drivers/fsl_common.h ****      * @retval kStatus_Success Interrupt enabled successfully
 361:../drivers/fsl_common.h ****      * @retval kStatus_Fail Failed to enable the interrupt
 362:../drivers/fsl_common.h ****      */
 363:../drivers/fsl_common.h ****     static inline status_t EnableIRQ(IRQn_Type interrupt)
 364:../drivers/fsl_common.h ****     {
 365:../drivers/fsl_common.h ****         if (NotAvail_IRQn == interrupt)
 2731              		.loc 5 365 0
 2732 002c 1A00     		movs	r2, r3
 2733 002e 8032     		adds	r2, r2, #128
 2734 0030 08D0     		beq	.L218
 2735              	.LVL296:
 2736              	.LBB68:
 2737              	.LBB69:
 2738              		.file 6 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 2739              		.loc 6 733 0
 2740 0032 002B     		cmp	r3, #0
 2741 0034 06DB     		blt	.L218
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 2742              		.loc 6 735 0
 2743 0036 1F22     		movs	r2, #31
 2744 0038 1340     		ands	r3, r2
 2745              	.LVL297:
 2746 003a 1E3A     		subs	r2, r2, #30
 2747 003c 9A40     		lsls	r2, r2, r3
 2748 003e 1300     		movs	r3, r2
 2749 0040 054A     		ldr	r2, .L220+16
 2750 0042 1360     		str	r3, [r2]
 2751              	.LVL298:
 2752              	.L218:
 2753              	.LBE69:
 2754              	.LBE68:
 2755              	.LBE67:
 2756              	.LBE66:
1245:../drivers/fsl_i2c.c **** 
 2757              		.loc 1 1245 0
 2758              		@ sp needed
 2759              	.LVL299:
 2760              	.LVL300:
 2761              	.LVL301:
 2762              	.LVL302:
 2763 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2764              	.L221:
 2765 0046 C046     		.align	2
 2766              	.L220:
 2767 0048 00000000 		.word	.LANCHOR4
 2768 004c 00000000 		.word	.LANCHOR0
 2769 0050 00000000 		.word	I2C_MasterTransferHandleIRQ
 2770 0054 00000000 		.word	.LANCHOR5
 2771 0058 00E100E0 		.word	-536813312
 2772              		.cfi_endproc
 2773              	.LFE78:
 2775              		.section	.text.I2C_MasterTransferNonBlocking,"ax",%progbits
 2776              		.align	1
 2777              		.global	I2C_MasterTransferNonBlocking
 2778              		.syntax unified
 2779              		.code	16
 2780              		.thumb_func
 2781              		.fpu softvfp
 2783              	I2C_MasterTransferNonBlocking:
 2784              	.LFB79:
1248:../drivers/fsl_i2c.c ****     assert(handle);
 2785              		.loc 1 1248 0
 2786              		.cfi_startproc
 2787              		@ args = 0, pretend = 0, frame = 0
 2788              		@ frame_needed = 0, uses_anonymous_args = 0
 2789              	.LVL303:
 2790 0000 70B5     		push	{r4, r5, r6, lr}
 2791              		.cfi_def_cfa_offset 16
 2792              		.cfi_offset 4, -16
 2793              		.cfi_offset 5, -12
 2794              		.cfi_offset 6, -8
 2795              		.cfi_offset 14, -4
 2796 0002 0500     		movs	r5, r0
 2797              	.LVL304:
1255:../drivers/fsl_i2c.c ****     {
 2798              		.loc 1 1255 0
 2799 0004 0B7F     		ldrb	r3, [r1, #28]
 2800 0006 002B     		cmp	r3, #0
 2801 0008 08D1     		bne	.L224
1262:../drivers/fsl_i2c.c **** 
 2802              		.loc 1 1262 0
 2803 000a FFF7FEFF 		bl	I2C_InitTransferStateMachine
 2804              	.LVL305:
 2805 000e 041E     		subs	r4, r0, #0
 2806              	.LVL306:
1264:../drivers/fsl_i2c.c ****         {
 2807              		.loc 1 1264 0
 2808 0010 05D1     		bne	.L222
1267:../drivers/fsl_i2c.c ****         }
 2809              		.loc 1 1267 0
 2810 0012 4021     		movs	r1, #64
 2811 0014 2800     		movs	r0, r5
 2812              	.LVL307:
 2813 0016 FFF7FEFF 		bl	I2C_EnableInterrupts
 2814              	.LVL308:
 2815 001a 00E0     		b	.L222
 2816              	.LVL309:
 2817              	.L224:
1257:../drivers/fsl_i2c.c ****     }
 2818              		.loc 1 1257 0
 2819 001c 014C     		ldr	r4, .L225
 2820              	.LVL310:
 2821              	.L222:
1272:../drivers/fsl_i2c.c **** 
 2822              		.loc 1 1272 0
 2823 001e 2000     		movs	r0, r4
 2824              		@ sp needed
 2825              	.LVL311:
 2826 0020 70BD     		pop	{r4, r5, r6, pc}
 2827              	.L226:
 2828 0022 C046     		.align	2
 2829              	.L225:
 2830 0024 4C040000 		.word	1100
 2831              		.cfi_endproc
 2832              	.LFE79:
 2834              		.section	.text.I2C_MasterTransferAbort,"ax",%progbits
 2835              		.align	1
 2836              		.global	I2C_MasterTransferAbort
 2837              		.syntax unified
 2838              		.code	16
 2839              		.thumb_func
 2840              		.fpu softvfp
 2842              	I2C_MasterTransferAbort:
 2843              	.LFB80:
1275:../drivers/fsl_i2c.c ****     assert(handle);
 2844              		.loc 1 1275 0
 2845              		.cfi_startproc
 2846              		@ args = 0, pretend = 0, frame = 8
 2847              		@ frame_needed = 0, uses_anonymous_args = 0
 2848              	.LVL312:
 2849 0000 70B5     		push	{r4, r5, r6, lr}
 2850              		.cfi_def_cfa_offset 16
 2851              		.cfi_offset 4, -16
 2852              		.cfi_offset 5, -12
 2853              		.cfi_offset 6, -8
 2854              		.cfi_offset 14, -4
 2855 0002 82B0     		sub	sp, sp, #8
 2856              		.cfi_def_cfa_offset 24
 2857 0004 0400     		movs	r4, r0
 2858 0006 0E00     		movs	r6, r1
1278:../drivers/fsl_i2c.c **** #if I2C_WAIT_TIMEOUT
 2859              		.loc 1 1278 0
 2860 0008 6B46     		mov	r3, sp
 2861 000a DA1D     		adds	r2, r3, #7
 2862 000c 0025     		movs	r5, #0
 2863 000e DD71     		strb	r5, [r3, #7]
1284:../drivers/fsl_i2c.c **** 
 2864              		.loc 1 1284 0
 2865 0010 DB79     		ldrb	r3, [r3, #7]
 2866 0012 0133     		adds	r3, r3, #1
 2867 0014 DBB2     		uxtb	r3, r3
 2868 0016 1370     		strb	r3, [r2]
1287:../drivers/fsl_i2c.c **** 
 2869              		.loc 1 1287 0
 2870 0018 4021     		movs	r1, #64
 2871              	.LVL313:
 2872 001a FFF7FEFF 		bl	I2C_DisableInterrupts
 2873              	.LVL314:
1290:../drivers/fsl_i2c.c **** 
 2874              		.loc 1 1290 0
 2875 001e 3577     		strb	r5, [r6, #28]
1293:../drivers/fsl_i2c.c ****     {
 2876              		.loc 1 1293 0
 2877 0020 A378     		ldrb	r3, [r4, #2]
 2878 0022 9B06     		lsls	r3, r3, #26
 2879 0024 21D5     		bpl	.L231
1299:../drivers/fsl_i2c.c ****     {
 2880              		.loc 1 1299 0
 2881 0026 7379     		ldrb	r3, [r6, #5]
 2882 0028 012B     		cmp	r3, #1
 2883 002a 0BD0     		beq	.L232
 2884              	.L229:
1336:../drivers/fsl_i2c.c ****         {
 2885              		.loc 1 1336 0 discriminator 1
 2886 002c E378     		ldrb	r3, [r4, #3]
 2887 002e 9B07     		lsls	r3, r3, #30
 2888 0030 FCD5     		bpl	.L229
1340:../drivers/fsl_i2c.c ****         base->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
 2889              		.loc 1 1340 0
 2890 0032 0223     		movs	r3, #2
 2891 0034 E370     		strb	r3, [r4, #3]
1341:../drivers/fsl_i2c.c ****     }
 2892              		.loc 1 1341 0
 2893 0036 A378     		ldrb	r3, [r4, #2]
 2894 0038 3822     		movs	r2, #56
 2895 003a 9343     		bics	r3, r2
 2896 003c A370     		strb	r3, [r4, #2]
1344:../drivers/fsl_i2c.c **** }
 2897              		.loc 1 1344 0
 2898 003e 0020     		movs	r0, #0
 2899              	.L227:
1345:../drivers/fsl_i2c.c **** 
 2900              		.loc 1 1345 0
 2901 0040 02B0     		add	sp, sp, #8
 2902              		@ sp needed
 2903              	.LVL315:
 2904              	.LVL316:
 2905 0042 70BD     		pop	{r4, r5, r6, pc}
 2906              	.LVL317:
 2907              	.L232:
1301:../drivers/fsl_i2c.c **** 
 2908              		.loc 1 1301 0
 2909 0044 A378     		ldrb	r3, [r4, #2]
 2910 0046 0822     		movs	r2, #8
 2911 0048 1343     		orrs	r3, r2
 2912 004a A370     		strb	r3, [r4, #2]
 2913              	.L230:
1314:../drivers/fsl_i2c.c ****         {
 2914              		.loc 1 1314 0 discriminator 1
 2915 004c E378     		ldrb	r3, [r4, #3]
 2916 004e 9B07     		lsls	r3, r3, #30
 2917 0050 FCD5     		bpl	.L230
1318:../drivers/fsl_i2c.c **** 
 2918              		.loc 1 1318 0
 2919 0052 0223     		movs	r3, #2
 2920 0054 E370     		strb	r3, [r4, #3]
1320:../drivers/fsl_i2c.c ****         dummy = base->D;
 2921              		.loc 1 1320 0
 2922 0056 A378     		ldrb	r3, [r4, #2]
 2923 0058 3822     		movs	r2, #56
 2924 005a 9343     		bics	r3, r2
 2925 005c A370     		strb	r3, [r4, #2]
1321:../drivers/fsl_i2c.c ****     }
 2926              		.loc 1 1321 0
 2927 005e 2379     		ldrb	r3, [r4, #4]
 2928 0060 DBB2     		uxtb	r3, r3
 2929 0062 6A46     		mov	r2, sp
 2930 0064 D371     		strb	r3, [r2, #7]
1344:../drivers/fsl_i2c.c **** }
 2931              		.loc 1 1344 0
 2932 0066 0020     		movs	r0, #0
 2933 0068 EAE7     		b	.L227
 2934              	.L231:
1295:../drivers/fsl_i2c.c ****     }
 2935              		.loc 1 1295 0
 2936 006a 0148     		ldr	r0, .L233
 2937 006c E8E7     		b	.L227
 2938              	.L234:
 2939 006e C046     		.align	2
 2940              	.L233:
 2941 0070 4C040000 		.word	1100
 2942              		.cfi_endproc
 2943              	.LFE80:
 2945              		.section	.text.I2C_MasterTransferGetCount,"ax",%progbits
 2946              		.align	1
 2947              		.global	I2C_MasterTransferGetCount
 2948              		.syntax unified
 2949              		.code	16
 2950              		.thumb_func
 2951              		.fpu softvfp
 2953              	I2C_MasterTransferGetCount:
 2954              	.LFB81:
1348:../drivers/fsl_i2c.c ****     assert(handle);
 2955              		.loc 1 1348 0
 2956              		.cfi_startproc
 2957              		@ args = 0, pretend = 0, frame = 0
 2958              		@ frame_needed = 0, uses_anonymous_args = 0
 2959              		@ link register save eliminated.
 2960              	.LVL318:
1351:../drivers/fsl_i2c.c ****     {
 2961              		.loc 1 1351 0
 2962 0000 002A     		cmp	r2, #0
 2963 0002 05D0     		beq	.L237
1356:../drivers/fsl_i2c.c **** 
 2964              		.loc 1 1356 0
 2965 0004 8B69     		ldr	r3, [r1, #24]
 2966 0006 4969     		ldr	r1, [r1, #20]
 2967              	.LVL319:
 2968 0008 5B1A     		subs	r3, r3, r1
 2969 000a 1360     		str	r3, [r2]
1358:../drivers/fsl_i2c.c **** }
 2970              		.loc 1 1358 0
 2971 000c 0020     		movs	r0, #0
 2972              	.LVL320:
 2973              	.L235:
1359:../drivers/fsl_i2c.c **** 
 2974              		.loc 1 1359 0
 2975              		@ sp needed
 2976 000e 7047     		bx	lr
 2977              	.LVL321:
 2978              	.L237:
1353:../drivers/fsl_i2c.c ****     }
 2979              		.loc 1 1353 0
 2980 0010 0420     		movs	r0, #4
 2981              	.LVL322:
 2982 0012 FCE7     		b	.L235
 2983              		.cfi_endproc
 2984              	.LFE81:
 2986              		.section	.text.I2C_SlaveInit,"ax",%progbits
 2987              		.align	1
 2988              		.global	I2C_SlaveInit
 2989              		.syntax unified
 2990              		.code	16
 2991              		.thumb_func
 2992              		.fpu softvfp
 2994              	I2C_SlaveInit:
 2995              	.LFB83:
1406:../drivers/fsl_i2c.c ****     assert(slaveConfig);
 2996              		.loc 1 1406 0
 2997              		.cfi_startproc
 2998              		@ args = 0, pretend = 0, frame = 0
 2999              		@ frame_needed = 0, uses_anonymous_args = 0
 3000              	.LVL323:
 3001 0000 70B5     		push	{r4, r5, r6, lr}
 3002              		.cfi_def_cfa_offset 16
 3003              		.cfi_offset 4, -16
 3004              		.cfi_offset 5, -12
 3005              		.cfi_offset 6, -8
 3006              		.cfi_offset 14, -4
 3007 0002 0400     		movs	r4, r0
 3008 0004 0E00     		movs	r6, r1
 3009 0006 1500     		movs	r5, r2
1412:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 3010              		.loc 1 1412 0
 3011 0008 FFF7FEFF 		bl	I2C_GetInstance
 3012              	.LVL324:
 3013 000c 8000     		lsls	r0, r0, #2
 3014 000e 284B     		ldr	r3, .L242
 3015 0010 C358     		ldr	r3, [r0, r3]
 3016              	.LVL325:
 3017              	.LBB70:
 3018              	.LBB71:
 449:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 3019              		.loc 4 449 0
 3020 0012 1A0C     		lsrs	r2, r3, #16
 3021 0014 2749     		ldr	r1, .L242+4
 3022 0016 8C46     		mov	ip, r1
 3023 0018 6244     		add	r2, r2, ip
 3024              	.LVL326:
 450:../drivers/fsl_clock.h **** }
 3025              		.loc 4 450 0
 3026 001a 1168     		ldr	r1, [r2]
 3027 001c 1B04     		lsls	r3, r3, #16
 3028              	.LVL327:
 3029 001e 1B0C     		lsrs	r3, r3, #16
 3030 0020 0120     		movs	r0, #1
 3031              	.LVL328:
 3032 0022 9840     		lsls	r0, r0, r3
 3033 0024 0300     		movs	r3, r0
 3034 0026 0B43     		orrs	r3, r1
 3035 0028 1360     		str	r3, [r2]
 3036              	.LVL329:
 3037              	.LBE71:
 3038              	.LBE70:
1416:../drivers/fsl_i2c.c ****     base->F = 0;
 3039              		.loc 1 1416 0
 3040 002a 0023     		movs	r3, #0
 3041 002c 2370     		strb	r3, [r4]
1417:../drivers/fsl_i2c.c ****     base->C1 = 0;
 3042              		.loc 1 1417 0
 3043 002e 6370     		strb	r3, [r4, #1]
1418:../drivers/fsl_i2c.c ****     base->S = 0xFFU;
 3044              		.loc 1 1418 0
 3045 0030 A370     		strb	r3, [r4, #2]
1419:../drivers/fsl_i2c.c ****     base->C2 = 0;
 3046              		.loc 1 1419 0
 3047 0032 FF22     		movs	r2, #255
 3048 0034 E270     		strb	r2, [r4, #3]
1420:../drivers/fsl_i2c.c **** #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
 3049              		.loc 1 1420 0
 3050 0036 6371     		strb	r3, [r4, #5]
1422:../drivers/fsl_i2c.c **** #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
 3051              		.loc 1 1422 0
 3052 0038 AF3A     		subs	r2, r2, #175
 3053 003a A271     		strb	r2, [r4, #6]
1426:../drivers/fsl_i2c.c **** 
 3054              		.loc 1 1426 0
 3055 003c E371     		strb	r3, [r4, #7]
1429:../drivers/fsl_i2c.c ****     {
 3056              		.loc 1 1429 0
 3057 003e 337A     		ldrb	r3, [r6, #8]
 3058 0040 002B     		cmp	r3, #0
 3059 0042 22D0     		beq	.L240
 3060 0044 022B     		cmp	r3, #2
 3061 0046 25D0     		beq	.L241
 3062              	.L239:
1447:../drivers/fsl_i2c.c ****     tmpReg &= ~I2C_C1_WUEN_MASK;
 3063              		.loc 1 1447 0
 3064 0048 A378     		ldrb	r3, [r4, #2]
 3065              	.LVL330:
1448:../drivers/fsl_i2c.c ****     base->C1 = tmpReg | I2C_C1_WUEN(slaveConfig->enableWakeUp) | I2C_C1_IICEN(slaveConfig->enableSl
 3066              		.loc 1 1448 0
 3067 004a 0222     		movs	r2, #2
 3068 004c 9343     		bics	r3, r2
 3069              	.LVL331:
 3070 004e 1A00     		movs	r2, r3
 3071              	.LVL332:
1449:../drivers/fsl_i2c.c **** 
 3072              		.loc 1 1449 0
 3073 0050 B378     		ldrb	r3, [r6, #2]
 3074 0052 5B00     		lsls	r3, r3, #1
 3075 0054 0221     		movs	r1, #2
 3076 0056 0B40     		ands	r3, r1
 3077 0058 1343     		orrs	r3, r2
 3078 005a 3278     		ldrb	r2, [r6]
 3079              	.LVL333:
 3080 005c D201     		lsls	r2, r2, #7
 3081 005e D2B2     		uxtb	r2, r2
 3082 0060 1343     		orrs	r3, r2
 3083 0062 A370     		strb	r3, [r4, #2]
1452:../drivers/fsl_i2c.c ****     tmpReg &= ~(I2C_C2_SBRC_MASK | I2C_C2_GCAEN_MASK);
 3084              		.loc 1 1452 0
 3085 0064 6379     		ldrb	r3, [r4, #5]
 3086              	.LVL334:
1453:../drivers/fsl_i2c.c ****     tmpReg |= I2C_C2_SBRC(slaveConfig->enableBaudRateCtl) | I2C_C2_GCAEN(slaveConfig->enableGeneral
 3087              		.loc 1 1453 0
 3088 0066 6D31     		adds	r1, r1, #109
 3089 0068 1940     		ands	r1, r3
 3090              	.LVL335:
1454:../drivers/fsl_i2c.c ****     base->C2 = tmpReg;
 3091              		.loc 1 1454 0
 3092 006a F378     		ldrb	r3, [r6, #3]
 3093 006c 1B01     		lsls	r3, r3, #4
 3094 006e 1022     		movs	r2, #16
 3095 0070 1340     		ands	r3, r2
 3096 0072 7278     		ldrb	r2, [r6, #1]
 3097 0074 D201     		lsls	r2, r2, #7
 3098 0076 D2B2     		uxtb	r2, r2
 3099 0078 1343     		orrs	r3, r2
 3100 007a 0B43     		orrs	r3, r1
 3101              	.LVL336:
1455:../drivers/fsl_i2c.c **** 
 3102              		.loc 1 1455 0
 3103 007c 6371     		strb	r3, [r4, #5]
1464:../drivers/fsl_i2c.c **** }
 3104              		.loc 1 1464 0
 3105 007e F168     		ldr	r1, [r6, #12]
 3106 0080 2A00     		movs	r2, r5
 3107 0082 2000     		movs	r0, r4
 3108 0084 FFF7FEFF 		bl	I2C_SetHoldTime
 3109              	.LVL337:
1465:../drivers/fsl_i2c.c **** 
 3110              		.loc 1 1465 0
 3111              		@ sp needed
 3112              	.LVL338:
 3113              	.LVL339:
 3114              	.LVL340:
 3115 0088 70BD     		pop	{r4, r5, r6, pc}
 3116              	.LVL341:
 3117              	.L240:
1432:../drivers/fsl_i2c.c ****             break;
 3118              		.loc 1 1432 0
 3119 008a B388     		ldrh	r3, [r6, #4]
 3120 008c 5B00     		lsls	r3, r3, #1
 3121 008e DBB2     		uxtb	r3, r3
 3122 0090 2370     		strb	r3, [r4]
1433:../drivers/fsl_i2c.c **** 
 3123              		.loc 1 1433 0
 3124 0092 D9E7     		b	.L239
 3125              	.L241:
1437:../drivers/fsl_i2c.c ****             base->RA = ((uint32_t)(slaveConfig->upperAddress)) << 1U;
 3126              		.loc 1 1437 0
 3127 0094 B388     		ldrh	r3, [r6, #4]
 3128 0096 5B00     		lsls	r3, r3, #1
 3129 0098 DBB2     		uxtb	r3, r3
 3130 009a 2370     		strb	r3, [r4]
1438:../drivers/fsl_i2c.c ****             base->C2 |= I2C_C2_RMEN_MASK;
 3131              		.loc 1 1438 0
 3132 009c F388     		ldrh	r3, [r6, #6]
 3133 009e 5B00     		lsls	r3, r3, #1
 3134 00a0 DBB2     		uxtb	r3, r3
 3135 00a2 E371     		strb	r3, [r4, #7]
1439:../drivers/fsl_i2c.c ****             break;
 3136              		.loc 1 1439 0
 3137 00a4 6379     		ldrb	r3, [r4, #5]
 3138 00a6 0822     		movs	r2, #8
 3139 00a8 1343     		orrs	r3, r2
 3140 00aa 6371     		strb	r3, [r4, #5]
1440:../drivers/fsl_i2c.c **** 
 3141              		.loc 1 1440 0
 3142 00ac CCE7     		b	.L239
 3143              	.L243:
 3144 00ae C046     		.align	2
 3145              	.L242:
 3146 00b0 00000000 		.word	.LANCHOR3
 3147 00b4 00700440 		.word	1074032640
 3148              		.cfi_endproc
 3149              	.LFE83:
 3151              		.section	.text.I2C_SlaveDeinit,"ax",%progbits
 3152              		.align	1
 3153              		.global	I2C_SlaveDeinit
 3154              		.syntax unified
 3155              		.code	16
 3156              		.thumb_func
 3157              		.fpu softvfp
 3159              	I2C_SlaveDeinit:
 3160              	.LFB84:
1468:../drivers/fsl_i2c.c ****     /* Disable I2C module. */
 3161              		.loc 1 1468 0
 3162              		.cfi_startproc
 3163              		@ args = 0, pretend = 0, frame = 0
 3164              		@ frame_needed = 0, uses_anonymous_args = 0
 3165              	.LVL342:
 3166 0000 10B5     		push	{r4, lr}
 3167              		.cfi_def_cfa_offset 8
 3168              		.cfi_offset 4, -8
 3169              		.cfi_offset 14, -4
 3170              	.LVL343:
 3171              	.LBB72:
 3172              	.LBB73:
 396:../drivers/fsl_i2c.h ****     }
 3173              		.loc 3 396 0
 3174 0002 8378     		ldrb	r3, [r0, #2]
 3175 0004 7F22     		movs	r2, #127
 3176 0006 1340     		ands	r3, r2
 3177 0008 8370     		strb	r3, [r0, #2]
 3178              	.LVL344:
 3179              	.LBE73:
 3180              	.LBE72:
1474:../drivers/fsl_i2c.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 3181              		.loc 1 1474 0
 3182 000a FFF7FEFF 		bl	I2C_GetInstance
 3183              	.LVL345:
 3184 000e 8000     		lsls	r0, r0, #2
 3185 0010 064B     		ldr	r3, .L245
 3186 0012 C358     		ldr	r3, [r0, r3]
 3187              	.LVL346:
 3188              	.LBB74:
 3189              	.LBB75:
 460:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 3190              		.loc 4 460 0
 3191 0014 1A0C     		lsrs	r2, r3, #16
 3192 0016 0649     		ldr	r1, .L245+4
 3193 0018 8C46     		mov	ip, r1
 3194 001a 6244     		add	r2, r2, ip
 3195              	.LVL347:
 3196              		.loc 4 461 0
 3197 001c 1168     		ldr	r1, [r2]
 3198 001e 1B04     		lsls	r3, r3, #16
 3199              	.LVL348:
 3200 0020 1B0C     		lsrs	r3, r3, #16
 3201 0022 0120     		movs	r0, #1
 3202              	.LVL349:
 3203 0024 9840     		lsls	r0, r0, r3
 3204 0026 8143     		bics	r1, r0
 3205 0028 1160     		str	r1, [r2]
 3206              	.LVL350:
 3207              	.LBE75:
 3208              	.LBE74:
1476:../drivers/fsl_i2c.c **** 
 3209              		.loc 1 1476 0
 3210              		@ sp needed
 3211 002a 10BD     		pop	{r4, pc}
 3212              	.L246:
 3213              		.align	2
 3214              	.L245:
 3215 002c 00000000 		.word	.LANCHOR3
 3216 0030 00700440 		.word	1074032640
 3217              		.cfi_endproc
 3218              	.LFE84:
 3220              		.section	.text.I2C_SlaveGetDefaultConfig,"ax",%progbits
 3221              		.align	1
 3222              		.global	I2C_SlaveGetDefaultConfig
 3223              		.syntax unified
 3224              		.code	16
 3225              		.thumb_func
 3226              		.fpu softvfp
 3228              	I2C_SlaveGetDefaultConfig:
 3229              	.LFB85:
1479:../drivers/fsl_i2c.c ****     assert(slaveConfig);
 3230              		.loc 1 1479 0
 3231              		.cfi_startproc
 3232              		@ args = 0, pretend = 0, frame = 0
 3233              		@ frame_needed = 0, uses_anonymous_args = 0
 3234              		@ link register save eliminated.
 3235              	.LVL351:
1483:../drivers/fsl_i2c.c **** 
 3236              		.loc 1 1483 0
 3237 0000 0023     		movs	r3, #0
 3238 0002 0372     		strb	r3, [r0, #8]
1486:../drivers/fsl_i2c.c **** 
 3239              		.loc 1 1486 0
 3240 0004 4370     		strb	r3, [r0, #1]
1489:../drivers/fsl_i2c.c **** 
 3241              		.loc 1 1489 0
 3242 0006 8370     		strb	r3, [r0, #2]
1492:../drivers/fsl_i2c.c **** 
 3243              		.loc 1 1492 0
 3244 0008 C370     		strb	r3, [r0, #3]
1500:../drivers/fsl_i2c.c **** 
 3245              		.loc 1 1500 0
 3246 000a FA23     		movs	r3, #250
 3247 000c 1B01     		lsls	r3, r3, #4
 3248 000e C360     		str	r3, [r0, #12]
1503:../drivers/fsl_i2c.c **** }
 3249              		.loc 1 1503 0
 3250 0010 0123     		movs	r3, #1
 3251 0012 0370     		strb	r3, [r0]
1504:../drivers/fsl_i2c.c **** 
 3252              		.loc 1 1504 0
 3253              		@ sp needed
 3254 0014 7047     		bx	lr
 3255              		.cfi_endproc
 3256              	.LFE85:
 3258              		.section	.text.I2C_SlaveWriteBlocking,"ax",%progbits
 3259              		.align	1
 3260              		.global	I2C_SlaveWriteBlocking
 3261              		.syntax unified
 3262              		.code	16
 3263              		.thumb_func
 3264              		.fpu softvfp
 3266              	I2C_SlaveWriteBlocking:
 3267              	.LFB86:
1507:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 3268              		.loc 1 1507 0
 3269              		.cfi_startproc
 3270              		@ args = 0, pretend = 0, frame = 8
 3271              		@ frame_needed = 0, uses_anonymous_args = 0
 3272              	.LVL352:
 3273 0000 30B5     		push	{r4, r5, lr}
 3274              		.cfi_def_cfa_offset 12
 3275              		.cfi_offset 4, -12
 3276              		.cfi_offset 5, -8
 3277              		.cfi_offset 14, -4
 3278 0002 83B0     		sub	sp, sp, #12
 3279              		.cfi_def_cfa_offset 24
 3280 0004 0400     		movs	r4, r0
 3281              	.LVL353:
1509:../drivers/fsl_i2c.c **** 
 3282              		.loc 1 1509 0
 3283 0006 6B46     		mov	r3, sp
 3284 0008 D81D     		adds	r0, r3, #7
 3285              	.LVL354:
 3286 000a 0023     		movs	r3, #0
 3287 000c 0370     		strb	r3, [r0]
1512:../drivers/fsl_i2c.c **** 
 3288              		.loc 1 1512 0
 3289 000e 0378     		ldrb	r3, [r0]
 3290 0010 0133     		adds	r3, r3, #1
 3291 0012 DBB2     		uxtb	r3, r3
 3292 0014 0370     		strb	r3, [r0]
 3293              	.L249:
1516:../drivers/fsl_i2c.c ****     {
 3294              		.loc 1 1516 0 discriminator 1
 3295 0016 A379     		ldrb	r3, [r4, #6]
 3296 0018 DB06     		lsls	r3, r3, #27
 3297 001a FCD5     		bpl	.L249
1520:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
 3298              		.loc 1 1520 0
 3299 001c A379     		ldrb	r3, [r4, #6]
 3300 001e 1020     		movs	r0, #16
 3301 0020 0343     		orrs	r3, r0
 3302 0022 A371     		strb	r3, [r4, #6]
1522:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 3303              		.loc 1 1522 0
 3304 0024 0223     		movs	r3, #2
 3305 0026 E370     		strb	r3, [r4, #3]
 3306              	.L250:
1537:../drivers/fsl_i2c.c ****     {
 3307              		.loc 1 1537 0 discriminator 1
 3308 0028 E378     		ldrb	r3, [r4, #3]
 3309 002a 5B06     		lsls	r3, r3, #25
 3310 002c FCD5     		bpl	.L250
1542:../drivers/fsl_i2c.c **** 
 3311              		.loc 1 1542 0
 3312 002e 2379     		ldrb	r3, [r4, #4]
 3313 0030 DBB2     		uxtb	r3, r3
 3314 0032 6846     		mov	r0, sp
 3315 0034 C51D     		adds	r5, r0, #7
 3316 0036 C371     		strb	r3, [r0, #7]
1544:../drivers/fsl_i2c.c **** 
 3317              		.loc 1 1544 0
 3318 0038 0023     		movs	r3, #0
 3319 003a 2000     		movs	r0, r4
 3320 003c FFF7FEFF 		bl	I2C_MasterWriteBlocking
 3321              	.LVL355:
1547:../drivers/fsl_i2c.c **** 
 3322              		.loc 1 1547 0
 3323 0040 A378     		ldrb	r3, [r4, #2]
 3324 0042 1822     		movs	r2, #24
 3325 0044 9343     		bics	r3, r2
 3326 0046 A370     		strb	r3, [r4, #2]
1550:../drivers/fsl_i2c.c **** 
 3327              		.loc 1 1550 0
 3328 0048 2379     		ldrb	r3, [r4, #4]
 3329 004a DBB2     		uxtb	r3, r3
 3330 004c 2B70     		strb	r3, [r5]
1553:../drivers/fsl_i2c.c **** 
 3331              		.loc 1 1553 0
 3332 004e 03B0     		add	sp, sp, #12
 3333              		@ sp needed
 3334              	.LVL356:
 3335 0050 30BD     		pop	{r4, r5, pc}
 3336              		.cfi_endproc
 3337              	.LFE86:
 3339              		.section	.text.I2C_SlaveReadBlocking,"ax",%progbits
 3340              		.align	1
 3341              		.global	I2C_SlaveReadBlocking
 3342              		.syntax unified
 3343              		.code	16
 3344              		.thumb_func
 3345              		.fpu softvfp
 3347              	I2C_SlaveReadBlocking:
 3348              	.LFB87:
1556:../drivers/fsl_i2c.c ****     status_t result = kStatus_Success;
 3349              		.loc 1 1556 0
 3350              		.cfi_startproc
 3351              		@ args = 0, pretend = 0, frame = 8
 3352              		@ frame_needed = 0, uses_anonymous_args = 0
 3353              	.LVL357:
 3354 0000 10B5     		push	{r4, lr}
 3355              		.cfi_def_cfa_offset 8
 3356              		.cfi_offset 4, -8
 3357              		.cfi_offset 14, -4
 3358 0002 82B0     		sub	sp, sp, #8
 3359              		.cfi_def_cfa_offset 16
 3360              	.LVL358:
1558:../drivers/fsl_i2c.c **** 
 3361              		.loc 1 1558 0
 3362 0004 6B46     		mov	r3, sp
 3363 0006 DC1D     		adds	r4, r3, #7
 3364 0008 0023     		movs	r3, #0
 3365 000a 2370     		strb	r3, [r4]
1561:../drivers/fsl_i2c.c **** 
 3366              		.loc 1 1561 0
 3367 000c 2378     		ldrb	r3, [r4]
 3368 000e 0133     		adds	r3, r3, #1
 3369 0010 DBB2     		uxtb	r3, r3
 3370 0012 2370     		strb	r3, [r4]
 3371              	.L252:
1566:../drivers/fsl_i2c.c ****     {
 3372              		.loc 1 1566 0 discriminator 1
 3373 0014 8379     		ldrb	r3, [r0, #6]
 3374 0016 DB06     		lsls	r3, r3, #27
 3375 0018 FCD5     		bpl	.L252
1570:../drivers/fsl_i2c.c ****     /* Clear the IICIF flag. */
 3376              		.loc 1 1570 0
 3377 001a 8379     		ldrb	r3, [r0, #6]
 3378 001c 1024     		movs	r4, #16
 3379 001e 2343     		orrs	r3, r4
 3380 0020 8371     		strb	r3, [r0, #6]
1572:../drivers/fsl_i2c.c **** #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
 3381              		.loc 1 1572 0
 3382 0022 0223     		movs	r3, #2
 3383 0024 C370     		strb	r3, [r0, #3]
 3384              	.L253:
1596:../drivers/fsl_i2c.c ****     {
 3385              		.loc 1 1596 0 discriminator 1
 3386 0026 C378     		ldrb	r3, [r0, #3]
 3387 0028 5B06     		lsls	r3, r3, #25
 3388 002a FCD5     		bpl	.L253
 3389              	.L254:
1599:../drivers/fsl_i2c.c ****     {
 3390              		.loc 1 1599 0 discriminator 1
 3391 002c C378     		ldrb	r3, [r0, #3]
 3392 002e 9B07     		lsls	r3, r3, #30
 3393 0030 FCD5     		bpl	.L254
1605:../drivers/fsl_i2c.c **** 
 3394              		.loc 1 1605 0
 3395 0032 0379     		ldrb	r3, [r0, #4]
 3396 0034 DBB2     		uxtb	r3, r3
 3397 0036 6C46     		mov	r4, sp
 3398 0038 E371     		strb	r3, [r4, #7]
1608:../drivers/fsl_i2c.c **** 
 3399              		.loc 1 1608 0
 3400 003a 0223     		movs	r3, #2
 3401 003c C370     		strb	r3, [r0, #3]
1611:../drivers/fsl_i2c.c **** 
 3402              		.loc 1 1611 0
 3403 003e 8378     		ldrb	r3, [r0, #2]
 3404 0040 1024     		movs	r4, #16
 3405 0042 A343     		bics	r3, r4
 3406 0044 8370     		strb	r3, [r0, #2]
1613:../drivers/fsl_i2c.c ****     {
 3407              		.loc 1 1613 0
 3408 0046 08E0     		b	.L255
 3409              	.LVL359:
 3410              	.L256:
1627:../drivers/fsl_i2c.c ****         {
 3411              		.loc 1 1627 0 discriminator 1
 3412 0048 C378     		ldrb	r3, [r0, #3]
 3413 004a 9B07     		lsls	r3, r3, #30
 3414 004c FCD5     		bpl	.L256
1632:../drivers/fsl_i2c.c **** 
 3415              		.loc 1 1632 0
 3416 004e 0223     		movs	r3, #2
 3417 0050 C370     		strb	r3, [r0, #3]
 3418              	.LVL360:
1635:../drivers/fsl_i2c.c ****     }
 3419              		.loc 1 1635 0
 3420 0052 0379     		ldrb	r3, [r0, #4]
 3421 0054 0B70     		strb	r3, [r1]
1613:../drivers/fsl_i2c.c ****     {
 3422              		.loc 1 1613 0
 3423 0056 2200     		movs	r2, r4
1635:../drivers/fsl_i2c.c ****     }
 3424              		.loc 1 1635 0
 3425 0058 0131     		adds	r1, r1, #1
 3426              	.LVL361:
 3427              	.L255:
1613:../drivers/fsl_i2c.c ****     {
 3428              		.loc 1 1613 0
 3429 005a 541E     		subs	r4, r2, #1
 3430              	.LVL362:
 3431 005c 002A     		cmp	r2, #0
 3432 005e F3D1     		bne	.L256
1639:../drivers/fsl_i2c.c **** 
 3433              		.loc 1 1639 0
 3434 0060 0020     		movs	r0, #0
 3435              	.LVL363:
 3436 0062 02B0     		add	sp, sp, #8
 3437              		@ sp needed
 3438              	.LVL364:
 3439 0064 10BD     		pop	{r4, pc}
 3440              		.cfi_endproc
 3441              	.LFE87:
 3443              		.section	.text.I2C_SlaveTransferCreateHandle,"ax",%progbits
 3444              		.align	1
 3445              		.global	I2C_SlaveTransferCreateHandle
 3446              		.syntax unified
 3447              		.code	16
 3448              		.thumb_func
 3449              		.fpu softvfp
 3451              	I2C_SlaveTransferCreateHandle:
 3452              	.LFB88:
1645:../drivers/fsl_i2c.c ****     assert(handle);
 3453              		.loc 1 1645 0
 3454              		.cfi_startproc
 3455              		@ args = 0, pretend = 0, frame = 0
 3456              		@ frame_needed = 0, uses_anonymous_args = 0
 3457              	.LVL365:
 3458 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3459              		.cfi_def_cfa_offset 24
 3460              		.cfi_offset 3, -24
 3461              		.cfi_offset 4, -20
 3462              		.cfi_offset 5, -16
 3463              		.cfi_offset 6, -12
 3464              		.cfi_offset 7, -8
 3465              		.cfi_offset 14, -4
 3466 0002 0C00     		movs	r4, r1
 3467 0004 1700     		movs	r7, r2
 3468 0006 1E00     		movs	r6, r3
1648:../drivers/fsl_i2c.c **** 
 3469              		.loc 1 1648 0
 3470 0008 FFF7FEFF 		bl	I2C_GetInstance
 3471              	.LVL366:
 3472 000c 0500     		movs	r5, r0
 3473              	.LVL367:
1651:../drivers/fsl_i2c.c **** 
 3474              		.loc 1 1651 0
 3475 000e 1C22     		movs	r2, #28
 3476 0010 0021     		movs	r1, #0
 3477 0012 2000     		movs	r0, r4
 3478              	.LVL368:
 3479 0014 FFF7FEFF 		bl	memset
 3480              	.LVL369:
1654:../drivers/fsl_i2c.c ****     handle->userData = userData;
 3481              		.loc 1 1654 0
 3482 0018 E761     		str	r7, [r4, #28]
1655:../drivers/fsl_i2c.c **** 
 3483              		.loc 1 1655 0
 3484 001a 2662     		str	r6, [r4, #32]
1658:../drivers/fsl_i2c.c **** 
 3485              		.loc 1 1658 0
 3486 001c AA00     		lsls	r2, r5, #2
 3487 001e 0A4B     		ldr	r3, .L259
 3488 0020 D450     		str	r4, [r2, r3]
1661:../drivers/fsl_i2c.c **** 
 3489              		.loc 1 1661 0
 3490 0022 0A4B     		ldr	r3, .L259+4
 3491 0024 0A4A     		ldr	r2, .L259+8
 3492 0026 1A60     		str	r2, [r3]
1664:../drivers/fsl_i2c.c **** }
 3493              		.loc 1 1664 0
 3494 0028 0A4B     		ldr	r3, .L259+12
 3495 002a 5B57     		ldrsb	r3, [r3, r5]
 3496              	.LVL370:
 3497              	.LBB76:
 3498              	.LBB77:
 3499              		.loc 5 365 0
 3500 002c 1A00     		movs	r2, r3
 3501 002e 8032     		adds	r2, r2, #128
 3502 0030 08D0     		beq	.L257
 3503              	.LVL371:
 3504              	.LBB78:
 3505              	.LBB79:
 733:../CMSIS/core_cm0plus.h ****   {
 3506              		.loc 6 733 0
 3507 0032 002B     		cmp	r3, #0
 3508 0034 06DB     		blt	.L257
 3509              		.loc 6 735 0
 3510 0036 1F22     		movs	r2, #31
 3511 0038 1340     		ands	r3, r2
 3512              	.LVL372:
 3513 003a 1E3A     		subs	r2, r2, #30
 3514 003c 9A40     		lsls	r2, r2, r3
 3515 003e 1300     		movs	r3, r2
 3516 0040 054A     		ldr	r2, .L259+16
 3517 0042 1360     		str	r3, [r2]
 3518              	.LVL373:
 3519              	.L257:
 3520              	.LBE79:
 3521              	.LBE78:
 3522              	.LBE77:
 3523              	.LBE76:
1665:../drivers/fsl_i2c.c **** 
 3524              		.loc 1 1665 0
 3525              		@ sp needed
 3526              	.LVL374:
 3527              	.LVL375:
 3528              	.LVL376:
 3529              	.LVL377:
 3530 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3531              	.L260:
 3532 0046 C046     		.align	2
 3533              	.L259:
 3534 0048 00000000 		.word	.LANCHOR4
 3535 004c 00000000 		.word	.LANCHOR1
 3536 0050 00000000 		.word	I2C_SlaveTransferHandleIRQ
 3537 0054 00000000 		.word	.LANCHOR5
 3538 0058 00E100E0 		.word	-536813312
 3539              		.cfi_endproc
 3540              	.LFE88:
 3542              		.section	.text.I2C_SlaveTransferNonBlocking,"ax",%progbits
 3543              		.align	1
 3544              		.global	I2C_SlaveTransferNonBlocking
 3545              		.syntax unified
 3546              		.code	16
 3547              		.thumb_func
 3548              		.fpu softvfp
 3550              	I2C_SlaveTransferNonBlocking:
 3551              	.LFB89:
1668:../drivers/fsl_i2c.c ****     assert(handle);
 3552              		.loc 1 1668 0
 3553              		.cfi_startproc
 3554              		@ args = 0, pretend = 0, frame = 0
 3555              		@ frame_needed = 0, uses_anonymous_args = 0
 3556              	.LVL378:
 3557 0000 70B5     		push	{r4, r5, r6, lr}
 3558              		.cfi_def_cfa_offset 16
 3559              		.cfi_offset 4, -16
 3560              		.cfi_offset 5, -12
 3561              		.cfi_offset 6, -8
 3562              		.cfi_offset 14, -4
 3563 0002 0400     		movs	r4, r0
 3564 0004 0D00     		movs	r5, r1
 3565 0006 1600     		movs	r6, r2
1672:../drivers/fsl_i2c.c ****     {
 3566              		.loc 1 1672 0
 3567 0008 0B78     		ldrb	r3, [r1]
 3568 000a 002B     		cmp	r3, #0
 3569 000c 1BD1     		bne	.L263
1679:../drivers/fsl_i2c.c **** 
 3570              		.loc 1 1679 0
 3571 000e 6021     		movs	r1, #96
 3572              	.LVL379:
 3573 0010 FFF7FEFF 		bl	I2C_DisableInterrupts
 3574              	.LVL380:
1682:../drivers/fsl_i2c.c **** 
 3575              		.loc 1 1682 0
 3576 0014 281D     		adds	r0, r5, #4
 3577 0016 1422     		movs	r2, #20
 3578 0018 0021     		movs	r1, #0
 3579 001a FFF7FEFF 		bl	memset
 3580              	.LVL381:
1685:../drivers/fsl_i2c.c **** 
 3581              		.loc 1 1685 0
 3582 001e 0123     		movs	r3, #1
 3583 0020 2B70     		strb	r3, [r5]
1688:../drivers/fsl_i2c.c **** 
 3584              		.loc 1 1688 0
 3585 0022 4533     		adds	r3, r3, #69
 3586 0024 1E43     		orrs	r6, r3
 3587              	.LVL382:
 3588 0026 AE61     		str	r6, [r5, #24]
 3589              	.LVL383:
 3590              	.LBB80:
 3591              	.LBB81:
 3592              	.LBB82:
 446:../drivers/fsl_i2c.h ****     }
 3593              		.loc 3 446 0
 3594 0028 A279     		ldrb	r2, [r4, #6]
 3595 002a 5021     		movs	r1, #80
 3596 002c 0A43     		orrs	r2, r1
 3597 002e A271     		strb	r2, [r4, #6]
 454:../drivers/fsl_i2c.h ****     }
 3598              		.loc 3 454 0
 3599 0030 A379     		ldrb	r3, [r4, #6]
 3600 0032 0B43     		orrs	r3, r1
 3601 0034 A371     		strb	r3, [r4, #6]
 3602              		.loc 3 458 0
 3603 0036 1223     		movs	r3, #18
 3604 0038 E370     		strb	r3, [r4, #3]
 3605              	.LVL384:
 3606              	.LBE82:
 3607              	.LBE81:
 3608              	.LBE80:
1694:../drivers/fsl_i2c.c ****     }
 3609              		.loc 1 1694 0
 3610 003a 6021     		movs	r1, #96
 3611 003c 2000     		movs	r0, r4
 3612 003e FFF7FEFF 		bl	I2C_EnableInterrupts
 3613              	.LVL385:
1697:../drivers/fsl_i2c.c **** }
 3614              		.loc 1 1697 0
 3615 0042 0020     		movs	r0, #0
 3616              	.L261:
1698:../drivers/fsl_i2c.c **** 
 3617              		.loc 1 1698 0
 3618              		@ sp needed
 3619              	.LVL386:
 3620              	.LVL387:
 3621 0044 70BD     		pop	{r4, r5, r6, pc}
 3622              	.LVL388:
 3623              	.L263:
1674:../drivers/fsl_i2c.c ****     }
 3624              		.loc 1 1674 0
 3625 0046 0148     		ldr	r0, .L264
 3626              	.LVL389:
 3627 0048 FCE7     		b	.L261
 3628              	.L265:
 3629 004a C046     		.align	2
 3630              	.L264:
 3631 004c 4C040000 		.word	1100
 3632              		.cfi_endproc
 3633              	.LFE89:
 3635              		.section	.text.I2C_SlaveTransferAbort,"ax",%progbits
 3636              		.align	1
 3637              		.global	I2C_SlaveTransferAbort
 3638              		.syntax unified
 3639              		.code	16
 3640              		.thumb_func
 3641              		.fpu softvfp
 3643              	I2C_SlaveTransferAbort:
 3644              	.LFB90:
1701:../drivers/fsl_i2c.c ****     assert(handle);
 3645              		.loc 1 1701 0
 3646              		.cfi_startproc
 3647              		@ args = 0, pretend = 0, frame = 0
 3648              		@ frame_needed = 0, uses_anonymous_args = 0
 3649              	.LVL390:
 3650 0000 10B5     		push	{r4, lr}
 3651              		.cfi_def_cfa_offset 8
 3652              		.cfi_offset 4, -8
 3653              		.cfi_offset 14, -4
 3654 0002 0C00     		movs	r4, r1
1704:../drivers/fsl_i2c.c ****     {
 3655              		.loc 1 1704 0
 3656 0004 0B78     		ldrb	r3, [r1]
 3657 0006 002B     		cmp	r3, #0
 3658 0008 00D1     		bne	.L268
 3659              	.LVL391:
 3660              	.L266:
1715:../drivers/fsl_i2c.c **** 
 3661              		.loc 1 1715 0
 3662              		@ sp needed
 3663              	.LVL392:
 3664 000a 10BD     		pop	{r4, pc}
 3665              	.LVL393:
 3666              	.L268:
1707:../drivers/fsl_i2c.c **** 
 3667              		.loc 1 1707 0
 3668 000c 6021     		movs	r1, #96
 3669              	.LVL394:
 3670 000e FFF7FEFF 		bl	I2C_DisableInterrupts
 3671              	.LVL395:
1710:../drivers/fsl_i2c.c **** 
 3672              		.loc 1 1710 0
 3673 0012 201D     		adds	r0, r4, #4
 3674 0014 1422     		movs	r2, #20
 3675 0016 0021     		movs	r1, #0
 3676 0018 FFF7FEFF 		bl	memset
 3677              	.LVL396:
1713:../drivers/fsl_i2c.c ****     }
 3678              		.loc 1 1713 0
 3679 001c 0023     		movs	r3, #0
 3680 001e 2370     		strb	r3, [r4]
1715:../drivers/fsl_i2c.c **** 
 3681              		.loc 1 1715 0
 3682 0020 F3E7     		b	.L266
 3683              		.cfi_endproc
 3684              	.LFE90:
 3686              		.section	.text.I2C_SlaveTransferGetCount,"ax",%progbits
 3687              		.align	1
 3688              		.global	I2C_SlaveTransferGetCount
 3689              		.syntax unified
 3690              		.code	16
 3691              		.thumb_func
 3692              		.fpu softvfp
 3694              	I2C_SlaveTransferGetCount:
 3695              	.LFB91:
1718:../drivers/fsl_i2c.c ****     assert(handle);
 3696              		.loc 1 1718 0
 3697              		.cfi_startproc
 3698              		@ args = 0, pretend = 0, frame = 0
 3699              		@ frame_needed = 0, uses_anonymous_args = 0
 3700              		@ link register save eliminated.
 3701              	.LVL397:
1721:../drivers/fsl_i2c.c ****     {
 3702              		.loc 1 1721 0
 3703 0000 002A     		cmp	r2, #0
 3704 0002 09D0     		beq	.L272
1727:../drivers/fsl_i2c.c ****     {
 3705              		.loc 1 1727 0
 3706 0004 0B78     		ldrb	r3, [r1]
 3707 0006 002B     		cmp	r3, #0
 3708 0008 03D0     		beq	.L273
1734:../drivers/fsl_i2c.c **** 
 3709              		.loc 1 1734 0
 3710 000a 4B69     		ldr	r3, [r1, #20]
 3711 000c 1360     		str	r3, [r2]
1736:../drivers/fsl_i2c.c **** }
 3712              		.loc 1 1736 0
 3713 000e 0020     		movs	r0, #0
 3714              	.LVL398:
 3715              	.L269:
1737:../drivers/fsl_i2c.c **** 
 3716              		.loc 1 1737 0
 3717              		@ sp needed
 3718 0010 7047     		bx	lr
 3719              	.LVL399:
 3720              	.L273:
1729:../drivers/fsl_i2c.c ****         return kStatus_NoTransferInProgress;
 3721              		.loc 1 1729 0
 3722 0012 1360     		str	r3, [r2]
1730:../drivers/fsl_i2c.c ****     }
 3723              		.loc 1 1730 0
 3724 0014 0620     		movs	r0, #6
 3725              	.LVL400:
 3726 0016 FBE7     		b	.L269
 3727              	.LVL401:
 3728              	.L272:
1723:../drivers/fsl_i2c.c ****     }
 3729              		.loc 1 1723 0
 3730 0018 0420     		movs	r0, #4
 3731              	.LVL402:
 3732 001a F9E7     		b	.L269
 3733              		.cfi_endproc
 3734              	.LFE91:
 3736              		.section	.text.I2C0_DriverIRQHandler,"ax",%progbits
 3737              		.align	1
 3738              		.global	I2C0_DriverIRQHandler
 3739              		.syntax unified
 3740              		.code	16
 3741              		.thumb_func
 3742              		.fpu softvfp
 3744              	I2C0_DriverIRQHandler:
 3745              	.LFB93:
1979:../drivers/fsl_i2c.c **** 
1980:../drivers/fsl_i2c.c **** #if defined(I2C0)
1981:../drivers/fsl_i2c.c **** void I2C0_DriverIRQHandler(void)
1982:../drivers/fsl_i2c.c **** {
 3746              		.loc 1 1982 0
 3747              		.cfi_startproc
 3748              		@ args = 0, pretend = 0, frame = 0
 3749              		@ frame_needed = 0, uses_anonymous_args = 0
 3750 0000 10B5     		push	{r4, lr}
 3751              		.cfi_def_cfa_offset 8
 3752              		.cfi_offset 4, -8
 3753              		.cfi_offset 14, -4
1983:../drivers/fsl_i2c.c ****     I2C_TransferCommonIRQHandler(I2C0, s_i2cHandle[0]);
 3754              		.loc 1 1983 0
 3755 0002 034B     		ldr	r3, .L275
 3756 0004 1968     		ldr	r1, [r3]
 3757 0006 0348     		ldr	r0, .L275+4
 3758 0008 FFF7FEFF 		bl	I2C_TransferCommonIRQHandler
 3759              	.LVL403:
1984:../drivers/fsl_i2c.c **** }
 3760              		.loc 1 1984 0
 3761              		@ sp needed
 3762 000c 10BD     		pop	{r4, pc}
 3763              	.L276:
 3764 000e C046     		.align	2
 3765              	.L275:
 3766 0010 00000000 		.word	.LANCHOR4
 3767 0014 00600640 		.word	1074159616
 3768              		.cfi_endproc
 3769              	.LFE93:
 3771              		.section	.text.I2C1_DriverIRQHandler,"ax",%progbits
 3772              		.align	1
 3773              		.global	I2C1_DriverIRQHandler
 3774              		.syntax unified
 3775              		.code	16
 3776              		.thumb_func
 3777              		.fpu softvfp
 3779              	I2C1_DriverIRQHandler:
 3780              	.LFB94:
1985:../drivers/fsl_i2c.c **** #endif
1986:../drivers/fsl_i2c.c **** 
1987:../drivers/fsl_i2c.c **** #if defined(I2C1)
1988:../drivers/fsl_i2c.c **** void I2C1_DriverIRQHandler(void)
1989:../drivers/fsl_i2c.c **** {
 3781              		.loc 1 1989 0
 3782              		.cfi_startproc
 3783              		@ args = 0, pretend = 0, frame = 0
 3784              		@ frame_needed = 0, uses_anonymous_args = 0
 3785 0000 10B5     		push	{r4, lr}
 3786              		.cfi_def_cfa_offset 8
 3787              		.cfi_offset 4, -8
 3788              		.cfi_offset 14, -4
1990:../drivers/fsl_i2c.c ****     I2C_TransferCommonIRQHandler(I2C1, s_i2cHandle[1]);
 3789              		.loc 1 1990 0
 3790 0002 034B     		ldr	r3, .L278
 3791 0004 5968     		ldr	r1, [r3, #4]
 3792 0006 0348     		ldr	r0, .L278+4
 3793 0008 FFF7FEFF 		bl	I2C_TransferCommonIRQHandler
 3794              	.LVL404:
1991:../drivers/fsl_i2c.c **** }
 3795              		.loc 1 1991 0
 3796              		@ sp needed
 3797 000c 10BD     		pop	{r4, pc}
 3798              	.L279:
 3799 000e C046     		.align	2
 3800              	.L278:
 3801 0010 00000000 		.word	.LANCHOR4
 3802 0014 00700640 		.word	1074163712
 3803              		.cfi_endproc
 3804              	.LFE94:
 3806              		.section	.bss.s_i2cHandle,"aw",%nobits
 3807              		.align	2
 3808              		.set	.LANCHOR4,. + 0
 3811              	s_i2cHandle:
 3812 0000 00000000 		.space	8
 3812      00000000 
 3813              		.section	.bss.s_i2cMasterIsr,"aw",%nobits
 3814              		.align	2
 3815              		.set	.LANCHOR0,. + 0
 3818              	s_i2cMasterIsr:
 3819 0000 00000000 		.space	4
 3820              		.section	.bss.s_i2cSlaveIsr,"aw",%nobits
 3821              		.align	2
 3822              		.set	.LANCHOR1,. + 0
 3825              	s_i2cSlaveIsr:
 3826 0000 00000000 		.space	4
 3827              		.section	.rodata.s_i2cBases,"a",%progbits
 3828              		.align	2
 3829              		.set	.LANCHOR2,. + 0
 3832              	s_i2cBases:
 3833 0000 00600640 		.word	1074159616
 3834 0004 00700640 		.word	1074163712
 3835              		.section	.rodata.s_i2cClocks,"a",%progbits
 3836              		.align	2
 3837              		.set	.LANCHOR3,. + 0
 3840              	s_i2cClocks:
 3841 0000 06003410 		.word	271843334
 3842 0004 07003410 		.word	271843335
 3843              		.section	.rodata.s_i2cDividerTable,"a",%progbits
 3844              		.align	2
 3847              	s_i2cDividerTable:
 3848 0000 1400     		.short	20
 3849 0002 1600     		.short	22
 3850 0004 1800     		.short	24
 3851 0006 1A00     		.short	26
 3852 0008 1C00     		.short	28
 3853 000a 1E00     		.short	30
 3854 000c 2200     		.short	34
 3855 000e 2800     		.short	40
 3856 0010 1C00     		.short	28
 3857 0012 2000     		.short	32
 3858 0014 2400     		.short	36
 3859 0016 2800     		.short	40
 3860 0018 2C00     		.short	44
 3861 001a 3000     		.short	48
 3862 001c 3800     		.short	56
 3863 001e 4400     		.short	68
 3864 0020 3000     		.short	48
 3865 0022 3800     		.short	56
 3866 0024 4000     		.short	64
 3867 0026 4800     		.short	72
 3868 0028 5000     		.short	80
 3869 002a 5800     		.short	88
 3870 002c 6800     		.short	104
 3871 002e 8000     		.short	128
 3872 0030 5000     		.short	80
 3873 0032 6000     		.short	96
 3874 0034 7000     		.short	112
 3875 0036 8000     		.short	128
 3876 0038 9000     		.short	144
 3877 003a A000     		.short	160
 3878 003c C000     		.short	192
 3879 003e F000     		.short	240
 3880 0040 A000     		.short	160
 3881 0042 C000     		.short	192
 3882 0044 E000     		.short	224
 3883 0046 0001     		.short	256
 3884 0048 2001     		.short	288
 3885 004a 4001     		.short	320
 3886 004c 8001     		.short	384
 3887 004e E001     		.short	480
 3888 0050 4001     		.short	320
 3889 0052 8001     		.short	384
 3890 0054 C001     		.short	448
 3891 0056 0002     		.short	512
 3892 0058 4002     		.short	576
 3893 005a 8002     		.short	640
 3894 005c 0003     		.short	768
 3895 005e C003     		.short	960
 3896 0060 8002     		.short	640
 3897 0062 0003     		.short	768
 3898 0064 8003     		.short	896
 3899 0066 0004     		.short	1024
 3900 0068 8004     		.short	1152
 3901 006a 0005     		.short	1280
 3902 006c 0006     		.short	1536
 3903 006e 8007     		.short	1920
 3904 0070 0005     		.short	1280
 3905 0072 0006     		.short	1536
 3906 0074 0007     		.short	1792
 3907 0076 0008     		.short	2048
 3908 0078 0009     		.short	2304
 3909 007a 000A     		.short	2560
 3910 007c 000C     		.short	3072
 3911 007e 000F     		.short	3840
 3912              		.section	.rodata.s_i2cIrqs,"a",%progbits
 3913              		.align	2
 3914              		.set	.LANCHOR5,. + 0
 3917              	s_i2cIrqs:
 3918 0000 08       		.byte	8
 3919 0001 09       		.byte	9
 3920              		.text
 3921              	.Letext0:
 3922              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 3923              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 3924              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 3925              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 3926              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 3927              		.file 12 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 3928              		.file 13 "../CMSIS/MKL17Z4.h"
 3929              		.file 14 "../CMSIS/system_MKL17Z4.h"
 3930              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_i2c.c
     /tmp/cc1WYNmz.s:17     .text.I2C_SetHoldTime:0000000000000000 $t
     /tmp/cc1WYNmz.s:23     .text.I2C_SetHoldTime:0000000000000000 I2C_SetHoldTime
     /tmp/cc1WYNmz.s:165    .text.I2C_SetHoldTime:000000000000008c $d
     /tmp/cc1WYNmz.s:3847   .rodata.s_i2cDividerTable:0000000000000000 s_i2cDividerTable
     /tmp/cc1WYNmz.s:171    .text.I2C_CheckAndClearError:0000000000000000 $t
     /tmp/cc1WYNmz.s:177    .text.I2C_CheckAndClearError:0000000000000000 I2C_CheckAndClearError
     /tmp/cc1WYNmz.s:218    .text.I2C_CheckAndClearError:0000000000000018 $d
     /tmp/cc1WYNmz.s:224    .text.I2C_TransferCommonIRQHandler:0000000000000000 $t
     /tmp/cc1WYNmz.s:230    .text.I2C_TransferCommonIRQHandler:0000000000000000 I2C_TransferCommonIRQHandler
     /tmp/cc1WYNmz.s:282    .text.I2C_TransferCommonIRQHandler:0000000000000024 $d
     /tmp/cc1WYNmz.s:288    .text.I2C_GetInstance:0000000000000000 $t
     /tmp/cc1WYNmz.s:295    .text.I2C_GetInstance:0000000000000000 I2C_GetInstance
     /tmp/cc1WYNmz.s:329    .text.I2C_GetInstance:0000000000000018 $d
     /tmp/cc1WYNmz.s:334    .text.I2C_MasterDeinit:0000000000000000 $t
     /tmp/cc1WYNmz.s:341    .text.I2C_MasterDeinit:0000000000000000 I2C_MasterDeinit
     /tmp/cc1WYNmz.s:399    .text.I2C_MasterDeinit:000000000000002c $d
     /tmp/cc1WYNmz.s:405    .text.I2C_MasterGetDefaultConfig:0000000000000000 $t
     /tmp/cc1WYNmz.s:412    .text.I2C_MasterGetDefaultConfig:0000000000000000 I2C_MasterGetDefaultConfig
     /tmp/cc1WYNmz.s:437    .text.I2C_MasterGetDefaultConfig:0000000000000010 $d
     /tmp/cc1WYNmz.s:442    .text.I2C_EnableInterrupts:0000000000000000 $t
     /tmp/cc1WYNmz.s:449    .text.I2C_EnableInterrupts:0000000000000000 I2C_EnableInterrupts
     /tmp/cc1WYNmz.s:491    .text.I2C_DisableInterrupts:0000000000000000 $t
     /tmp/cc1WYNmz.s:498    .text.I2C_DisableInterrupts:0000000000000000 I2C_DisableInterrupts
     /tmp/cc1WYNmz.s:531    .text.I2C_MasterSetBaudRate:0000000000000000 $t
     /tmp/cc1WYNmz.s:538    .text.I2C_MasterSetBaudRate:0000000000000000 I2C_MasterSetBaudRate
     /tmp/cc1WYNmz.s:677    .text.I2C_MasterSetBaudRate:0000000000000088 $d
     /tmp/cc1WYNmz.s:682    .text.I2C_MasterInit:0000000000000000 $t
     /tmp/cc1WYNmz.s:689    .text.I2C_MasterInit:0000000000000000 I2C_MasterInit
     /tmp/cc1WYNmz.s:821    .text.I2C_MasterInit:0000000000000084 $d
     /tmp/cc1WYNmz.s:827    .text.I2C_MasterStop:0000000000000000 $t
     /tmp/cc1WYNmz.s:834    .text.I2C_MasterStop:0000000000000000 I2C_MasterStop
     /tmp/cc1WYNmz.s:861    .text.I2C_MasterGetStatusFlags:0000000000000000 $t
     /tmp/cc1WYNmz.s:868    .text.I2C_MasterGetStatusFlags:0000000000000000 I2C_MasterGetStatusFlags
     /tmp/cc1WYNmz.s:909    .text.I2C_MasterStart:0000000000000000 $t
     /tmp/cc1WYNmz.s:916    .text.I2C_MasterStart:0000000000000000 I2C_MasterStart
     /tmp/cc1WYNmz.s:981    .text.I2C_MasterStart:0000000000000038 $d
     /tmp/cc1WYNmz.s:986    .text.I2C_MasterRepeatedStart:0000000000000000 $t
     /tmp/cc1WYNmz.s:993    .text.I2C_MasterRepeatedStart:0000000000000000 I2C_MasterRepeatedStart
     /tmp/cc1WYNmz.s:1098   .text.I2C_MasterRepeatedStart:000000000000005c $d
     /tmp/cc1WYNmz.s:1103   .text.I2C_MasterTransferRunStateMachine:0000000000000000 $t
     /tmp/cc1WYNmz.s:1109   .text.I2C_MasterTransferRunStateMachine:0000000000000000 I2C_MasterTransferRunStateMachine
     /tmp/cc1WYNmz.s:1437   .text.I2C_MasterTransferRunStateMachine:0000000000000190 $d
     /tmp/cc1WYNmz.s:1443   .text.I2C_MasterTransferHandleIRQ:0000000000000000 $t
     /tmp/cc1WYNmz.s:1450   .text.I2C_MasterTransferHandleIRQ:0000000000000000 I2C_MasterTransferHandleIRQ
     /tmp/cc1WYNmz.s:1551   .text.I2C_MasterTransferHandleIRQ:000000000000006c $d
     /tmp/cc1WYNmz.s:1557   .text.I2C_InitTransferStateMachine:0000000000000000 $t
     /tmp/cc1WYNmz.s:1563   .text.I2C_InitTransferStateMachine:0000000000000000 I2C_InitTransferStateMachine
     /tmp/cc1WYNmz.s:1700   .text.I2C_SlaveTransferHandleIRQ:0000000000000000 $t
     /tmp/cc1WYNmz.s:1707   .text.I2C_SlaveTransferHandleIRQ:0000000000000000 I2C_SlaveTransferHandleIRQ
     /tmp/cc1WYNmz.s:2094   .text.I2C_SlaveTransferHandleIRQ:00000000000001cc $d
     /tmp/cc1WYNmz.s:2099   .text.I2C_MasterWriteBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:2106   .text.I2C_MasterWriteBlocking:0000000000000000 I2C_MasterWriteBlocking
     /tmp/cc1WYNmz.s:2227   .text.I2C_MasterWriteBlocking:0000000000000070 $d
     /tmp/cc1WYNmz.s:2233   .text.I2C_MasterReadBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:2240   .text.I2C_MasterReadBlocking:0000000000000000 I2C_MasterReadBlocking
     /tmp/cc1WYNmz.s:2375   .text.I2C_MasterTransferBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:2382   .text.I2C_MasterTransferBlocking:0000000000000000 I2C_MasterTransferBlocking
     /tmp/cc1WYNmz.s:2669   .text.I2C_MasterTransferBlocking:000000000000014c $d
     /tmp/cc1WYNmz.s:2675   .text.I2C_MasterTransferCreateHandle:0000000000000000 $t
     /tmp/cc1WYNmz.s:2682   .text.I2C_MasterTransferCreateHandle:0000000000000000 I2C_MasterTransferCreateHandle
     /tmp/cc1WYNmz.s:2767   .text.I2C_MasterTransferCreateHandle:0000000000000048 $d
     /tmp/cc1WYNmz.s:2776   .text.I2C_MasterTransferNonBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:2783   .text.I2C_MasterTransferNonBlocking:0000000000000000 I2C_MasterTransferNonBlocking
     /tmp/cc1WYNmz.s:2830   .text.I2C_MasterTransferNonBlocking:0000000000000024 $d
     /tmp/cc1WYNmz.s:2835   .text.I2C_MasterTransferAbort:0000000000000000 $t
     /tmp/cc1WYNmz.s:2842   .text.I2C_MasterTransferAbort:0000000000000000 I2C_MasterTransferAbort
     /tmp/cc1WYNmz.s:2941   .text.I2C_MasterTransferAbort:0000000000000070 $d
     /tmp/cc1WYNmz.s:2946   .text.I2C_MasterTransferGetCount:0000000000000000 $t
     /tmp/cc1WYNmz.s:2953   .text.I2C_MasterTransferGetCount:0000000000000000 I2C_MasterTransferGetCount
     /tmp/cc1WYNmz.s:2987   .text.I2C_SlaveInit:0000000000000000 $t
     /tmp/cc1WYNmz.s:2994   .text.I2C_SlaveInit:0000000000000000 I2C_SlaveInit
     /tmp/cc1WYNmz.s:3146   .text.I2C_SlaveInit:00000000000000b0 $d
     /tmp/cc1WYNmz.s:3152   .text.I2C_SlaveDeinit:0000000000000000 $t
     /tmp/cc1WYNmz.s:3159   .text.I2C_SlaveDeinit:0000000000000000 I2C_SlaveDeinit
     /tmp/cc1WYNmz.s:3215   .text.I2C_SlaveDeinit:000000000000002c $d
     /tmp/cc1WYNmz.s:3221   .text.I2C_SlaveGetDefaultConfig:0000000000000000 $t
     /tmp/cc1WYNmz.s:3228   .text.I2C_SlaveGetDefaultConfig:0000000000000000 I2C_SlaveGetDefaultConfig
     /tmp/cc1WYNmz.s:3259   .text.I2C_SlaveWriteBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:3266   .text.I2C_SlaveWriteBlocking:0000000000000000 I2C_SlaveWriteBlocking
     /tmp/cc1WYNmz.s:3340   .text.I2C_SlaveReadBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:3347   .text.I2C_SlaveReadBlocking:0000000000000000 I2C_SlaveReadBlocking
     /tmp/cc1WYNmz.s:3444   .text.I2C_SlaveTransferCreateHandle:0000000000000000 $t
     /tmp/cc1WYNmz.s:3451   .text.I2C_SlaveTransferCreateHandle:0000000000000000 I2C_SlaveTransferCreateHandle
     /tmp/cc1WYNmz.s:3534   .text.I2C_SlaveTransferCreateHandle:0000000000000048 $d
     /tmp/cc1WYNmz.s:3543   .text.I2C_SlaveTransferNonBlocking:0000000000000000 $t
     /tmp/cc1WYNmz.s:3550   .text.I2C_SlaveTransferNonBlocking:0000000000000000 I2C_SlaveTransferNonBlocking
     /tmp/cc1WYNmz.s:3631   .text.I2C_SlaveTransferNonBlocking:000000000000004c $d
     /tmp/cc1WYNmz.s:3636   .text.I2C_SlaveTransferAbort:0000000000000000 $t
     /tmp/cc1WYNmz.s:3643   .text.I2C_SlaveTransferAbort:0000000000000000 I2C_SlaveTransferAbort
     /tmp/cc1WYNmz.s:3687   .text.I2C_SlaveTransferGetCount:0000000000000000 $t
     /tmp/cc1WYNmz.s:3694   .text.I2C_SlaveTransferGetCount:0000000000000000 I2C_SlaveTransferGetCount
     /tmp/cc1WYNmz.s:3737   .text.I2C0_DriverIRQHandler:0000000000000000 $t
     /tmp/cc1WYNmz.s:3744   .text.I2C0_DriverIRQHandler:0000000000000000 I2C0_DriverIRQHandler
     /tmp/cc1WYNmz.s:3766   .text.I2C0_DriverIRQHandler:0000000000000010 $d
     /tmp/cc1WYNmz.s:3772   .text.I2C1_DriverIRQHandler:0000000000000000 $t
     /tmp/cc1WYNmz.s:3779   .text.I2C1_DriverIRQHandler:0000000000000000 I2C1_DriverIRQHandler
     /tmp/cc1WYNmz.s:3801   .text.I2C1_DriverIRQHandler:0000000000000010 $d
     /tmp/cc1WYNmz.s:3807   .bss.s_i2cHandle:0000000000000000 $d
     /tmp/cc1WYNmz.s:3811   .bss.s_i2cHandle:0000000000000000 s_i2cHandle
     /tmp/cc1WYNmz.s:3814   .bss.s_i2cMasterIsr:0000000000000000 $d
     /tmp/cc1WYNmz.s:3818   .bss.s_i2cMasterIsr:0000000000000000 s_i2cMasterIsr
     /tmp/cc1WYNmz.s:3821   .bss.s_i2cSlaveIsr:0000000000000000 $d
     /tmp/cc1WYNmz.s:3825   .bss.s_i2cSlaveIsr:0000000000000000 s_i2cSlaveIsr
     /tmp/cc1WYNmz.s:3828   .rodata.s_i2cBases:0000000000000000 $d
     /tmp/cc1WYNmz.s:3832   .rodata.s_i2cBases:0000000000000000 s_i2cBases
     /tmp/cc1WYNmz.s:3836   .rodata.s_i2cClocks:0000000000000000 $d
     /tmp/cc1WYNmz.s:3840   .rodata.s_i2cClocks:0000000000000000 s_i2cClocks
     /tmp/cc1WYNmz.s:3844   .rodata.s_i2cDividerTable:0000000000000000 $d
     /tmp/cc1WYNmz.s:3913   .rodata.s_i2cIrqs:0000000000000000 $d
     /tmp/cc1WYNmz.s:3917   .rodata.s_i2cIrqs:0000000000000000 s_i2cIrqs

UNDEFINED SYMBOLS
__aeabi_uidiv
memset
