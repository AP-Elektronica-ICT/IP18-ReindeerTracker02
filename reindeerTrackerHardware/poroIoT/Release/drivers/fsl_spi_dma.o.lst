   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_spi_dma.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.SPI_TxDMACallback,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	SPI_TxDMACallback:
  23              	.LFB82:
  24              		.file 1 "../drivers/fsl_spi_dma.c"
   1:../drivers/fsl_spi_dma.c **** /*
   2:../drivers/fsl_spi_dma.c ****  * The Clear BSD License
   3:../drivers/fsl_spi_dma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_spi_dma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_spi_dma.c ****  * All rights reserved.
   6:../drivers/fsl_spi_dma.c ****  *
   7:../drivers/fsl_spi_dma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_spi_dma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_spi_dma.c ****  * that the following conditions are met:
  10:../drivers/fsl_spi_dma.c ****  *
  11:../drivers/fsl_spi_dma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_spi_dma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_spi_dma.c ****  *
  14:../drivers/fsl_spi_dma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_spi_dma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_spi_dma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_spi_dma.c ****  *
  18:../drivers/fsl_spi_dma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_spi_dma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_spi_dma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_spi_dma.c ****  *
  22:../drivers/fsl_spi_dma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_spi_dma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_spi_dma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_spi_dma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_spi_dma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_spi_dma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_spi_dma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_spi_dma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_spi_dma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_spi_dma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_spi_dma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_spi_dma.c ****  */
  34:../drivers/fsl_spi_dma.c **** 
  35:../drivers/fsl_spi_dma.c **** #include "fsl_spi_dma.h"
  36:../drivers/fsl_spi_dma.c **** 
  37:../drivers/fsl_spi_dma.c **** /*******************************************************************************
  38:../drivers/fsl_spi_dma.c ****  * Definitons
  39:../drivers/fsl_spi_dma.c ****  ******************************************************************************/
  40:../drivers/fsl_spi_dma.c **** /*<! Structure definition for spi_dma_private_handle_t. The structure is private. */
  41:../drivers/fsl_spi_dma.c **** typedef struct _spi_dma_private_handle
  42:../drivers/fsl_spi_dma.c **** {
  43:../drivers/fsl_spi_dma.c ****     SPI_Type *base;
  44:../drivers/fsl_spi_dma.c ****     spi_dma_handle_t *handle;
  45:../drivers/fsl_spi_dma.c **** } spi_dma_private_handle_t;
  46:../drivers/fsl_spi_dma.c **** 
  47:../drivers/fsl_spi_dma.c **** /*! @brief SPI transfer state, which is used for SPI transactiaonl APIs' internal state. */
  48:../drivers/fsl_spi_dma.c **** enum _spi_dma_states_t
  49:../drivers/fsl_spi_dma.c **** {
  50:../drivers/fsl_spi_dma.c ****     kSPI_Idle = 0x0, /*!< SPI is idle state */
  51:../drivers/fsl_spi_dma.c ****     kSPI_Busy        /*!< SPI is busy tranferring data. */
  52:../drivers/fsl_spi_dma.c **** };
  53:../drivers/fsl_spi_dma.c **** 
  54:../drivers/fsl_spi_dma.c **** /*<! Private handle only used for internally. */
  55:../drivers/fsl_spi_dma.c **** static spi_dma_private_handle_t s_dmaPrivateHandle[FSL_FEATURE_SOC_SPI_COUNT];
  56:../drivers/fsl_spi_dma.c **** /*******************************************************************************
  57:../drivers/fsl_spi_dma.c ****  * Prototypes
  58:../drivers/fsl_spi_dma.c ****  ******************************************************************************/
  59:../drivers/fsl_spi_dma.c **** /*!
  60:../drivers/fsl_spi_dma.c ****  * @brief Get the instance for SPI module.
  61:../drivers/fsl_spi_dma.c ****  *
  62:../drivers/fsl_spi_dma.c ****  * @param base SPI base address
  63:../drivers/fsl_spi_dma.c ****  */
  64:../drivers/fsl_spi_dma.c **** extern uint32_t SPI_GetInstance(SPI_Type *base);
  65:../drivers/fsl_spi_dma.c **** 
  66:../drivers/fsl_spi_dma.c **** /*!
  67:../drivers/fsl_spi_dma.c ****  * @brief DMA callback function for SPI send transfer.
  68:../drivers/fsl_spi_dma.c ****  *
  69:../drivers/fsl_spi_dma.c ****  * @param handle DMA handle pointer.
  70:../drivers/fsl_spi_dma.c ****  * @param userData User data for DMA callback function.
  71:../drivers/fsl_spi_dma.c ****  */
  72:../drivers/fsl_spi_dma.c **** static void SPI_TxDMACallback(dma_handle_t *handle, void *userData);
  73:../drivers/fsl_spi_dma.c **** 
  74:../drivers/fsl_spi_dma.c **** /*!
  75:../drivers/fsl_spi_dma.c ****  * @brief DMA callback function for SPI receive transfer.
  76:../drivers/fsl_spi_dma.c ****  *
  77:../drivers/fsl_spi_dma.c ****  * @param handle DMA handle pointer.
  78:../drivers/fsl_spi_dma.c ****  * @param userData User data for DMA callback function.
  79:../drivers/fsl_spi_dma.c ****  */
  80:../drivers/fsl_spi_dma.c **** static void SPI_RxDMACallback(dma_handle_t *handle, void *userData);
  81:../drivers/fsl_spi_dma.c **** 
  82:../drivers/fsl_spi_dma.c **** /*******************************************************************************
  83:../drivers/fsl_spi_dma.c ****  * Variables
  84:../drivers/fsl_spi_dma.c ****  ******************************************************************************/
  85:../drivers/fsl_spi_dma.c **** 
  86:../drivers/fsl_spi_dma.c **** /*! @brief Global variable for dummy data value setting. */
  87:../drivers/fsl_spi_dma.c **** extern volatile uint8_t s_dummyData[];
  88:../drivers/fsl_spi_dma.c **** /*******************************************************************************
  89:../drivers/fsl_spi_dma.c **** * Code
  90:../drivers/fsl_spi_dma.c **** ******************************************************************************/
  91:../drivers/fsl_spi_dma.c **** static void SPI_TxDMACallback(dma_handle_t *handle, void *userData)
  92:../drivers/fsl_spi_dma.c **** {
  25              		.loc 1 92 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 70B5     		push	{r4, r5, r6, lr}
  31              		.cfi_def_cfa_offset 16
  32              		.cfi_offset 4, -16
  33              		.cfi_offset 5, -12
  34              		.cfi_offset 6, -8
  35              		.cfi_offset 14, -4
  36              	.LVL1:
  93:../drivers/fsl_spi_dma.c ****     spi_dma_private_handle_t *privHandle = (spi_dma_private_handle_t *)userData;
  94:../drivers/fsl_spi_dma.c ****     spi_dma_handle_t *spiHandle = privHandle->handle;
  37              		.loc 1 94 0
  38 0002 4C68     		ldr	r4, [r1, #4]
  39              	.LVL2:
  95:../drivers/fsl_spi_dma.c ****     SPI_Type *base = privHandle->base;
  40              		.loc 1 95 0
  41 0004 0868     		ldr	r0, [r1]
  42              	.LVL3:
  43              	.LBB42:
  44              	.LBB43:
  45              		.file 2 "../drivers/fsl_spi.h"
   1:../drivers/fsl_spi.h **** /*
   2:../drivers/fsl_spi.h ****  * The Clear BSD License
   3:../drivers/fsl_spi.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_spi.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_spi.h ****  * All rights reserved.
   6:../drivers/fsl_spi.h ****  *
   7:../drivers/fsl_spi.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_spi.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_spi.h ****  * that the following conditions are met:
  10:../drivers/fsl_spi.h ****  *
  11:../drivers/fsl_spi.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_spi.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_spi.h ****  *
  14:../drivers/fsl_spi.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_spi.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_spi.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_spi.h ****  *
  18:../drivers/fsl_spi.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_spi.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_spi.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_spi.h ****  *
  22:../drivers/fsl_spi.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_spi.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_spi.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_spi.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_spi.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_spi.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_spi.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_spi.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_spi.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_spi.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_spi.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_spi.h ****  */
  34:../drivers/fsl_spi.h **** #ifndef _FSL_SPI_H_
  35:../drivers/fsl_spi.h **** #define _FSL_SPI_H_
  36:../drivers/fsl_spi.h **** 
  37:../drivers/fsl_spi.h **** #include "fsl_common.h"
  38:../drivers/fsl_spi.h **** 
  39:../drivers/fsl_spi.h **** /*!
  40:../drivers/fsl_spi.h ****  * @addtogroup spi_driver
  41:../drivers/fsl_spi.h ****  * @{
  42:../drivers/fsl_spi.h ****  */
  43:../drivers/fsl_spi.h **** 
  44:../drivers/fsl_spi.h **** /*******************************************************************************
  45:../drivers/fsl_spi.h ****  * Definitions
  46:../drivers/fsl_spi.h ****  ******************************************************************************/
  47:../drivers/fsl_spi.h **** 
  48:../drivers/fsl_spi.h **** /*! @name Driver version */
  49:../drivers/fsl_spi.h **** /*@{*/
  50:../drivers/fsl_spi.h **** /*! @brief SPI driver version 2.0.4. */
  51:../drivers/fsl_spi.h **** #define FSL_SPI_DRIVER_VERSION (MAKE_VERSION(2, 0, 4))
  52:../drivers/fsl_spi.h **** /*@}*/
  53:../drivers/fsl_spi.h **** 
  54:../drivers/fsl_spi.h **** #ifndef SPI_DUMMYDATA
  55:../drivers/fsl_spi.h **** /*! @brief SPI dummy transfer data, the data is sent while txBuff is NULL. */
  56:../drivers/fsl_spi.h **** #define SPI_DUMMYDATA (0xFFU)
  57:../drivers/fsl_spi.h **** #endif
  58:../drivers/fsl_spi.h **** 
  59:../drivers/fsl_spi.h **** /*! @brief Return status for the SPI driver.*/
  60:../drivers/fsl_spi.h **** enum _spi_status
  61:../drivers/fsl_spi.h **** {
  62:../drivers/fsl_spi.h ****     kStatus_SPI_Busy = MAKE_STATUS(kStatusGroup_SPI, 0), /*!< SPI bus is busy */
  63:../drivers/fsl_spi.h ****     kStatus_SPI_Idle = MAKE_STATUS(kStatusGroup_SPI, 1), /*!< SPI is idle */
  64:../drivers/fsl_spi.h ****     kStatus_SPI_Error = MAKE_STATUS(kStatusGroup_SPI, 2) /*!< SPI  error */
  65:../drivers/fsl_spi.h **** };
  66:../drivers/fsl_spi.h **** 
  67:../drivers/fsl_spi.h **** /*! @brief SPI clock polarity configuration.*/
  68:../drivers/fsl_spi.h **** typedef enum _spi_clock_polarity
  69:../drivers/fsl_spi.h **** {
  70:../drivers/fsl_spi.h ****     kSPI_ClockPolarityActiveHigh = 0x0U, /*!< Active-high SPI clock (idles low). */
  71:../drivers/fsl_spi.h ****     kSPI_ClockPolarityActiveLow          /*!< Active-low SPI clock (idles high). */
  72:../drivers/fsl_spi.h **** } spi_clock_polarity_t;
  73:../drivers/fsl_spi.h **** 
  74:../drivers/fsl_spi.h **** /*! @brief SPI clock phase configuration.*/
  75:../drivers/fsl_spi.h **** typedef enum _spi_clock_phase
  76:../drivers/fsl_spi.h **** {
  77:../drivers/fsl_spi.h ****     kSPI_ClockPhaseFirstEdge = 0x0U, /*!< First edge on SPSCK occurs at the middle of the first
  78:../drivers/fsl_spi.h ****                                       *   cycle of a data transfer. */
  79:../drivers/fsl_spi.h ****     kSPI_ClockPhaseSecondEdge        /*!< First edge on SPSCK occurs at the start of the
  80:../drivers/fsl_spi.h ****                                       *   first cycle of a data transfer. */
  81:../drivers/fsl_spi.h **** } spi_clock_phase_t;
  82:../drivers/fsl_spi.h **** 
  83:../drivers/fsl_spi.h **** /*! @brief SPI data shifter direction options.*/
  84:../drivers/fsl_spi.h **** typedef enum _spi_shift_direction
  85:../drivers/fsl_spi.h **** {
  86:../drivers/fsl_spi.h ****     kSPI_MsbFirst = 0x0U, /*!< Data transfers start with most significant bit. */
  87:../drivers/fsl_spi.h ****     kSPI_LsbFirst         /*!< Data transfers start with least significant bit. */
  88:../drivers/fsl_spi.h **** } spi_shift_direction_t;
  89:../drivers/fsl_spi.h **** 
  90:../drivers/fsl_spi.h **** /*! @brief SPI slave select output mode options.*/
  91:../drivers/fsl_spi.h **** typedef enum _spi_ss_output_mode
  92:../drivers/fsl_spi.h **** {
  93:../drivers/fsl_spi.h ****     kSPI_SlaveSelectAsGpio = 0x0U,         /*!< Slave select pin configured as GPIO. */
  94:../drivers/fsl_spi.h ****     kSPI_SlaveSelectFaultInput = 0x2U,     /*!< Slave select pin configured for fault detection. */
  95:../drivers/fsl_spi.h ****     kSPI_SlaveSelectAutomaticOutput = 0x3U /*!< Slave select pin configured for automatic SPI outpu
  96:../drivers/fsl_spi.h **** } spi_ss_output_mode_t;
  97:../drivers/fsl_spi.h **** 
  98:../drivers/fsl_spi.h **** /*! @brief SPI pin mode options.*/
  99:../drivers/fsl_spi.h **** typedef enum _spi_pin_mode
 100:../drivers/fsl_spi.h **** {
 101:../drivers/fsl_spi.h ****     kSPI_PinModeNormal = 0x0U, /*!< Pins operate in normal, single-direction mode.*/
 102:../drivers/fsl_spi.h ****     kSPI_PinModeInput = 0x1U,  /*!< Bidirectional mode. Master: MOSI pin is input;
 103:../drivers/fsl_spi.h ****                                 *   Slave: MISO pin is input. */
 104:../drivers/fsl_spi.h ****     kSPI_PinModeOutput = 0x3U  /*!< Bidirectional mode. Master: MOSI pin is output;
 105:../drivers/fsl_spi.h ****                                 *   Slave: MISO pin is output. */
 106:../drivers/fsl_spi.h **** } spi_pin_mode_t;
 107:../drivers/fsl_spi.h **** 
 108:../drivers/fsl_spi.h **** /*! @brief SPI data length mode options.*/
 109:../drivers/fsl_spi.h **** typedef enum _spi_data_bitcount_mode
 110:../drivers/fsl_spi.h **** {
 111:../drivers/fsl_spi.h ****     kSPI_8BitMode = 0x0U, /*!< 8-bit data transmission mode*/
 112:../drivers/fsl_spi.h ****     kSPI_16BitMode        /*!< 16-bit data transmission mode*/
 113:../drivers/fsl_spi.h **** } spi_data_bitcount_mode_t;
 114:../drivers/fsl_spi.h **** 
 115:../drivers/fsl_spi.h **** /*! @brief SPI interrupt sources.*/
 116:../drivers/fsl_spi.h **** enum _spi_interrupt_enable
 117:../drivers/fsl_spi.h **** {
 118:../drivers/fsl_spi.h ****     kSPI_RxFullAndModfInterruptEnable = 0x1U, /*!< Receive buffer full (SPRF) and mode fault (MODF)
 119:../drivers/fsl_spi.h ****     kSPI_TxEmptyInterruptEnable = 0x2U,       /*!< Transmit buffer empty interrupt */
 120:../drivers/fsl_spi.h ****     kSPI_MatchInterruptEnable = 0x4U,         /*!< Match interrupt */
 121:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 122:../drivers/fsl_spi.h ****     kSPI_RxFifoNearFullInterruptEnable = 0x8U,   /*!< Receive FIFO nearly full interrupt */
 123:../drivers/fsl_spi.h ****     kSPI_TxFifoNearEmptyInterruptEnable = 0x10U, /*!< Transmit FIFO nearly empty interrupt */
 124:../drivers/fsl_spi.h **** #endif                                           /* FSL_FEATURE_SPI_HAS_FIFO */
 125:../drivers/fsl_spi.h **** };
 126:../drivers/fsl_spi.h **** 
 127:../drivers/fsl_spi.h **** /*! @brief SPI status flags.*/
 128:../drivers/fsl_spi.h **** enum _spi_flags
 129:../drivers/fsl_spi.h **** {
 130:../drivers/fsl_spi.h ****     kSPI_RxBufferFullFlag = SPI_S_SPRF_MASK,   /*!< Read buffer full flag */
 131:../drivers/fsl_spi.h ****     kSPI_MatchFlag = SPI_S_SPMF_MASK,          /*!< Match flag */
 132:../drivers/fsl_spi.h ****     kSPI_TxBufferEmptyFlag = SPI_S_SPTEF_MASK, /*!< Transmit buffer empty flag */
 133:../drivers/fsl_spi.h ****     kSPI_ModeFaultFlag = SPI_S_MODF_MASK,      /*!< Mode fault flag */
 134:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 135:../drivers/fsl_spi.h ****     kSPI_RxFifoNearFullFlag = SPI_S_RNFULLF_MASK,  /*!< Rx FIFO near full */
 136:../drivers/fsl_spi.h ****     kSPI_TxFifoNearEmptyFlag = SPI_S_TNEAREF_MASK, /*!< Tx FIFO near empty */
 137:../drivers/fsl_spi.h ****     kSPI_TxFifoFullFlag = SPI_S_TXFULLF_MASK,      /*!< Tx FIFO full */
 138:../drivers/fsl_spi.h ****     kSPI_RxFifoEmptyFlag = SPI_S_RFIFOEF_MASK,     /*!< Rx FIFO empty */
 139:../drivers/fsl_spi.h ****     kSPI_TxFifoError = SPI_CI_TXFERR_MASK << 8U,   /*!< Tx FIFO error */
 140:../drivers/fsl_spi.h ****     kSPI_RxFifoError = SPI_CI_RXFERR_MASK << 8U,   /*!< Rx FIFO error */
 141:../drivers/fsl_spi.h ****     kSPI_TxOverflow = SPI_CI_TXFOF_MASK << 8U,     /*!< Tx FIFO Overflow */
 142:../drivers/fsl_spi.h ****     kSPI_RxOverflow = SPI_CI_RXFOF_MASK << 8U      /*!< Rx FIFO Overflow */
 143:../drivers/fsl_spi.h **** #endif                                             /* FSL_FEATURE_SPI_HAS_FIFO */
 144:../drivers/fsl_spi.h **** };
 145:../drivers/fsl_spi.h **** 
 146:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 147:../drivers/fsl_spi.h **** /*! @brief SPI FIFO write-1-to-clear interrupt flags.*/
 148:../drivers/fsl_spi.h **** typedef enum _spi_w1c_interrupt
 149:../drivers/fsl_spi.h **** {
 150:../drivers/fsl_spi.h ****     kSPI_RxFifoFullClearInterrupt = SPI_CI_SPRFCI_MASK,    /*!< Receive FIFO full interrupt */
 151:../drivers/fsl_spi.h ****     kSPI_TxFifoEmptyClearInterrupt = SPI_CI_SPTEFCI_MASK,  /*!< Transmit FIFO empty interrupt */
 152:../drivers/fsl_spi.h ****     kSPI_RxNearFullClearInterrupt = SPI_CI_RNFULLFCI_MASK, /*!< Receive FIFO nearly full interrupt 
 153:../drivers/fsl_spi.h ****     kSPI_TxNearEmptyClearInterrupt = SPI_CI_TNEAREFCI_MASK /*!< Transmit FIFO nearly empty interrup
 154:../drivers/fsl_spi.h **** } spi_w1c_interrupt_t;
 155:../drivers/fsl_spi.h **** 
 156:../drivers/fsl_spi.h **** /*! @brief SPI TX FIFO watermark settings.*/
 157:../drivers/fsl_spi.h **** typedef enum _spi_txfifo_watermark
 158:../drivers/fsl_spi.h **** {
 159:../drivers/fsl_spi.h ****     kSPI_TxFifoOneFourthEmpty = 0, /*!< SPI tx watermark at 1/4 FIFO size */
 160:../drivers/fsl_spi.h ****     kSPI_TxFifoOneHalfEmpty = 1    /*!< SPI tx watermark at 1/2 FIFO size */
 161:../drivers/fsl_spi.h **** } spi_txfifo_watermark_t;
 162:../drivers/fsl_spi.h **** 
 163:../drivers/fsl_spi.h **** /*! @brief SPI RX FIFO watermark settings.*/
 164:../drivers/fsl_spi.h **** typedef enum _spi_rxfifo_watermark
 165:../drivers/fsl_spi.h **** {
 166:../drivers/fsl_spi.h ****     kSPI_RxFifoThreeFourthsFull = 0, /*!< SPI rx watermark at 3/4 FIFO size */
 167:../drivers/fsl_spi.h ****     kSPI_RxFifoOneHalfFull = 1       /*!< SPI rx watermark at 1/2 FIFO size */
 168:../drivers/fsl_spi.h **** } spi_rxfifo_watermark_t;
 169:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 170:../drivers/fsl_spi.h **** 
 171:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_DMA_SUPPORT) && FSL_FEATURE_SPI_HAS_DMA_SUPPORT
 172:../drivers/fsl_spi.h **** /*! @brief SPI DMA source*/
 173:../drivers/fsl_spi.h **** enum _spi_dma_enable_t
 174:../drivers/fsl_spi.h **** {
 175:../drivers/fsl_spi.h ****     kSPI_TxDmaEnable = SPI_C2_TXDMAE_MASK,                        /*!< Tx DMA request source */
 176:../drivers/fsl_spi.h ****     kSPI_RxDmaEnable = SPI_C2_RXDMAE_MASK,                        /*!< Rx DMA request source */
 177:../drivers/fsl_spi.h ****     kSPI_DmaAllEnable = (SPI_C2_TXDMAE_MASK | SPI_C2_RXDMAE_MASK) /*!< All DMA request source*/
 178:../drivers/fsl_spi.h **** };
 179:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_DMA_SUPPORT */
 180:../drivers/fsl_spi.h **** 
 181:../drivers/fsl_spi.h **** /*! @brief SPI master user configure structure.*/
 182:../drivers/fsl_spi.h **** typedef struct _spi_master_config
 183:../drivers/fsl_spi.h **** {
 184:../drivers/fsl_spi.h ****     bool enableMaster;               /*!< Enable SPI at initialization time */
 185:../drivers/fsl_spi.h ****     bool enableStopInWaitMode;       /*!< SPI stop in wait mode */
 186:../drivers/fsl_spi.h ****     spi_clock_polarity_t polarity;   /*!< Clock polarity */
 187:../drivers/fsl_spi.h ****     spi_clock_phase_t phase;         /*!< Clock phase */
 188:../drivers/fsl_spi.h ****     spi_shift_direction_t direction; /*!< MSB or LSB */
 189:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 190:../drivers/fsl_spi.h ****     spi_data_bitcount_mode_t dataMode; /*!< 8bit or 16bit mode */
 191:../drivers/fsl_spi.h **** #endif                                 /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 192:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 193:../drivers/fsl_spi.h ****     spi_txfifo_watermark_t txWatermark; /*!< Tx watermark settings */
 194:../drivers/fsl_spi.h ****     spi_rxfifo_watermark_t rxWatermark; /*!< Rx watermark settings */
 195:../drivers/fsl_spi.h **** #endif                                  /* FSL_FEATURE_SPI_HAS_FIFO */
 196:../drivers/fsl_spi.h ****     spi_ss_output_mode_t outputMode;    /*!< SS pin setting */
 197:../drivers/fsl_spi.h ****     spi_pin_mode_t pinMode;             /*!< SPI pin mode select */
 198:../drivers/fsl_spi.h ****     uint32_t baudRate_Bps;              /*!< Baud Rate for SPI in Hz */
 199:../drivers/fsl_spi.h **** } spi_master_config_t;
 200:../drivers/fsl_spi.h **** 
 201:../drivers/fsl_spi.h **** /*! @brief SPI slave user configure structure.*/
 202:../drivers/fsl_spi.h **** typedef struct _spi_slave_config
 203:../drivers/fsl_spi.h **** {
 204:../drivers/fsl_spi.h ****     bool enableSlave;                /*!< Enable SPI at initialization time */
 205:../drivers/fsl_spi.h ****     bool enableStopInWaitMode;       /*!< SPI stop in wait mode */
 206:../drivers/fsl_spi.h ****     spi_clock_polarity_t polarity;   /*!< Clock polarity */
 207:../drivers/fsl_spi.h ****     spi_clock_phase_t phase;         /*!< Clock phase */
 208:../drivers/fsl_spi.h ****     spi_shift_direction_t direction; /*!< MSB or LSB */
 209:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 210:../drivers/fsl_spi.h ****     spi_data_bitcount_mode_t dataMode; /*!< 8bit or 16bit mode */
 211:../drivers/fsl_spi.h **** #endif                                 /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 212:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 213:../drivers/fsl_spi.h ****     spi_txfifo_watermark_t txWatermark; /*!< Tx watermark settings */
 214:../drivers/fsl_spi.h ****     spi_rxfifo_watermark_t rxWatermark; /*!< Rx watermark settings */
 215:../drivers/fsl_spi.h **** #endif                                  /* FSL_FEATURE_SPI_HAS_FIFO */
 216:../drivers/fsl_spi.h ****     spi_pin_mode_t pinMode;             /*!< SPI pin mode select */
 217:../drivers/fsl_spi.h **** } spi_slave_config_t;
 218:../drivers/fsl_spi.h **** 
 219:../drivers/fsl_spi.h **** /*! @brief SPI transfer structure */
 220:../drivers/fsl_spi.h **** typedef struct _spi_transfer
 221:../drivers/fsl_spi.h **** {
 222:../drivers/fsl_spi.h ****     uint8_t *txData; /*!< Send buffer */
 223:../drivers/fsl_spi.h ****     uint8_t *rxData; /*!< Receive buffer */
 224:../drivers/fsl_spi.h ****     size_t dataSize; /*!< Transfer bytes */
 225:../drivers/fsl_spi.h ****     uint32_t flags;  /*!< SPI control flag, useless to SPI.*/
 226:../drivers/fsl_spi.h **** } spi_transfer_t;
 227:../drivers/fsl_spi.h **** 
 228:../drivers/fsl_spi.h **** typedef struct _spi_master_handle spi_master_handle_t;
 229:../drivers/fsl_spi.h **** 
 230:../drivers/fsl_spi.h **** /*! @brief  Slave handle is the same with master handle  */
 231:../drivers/fsl_spi.h **** typedef spi_master_handle_t spi_slave_handle_t;
 232:../drivers/fsl_spi.h **** 
 233:../drivers/fsl_spi.h **** /*! @brief SPI master callback for finished transmit */
 234:../drivers/fsl_spi.h **** typedef void (*spi_master_callback_t)(SPI_Type *base, spi_master_handle_t *handle, status_t status,
 235:../drivers/fsl_spi.h **** 
 236:../drivers/fsl_spi.h **** /*! @brief SPI master callback for finished transmit */
 237:../drivers/fsl_spi.h **** typedef void (*spi_slave_callback_t)(SPI_Type *base, spi_slave_handle_t *handle, status_t status, v
 238:../drivers/fsl_spi.h **** 
 239:../drivers/fsl_spi.h **** /*! @brief SPI transfer handle structure */
 240:../drivers/fsl_spi.h **** struct _spi_master_handle
 241:../drivers/fsl_spi.h **** {
 242:../drivers/fsl_spi.h ****     uint8_t *volatile txData;         /*!< Transfer buffer */
 243:../drivers/fsl_spi.h ****     uint8_t *volatile rxData;         /*!< Receive buffer */
 244:../drivers/fsl_spi.h ****     volatile size_t txRemainingBytes; /*!< Send data remaining in bytes */
 245:../drivers/fsl_spi.h ****     volatile size_t rxRemainingBytes; /*!< Receive data remaining in bytes */
 246:../drivers/fsl_spi.h ****     volatile uint32_t state;          /*!< SPI internal state */
 247:../drivers/fsl_spi.h ****     size_t transferSize;              /*!< Bytes to be transferred */
 248:../drivers/fsl_spi.h ****     uint8_t bytePerFrame;             /*!< SPI mode, 2bytes or 1byte in a frame */
 249:../drivers/fsl_spi.h ****     uint8_t watermark;                /*!< Watermark value for SPI transfer */
 250:../drivers/fsl_spi.h ****     spi_master_callback_t callback;   /*!< SPI callback */
 251:../drivers/fsl_spi.h ****     void *userData;                   /*!< Callback parameter */
 252:../drivers/fsl_spi.h **** };
 253:../drivers/fsl_spi.h **** 
 254:../drivers/fsl_spi.h **** #if defined(__cplusplus)
 255:../drivers/fsl_spi.h **** extern "C" {
 256:../drivers/fsl_spi.h **** #endif
 257:../drivers/fsl_spi.h **** /*******************************************************************************
 258:../drivers/fsl_spi.h ****  * APIs
 259:../drivers/fsl_spi.h ****  ******************************************************************************/
 260:../drivers/fsl_spi.h **** /*!
 261:../drivers/fsl_spi.h ****  * @name Initialization and deinitialization
 262:../drivers/fsl_spi.h ****  * @{
 263:../drivers/fsl_spi.h ****  */
 264:../drivers/fsl_spi.h **** 
 265:../drivers/fsl_spi.h **** /*!
 266:../drivers/fsl_spi.h ****  * @brief  Sets the SPI master configuration structure to default values.
 267:../drivers/fsl_spi.h ****  *
 268:../drivers/fsl_spi.h ****  * The purpose of this API is to get the configuration structure initialized for use in SPI_MasterI
 269:../drivers/fsl_spi.h ****  * User may use the initialized structure unchanged in SPI_MasterInit(), or modify
 270:../drivers/fsl_spi.h ****  * some fields of the structure before calling SPI_MasterInit(). After calling this API,
 271:../drivers/fsl_spi.h ****  * the master is ready to transfer.
 272:../drivers/fsl_spi.h ****  * Example:
 273:../drivers/fsl_spi.h ****    @code
 274:../drivers/fsl_spi.h ****    spi_master_config_t config;
 275:../drivers/fsl_spi.h ****    SPI_MasterGetDefaultConfig(&config);
 276:../drivers/fsl_spi.h ****    @endcode
 277:../drivers/fsl_spi.h ****  *
 278:../drivers/fsl_spi.h ****  * @param config pointer to master config structure
 279:../drivers/fsl_spi.h ****  */
 280:../drivers/fsl_spi.h **** void SPI_MasterGetDefaultConfig(spi_master_config_t *config);
 281:../drivers/fsl_spi.h **** 
 282:../drivers/fsl_spi.h **** /*!
 283:../drivers/fsl_spi.h ****  * @brief Initializes the SPI with master configuration.
 284:../drivers/fsl_spi.h ****  *
 285:../drivers/fsl_spi.h ****  * The configuration structure can be filled by user from scratch, or be set with default
 286:../drivers/fsl_spi.h ****  * values by SPI_MasterGetDefaultConfig(). After calling this API, the slave is ready to transfer.
 287:../drivers/fsl_spi.h ****  * Example
 288:../drivers/fsl_spi.h ****    @code
 289:../drivers/fsl_spi.h ****    spi_master_config_t config = {
 290:../drivers/fsl_spi.h ****    .baudRate_Bps = 400000,
 291:../drivers/fsl_spi.h ****    ...
 292:../drivers/fsl_spi.h ****    };
 293:../drivers/fsl_spi.h ****    SPI_MasterInit(SPI0, &config);
 294:../drivers/fsl_spi.h ****    @endcode
 295:../drivers/fsl_spi.h ****  *
 296:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 297:../drivers/fsl_spi.h ****  * @param config pointer to master configuration structure
 298:../drivers/fsl_spi.h ****  * @param srcClock_Hz Source clock frequency.
 299:../drivers/fsl_spi.h ****  */
 300:../drivers/fsl_spi.h **** void SPI_MasterInit(SPI_Type *base, const spi_master_config_t *config, uint32_t srcClock_Hz);
 301:../drivers/fsl_spi.h **** 
 302:../drivers/fsl_spi.h **** /*!
 303:../drivers/fsl_spi.h ****  * @brief  Sets the SPI slave configuration structure to default values.
 304:../drivers/fsl_spi.h ****  *
 305:../drivers/fsl_spi.h ****  * The purpose of this API is to get the configuration structure initialized for use in SPI_SlaveIn
 306:../drivers/fsl_spi.h ****  * Modify some fields of the structure before calling SPI_SlaveInit().
 307:../drivers/fsl_spi.h ****  * Example:
 308:../drivers/fsl_spi.h ****    @code
 309:../drivers/fsl_spi.h ****    spi_slave_config_t config;
 310:../drivers/fsl_spi.h ****    SPI_SlaveGetDefaultConfig(&config);
 311:../drivers/fsl_spi.h ****    @endcode
 312:../drivers/fsl_spi.h ****  *
 313:../drivers/fsl_spi.h ****  * @param config pointer to slave configuration structure
 314:../drivers/fsl_spi.h ****  */
 315:../drivers/fsl_spi.h **** void SPI_SlaveGetDefaultConfig(spi_slave_config_t *config);
 316:../drivers/fsl_spi.h **** 
 317:../drivers/fsl_spi.h **** /*!
 318:../drivers/fsl_spi.h ****  * @brief Initializes the SPI with slave configuration.
 319:../drivers/fsl_spi.h ****  *
 320:../drivers/fsl_spi.h ****  * The configuration structure can be filled by user from scratch or be set with
 321:../drivers/fsl_spi.h ****  * default values by SPI_SlaveGetDefaultConfig().
 322:../drivers/fsl_spi.h ****  * After calling this API, the slave is ready to transfer.
 323:../drivers/fsl_spi.h ****  * Example
 324:../drivers/fsl_spi.h ****    @code
 325:../drivers/fsl_spi.h ****     spi_slave_config_t config = {
 326:../drivers/fsl_spi.h ****     .polarity = kSPIClockPolarity_ActiveHigh;
 327:../drivers/fsl_spi.h ****     .phase = kSPIClockPhase_FirstEdge;
 328:../drivers/fsl_spi.h ****     .direction = kSPIMsbFirst;
 329:../drivers/fsl_spi.h ****     ...
 330:../drivers/fsl_spi.h ****     };
 331:../drivers/fsl_spi.h ****     SPI_MasterInit(SPI0, &config);
 332:../drivers/fsl_spi.h ****    @endcode
 333:../drivers/fsl_spi.h ****  *
 334:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 335:../drivers/fsl_spi.h ****  * @param config pointer to master configuration structure
 336:../drivers/fsl_spi.h ****  */
 337:../drivers/fsl_spi.h **** void SPI_SlaveInit(SPI_Type *base, const spi_slave_config_t *config);
 338:../drivers/fsl_spi.h **** 
 339:../drivers/fsl_spi.h **** /*!
 340:../drivers/fsl_spi.h ****  * @brief De-initializes the SPI.
 341:../drivers/fsl_spi.h ****  *
 342:../drivers/fsl_spi.h ****  * Calling this API resets the SPI module, gates the SPI clock.
 343:../drivers/fsl_spi.h ****  * The SPI module can't work unless calling the SPI_MasterInit/SPI_SlaveInit to initialize module.
 344:../drivers/fsl_spi.h ****  *
 345:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 346:../drivers/fsl_spi.h ****  */
 347:../drivers/fsl_spi.h **** void SPI_Deinit(SPI_Type *base);
 348:../drivers/fsl_spi.h **** 
 349:../drivers/fsl_spi.h **** /*!
 350:../drivers/fsl_spi.h ****  * @brief Enables or disables the SPI.
 351:../drivers/fsl_spi.h ****  *
 352:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 353:../drivers/fsl_spi.h ****  * @param enable pass true to enable module, false to disable module
 354:../drivers/fsl_spi.h ****  */
 355:../drivers/fsl_spi.h **** static inline void SPI_Enable(SPI_Type *base, bool enable)
 356:../drivers/fsl_spi.h **** {
 357:../drivers/fsl_spi.h ****     if (enable)
 358:../drivers/fsl_spi.h ****     {
 359:../drivers/fsl_spi.h ****         base->C1 |= SPI_C1_SPE_MASK;
 360:../drivers/fsl_spi.h ****     }
 361:../drivers/fsl_spi.h ****     else
 362:../drivers/fsl_spi.h ****     {
 363:../drivers/fsl_spi.h ****         base->C1 &= ~SPI_C1_SPE_MASK;
 364:../drivers/fsl_spi.h ****     }
 365:../drivers/fsl_spi.h **** }
 366:../drivers/fsl_spi.h **** 
 367:../drivers/fsl_spi.h **** /*! @} */
 368:../drivers/fsl_spi.h **** 
 369:../drivers/fsl_spi.h **** /*!
 370:../drivers/fsl_spi.h ****  * @name Status
 371:../drivers/fsl_spi.h ****  * @{
 372:../drivers/fsl_spi.h ****  */
 373:../drivers/fsl_spi.h **** 
 374:../drivers/fsl_spi.h **** /*!
 375:../drivers/fsl_spi.h ****  * @brief Gets the status flag.
 376:../drivers/fsl_spi.h ****  *
 377:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 378:../drivers/fsl_spi.h ****  * @return SPI Status, use status flag to AND #_spi_flags could get the related status.
 379:../drivers/fsl_spi.h ****  */
 380:../drivers/fsl_spi.h **** uint32_t SPI_GetStatusFlags(SPI_Type *base);
 381:../drivers/fsl_spi.h **** 
 382:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 383:../drivers/fsl_spi.h **** /*!
 384:../drivers/fsl_spi.h ****  * @brief Clear the interrupt if enable INCTLR.
 385:../drivers/fsl_spi.h ****  *
 386:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 387:../drivers/fsl_spi.h ****  * @param interrupt Interrupt need to be cleared
 388:../drivers/fsl_spi.h ****  *      The parameter could be any combination of the following values:
 389:../drivers/fsl_spi.h ****  *          @arg kSPIRxFifoFullClearInt
 390:../drivers/fsl_spi.h ****  *          @arg kSPITxFifoEmptyClearInt
 391:../drivers/fsl_spi.h ****  *          @arg kSPIRxNearFullClearInt
 392:../drivers/fsl_spi.h ****  *          @arg kSPITxNearEmptyClearInt
 393:../drivers/fsl_spi.h ****  */
 394:../drivers/fsl_spi.h **** static inline void SPI_ClearInterrupt(SPI_Type *base, uint32_t mask)
 395:../drivers/fsl_spi.h **** {
 396:../drivers/fsl_spi.h ****     base->CI |= mask;
 397:../drivers/fsl_spi.h **** }
 398:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 399:../drivers/fsl_spi.h **** 
 400:../drivers/fsl_spi.h **** /*! @} */
 401:../drivers/fsl_spi.h **** 
 402:../drivers/fsl_spi.h **** /*!
 403:../drivers/fsl_spi.h ****  * @name Interrupts
 404:../drivers/fsl_spi.h ****  * @{
 405:../drivers/fsl_spi.h ****  */
 406:../drivers/fsl_spi.h **** 
 407:../drivers/fsl_spi.h **** /*!
 408:../drivers/fsl_spi.h ****  * @brief Enables the interrupt for the SPI.
 409:../drivers/fsl_spi.h ****  *
 410:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 411:../drivers/fsl_spi.h ****  * @param mask SPI interrupt source. The parameter can be any combination of the following values:
 412:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFullAndModfInterruptEnable
 413:../drivers/fsl_spi.h ****  *        @arg kSPI_TxEmptyInterruptEnable
 414:../drivers/fsl_spi.h ****  *        @arg kSPI_MatchInterruptEnable
 415:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFifoNearFullInterruptEnable
 416:../drivers/fsl_spi.h ****  *        @arg kSPI_TxFifoNearEmptyInterruptEnable
 417:../drivers/fsl_spi.h ****  */
 418:../drivers/fsl_spi.h **** void SPI_EnableInterrupts(SPI_Type *base, uint32_t mask);
 419:../drivers/fsl_spi.h **** 
 420:../drivers/fsl_spi.h **** /*!
 421:../drivers/fsl_spi.h ****  * @brief Disables the interrupt for the SPI.
 422:../drivers/fsl_spi.h ****  *
 423:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 424:../drivers/fsl_spi.h ****  * @param mask SPI interrupt source. The parameter can be any combination of the following values:
 425:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFullAndModfInterruptEnable
 426:../drivers/fsl_spi.h ****  *        @arg kSPI_TxEmptyInterruptEnable
 427:../drivers/fsl_spi.h ****  *        @arg kSPI_MatchInterruptEnable
 428:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFifoNearFullInterruptEnable
 429:../drivers/fsl_spi.h ****  *        @arg kSPI_TxFifoNearEmptyInterruptEnable
 430:../drivers/fsl_spi.h ****  */
 431:../drivers/fsl_spi.h **** void SPI_DisableInterrupts(SPI_Type *base, uint32_t mask);
 432:../drivers/fsl_spi.h **** 
 433:../drivers/fsl_spi.h **** /*! @} */
 434:../drivers/fsl_spi.h **** 
 435:../drivers/fsl_spi.h **** /*!
 436:../drivers/fsl_spi.h ****  * @name DMA Control
 437:../drivers/fsl_spi.h ****  * @{
 438:../drivers/fsl_spi.h ****  */
 439:../drivers/fsl_spi.h **** 
 440:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_DMA_SUPPORT) && FSL_FEATURE_SPI_HAS_DMA_SUPPORT
 441:../drivers/fsl_spi.h **** /*!
 442:../drivers/fsl_spi.h ****  * @brief Enables the DMA source for SPI.
 443:../drivers/fsl_spi.h ****  *
 444:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 445:../drivers/fsl_spi.h ****  * @param source SPI DMA source.
 446:../drivers/fsl_spi.h ****  * @param enable True means enable DMA, false means disable DMA
 447:../drivers/fsl_spi.h ****  */
 448:../drivers/fsl_spi.h **** static inline void SPI_EnableDMA(SPI_Type *base, uint32_t mask, bool enable)
 449:../drivers/fsl_spi.h **** {
 450:../drivers/fsl_spi.h ****     if (enable)
 451:../drivers/fsl_spi.h ****     {
 452:../drivers/fsl_spi.h ****         base->C2 |= mask;
 453:../drivers/fsl_spi.h ****     }
 454:../drivers/fsl_spi.h ****     else
 455:../drivers/fsl_spi.h ****     {
 456:../drivers/fsl_spi.h ****         base->C2 &= ~mask;
  46              		.loc 2 456 0
  47 0006 8378     		ldrb	r3, [r0, #2]
  48 0008 2022     		movs	r2, #32
  49 000a 9343     		bics	r3, r2
  50 000c 8370     		strb	r3, [r0, #2]
  51              	.LVL4:
  52              	.LBE43:
  53              	.LBE42:
  96:../drivers/fsl_spi_dma.c **** 
  97:../drivers/fsl_spi_dma.c ****     /* Disable Tx dma */
  98:../drivers/fsl_spi_dma.c ****     SPI_EnableDMA(base, kSPI_TxDmaEnable, false);
  99:../drivers/fsl_spi_dma.c **** 
 100:../drivers/fsl_spi_dma.c ****     /* Stop DMA tranfer */
 101:../drivers/fsl_spi_dma.c ****     DMA_StopTransfer(spiHandle->txHandle);
  54              		.loc 1 101 0
  55 000e 6268     		ldr	r2, [r4, #4]
  56              	.LVL5:
  57              	.LBB44:
  58              	.LBB45:
  59              		.file 3 "../drivers/fsl_dma.h"
   1:../drivers/fsl_dma.h **** /*
   2:../drivers/fsl_dma.h ****  * The Clear BSD License
   3:../drivers/fsl_dma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dma.h ****  * All rights reserved.
   6:../drivers/fsl_dma.h ****  *
   7:../drivers/fsl_dma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dma.h ****  * that the following conditions are met:
  10:../drivers/fsl_dma.h ****  *
  11:../drivers/fsl_dma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dma.h ****  *
  14:../drivers/fsl_dma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dma.h ****  *
  18:../drivers/fsl_dma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dma.h ****  *
  22:../drivers/fsl_dma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dma.h ****  */
  34:../drivers/fsl_dma.h **** 
  35:../drivers/fsl_dma.h **** #ifndef _FSL_DMA_H_
  36:../drivers/fsl_dma.h **** #define _FSL_DMA_H_
  37:../drivers/fsl_dma.h **** 
  38:../drivers/fsl_dma.h **** #include "fsl_common.h"
  39:../drivers/fsl_dma.h **** 
  40:../drivers/fsl_dma.h **** /*!
  41:../drivers/fsl_dma.h ****  * @addtogroup dma
  42:../drivers/fsl_dma.h ****  * @{
  43:../drivers/fsl_dma.h ****  */
  44:../drivers/fsl_dma.h **** 
  45:../drivers/fsl_dma.h **** 
  46:../drivers/fsl_dma.h **** /*******************************************************************************
  47:../drivers/fsl_dma.h ****  * Definitions
  48:../drivers/fsl_dma.h ****  ******************************************************************************/
  49:../drivers/fsl_dma.h **** 
  50:../drivers/fsl_dma.h **** /*! @name Driver version */
  51:../drivers/fsl_dma.h **** /*@{*/
  52:../drivers/fsl_dma.h **** /*! @brief DMA driver version 2.0.1. */
  53:../drivers/fsl_dma.h **** #define FSL_DMA_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  54:../drivers/fsl_dma.h **** /*@}*/
  55:../drivers/fsl_dma.h **** 
  56:../drivers/fsl_dma.h **** /*! @brief status flag for the DMA driver. */
  57:../drivers/fsl_dma.h **** enum _dma_channel_status_flags
  58:../drivers/fsl_dma.h **** {
  59:../drivers/fsl_dma.h ****     kDMA_TransactionsBCRFlag = DMA_DSR_BCR_BCR_MASK,       /*!< Contains the number of bytes yet to
  60:../drivers/fsl_dma.h ****                                                                 transferred for a given block */
  61:../drivers/fsl_dma.h ****     kDMA_TransactionsDoneFlag = DMA_DSR_BCR_DONE_MASK,     /*!< Transactions Done */
  62:../drivers/fsl_dma.h ****     kDMA_TransactionsBusyFlag = DMA_DSR_BCR_BSY_MASK,      /*!< Transactions Busy */
  63:../drivers/fsl_dma.h ****     kDMA_TransactionsRequestFlag = DMA_DSR_BCR_REQ_MASK,   /*!< Transactions Request */
  64:../drivers/fsl_dma.h ****     kDMA_BusErrorOnDestinationFlag = DMA_DSR_BCR_BED_MASK, /*!< Bus Error on Destination */
  65:../drivers/fsl_dma.h ****     kDMA_BusErrorOnSourceFlag = DMA_DSR_BCR_BES_MASK,      /*!< Bus Error on Source */
  66:../drivers/fsl_dma.h ****     kDMA_ConfigurationErrorFlag = DMA_DSR_BCR_CE_MASK,     /*!< Configuration Error */
  67:../drivers/fsl_dma.h **** };
  68:../drivers/fsl_dma.h **** 
  69:../drivers/fsl_dma.h **** /*! @brief DMA transfer size type*/
  70:../drivers/fsl_dma.h **** typedef enum _dma_transfer_size
  71:../drivers/fsl_dma.h **** {
  72:../drivers/fsl_dma.h ****     kDMA_Transfersize32bits = 0x0U, /*!< 32 bits are transferred for every read/write */
  73:../drivers/fsl_dma.h ****     kDMA_Transfersize8bits,         /*!< 8 bits are transferred for every read/write */
  74:../drivers/fsl_dma.h ****     kDMA_Transfersize16bits,        /*!< 16b its are transferred for every read/write */
  75:../drivers/fsl_dma.h **** } dma_transfer_size_t;
  76:../drivers/fsl_dma.h **** 
  77:../drivers/fsl_dma.h **** /*! @brief Configuration type for the DMA modulo */
  78:../drivers/fsl_dma.h **** typedef enum _dma_modulo
  79:../drivers/fsl_dma.h **** {
  80:../drivers/fsl_dma.h ****     kDMA_ModuloDisable = 0x0U, /*!< Buffer disabled */
  81:../drivers/fsl_dma.h ****     kDMA_Modulo16Bytes,        /*!< Circular buffer size is 16 bytes. */
  82:../drivers/fsl_dma.h ****     kDMA_Modulo32Bytes,        /*!< Circular buffer size is 32 bytes. */
  83:../drivers/fsl_dma.h ****     kDMA_Modulo64Bytes,        /*!< Circular buffer size is 64 bytes. */
  84:../drivers/fsl_dma.h ****     kDMA_Modulo128Bytes,       /*!< Circular buffer size is 128 bytes. */
  85:../drivers/fsl_dma.h ****     kDMA_Modulo256Bytes,       /*!< Circular buffer size is 256 bytes. */
  86:../drivers/fsl_dma.h ****     kDMA_Modulo512Bytes,       /*!< Circular buffer size is 512 bytes. */
  87:../drivers/fsl_dma.h ****     kDMA_Modulo1KBytes,        /*!< Circular buffer size is 1 KB. */
  88:../drivers/fsl_dma.h ****     kDMA_Modulo2KBytes,        /*!< Circular buffer size is 2 KB. */
  89:../drivers/fsl_dma.h ****     kDMA_Modulo4KBytes,        /*!< Circular buffer size is 4 KB. */
  90:../drivers/fsl_dma.h ****     kDMA_Modulo8KBytes,        /*!< Circular buffer size is 8 KB. */
  91:../drivers/fsl_dma.h ****     kDMA_Modulo16KBytes,       /*!< Circular buffer size is 16 KB. */
  92:../drivers/fsl_dma.h ****     kDMA_Modulo32KBytes,       /*!< Circular buffer size is 32 KB. */
  93:../drivers/fsl_dma.h ****     kDMA_Modulo64KBytes,       /*!< Circular buffer size is 64 KB. */
  94:../drivers/fsl_dma.h ****     kDMA_Modulo128KBytes,      /*!< Circular buffer size is 128 KB. */
  95:../drivers/fsl_dma.h ****     kDMA_Modulo256KBytes,      /*!< Circular buffer size is 256 KB. */
  96:../drivers/fsl_dma.h **** } dma_modulo_t;
  97:../drivers/fsl_dma.h **** 
  98:../drivers/fsl_dma.h **** /*! @brief DMA channel link type */
  99:../drivers/fsl_dma.h **** typedef enum _dma_channel_link_type
 100:../drivers/fsl_dma.h **** {
 101:../drivers/fsl_dma.h ****     kDMA_ChannelLinkDisable = 0x0U,      /*!< No channel link. */
 102:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AndChannel2, /*!< Perform a link to channel LCH1 after each cycle-steal
 103:../drivers/fsl_dma.h ****                                               followed by a link to LCH2 after the BCR decrements t
 104:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1,            /*!< Perform a link to LCH1 after each cycle-steal transfe
 105:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AfterBCR0,   /*!< Perform a link to LCH1 after the BCR decrements. */
 106:../drivers/fsl_dma.h **** } dma_channel_link_type_t;
 107:../drivers/fsl_dma.h **** 
 108:../drivers/fsl_dma.h **** /*! @brief DMA transfer type */
 109:../drivers/fsl_dma.h **** typedef enum _dma_transfer_type
 110:../drivers/fsl_dma.h **** {
 111:../drivers/fsl_dma.h ****     kDMA_MemoryToMemory = 0x0U, /*!< Memory to Memory transfer. */
 112:../drivers/fsl_dma.h ****     kDMA_PeripheralToMemory,    /*!< Peripheral to Memory transfer. */
 113:../drivers/fsl_dma.h ****     kDMA_MemoryToPeripheral,    /*!< Memory to Peripheral transfer. */
 114:../drivers/fsl_dma.h **** } dma_transfer_type_t;
 115:../drivers/fsl_dma.h **** 
 116:../drivers/fsl_dma.h **** /*! @brief DMA transfer options */
 117:../drivers/fsl_dma.h **** typedef enum _dma_transfer_options
 118:../drivers/fsl_dma.h **** {
 119:../drivers/fsl_dma.h ****     kDMA_NoOptions = 0x0U, /*!< Transfer without options. */
 120:../drivers/fsl_dma.h ****     kDMA_EnableInterrupt,  /*!< Enable interrupt while transfer complete. */
 121:../drivers/fsl_dma.h **** } dma_transfer_options_t;
 122:../drivers/fsl_dma.h **** 
 123:../drivers/fsl_dma.h **** /*! @brief DMA transfer status */
 124:../drivers/fsl_dma.h **** enum _dma_transfer_status
 125:../drivers/fsl_dma.h **** {
 126:../drivers/fsl_dma.h ****     kStatus_DMA_Busy = MAKE_STATUS(kStatusGroup_DMA, 0),
 127:../drivers/fsl_dma.h **** };
 128:../drivers/fsl_dma.h **** 
 129:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 130:../drivers/fsl_dma.h **** typedef struct _dma_transfer_config
 131:../drivers/fsl_dma.h **** {
 132:../drivers/fsl_dma.h ****     uint32_t srcAddr;             /*!< DMA transfer source address. */
 133:../drivers/fsl_dma.h ****     uint32_t destAddr;            /*!< DMA destination address.*/
 134:../drivers/fsl_dma.h ****     bool enableSrcIncrement;      /*!< Source address increase after each transfer. */
 135:../drivers/fsl_dma.h ****     dma_transfer_size_t srcSize;  /*!< Source transfer size unit. */
 136:../drivers/fsl_dma.h ****     bool enableDestIncrement;     /*!< Destination address increase after each transfer. */
 137:../drivers/fsl_dma.h ****     dma_transfer_size_t destSize; /*!< Destination transfer unit.*/
 138:../drivers/fsl_dma.h ****     uint32_t transferSize;        /*!< The number of bytes to be transferred. */
 139:../drivers/fsl_dma.h **** } dma_transfer_config_t;
 140:../drivers/fsl_dma.h **** 
 141:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 142:../drivers/fsl_dma.h **** typedef struct _dma_channel_link_config
 143:../drivers/fsl_dma.h **** {
 144:../drivers/fsl_dma.h ****     dma_channel_link_type_t linkType; /*!< Channel link type. */
 145:../drivers/fsl_dma.h ****     uint32_t channel1;                /*!< The index of channel 1. */
 146:../drivers/fsl_dma.h ****     uint32_t channel2;                /*!< The index of channel 2. */
 147:../drivers/fsl_dma.h **** } dma_channel_link_config_t;
 148:../drivers/fsl_dma.h **** 
 149:../drivers/fsl_dma.h **** struct _dma_handle;
 150:../drivers/fsl_dma.h **** /*! @brief Callback function prototype for the DMA driver. */
 151:../drivers/fsl_dma.h **** typedef void (*dma_callback)(struct _dma_handle *handle, void *userData);
 152:../drivers/fsl_dma.h **** 
 153:../drivers/fsl_dma.h **** /*! @brief DMA DMA handle structure */
 154:../drivers/fsl_dma.h **** typedef struct _dma_handle
 155:../drivers/fsl_dma.h **** {
 156:../drivers/fsl_dma.h ****     DMA_Type *base;        /*!< DMA peripheral address. */
 157:../drivers/fsl_dma.h ****     uint8_t channel;       /*!< DMA channel used. */
 158:../drivers/fsl_dma.h ****     dma_callback callback; /*!< DMA callback function.*/
 159:../drivers/fsl_dma.h ****     void *userData;        /*!< Callback parameter. */
 160:../drivers/fsl_dma.h **** } dma_handle_t;
 161:../drivers/fsl_dma.h **** 
 162:../drivers/fsl_dma.h **** /*******************************************************************************
 163:../drivers/fsl_dma.h ****  * API
 164:../drivers/fsl_dma.h ****  ******************************************************************************/
 165:../drivers/fsl_dma.h **** #if defined(__cplusplus)
 166:../drivers/fsl_dma.h **** extern "C" {
 167:../drivers/fsl_dma.h **** #endif /* __cplusplus */
 168:../drivers/fsl_dma.h **** 
 169:../drivers/fsl_dma.h **** /*!
 170:../drivers/fsl_dma.h ****  * @name DMA Initialization and De-initialization
 171:../drivers/fsl_dma.h ****  * @{
 172:../drivers/fsl_dma.h ****  */
 173:../drivers/fsl_dma.h **** 
 174:../drivers/fsl_dma.h **** /*!
 175:../drivers/fsl_dma.h ****  * @brief Initializes the DMA peripheral.
 176:../drivers/fsl_dma.h ****  *
 177:../drivers/fsl_dma.h ****  * This function ungates the DMA clock.
 178:../drivers/fsl_dma.h ****  *
 179:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 180:../drivers/fsl_dma.h ****  */
 181:../drivers/fsl_dma.h **** void DMA_Init(DMA_Type *base);
 182:../drivers/fsl_dma.h **** 
 183:../drivers/fsl_dma.h **** /*!
 184:../drivers/fsl_dma.h ****  * @brief Deinitializes the DMA peripheral.
 185:../drivers/fsl_dma.h ****  *
 186:../drivers/fsl_dma.h ****  * This function gates the DMA clock.
 187:../drivers/fsl_dma.h ****  *
 188:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 189:../drivers/fsl_dma.h ****  */
 190:../drivers/fsl_dma.h **** void DMA_Deinit(DMA_Type *base);
 191:../drivers/fsl_dma.h **** 
 192:../drivers/fsl_dma.h **** /* @} */
 193:../drivers/fsl_dma.h **** /*!
 194:../drivers/fsl_dma.h ****  * @name DMA Channel Operation
 195:../drivers/fsl_dma.h ****  * @{
 196:../drivers/fsl_dma.h ****  */
 197:../drivers/fsl_dma.h **** 
 198:../drivers/fsl_dma.h **** /*!
 199:../drivers/fsl_dma.h ****  * @brief Resets the DMA channel.
 200:../drivers/fsl_dma.h ****  *
 201:../drivers/fsl_dma.h ****  * Sets all register values to reset values and enables
 202:../drivers/fsl_dma.h ****  * the cycle steal and auto stop channel request features.
 203:../drivers/fsl_dma.h ****  *
 204:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 205:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 206:../drivers/fsl_dma.h ****  */
 207:../drivers/fsl_dma.h **** void DMA_ResetChannel(DMA_Type *base, uint32_t channel);
 208:../drivers/fsl_dma.h **** 
 209:../drivers/fsl_dma.h **** /*!
 210:../drivers/fsl_dma.h ****  * @brief Configures the DMA transfer attribute.
 211:../drivers/fsl_dma.h ****  *
 212:../drivers/fsl_dma.h ****  * This function configures the transfer attribute including the source address,
 213:../drivers/fsl_dma.h ****  * destination address, transfer size, and so on.
 214:../drivers/fsl_dma.h ****  * This example shows how to set up the the dma_transfer_config_t
 215:../drivers/fsl_dma.h ****  * parameters and how to call the DMA_ConfigBasicTransfer function.
 216:../drivers/fsl_dma.h ****  * @code
 217:../drivers/fsl_dma.h ****  *   dma_transfer_config_t transferConfig;
 218:../drivers/fsl_dma.h ****  *   memset(&transferConfig, 0, sizeof(transferConfig));
 219:../drivers/fsl_dma.h ****  *   transferConfig.srcAddr = (uint32_t)srcAddr;
 220:../drivers/fsl_dma.h ****  *   transferConfig.destAddr = (uint32_t)destAddr;
 221:../drivers/fsl_dma.h ****  *   transferConfig.enbaleSrcIncrement = true;
 222:../drivers/fsl_dma.h ****  *   transferConfig.enableDestIncrement = true;
 223:../drivers/fsl_dma.h ****  *   transferConfig.srcSize = kDMA_Transfersize32bits;
 224:../drivers/fsl_dma.h ****  *   transferConfig.destSize = kDMA_Transfersize32bits;
 225:../drivers/fsl_dma.h ****  *   transferConfig.transferSize = sizeof(uint32_t) * BUFF_LENGTH;
 226:../drivers/fsl_dma.h ****  *   DMA_SetTransferConfig(DMA0, 0, &transferConfig);
 227:../drivers/fsl_dma.h ****  * @endcode
 228:../drivers/fsl_dma.h ****  *
 229:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 230:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 231:../drivers/fsl_dma.h ****  * @param config Pointer to the DMA transfer configuration structure.
 232:../drivers/fsl_dma.h ****  */
 233:../drivers/fsl_dma.h **** void DMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const dma_transfer_config_t *config);
 234:../drivers/fsl_dma.h **** 
 235:../drivers/fsl_dma.h **** /*!
 236:../drivers/fsl_dma.h ****  * @brief Configures the DMA channel link feature.
 237:../drivers/fsl_dma.h ****  *
 238:../drivers/fsl_dma.h ****  * This function allows DMA channels to have their transfers linked. The current DMA channel
 239:../drivers/fsl_dma.h ****  * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the channel link
 240:../drivers/fsl_dma.h ****  * type.
 241:../drivers/fsl_dma.h ****  * Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2
 242:../drivers/fsl_dma.h ****  * after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1AndChannel2.
 243:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after each cycle-steal transfer if the type is kDMA_ChannelLinkChannel1.
 244:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1Afte
 245:../drivers/fsl_dma.h ****  *
 246:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 247:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 248:../drivers/fsl_dma.h ****  * @param config Pointer to the channel link configuration structure.
 249:../drivers/fsl_dma.h ****  */
 250:../drivers/fsl_dma.h **** void DMA_SetChannelLinkConfig(DMA_Type *base, uint32_t channel, const dma_channel_link_config_t *co
 251:../drivers/fsl_dma.h **** 
 252:../drivers/fsl_dma.h **** /*!
 253:../drivers/fsl_dma.h ****  * @brief Sets the DMA source address for the DMA transfer.
 254:../drivers/fsl_dma.h ****  *
 255:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 256:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 257:../drivers/fsl_dma.h ****  * @param srcAddr DMA source address.
 258:../drivers/fsl_dma.h ****  */
 259:../drivers/fsl_dma.h **** static inline void DMA_SetSourceAddress(DMA_Type *base, uint32_t channel, uint32_t srcAddr)
 260:../drivers/fsl_dma.h **** {
 261:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 262:../drivers/fsl_dma.h **** 
 263:../drivers/fsl_dma.h ****     base->DMA[channel].SAR = srcAddr;
 264:../drivers/fsl_dma.h **** }
 265:../drivers/fsl_dma.h **** 
 266:../drivers/fsl_dma.h **** /*!
 267:../drivers/fsl_dma.h ****  * @brief Sets the DMA destination address for the DMA transfer.
 268:../drivers/fsl_dma.h ****  *
 269:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 270:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 271:../drivers/fsl_dma.h ****  * @param destAddr DMA destination address.
 272:../drivers/fsl_dma.h ****  */
 273:../drivers/fsl_dma.h **** static inline void DMA_SetDestinationAddress(DMA_Type *base, uint32_t channel, uint32_t destAddr)
 274:../drivers/fsl_dma.h **** {
 275:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 276:../drivers/fsl_dma.h **** 
 277:../drivers/fsl_dma.h ****     base->DMA[channel].DAR = destAddr;
 278:../drivers/fsl_dma.h **** }
 279:../drivers/fsl_dma.h **** 
 280:../drivers/fsl_dma.h **** /*!
 281:../drivers/fsl_dma.h ****  * @brief Sets the DMA transfer size for the DMA transfer.
 282:../drivers/fsl_dma.h ****  *
 283:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 284:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 285:../drivers/fsl_dma.h ****  * @param size The number of bytes to be transferred.
 286:../drivers/fsl_dma.h ****  */
 287:../drivers/fsl_dma.h **** static inline void DMA_SetTransferSize(DMA_Type *base, uint32_t channel, uint32_t size)
 288:../drivers/fsl_dma.h **** {
 289:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 290:../drivers/fsl_dma.h **** 
 291:../drivers/fsl_dma.h ****     base->DMA[channel].DSR_BCR = DMA_DSR_BCR_BCR(size);
 292:../drivers/fsl_dma.h **** }
 293:../drivers/fsl_dma.h **** 
 294:../drivers/fsl_dma.h **** /*!
 295:../drivers/fsl_dma.h ****  * @brief Sets the DMA modulo for the DMA transfer.
 296:../drivers/fsl_dma.h ****  *
 297:../drivers/fsl_dma.h ****  * This function defines a specific address range specified to be the value after (SAR + SSIZE)/(DA
 298:../drivers/fsl_dma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 299:../drivers/fsl_dma.h ****  * data queue easily.
 300:../drivers/fsl_dma.h ****  *
 301:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 302:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 303:../drivers/fsl_dma.h ****  * @param srcModulo source address modulo.
 304:../drivers/fsl_dma.h ****  * @param destModulo destination address modulo.
 305:../drivers/fsl_dma.h ****  */
 306:../drivers/fsl_dma.h **** void DMA_SetModulo(DMA_Type *base, uint32_t channel, dma_modulo_t srcModulo, dma_modulo_t destModul
 307:../drivers/fsl_dma.h **** 
 308:../drivers/fsl_dma.h **** /*!
 309:../drivers/fsl_dma.h ****  * @brief Enables the DMA cycle steal for the DMA transfer.
 310:../drivers/fsl_dma.h ****  *
 311:../drivers/fsl_dma.h ****  * If the cycle steal feature is enabled (true), the DMA controller forces a single read/write tran
 312:../drivers/fsl_dma.h ****  *  or it continuously makes read/write transfers until the BCR decrements to 0.
 313:../drivers/fsl_dma.h ****  *
 314:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 315:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 316:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 317:../drivers/fsl_dma.h ****  */
 318:../drivers/fsl_dma.h **** static inline void DMA_EnableCycleSteal(DMA_Type *base, uint32_t channel, bool enable)
 319:../drivers/fsl_dma.h **** {
 320:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 321:../drivers/fsl_dma.h **** 
 322:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_CS_MASK)) | DMA_DCR_CS(enable);
 323:../drivers/fsl_dma.h **** }
 324:../drivers/fsl_dma.h **** 
 325:../drivers/fsl_dma.h **** /*!
 326:../drivers/fsl_dma.h ****  * @brief Enables the DMA auto align for the DMA transfer.
 327:../drivers/fsl_dma.h ****  *
 328:../drivers/fsl_dma.h ****  * If the auto align feature is enabled (true), the appropriate address register increments
 329:../drivers/fsl_dma.h ****  * regardless of DINC or SINC.
 330:../drivers/fsl_dma.h ****  *
 331:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 332:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 333:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 334:../drivers/fsl_dma.h ****  */
 335:../drivers/fsl_dma.h **** static inline void DMA_EnableAutoAlign(DMA_Type *base, uint32_t channel, bool enable)
 336:../drivers/fsl_dma.h **** {
 337:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 338:../drivers/fsl_dma.h **** 
 339:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_AA_MASK)) | DMA_DCR_AA(enable);
 340:../drivers/fsl_dma.h **** }
 341:../drivers/fsl_dma.h **** 
 342:../drivers/fsl_dma.h **** /*!
 343:../drivers/fsl_dma.h ****  * @brief Enables the DMA async request for the DMA transfer.
 344:../drivers/fsl_dma.h ****  *
 345:../drivers/fsl_dma.h ****  * If the async request feature is enabled (true), the DMA supports asynchronous DREQs
 346:../drivers/fsl_dma.h ****  * while the MCU is in stop mode.
 347:../drivers/fsl_dma.h ****  *
 348:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 349:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 350:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 351:../drivers/fsl_dma.h ****  */
 352:../drivers/fsl_dma.h **** static inline void DMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 353:../drivers/fsl_dma.h **** {
 354:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 355:../drivers/fsl_dma.h **** 
 356:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_EADREQ_MASK)) | DMA_DCR_EADREQ(ena
 357:../drivers/fsl_dma.h **** }
 358:../drivers/fsl_dma.h **** 
 359:../drivers/fsl_dma.h **** /*!
 360:../drivers/fsl_dma.h ****  * @brief Enables an interrupt for the DMA transfer.
 361:../drivers/fsl_dma.h ****  *
 362:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 363:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 364:../drivers/fsl_dma.h ****  */
 365:../drivers/fsl_dma.h **** static inline void DMA_EnableInterrupts(DMA_Type *base, uint32_t channel)
 366:../drivers/fsl_dma.h **** {
 367:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 368:../drivers/fsl_dma.h **** 
 369:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_EINT(true);
 370:../drivers/fsl_dma.h **** }
 371:../drivers/fsl_dma.h **** 
 372:../drivers/fsl_dma.h **** /*!
 373:../drivers/fsl_dma.h ****  * @brief Disables an interrupt for the DMA transfer.
 374:../drivers/fsl_dma.h ****  *
 375:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 376:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 377:../drivers/fsl_dma.h ****  */
 378:../drivers/fsl_dma.h **** static inline void DMA_DisableInterrupts(DMA_Type *base, uint32_t channel)
 379:../drivers/fsl_dma.h **** {
 380:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 381:../drivers/fsl_dma.h **** 
 382:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_EINT_MASK;
 383:../drivers/fsl_dma.h **** }
 384:../drivers/fsl_dma.h **** 
 385:../drivers/fsl_dma.h **** /* @} */
 386:../drivers/fsl_dma.h **** /*!
 387:../drivers/fsl_dma.h ****  * @name DMA Channel Transfer Operation
 388:../drivers/fsl_dma.h ****  * @{
 389:../drivers/fsl_dma.h ****  */
 390:../drivers/fsl_dma.h **** 
 391:../drivers/fsl_dma.h **** /*!
 392:../drivers/fsl_dma.h ****  * @brief Enables the DMA hardware channel request.
 393:../drivers/fsl_dma.h ****  *
 394:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 395:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 396:../drivers/fsl_dma.h ****  */
 397:../drivers/fsl_dma.h **** static inline void DMA_EnableChannelRequest(DMA_Type *base, uint32_t channel)
 398:../drivers/fsl_dma.h **** {
 399:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 400:../drivers/fsl_dma.h **** 
 401:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_ERQ_MASK;
 402:../drivers/fsl_dma.h **** }
 403:../drivers/fsl_dma.h **** 
 404:../drivers/fsl_dma.h **** /*!
 405:../drivers/fsl_dma.h ****  * @brief Disables the DMA hardware channel request.
 406:../drivers/fsl_dma.h ****  *
 407:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 408:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 409:../drivers/fsl_dma.h ****  */
 410:../drivers/fsl_dma.h **** static inline void DMA_DisableChannelRequest(DMA_Type *base, uint32_t channel)
 411:../drivers/fsl_dma.h **** {
 412:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 413:../drivers/fsl_dma.h **** 
 414:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_ERQ_MASK;
 415:../drivers/fsl_dma.h **** }
 416:../drivers/fsl_dma.h **** 
 417:../drivers/fsl_dma.h **** /*!
 418:../drivers/fsl_dma.h ****  * @brief Starts the DMA transfer with a software trigger.
 419:../drivers/fsl_dma.h ****  *
 420:../drivers/fsl_dma.h ****  * This function starts only one read/write iteration.
 421:../drivers/fsl_dma.h ****  *
 422:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 423:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 424:../drivers/fsl_dma.h ****  */
 425:../drivers/fsl_dma.h **** static inline void DMA_TriggerChannelStart(DMA_Type *base, uint32_t channel)
 426:../drivers/fsl_dma.h **** {
 427:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 428:../drivers/fsl_dma.h **** 
 429:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_START_MASK;
 430:../drivers/fsl_dma.h **** }
 431:../drivers/fsl_dma.h **** 
 432:../drivers/fsl_dma.h **** /* @} */
 433:../drivers/fsl_dma.h **** /*!
 434:../drivers/fsl_dma.h ****  * @name DMA Channel Status Operation
 435:../drivers/fsl_dma.h ****  * @{
 436:../drivers/fsl_dma.h ****  */
 437:../drivers/fsl_dma.h **** 
 438:../drivers/fsl_dma.h **** /*!
 439:../drivers/fsl_dma.h ****  * @brief Gets the remaining bytes of the current DMA transfer.
 440:../drivers/fsl_dma.h ****  *
 441:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 442:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 443:../drivers/fsl_dma.h ****  * @return The number of bytes which have not been transferred yet.
 444:../drivers/fsl_dma.h ****  */
 445:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetRemainingBytes(DMA_Type *base, uint32_t channel)
 446:../drivers/fsl_dma.h **** {
 447:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 448:../drivers/fsl_dma.h **** 
 449:../drivers/fsl_dma.h ****     return (base->DMA[channel].DSR_BCR & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT;
 450:../drivers/fsl_dma.h **** }
 451:../drivers/fsl_dma.h **** 
 452:../drivers/fsl_dma.h **** /*!
 453:../drivers/fsl_dma.h ****  * @brief Gets the DMA channel status flags.
 454:../drivers/fsl_dma.h ****  *
 455:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 456:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 457:../drivers/fsl_dma.h ****  * @return The mask of the channel status. Use the _dma_channel_status_flags
 458:../drivers/fsl_dma.h ****  *         type to decode the return 32 bit variables.
 459:../drivers/fsl_dma.h ****  */
 460:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetChannelStatusFlags(DMA_Type *base, uint32_t channel)
 461:../drivers/fsl_dma.h **** {
 462:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 463:../drivers/fsl_dma.h **** 
 464:../drivers/fsl_dma.h ****     return base->DMA[channel].DSR_BCR;
 465:../drivers/fsl_dma.h **** }
 466:../drivers/fsl_dma.h **** 
 467:../drivers/fsl_dma.h **** /*!
 468:../drivers/fsl_dma.h ****  * @brief Clears the DMA channel status flags.
 469:../drivers/fsl_dma.h ****  *
 470:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 471:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 472:../drivers/fsl_dma.h ****  * @param mask The mask of the channel status to be cleared. Use
 473:../drivers/fsl_dma.h ****  *             the defined _dma_channel_status_flags type.
 474:../drivers/fsl_dma.h ****  */
 475:../drivers/fsl_dma.h **** static inline void DMA_ClearChannelStatusFlags(DMA_Type *base, uint32_t channel, uint32_t mask)
 476:../drivers/fsl_dma.h **** {
 477:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 478:../drivers/fsl_dma.h **** 
 479:../drivers/fsl_dma.h ****     if (mask != 0U)
 480:../drivers/fsl_dma.h ****     {
 481:../drivers/fsl_dma.h ****         base->DMA[channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 482:../drivers/fsl_dma.h ****     }
 483:../drivers/fsl_dma.h **** }
 484:../drivers/fsl_dma.h **** 
 485:../drivers/fsl_dma.h **** /* @} */
 486:../drivers/fsl_dma.h **** /*!
 487:../drivers/fsl_dma.h ****  * @name DMA Channel Transactional Operation
 488:../drivers/fsl_dma.h ****  * @{
 489:../drivers/fsl_dma.h ****  */
 490:../drivers/fsl_dma.h **** 
 491:../drivers/fsl_dma.h **** /*!
 492:../drivers/fsl_dma.h ****  * @brief Creates the DMA handle.
 493:../drivers/fsl_dma.h ****  *
 494:../drivers/fsl_dma.h ****  * This function is called first if using the transactional API for the DMA. This function
 495:../drivers/fsl_dma.h ****  * initializes the internal state of the DMA handle.
 496:../drivers/fsl_dma.h ****  *
 497:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer. The DMA handle stores callback function and
 498:../drivers/fsl_dma.h ****  *               parameters.
 499:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 500:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 501:../drivers/fsl_dma.h ****  */
 502:../drivers/fsl_dma.h **** void DMA_CreateHandle(dma_handle_t *handle, DMA_Type *base, uint32_t channel);
 503:../drivers/fsl_dma.h **** 
 504:../drivers/fsl_dma.h **** /*!
 505:../drivers/fsl_dma.h ****  * @brief Sets the DMA callback function.
 506:../drivers/fsl_dma.h ****  *
 507:../drivers/fsl_dma.h ****  * This callback is called in the DMA IRQ handler. Use the callback to do something
 508:../drivers/fsl_dma.h ****  * after the current transfer complete.
 509:../drivers/fsl_dma.h ****  *
 510:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 511:../drivers/fsl_dma.h ****  * @param callback DMA callback function pointer.
 512:../drivers/fsl_dma.h ****  * @param userData Parameter for callback function. If it is not needed, just set to NULL.
 513:../drivers/fsl_dma.h ****  */
 514:../drivers/fsl_dma.h **** void DMA_SetCallback(dma_handle_t *handle, dma_callback callback, void *userData);
 515:../drivers/fsl_dma.h **** 
 516:../drivers/fsl_dma.h **** /*!
 517:../drivers/fsl_dma.h ****  * @brief Prepares the DMA transfer configuration structure.
 518:../drivers/fsl_dma.h ****  *
 519:../drivers/fsl_dma.h ****  * This function prepares the transfer configuration structure according to the user input.
 520:../drivers/fsl_dma.h ****  *
 521:../drivers/fsl_dma.h ****  * @param config Pointer to the user configuration structure of type dma_transfer_config_t.
 522:../drivers/fsl_dma.h ****  * @param srcAddr DMA transfer source address.
 523:../drivers/fsl_dma.h ****  * @param srcWidth DMA transfer source address width (byte).
 524:../drivers/fsl_dma.h ****  * @param destAddr DMA transfer destination address.
 525:../drivers/fsl_dma.h ****  * @param destWidth DMA transfer destination address width (byte).
 526:../drivers/fsl_dma.h ****  * @param transferBytes DMA transfer bytes to be transferred.
 527:../drivers/fsl_dma.h ****  * @param type DMA transfer type.
 528:../drivers/fsl_dma.h ****  */
 529:../drivers/fsl_dma.h **** void DMA_PrepareTransfer(dma_transfer_config_t *config,
 530:../drivers/fsl_dma.h ****                          void *srcAddr,
 531:../drivers/fsl_dma.h ****                          uint32_t srcWidth,
 532:../drivers/fsl_dma.h ****                          void *destAddr,
 533:../drivers/fsl_dma.h ****                          uint32_t destWidth,
 534:../drivers/fsl_dma.h ****                          uint32_t transferBytes,
 535:../drivers/fsl_dma.h ****                          dma_transfer_type_t type);
 536:../drivers/fsl_dma.h **** 
 537:../drivers/fsl_dma.h **** /*!
 538:../drivers/fsl_dma.h ****  * @brief Submits the DMA transfer request.
 539:../drivers/fsl_dma.h ****  *
 540:../drivers/fsl_dma.h ****  * This function submits the DMA transfer request according to the transfer configuration structure
 541:../drivers/fsl_dma.h ****  *
 542:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 543:../drivers/fsl_dma.h ****  * @param config Pointer to DMA transfer configuration structure.
 544:../drivers/fsl_dma.h ****  * @param options Additional configurations for transfer. Use
 545:../drivers/fsl_dma.h ****  *                the defined dma_transfer_options_t type.
 546:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA submit transfer request succeeded.
 547:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA is busy. Submit transfer request is not allow
 548:../drivers/fsl_dma.h ****  * @note This function can't process multi transfer request.
 549:../drivers/fsl_dma.h ****  */
 550:../drivers/fsl_dma.h **** status_t DMA_SubmitTransfer(dma_handle_t *handle, const dma_transfer_config_t *config, uint32_t opt
 551:../drivers/fsl_dma.h **** 
 552:../drivers/fsl_dma.h **** /*!
 553:../drivers/fsl_dma.h ****  * @brief DMA starts a transfer.
 554:../drivers/fsl_dma.h ****  *
 555:../drivers/fsl_dma.h ****  * This function enables the channel request. Call this function
 556:../drivers/fsl_dma.h ****  * after submitting a transfer request.
 557:../drivers/fsl_dma.h ****  *
 558:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 559:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA start transfer succeed.
 560:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA has started a transfer.
 561:../drivers/fsl_dma.h ****  */
 562:../drivers/fsl_dma.h **** static inline void DMA_StartTransfer(dma_handle_t *handle)
 563:../drivers/fsl_dma.h **** {
 564:../drivers/fsl_dma.h ****     assert(handle != NULL);
 565:../drivers/fsl_dma.h **** 
 566:../drivers/fsl_dma.h ****     handle->base->DMA[handle->channel].DCR |= DMA_DCR_ERQ_MASK;
 567:../drivers/fsl_dma.h **** }
 568:../drivers/fsl_dma.h **** 
 569:../drivers/fsl_dma.h **** /*!
 570:../drivers/fsl_dma.h ****  * @brief DMA stops a transfer.
 571:../drivers/fsl_dma.h ****  *
 572:../drivers/fsl_dma.h ****  * This function disables the channel request to stop a DMA transfer.
 573:../drivers/fsl_dma.h ****  * The transfer can be resumed by calling the DMA_StartTransfer.
 574:../drivers/fsl_dma.h ****  *
 575:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 576:../drivers/fsl_dma.h ****  */
 577:../drivers/fsl_dma.h **** static inline void DMA_StopTransfer(dma_handle_t *handle)
 578:../drivers/fsl_dma.h **** {
 579:../drivers/fsl_dma.h ****     assert(handle != NULL);
 580:../drivers/fsl_dma.h **** 
 581:../drivers/fsl_dma.h ****     handle->base->DMA[handle->channel].DCR &= ~DMA_DCR_ERQ_MASK;
  60              		.loc 3 581 0
  61 0010 1368     		ldr	r3, [r2]
  62 0012 1279     		ldrb	r2, [r2, #4]
  63              	.LVL6:
  64 0014 1201     		lsls	r2, r2, #4
  65 0016 9B18     		adds	r3, r3, r2
  66 0018 0D33     		adds	r3, r3, #13
  67 001a FF33     		adds	r3, r3, #255
  68 001c 1A68     		ldr	r2, [r3]
  69 001e 0849     		ldr	r1, .L3
  70              	.LVL7:
  71 0020 0A40     		ands	r2, r1
  72 0022 1A60     		str	r2, [r3]
  73              	.LVL8:
  74              	.LBE45:
  75              	.LBE44:
 102:../drivers/fsl_spi_dma.c **** 
 103:../drivers/fsl_spi_dma.c ****     /* change the state */
 104:../drivers/fsl_spi_dma.c ****     spiHandle->txInProgress = false;
  76              		.loc 1 104 0
  77 0024 0023     		movs	r3, #0
  78 0026 2370     		strb	r3, [r4]
 105:../drivers/fsl_spi_dma.c **** 
 106:../drivers/fsl_spi_dma.c ****     /* All finished, call the callback */
 107:../drivers/fsl_spi_dma.c ****     if ((spiHandle->txInProgress == false) && (spiHandle->rxInProgress == false))
  79              		.loc 1 107 0
  80 0028 6378     		ldrb	r3, [r4, #1]
  81 002a 002B     		cmp	r3, #0
  82 002c 07D1     		bne	.L1
 108:../drivers/fsl_spi_dma.c ****     {
 109:../drivers/fsl_spi_dma.c ****         spiHandle->state = kSPI_Idle;
  83              		.loc 1 109 0
  84 002e A361     		str	r3, [r4, #24]
 110:../drivers/fsl_spi_dma.c ****         if (spiHandle->callback)
  85              		.loc 1 110 0
  86 0030 2569     		ldr	r5, [r4, #16]
  87 0032 002D     		cmp	r5, #0
  88 0034 03D0     		beq	.L1
 111:../drivers/fsl_spi_dma.c ****         {
 112:../drivers/fsl_spi_dma.c ****             (spiHandle->callback)(base, spiHandle, kStatus_Success, spiHandle->userData);
  89              		.loc 1 112 0
  90 0036 6369     		ldr	r3, [r4, #20]
  91 0038 0022     		movs	r2, #0
  92 003a 2100     		movs	r1, r4
  93 003c A847     		blx	r5
  94              	.LVL9:
  95              	.L1:
 113:../drivers/fsl_spi_dma.c ****         }
 114:../drivers/fsl_spi_dma.c ****     }
 115:../drivers/fsl_spi_dma.c **** }
  96              		.loc 1 115 0
  97              		@ sp needed
  98              	.LVL10:
  99 003e 70BD     		pop	{r4, r5, r6, pc}
 100              	.L4:
 101              		.align	2
 102              	.L3:
 103 0040 FFFFFFBF 		.word	-1073741825
 104              		.cfi_endproc
 105              	.LFE82:
 107              		.section	.text.SPI_RxDMACallback,"ax",%progbits
 108              		.align	1
 109              		.syntax unified
 110              		.code	16
 111              		.thumb_func
 112              		.fpu softvfp
 114              	SPI_RxDMACallback:
 115              	.LFB83:
 116:../drivers/fsl_spi_dma.c **** 
 117:../drivers/fsl_spi_dma.c **** static void SPI_RxDMACallback(dma_handle_t *handle, void *userData)
 118:../drivers/fsl_spi_dma.c **** {
 116              		.loc 1 118 0
 117              		.cfi_startproc
 118              		@ args = 0, pretend = 0, frame = 0
 119              		@ frame_needed = 0, uses_anonymous_args = 0
 120              	.LVL11:
 121 0000 70B5     		push	{r4, r5, r6, lr}
 122              		.cfi_def_cfa_offset 16
 123              		.cfi_offset 4, -16
 124              		.cfi_offset 5, -12
 125              		.cfi_offset 6, -8
 126              		.cfi_offset 14, -4
 127              	.LVL12:
 119:../drivers/fsl_spi_dma.c ****     spi_dma_private_handle_t *privHandle = (spi_dma_private_handle_t *)userData;
 120:../drivers/fsl_spi_dma.c ****     spi_dma_handle_t *spiHandle = privHandle->handle;
 128              		.loc 1 120 0
 129 0002 4C68     		ldr	r4, [r1, #4]
 130              	.LVL13:
 121:../drivers/fsl_spi_dma.c ****     SPI_Type *base = privHandle->base;
 131              		.loc 1 121 0
 132 0004 0868     		ldr	r0, [r1]
 133              	.LVL14:
 134              	.LBB46:
 135              	.LBB47:
 136              		.loc 2 456 0
 137 0006 8378     		ldrb	r3, [r0, #2]
 138 0008 0422     		movs	r2, #4
 139 000a 9343     		bics	r3, r2
 140 000c 8370     		strb	r3, [r0, #2]
 141              	.LVL15:
 142              	.LBE47:
 143              	.LBE46:
 122:../drivers/fsl_spi_dma.c **** 
 123:../drivers/fsl_spi_dma.c ****     /* Disable Tx dma */
 124:../drivers/fsl_spi_dma.c ****     SPI_EnableDMA(base, kSPI_RxDmaEnable, false);
 125:../drivers/fsl_spi_dma.c **** 
 126:../drivers/fsl_spi_dma.c ****     /* Stop DMA tranfer */
 127:../drivers/fsl_spi_dma.c ****     DMA_StopTransfer(spiHandle->rxHandle);
 144              		.loc 1 127 0
 145 000e A268     		ldr	r2, [r4, #8]
 146              	.LVL16:
 147              	.LBB48:
 148              	.LBB49:
 149              		.loc 3 581 0
 150 0010 1368     		ldr	r3, [r2]
 151 0012 1279     		ldrb	r2, [r2, #4]
 152              	.LVL17:
 153 0014 1201     		lsls	r2, r2, #4
 154 0016 9B18     		adds	r3, r3, r2
 155 0018 0D33     		adds	r3, r3, #13
 156 001a FF33     		adds	r3, r3, #255
 157 001c 1A68     		ldr	r2, [r3]
 158 001e 0849     		ldr	r1, .L7
 159              	.LVL18:
 160 0020 0A40     		ands	r2, r1
 161 0022 1A60     		str	r2, [r3]
 162              	.LVL19:
 163              	.LBE49:
 164              	.LBE48:
 128:../drivers/fsl_spi_dma.c **** 
 129:../drivers/fsl_spi_dma.c ****     /* change the state */
 130:../drivers/fsl_spi_dma.c ****     spiHandle->rxInProgress = false;
 165              		.loc 1 130 0
 166 0024 0023     		movs	r3, #0
 167 0026 6370     		strb	r3, [r4, #1]
 131:../drivers/fsl_spi_dma.c **** 
 132:../drivers/fsl_spi_dma.c ****     /* All finished, call the callback */
 133:../drivers/fsl_spi_dma.c ****     if ((spiHandle->txInProgress == false) && (spiHandle->rxInProgress == false))
 168              		.loc 1 133 0
 169 0028 2378     		ldrb	r3, [r4]
 170 002a 002B     		cmp	r3, #0
 171 002c 07D1     		bne	.L5
 134:../drivers/fsl_spi_dma.c ****     {
 135:../drivers/fsl_spi_dma.c ****         spiHandle->state = kSPI_Idle;
 172              		.loc 1 135 0
 173 002e A361     		str	r3, [r4, #24]
 136:../drivers/fsl_spi_dma.c ****         if (spiHandle->callback)
 174              		.loc 1 136 0
 175 0030 2569     		ldr	r5, [r4, #16]
 176 0032 002D     		cmp	r5, #0
 177 0034 03D0     		beq	.L5
 137:../drivers/fsl_spi_dma.c ****         {
 138:../drivers/fsl_spi_dma.c ****             (spiHandle->callback)(base, spiHandle, kStatus_Success, spiHandle->userData);
 178              		.loc 1 138 0
 179 0036 6369     		ldr	r3, [r4, #20]
 180 0038 0022     		movs	r2, #0
 181 003a 2100     		movs	r1, r4
 182 003c A847     		blx	r5
 183              	.LVL20:
 184              	.L5:
 139:../drivers/fsl_spi_dma.c ****         }
 140:../drivers/fsl_spi_dma.c ****     }
 141:../drivers/fsl_spi_dma.c **** }
 185              		.loc 1 141 0
 186              		@ sp needed
 187              	.LVL21:
 188 003e 70BD     		pop	{r4, r5, r6, pc}
 189              	.L8:
 190              		.align	2
 191              	.L7:
 192 0040 FFFFFFBF 		.word	-1073741825
 193              		.cfi_endproc
 194              	.LFE83:
 196              		.section	.text.SPI_MasterTransferCreateHandleDMA,"ax",%progbits
 197              		.align	1
 198              		.global	SPI_MasterTransferCreateHandleDMA
 199              		.syntax unified
 200              		.code	16
 201              		.thumb_func
 202              		.fpu softvfp
 204              	SPI_MasterTransferCreateHandleDMA:
 205              	.LFB84:
 142:../drivers/fsl_spi_dma.c **** 
 143:../drivers/fsl_spi_dma.c **** void SPI_MasterTransferCreateHandleDMA(SPI_Type *base,
 144:../drivers/fsl_spi_dma.c ****                                        spi_dma_handle_t *handle,
 145:../drivers/fsl_spi_dma.c ****                                        spi_dma_callback_t callback,
 146:../drivers/fsl_spi_dma.c ****                                        void *userData,
 147:../drivers/fsl_spi_dma.c ****                                        dma_handle_t *txHandle,
 148:../drivers/fsl_spi_dma.c ****                                        dma_handle_t *rxHandle)
 149:../drivers/fsl_spi_dma.c **** {
 206              		.loc 1 149 0
 207              		.cfi_startproc
 208              		@ args = 8, pretend = 0, frame = 16
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              	.LVL22:
 211 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 212              		.cfi_def_cfa_offset 20
 213              		.cfi_offset 4, -20
 214              		.cfi_offset 5, -16
 215              		.cfi_offset 6, -12
 216              		.cfi_offset 7, -8
 217              		.cfi_offset 14, -4
 218 0002 C646     		mov	lr, r8
 219 0004 00B5     		push	{lr}
 220              		.cfi_def_cfa_offset 24
 221              		.cfi_offset 8, -24
 222 0006 84B0     		sub	sp, sp, #16
 223              		.cfi_def_cfa_offset 40
 224 0008 0500     		movs	r5, r0
 225 000a 0C00     		movs	r4, r1
 226 000c 9046     		mov	r8, r2
 227 000e 1F00     		movs	r7, r3
 150:../drivers/fsl_spi_dma.c ****     assert(handle);
 151:../drivers/fsl_spi_dma.c ****     dma_transfer_config_t config = {0};
 228              		.loc 1 151 0
 229 0010 1022     		movs	r2, #16
 230              	.LVL23:
 231 0012 0021     		movs	r1, #0
 232              	.LVL24:
 233 0014 6846     		mov	r0, sp
 234              	.LVL25:
 235 0016 FFF7FEFF 		bl	memset
 236              	.LVL26:
 152:../drivers/fsl_spi_dma.c ****     uint32_t instance = SPI_GetInstance(base);
 237              		.loc 1 152 0
 238 001a 2800     		movs	r0, r5
 239 001c FFF7FEFF 		bl	SPI_GetInstance
 240              	.LVL27:
 241 0020 0600     		movs	r6, r0
 242              	.LVL28:
 153:../drivers/fsl_spi_dma.c **** 
 154:../drivers/fsl_spi_dma.c ****     /* Zero the handle */
 155:../drivers/fsl_spi_dma.c ****     memset(handle, 0, sizeof(*handle));
 243              		.loc 1 155 0
 244 0022 2022     		movs	r2, #32
 245 0024 0021     		movs	r1, #0
 246 0026 2000     		movs	r0, r4
 247              	.LVL29:
 248 0028 FFF7FEFF 		bl	memset
 249              	.LVL30:
 156:../drivers/fsl_spi_dma.c **** 
 157:../drivers/fsl_spi_dma.c ****     /* Set spi base to handle */
 158:../drivers/fsl_spi_dma.c ****     handle->txHandle = txHandle;
 250              		.loc 1 158 0
 251 002c 0A9B     		ldr	r3, [sp, #40]
 252 002e 6360     		str	r3, [r4, #4]
 159:../drivers/fsl_spi_dma.c ****     handle->rxHandle = rxHandle;
 253              		.loc 1 159 0
 254 0030 0B9B     		ldr	r3, [sp, #44]
 255 0032 A360     		str	r3, [r4, #8]
 160:../drivers/fsl_spi_dma.c ****     handle->callback = callback;
 256              		.loc 1 160 0
 257 0034 4346     		mov	r3, r8
 258 0036 2361     		str	r3, [r4, #16]
 161:../drivers/fsl_spi_dma.c ****     handle->userData = userData;
 259              		.loc 1 161 0
 260 0038 6761     		str	r7, [r4, #20]
 162:../drivers/fsl_spi_dma.c **** 
 163:../drivers/fsl_spi_dma.c ****     /* Set SPI state to idle */
 164:../drivers/fsl_spi_dma.c ****     handle->state = kSPI_Idle;
 165:../drivers/fsl_spi_dma.c **** 
 166:../drivers/fsl_spi_dma.c ****     /* Set handle to global state */
 167:../drivers/fsl_spi_dma.c ****     s_dmaPrivateHandle[instance].base = base;
 261              		.loc 1 167 0
 262 003a 224B     		ldr	r3, .L14
 263 003c F200     		lsls	r2, r6, #3
 264 003e D550     		str	r5, [r2, r3]
 168:../drivers/fsl_spi_dma.c ****     s_dmaPrivateHandle[instance].handle = handle;
 265              		.loc 1 168 0
 266 0040 9B18     		adds	r3, r3, r2
 267 0042 5C60     		str	r4, [r3, #4]
 169:../drivers/fsl_spi_dma.c **** 
 170:../drivers/fsl_spi_dma.c **** /* Compute internal state */
 171:../drivers/fsl_spi_dma.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && (FSL_FEATURE_SPI_16BIT_TRANSFERS)
 172:../drivers/fsl_spi_dma.c ****     handle->bytesPerFrame = ((base->C2 & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT) + 1U;
 268              		.loc 1 172 0
 269 0044 AA78     		ldrb	r2, [r5, #2]
 270 0046 9209     		lsrs	r2, r2, #6
 271 0048 0123     		movs	r3, #1
 272 004a 1340     		ands	r3, r2
 273 004c 0133     		adds	r3, r3, #1
 274 004e 2373     		strb	r3, [r4, #12]
 173:../drivers/fsl_spi_dma.c **** #else
 174:../drivers/fsl_spi_dma.c ****     handle->bytesPerFrame = 1U;
 175:../drivers/fsl_spi_dma.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 176:../drivers/fsl_spi_dma.c **** 
 177:../drivers/fsl_spi_dma.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && (FSL_FEATURE_SPI_HAS_FIFO)
 178:../drivers/fsl_spi_dma.c ****     /* If using DMA, disable FIFO, as the FIFO may cause data loss if the data size is not integer
 179:../drivers/fsl_spi_dma.c ****        times of 2bytes. As SPI cannot set watermark to 0, only can set to 1/2 FIFO size or 3/4 FIFO
 180:../drivers/fsl_spi_dma.c ****        size. */
 181:../drivers/fsl_spi_dma.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
 275              		.loc 1 181 0
 276 0050 1D4B     		ldr	r3, .L14+4
 277 0052 9D42     		cmp	r5, r3
 278 0054 03D0     		beq	.L10
 182:../drivers/fsl_spi_dma.c ****     {
 183:../drivers/fsl_spi_dma.c ****         base->C3 &= ~SPI_C3_FIFOMODE_MASK;
 279              		.loc 1 183 0
 280 0056 EB7A     		ldrb	r3, [r5, #11]
 281 0058 0122     		movs	r2, #1
 282 005a 9343     		bics	r3, r2
 283 005c EB72     		strb	r3, [r5, #11]
 284              	.L10:
 285              	.LVL31:
 286              	.LBB50:
 287              	.LBB51:
 457:../drivers/fsl_spi.h ****     }
 458:../drivers/fsl_spi.h **** }
 459:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_DMA_SUPPORT */
 460:../drivers/fsl_spi.h **** 
 461:../drivers/fsl_spi.h **** /*!
 462:../drivers/fsl_spi.h ****  * @brief  Gets the SPI tx/rx data register address.
 463:../drivers/fsl_spi.h ****  *
 464:../drivers/fsl_spi.h ****  * This API is used to provide a transfer address for the SPI DMA transfer configuration.
 465:../drivers/fsl_spi.h ****  *
 466:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 467:../drivers/fsl_spi.h ****  * @return data register address
 468:../drivers/fsl_spi.h ****  */
 469:../drivers/fsl_spi.h **** static inline uint32_t SPI_GetDataRegisterAddress(SPI_Type *base)
 470:../drivers/fsl_spi.h **** {
 471:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 472:../drivers/fsl_spi.h ****     return (uint32_t)(&(base->DL));
 288              		.loc 2 472 0
 289 005e 0635     		adds	r5, r5, #6
 290              	.LVL32:
 291              	.LBE51:
 292              	.LBE50:
 184:../drivers/fsl_spi_dma.c ****     }
 185:../drivers/fsl_spi_dma.c **** 
 186:../drivers/fsl_spi_dma.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 187:../drivers/fsl_spi_dma.c **** 
 188:../drivers/fsl_spi_dma.c ****     /* Set the non-change attribute for Tx DMA transfer, to improve efficiency */
 189:../drivers/fsl_spi_dma.c ****     config.destAddr = SPI_GetDataRegisterAddress(base);
 293              		.loc 1 189 0
 294 0060 0195     		str	r5, [sp, #4]
 190:../drivers/fsl_spi_dma.c ****     config.enableDestIncrement = false;
 295              		.loc 1 190 0
 296 0062 0023     		movs	r3, #0
 297 0064 6A46     		mov	r2, sp
 298 0066 9372     		strb	r3, [r2, #10]
 191:../drivers/fsl_spi_dma.c ****     config.enableSrcIncrement = true;
 299              		.loc 1 191 0
 300 0068 0133     		adds	r3, r3, #1
 301 006a 1372     		strb	r3, [r2, #8]
 192:../drivers/fsl_spi_dma.c ****     if (handle->bytesPerFrame == 1U)
 302              		.loc 1 192 0
 303 006c 237B     		ldrb	r3, [r4, #12]
 304 006e 012B     		cmp	r3, #1
 305 0070 24D0     		beq	.L13
 193:../drivers/fsl_spi_dma.c ****     {
 194:../drivers/fsl_spi_dma.c ****         config.srcSize = kDMA_Transfersize8bits;
 195:../drivers/fsl_spi_dma.c ****         config.destSize = kDMA_Transfersize8bits;
 196:../drivers/fsl_spi_dma.c ****     }
 197:../drivers/fsl_spi_dma.c ****     else
 198:../drivers/fsl_spi_dma.c ****     {
 199:../drivers/fsl_spi_dma.c ****         config.srcSize = kDMA_Transfersize16bits;
 306              		.loc 1 199 0
 307 0072 0223     		movs	r3, #2
 308 0074 6A46     		mov	r2, sp
 309 0076 5372     		strb	r3, [r2, #9]
 200:../drivers/fsl_spi_dma.c ****         config.destSize = kDMA_Transfersize16bits;
 310              		.loc 1 200 0
 311 0078 D372     		strb	r3, [r2, #11]
 312              	.L12:
 201:../drivers/fsl_spi_dma.c ****     }
 202:../drivers/fsl_spi_dma.c **** 
 203:../drivers/fsl_spi_dma.c ****     DMA_SubmitTransfer(handle->txHandle, &config, true);
 313              		.loc 1 203 0
 314 007a 0122     		movs	r2, #1
 315 007c 6946     		mov	r1, sp
 316 007e 6068     		ldr	r0, [r4, #4]
 317 0080 FFF7FEFF 		bl	DMA_SubmitTransfer
 318              	.LVL33:
 204:../drivers/fsl_spi_dma.c **** 
 205:../drivers/fsl_spi_dma.c ****     /* Set non-change attribute for Rx DMA */
 206:../drivers/fsl_spi_dma.c ****     config.srcAddr = SPI_GetDataRegisterAddress(base);
 319              		.loc 1 206 0
 320 0084 0095     		str	r5, [sp]
 207:../drivers/fsl_spi_dma.c ****     config.destAddr = 0U;
 321              		.loc 1 207 0
 322 0086 0023     		movs	r3, #0
 323 0088 0193     		str	r3, [sp, #4]
 208:../drivers/fsl_spi_dma.c ****     config.enableDestIncrement = true;
 324              		.loc 1 208 0
 325 008a 0122     		movs	r2, #1
 326 008c 6946     		mov	r1, sp
 327 008e 8A72     		strb	r2, [r1, #10]
 209:../drivers/fsl_spi_dma.c ****     config.enableSrcIncrement = false;
 328              		.loc 1 209 0
 329 0090 0B72     		strb	r3, [r1, #8]
 210:../drivers/fsl_spi_dma.c ****     DMA_SubmitTransfer(handle->rxHandle, &config, true);
 330              		.loc 1 210 0
 331 0092 0122     		movs	r2, #1
 332 0094 A068     		ldr	r0, [r4, #8]
 333 0096 FFF7FEFF 		bl	DMA_SubmitTransfer
 334              	.LVL34:
 211:../drivers/fsl_spi_dma.c **** 
 212:../drivers/fsl_spi_dma.c ****     /* Install callback for Tx dma channel */
 213:../drivers/fsl_spi_dma.c ****     DMA_SetCallback(handle->txHandle, SPI_TxDMACallback, &s_dmaPrivateHandle[instance]);
 335              		.loc 1 213 0
 336 009a F600     		lsls	r6, r6, #3
 337              	.LVL35:
 338 009c 094D     		ldr	r5, .L14
 339 009e AD19     		adds	r5, r5, r6
 340 00a0 2A00     		movs	r2, r5
 341 00a2 0A49     		ldr	r1, .L14+8
 342 00a4 6068     		ldr	r0, [r4, #4]
 343 00a6 FFF7FEFF 		bl	DMA_SetCallback
 344              	.LVL36:
 214:../drivers/fsl_spi_dma.c ****     DMA_SetCallback(handle->rxHandle, SPI_RxDMACallback, &s_dmaPrivateHandle[instance]);
 345              		.loc 1 214 0
 346 00aa A068     		ldr	r0, [r4, #8]
 347 00ac 2A00     		movs	r2, r5
 348 00ae 0849     		ldr	r1, .L14+12
 349 00b0 FFF7FEFF 		bl	DMA_SetCallback
 350              	.LVL37:
 215:../drivers/fsl_spi_dma.c **** }
 351              		.loc 1 215 0
 352 00b4 04B0     		add	sp, sp, #16
 353              		@ sp needed
 354              	.LVL38:
 355              	.LVL39:
 356              	.LVL40:
 357 00b6 04BC     		pop	{r2}
 358 00b8 9046     		mov	r8, r2
 359 00ba F0BD     		pop	{r4, r5, r6, r7, pc}
 360              	.LVL41:
 361              	.L13:
 194:../drivers/fsl_spi_dma.c ****         config.destSize = kDMA_Transfersize8bits;
 362              		.loc 1 194 0
 363 00bc 5372     		strb	r3, [r2, #9]
 195:../drivers/fsl_spi_dma.c ****     }
 364              		.loc 1 195 0
 365 00be D372     		strb	r3, [r2, #11]
 366 00c0 DBE7     		b	.L12
 367              	.L15:
 368 00c2 C046     		.align	2
 369              	.L14:
 370 00c4 00000000 		.word	.LANCHOR0
 371 00c8 00600740 		.word	1074225152
 372 00cc 00000000 		.word	SPI_TxDMACallback
 373 00d0 00000000 		.word	SPI_RxDMACallback
 374              		.cfi_endproc
 375              	.LFE84:
 377              		.section	.text.SPI_MasterTransferDMA,"ax",%progbits
 378              		.align	1
 379              		.global	SPI_MasterTransferDMA
 380              		.syntax unified
 381              		.code	16
 382              		.thumb_func
 383              		.fpu softvfp
 385              	SPI_MasterTransferDMA:
 386              	.LFB85:
 216:../drivers/fsl_spi_dma.c **** 
 217:../drivers/fsl_spi_dma.c **** status_t SPI_MasterTransferDMA(SPI_Type *base, spi_dma_handle_t *handle, spi_transfer_t *xfer)
 218:../drivers/fsl_spi_dma.c **** {
 387              		.loc 1 218 0
 388              		.cfi_startproc
 389              		@ args = 0, pretend = 0, frame = 16
 390              		@ frame_needed = 0, uses_anonymous_args = 0
 391              	.LVL42:
 392 0000 70B5     		push	{r4, r5, r6, lr}
 393              		.cfi_def_cfa_offset 16
 394              		.cfi_offset 4, -16
 395              		.cfi_offset 5, -12
 396              		.cfi_offset 6, -8
 397              		.cfi_offset 14, -4
 398 0002 84B0     		sub	sp, sp, #16
 399              		.cfi_def_cfa_offset 32
 400 0004 0600     		movs	r6, r0
 401 0006 0C00     		movs	r4, r1
 402 0008 1500     		movs	r5, r2
 219:../drivers/fsl_spi_dma.c ****     assert(handle && xfer);
 220:../drivers/fsl_spi_dma.c **** 
 221:../drivers/fsl_spi_dma.c ****     dma_transfer_config_t config = {0};
 403              		.loc 1 221 0
 404 000a 1022     		movs	r2, #16
 405              	.LVL43:
 406 000c 0021     		movs	r1, #0
 407              	.LVL44:
 408 000e 6846     		mov	r0, sp
 409              	.LVL45:
 410 0010 FFF7FEFF 		bl	memset
 411              	.LVL46:
 222:../drivers/fsl_spi_dma.c **** 
 223:../drivers/fsl_spi_dma.c ****     /* Check if the device is busy */
 224:../drivers/fsl_spi_dma.c ****     if (handle->state == kSPI_Busy)
 412              		.loc 1 224 0
 413 0014 A369     		ldr	r3, [r4, #24]
 414 0016 012B     		cmp	r3, #1
 415 0018 00D1     		bne	.LCB379
 416 001a 7EE0     		b	.L25	@long jump
 417              	.LCB379:
 225:../drivers/fsl_spi_dma.c ****     {
 226:../drivers/fsl_spi_dma.c ****         return kStatus_SPI_Busy;
 227:../drivers/fsl_spi_dma.c ****     }
 228:../drivers/fsl_spi_dma.c **** 
 229:../drivers/fsl_spi_dma.c ****     /* Check if input parameter invalid */
 230:../drivers/fsl_spi_dma.c ****     if (((xfer->txData == NULL) && (xfer->rxData == NULL)) || (xfer->dataSize == 0U))
 418              		.loc 1 230 0
 419 001c 2B68     		ldr	r3, [r5]
 420 001e 002B     		cmp	r3, #0
 421 0020 68D0     		beq	.L28
 422              	.L18:
 423              		.loc 1 230 0 is_stmt 0 discriminator 3
 424 0022 AB68     		ldr	r3, [r5, #8]
 425 0024 002B     		cmp	r3, #0
 426 0026 00D1     		bne	.LCB388
 427 0028 7AE0     		b	.L27	@long jump
 428              	.LCB388:
 429              	.LVL47:
 430              	.LBB52:
 431              	.LBB53:
 363:../drivers/fsl_spi.h ****     }
 432              		.loc 2 363 0 is_stmt 1
 433 002a F378     		ldrb	r3, [r6, #3]
 434 002c 4022     		movs	r2, #64
 435 002e 9343     		bics	r3, r2
 436 0030 F370     		strb	r3, [r6, #3]
 437              	.LVL48:
 438              	.LBE53:
 439              	.LBE52:
 440              	.LBB54:
 441              	.LBB55:
 359:../drivers/fsl_spi.h ****     }
 442              		.loc 2 359 0
 443 0032 F378     		ldrb	r3, [r6, #3]
 444 0034 1343     		orrs	r3, r2
 445 0036 F370     		strb	r3, [r6, #3]
 446              	.LVL49:
 447              	.LBE55:
 448              	.LBE54:
 449              	.LBB56:
 450              	.LBB57:
 451              		.loc 2 472 0
 452 0038 B31D     		adds	r3, r6, #6
 453              	.LVL50:
 454              	.LBE57:
 455              	.LBE56:
 231:../drivers/fsl_spi_dma.c ****     {
 232:../drivers/fsl_spi_dma.c ****         return kStatus_InvalidArgument;
 233:../drivers/fsl_spi_dma.c ****     }
 234:../drivers/fsl_spi_dma.c **** 
 235:../drivers/fsl_spi_dma.c ****     /* Disable SPI and then enable it, this is used to clear S register*/
 236:../drivers/fsl_spi_dma.c ****     SPI_Enable(base, false);
 237:../drivers/fsl_spi_dma.c ****     SPI_Enable(base, true);
 238:../drivers/fsl_spi_dma.c **** 
 239:../drivers/fsl_spi_dma.c ****     /* Configure tx transfer DMA */
 240:../drivers/fsl_spi_dma.c ****     config.destAddr = SPI_GetDataRegisterAddress(base);
 456              		.loc 1 240 0
 457 003a 0193     		str	r3, [sp, #4]
 241:../drivers/fsl_spi_dma.c ****     config.enableDestIncrement = false;
 458              		.loc 1 241 0
 459 003c 0023     		movs	r3, #0
 460 003e 6A46     		mov	r2, sp
 461 0040 9372     		strb	r3, [r2, #10]
 242:../drivers/fsl_spi_dma.c ****     if (handle->bytesPerFrame == 1U)
 462              		.loc 1 242 0
 463 0042 237B     		ldrb	r3, [r4, #12]
 464 0044 012B     		cmp	r3, #1
 465 0046 5BD0     		beq	.L29
 243:../drivers/fsl_spi_dma.c ****     {
 244:../drivers/fsl_spi_dma.c ****         config.srcSize = kDMA_Transfersize8bits;
 245:../drivers/fsl_spi_dma.c ****         config.destSize = kDMA_Transfersize8bits;
 246:../drivers/fsl_spi_dma.c ****     }
 247:../drivers/fsl_spi_dma.c ****     else
 248:../drivers/fsl_spi_dma.c ****     {
 249:../drivers/fsl_spi_dma.c ****         config.srcSize = kDMA_Transfersize16bits;
 466              		.loc 1 249 0
 467 0048 0223     		movs	r3, #2
 468 004a 6A46     		mov	r2, sp
 469 004c 5372     		strb	r3, [r2, #9]
 250:../drivers/fsl_spi_dma.c ****         config.destSize = kDMA_Transfersize16bits;
 470              		.loc 1 250 0
 471 004e D372     		strb	r3, [r2, #11]
 472              	.L20:
 251:../drivers/fsl_spi_dma.c ****     }
 252:../drivers/fsl_spi_dma.c ****     config.transferSize = xfer->dataSize;
 473              		.loc 1 252 0
 474 0050 AB68     		ldr	r3, [r5, #8]
 475 0052 0393     		str	r3, [sp, #12]
 253:../drivers/fsl_spi_dma.c ****     /* Configure DMA channel */
 254:../drivers/fsl_spi_dma.c ****     if (xfer->txData)
 476              		.loc 1 254 0
 477 0054 2B68     		ldr	r3, [r5]
 478 0056 002B     		cmp	r3, #0
 479 0058 55D0     		beq	.L21
 255:../drivers/fsl_spi_dma.c ****     {
 256:../drivers/fsl_spi_dma.c ****         config.enableSrcIncrement = true;
 480              		.loc 1 256 0
 481 005a 0123     		movs	r3, #1
 482 005c 6A46     		mov	r2, sp
 483 005e 1372     		strb	r3, [r2, #8]
 257:../drivers/fsl_spi_dma.c ****         config.srcAddr = (uint32_t)(xfer->txData);
 484              		.loc 1 257 0
 485 0060 2B68     		ldr	r3, [r5]
 486 0062 0093     		str	r3, [sp]
 487              	.L22:
 258:../drivers/fsl_spi_dma.c ****     }
 259:../drivers/fsl_spi_dma.c ****     else
 260:../drivers/fsl_spi_dma.c ****     {
 261:../drivers/fsl_spi_dma.c ****         /* Disable the source increasement and source set to dummyData */
 262:../drivers/fsl_spi_dma.c ****         config.enableSrcIncrement = false;
 263:../drivers/fsl_spi_dma.c ****         config.srcAddr = (uint32_t)(&s_dummyData[SPI_GetInstance(base)]);
 264:../drivers/fsl_spi_dma.c ****     }
 265:../drivers/fsl_spi_dma.c ****     DMA_SubmitTransfer(handle->txHandle, &config, true);
 488              		.loc 1 265 0
 489 0064 0122     		movs	r2, #1
 490 0066 6946     		mov	r1, sp
 491 0068 6068     		ldr	r0, [r4, #4]
 492 006a FFF7FEFF 		bl	DMA_SubmitTransfer
 493              	.LVL51:
 266:../drivers/fsl_spi_dma.c **** 
 267:../drivers/fsl_spi_dma.c ****     /* Handle rx transfer */
 268:../drivers/fsl_spi_dma.c ****     if (xfer->rxData)
 494              		.loc 1 268 0
 495 006e 6868     		ldr	r0, [r5, #4]
 496 0070 0028     		cmp	r0, #0
 497 0072 11D0     		beq	.L23
 269:../drivers/fsl_spi_dma.c ****     {
 270:../drivers/fsl_spi_dma.c ****         /* Set the source address */
 271:../drivers/fsl_spi_dma.c ****         DMA_SetDestinationAddress(handle->rxHandle->base, handle->rxHandle->channel, (uint32_t)(xfe
 498              		.loc 1 271 0
 499 0074 A368     		ldr	r3, [r4, #8]
 500 0076 1968     		ldr	r1, [r3]
 501 0078 1B79     		ldrb	r3, [r3, #4]
 502              	.LVL52:
 503              	.LBB58:
 504              	.LBB59:
 277:../drivers/fsl_dma.h **** }
 505              		.loc 3 277 0
 506 007a 1033     		adds	r3, r3, #16
 507              	.LVL53:
 508 007c 1B01     		lsls	r3, r3, #4
 509              	.LVL54:
 510 007e CB18     		adds	r3, r1, r3
 511 0080 5860     		str	r0, [r3, #4]
 512              	.LVL55:
 513              	.LBE59:
 514              	.LBE58:
 272:../drivers/fsl_spi_dma.c **** 
 273:../drivers/fsl_spi_dma.c ****         /* Set the transfer size */
 274:../drivers/fsl_spi_dma.c ****         DMA_SetTransferSize(handle->rxHandle->base, handle->rxHandle->channel, xfer->dataSize);
 515              		.loc 1 274 0
 516 0082 A268     		ldr	r2, [r4, #8]
 517 0084 1368     		ldr	r3, [r2]
 518 0086 1179     		ldrb	r1, [r2, #4]
 519              	.LVL56:
 520              	.LBB60:
 521              	.LBB61:
 291:../drivers/fsl_dma.h **** }
 522              		.loc 3 291 0
 523 0088 AA68     		ldr	r2, [r5, #8]
 524 008a 1202     		lsls	r2, r2, #8
 525 008c 120A     		lsrs	r2, r2, #8
 526 008e 0901     		lsls	r1, r1, #4
 527              	.LVL57:
 528 0090 5B18     		adds	r3, r3, r1
 529              	.LVL58:
 530 0092 0933     		adds	r3, r3, #9
 531 0094 FF33     		adds	r3, r3, #255
 532 0096 1A60     		str	r2, [r3]
 533              	.LVL59:
 534              	.L23:
 535              	.LBE61:
 536              	.LBE60:
 275:../drivers/fsl_spi_dma.c ****     }
 276:../drivers/fsl_spi_dma.c **** 
 277:../drivers/fsl_spi_dma.c ****     /* Change the state of handle */
 278:../drivers/fsl_spi_dma.c ****     handle->transferSize = xfer->dataSize;
 537              		.loc 1 278 0
 538 0098 AB68     		ldr	r3, [r5, #8]
 539 009a E361     		str	r3, [r4, #28]
 279:../drivers/fsl_spi_dma.c ****     handle->state = kSPI_Busy;
 540              		.loc 1 279 0
 541 009c 0123     		movs	r3, #1
 542 009e A361     		str	r3, [r4, #24]
 280:../drivers/fsl_spi_dma.c **** 
 281:../drivers/fsl_spi_dma.c ****     /* Start Rx transfer if needed */
 282:../drivers/fsl_spi_dma.c ****     if (xfer->rxData)
 543              		.loc 1 282 0
 544 00a0 6B68     		ldr	r3, [r5, #4]
 545 00a2 002B     		cmp	r3, #0
 546 00a4 11D0     		beq	.L24
 283:../drivers/fsl_spi_dma.c ****     {
 284:../drivers/fsl_spi_dma.c ****         handle->rxInProgress = true;
 547              		.loc 1 284 0
 548 00a6 0123     		movs	r3, #1
 549 00a8 6370     		strb	r3, [r4, #1]
 550              	.LVL60:
 551              	.LBB62:
 552              	.LBB63:
 452:../drivers/fsl_spi.h ****     }
 553              		.loc 2 452 0
 554 00aa B378     		ldrb	r3, [r6, #2]
 555 00ac 0422     		movs	r2, #4
 556 00ae 1343     		orrs	r3, r2
 557 00b0 B370     		strb	r3, [r6, #2]
 558              	.LVL61:
 559              	.LBE63:
 560              	.LBE62:
 285:../drivers/fsl_spi_dma.c ****         SPI_EnableDMA(base, kSPI_RxDmaEnable, true);
 286:../drivers/fsl_spi_dma.c ****         DMA_StartTransfer(handle->rxHandle);
 561              		.loc 1 286 0
 562 00b2 A268     		ldr	r2, [r4, #8]
 563              	.LVL62:
 564              	.LBB64:
 565              	.LBB65:
 566:../drivers/fsl_dma.h **** }
 566              		.loc 3 566 0
 567 00b4 1368     		ldr	r3, [r2]
 568 00b6 1279     		ldrb	r2, [r2, #4]
 569              	.LVL63:
 570 00b8 1201     		lsls	r2, r2, #4
 571 00ba 9B18     		adds	r3, r3, r2
 572 00bc 0D33     		adds	r3, r3, #13
 573 00be FF33     		adds	r3, r3, #255
 574 00c0 1968     		ldr	r1, [r3]
 575 00c2 8022     		movs	r2, #128
 576 00c4 D205     		lsls	r2, r2, #23
 577 00c6 0A43     		orrs	r2, r1
 578 00c8 1A60     		str	r2, [r3]
 579              	.LVL64:
 580              	.L24:
 581              	.LBE65:
 582              	.LBE64:
 287:../drivers/fsl_spi_dma.c ****     }
 288:../drivers/fsl_spi_dma.c **** 
 289:../drivers/fsl_spi_dma.c ****     /* Always start Tx transfer */
 290:../drivers/fsl_spi_dma.c ****     handle->txInProgress = true;
 583              		.loc 1 290 0
 584 00ca 0123     		movs	r3, #1
 585 00cc 2370     		strb	r3, [r4]
 586              	.LVL65:
 587              	.LBB66:
 588              	.LBB67:
 452:../drivers/fsl_spi.h ****     }
 589              		.loc 2 452 0
 590 00ce B378     		ldrb	r3, [r6, #2]
 591 00d0 2022     		movs	r2, #32
 592 00d2 1343     		orrs	r3, r2
 593 00d4 B370     		strb	r3, [r6, #2]
 594              	.LVL66:
 595              	.LBE67:
 596              	.LBE66:
 291:../drivers/fsl_spi_dma.c ****     SPI_EnableDMA(base, kSPI_TxDmaEnable, true);
 292:../drivers/fsl_spi_dma.c ****     DMA_StartTransfer(handle->txHandle);
 597              		.loc 1 292 0
 598 00d6 6268     		ldr	r2, [r4, #4]
 599              	.LVL67:
 600              	.LBB68:
 601              	.LBB69:
 566:../drivers/fsl_dma.h **** }
 602              		.loc 3 566 0
 603 00d8 1368     		ldr	r3, [r2]
 604 00da 1279     		ldrb	r2, [r2, #4]
 605              	.LVL68:
 606 00dc 1201     		lsls	r2, r2, #4
 607 00de 9B18     		adds	r3, r3, r2
 608 00e0 0D33     		adds	r3, r3, #13
 609 00e2 FF33     		adds	r3, r3, #255
 610 00e4 1968     		ldr	r1, [r3]
 611 00e6 8022     		movs	r2, #128
 612 00e8 D205     		lsls	r2, r2, #23
 613 00ea 0A43     		orrs	r2, r1
 614 00ec 1A60     		str	r2, [r3]
 615              	.LVL69:
 616              	.LBE69:
 617              	.LBE68:
 293:../drivers/fsl_spi_dma.c **** 
 294:../drivers/fsl_spi_dma.c ****     return kStatus_Success;
 618              		.loc 1 294 0
 619 00ee 0020     		movs	r0, #0
 620              	.L16:
 295:../drivers/fsl_spi_dma.c **** }
 621              		.loc 1 295 0
 622 00f0 04B0     		add	sp, sp, #16
 623              		@ sp needed
 624              	.LVL70:
 625              	.LVL71:
 626              	.LVL72:
 627 00f2 70BD     		pop	{r4, r5, r6, pc}
 628              	.LVL73:
 629              	.L28:
 230:../drivers/fsl_spi_dma.c ****     {
 630              		.loc 1 230 0 discriminator 1
 631 00f4 6B68     		ldr	r3, [r5, #4]
 632 00f6 002B     		cmp	r3, #0
 633 00f8 00D0     		beq	.LCB627
 634 00fa 92E7     		b	.L18	@long jump
 635              	.LCB627:
 232:../drivers/fsl_spi_dma.c ****     }
 636              		.loc 1 232 0
 637 00fc 0420     		movs	r0, #4
 638 00fe F7E7     		b	.L16
 639              	.L29:
 244:../drivers/fsl_spi_dma.c ****         config.destSize = kDMA_Transfersize8bits;
 640              		.loc 1 244 0
 641 0100 5372     		strb	r3, [r2, #9]
 245:../drivers/fsl_spi_dma.c ****     }
 642              		.loc 1 245 0
 643 0102 D372     		strb	r3, [r2, #11]
 644 0104 A4E7     		b	.L20
 645              	.L21:
 262:../drivers/fsl_spi_dma.c ****         config.srcAddr = (uint32_t)(&s_dummyData[SPI_GetInstance(base)]);
 646              		.loc 1 262 0
 647 0106 0023     		movs	r3, #0
 648 0108 6A46     		mov	r2, sp
 649 010a 1372     		strb	r3, [r2, #8]
 263:../drivers/fsl_spi_dma.c ****     }
 650              		.loc 1 263 0
 651 010c 3000     		movs	r0, r6
 652 010e FFF7FEFF 		bl	SPI_GetInstance
 653              	.LVL74:
 654 0112 044B     		ldr	r3, .L30
 655 0114 C018     		adds	r0, r0, r3
 656 0116 0090     		str	r0, [sp]
 657 0118 A4E7     		b	.L22
 658              	.L25:
 226:../drivers/fsl_spi_dma.c ****     }
 659              		.loc 1 226 0
 660 011a AF20     		movs	r0, #175
 661 011c C000     		lsls	r0, r0, #3
 662 011e E7E7     		b	.L16
 663              	.L27:
 232:../drivers/fsl_spi_dma.c ****     }
 664              		.loc 1 232 0
 665 0120 0420     		movs	r0, #4
 666 0122 E5E7     		b	.L16
 667              	.L31:
 668              		.align	2
 669              	.L30:
 670 0124 00000000 		.word	s_dummyData
 671              		.cfi_endproc
 672              	.LFE85:
 674              		.section	.text.SPI_MasterTransferGetCountDMA,"ax",%progbits
 675              		.align	1
 676              		.global	SPI_MasterTransferGetCountDMA
 677              		.syntax unified
 678              		.code	16
 679              		.thumb_func
 680              		.fpu softvfp
 682              	SPI_MasterTransferGetCountDMA:
 683              	.LFB86:
 296:../drivers/fsl_spi_dma.c **** 
 297:../drivers/fsl_spi_dma.c **** status_t SPI_MasterTransferGetCountDMA(SPI_Type *base, spi_dma_handle_t *handle, size_t *count)
 298:../drivers/fsl_spi_dma.c **** {
 684              		.loc 1 298 0
 685              		.cfi_startproc
 686              		@ args = 0, pretend = 0, frame = 0
 687              		@ frame_needed = 0, uses_anonymous_args = 0
 688              		@ link register save eliminated.
 689              	.LVL75:
 299:../drivers/fsl_spi_dma.c ****     assert(handle);
 300:../drivers/fsl_spi_dma.c **** 
 301:../drivers/fsl_spi_dma.c ****     status_t status = kStatus_Success;
 302:../drivers/fsl_spi_dma.c **** 
 303:../drivers/fsl_spi_dma.c ****     if (handle->state != kSPI_Busy)
 690              		.loc 1 303 0
 691 0000 8B69     		ldr	r3, [r1, #24]
 692 0002 012B     		cmp	r3, #1
 693 0004 20D1     		bne	.L35
 304:../drivers/fsl_spi_dma.c ****     {
 305:../drivers/fsl_spi_dma.c ****         status = kStatus_NoTransferInProgress;
 306:../drivers/fsl_spi_dma.c ****     }
 307:../drivers/fsl_spi_dma.c ****     else
 308:../drivers/fsl_spi_dma.c ****     {
 309:../drivers/fsl_spi_dma.c ****         if (handle->rxInProgress)
 694              		.loc 1 309 0
 695 0006 4B78     		ldrb	r3, [r1, #1]
 696 0008 002B     		cmp	r3, #0
 697 000a 0ED1     		bne	.L36
 310:../drivers/fsl_spi_dma.c ****         {
 311:../drivers/fsl_spi_dma.c ****             *count = handle->transferSize - DMA_GetRemainingBytes(handle->rxHandle->base, handle->r
 312:../drivers/fsl_spi_dma.c ****         }
 313:../drivers/fsl_spi_dma.c ****         else
 314:../drivers/fsl_spi_dma.c ****         {
 315:../drivers/fsl_spi_dma.c ****             *count = handle->transferSize - DMA_GetRemainingBytes(handle->txHandle->base, handle->t
 698              		.loc 1 315 0
 699 000c C869     		ldr	r0, [r1, #28]
 700              	.LVL76:
 701 000e 4B68     		ldr	r3, [r1, #4]
 702 0010 1968     		ldr	r1, [r3]
 703              	.LVL77:
 704 0012 1B79     		ldrb	r3, [r3, #4]
 705              	.LVL78:
 706              	.LBB70:
 707              	.LBB71:
 449:../drivers/fsl_dma.h **** }
 708              		.loc 3 449 0
 709 0014 1B01     		lsls	r3, r3, #4
 710              	.LVL79:
 711 0016 C918     		adds	r1, r1, r3
 712              	.LVL80:
 713 0018 0931     		adds	r1, r1, #9
 714 001a FF31     		adds	r1, r1, #255
 715 001c 0B68     		ldr	r3, [r1]
 716 001e 1B02     		lsls	r3, r3, #8
 717 0020 1B0A     		lsrs	r3, r3, #8
 718              	.LVL81:
 719              	.LBE71:
 720              	.LBE70:
 721              		.loc 1 315 0
 722 0022 C31A     		subs	r3, r0, r3
 723 0024 1360     		str	r3, [r2]
 301:../drivers/fsl_spi_dma.c **** 
 724              		.loc 1 301 0
 725 0026 0020     		movs	r0, #0
 726 0028 0FE0     		b	.L32
 727              	.LVL82:
 728              	.L36:
 311:../drivers/fsl_spi_dma.c ****         }
 729              		.loc 1 311 0
 730 002a C869     		ldr	r0, [r1, #28]
 731              	.LVL83:
 732 002c 8B68     		ldr	r3, [r1, #8]
 733 002e 1968     		ldr	r1, [r3]
 734              	.LVL84:
 735 0030 1B79     		ldrb	r3, [r3, #4]
 736              	.LVL85:
 737              	.LBB72:
 738              	.LBB73:
 449:../drivers/fsl_dma.h **** }
 739              		.loc 3 449 0
 740 0032 1B01     		lsls	r3, r3, #4
 741              	.LVL86:
 742 0034 C918     		adds	r1, r1, r3
 743              	.LVL87:
 744 0036 0931     		adds	r1, r1, #9
 745 0038 FF31     		adds	r1, r1, #255
 746 003a 0B68     		ldr	r3, [r1]
 747 003c 1B02     		lsls	r3, r3, #8
 748 003e 1B0A     		lsrs	r3, r3, #8
 749              	.LVL88:
 750              	.LBE73:
 751              	.LBE72:
 311:../drivers/fsl_spi_dma.c ****         }
 752              		.loc 1 311 0
 753 0040 C31A     		subs	r3, r0, r3
 754 0042 1360     		str	r3, [r2]
 301:../drivers/fsl_spi_dma.c **** 
 755              		.loc 1 301 0
 756 0044 0020     		movs	r0, #0
 757 0046 00E0     		b	.L32
 758              	.LVL89:
 759              	.L35:
 305:../drivers/fsl_spi_dma.c ****     }
 760              		.loc 1 305 0
 761 0048 0620     		movs	r0, #6
 762              	.LVL90:
 763              	.L32:
 316:../drivers/fsl_spi_dma.c ****         }
 317:../drivers/fsl_spi_dma.c ****     }
 318:../drivers/fsl_spi_dma.c **** 
 319:../drivers/fsl_spi_dma.c ****     return status;
 320:../drivers/fsl_spi_dma.c **** }
 764              		.loc 1 320 0
 765              		@ sp needed
 766 004a 7047     		bx	lr
 767              		.cfi_endproc
 768              	.LFE86:
 770              		.section	.text.SPI_MasterTransferAbortDMA,"ax",%progbits
 771              		.align	1
 772              		.global	SPI_MasterTransferAbortDMA
 773              		.syntax unified
 774              		.code	16
 775              		.thumb_func
 776              		.fpu softvfp
 778              	SPI_MasterTransferAbortDMA:
 779              	.LFB87:
 321:../drivers/fsl_spi_dma.c **** 
 322:../drivers/fsl_spi_dma.c **** void SPI_MasterTransferAbortDMA(SPI_Type *base, spi_dma_handle_t *handle)
 323:../drivers/fsl_spi_dma.c **** {
 780              		.loc 1 323 0
 781              		.cfi_startproc
 782              		@ args = 0, pretend = 0, frame = 0
 783              		@ frame_needed = 0, uses_anonymous_args = 0
 784              	.LVL91:
 785 0000 30B5     		push	{r4, r5, lr}
 786              		.cfi_def_cfa_offset 12
 787              		.cfi_offset 4, -12
 788              		.cfi_offset 5, -8
 789              		.cfi_offset 14, -4
 324:../drivers/fsl_spi_dma.c ****     assert(handle);
 325:../drivers/fsl_spi_dma.c **** 
 326:../drivers/fsl_spi_dma.c ****     /* Disable dma */
 327:../drivers/fsl_spi_dma.c ****     DMA_StopTransfer(handle->txHandle);
 790              		.loc 1 327 0
 791 0002 4A68     		ldr	r2, [r1, #4]
 792              	.LVL92:
 793              	.LBB74:
 794              	.LBB75:
 795              		.loc 3 581 0
 796 0004 1368     		ldr	r3, [r2]
 797 0006 1279     		ldrb	r2, [r2, #4]
 798              	.LVL93:
 799 0008 1201     		lsls	r2, r2, #4
 800 000a 9B18     		adds	r3, r3, r2
 801 000c 0D33     		adds	r3, r3, #13
 802 000e FF33     		adds	r3, r3, #255
 803 0010 1C68     		ldr	r4, [r3]
 804 0012 0B4D     		ldr	r5, .L38
 805 0014 2C40     		ands	r4, r5
 806 0016 1C60     		str	r4, [r3]
 807              	.LVL94:
 808              	.LBE75:
 809              	.LBE74:
 328:../drivers/fsl_spi_dma.c ****     DMA_StopTransfer(handle->rxHandle);
 810              		.loc 1 328 0
 811 0018 8A68     		ldr	r2, [r1, #8]
 812              	.LVL95:
 813              	.LBB76:
 814              	.LBB77:
 815              		.loc 3 581 0
 816 001a 1368     		ldr	r3, [r2]
 817 001c 1479     		ldrb	r4, [r2, #4]
 818 001e 2401     		lsls	r4, r4, #4
 819 0020 1B19     		adds	r3, r3, r4
 820 0022 0D33     		adds	r3, r3, #13
 821 0024 FF33     		adds	r3, r3, #255
 822 0026 1A68     		ldr	r2, [r3]
 823              	.LVL96:
 824 0028 2A40     		ands	r2, r5
 825 002a 1A60     		str	r2, [r3]
 826              	.LVL97:
 827              	.LBE77:
 828              	.LBE76:
 829              	.LBB78:
 830              	.LBB79:
 456:../drivers/fsl_spi.h ****     }
 831              		.loc 2 456 0
 832 002c 8378     		ldrb	r3, [r0, #2]
 833 002e 2422     		movs	r2, #36
 834 0030 9343     		bics	r3, r2
 835 0032 8370     		strb	r3, [r0, #2]
 836              	.LVL98:
 837              	.LBE79:
 838              	.LBE78:
 329:../drivers/fsl_spi_dma.c **** 
 330:../drivers/fsl_spi_dma.c ****     /* Disable DMA enable bit */
 331:../drivers/fsl_spi_dma.c ****     SPI_EnableDMA(base, kSPI_DmaAllEnable, false);
 332:../drivers/fsl_spi_dma.c **** 
 333:../drivers/fsl_spi_dma.c ****     /* Set the handle state */
 334:../drivers/fsl_spi_dma.c ****     handle->txInProgress = false;
 839              		.loc 1 334 0
 840 0034 0023     		movs	r3, #0
 841 0036 0B70     		strb	r3, [r1]
 335:../drivers/fsl_spi_dma.c ****     handle->rxInProgress = false;
 842              		.loc 1 335 0
 843 0038 4B70     		strb	r3, [r1, #1]
 336:../drivers/fsl_spi_dma.c ****     handle->state = kSPI_Idle;
 844              		.loc 1 336 0
 845 003a 8B61     		str	r3, [r1, #24]
 337:../drivers/fsl_spi_dma.c **** }
 846              		.loc 1 337 0
 847              		@ sp needed
 848 003c 30BD     		pop	{r4, r5, pc}
 849              	.L39:
 850 003e C046     		.align	2
 851              	.L38:
 852 0040 FFFFFFBF 		.word	-1073741825
 853              		.cfi_endproc
 854              	.LFE87:
 856              		.section	.bss.s_dmaPrivateHandle,"aw",%nobits
 857              		.align	2
 858              		.set	.LANCHOR0,. + 0
 861              	s_dmaPrivateHandle:
 862 0000 00000000 		.space	16
 862      00000000 
 862      00000000 
 862      00000000 
 863              		.text
 864              	.Letext0:
 865              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 866              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 867              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 868              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 869              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 870              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 871              		.file 10 "../CMSIS/system_MKL17Z4.h"
 872              		.file 11 "../CMSIS/MKL17Z4.h"
 873              		.file 12 "../drivers/fsl_common.h"
 874              		.file 13 "../drivers/fsl_clock.h"
 875              		.file 14 "../drivers/fsl_spi_dma.h"
 876              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_spi_dma.c
     /tmp/ccfW58BF.s:16     .text.SPI_TxDMACallback:0000000000000000 $t
     /tmp/ccfW58BF.s:22     .text.SPI_TxDMACallback:0000000000000000 SPI_TxDMACallback
     /tmp/ccfW58BF.s:103    .text.SPI_TxDMACallback:0000000000000040 $d
     /tmp/ccfW58BF.s:108    .text.SPI_RxDMACallback:0000000000000000 $t
     /tmp/ccfW58BF.s:114    .text.SPI_RxDMACallback:0000000000000000 SPI_RxDMACallback
     /tmp/ccfW58BF.s:192    .text.SPI_RxDMACallback:0000000000000040 $d
     /tmp/ccfW58BF.s:197    .text.SPI_MasterTransferCreateHandleDMA:0000000000000000 $t
     /tmp/ccfW58BF.s:204    .text.SPI_MasterTransferCreateHandleDMA:0000000000000000 SPI_MasterTransferCreateHandleDMA
     /tmp/ccfW58BF.s:370    .text.SPI_MasterTransferCreateHandleDMA:00000000000000c4 $d
     /tmp/ccfW58BF.s:378    .text.SPI_MasterTransferDMA:0000000000000000 $t
     /tmp/ccfW58BF.s:385    .text.SPI_MasterTransferDMA:0000000000000000 SPI_MasterTransferDMA
     /tmp/ccfW58BF.s:670    .text.SPI_MasterTransferDMA:0000000000000124 $d
     /tmp/ccfW58BF.s:675    .text.SPI_MasterTransferGetCountDMA:0000000000000000 $t
     /tmp/ccfW58BF.s:682    .text.SPI_MasterTransferGetCountDMA:0000000000000000 SPI_MasterTransferGetCountDMA
     /tmp/ccfW58BF.s:771    .text.SPI_MasterTransferAbortDMA:0000000000000000 $t
     /tmp/ccfW58BF.s:778    .text.SPI_MasterTransferAbortDMA:0000000000000000 SPI_MasterTransferAbortDMA
     /tmp/ccfW58BF.s:852    .text.SPI_MasterTransferAbortDMA:0000000000000040 $d
     /tmp/ccfW58BF.s:857    .bss.s_dmaPrivateHandle:0000000000000000 $d
     /tmp/ccfW58BF.s:861    .bss.s_dmaPrivateHandle:0000000000000000 s_dmaPrivateHandle

UNDEFINED SYMBOLS
memset
SPI_GetInstance
DMA_SubmitTransfer
DMA_SetCallback
s_dummyData
