   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_smc.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.SMC_PreEnterStopModes,"ax",%progbits
  16              		.align	1
  17              		.global	SMC_PreEnterStopModes
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	SMC_PreEnterStopModes:
  24              	.LFB55:
  25              		.file 1 "../drivers/fsl_smc.c"
   1:../drivers/fsl_smc.c **** /*
   2:../drivers/fsl_smc.c ****  * The Clear BSD License
   3:../drivers/fsl_smc.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_smc.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_smc.c ****  * All rights reserved.
   6:../drivers/fsl_smc.c ****  *
   7:../drivers/fsl_smc.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_smc.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_smc.c ****  * that the following conditions are met:
  10:../drivers/fsl_smc.c ****  *
  11:../drivers/fsl_smc.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_smc.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_smc.c ****  *
  14:../drivers/fsl_smc.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_smc.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_smc.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_smc.c ****  *
  18:../drivers/fsl_smc.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_smc.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_smc.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_smc.c ****  *
  22:../drivers/fsl_smc.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_smc.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_smc.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_smc.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_smc.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_smc.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_smc.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_smc.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_smc.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_smc.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_smc.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_smc.c ****  */
  34:../drivers/fsl_smc.c **** 
  35:../drivers/fsl_smc.c **** #include "fsl_smc.h"
  36:../drivers/fsl_smc.c **** #include "fsl_flash.h"
  37:../drivers/fsl_smc.c **** #include "fsl_common.h"
  38:../drivers/fsl_smc.c **** 
  39:../drivers/fsl_smc.c **** static uint32_t g_savedPrimask;
  40:../drivers/fsl_smc.c **** 
  41:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_PARAM) && FSL_FEATURE_SMC_HAS_PARAM)
  42:../drivers/fsl_smc.c **** void SMC_GetParam(SMC_Type *base, smc_param_t *param)
  43:../drivers/fsl_smc.c **** {
  44:../drivers/fsl_smc.c ****     uint32_t reg = base->PARAM;
  45:../drivers/fsl_smc.c ****     param->hsrunEnable = (bool)(reg & SMC_PARAM_EHSRUN_MASK);
  46:../drivers/fsl_smc.c ****     param->llsEnable = (bool)(reg & SMC_PARAM_ELLS_MASK);
  47:../drivers/fsl_smc.c ****     param->lls2Enable = (bool)(reg & SMC_PARAM_ELLS2_MASK);
  48:../drivers/fsl_smc.c ****     param->vlls0Enable = (bool)(reg & SMC_PARAM_EVLLS0_MASK);
  49:../drivers/fsl_smc.c **** }
  50:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_PARAM */
  51:../drivers/fsl_smc.c **** 
  52:../drivers/fsl_smc.c **** void SMC_PreEnterStopModes(void)
  53:../drivers/fsl_smc.c **** {
  26              		.loc 1 53 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 00B5     		push	{lr}
  31              		.cfi_def_cfa_offset 4
  32              		.cfi_offset 14, -4
  33 0002 83B0     		sub	sp, sp, #12
  34              		.cfi_def_cfa_offset 16
  54:../drivers/fsl_smc.c ****     flash_prefetch_speculation_status_t speculationStatus = {
  35              		.loc 1 54 0
  36 0004 01A8     		add	r0, sp, #4
  37 0006 074B     		ldr	r3, .L2
  38 0008 1B88     		ldrh	r3, [r3]
  39 000a 0380     		strh	r3, [r0]
  40              	.LBB68:
  41              	.LBB69:
  42              	.LBB70:
  43              	.LBB71:
  44              		.file 2 "../CMSIS/cmsis_gcc.h"
   1:../CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:../CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../CMSIS/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../CMSIS/cmsis_gcc.h ****  * @version  V5.0.2
   5:../CMSIS/cmsis_gcc.h ****  * @date     13. February 2017
   6:../CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:../CMSIS/cmsis_gcc.h **** /*
   8:../CMSIS/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/cmsis_gcc.h ****  *
  10:../CMSIS/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/cmsis_gcc.h ****  *
  12:../CMSIS/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../CMSIS/cmsis_gcc.h ****  *
  16:../CMSIS/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/cmsis_gcc.h ****  *
  18:../CMSIS/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/cmsis_gcc.h ****  * limitations under the License.
  23:../CMSIS/cmsis_gcc.h ****  */
  24:../CMSIS/cmsis_gcc.h **** 
  25:../CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../CMSIS/cmsis_gcc.h **** 
  28:../CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../CMSIS/cmsis_gcc.h **** 
  34:../CMSIS/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../CMSIS/cmsis_gcc.h **** #ifndef __has_builtin
  36:../CMSIS/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../CMSIS/cmsis_gcc.h **** #endif
  38:../CMSIS/cmsis_gcc.h **** 
  39:../CMSIS/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../CMSIS/cmsis_gcc.h **** #ifndef   __ASM
  41:../CMSIS/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../CMSIS/cmsis_gcc.h **** #endif
  43:../CMSIS/cmsis_gcc.h **** #ifndef   __INLINE
  44:../CMSIS/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../CMSIS/cmsis_gcc.h **** #endif
  46:../CMSIS/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../CMSIS/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../CMSIS/cmsis_gcc.h **** #endif
  49:../CMSIS/cmsis_gcc.h **** #ifndef   __NO_RETURN
  50:../CMSIS/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((noreturn))
  51:../CMSIS/cmsis_gcc.h **** #endif
  52:../CMSIS/cmsis_gcc.h **** #ifndef   __USED
  53:../CMSIS/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  54:../CMSIS/cmsis_gcc.h **** #endif
  55:../CMSIS/cmsis_gcc.h **** #ifndef   __WEAK
  56:../CMSIS/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  57:../CMSIS/cmsis_gcc.h **** #endif
  58:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED
  59:../CMSIS/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  60:../CMSIS/cmsis_gcc.h **** #endif
  61:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  62:../CMSIS/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  63:../CMSIS/cmsis_gcc.h **** #endif
  64:../CMSIS/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  65:../CMSIS/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  66:../CMSIS/cmsis_gcc.h **** #endif
  67:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  68:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  69:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  70:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  71:../CMSIS/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  72:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  73:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  74:../CMSIS/cmsis_gcc.h **** #endif
  75:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  76:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  77:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  78:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  79:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  80:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  81:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  82:../CMSIS/cmsis_gcc.h **** #endif
  83:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  84:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  85:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  86:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  87:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  88:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  89:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  90:../CMSIS/cmsis_gcc.h **** #endif
  91:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  92:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
  93:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  94:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  95:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  96:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  97:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
  98:../CMSIS/cmsis_gcc.h **** #endif
  99:../CMSIS/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 100:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic push
 101:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 102:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 103:../CMSIS/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 104:../CMSIS/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 105:../CMSIS/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 106:../CMSIS/cmsis_gcc.h **** #endif
 107:../CMSIS/cmsis_gcc.h **** #ifndef   __ALIGNED
 108:../CMSIS/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 109:../CMSIS/cmsis_gcc.h **** #endif
 110:../CMSIS/cmsis_gcc.h **** #ifndef   __RESTRICT
 111:../CMSIS/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 112:../CMSIS/cmsis_gcc.h **** #endif
 113:../CMSIS/cmsis_gcc.h **** 
 114:../CMSIS/cmsis_gcc.h **** 
 115:../CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 116:../CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 117:../CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 118:../CMSIS/cmsis_gcc.h ****   @{
 119:../CMSIS/cmsis_gcc.h ****  */
 120:../CMSIS/cmsis_gcc.h **** 
 121:../CMSIS/cmsis_gcc.h **** /**
 122:../CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 123:../CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 124:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 125:../CMSIS/cmsis_gcc.h ****  */
 126:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
 127:../CMSIS/cmsis_gcc.h **** {
 128:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 129:../CMSIS/cmsis_gcc.h **** }
 130:../CMSIS/cmsis_gcc.h **** 
 131:../CMSIS/cmsis_gcc.h **** 
 132:../CMSIS/cmsis_gcc.h **** /**
 133:../CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 134:../CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 135:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 136:../CMSIS/cmsis_gcc.h ****  */
 137:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
 138:../CMSIS/cmsis_gcc.h **** {
 139:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 140:../CMSIS/cmsis_gcc.h **** }
 141:../CMSIS/cmsis_gcc.h **** 
 142:../CMSIS/cmsis_gcc.h **** 
 143:../CMSIS/cmsis_gcc.h **** /**
 144:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
 145:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 146:../CMSIS/cmsis_gcc.h ****   \return               Control Register value
 147:../CMSIS/cmsis_gcc.h ****  */
 148:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 149:../CMSIS/cmsis_gcc.h **** {
 150:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 151:../CMSIS/cmsis_gcc.h **** 
 152:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 153:../CMSIS/cmsis_gcc.h ****   return(result);
 154:../CMSIS/cmsis_gcc.h **** }
 155:../CMSIS/cmsis_gcc.h **** 
 156:../CMSIS/cmsis_gcc.h **** 
 157:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 158:../CMSIS/cmsis_gcc.h **** /**
 159:../CMSIS/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 160:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 161:../CMSIS/cmsis_gcc.h ****   \return               non-secure Control Register value
 162:../CMSIS/cmsis_gcc.h ****  */
 163:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 164:../CMSIS/cmsis_gcc.h **** {
 165:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 166:../CMSIS/cmsis_gcc.h **** 
 167:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 168:../CMSIS/cmsis_gcc.h ****   return(result);
 169:../CMSIS/cmsis_gcc.h **** }
 170:../CMSIS/cmsis_gcc.h **** #endif
 171:../CMSIS/cmsis_gcc.h **** 
 172:../CMSIS/cmsis_gcc.h **** 
 173:../CMSIS/cmsis_gcc.h **** /**
 174:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
 175:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 176:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 177:../CMSIS/cmsis_gcc.h ****  */
 178:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 179:../CMSIS/cmsis_gcc.h **** {
 180:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 181:../CMSIS/cmsis_gcc.h **** }
 182:../CMSIS/cmsis_gcc.h **** 
 183:../CMSIS/cmsis_gcc.h **** 
 184:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 185:../CMSIS/cmsis_gcc.h **** /**
 186:../CMSIS/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 187:../CMSIS/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 188:../CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 189:../CMSIS/cmsis_gcc.h ****  */
 190:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 191:../CMSIS/cmsis_gcc.h **** {
 192:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 193:../CMSIS/cmsis_gcc.h **** }
 194:../CMSIS/cmsis_gcc.h **** #endif
 195:../CMSIS/cmsis_gcc.h **** 
 196:../CMSIS/cmsis_gcc.h **** 
 197:../CMSIS/cmsis_gcc.h **** /**
 198:../CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 199:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 200:../CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 201:../CMSIS/cmsis_gcc.h ****  */
 202:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 203:../CMSIS/cmsis_gcc.h **** {
 204:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 205:../CMSIS/cmsis_gcc.h **** 
 206:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 207:../CMSIS/cmsis_gcc.h ****   return(result);
 208:../CMSIS/cmsis_gcc.h **** }
 209:../CMSIS/cmsis_gcc.h **** 
 210:../CMSIS/cmsis_gcc.h **** 
 211:../CMSIS/cmsis_gcc.h **** /**
 212:../CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 213:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 214:../CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 215:../CMSIS/cmsis_gcc.h ****  */
 216:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 217:../CMSIS/cmsis_gcc.h **** {
 218:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 219:../CMSIS/cmsis_gcc.h **** 
 220:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 221:../CMSIS/cmsis_gcc.h ****   return(result);
 222:../CMSIS/cmsis_gcc.h **** }
 223:../CMSIS/cmsis_gcc.h **** 
 224:../CMSIS/cmsis_gcc.h **** 
 225:../CMSIS/cmsis_gcc.h **** /**
 226:../CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 227:../CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 228:../CMSIS/cmsis_gcc.h ****   \return               xPSR Register value
 229:../CMSIS/cmsis_gcc.h ****  */
 230:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 231:../CMSIS/cmsis_gcc.h **** {
 232:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 233:../CMSIS/cmsis_gcc.h **** 
 234:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 235:../CMSIS/cmsis_gcc.h ****   return(result);
 236:../CMSIS/cmsis_gcc.h **** }
 237:../CMSIS/cmsis_gcc.h **** 
 238:../CMSIS/cmsis_gcc.h **** 
 239:../CMSIS/cmsis_gcc.h **** /**
 240:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 241:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 242:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 243:../CMSIS/cmsis_gcc.h ****  */
 244:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 245:../CMSIS/cmsis_gcc.h **** {
 246:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 247:../CMSIS/cmsis_gcc.h **** 
 248:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 249:../CMSIS/cmsis_gcc.h ****   return(result);
 250:../CMSIS/cmsis_gcc.h **** }
 251:../CMSIS/cmsis_gcc.h **** 
 252:../CMSIS/cmsis_gcc.h **** 
 253:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 254:../CMSIS/cmsis_gcc.h **** /**
 255:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 256:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 257:../CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 258:../CMSIS/cmsis_gcc.h ****  */
 259:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 260:../CMSIS/cmsis_gcc.h **** {
 261:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 262:../CMSIS/cmsis_gcc.h **** 
 263:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 264:../CMSIS/cmsis_gcc.h ****   return(result);
 265:../CMSIS/cmsis_gcc.h **** }
 266:../CMSIS/cmsis_gcc.h **** #endif
 267:../CMSIS/cmsis_gcc.h **** 
 268:../CMSIS/cmsis_gcc.h **** 
 269:../CMSIS/cmsis_gcc.h **** /**
 270:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 271:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 272:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 273:../CMSIS/cmsis_gcc.h ****  */
 274:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 275:../CMSIS/cmsis_gcc.h **** {
 276:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 277:../CMSIS/cmsis_gcc.h **** }
 278:../CMSIS/cmsis_gcc.h **** 
 279:../CMSIS/cmsis_gcc.h **** 
 280:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 281:../CMSIS/cmsis_gcc.h **** /**
 282:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 283:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 284:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 285:../CMSIS/cmsis_gcc.h ****  */
 286:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 287:../CMSIS/cmsis_gcc.h **** {
 288:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 289:../CMSIS/cmsis_gcc.h **** }
 290:../CMSIS/cmsis_gcc.h **** #endif
 291:../CMSIS/cmsis_gcc.h **** 
 292:../CMSIS/cmsis_gcc.h **** 
 293:../CMSIS/cmsis_gcc.h **** /**
 294:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 295:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 296:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 297:../CMSIS/cmsis_gcc.h ****  */
 298:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 299:../CMSIS/cmsis_gcc.h **** {
 300:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 301:../CMSIS/cmsis_gcc.h **** 
 302:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 303:../CMSIS/cmsis_gcc.h ****   return(result);
 304:../CMSIS/cmsis_gcc.h **** }
 305:../CMSIS/cmsis_gcc.h **** 
 306:../CMSIS/cmsis_gcc.h **** 
 307:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 308:../CMSIS/cmsis_gcc.h **** /**
 309:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 310:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 311:../CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 312:../CMSIS/cmsis_gcc.h ****  */
 313:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 314:../CMSIS/cmsis_gcc.h **** {
 315:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 316:../CMSIS/cmsis_gcc.h **** 
 317:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 318:../CMSIS/cmsis_gcc.h ****   return(result);
 319:../CMSIS/cmsis_gcc.h **** }
 320:../CMSIS/cmsis_gcc.h **** #endif
 321:../CMSIS/cmsis_gcc.h **** 
 322:../CMSIS/cmsis_gcc.h **** 
 323:../CMSIS/cmsis_gcc.h **** /**
 324:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 325:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 326:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 327:../CMSIS/cmsis_gcc.h ****  */
 328:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 329:../CMSIS/cmsis_gcc.h **** {
 330:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 331:../CMSIS/cmsis_gcc.h **** }
 332:../CMSIS/cmsis_gcc.h **** 
 333:../CMSIS/cmsis_gcc.h **** 
 334:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 335:../CMSIS/cmsis_gcc.h **** /**
 336:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 337:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 338:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 339:../CMSIS/cmsis_gcc.h ****  */
 340:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 341:../CMSIS/cmsis_gcc.h **** {
 342:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 343:../CMSIS/cmsis_gcc.h **** }
 344:../CMSIS/cmsis_gcc.h **** #endif
 345:../CMSIS/cmsis_gcc.h **** 
 346:../CMSIS/cmsis_gcc.h **** 
 347:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 348:../CMSIS/cmsis_gcc.h **** /**
 349:../CMSIS/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 350:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 351:../CMSIS/cmsis_gcc.h ****   \return               SP Register value
 352:../CMSIS/cmsis_gcc.h ****  */
 353:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_SP_NS(void)
 354:../CMSIS/cmsis_gcc.h **** {
 355:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 356:../CMSIS/cmsis_gcc.h **** 
 357:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 358:../CMSIS/cmsis_gcc.h ****   return(result);
 359:../CMSIS/cmsis_gcc.h **** }
 360:../CMSIS/cmsis_gcc.h **** 
 361:../CMSIS/cmsis_gcc.h **** 
 362:../CMSIS/cmsis_gcc.h **** /**
 363:../CMSIS/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 364:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 365:../CMSIS/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 366:../CMSIS/cmsis_gcc.h ****  */
 367:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 368:../CMSIS/cmsis_gcc.h **** {
 369:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 370:../CMSIS/cmsis_gcc.h **** }
 371:../CMSIS/cmsis_gcc.h **** #endif
 372:../CMSIS/cmsis_gcc.h **** 
 373:../CMSIS/cmsis_gcc.h **** 
 374:../CMSIS/cmsis_gcc.h **** /**
 375:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 376:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 377:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 378:../CMSIS/cmsis_gcc.h ****  */
 379:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 380:../CMSIS/cmsis_gcc.h **** {
 381:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 382:../CMSIS/cmsis_gcc.h **** 
 383:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
  45              		.loc 2 383 0
  46              		.syntax divided
  47              	@ 383 "../CMSIS/cmsis_gcc.h" 1
  48 000c EFF31083 		MRS r3, primask
  49              	@ 0 "" 2
  50              		.thumb
  51              		.syntax unified
  52              	.LBE71:
  53              	.LBE70:
  54              	.LBB72:
  55              	.LBB73:
 139:../CMSIS/cmsis_gcc.h **** }
  56              		.loc 2 139 0
  57              		.syntax divided
  58              	@ 139 "../CMSIS/cmsis_gcc.h" 1
  59 0010 72B6     		cpsid i
  60              	@ 0 "" 2
  61              		.thumb
  62              		.syntax unified
  63              	.LBE73:
  64              	.LBE72:
  65              	.LBE69:
  66              	.LBE68:
  55:../drivers/fsl_smc.c ****         kFLASH_prefetchSpeculationOptionDisable, /* Disable instruction speculation.*/
  56:../drivers/fsl_smc.c ****         kFLASH_prefetchSpeculationOptionDisable, /* Disable data speculation.*/
  57:../drivers/fsl_smc.c ****     };
  58:../drivers/fsl_smc.c **** 
  59:../drivers/fsl_smc.c ****     g_savedPrimask = DisableGlobalIRQ();
  67              		.loc 1 59 0
  68 0012 054A     		ldr	r2, .L2+4
  69 0014 1360     		str	r3, [r2]
  70              	.LBB74:
  71              	.LBB75:
 384:../CMSIS/cmsis_gcc.h ****   return(result);
 385:../CMSIS/cmsis_gcc.h **** }
 386:../CMSIS/cmsis_gcc.h **** 
 387:../CMSIS/cmsis_gcc.h **** 
 388:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 389:../CMSIS/cmsis_gcc.h **** /**
 390:../CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 391:../CMSIS/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 392:../CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 393:../CMSIS/cmsis_gcc.h ****  */
 394:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 395:../CMSIS/cmsis_gcc.h **** {
 396:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 397:../CMSIS/cmsis_gcc.h **** 
 398:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 399:../CMSIS/cmsis_gcc.h ****   return(result);
 400:../CMSIS/cmsis_gcc.h **** }
 401:../CMSIS/cmsis_gcc.h **** #endif
 402:../CMSIS/cmsis_gcc.h **** 
 403:../CMSIS/cmsis_gcc.h **** 
 404:../CMSIS/cmsis_gcc.h **** /**
 405:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 406:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 407:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 408:../CMSIS/cmsis_gcc.h ****  */
 409:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 410:../CMSIS/cmsis_gcc.h **** {
 411:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 412:../CMSIS/cmsis_gcc.h **** }
 413:../CMSIS/cmsis_gcc.h **** 
 414:../CMSIS/cmsis_gcc.h **** 
 415:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 416:../CMSIS/cmsis_gcc.h **** /**
 417:../CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 418:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 419:../CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 420:../CMSIS/cmsis_gcc.h ****  */
 421:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 422:../CMSIS/cmsis_gcc.h **** {
 423:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 424:../CMSIS/cmsis_gcc.h **** }
 425:../CMSIS/cmsis_gcc.h **** #endif
 426:../CMSIS/cmsis_gcc.h **** 
 427:../CMSIS/cmsis_gcc.h **** 
 428:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 429:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 430:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 431:../CMSIS/cmsis_gcc.h **** /**
 432:../CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 433:../CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 434:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 435:../CMSIS/cmsis_gcc.h ****  */
 436:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 437:../CMSIS/cmsis_gcc.h **** {
 438:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 439:../CMSIS/cmsis_gcc.h **** }
 440:../CMSIS/cmsis_gcc.h **** 
 441:../CMSIS/cmsis_gcc.h **** 
 442:../CMSIS/cmsis_gcc.h **** /**
 443:../CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 444:../CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 445:../CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 446:../CMSIS/cmsis_gcc.h ****  */
 447:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 448:../CMSIS/cmsis_gcc.h **** {
 449:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 450:../CMSIS/cmsis_gcc.h **** }
 451:../CMSIS/cmsis_gcc.h **** 
 452:../CMSIS/cmsis_gcc.h **** 
 453:../CMSIS/cmsis_gcc.h **** /**
 454:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 455:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 456:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 457:../CMSIS/cmsis_gcc.h ****  */
 458:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 459:../CMSIS/cmsis_gcc.h **** {
 460:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 461:../CMSIS/cmsis_gcc.h **** 
 462:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 463:../CMSIS/cmsis_gcc.h ****   return(result);
 464:../CMSIS/cmsis_gcc.h **** }
 465:../CMSIS/cmsis_gcc.h **** 
 466:../CMSIS/cmsis_gcc.h **** 
 467:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 468:../CMSIS/cmsis_gcc.h **** /**
 469:../CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 470:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 471:../CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 472:../CMSIS/cmsis_gcc.h ****  */
 473:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 474:../CMSIS/cmsis_gcc.h **** {
 475:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 476:../CMSIS/cmsis_gcc.h **** 
 477:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 478:../CMSIS/cmsis_gcc.h ****   return(result);
 479:../CMSIS/cmsis_gcc.h **** }
 480:../CMSIS/cmsis_gcc.h **** #endif
 481:../CMSIS/cmsis_gcc.h **** 
 482:../CMSIS/cmsis_gcc.h **** 
 483:../CMSIS/cmsis_gcc.h **** /**
 484:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 485:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 486:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 487:../CMSIS/cmsis_gcc.h ****  */
 488:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 489:../CMSIS/cmsis_gcc.h **** {
 490:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 491:../CMSIS/cmsis_gcc.h **** }
 492:../CMSIS/cmsis_gcc.h **** 
 493:../CMSIS/cmsis_gcc.h **** 
 494:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 495:../CMSIS/cmsis_gcc.h **** /**
 496:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 497:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 498:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 499:../CMSIS/cmsis_gcc.h ****  */
 500:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 501:../CMSIS/cmsis_gcc.h **** {
 502:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 503:../CMSIS/cmsis_gcc.h **** }
 504:../CMSIS/cmsis_gcc.h **** #endif
 505:../CMSIS/cmsis_gcc.h **** 
 506:../CMSIS/cmsis_gcc.h **** 
 507:../CMSIS/cmsis_gcc.h **** /**
 508:../CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 509:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 510:../CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 511:../CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 512:../CMSIS/cmsis_gcc.h ****  */
 513:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 514:../CMSIS/cmsis_gcc.h **** {
 515:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 516:../CMSIS/cmsis_gcc.h **** }
 517:../CMSIS/cmsis_gcc.h **** 
 518:../CMSIS/cmsis_gcc.h **** 
 519:../CMSIS/cmsis_gcc.h **** /**
 520:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 521:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 522:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 523:../CMSIS/cmsis_gcc.h ****  */
 524:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 525:../CMSIS/cmsis_gcc.h **** {
 526:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 527:../CMSIS/cmsis_gcc.h **** 
 528:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 529:../CMSIS/cmsis_gcc.h ****   return(result);
 530:../CMSIS/cmsis_gcc.h **** }
 531:../CMSIS/cmsis_gcc.h **** 
 532:../CMSIS/cmsis_gcc.h **** 
 533:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 534:../CMSIS/cmsis_gcc.h **** /**
 535:../CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 536:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 537:../CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 538:../CMSIS/cmsis_gcc.h ****  */
 539:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 540:../CMSIS/cmsis_gcc.h **** {
 541:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 542:../CMSIS/cmsis_gcc.h **** 
 543:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 544:../CMSIS/cmsis_gcc.h ****   return(result);
 545:../CMSIS/cmsis_gcc.h **** }
 546:../CMSIS/cmsis_gcc.h **** #endif
 547:../CMSIS/cmsis_gcc.h **** 
 548:../CMSIS/cmsis_gcc.h **** 
 549:../CMSIS/cmsis_gcc.h **** /**
 550:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 551:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 552:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 553:../CMSIS/cmsis_gcc.h ****  */
 554:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 555:../CMSIS/cmsis_gcc.h **** {
 556:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 557:../CMSIS/cmsis_gcc.h **** }
 558:../CMSIS/cmsis_gcc.h **** 
 559:../CMSIS/cmsis_gcc.h **** 
 560:../CMSIS/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 561:../CMSIS/cmsis_gcc.h **** /**
 562:../CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 563:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 564:../CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 565:../CMSIS/cmsis_gcc.h ****  */
 566:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 567:../CMSIS/cmsis_gcc.h **** {
 568:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 569:../CMSIS/cmsis_gcc.h **** }
 570:../CMSIS/cmsis_gcc.h **** #endif
 571:../CMSIS/cmsis_gcc.h **** 
 572:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 573:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 574:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 575:../CMSIS/cmsis_gcc.h **** 
 576:../CMSIS/cmsis_gcc.h **** 
 577:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 578:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 579:../CMSIS/cmsis_gcc.h **** 
 580:../CMSIS/cmsis_gcc.h **** /**
 581:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 582:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 583:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 584:../CMSIS/cmsis_gcc.h ****  */
 585:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 586:../CMSIS/cmsis_gcc.h **** {
 587:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 588:../CMSIS/cmsis_gcc.h **** 
 589:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 590:../CMSIS/cmsis_gcc.h ****   return(result);
 591:../CMSIS/cmsis_gcc.h **** }
 592:../CMSIS/cmsis_gcc.h **** 
 593:../CMSIS/cmsis_gcc.h **** 
 594:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 595:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 596:../CMSIS/cmsis_gcc.h **** /**
 597:../CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 598:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 599:../CMSIS/cmsis_gcc.h ****   \return               PSPLIM Register value
 600:../CMSIS/cmsis_gcc.h ****  */
 601:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 602:../CMSIS/cmsis_gcc.h **** {
 603:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 604:../CMSIS/cmsis_gcc.h **** 
 605:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 606:../CMSIS/cmsis_gcc.h ****   return(result);
 607:../CMSIS/cmsis_gcc.h **** }
 608:../CMSIS/cmsis_gcc.h **** #endif
 609:../CMSIS/cmsis_gcc.h **** 
 610:../CMSIS/cmsis_gcc.h **** 
 611:../CMSIS/cmsis_gcc.h **** /**
 612:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 613:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 614:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 615:../CMSIS/cmsis_gcc.h ****  */
 616:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 617:../CMSIS/cmsis_gcc.h **** {
 618:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 619:../CMSIS/cmsis_gcc.h **** }
 620:../CMSIS/cmsis_gcc.h **** 
 621:../CMSIS/cmsis_gcc.h **** 
 622:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 623:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 624:../CMSIS/cmsis_gcc.h **** /**
 625:../CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 626:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 627:../CMSIS/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 628:../CMSIS/cmsis_gcc.h ****  */
 629:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 630:../CMSIS/cmsis_gcc.h **** {
 631:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 632:../CMSIS/cmsis_gcc.h **** }
 633:../CMSIS/cmsis_gcc.h **** #endif
 634:../CMSIS/cmsis_gcc.h **** 
 635:../CMSIS/cmsis_gcc.h **** 
 636:../CMSIS/cmsis_gcc.h **** /**
 637:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 638:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 639:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 640:../CMSIS/cmsis_gcc.h ****  */
 641:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 642:../CMSIS/cmsis_gcc.h **** {
 643:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 644:../CMSIS/cmsis_gcc.h **** 
 645:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 646:../CMSIS/cmsis_gcc.h **** 
 647:../CMSIS/cmsis_gcc.h ****   return(result);
 648:../CMSIS/cmsis_gcc.h **** }
 649:../CMSIS/cmsis_gcc.h **** 
 650:../CMSIS/cmsis_gcc.h **** 
 651:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 652:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 653:../CMSIS/cmsis_gcc.h **** /**
 654:../CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 655:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 656:../CMSIS/cmsis_gcc.h ****   \return               MSPLIM Register value
 657:../CMSIS/cmsis_gcc.h ****  */
 658:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 659:../CMSIS/cmsis_gcc.h **** {
 660:../CMSIS/cmsis_gcc.h ****   register uint32_t result;
 661:../CMSIS/cmsis_gcc.h **** 
 662:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 663:../CMSIS/cmsis_gcc.h ****   return(result);
 664:../CMSIS/cmsis_gcc.h **** }
 665:../CMSIS/cmsis_gcc.h **** #endif
 666:../CMSIS/cmsis_gcc.h **** 
 667:../CMSIS/cmsis_gcc.h **** 
 668:../CMSIS/cmsis_gcc.h **** /**
 669:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 670:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 671:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 672:../CMSIS/cmsis_gcc.h ****  */
 673:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 674:../CMSIS/cmsis_gcc.h **** {
 675:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 676:../CMSIS/cmsis_gcc.h **** }
 677:../CMSIS/cmsis_gcc.h **** 
 678:../CMSIS/cmsis_gcc.h **** 
 679:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 680:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 681:../CMSIS/cmsis_gcc.h **** /**
 682:../CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 683:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 684:../CMSIS/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 685:../CMSIS/cmsis_gcc.h ****  */
 686:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 687:../CMSIS/cmsis_gcc.h **** {
 688:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 689:../CMSIS/cmsis_gcc.h **** }
 690:../CMSIS/cmsis_gcc.h **** #endif
 691:../CMSIS/cmsis_gcc.h **** 
 692:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 693:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 694:../CMSIS/cmsis_gcc.h **** 
 695:../CMSIS/cmsis_gcc.h **** 
 696:../CMSIS/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 697:../CMSIS/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 698:../CMSIS/cmsis_gcc.h **** 
 699:../CMSIS/cmsis_gcc.h **** /**
 700:../CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 701:../CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 702:../CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 703:../CMSIS/cmsis_gcc.h ****  */
 704:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 705:../CMSIS/cmsis_gcc.h **** {
 706:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 707:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 708:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 709:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 710:../CMSIS/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 711:../CMSIS/cmsis_gcc.h **** #else
 712:../CMSIS/cmsis_gcc.h ****   uint32_t result;
 713:../CMSIS/cmsis_gcc.h **** 
 714:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 715:../CMSIS/cmsis_gcc.h ****   return(result);
 716:../CMSIS/cmsis_gcc.h **** #endif
 717:../CMSIS/cmsis_gcc.h **** #else
 718:../CMSIS/cmsis_gcc.h ****   return(0U);
 719:../CMSIS/cmsis_gcc.h **** #endif
 720:../CMSIS/cmsis_gcc.h **** }
 721:../CMSIS/cmsis_gcc.h **** 
 722:../CMSIS/cmsis_gcc.h **** 
 723:../CMSIS/cmsis_gcc.h **** /**
 724:../CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 725:../CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 726:../CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 727:../CMSIS/cmsis_gcc.h ****  */
 728:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 729:../CMSIS/cmsis_gcc.h **** {
 730:../CMSIS/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 731:../CMSIS/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 732:../CMSIS/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 733:../CMSIS/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 734:../CMSIS/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 735:../CMSIS/cmsis_gcc.h **** #else
 736:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 737:../CMSIS/cmsis_gcc.h **** #endif
 738:../CMSIS/cmsis_gcc.h **** #else
 739:../CMSIS/cmsis_gcc.h ****   (void)fpscr;
 740:../CMSIS/cmsis_gcc.h **** #endif
 741:../CMSIS/cmsis_gcc.h **** }
 742:../CMSIS/cmsis_gcc.h **** 
 743:../CMSIS/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 744:../CMSIS/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 745:../CMSIS/cmsis_gcc.h **** 
 746:../CMSIS/cmsis_gcc.h **** 
 747:../CMSIS/cmsis_gcc.h **** 
 748:../CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 749:../CMSIS/cmsis_gcc.h **** 
 750:../CMSIS/cmsis_gcc.h **** 
 751:../CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 752:../CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 753:../CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 754:../CMSIS/cmsis_gcc.h ****   @{
 755:../CMSIS/cmsis_gcc.h **** */
 756:../CMSIS/cmsis_gcc.h **** 
 757:../CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 758:../CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 759:../CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 760:../CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 761:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 762:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 763:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 764:../CMSIS/cmsis_gcc.h **** #else
 765:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 766:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 767:../CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 768:../CMSIS/cmsis_gcc.h **** #endif
 769:../CMSIS/cmsis_gcc.h **** 
 770:../CMSIS/cmsis_gcc.h **** /**
 771:../CMSIS/cmsis_gcc.h ****   \brief   No Operation
 772:../CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 773:../CMSIS/cmsis_gcc.h ****  */
 774:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 775:../CMSIS/cmsis_gcc.h **** //{
 776:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("nop");
 777:../CMSIS/cmsis_gcc.h **** //}
 778:../CMSIS/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 779:../CMSIS/cmsis_gcc.h **** 
 780:../CMSIS/cmsis_gcc.h **** /**
 781:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Interrupt
 782:../CMSIS/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 783:../CMSIS/cmsis_gcc.h ****  */
 784:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 785:../CMSIS/cmsis_gcc.h **** //{
 786:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 787:../CMSIS/cmsis_gcc.h **** //}
 788:../CMSIS/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 789:../CMSIS/cmsis_gcc.h **** 
 790:../CMSIS/cmsis_gcc.h **** 
 791:../CMSIS/cmsis_gcc.h **** /**
 792:../CMSIS/cmsis_gcc.h ****   \brief   Wait For Event
 793:../CMSIS/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 794:../CMSIS/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 795:../CMSIS/cmsis_gcc.h ****  */
 796:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 797:../CMSIS/cmsis_gcc.h **** //{
 798:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 799:../CMSIS/cmsis_gcc.h **** //}
 800:../CMSIS/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 801:../CMSIS/cmsis_gcc.h **** 
 802:../CMSIS/cmsis_gcc.h **** 
 803:../CMSIS/cmsis_gcc.h **** /**
 804:../CMSIS/cmsis_gcc.h ****   \brief   Send Event
 805:../CMSIS/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 806:../CMSIS/cmsis_gcc.h ****  */
 807:../CMSIS/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 808:../CMSIS/cmsis_gcc.h **** //{
 809:../CMSIS/cmsis_gcc.h **** //  __ASM volatile ("sev");
 810:../CMSIS/cmsis_gcc.h **** //}
 811:../CMSIS/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 812:../CMSIS/cmsis_gcc.h **** 
 813:../CMSIS/cmsis_gcc.h **** 
 814:../CMSIS/cmsis_gcc.h **** /**
 815:../CMSIS/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 816:../CMSIS/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 817:../CMSIS/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 818:../CMSIS/cmsis_gcc.h ****            after the instruction has been completed.
 819:../CMSIS/cmsis_gcc.h ****  */
 820:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 821:../CMSIS/cmsis_gcc.h **** {
 822:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
  72              		.loc 2 822 0
  73              		.syntax divided
  74              	@ 822 "../CMSIS/cmsis_gcc.h" 1
  75 0016 BFF36F8F 		isb 0xF
  76              	@ 0 "" 2
  77              		.thumb
  78              		.syntax unified
  79              	.LBE75:
  80              	.LBE74:
  60:../drivers/fsl_smc.c ****     __ISB();
  61:../drivers/fsl_smc.c **** 
  62:../drivers/fsl_smc.c ****     /*
  63:../drivers/fsl_smc.c ****      * Before enter stop modes, the flash cache prefetch should be disabled.
  64:../drivers/fsl_smc.c ****      * Otherwise the prefetch might be interrupted by stop, then the data and
  65:../drivers/fsl_smc.c ****      * and instruction from flash are wrong.
  66:../drivers/fsl_smc.c ****      */
  67:../drivers/fsl_smc.c ****     FLASH_PflashSetPrefetchSpeculation(&speculationStatus);
  81              		.loc 1 67 0
  82 001a FFF7FEFF 		bl	FLASH_PflashSetPrefetchSpeculation
  83              	.LVL0:
  68:../drivers/fsl_smc.c **** }
  84              		.loc 1 68 0
  85 001e 03B0     		add	sp, sp, #12
  86              		@ sp needed
  87 0020 00BD     		pop	{pc}
  88              	.L3:
  89 0022 C046     		.align	2
  90              	.L2:
  91 0024 00000000 		.word	.LANCHOR0
  92 0028 00000000 		.word	.LANCHOR1
  93              		.cfi_endproc
  94              	.LFE55:
  96              		.section	.text.SMC_PostExitStopModes,"ax",%progbits
  97              		.align	1
  98              		.global	SMC_PostExitStopModes
  99              		.syntax unified
 100              		.code	16
 101              		.thumb_func
 102              		.fpu softvfp
 104              	SMC_PostExitStopModes:
 105              	.LFB56:
  69:../drivers/fsl_smc.c **** 
  70:../drivers/fsl_smc.c **** void SMC_PostExitStopModes(void)
  71:../drivers/fsl_smc.c **** {
 106              		.loc 1 71 0
 107              		.cfi_startproc
 108              		@ args = 0, pretend = 0, frame = 8
 109              		@ frame_needed = 0, uses_anonymous_args = 0
 110 0000 00B5     		push	{lr}
 111              		.cfi_def_cfa_offset 4
 112              		.cfi_offset 14, -4
 113 0002 83B0     		sub	sp, sp, #12
 114              		.cfi_def_cfa_offset 16
  72:../drivers/fsl_smc.c ****     flash_prefetch_speculation_status_t speculationStatus = {
 115              		.loc 1 72 0
 116 0004 01A8     		add	r0, sp, #4
 117 0006 0023     		movs	r3, #0
 118 0008 0370     		strb	r3, [r0]
 119 000a 4370     		strb	r3, [r0, #1]
  73:../drivers/fsl_smc.c ****         kFLASH_prefetchSpeculationOptionEnable, /* Enable instruction speculation.*/
  74:../drivers/fsl_smc.c ****         kFLASH_prefetchSpeculationOptionEnable, /* Enable data speculation.*/
  75:../drivers/fsl_smc.c ****     };
  76:../drivers/fsl_smc.c **** 
  77:../drivers/fsl_smc.c ****     FLASH_PflashSetPrefetchSpeculation(&speculationStatus);
 120              		.loc 1 77 0
 121 000c FFF7FEFF 		bl	FLASH_PflashSetPrefetchSpeculation
 122              	.LVL1:
  78:../drivers/fsl_smc.c **** 
  79:../drivers/fsl_smc.c ****     EnableGlobalIRQ(g_savedPrimask);
 123              		.loc 1 79 0
 124 0010 034B     		ldr	r3, .L5
 125 0012 1B68     		ldr	r3, [r3]
 126              	.LVL2:
 127              	.LBB76:
 128              	.LBB77:
 129              	.LBB78:
 411:../CMSIS/cmsis_gcc.h **** }
 130              		.loc 2 411 0
 131              		.syntax divided
 132              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 133 0014 83F31088 		MSR primask, r3
 134              	@ 0 "" 2
 135              	.LVL3:
 136              		.thumb
 137              		.syntax unified
 138              	.LBE78:
 139              	.LBE77:
 140              	.LBE76:
 141              	.LBB79:
 142              	.LBB80:
 143              		.loc 2 822 0
 144              		.syntax divided
 145              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 146 0018 BFF36F8F 		isb 0xF
 147              	@ 0 "" 2
 148              		.thumb
 149              		.syntax unified
 150              	.LBE80:
 151              	.LBE79:
  80:../drivers/fsl_smc.c ****     __ISB();
  81:../drivers/fsl_smc.c **** }
 152              		.loc 1 81 0
 153 001c 03B0     		add	sp, sp, #12
 154              		@ sp needed
 155 001e 00BD     		pop	{pc}
 156              	.L6:
 157              		.align	2
 158              	.L5:
 159 0020 00000000 		.word	.LANCHOR1
 160              		.cfi_endproc
 161              	.LFE56:
 163              		.section	.text.SMC_PreEnterWaitModes,"ax",%progbits
 164              		.align	1
 165              		.global	SMC_PreEnterWaitModes
 166              		.syntax unified
 167              		.code	16
 168              		.thumb_func
 169              		.fpu softvfp
 171              	SMC_PreEnterWaitModes:
 172              	.LFB57:
  82:../drivers/fsl_smc.c **** 
  83:../drivers/fsl_smc.c **** void SMC_PreEnterWaitModes(void)
  84:../drivers/fsl_smc.c **** {
 173              		.loc 1 84 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178              	.LBB81:
 179              	.LBB82:
 180              	.LBB83:
 181              	.LBB84:
 383:../CMSIS/cmsis_gcc.h ****   return(result);
 182              		.loc 2 383 0
 183              		.syntax divided
 184              	@ 383 "../CMSIS/cmsis_gcc.h" 1
 185 0000 EFF31083 		MRS r3, primask
 186              	@ 0 "" 2
 187              		.thumb
 188              		.syntax unified
 189              	.LBE84:
 190              	.LBE83:
 191              	.LBB85:
 192              	.LBB86:
 139:../CMSIS/cmsis_gcc.h **** }
 193              		.loc 2 139 0
 194              		.syntax divided
 195              	@ 139 "../CMSIS/cmsis_gcc.h" 1
 196 0004 72B6     		cpsid i
 197              	@ 0 "" 2
 198              		.thumb
 199              		.syntax unified
 200              	.LBE86:
 201              	.LBE85:
 202              	.LBE82:
 203              	.LBE81:
  85:../drivers/fsl_smc.c ****     g_savedPrimask = DisableGlobalIRQ();
 204              		.loc 1 85 0
 205 0006 024A     		ldr	r2, .L8
 206 0008 1360     		str	r3, [r2]
 207              	.LBB87:
 208              	.LBB88:
 209              		.loc 2 822 0
 210              		.syntax divided
 211              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 212 000a BFF36F8F 		isb 0xF
 213              	@ 0 "" 2
 214              		.thumb
 215              		.syntax unified
 216              	.LBE88:
 217              	.LBE87:
  86:../drivers/fsl_smc.c ****     __ISB();
  87:../drivers/fsl_smc.c **** }
 218              		.loc 1 87 0
 219              		@ sp needed
 220 000e 7047     		bx	lr
 221              	.L9:
 222              		.align	2
 223              	.L8:
 224 0010 00000000 		.word	.LANCHOR1
 225              		.cfi_endproc
 226              	.LFE57:
 228              		.section	.text.SMC_PostExitWaitModes,"ax",%progbits
 229              		.align	1
 230              		.global	SMC_PostExitWaitModes
 231              		.syntax unified
 232              		.code	16
 233              		.thumb_func
 234              		.fpu softvfp
 236              	SMC_PostExitWaitModes:
 237              	.LFB58:
  88:../drivers/fsl_smc.c **** 
  89:../drivers/fsl_smc.c **** void SMC_PostExitWaitModes(void)
  90:../drivers/fsl_smc.c **** {
 238              		.loc 1 90 0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
  91:../drivers/fsl_smc.c ****     EnableGlobalIRQ(g_savedPrimask);
 243              		.loc 1 91 0
 244 0000 034B     		ldr	r3, .L11
 245 0002 1B68     		ldr	r3, [r3]
 246              	.LVL4:
 247              	.LBB89:
 248              	.LBB90:
 249              	.LBB91:
 411:../CMSIS/cmsis_gcc.h **** }
 250              		.loc 2 411 0
 251              		.syntax divided
 252              	@ 411 "../CMSIS/cmsis_gcc.h" 1
 253 0004 83F31088 		MSR primask, r3
 254              	@ 0 "" 2
 255              	.LVL5:
 256              		.thumb
 257              		.syntax unified
 258              	.LBE91:
 259              	.LBE90:
 260              	.LBE89:
 261              	.LBB92:
 262              	.LBB93:
 263              		.loc 2 822 0
 264              		.syntax divided
 265              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 266 0008 BFF36F8F 		isb 0xF
 267              	@ 0 "" 2
 268              		.thumb
 269              		.syntax unified
 270              	.LBE93:
 271              	.LBE92:
  92:../drivers/fsl_smc.c ****     __ISB();
  93:../drivers/fsl_smc.c **** }
 272              		.loc 1 93 0
 273              		@ sp needed
 274 000c 7047     		bx	lr
 275              	.L12:
 276 000e C046     		.align	2
 277              	.L11:
 278 0010 00000000 		.word	.LANCHOR1
 279              		.cfi_endproc
 280              	.LFE58:
 282              		.section	.text.SMC_SetPowerModeRun,"ax",%progbits
 283              		.align	1
 284              		.global	SMC_SetPowerModeRun
 285              		.syntax unified
 286              		.code	16
 287              		.thumb_func
 288              		.fpu softvfp
 290              	SMC_SetPowerModeRun:
 291              	.LFB59:
  94:../drivers/fsl_smc.c **** 
  95:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeRun(SMC_Type *base)
  96:../drivers/fsl_smc.c **** {
 292              		.loc 1 96 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 296              		@ link register save eliminated.
 297              	.LVL6:
  97:../drivers/fsl_smc.c ****     uint8_t reg;
  98:../drivers/fsl_smc.c **** 
  99:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 298              		.loc 1 99 0
 299 0000 4378     		ldrb	r3, [r0, #1]
 300              	.LVL7:
 100:../drivers/fsl_smc.c ****     /* configure Normal RUN mode */
 101:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_RUNM_MASK;
 301              		.loc 1 101 0
 302 0002 6022     		movs	r2, #96
 303 0004 9343     		bics	r3, r2
 304              	.LVL8:
 102:../drivers/fsl_smc.c ****     reg |= (kSMC_RunNormal << SMC_PMCTRL_RUNM_SHIFT);
 103:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 305              		.loc 1 103 0
 306 0006 4370     		strb	r3, [r0, #1]
 104:../drivers/fsl_smc.c **** 
 105:../drivers/fsl_smc.c ****     return kStatus_Success;
 106:../drivers/fsl_smc.c **** }
 307              		.loc 1 106 0
 308 0008 0020     		movs	r0, #0
 309              	.LVL9:
 310              		@ sp needed
 311 000a 7047     		bx	lr
 312              		.cfi_endproc
 313              	.LFE59:
 315              		.section	.text.SMC_SetPowerModeWait,"ax",%progbits
 316              		.align	1
 317              		.global	SMC_SetPowerModeWait
 318              		.syntax unified
 319              		.code	16
 320              		.thumb_func
 321              		.fpu softvfp
 323              	SMC_SetPowerModeWait:
 324              	.LFB60:
 107:../drivers/fsl_smc.c **** 
 108:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
 109:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeHsrun(SMC_Type *base)
 110:../drivers/fsl_smc.c **** {
 111:../drivers/fsl_smc.c ****     uint8_t reg;
 112:../drivers/fsl_smc.c **** 
 113:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 114:../drivers/fsl_smc.c ****     /* configure High Speed RUN mode */
 115:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_RUNM_MASK;
 116:../drivers/fsl_smc.c ****     reg |= (kSMC_Hsrun << SMC_PMCTRL_RUNM_SHIFT);
 117:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 118:../drivers/fsl_smc.c **** 
 119:../drivers/fsl_smc.c ****     return kStatus_Success;
 120:../drivers/fsl_smc.c **** }
 121:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
 122:../drivers/fsl_smc.c **** 
 123:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeWait(SMC_Type *base)
 124:../drivers/fsl_smc.c **** {
 325              		.loc 1 124 0
 326              		.cfi_startproc
 327              		@ args = 0, pretend = 0, frame = 0
 328              		@ frame_needed = 0, uses_anonymous_args = 0
 329              		@ link register save eliminated.
 330              	.LVL10:
 125:../drivers/fsl_smc.c ****     /* configure Normal Wait mode */
 126:../drivers/fsl_smc.c ****     SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
 331              		.loc 1 126 0
 332 0000 054A     		ldr	r2, .L15
 333 0002 1369     		ldr	r3, [r2, #16]
 334 0004 0421     		movs	r1, #4
 335 0006 8B43     		bics	r3, r1
 336 0008 1361     		str	r3, [r2, #16]
 337              	.LBB94:
 338              	.LBB95:
 823:../CMSIS/cmsis_gcc.h **** }
 824:../CMSIS/cmsis_gcc.h **** 
 825:../CMSIS/cmsis_gcc.h **** 
 826:../CMSIS/cmsis_gcc.h **** /**
 827:../CMSIS/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 828:../CMSIS/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 829:../CMSIS/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 830:../CMSIS/cmsis_gcc.h ****  */
 831:../CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 832:../CMSIS/cmsis_gcc.h **** {
 833:../CMSIS/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 339              		.loc 2 833 0
 340              		.syntax divided
 341              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 342 000a BFF34F8F 		dsb 0xF
 343              	@ 0 "" 2
 344              		.thumb
 345              		.syntax unified
 346              	.LBE95:
 347              	.LBE94:
 127:../drivers/fsl_smc.c ****     __DSB();
 128:../drivers/fsl_smc.c ****     __WFI();
 348              		.loc 1 128 0
 349              		.syntax divided
 350              	@ 128 "../drivers/fsl_smc.c" 1
 351 000e 30BF     		wfi
 352              	@ 0 "" 2
 353              		.thumb
 354              		.syntax unified
 355              	.LBB96:
 356              	.LBB97:
 822:../CMSIS/cmsis_gcc.h **** }
 357              		.loc 2 822 0
 358              		.syntax divided
 359              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 360 0010 BFF36F8F 		isb 0xF
 361              	@ 0 "" 2
 362              		.thumb
 363              		.syntax unified
 364              	.LBE97:
 365              	.LBE96:
 129:../drivers/fsl_smc.c ****     __ISB();
 130:../drivers/fsl_smc.c **** 
 131:../drivers/fsl_smc.c ****     return kStatus_Success;
 132:../drivers/fsl_smc.c **** }
 366              		.loc 1 132 0
 367 0014 0020     		movs	r0, #0
 368              	.LVL11:
 369              		@ sp needed
 370 0016 7047     		bx	lr
 371              	.L16:
 372              		.align	2
 373              	.L15:
 374 0018 00ED00E0 		.word	-536810240
 375              		.cfi_endproc
 376              	.LFE60:
 378              		.section	.text.SMC_SetPowerModeStop,"ax",%progbits
 379              		.align	1
 380              		.global	SMC_SetPowerModeStop
 381              		.syntax unified
 382              		.code	16
 383              		.thumb_func
 384              		.fpu softvfp
 386              	SMC_SetPowerModeStop:
 387              	.LFB61:
 133:../drivers/fsl_smc.c **** 
 134:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeStop(SMC_Type *base, smc_partial_stop_option_t option)
 135:../drivers/fsl_smc.c **** {
 388              		.loc 1 135 0
 389              		.cfi_startproc
 390              		@ args = 0, pretend = 0, frame = 0
 391              		@ frame_needed = 0, uses_anonymous_args = 0
 392              		@ link register save eliminated.
 393              	.LVL12:
 136:../drivers/fsl_smc.c ****     uint8_t reg;
 137:../drivers/fsl_smc.c **** 
 138:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_PSTOPO) && FSL_FEATURE_SMC_HAS_PSTOPO)
 139:../drivers/fsl_smc.c ****     /* configure the Partial Stop mode in Noraml Stop mode */
 140:../drivers/fsl_smc.c ****     reg = base->STOPCTRL;
 394              		.loc 1 140 0
 395 0000 8378     		ldrb	r3, [r0, #2]
 396              	.LVL13:
 141:../drivers/fsl_smc.c ****     reg &= ~SMC_STOPCTRL_PSTOPO_MASK;
 397              		.loc 1 141 0
 398 0002 3F22     		movs	r2, #63
 399 0004 1340     		ands	r3, r2
 400              	.LVL14:
 142:../drivers/fsl_smc.c ****     reg |= ((uint32_t)option << SMC_STOPCTRL_PSTOPO_SHIFT);
 401              		.loc 1 142 0
 402 0006 8901     		lsls	r1, r1, #6
 403              	.LVL15:
 404 0008 C9B2     		uxtb	r1, r1
 405 000a 1943     		orrs	r1, r3
 406              	.LVL16:
 143:../drivers/fsl_smc.c ****     base->STOPCTRL = reg;
 407              		.loc 1 143 0
 408 000c 8170     		strb	r1, [r0, #2]
 144:../drivers/fsl_smc.c **** #endif
 145:../drivers/fsl_smc.c **** 
 146:../drivers/fsl_smc.c ****     /* configure Normal Stop mode */
 147:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 409              		.loc 1 147 0
 410 000e 4378     		ldrb	r3, [r0, #1]
 411              	.LVL17:
 148:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_STOPM_MASK;
 412              		.loc 1 148 0
 413 0010 383A     		subs	r2, r2, #56
 414 0012 9343     		bics	r3, r2
 415              	.LVL18:
 149:../drivers/fsl_smc.c ****     reg |= (kSMC_StopNormal << SMC_PMCTRL_STOPM_SHIFT);
 150:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 416              		.loc 1 150 0
 417 0014 4370     		strb	r3, [r0, #1]
 151:../drivers/fsl_smc.c **** 
 152:../drivers/fsl_smc.c ****     /* Set the SLEEPDEEP bit to enable deep sleep mode (stop mode) */
 153:../drivers/fsl_smc.c ****     SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 418              		.loc 1 153 0
 419 0016 094A     		ldr	r2, .L21
 420 0018 1369     		ldr	r3, [r2, #16]
 421              	.LVL19:
 422 001a 0421     		movs	r1, #4
 423 001c 0B43     		orrs	r3, r1
 424 001e 1361     		str	r3, [r2, #16]
 425              	.LVL20:
 154:../drivers/fsl_smc.c **** 
 155:../drivers/fsl_smc.c ****     /* read back to make sure the configuration valid before enter stop mode */
 156:../drivers/fsl_smc.c ****     (void)base->PMCTRL;
 426              		.loc 1 156 0
 427 0020 4378     		ldrb	r3, [r0, #1]
 428              	.LBB98:
 429              	.LBB99:
 430              		.loc 2 833 0
 431              		.syntax divided
 432              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 433 0022 BFF34F8F 		dsb 0xF
 434              	@ 0 "" 2
 435              		.thumb
 436              		.syntax unified
 437              	.LBE99:
 438              	.LBE98:
 157:../drivers/fsl_smc.c ****     __DSB();
 158:../drivers/fsl_smc.c ****     __WFI();
 439              		.loc 1 158 0
 440              		.syntax divided
 441              	@ 158 "../drivers/fsl_smc.c" 1
 442 0026 30BF     		wfi
 443              	@ 0 "" 2
 444              		.thumb
 445              		.syntax unified
 446              	.LBB100:
 447              	.LBB101:
 822:../CMSIS/cmsis_gcc.h **** }
 448              		.loc 2 822 0
 449              		.syntax divided
 450              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 451 0028 BFF36F8F 		isb 0xF
 452              	@ 0 "" 2
 453              		.thumb
 454              		.syntax unified
 455              	.LBE101:
 456              	.LBE100:
 159:../drivers/fsl_smc.c ****     __ISB();
 160:../drivers/fsl_smc.c **** 
 161:../drivers/fsl_smc.c ****     /* check whether the power mode enter Stop mode succeed */
 162:../drivers/fsl_smc.c ****     if (base->PMCTRL & SMC_PMCTRL_STOPA_MASK)
 457              		.loc 1 162 0
 458 002c 4378     		ldrb	r3, [r0, #1]
 459 002e 1B07     		lsls	r3, r3, #28
 460 0030 01D4     		bmi	.L20
 163:../drivers/fsl_smc.c ****     {
 164:../drivers/fsl_smc.c ****         return kStatus_SMC_StopAbort;
 165:../drivers/fsl_smc.c ****     }
 166:../drivers/fsl_smc.c ****     else
 167:../drivers/fsl_smc.c ****     {
 168:../drivers/fsl_smc.c ****         return kStatus_Success;
 461              		.loc 1 168 0
 462 0032 0020     		movs	r0, #0
 463              	.LVL21:
 464              	.L17:
 169:../drivers/fsl_smc.c ****     }
 170:../drivers/fsl_smc.c **** }
 465              		.loc 1 170 0
 466              		@ sp needed
 467 0034 7047     		bx	lr
 468              	.LVL22:
 469              	.L20:
 164:../drivers/fsl_smc.c ****     }
 470              		.loc 1 164 0
 471 0036 0248     		ldr	r0, .L21+4
 472              	.LVL23:
 473 0038 FCE7     		b	.L17
 474              	.L22:
 475 003a C046     		.align	2
 476              	.L21:
 477 003c 00ED00E0 		.word	-536810240
 478 0040 3C0F0000 		.word	3900
 479              		.cfi_endproc
 480              	.LFE61:
 482              		.section	.text.SMC_SetPowerModeVlpr,"ax",%progbits
 483              		.align	1
 484              		.global	SMC_SetPowerModeVlpr
 485              		.syntax unified
 486              		.code	16
 487              		.thumb_func
 488              		.fpu softvfp
 490              	SMC_SetPowerModeVlpr:
 491              	.LFB62:
 171:../drivers/fsl_smc.c **** 
 172:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeVlpr(SMC_Type *base
 173:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LPWUI) && FSL_FEATURE_SMC_HAS_LPWUI)
 174:../drivers/fsl_smc.c ****                               ,
 175:../drivers/fsl_smc.c ****                               bool wakeupMode
 176:../drivers/fsl_smc.c **** #endif
 177:../drivers/fsl_smc.c ****                               )
 178:../drivers/fsl_smc.c **** {
 492              		.loc 1 178 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 0
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              		@ link register save eliminated.
 497              	.LVL24:
 179:../drivers/fsl_smc.c ****     uint8_t reg;
 180:../drivers/fsl_smc.c **** 
 181:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 498              		.loc 1 181 0
 499 0000 4378     		ldrb	r3, [r0, #1]
 500              	.LVL25:
 182:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LPWUI) && FSL_FEATURE_SMC_HAS_LPWUI)
 183:../drivers/fsl_smc.c ****     /* configure whether the system remains in VLP mode on an interrupt */
 184:../drivers/fsl_smc.c ****     if (wakeupMode)
 185:../drivers/fsl_smc.c ****     {
 186:../drivers/fsl_smc.c ****         /* exits to RUN mode on an interrupt */
 187:../drivers/fsl_smc.c ****         reg |= SMC_PMCTRL_LPWUI_MASK;
 188:../drivers/fsl_smc.c ****     }
 189:../drivers/fsl_smc.c ****     else
 190:../drivers/fsl_smc.c ****     {
 191:../drivers/fsl_smc.c ****         /* remains in VLP mode on an interrupt */
 192:../drivers/fsl_smc.c ****         reg &= ~SMC_PMCTRL_LPWUI_MASK;
 193:../drivers/fsl_smc.c ****     }
 194:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_LPWUI */
 195:../drivers/fsl_smc.c **** 
 196:../drivers/fsl_smc.c ****     /* configure VLPR mode */
 197:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_RUNM_MASK;
 501              		.loc 1 197 0
 502 0002 6022     		movs	r2, #96
 503 0004 9343     		bics	r3, r2
 504              	.LVL26:
 198:../drivers/fsl_smc.c ****     reg |= (kSMC_RunVlpr << SMC_PMCTRL_RUNM_SHIFT);
 505              		.loc 1 198 0
 506 0006 4022     		movs	r2, #64
 507 0008 1343     		orrs	r3, r2
 508              	.LVL27:
 199:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 509              		.loc 1 199 0
 510 000a 4370     		strb	r3, [r0, #1]
 200:../drivers/fsl_smc.c **** 
 201:../drivers/fsl_smc.c ****     return kStatus_Success;
 202:../drivers/fsl_smc.c **** }
 511              		.loc 1 202 0
 512 000c 0020     		movs	r0, #0
 513              	.LVL28:
 514              		@ sp needed
 515 000e 7047     		bx	lr
 516              		.cfi_endproc
 517              	.LFE62:
 519              		.section	.text.SMC_SetPowerModeVlpw,"ax",%progbits
 520              		.align	1
 521              		.global	SMC_SetPowerModeVlpw
 522              		.syntax unified
 523              		.code	16
 524              		.thumb_func
 525              		.fpu softvfp
 527              	SMC_SetPowerModeVlpw:
 528              	.LFB63:
 203:../drivers/fsl_smc.c **** 
 204:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeVlpw(SMC_Type *base)
 205:../drivers/fsl_smc.c **** {
 529              		.loc 1 205 0
 530              		.cfi_startproc
 531              		@ args = 0, pretend = 0, frame = 0
 532              		@ frame_needed = 0, uses_anonymous_args = 0
 533              		@ link register save eliminated.
 534              	.LVL29:
 206:../drivers/fsl_smc.c ****     /* configure VLPW mode */
 207:../drivers/fsl_smc.c ****     /* Set the SLEEPDEEP bit to enable deep sleep mode */
 208:../drivers/fsl_smc.c ****     SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
 535              		.loc 1 208 0
 536 0000 054A     		ldr	r2, .L25
 537 0002 1369     		ldr	r3, [r2, #16]
 538 0004 0421     		movs	r1, #4
 539 0006 8B43     		bics	r3, r1
 540 0008 1361     		str	r3, [r2, #16]
 541              	.LBB102:
 542              	.LBB103:
 543              		.loc 2 833 0
 544              		.syntax divided
 545              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 546 000a BFF34F8F 		dsb 0xF
 547              	@ 0 "" 2
 548              		.thumb
 549              		.syntax unified
 550              	.LBE103:
 551              	.LBE102:
 209:../drivers/fsl_smc.c ****     __DSB();
 210:../drivers/fsl_smc.c ****     __WFI();
 552              		.loc 1 210 0
 553              		.syntax divided
 554              	@ 210 "../drivers/fsl_smc.c" 1
 555 000e 30BF     		wfi
 556              	@ 0 "" 2
 557              		.thumb
 558              		.syntax unified
 559              	.LBB104:
 560              	.LBB105:
 822:../CMSIS/cmsis_gcc.h **** }
 561              		.loc 2 822 0
 562              		.syntax divided
 563              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 564 0010 BFF36F8F 		isb 0xF
 565              	@ 0 "" 2
 566              		.thumb
 567              		.syntax unified
 568              	.LBE105:
 569              	.LBE104:
 211:../drivers/fsl_smc.c ****     __ISB();
 212:../drivers/fsl_smc.c **** 
 213:../drivers/fsl_smc.c ****     return kStatus_Success;
 214:../drivers/fsl_smc.c **** }
 570              		.loc 1 214 0
 571 0014 0020     		movs	r0, #0
 572              	.LVL30:
 573              		@ sp needed
 574 0016 7047     		bx	lr
 575              	.L26:
 576              		.align	2
 577              	.L25:
 578 0018 00ED00E0 		.word	-536810240
 579              		.cfi_endproc
 580              	.LFE63:
 582              		.section	.text.SMC_SetPowerModeVlps,"ax",%progbits
 583              		.align	1
 584              		.global	SMC_SetPowerModeVlps
 585              		.syntax unified
 586              		.code	16
 587              		.thumb_func
 588              		.fpu softvfp
 590              	SMC_SetPowerModeVlps:
 591              	.LFB64:
 215:../drivers/fsl_smc.c **** 
 216:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeVlps(SMC_Type *base)
 217:../drivers/fsl_smc.c **** {
 592              		.loc 1 217 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 0
 595              		@ frame_needed = 0, uses_anonymous_args = 0
 596              		@ link register save eliminated.
 597              	.LVL31:
 218:../drivers/fsl_smc.c ****     uint8_t reg;
 219:../drivers/fsl_smc.c **** 
 220:../drivers/fsl_smc.c ****     /* configure VLPS mode */
 221:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 598              		.loc 1 221 0
 599 0000 4378     		ldrb	r3, [r0, #1]
 600              	.LVL32:
 222:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_STOPM_MASK;
 601              		.loc 1 222 0
 602 0002 0722     		movs	r2, #7
 603 0004 9343     		bics	r3, r2
 604              	.LVL33:
 223:../drivers/fsl_smc.c ****     reg |= (kSMC_StopVlps << SMC_PMCTRL_STOPM_SHIFT);
 605              		.loc 1 223 0
 606 0006 0222     		movs	r2, #2
 607 0008 1343     		orrs	r3, r2
 608              	.LVL34:
 224:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 609              		.loc 1 224 0
 610 000a 4370     		strb	r3, [r0, #1]
 225:../drivers/fsl_smc.c **** 
 226:../drivers/fsl_smc.c ****     /* Set the SLEEPDEEP bit to enable deep sleep mode */
 227:../drivers/fsl_smc.c ****     SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 611              		.loc 1 227 0
 612 000c 084A     		ldr	r2, .L31
 613 000e 1369     		ldr	r3, [r2, #16]
 614              	.LVL35:
 615 0010 0421     		movs	r1, #4
 616 0012 0B43     		orrs	r3, r1
 617 0014 1361     		str	r3, [r2, #16]
 618              	.LVL36:
 228:../drivers/fsl_smc.c **** 
 229:../drivers/fsl_smc.c ****     /* read back to make sure the configuration valid before enter stop mode */
 230:../drivers/fsl_smc.c ****     (void)base->PMCTRL;
 619              		.loc 1 230 0
 620 0016 4378     		ldrb	r3, [r0, #1]
 621              	.LBB106:
 622              	.LBB107:
 623              		.loc 2 833 0
 624              		.syntax divided
 625              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 626 0018 BFF34F8F 		dsb 0xF
 627              	@ 0 "" 2
 628              		.thumb
 629              		.syntax unified
 630              	.LBE107:
 631              	.LBE106:
 231:../drivers/fsl_smc.c ****     __DSB();
 232:../drivers/fsl_smc.c ****     __WFI();
 632              		.loc 1 232 0
 633              		.syntax divided
 634              	@ 232 "../drivers/fsl_smc.c" 1
 635 001c 30BF     		wfi
 636              	@ 0 "" 2
 637              		.thumb
 638              		.syntax unified
 639              	.LBB108:
 640              	.LBB109:
 822:../CMSIS/cmsis_gcc.h **** }
 641              		.loc 2 822 0
 642              		.syntax divided
 643              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 644 001e BFF36F8F 		isb 0xF
 645              	@ 0 "" 2
 646              		.thumb
 647              		.syntax unified
 648              	.LBE109:
 649              	.LBE108:
 233:../drivers/fsl_smc.c ****     __ISB();
 234:../drivers/fsl_smc.c **** 
 235:../drivers/fsl_smc.c ****     /* check whether the power mode enter VLPS mode succeed */
 236:../drivers/fsl_smc.c ****     if (base->PMCTRL & SMC_PMCTRL_STOPA_MASK)
 650              		.loc 1 236 0
 651 0022 4378     		ldrb	r3, [r0, #1]
 652 0024 1B07     		lsls	r3, r3, #28
 653 0026 01D4     		bmi	.L30
 237:../drivers/fsl_smc.c ****     {
 238:../drivers/fsl_smc.c ****         return kStatus_SMC_StopAbort;
 239:../drivers/fsl_smc.c ****     }
 240:../drivers/fsl_smc.c ****     else
 241:../drivers/fsl_smc.c ****     {
 242:../drivers/fsl_smc.c ****         return kStatus_Success;
 654              		.loc 1 242 0
 655 0028 0020     		movs	r0, #0
 656              	.LVL37:
 657              	.L27:
 243:../drivers/fsl_smc.c ****     }
 244:../drivers/fsl_smc.c **** }
 658              		.loc 1 244 0
 659              		@ sp needed
 660 002a 7047     		bx	lr
 661              	.LVL38:
 662              	.L30:
 238:../drivers/fsl_smc.c ****     }
 663              		.loc 1 238 0
 664 002c 0148     		ldr	r0, .L31+4
 665              	.LVL39:
 666 002e FCE7     		b	.L27
 667              	.L32:
 668              		.align	2
 669              	.L31:
 670 0030 00ED00E0 		.word	-536810240
 671 0034 3C0F0000 		.word	3900
 672              		.cfi_endproc
 673              	.LFE64:
 675              		.section	.text.SMC_SetPowerModeLls,"ax",%progbits
 676              		.align	1
 677              		.global	SMC_SetPowerModeLls
 678              		.syntax unified
 679              		.code	16
 680              		.thumb_func
 681              		.fpu softvfp
 683              	SMC_SetPowerModeLls:
 684              	.LFB65:
 245:../drivers/fsl_smc.c **** 
 246:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
 247:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeLls(SMC_Type *base
 248:../drivers/fsl_smc.c **** #if ((defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE) || \
 249:../drivers/fsl_smc.c ****      (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO))
 250:../drivers/fsl_smc.c ****                              ,
 251:../drivers/fsl_smc.c ****                              const smc_power_mode_lls_config_t *config
 252:../drivers/fsl_smc.c **** #endif
 253:../drivers/fsl_smc.c ****                              )
 254:../drivers/fsl_smc.c **** {
 685              		.loc 1 254 0
 686              		.cfi_startproc
 687              		@ args = 0, pretend = 0, frame = 0
 688              		@ frame_needed = 0, uses_anonymous_args = 0
 689              		@ link register save eliminated.
 690              	.LVL40:
 255:../drivers/fsl_smc.c ****     uint8_t reg;
 256:../drivers/fsl_smc.c **** 
 257:../drivers/fsl_smc.c ****     /* configure to LLS mode */
 258:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 691              		.loc 1 258 0
 692 0000 4378     		ldrb	r3, [r0, #1]
 693              	.LVL41:
 259:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_STOPM_MASK;
 694              		.loc 1 259 0
 695 0002 0722     		movs	r2, #7
 696 0004 9343     		bics	r3, r2
 697              	.LVL42:
 260:../drivers/fsl_smc.c ****     reg |= (kSMC_StopLls << SMC_PMCTRL_STOPM_SHIFT);
 698              		.loc 1 260 0
 699 0006 0322     		movs	r2, #3
 700 0008 1343     		orrs	r3, r2
 701              	.LVL43:
 261:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 702              		.loc 1 261 0
 703 000a 4370     		strb	r3, [r0, #1]
 262:../drivers/fsl_smc.c **** 
 263:../drivers/fsl_smc.c **** /* configure LLS sub-mode*/
 264:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 265:../drivers/fsl_smc.c ****     reg = base->STOPCTRL;
 266:../drivers/fsl_smc.c ****     reg &= ~SMC_STOPCTRL_LLSM_MASK;
 267:../drivers/fsl_smc.c ****     reg |= ((uint32_t)config->subMode << SMC_STOPCTRL_LLSM_SHIFT);
 268:../drivers/fsl_smc.c ****     base->STOPCTRL = reg;
 269:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_LLS_SUBMODE */
 270:../drivers/fsl_smc.c **** 
 271:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 272:../drivers/fsl_smc.c ****     if (config->enableLpoClock)
 273:../drivers/fsl_smc.c ****     {
 274:../drivers/fsl_smc.c ****         base->STOPCTRL &= ~SMC_STOPCTRL_LPOPO_MASK;
 275:../drivers/fsl_smc.c ****     }
 276:../drivers/fsl_smc.c ****     else
 277:../drivers/fsl_smc.c ****     {
 278:../drivers/fsl_smc.c ****         base->STOPCTRL |= SMC_STOPCTRL_LPOPO_MASK;
 279:../drivers/fsl_smc.c ****     }
 280:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_LPOPO */
 281:../drivers/fsl_smc.c **** 
 282:../drivers/fsl_smc.c ****     /* Set the SLEEPDEEP bit to enable deep sleep mode */
 283:../drivers/fsl_smc.c ****     SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 704              		.loc 1 283 0
 705 000c 084A     		ldr	r2, .L37
 706 000e 1369     		ldr	r3, [r2, #16]
 707              	.LVL44:
 708 0010 0421     		movs	r1, #4
 709 0012 0B43     		orrs	r3, r1
 710 0014 1361     		str	r3, [r2, #16]
 711              	.LVL45:
 284:../drivers/fsl_smc.c **** 
 285:../drivers/fsl_smc.c ****     /* read back to make sure the configuration valid before enter stop mode */
 286:../drivers/fsl_smc.c ****     (void)base->PMCTRL;
 712              		.loc 1 286 0
 713 0016 4378     		ldrb	r3, [r0, #1]
 714              	.LBB110:
 715              	.LBB111:
 716              		.loc 2 833 0
 717              		.syntax divided
 718              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 719 0018 BFF34F8F 		dsb 0xF
 720              	@ 0 "" 2
 721              		.thumb
 722              		.syntax unified
 723              	.LBE111:
 724              	.LBE110:
 287:../drivers/fsl_smc.c ****     __DSB();
 288:../drivers/fsl_smc.c ****     __WFI();
 725              		.loc 1 288 0
 726              		.syntax divided
 727              	@ 288 "../drivers/fsl_smc.c" 1
 728 001c 30BF     		wfi
 729              	@ 0 "" 2
 730              		.thumb
 731              		.syntax unified
 732              	.LBB112:
 733              	.LBB113:
 822:../CMSIS/cmsis_gcc.h **** }
 734              		.loc 2 822 0
 735              		.syntax divided
 736              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 737 001e BFF36F8F 		isb 0xF
 738              	@ 0 "" 2
 739              		.thumb
 740              		.syntax unified
 741              	.LBE113:
 742              	.LBE112:
 289:../drivers/fsl_smc.c ****     __ISB();
 290:../drivers/fsl_smc.c **** 
 291:../drivers/fsl_smc.c ****     /* check whether the power mode enter LLS mode succeed */
 292:../drivers/fsl_smc.c ****     if (base->PMCTRL & SMC_PMCTRL_STOPA_MASK)
 743              		.loc 1 292 0
 744 0022 4378     		ldrb	r3, [r0, #1]
 745 0024 1B07     		lsls	r3, r3, #28
 746 0026 01D4     		bmi	.L36
 293:../drivers/fsl_smc.c ****     {
 294:../drivers/fsl_smc.c ****         return kStatus_SMC_StopAbort;
 295:../drivers/fsl_smc.c ****     }
 296:../drivers/fsl_smc.c ****     else
 297:../drivers/fsl_smc.c ****     {
 298:../drivers/fsl_smc.c ****         return kStatus_Success;
 747              		.loc 1 298 0
 748 0028 0020     		movs	r0, #0
 749              	.LVL46:
 750              	.L33:
 299:../drivers/fsl_smc.c ****     }
 300:../drivers/fsl_smc.c **** }
 751              		.loc 1 300 0
 752              		@ sp needed
 753 002a 7047     		bx	lr
 754              	.LVL47:
 755              	.L36:
 294:../drivers/fsl_smc.c ****     }
 756              		.loc 1 294 0
 757 002c 0148     		ldr	r0, .L37+4
 758              	.LVL48:
 759 002e FCE7     		b	.L33
 760              	.L38:
 761              		.align	2
 762              	.L37:
 763 0030 00ED00E0 		.word	-536810240
 764 0034 3C0F0000 		.word	3900
 765              		.cfi_endproc
 766              	.LFE65:
 768              		.section	.text.SMC_SetPowerModeVlls,"ax",%progbits
 769              		.align	1
 770              		.global	SMC_SetPowerModeVlls
 771              		.syntax unified
 772              		.code	16
 773              		.thumb_func
 774              		.fpu softvfp
 776              	SMC_SetPowerModeVlls:
 777              	.LFB66:
 301:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
 302:../drivers/fsl_smc.c **** 
 303:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 304:../drivers/fsl_smc.c **** status_t SMC_SetPowerModeVlls(SMC_Type *base, const smc_power_mode_vlls_config_t *config)
 305:../drivers/fsl_smc.c **** {
 778              		.loc 1 305 0
 779              		.cfi_startproc
 780              		@ args = 0, pretend = 0, frame = 0
 781              		@ frame_needed = 0, uses_anonymous_args = 0
 782              	.LVL49:
 783 0000 10B5     		push	{r4, lr}
 784              		.cfi_def_cfa_offset 8
 785              		.cfi_offset 4, -8
 786              		.cfi_offset 14, -4
 306:../drivers/fsl_smc.c ****     uint8_t reg;
 307:../drivers/fsl_smc.c **** 
 308:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_PORPO) && FSL_FEATURE_SMC_HAS_PORPO)
 309:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG) ||     \
 310:../drivers/fsl_smc.c ****     (defined(FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) && FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) || \
 311:../drivers/fsl_smc.c ****     (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 312:../drivers/fsl_smc.c ****     if (config->subMode == kSMC_StopSub0)
 787              		.loc 1 312 0
 788 0002 0B78     		ldrb	r3, [r1]
 789 0004 002B     		cmp	r3, #0
 790 0006 06D1     		bne	.L40
 313:../drivers/fsl_smc.c **** #endif
 314:../drivers/fsl_smc.c ****     {
 315:../drivers/fsl_smc.c ****         /* configure whether the Por Detect work in Vlls0 mode */
 316:../drivers/fsl_smc.c ****         if (config->enablePorDetectInVlls0)
 791              		.loc 1 316 0
 792 0008 4B78     		ldrb	r3, [r1, #1]
 793 000a 002B     		cmp	r3, #0
 794 000c 1FD0     		beq	.L41
 317:../drivers/fsl_smc.c ****         {
 318:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG)
 319:../drivers/fsl_smc.c ****             base->VLLSCTRL &= ~SMC_VLLSCTRL_PORPO_MASK;
 320:../drivers/fsl_smc.c **** #else
 321:../drivers/fsl_smc.c ****             base->STOPCTRL &= ~SMC_STOPCTRL_PORPO_MASK;
 795              		.loc 1 321 0
 796 000e 8378     		ldrb	r3, [r0, #2]
 797 0010 2022     		movs	r2, #32
 798 0012 9343     		bics	r3, r2
 799 0014 8370     		strb	r3, [r0, #2]
 800              	.L40:
 322:../drivers/fsl_smc.c **** #endif
 323:../drivers/fsl_smc.c ****         }
 324:../drivers/fsl_smc.c ****         else
 325:../drivers/fsl_smc.c ****         {
 326:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG)
 327:../drivers/fsl_smc.c ****             base->VLLSCTRL |= SMC_VLLSCTRL_PORPO_MASK;
 328:../drivers/fsl_smc.c **** #else
 329:../drivers/fsl_smc.c ****             base->STOPCTRL |= SMC_STOPCTRL_PORPO_MASK;
 330:../drivers/fsl_smc.c **** #endif
 331:../drivers/fsl_smc.c ****         }
 332:../drivers/fsl_smc.c ****     }
 333:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_PORPO */
 334:../drivers/fsl_smc.c **** 
 335:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION) && FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION)
 336:../drivers/fsl_smc.c ****     else if (config->subMode == kSMC_StopSub2)
 337:../drivers/fsl_smc.c ****     {
 338:../drivers/fsl_smc.c ****         /* configure whether the Por Detect work in Vlls0 mode */
 339:../drivers/fsl_smc.c ****         if (config->enableRam2InVlls2)
 340:../drivers/fsl_smc.c ****         {
 341:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG)
 342:../drivers/fsl_smc.c ****             base->VLLSCTRL |= SMC_VLLSCTRL_RAM2PO_MASK;
 343:../drivers/fsl_smc.c **** #else
 344:../drivers/fsl_smc.c ****             base->STOPCTRL |= SMC_STOPCTRL_RAM2PO_MASK;
 345:../drivers/fsl_smc.c **** #endif
 346:../drivers/fsl_smc.c ****         }
 347:../drivers/fsl_smc.c ****         else
 348:../drivers/fsl_smc.c ****         {
 349:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG)
 350:../drivers/fsl_smc.c ****             base->VLLSCTRL &= ~SMC_VLLSCTRL_RAM2PO_MASK;
 351:../drivers/fsl_smc.c **** #else
 352:../drivers/fsl_smc.c ****             base->STOPCTRL &= ~SMC_STOPCTRL_RAM2PO_MASK;
 353:../drivers/fsl_smc.c **** #endif
 354:../drivers/fsl_smc.c ****         }
 355:../drivers/fsl_smc.c ****     }
 356:../drivers/fsl_smc.c ****     else
 357:../drivers/fsl_smc.c ****     {
 358:../drivers/fsl_smc.c ****     }
 359:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION */
 360:../drivers/fsl_smc.c **** 
 361:../drivers/fsl_smc.c ****     /* configure to VLLS mode */
 362:../drivers/fsl_smc.c ****     reg = base->PMCTRL;
 801              		.loc 1 362 0
 802 0016 4378     		ldrb	r3, [r0, #1]
 803              	.LVL50:
 363:../drivers/fsl_smc.c ****     reg &= ~SMC_PMCTRL_STOPM_MASK;
 804              		.loc 1 363 0
 805 0018 0722     		movs	r2, #7
 806 001a 9343     		bics	r3, r2
 807              	.LVL51:
 364:../drivers/fsl_smc.c ****     reg |= (kSMC_StopVlls << SMC_PMCTRL_STOPM_SHIFT);
 808              		.loc 1 364 0
 809 001c 0424     		movs	r4, #4
 810 001e 2343     		orrs	r3, r4
 811              	.LVL52:
 365:../drivers/fsl_smc.c ****     base->PMCTRL = reg;
 812              		.loc 1 365 0
 813 0020 4370     		strb	r3, [r0, #1]
 366:../drivers/fsl_smc.c **** 
 367:../drivers/fsl_smc.c **** /* configure the VLLS sub-mode */
 368:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG)
 369:../drivers/fsl_smc.c ****     reg = base->VLLSCTRL;
 370:../drivers/fsl_smc.c ****     reg &= ~SMC_VLLSCTRL_VLLSM_MASK;
 371:../drivers/fsl_smc.c ****     reg |= ((uint32_t)config->subMode << SMC_VLLSCTRL_VLLSM_SHIFT);
 372:../drivers/fsl_smc.c ****     base->VLLSCTRL = reg;
 373:../drivers/fsl_smc.c **** #else
 374:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 375:../drivers/fsl_smc.c ****     reg = base->STOPCTRL;
 376:../drivers/fsl_smc.c ****     reg &= ~SMC_STOPCTRL_LLSM_MASK;
 377:../drivers/fsl_smc.c ****     reg |= ((uint32_t)config->subMode << SMC_STOPCTRL_LLSM_SHIFT);
 378:../drivers/fsl_smc.c ****     base->STOPCTRL = reg;
 379:../drivers/fsl_smc.c **** #else
 380:../drivers/fsl_smc.c ****     reg = base->STOPCTRL;
 814              		.loc 1 380 0
 815 0022 8378     		ldrb	r3, [r0, #2]
 816              	.LVL53:
 381:../drivers/fsl_smc.c ****     reg &= ~SMC_STOPCTRL_VLLSM_MASK;
 817              		.loc 1 381 0
 818 0024 9343     		bics	r3, r2
 819              	.LVL54:
 820 0026 1A00     		movs	r2, r3
 821              	.LVL55:
 382:../drivers/fsl_smc.c ****     reg |= ((uint32_t)config->subMode << SMC_STOPCTRL_VLLSM_SHIFT);
 822              		.loc 1 382 0
 823 0028 0B78     		ldrb	r3, [r1]
 824 002a 1343     		orrs	r3, r2
 825              	.LVL56:
 383:../drivers/fsl_smc.c ****     base->STOPCTRL = reg;
 826              		.loc 1 383 0
 827 002c 8370     		strb	r3, [r0, #2]
 384:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_LLS_SUBMODE */
 385:../drivers/fsl_smc.c **** #endif
 386:../drivers/fsl_smc.c **** 
 387:../drivers/fsl_smc.c **** #if (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 388:../drivers/fsl_smc.c ****     if (config->enableLpoClock)
 389:../drivers/fsl_smc.c ****     {
 390:../drivers/fsl_smc.c ****         base->STOPCTRL &= ~SMC_STOPCTRL_LPOPO_MASK;
 391:../drivers/fsl_smc.c ****     }
 392:../drivers/fsl_smc.c ****     else
 393:../drivers/fsl_smc.c ****     {
 394:../drivers/fsl_smc.c ****         base->STOPCTRL |= SMC_STOPCTRL_LPOPO_MASK;
 395:../drivers/fsl_smc.c ****     }
 396:../drivers/fsl_smc.c **** #endif /* FSL_FEATURE_SMC_HAS_LPOPO */
 397:../drivers/fsl_smc.c **** 
 398:../drivers/fsl_smc.c ****     /* Set the SLEEPDEEP bit to enable deep sleep mode */
 399:../drivers/fsl_smc.c ****     SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 828              		.loc 1 399 0
 829 002e 0B4A     		ldr	r2, .L45
 830 0030 1369     		ldr	r3, [r2, #16]
 831              	.LVL57:
 832 0032 0421     		movs	r1, #4
 833              	.LVL58:
 834 0034 0B43     		orrs	r3, r1
 835 0036 1361     		str	r3, [r2, #16]
 836              	.LVL59:
 400:../drivers/fsl_smc.c **** 
 401:../drivers/fsl_smc.c ****     /* read back to make sure the configuration valid before enter stop mode */
 402:../drivers/fsl_smc.c ****     (void)base->PMCTRL;
 837              		.loc 1 402 0
 838 0038 4378     		ldrb	r3, [r0, #1]
 839              	.LBB114:
 840              	.LBB115:
 841              		.loc 2 833 0
 842              		.syntax divided
 843              	@ 833 "../CMSIS/cmsis_gcc.h" 1
 844 003a BFF34F8F 		dsb 0xF
 845              	@ 0 "" 2
 846              		.thumb
 847              		.syntax unified
 848              	.LBE115:
 849              	.LBE114:
 403:../drivers/fsl_smc.c ****     __DSB();
 404:../drivers/fsl_smc.c ****     __WFI();
 850              		.loc 1 404 0
 851              		.syntax divided
 852              	@ 404 "../drivers/fsl_smc.c" 1
 853 003e 30BF     		wfi
 854              	@ 0 "" 2
 855              		.thumb
 856              		.syntax unified
 857              	.LBB116:
 858              	.LBB117:
 822:../CMSIS/cmsis_gcc.h **** }
 859              		.loc 2 822 0
 860              		.syntax divided
 861              	@ 822 "../CMSIS/cmsis_gcc.h" 1
 862 0040 BFF36F8F 		isb 0xF
 863              	@ 0 "" 2
 864              		.thumb
 865              		.syntax unified
 866              	.LBE117:
 867              	.LBE116:
 405:../drivers/fsl_smc.c ****     __ISB();
 406:../drivers/fsl_smc.c **** 
 407:../drivers/fsl_smc.c ****     /* check whether the power mode enter LLS mode succeed */
 408:../drivers/fsl_smc.c ****     if (base->PMCTRL & SMC_PMCTRL_STOPA_MASK)
 868              		.loc 1 408 0
 869 0044 4378     		ldrb	r3, [r0, #1]
 870 0046 1B07     		lsls	r3, r3, #28
 871 0048 06D4     		bmi	.L44
 409:../drivers/fsl_smc.c ****     {
 410:../drivers/fsl_smc.c ****         return kStatus_SMC_StopAbort;
 411:../drivers/fsl_smc.c ****     }
 412:../drivers/fsl_smc.c ****     else
 413:../drivers/fsl_smc.c ****     {
 414:../drivers/fsl_smc.c ****         return kStatus_Success;
 872              		.loc 1 414 0
 873 004a 0020     		movs	r0, #0
 874              	.LVL60:
 875              	.L39:
 415:../drivers/fsl_smc.c ****     }
 416:../drivers/fsl_smc.c **** }
 876              		.loc 1 416 0
 877              		@ sp needed
 878 004c 10BD     		pop	{r4, pc}
 879              	.LVL61:
 880              	.L41:
 329:../drivers/fsl_smc.c **** #endif
 881              		.loc 1 329 0
 882 004e 8378     		ldrb	r3, [r0, #2]
 883 0050 2022     		movs	r2, #32
 884 0052 1343     		orrs	r3, r2
 885 0054 8370     		strb	r3, [r0, #2]
 886 0056 DEE7     		b	.L40
 887              	.LVL62:
 888              	.L44:
 410:../drivers/fsl_smc.c ****     }
 889              		.loc 1 410 0
 890 0058 0148     		ldr	r0, .L45+4
 891              	.LVL63:
 892 005a F7E7     		b	.L39
 893              	.L46:
 894              		.align	2
 895              	.L45:
 896 005c 00ED00E0 		.word	-536810240
 897 0060 3C0F0000 		.word	3900
 898              		.cfi_endproc
 899              	.LFE66:
 901              		.section	.rodata
 902              		.align	2
 903              		.set	.LANCHOR0,. + 0
 904              	.LC0:
 905 0000 01       		.byte	1
 906 0001 01       		.byte	1
 907              		.section	.bss.g_savedPrimask,"aw",%nobits
 908              		.align	2
 909              		.set	.LANCHOR1,. + 0
 912              	g_savedPrimask:
 913 0000 00000000 		.space	4
 914              		.text
 915              	.Letext0:
 916              		.file 3 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 917              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 918              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 919              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 920              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 921              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 922              		.file 9 "../CMSIS/core_cm0plus.h"
 923              		.file 10 "../CMSIS/system_MKL17Z4.h"
 924              		.file 11 "../CMSIS/MKL17Z4.h"
 925              		.file 12 "../drivers/fsl_common.h"
 926              		.file 13 "../drivers/fsl_clock.h"
 927              		.file 14 "../drivers/fsl_smc.h"
 928              		.file 15 "../drivers/fsl_flash.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_smc.c
     /tmp/ccVjWw5A.s:16     .text.SMC_PreEnterStopModes:0000000000000000 $t
     /tmp/ccVjWw5A.s:23     .text.SMC_PreEnterStopModes:0000000000000000 SMC_PreEnterStopModes
     /tmp/ccVjWw5A.s:91     .text.SMC_PreEnterStopModes:0000000000000024 $d
     /tmp/ccVjWw5A.s:97     .text.SMC_PostExitStopModes:0000000000000000 $t
     /tmp/ccVjWw5A.s:104    .text.SMC_PostExitStopModes:0000000000000000 SMC_PostExitStopModes
     /tmp/ccVjWw5A.s:159    .text.SMC_PostExitStopModes:0000000000000020 $d
     /tmp/ccVjWw5A.s:164    .text.SMC_PreEnterWaitModes:0000000000000000 $t
     /tmp/ccVjWw5A.s:171    .text.SMC_PreEnterWaitModes:0000000000000000 SMC_PreEnterWaitModes
     /tmp/ccVjWw5A.s:224    .text.SMC_PreEnterWaitModes:0000000000000010 $d
     /tmp/ccVjWw5A.s:229    .text.SMC_PostExitWaitModes:0000000000000000 $t
     /tmp/ccVjWw5A.s:236    .text.SMC_PostExitWaitModes:0000000000000000 SMC_PostExitWaitModes
     /tmp/ccVjWw5A.s:278    .text.SMC_PostExitWaitModes:0000000000000010 $d
     /tmp/ccVjWw5A.s:283    .text.SMC_SetPowerModeRun:0000000000000000 $t
     /tmp/ccVjWw5A.s:290    .text.SMC_SetPowerModeRun:0000000000000000 SMC_SetPowerModeRun
     /tmp/ccVjWw5A.s:316    .text.SMC_SetPowerModeWait:0000000000000000 $t
     /tmp/ccVjWw5A.s:323    .text.SMC_SetPowerModeWait:0000000000000000 SMC_SetPowerModeWait
     /tmp/ccVjWw5A.s:374    .text.SMC_SetPowerModeWait:0000000000000018 $d
     /tmp/ccVjWw5A.s:379    .text.SMC_SetPowerModeStop:0000000000000000 $t
     /tmp/ccVjWw5A.s:386    .text.SMC_SetPowerModeStop:0000000000000000 SMC_SetPowerModeStop
     /tmp/ccVjWw5A.s:477    .text.SMC_SetPowerModeStop:000000000000003c $d
     /tmp/ccVjWw5A.s:483    .text.SMC_SetPowerModeVlpr:0000000000000000 $t
     /tmp/ccVjWw5A.s:490    .text.SMC_SetPowerModeVlpr:0000000000000000 SMC_SetPowerModeVlpr
     /tmp/ccVjWw5A.s:520    .text.SMC_SetPowerModeVlpw:0000000000000000 $t
     /tmp/ccVjWw5A.s:527    .text.SMC_SetPowerModeVlpw:0000000000000000 SMC_SetPowerModeVlpw
     /tmp/ccVjWw5A.s:578    .text.SMC_SetPowerModeVlpw:0000000000000018 $d
     /tmp/ccVjWw5A.s:583    .text.SMC_SetPowerModeVlps:0000000000000000 $t
     /tmp/ccVjWw5A.s:590    .text.SMC_SetPowerModeVlps:0000000000000000 SMC_SetPowerModeVlps
     /tmp/ccVjWw5A.s:670    .text.SMC_SetPowerModeVlps:0000000000000030 $d
     /tmp/ccVjWw5A.s:676    .text.SMC_SetPowerModeLls:0000000000000000 $t
     /tmp/ccVjWw5A.s:683    .text.SMC_SetPowerModeLls:0000000000000000 SMC_SetPowerModeLls
     /tmp/ccVjWw5A.s:763    .text.SMC_SetPowerModeLls:0000000000000030 $d
     /tmp/ccVjWw5A.s:769    .text.SMC_SetPowerModeVlls:0000000000000000 $t
     /tmp/ccVjWw5A.s:776    .text.SMC_SetPowerModeVlls:0000000000000000 SMC_SetPowerModeVlls
     /tmp/ccVjWw5A.s:896    .text.SMC_SetPowerModeVlls:000000000000005c $d
     /tmp/ccVjWw5A.s:902    .rodata:0000000000000000 $d
     /tmp/ccVjWw5A.s:908    .bss.g_savedPrimask:0000000000000000 $d
     /tmp/ccVjWw5A.s:912    .bss.g_savedPrimask:0000000000000000 g_savedPrimask

UNDEFINED SYMBOLS
FLASH_PflashSetPrefetchSpeculation
