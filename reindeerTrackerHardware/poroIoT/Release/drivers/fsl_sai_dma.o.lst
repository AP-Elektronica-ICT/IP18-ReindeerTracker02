   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_sai_dma.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.SAI_TransferTxCreateHandleDMA,"ax",%progbits
  16              		.align	1
  17              		.global	SAI_TransferTxCreateHandleDMA
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	SAI_TransferTxCreateHandleDMA:
  24              	.LFB85:
  25              		.file 1 "../drivers/fsl_sai_dma.c"
   1:../drivers/fsl_sai_dma.c **** /*
   2:../drivers/fsl_sai_dma.c ****  * The Clear BSD License
   3:../drivers/fsl_sai_dma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_sai_dma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_sai_dma.c ****  * All rights reserved.
   6:../drivers/fsl_sai_dma.c ****  *
   7:../drivers/fsl_sai_dma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_sai_dma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_sai_dma.c ****  * that the following conditions are met:
  10:../drivers/fsl_sai_dma.c ****  *
  11:../drivers/fsl_sai_dma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_sai_dma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_sai_dma.c ****  *
  14:../drivers/fsl_sai_dma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_sai_dma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_sai_dma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_sai_dma.c ****  *
  18:../drivers/fsl_sai_dma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_sai_dma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_sai_dma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_sai_dma.c ****  *
  22:../drivers/fsl_sai_dma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_sai_dma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_sai_dma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_sai_dma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_sai_dma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_sai_dma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_sai_dma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_sai_dma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_sai_dma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_sai_dma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_sai_dma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_sai_dma.c ****  */
  34:../drivers/fsl_sai_dma.c **** 
  35:../drivers/fsl_sai_dma.c **** #include "fsl_sai_dma.h"
  36:../drivers/fsl_sai_dma.c **** 
  37:../drivers/fsl_sai_dma.c **** /*******************************************************************************
  38:../drivers/fsl_sai_dma.c **** * Definitions
  39:../drivers/fsl_sai_dma.c **** ******************************************************************************/
  40:../drivers/fsl_sai_dma.c **** /*<! Structure definition for sai_dma_private_handle_t. The structure is private. */
  41:../drivers/fsl_sai_dma.c **** typedef struct _sai_dma_private_handle
  42:../drivers/fsl_sai_dma.c **** {
  43:../drivers/fsl_sai_dma.c ****     I2S_Type *base;
  44:../drivers/fsl_sai_dma.c ****     sai_dma_handle_t *handle;
  45:../drivers/fsl_sai_dma.c **** } sai_dma_private_handle_t;
  46:../drivers/fsl_sai_dma.c **** 
  47:../drivers/fsl_sai_dma.c **** enum _sai_dma_states
  48:../drivers/fsl_sai_dma.c **** {
  49:../drivers/fsl_sai_dma.c ****     kSAI_Idle = 0x0U,
  50:../drivers/fsl_sai_dma.c ****     kSAI_Busy = 0x1U,
  51:../drivers/fsl_sai_dma.c **** };
  52:../drivers/fsl_sai_dma.c **** 
  53:../drivers/fsl_sai_dma.c **** /*<! Private handle only used for internally. */
  54:../drivers/fsl_sai_dma.c **** static sai_dma_private_handle_t s_dmaPrivateHandle[FSL_FEATURE_SOC_I2S_COUNT][2];
  55:../drivers/fsl_sai_dma.c **** 
  56:../drivers/fsl_sai_dma.c **** /*******************************************************************************
  57:../drivers/fsl_sai_dma.c ****  * Prototypes
  58:../drivers/fsl_sai_dma.c ****  ******************************************************************************/
  59:../drivers/fsl_sai_dma.c **** /*!
  60:../drivers/fsl_sai_dma.c ****  * @brief Get the instance number for SAI.
  61:../drivers/fsl_sai_dma.c ****  *
  62:../drivers/fsl_sai_dma.c ****  * @param base SAI base pointer.
  63:../drivers/fsl_sai_dma.c ****  */
  64:../drivers/fsl_sai_dma.c **** extern uint32_t SAI_GetInstance(I2S_Type *base);
  65:../drivers/fsl_sai_dma.c **** 
  66:../drivers/fsl_sai_dma.c **** /*!
  67:../drivers/fsl_sai_dma.c ****  * @brief SAI EDMA callback for send.
  68:../drivers/fsl_sai_dma.c ****  *
  69:../drivers/fsl_sai_dma.c ****  * @param handle pointer to sai_dma_handle_t structure which stores the transfer state.
  70:../drivers/fsl_sai_dma.c ****  * @param userData Parameter for user callback.
  71:../drivers/fsl_sai_dma.c ****  */
  72:../drivers/fsl_sai_dma.c **** static void SAI_TxDMACallback(dma_handle_t *handle, void *userData);
  73:../drivers/fsl_sai_dma.c **** 
  74:../drivers/fsl_sai_dma.c **** /*!
  75:../drivers/fsl_sai_dma.c ****  * @brief SAI EDMA callback for receive.
  76:../drivers/fsl_sai_dma.c ****  *
  77:../drivers/fsl_sai_dma.c ****  * @param handle pointer to sai_dma_handle_t structure which stores the transfer state.
  78:../drivers/fsl_sai_dma.c ****  * @param userData Parameter for user callback.
  79:../drivers/fsl_sai_dma.c ****  */
  80:../drivers/fsl_sai_dma.c **** static void SAI_RxDMACallback(dma_handle_t *handle, void *userData);
  81:../drivers/fsl_sai_dma.c **** 
  82:../drivers/fsl_sai_dma.c **** /*******************************************************************************
  83:../drivers/fsl_sai_dma.c **** * Code
  84:../drivers/fsl_sai_dma.c **** ******************************************************************************/
  85:../drivers/fsl_sai_dma.c **** static void SAI_TxDMACallback(dma_handle_t *handle, void *userData)
  86:../drivers/fsl_sai_dma.c **** {
  87:../drivers/fsl_sai_dma.c ****     sai_dma_private_handle_t *privHandle = (sai_dma_private_handle_t *)userData;
  88:../drivers/fsl_sai_dma.c ****     sai_dma_handle_t *saiHandle = privHandle->handle;
  89:../drivers/fsl_sai_dma.c **** 
  90:../drivers/fsl_sai_dma.c ****     /* Update queue counter */
  91:../drivers/fsl_sai_dma.c ****     memset(&saiHandle->saiQueue[saiHandle->queueDriver], 0, sizeof(sai_transfer_t));
  92:../drivers/fsl_sai_dma.c ****     saiHandle->queueDriver = (saiHandle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
  93:../drivers/fsl_sai_dma.c **** 
  94:../drivers/fsl_sai_dma.c ****     /* Call callback function */
  95:../drivers/fsl_sai_dma.c ****     if (saiHandle->callback)
  96:../drivers/fsl_sai_dma.c ****     {
  97:../drivers/fsl_sai_dma.c ****         (saiHandle->callback)(privHandle->base, saiHandle, kStatus_SAI_TxIdle, saiHandle->userData)
  98:../drivers/fsl_sai_dma.c ****     }
  99:../drivers/fsl_sai_dma.c **** 
 100:../drivers/fsl_sai_dma.c ****     /* If all data finished, just stop the transfer */
 101:../drivers/fsl_sai_dma.c ****     if (saiHandle->saiQueue[saiHandle->queueDriver].data == NULL)
 102:../drivers/fsl_sai_dma.c ****     {
 103:../drivers/fsl_sai_dma.c ****         SAI_TransferAbortSendDMA(privHandle->base, saiHandle);
 104:../drivers/fsl_sai_dma.c ****     }
 105:../drivers/fsl_sai_dma.c **** }
 106:../drivers/fsl_sai_dma.c **** 
 107:../drivers/fsl_sai_dma.c **** static void SAI_RxDMACallback(dma_handle_t *handle, void *userData)
 108:../drivers/fsl_sai_dma.c **** {
 109:../drivers/fsl_sai_dma.c ****     sai_dma_private_handle_t *privHandle = (sai_dma_private_handle_t *)userData;
 110:../drivers/fsl_sai_dma.c ****     sai_dma_handle_t *saiHandle = privHandle->handle;
 111:../drivers/fsl_sai_dma.c **** 
 112:../drivers/fsl_sai_dma.c ****     /* Update queue counter */
 113:../drivers/fsl_sai_dma.c ****     memset(&saiHandle->saiQueue[saiHandle->queueDriver], 0, sizeof(sai_transfer_t));
 114:../drivers/fsl_sai_dma.c ****     saiHandle->queueDriver = (saiHandle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
 115:../drivers/fsl_sai_dma.c **** 
 116:../drivers/fsl_sai_dma.c ****     /* Call callback function */
 117:../drivers/fsl_sai_dma.c ****     if (saiHandle->callback)
 118:../drivers/fsl_sai_dma.c ****     {
 119:../drivers/fsl_sai_dma.c ****         (saiHandle->callback)(privHandle->base, saiHandle, kStatus_SAI_RxIdle, saiHandle->userData)
 120:../drivers/fsl_sai_dma.c ****     }
 121:../drivers/fsl_sai_dma.c **** 
 122:../drivers/fsl_sai_dma.c ****     /* If all data finished, just stop the transfer */
 123:../drivers/fsl_sai_dma.c ****     if (saiHandle->saiQueue[saiHandle->queueDriver].data == NULL)
 124:../drivers/fsl_sai_dma.c ****     {
 125:../drivers/fsl_sai_dma.c ****         SAI_TransferAbortReceiveDMA(privHandle->base, saiHandle);
 126:../drivers/fsl_sai_dma.c ****     }
 127:../drivers/fsl_sai_dma.c **** }
 128:../drivers/fsl_sai_dma.c **** 
 129:../drivers/fsl_sai_dma.c **** void SAI_TransferTxCreateHandleDMA(
 130:../drivers/fsl_sai_dma.c ****     I2S_Type *base, sai_dma_handle_t *handle, sai_dma_callback_t callback, void *userData, dma_hand
 131:../drivers/fsl_sai_dma.c **** {
  26              		.loc 1 131 0
  27              		.cfi_startproc
  28              		@ args = 4, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  32              		.cfi_def_cfa_offset 20
  33              		.cfi_offset 4, -20
  34              		.cfi_offset 5, -16
  35              		.cfi_offset 6, -12
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 C646     		mov	lr, r8
  39 0004 00B5     		push	{lr}
  40              		.cfi_def_cfa_offset 24
  41              		.cfi_offset 8, -24
  42 0006 0500     		movs	r5, r0
  43 0008 0C00     		movs	r4, r1
  44 000a 9046     		mov	r8, r2
  45 000c 1F00     		movs	r7, r3
 132:../drivers/fsl_sai_dma.c ****     assert(handle && dmaHandle);
 133:../drivers/fsl_sai_dma.c **** 
 134:../drivers/fsl_sai_dma.c ****     uint32_t instance = SAI_GetInstance(base);
  46              		.loc 1 134 0
  47 000e FFF7FEFF 		bl	SAI_GetInstance
  48              	.LVL1:
  49 0012 0600     		movs	r6, r0
  50              	.LVL2:
 135:../drivers/fsl_sai_dma.c **** 
 136:../drivers/fsl_sai_dma.c ****     /* Zero the handle */
 137:../drivers/fsl_sai_dma.c ****     memset(handle, 0, sizeof(*handle));
  51              		.loc 1 137 0
  52 0014 201D     		adds	r0, r4, #4
  53              	.LVL3:
  54 0016 4422     		movs	r2, #68
  55 0018 0021     		movs	r1, #0
  56 001a FFF7FEFF 		bl	memset
  57              	.LVL4:
 138:../drivers/fsl_sai_dma.c **** 
 139:../drivers/fsl_sai_dma.c ****     /* Set sai base to handle */
 140:../drivers/fsl_sai_dma.c ****     handle->dmaHandle = dmaHandle;
  58              		.loc 1 140 0
  59 001e 069B     		ldr	r3, [sp, #24]
  60 0020 2360     		str	r3, [r4]
 141:../drivers/fsl_sai_dma.c ****     handle->callback = callback;
  61              		.loc 1 141 0
  62 0022 4346     		mov	r3, r8
  63 0024 E360     		str	r3, [r4, #12]
 142:../drivers/fsl_sai_dma.c ****     handle->userData = userData;
  64              		.loc 1 142 0
  65 0026 2761     		str	r7, [r4, #16]
 143:../drivers/fsl_sai_dma.c **** 
 144:../drivers/fsl_sai_dma.c ****     /* Set SAI state to idle */
 145:../drivers/fsl_sai_dma.c ****     handle->state = kSAI_Idle;
 146:../drivers/fsl_sai_dma.c **** 
 147:../drivers/fsl_sai_dma.c ****     s_dmaPrivateHandle[instance][0].base = base;
  66              		.loc 1 147 0
  67 0028 084A     		ldr	r2, .L2
  68 002a 3601     		lsls	r6, r6, #4
  69              	.LVL5:
  70 002c B550     		str	r5, [r6, r2]
 148:../drivers/fsl_sai_dma.c ****     s_dmaPrivateHandle[instance][0].handle = handle;
  71              		.loc 1 148 0
  72 002e 9219     		adds	r2, r2, r6
  73 0030 5460     		str	r4, [r2, #4]
 149:../drivers/fsl_sai_dma.c **** 
 150:../drivers/fsl_sai_dma.c **** /* Use FIFO error continue nstead of using interrupt to handle error */
 151:../drivers/fsl_sai_dma.c **** #if defined(FSL_FEATURE_SAI_HAS_FIFO_FUNCTION_AFTER_ERROR) && (FSL_FEATURE_SAI_HAS_FIFO_FUNCTION_AF
 152:../drivers/fsl_sai_dma.c ****     base->TCR4 |= I2S_TCR4_FCONT_MASK;
  74              		.loc 1 152 0
  75 0032 2969     		ldr	r1, [r5, #16]
  76 0034 8023     		movs	r3, #128
  77 0036 5B05     		lsls	r3, r3, #21
  78 0038 0B43     		orrs	r3, r1
  79 003a 2B61     		str	r3, [r5, #16]
 153:../drivers/fsl_sai_dma.c **** #endif
 154:../drivers/fsl_sai_dma.c **** 
 155:../drivers/fsl_sai_dma.c ****     /* Install callback for Tx dma channel */
 156:../drivers/fsl_sai_dma.c ****     DMA_SetCallback(dmaHandle, SAI_TxDMACallback, &s_dmaPrivateHandle[instance][0]);
  80              		.loc 1 156 0
  81 003c 0449     		ldr	r1, .L2+4
  82 003e 0698     		ldr	r0, [sp, #24]
  83 0040 FFF7FEFF 		bl	DMA_SetCallback
  84              	.LVL6:
 157:../drivers/fsl_sai_dma.c **** }
  85              		.loc 1 157 0
  86              		@ sp needed
  87              	.LVL7:
  88              	.LVL8:
  89              	.LVL9:
  90              	.LVL10:
  91 0044 04BC     		pop	{r2}
  92 0046 9046     		mov	r8, r2
  93 0048 F0BD     		pop	{r4, r5, r6, r7, pc}
  94              	.L3:
  95 004a C046     		.align	2
  96              	.L2:
  97 004c 00000000 		.word	.LANCHOR0
  98 0050 00000000 		.word	SAI_TxDMACallback
  99              		.cfi_endproc
 100              	.LFE85:
 102              		.section	.text.SAI_TransferRxCreateHandleDMA,"ax",%progbits
 103              		.align	1
 104              		.global	SAI_TransferRxCreateHandleDMA
 105              		.syntax unified
 106              		.code	16
 107              		.thumb_func
 108              		.fpu softvfp
 110              	SAI_TransferRxCreateHandleDMA:
 111              	.LFB86:
 158:../drivers/fsl_sai_dma.c **** 
 159:../drivers/fsl_sai_dma.c **** void SAI_TransferRxCreateHandleDMA(
 160:../drivers/fsl_sai_dma.c ****     I2S_Type *base, sai_dma_handle_t *handle, sai_dma_callback_t callback, void *userData, dma_hand
 161:../drivers/fsl_sai_dma.c **** {
 112              		.loc 1 161 0
 113              		.cfi_startproc
 114              		@ args = 4, pretend = 0, frame = 0
 115              		@ frame_needed = 0, uses_anonymous_args = 0
 116              	.LVL11:
 117 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 118              		.cfi_def_cfa_offset 20
 119              		.cfi_offset 4, -20
 120              		.cfi_offset 5, -16
 121              		.cfi_offset 6, -12
 122              		.cfi_offset 7, -8
 123              		.cfi_offset 14, -4
 124 0002 C646     		mov	lr, r8
 125 0004 00B5     		push	{lr}
 126              		.cfi_def_cfa_offset 24
 127              		.cfi_offset 8, -24
 128 0006 0600     		movs	r6, r0
 129 0008 0D00     		movs	r5, r1
 130 000a 9046     		mov	r8, r2
 131 000c 1F00     		movs	r7, r3
 162:../drivers/fsl_sai_dma.c ****     assert(handle && dmaHandle);
 163:../drivers/fsl_sai_dma.c **** 
 164:../drivers/fsl_sai_dma.c ****     uint32_t instance = SAI_GetInstance(base);
 132              		.loc 1 164 0
 133 000e FFF7FEFF 		bl	SAI_GetInstance
 134              	.LVL12:
 135 0012 0400     		movs	r4, r0
 136              	.LVL13:
 165:../drivers/fsl_sai_dma.c **** 
 166:../drivers/fsl_sai_dma.c ****     /* Zero the handle */
 167:../drivers/fsl_sai_dma.c ****     memset(handle, 0, sizeof(*handle));
 137              		.loc 1 167 0
 138 0014 281D     		adds	r0, r5, #4
 139              	.LVL14:
 140 0016 4422     		movs	r2, #68
 141 0018 0021     		movs	r1, #0
 142 001a FFF7FEFF 		bl	memset
 143              	.LVL15:
 168:../drivers/fsl_sai_dma.c **** 
 169:../drivers/fsl_sai_dma.c ****     /* Set sai base to handle */
 170:../drivers/fsl_sai_dma.c ****     handle->dmaHandle = dmaHandle;
 144              		.loc 1 170 0
 145 001e 069B     		ldr	r3, [sp, #24]
 146 0020 2B60     		str	r3, [r5]
 171:../drivers/fsl_sai_dma.c ****     handle->callback = callback;
 147              		.loc 1 171 0
 148 0022 4346     		mov	r3, r8
 149 0024 EB60     		str	r3, [r5, #12]
 172:../drivers/fsl_sai_dma.c ****     handle->userData = userData;
 150              		.loc 1 172 0
 151 0026 2F61     		str	r7, [r5, #16]
 173:../drivers/fsl_sai_dma.c **** 
 174:../drivers/fsl_sai_dma.c ****     /* Set SAI state to idle */
 175:../drivers/fsl_sai_dma.c ****     handle->state = kSAI_Idle;
 176:../drivers/fsl_sai_dma.c **** 
 177:../drivers/fsl_sai_dma.c ****     s_dmaPrivateHandle[instance][1].base = base;
 152              		.loc 1 177 0
 153 0028 0A4B     		ldr	r3, .L5
 154 002a 2001     		lsls	r0, r4, #4
 155 002c 1A18     		adds	r2, r3, r0
 156 002e 9660     		str	r6, [r2, #8]
 178:../drivers/fsl_sai_dma.c ****     s_dmaPrivateHandle[instance][1].handle = handle;
 157              		.loc 1 178 0
 158 0030 D560     		str	r5, [r2, #12]
 179:../drivers/fsl_sai_dma.c **** 
 180:../drivers/fsl_sai_dma.c **** /* Use FIFO error continue nstead of using interrupt to handle error */
 181:../drivers/fsl_sai_dma.c **** #if defined(FSL_FEATURE_SAI_HAS_FIFO_FUNCTION_AFTER_ERROR) && (FSL_FEATURE_SAI_HAS_FIFO_FUNCTION_AF
 182:../drivers/fsl_sai_dma.c ****     base->RCR4 |= I2S_RCR4_FCONT_MASK;
 159              		.loc 1 182 0
 160 0032 9021     		movs	r1, #144
 161 0034 7458     		ldr	r4, [r6, r1]
 162              	.LVL16:
 163 0036 8022     		movs	r2, #128
 164 0038 5205     		lsls	r2, r2, #21
 165 003a 2243     		orrs	r2, r4
 166 003c 7250     		str	r2, [r6, r1]
 183:../drivers/fsl_sai_dma.c **** #endif
 184:../drivers/fsl_sai_dma.c **** 
 185:../drivers/fsl_sai_dma.c ****     /* Install callback for Tx dma channel */
 186:../drivers/fsl_sai_dma.c ****     DMA_SetCallback(dmaHandle, SAI_RxDMACallback, &s_dmaPrivateHandle[instance][1]);
 167              		.loc 1 186 0
 168 003e 0200     		movs	r2, r0
 169 0040 0832     		adds	r2, r2, #8
 170 0042 9A18     		adds	r2, r3, r2
 171 0044 0449     		ldr	r1, .L5+4
 172 0046 0698     		ldr	r0, [sp, #24]
 173 0048 FFF7FEFF 		bl	DMA_SetCallback
 174              	.LVL17:
 187:../drivers/fsl_sai_dma.c **** }
 175              		.loc 1 187 0
 176              		@ sp needed
 177              	.LVL18:
 178              	.LVL19:
 179              	.LVL20:
 180              	.LVL21:
 181 004c 04BC     		pop	{r2}
 182 004e 9046     		mov	r8, r2
 183 0050 F0BD     		pop	{r4, r5, r6, r7, pc}
 184              	.L6:
 185 0052 C046     		.align	2
 186              	.L5:
 187 0054 00000000 		.word	.LANCHOR0
 188 0058 00000000 		.word	SAI_RxDMACallback
 189              		.cfi_endproc
 190              	.LFE86:
 192              		.section	.text.SAI_TransferTxSetFormatDMA,"ax",%progbits
 193              		.align	1
 194              		.global	SAI_TransferTxSetFormatDMA
 195              		.syntax unified
 196              		.code	16
 197              		.thumb_func
 198              		.fpu softvfp
 200              	SAI_TransferTxSetFormatDMA:
 201              	.LFB87:
 188:../drivers/fsl_sai_dma.c **** 
 189:../drivers/fsl_sai_dma.c **** void SAI_TransferTxSetFormatDMA(I2S_Type *base,
 190:../drivers/fsl_sai_dma.c ****                                 sai_dma_handle_t *handle,
 191:../drivers/fsl_sai_dma.c ****                                 sai_transfer_format_t *format,
 192:../drivers/fsl_sai_dma.c ****                                 uint32_t mclkSourceClockHz,
 193:../drivers/fsl_sai_dma.c ****                                 uint32_t bclkSourceClockHz)
 194:../drivers/fsl_sai_dma.c **** {
 202              		.loc 1 194 0
 203              		.cfi_startproc
 204              		@ args = 4, pretend = 0, frame = 16
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              	.LVL22:
 207 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 208              		.cfi_def_cfa_offset 20
 209              		.cfi_offset 4, -20
 210              		.cfi_offset 5, -16
 211              		.cfi_offset 6, -12
 212              		.cfi_offset 7, -8
 213              		.cfi_offset 14, -4
 214 0002 85B0     		sub	sp, sp, #20
 215              		.cfi_def_cfa_offset 40
 216 0004 0400     		movs	r4, r0
 217 0006 0E00     		movs	r6, r1
 218 0008 1500     		movs	r5, r2
 219 000a 1F00     		movs	r7, r3
 195:../drivers/fsl_sai_dma.c ****     assert(handle && format);
 196:../drivers/fsl_sai_dma.c **** 
 197:../drivers/fsl_sai_dma.c ****     dma_transfer_config_t config = {0};
 220              		.loc 1 197 0
 221 000c 1022     		movs	r2, #16
 222              	.LVL23:
 223 000e 0021     		movs	r1, #0
 224              	.LVL24:
 225 0010 6846     		mov	r0, sp
 226              	.LVL25:
 227 0012 FFF7FEFF 		bl	memset
 228              	.LVL26:
 198:../drivers/fsl_sai_dma.c **** 
 199:../drivers/fsl_sai_dma.c ****     /* Configure the audio format to SAI registers */
 200:../drivers/fsl_sai_dma.c ****     SAI_TxSetFormat(base, format, mclkSourceClockHz, bclkSourceClockHz);
 229              		.loc 1 200 0
 230 0016 0A9B     		ldr	r3, [sp, #40]
 231 0018 3A00     		movs	r2, r7
 232 001a 2900     		movs	r1, r5
 233 001c 2000     		movs	r0, r4
 234 001e FFF7FEFF 		bl	SAI_TxSetFormat
 235              	.LVL27:
 201:../drivers/fsl_sai_dma.c **** 
 202:../drivers/fsl_sai_dma.c ****     /* Update the information in handle */
 203:../drivers/fsl_sai_dma.c ****     handle->channel = format->channel;
 236              		.loc 1 203 0
 237 0022 2B7C     		ldrb	r3, [r5, #16]
 238 0024 7371     		strb	r3, [r6, #5]
 204:../drivers/fsl_sai_dma.c **** 
 205:../drivers/fsl_sai_dma.c ****     /* Configure the data format into DMA register */
 206:../drivers/fsl_sai_dma.c ****     config.destAddr = SAI_TxGetDataRegisterAddress(base, format->channel);
 239              		.loc 1 206 0
 240 0026 287C     		ldrb	r0, [r5, #16]
 241              	.LVL28:
 242              	.LBB30:
 243              	.LBB31:
 244              		.file 2 "../drivers/fsl_sai.h"
   1:../drivers/fsl_sai.h **** /*
   2:../drivers/fsl_sai.h ****  * The Clear BSD License
   3:../drivers/fsl_sai.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_sai.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_sai.h ****  * All rights reserved.
   6:../drivers/fsl_sai.h ****  *
   7:../drivers/fsl_sai.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_sai.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_sai.h ****  * that the following conditions are met:
  10:../drivers/fsl_sai.h ****  *
  11:../drivers/fsl_sai.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_sai.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_sai.h ****  *
  14:../drivers/fsl_sai.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_sai.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_sai.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_sai.h ****  *
  18:../drivers/fsl_sai.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_sai.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_sai.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_sai.h ****  *
  22:../drivers/fsl_sai.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_sai.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_sai.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_sai.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_sai.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_sai.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_sai.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_sai.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_sai.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_sai.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_sai.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_sai.h ****  */
  34:../drivers/fsl_sai.h **** 
  35:../drivers/fsl_sai.h **** #ifndef _FSL_SAI_H_
  36:../drivers/fsl_sai.h **** #define _FSL_SAI_H_
  37:../drivers/fsl_sai.h **** 
  38:../drivers/fsl_sai.h **** #include "fsl_common.h"
  39:../drivers/fsl_sai.h **** 
  40:../drivers/fsl_sai.h **** /*!
  41:../drivers/fsl_sai.h ****  * @addtogroup sai
  42:../drivers/fsl_sai.h ****  * @{
  43:../drivers/fsl_sai.h ****  */
  44:../drivers/fsl_sai.h **** 
  45:../drivers/fsl_sai.h **** /*******************************************************************************
  46:../drivers/fsl_sai.h ****  * Definitions
  47:../drivers/fsl_sai.h ****  ******************************************************************************/
  48:../drivers/fsl_sai.h **** 
  49:../drivers/fsl_sai.h **** /*! @name Driver version */
  50:../drivers/fsl_sai.h **** /*@{*/
  51:../drivers/fsl_sai.h **** #define FSL_SAI_DRIVER_VERSION (MAKE_VERSION(2, 1, 3)) /*!< Version 2.1.3 */
  52:../drivers/fsl_sai.h **** /*@}*/
  53:../drivers/fsl_sai.h **** 
  54:../drivers/fsl_sai.h **** /*! @brief SAI return status*/
  55:../drivers/fsl_sai.h **** enum _sai_status_t
  56:../drivers/fsl_sai.h **** {
  57:../drivers/fsl_sai.h ****     kStatus_SAI_TxBusy = MAKE_STATUS(kStatusGroup_SAI, 0),    /*!< SAI Tx is busy. */
  58:../drivers/fsl_sai.h ****     kStatus_SAI_RxBusy = MAKE_STATUS(kStatusGroup_SAI, 1),    /*!< SAI Rx is busy. */
  59:../drivers/fsl_sai.h ****     kStatus_SAI_TxError = MAKE_STATUS(kStatusGroup_SAI, 2),   /*!< SAI Tx FIFO error. */
  60:../drivers/fsl_sai.h ****     kStatus_SAI_RxError = MAKE_STATUS(kStatusGroup_SAI, 3),   /*!< SAI Rx FIFO error. */
  61:../drivers/fsl_sai.h ****     kStatus_SAI_QueueFull = MAKE_STATUS(kStatusGroup_SAI, 4), /*!< SAI transfer queue is full. */
  62:../drivers/fsl_sai.h ****     kStatus_SAI_TxIdle = MAKE_STATUS(kStatusGroup_SAI, 5),    /*!< SAI Tx is idle */
  63:../drivers/fsl_sai.h ****     kStatus_SAI_RxIdle = MAKE_STATUS(kStatusGroup_SAI, 6)     /*!< SAI Rx is idle */
  64:../drivers/fsl_sai.h **** };
  65:../drivers/fsl_sai.h **** 
  66:../drivers/fsl_sai.h **** /*! @brief Define the SAI bus type */
  67:../drivers/fsl_sai.h **** typedef enum _sai_protocol
  68:../drivers/fsl_sai.h **** {
  69:../drivers/fsl_sai.h ****     kSAI_BusLeftJustified = 0x0U, /*!< Uses left justified format.*/
  70:../drivers/fsl_sai.h ****     kSAI_BusRightJustified,       /*!< Uses right justified format. */
  71:../drivers/fsl_sai.h ****     kSAI_BusI2S,                  /*!< Uses I2S format. */
  72:../drivers/fsl_sai.h ****     kSAI_BusPCMA,                 /*!< Uses I2S PCM A format.*/
  73:../drivers/fsl_sai.h ****     kSAI_BusPCMB                  /*!< Uses I2S PCM B format. */
  74:../drivers/fsl_sai.h **** } sai_protocol_t;
  75:../drivers/fsl_sai.h **** 
  76:../drivers/fsl_sai.h **** /*! @brief Master or slave mode */
  77:../drivers/fsl_sai.h **** typedef enum _sai_master_slave
  78:../drivers/fsl_sai.h **** {
  79:../drivers/fsl_sai.h ****     kSAI_Master = 0x0U, /*!< Master mode */
  80:../drivers/fsl_sai.h ****     kSAI_Slave = 0x1U   /*!< Slave mode */
  81:../drivers/fsl_sai.h **** } sai_master_slave_t;
  82:../drivers/fsl_sai.h **** 
  83:../drivers/fsl_sai.h **** /*! @brief Mono or stereo audio format */
  84:../drivers/fsl_sai.h **** typedef enum _sai_mono_stereo
  85:../drivers/fsl_sai.h **** {
  86:../drivers/fsl_sai.h ****     kSAI_Stereo = 0x0U, /*!< Stereo sound. */
  87:../drivers/fsl_sai.h ****     kSAI_MonoRight,     /*!< Only Right channel have sound. */
  88:../drivers/fsl_sai.h ****     kSAI_MonoLeft       /*!< Only left channel have sound. */
  89:../drivers/fsl_sai.h **** } sai_mono_stereo_t;
  90:../drivers/fsl_sai.h **** 
  91:../drivers/fsl_sai.h **** /*! @brief Synchronous or asynchronous mode */
  92:../drivers/fsl_sai.h **** typedef enum _sai_sync_mode
  93:../drivers/fsl_sai.h **** {
  94:../drivers/fsl_sai.h ****     kSAI_ModeAsync = 0x0U,    /*!< Asynchronous mode */
  95:../drivers/fsl_sai.h ****     kSAI_ModeSync,            /*!< Synchronous mode (with receiver or transmit) */
  96:../drivers/fsl_sai.h ****     kSAI_ModeSyncWithOtherTx, /*!< Synchronous with another SAI transmit */
  97:../drivers/fsl_sai.h ****     kSAI_ModeSyncWithOtherRx  /*!< Synchronous with another SAI receiver */
  98:../drivers/fsl_sai.h **** } sai_sync_mode_t;
  99:../drivers/fsl_sai.h **** 
 100:../drivers/fsl_sai.h **** /*! @brief Mater clock source */
 101:../drivers/fsl_sai.h **** typedef enum _sai_mclk_source
 102:../drivers/fsl_sai.h **** {
 103:../drivers/fsl_sai.h ****     kSAI_MclkSourceSysclk = 0x0U, /*!< Master clock from the system clock */
 104:../drivers/fsl_sai.h ****     kSAI_MclkSourceSelect1,       /*!< Master clock from source 1 */
 105:../drivers/fsl_sai.h ****     kSAI_MclkSourceSelect2,       /*!< Master clock from source 2 */
 106:../drivers/fsl_sai.h ****     kSAI_MclkSourceSelect3        /*!< Master clock from source 3 */
 107:../drivers/fsl_sai.h **** } sai_mclk_source_t;
 108:../drivers/fsl_sai.h **** 
 109:../drivers/fsl_sai.h **** /*! @brief Bit clock source */
 110:../drivers/fsl_sai.h **** typedef enum _sai_bclk_source
 111:../drivers/fsl_sai.h **** {
 112:../drivers/fsl_sai.h ****     kSAI_BclkSourceBusclk = 0x0U, /*!< Bit clock using bus clock */
 113:../drivers/fsl_sai.h ****     kSAI_BclkSourceMclkDiv,       /*!< Bit clock using master clock divider */
 114:../drivers/fsl_sai.h ****     kSAI_BclkSourceOtherSai0,     /*!< Bit clock from other SAI device  */
 115:../drivers/fsl_sai.h ****     kSAI_BclkSourceOtherSai1      /*!< Bit clock from other SAI device */
 116:../drivers/fsl_sai.h **** } sai_bclk_source_t;
 117:../drivers/fsl_sai.h **** 
 118:../drivers/fsl_sai.h **** /*! @brief The SAI interrupt enable flag */
 119:../drivers/fsl_sai.h **** enum _sai_interrupt_enable_t
 120:../drivers/fsl_sai.h **** {
 121:../drivers/fsl_sai.h ****     kSAI_WordStartInterruptEnable =
 122:../drivers/fsl_sai.h ****         I2S_TCSR_WSIE_MASK, /*!< Word start flag, means the first word in a frame detected */
 123:../drivers/fsl_sai.h ****     kSAI_SyncErrorInterruptEnable = I2S_TCSR_SEIE_MASK,   /*!< Sync error flag, means the sync erro
 124:../drivers/fsl_sai.h ****     kSAI_FIFOWarningInterruptEnable = I2S_TCSR_FWIE_MASK, /*!< FIFO warning flag, means the FIFO is
 125:../drivers/fsl_sai.h ****     kSAI_FIFOErrorInterruptEnable = I2S_TCSR_FEIE_MASK,   /*!< FIFO error flag */
 126:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 127:../drivers/fsl_sai.h ****     kSAI_FIFORequestInterruptEnable = I2S_TCSR_FRIE_MASK, /*!< FIFO request, means reached watermar
 128:../drivers/fsl_sai.h **** #endif                                                    /* FSL_FEATURE_SAI_FIFO_COUNT */
 129:../drivers/fsl_sai.h **** };
 130:../drivers/fsl_sai.h **** 
 131:../drivers/fsl_sai.h **** /*! @brief The DMA request sources */
 132:../drivers/fsl_sai.h **** enum _sai_dma_enable_t
 133:../drivers/fsl_sai.h **** {
 134:../drivers/fsl_sai.h ****     kSAI_FIFOWarningDMAEnable = I2S_TCSR_FWDE_MASK, /*!< FIFO warning caused by the DMA request */
 135:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 136:../drivers/fsl_sai.h ****     kSAI_FIFORequestDMAEnable = I2S_TCSR_FRDE_MASK, /*!< FIFO request caused by the DMA request */
 137:../drivers/fsl_sai.h **** #endif                                              /* FSL_FEATURE_SAI_FIFO_COUNT */
 138:../drivers/fsl_sai.h **** };
 139:../drivers/fsl_sai.h **** 
 140:../drivers/fsl_sai.h **** /*! @brief The SAI status flag */
 141:../drivers/fsl_sai.h **** enum _sai_flags
 142:../drivers/fsl_sai.h **** {
 143:../drivers/fsl_sai.h ****     kSAI_WordStartFlag = I2S_TCSR_WSF_MASK, /*!< Word start flag, means the first word in a frame d
 144:../drivers/fsl_sai.h ****     kSAI_SyncErrorFlag = I2S_TCSR_SEF_MASK, /*!< Sync error flag, means the sync error is detected 
 145:../drivers/fsl_sai.h ****     kSAI_FIFOErrorFlag = I2S_TCSR_FEF_MASK, /*!< FIFO error flag */
 146:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 147:../drivers/fsl_sai.h ****     kSAI_FIFORequestFlag = I2S_TCSR_FRF_MASK, /*!< FIFO request flag. */
 148:../drivers/fsl_sai.h **** #endif                                        /* FSL_FEATURE_SAI_FIFO_COUNT */
 149:../drivers/fsl_sai.h ****     kSAI_FIFOWarningFlag = I2S_TCSR_FWF_MASK, /*!< FIFO warning flag */
 150:../drivers/fsl_sai.h **** };
 151:../drivers/fsl_sai.h **** 
 152:../drivers/fsl_sai.h **** /*! @brief The reset type */
 153:../drivers/fsl_sai.h **** typedef enum _sai_reset_type
 154:../drivers/fsl_sai.h **** {
 155:../drivers/fsl_sai.h ****     kSAI_ResetTypeSoftware = I2S_TCSR_SR_MASK,          /*!< Software reset, reset the logic state 
 156:../drivers/fsl_sai.h ****     kSAI_ResetTypeFIFO = I2S_TCSR_FR_MASK,              /*!< FIFO reset, reset the FIFO read and wr
 157:../drivers/fsl_sai.h ****     kSAI_ResetAll = I2S_TCSR_SR_MASK | I2S_TCSR_FR_MASK /*!< All reset. */
 158:../drivers/fsl_sai.h **** } sai_reset_type_t;
 159:../drivers/fsl_sai.h **** 
 160:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_HAS_FIFO_PACKING) && FSL_FEATURE_SAI_HAS_FIFO_PACKING
 161:../drivers/fsl_sai.h **** /*!
 162:../drivers/fsl_sai.h ****  * @brief The SAI packing mode
 163:../drivers/fsl_sai.h ****  * The mode includes 8 bit and 16 bit packing.
 164:../drivers/fsl_sai.h ****  */
 165:../drivers/fsl_sai.h **** typedef enum _sai_fifo_packing
 166:../drivers/fsl_sai.h **** {
 167:../drivers/fsl_sai.h ****     kSAI_FifoPackingDisabled = 0x0U, /*!< Packing disabled */
 168:../drivers/fsl_sai.h ****     kSAI_FifoPacking8bit = 0x2U,     /*!< 8 bit packing enabled */
 169:../drivers/fsl_sai.h ****     kSAI_FifoPacking16bit = 0x3U     /*!< 16bit packing enabled */
 170:../drivers/fsl_sai.h **** } sai_fifo_packing_t;
 171:../drivers/fsl_sai.h **** #endif /* FSL_FEATURE_SAI_HAS_FIFO_PACKING */
 172:../drivers/fsl_sai.h **** 
 173:../drivers/fsl_sai.h **** /*! @brief SAI user configuration structure */
 174:../drivers/fsl_sai.h **** typedef struct _sai_config
 175:../drivers/fsl_sai.h **** {
 176:../drivers/fsl_sai.h ****     sai_protocol_t protocol;  /*!< Audio bus protocol in SAI */
 177:../drivers/fsl_sai.h ****     sai_sync_mode_t syncMode; /*!< SAI sync mode, control Tx/Rx clock sync */
 178:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_HAS_MCR) && (FSL_FEATURE_SAI_HAS_MCR)
 179:../drivers/fsl_sai.h ****     bool mclkOutputEnable;          /*!< Master clock output enable, true means master clock divide
 180:../drivers/fsl_sai.h **** #endif                              /* FSL_FEATURE_SAI_HAS_MCR */
 181:../drivers/fsl_sai.h ****     sai_mclk_source_t mclkSource;   /*!< Master Clock source */
 182:../drivers/fsl_sai.h ****     sai_bclk_source_t bclkSource;   /*!< Bit Clock source */
 183:../drivers/fsl_sai.h ****     sai_master_slave_t masterSlave; /*!< Master or slave */
 184:../drivers/fsl_sai.h **** } sai_config_t;
 185:../drivers/fsl_sai.h **** 
 186:../drivers/fsl_sai.h **** /*!@brief SAI transfer queue size, user can refine it according to use case. */
 187:../drivers/fsl_sai.h **** #define SAI_XFER_QUEUE_SIZE (4)
 188:../drivers/fsl_sai.h **** 
 189:../drivers/fsl_sai.h **** /*! @brief Audio sample rate */
 190:../drivers/fsl_sai.h **** typedef enum _sai_sample_rate
 191:../drivers/fsl_sai.h **** {
 192:../drivers/fsl_sai.h ****     kSAI_SampleRate8KHz = 8000U,     /*!< Sample rate 8000 Hz */
 193:../drivers/fsl_sai.h ****     kSAI_SampleRate11025Hz = 11025U, /*!< Sample rate 11025 Hz */
 194:../drivers/fsl_sai.h ****     kSAI_SampleRate12KHz = 12000U,   /*!< Sample rate 12000 Hz */
 195:../drivers/fsl_sai.h ****     kSAI_SampleRate16KHz = 16000U,   /*!< Sample rate 16000 Hz */
 196:../drivers/fsl_sai.h ****     kSAI_SampleRate22050Hz = 22050U, /*!< Sample rate 22050 Hz */
 197:../drivers/fsl_sai.h ****     kSAI_SampleRate24KHz = 24000U,   /*!< Sample rate 24000 Hz */
 198:../drivers/fsl_sai.h ****     kSAI_SampleRate32KHz = 32000U,   /*!< Sample rate 32000 Hz */
 199:../drivers/fsl_sai.h ****     kSAI_SampleRate44100Hz = 44100U, /*!< Sample rate 44100 Hz */
 200:../drivers/fsl_sai.h ****     kSAI_SampleRate48KHz = 48000U,   /*!< Sample rate 48000 Hz */
 201:../drivers/fsl_sai.h ****     kSAI_SampleRate96KHz = 96000U    /*!< Sample rate 96000 Hz */
 202:../drivers/fsl_sai.h **** } sai_sample_rate_t;
 203:../drivers/fsl_sai.h **** 
 204:../drivers/fsl_sai.h **** /*! @brief Audio word width */
 205:../drivers/fsl_sai.h **** typedef enum _sai_word_width
 206:../drivers/fsl_sai.h **** {
 207:../drivers/fsl_sai.h ****     kSAI_WordWidth8bits = 8U,   /*!< Audio data width 8 bits */
 208:../drivers/fsl_sai.h ****     kSAI_WordWidth16bits = 16U, /*!< Audio data width 16 bits */
 209:../drivers/fsl_sai.h ****     kSAI_WordWidth24bits = 24U, /*!< Audio data width 24 bits */
 210:../drivers/fsl_sai.h ****     kSAI_WordWidth32bits = 32U  /*!< Audio data width 32 bits */
 211:../drivers/fsl_sai.h **** } sai_word_width_t;
 212:../drivers/fsl_sai.h **** 
 213:../drivers/fsl_sai.h **** /*! @brief sai transfer format */
 214:../drivers/fsl_sai.h **** typedef struct _sai_transfer_format
 215:../drivers/fsl_sai.h **** {
 216:../drivers/fsl_sai.h ****     uint32_t sampleRate_Hz;   /*!< Sample rate of audio data */
 217:../drivers/fsl_sai.h ****     uint32_t bitWidth;        /*!< Data length of audio data, usually 8/16/24/32 bits */
 218:../drivers/fsl_sai.h ****     sai_mono_stereo_t stereo; /*!< Mono or stereo */
 219:../drivers/fsl_sai.h ****     uint32_t masterClockHz;   /*!< Master clock frequency in Hz */
 220:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 221:../drivers/fsl_sai.h ****     uint8_t watermark;       /*!< Watermark value */
 222:../drivers/fsl_sai.h **** #endif                       /* FSL_FEATURE_SAI_FIFO_COUNT */
 223:../drivers/fsl_sai.h ****     uint8_t channel;         /*!< Data channel used in transfer.*/
 224:../drivers/fsl_sai.h ****     sai_protocol_t protocol; /*!< Which audio protocol used */
 225:../drivers/fsl_sai.h ****     bool isFrameSyncCompact; /*!< True means Frame sync length is configurable according to bitWidt
 226:../drivers/fsl_sai.h ****                                 sync length is 64 times of bit clock. */
 227:../drivers/fsl_sai.h **** } sai_transfer_format_t;
 228:../drivers/fsl_sai.h **** 
 229:../drivers/fsl_sai.h **** /*! @brief SAI transfer structure */
 230:../drivers/fsl_sai.h **** typedef struct _sai_transfer
 231:../drivers/fsl_sai.h **** {
 232:../drivers/fsl_sai.h ****     uint8_t *data;   /*!< Data start address to transfer. */
 233:../drivers/fsl_sai.h ****     size_t dataSize; /*!< Transfer size. */
 234:../drivers/fsl_sai.h **** } sai_transfer_t;
 235:../drivers/fsl_sai.h **** 
 236:../drivers/fsl_sai.h **** typedef struct _sai_handle sai_handle_t;
 237:../drivers/fsl_sai.h **** 
 238:../drivers/fsl_sai.h **** /*! @brief SAI transfer callback prototype */
 239:../drivers/fsl_sai.h **** typedef void (*sai_transfer_callback_t)(I2S_Type *base, sai_handle_t *handle, status_t status, void
 240:../drivers/fsl_sai.h **** 
 241:../drivers/fsl_sai.h **** /*! @brief SAI handle structure */
 242:../drivers/fsl_sai.h **** struct _sai_handle
 243:../drivers/fsl_sai.h **** {
 244:../drivers/fsl_sai.h ****     uint32_t state;                               /*!< Transfer status */
 245:../drivers/fsl_sai.h ****     sai_transfer_callback_t callback;             /*!< Callback function called at transfer event*/
 246:../drivers/fsl_sai.h ****     void *userData;                               /*!< Callback parameter passed to callback functi
 247:../drivers/fsl_sai.h ****     uint8_t bitWidth;                             /*!< Bit width for transfer, 8/16/24/32 bits */
 248:../drivers/fsl_sai.h ****     uint8_t channel;                              /*!< Transfer channel */
 249:../drivers/fsl_sai.h ****     sai_transfer_t saiQueue[SAI_XFER_QUEUE_SIZE]; /*!< Transfer queue storing queued transfer */
 250:../drivers/fsl_sai.h ****     size_t transferSize[SAI_XFER_QUEUE_SIZE];     /*!< Data bytes need to transfer */
 251:../drivers/fsl_sai.h ****     volatile uint8_t queueUser;                   /*!< Index for user to queue transfer */
 252:../drivers/fsl_sai.h ****     volatile uint8_t queueDriver;                 /*!< Index for driver to get the transfer data an
 253:../drivers/fsl_sai.h **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 254:../drivers/fsl_sai.h ****     uint8_t watermark; /*!< Watermark value */
 255:../drivers/fsl_sai.h **** #endif
 256:../drivers/fsl_sai.h **** };
 257:../drivers/fsl_sai.h **** 
 258:../drivers/fsl_sai.h **** /*******************************************************************************
 259:../drivers/fsl_sai.h ****  * API
 260:../drivers/fsl_sai.h ****  ******************************************************************************/
 261:../drivers/fsl_sai.h **** 
 262:../drivers/fsl_sai.h **** #if defined(__cplusplus)
 263:../drivers/fsl_sai.h **** extern "C" {
 264:../drivers/fsl_sai.h **** #endif /*_cplusplus*/
 265:../drivers/fsl_sai.h **** 
 266:../drivers/fsl_sai.h **** /*!
 267:../drivers/fsl_sai.h ****  * @name Initialization and deinitialization
 268:../drivers/fsl_sai.h ****  * @{
 269:../drivers/fsl_sai.h ****  */
 270:../drivers/fsl_sai.h **** 
 271:../drivers/fsl_sai.h **** /*!
 272:../drivers/fsl_sai.h ****  * @brief Initializes the SAI Tx peripheral.
 273:../drivers/fsl_sai.h ****  *
 274:../drivers/fsl_sai.h ****  * Ungates the SAI clock, resets the module, and configures SAI Tx with a configuration structure.
 275:../drivers/fsl_sai.h ****  * The configuration structure can be custom filled or set with default values by
 276:../drivers/fsl_sai.h ****  * SAI_TxGetDefaultConfig().
 277:../drivers/fsl_sai.h ****  *
 278:../drivers/fsl_sai.h ****  * @note  This API should be called at the beginning of the application to use
 279:../drivers/fsl_sai.h ****  * the SAI driver. Otherwise, accessing the SAIM module can cause a hard fault
 280:../drivers/fsl_sai.h ****  * because the clock is not enabled.
 281:../drivers/fsl_sai.h ****  *
 282:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 283:../drivers/fsl_sai.h ****  * @param config SAI configuration structure.
 284:../drivers/fsl_sai.h **** */
 285:../drivers/fsl_sai.h **** void SAI_TxInit(I2S_Type *base, const sai_config_t *config);
 286:../drivers/fsl_sai.h **** 
 287:../drivers/fsl_sai.h **** /*!
 288:../drivers/fsl_sai.h ****  * @brief Initializes the the SAI Rx peripheral.
 289:../drivers/fsl_sai.h ****  *
 290:../drivers/fsl_sai.h ****  * Ungates the SAI clock, resets the module, and configures the SAI Rx with a configuration structu
 291:../drivers/fsl_sai.h ****  * The configuration structure can be custom filled or set with default values by
 292:../drivers/fsl_sai.h ****  * SAI_RxGetDefaultConfig().
 293:../drivers/fsl_sai.h ****  *
 294:../drivers/fsl_sai.h ****  * @note  This API should be called at the beginning of the application to use
 295:../drivers/fsl_sai.h ****  * the SAI driver. Otherwise, accessing the SAI module can cause a hard fault
 296:../drivers/fsl_sai.h ****  * because the clock is not enabled.
 297:../drivers/fsl_sai.h ****  *
 298:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 299:../drivers/fsl_sai.h ****  * @param config SAI configuration structure.
 300:../drivers/fsl_sai.h ****  */
 301:../drivers/fsl_sai.h **** void SAI_RxInit(I2S_Type *base, const sai_config_t *config);
 302:../drivers/fsl_sai.h **** 
 303:../drivers/fsl_sai.h **** /*!
 304:../drivers/fsl_sai.h ****  * @brief  Sets the SAI Tx configuration structure to default values.
 305:../drivers/fsl_sai.h ****  *
 306:../drivers/fsl_sai.h ****  * This API initializes the configuration structure for use in SAI_TxConfig().
 307:../drivers/fsl_sai.h ****  * The initialized structure can remain unchanged in SAI_TxConfig(), or it can be modified
 308:../drivers/fsl_sai.h ****  *  before calling SAI_TxConfig().
 309:../drivers/fsl_sai.h ****  * This is an example.
 310:../drivers/fsl_sai.h ****    @code
 311:../drivers/fsl_sai.h ****    sai_config_t config;
 312:../drivers/fsl_sai.h ****    SAI_TxGetDefaultConfig(&config);
 313:../drivers/fsl_sai.h ****    @endcode
 314:../drivers/fsl_sai.h ****  *
 315:../drivers/fsl_sai.h ****  * @param config pointer to master configuration structure
 316:../drivers/fsl_sai.h ****  */
 317:../drivers/fsl_sai.h **** void SAI_TxGetDefaultConfig(sai_config_t *config);
 318:../drivers/fsl_sai.h **** 
 319:../drivers/fsl_sai.h **** /*!
 320:../drivers/fsl_sai.h ****  * @brief  Sets the SAI Rx configuration structure to default values.
 321:../drivers/fsl_sai.h ****  *
 322:../drivers/fsl_sai.h ****  * This API initializes the configuration structure for use in SAI_RxConfig().
 323:../drivers/fsl_sai.h ****  * The initialized structure can remain unchanged in SAI_RxConfig() or it can be modified
 324:../drivers/fsl_sai.h ****  *  before calling SAI_RxConfig().
 325:../drivers/fsl_sai.h ****  * This is an example.
 326:../drivers/fsl_sai.h ****    @code
 327:../drivers/fsl_sai.h ****    sai_config_t config;
 328:../drivers/fsl_sai.h ****    SAI_RxGetDefaultConfig(&config);
 329:../drivers/fsl_sai.h ****    @endcode
 330:../drivers/fsl_sai.h ****  *
 331:../drivers/fsl_sai.h ****  * @param config pointer to master configuration structure
 332:../drivers/fsl_sai.h ****  */
 333:../drivers/fsl_sai.h **** void SAI_RxGetDefaultConfig(sai_config_t *config);
 334:../drivers/fsl_sai.h **** 
 335:../drivers/fsl_sai.h **** /*!
 336:../drivers/fsl_sai.h ****  * @brief De-initializes the SAI peripheral.
 337:../drivers/fsl_sai.h ****  *
 338:../drivers/fsl_sai.h ****  * This API gates the SAI clock. The SAI module can't operate unless SAI_TxInit
 339:../drivers/fsl_sai.h ****  * or SAI_RxInit is called to enable the clock.
 340:../drivers/fsl_sai.h ****  *
 341:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 342:../drivers/fsl_sai.h **** */
 343:../drivers/fsl_sai.h **** void SAI_Deinit(I2S_Type *base);
 344:../drivers/fsl_sai.h **** 
 345:../drivers/fsl_sai.h **** /*!
 346:../drivers/fsl_sai.h ****  * @brief Resets the SAI Tx.
 347:../drivers/fsl_sai.h ****  *
 348:../drivers/fsl_sai.h ****  * This function enables the software reset and FIFO reset of SAI Tx. After reset, clear the reset 
 349:../drivers/fsl_sai.h ****  *
 350:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 351:../drivers/fsl_sai.h ****  */
 352:../drivers/fsl_sai.h **** void SAI_TxReset(I2S_Type *base);
 353:../drivers/fsl_sai.h **** 
 354:../drivers/fsl_sai.h **** /*!
 355:../drivers/fsl_sai.h ****  * @brief Resets the SAI Rx.
 356:../drivers/fsl_sai.h ****  *
 357:../drivers/fsl_sai.h ****  * This function enables the software reset and FIFO reset of SAI Rx. After reset, clear the reset 
 358:../drivers/fsl_sai.h ****  *
 359:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 360:../drivers/fsl_sai.h ****  */
 361:../drivers/fsl_sai.h **** void SAI_RxReset(I2S_Type *base);
 362:../drivers/fsl_sai.h **** 
 363:../drivers/fsl_sai.h **** /*!
 364:../drivers/fsl_sai.h ****  * @brief Enables/disables the SAI Tx.
 365:../drivers/fsl_sai.h ****  *
 366:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 367:../drivers/fsl_sai.h ****  * @param enable True means enable SAI Tx, false means disable.
 368:../drivers/fsl_sai.h ****  */
 369:../drivers/fsl_sai.h **** void SAI_TxEnable(I2S_Type *base, bool enable);
 370:../drivers/fsl_sai.h **** 
 371:../drivers/fsl_sai.h **** /*!
 372:../drivers/fsl_sai.h ****  * @brief Enables/disables the SAI Rx.
 373:../drivers/fsl_sai.h ****  *
 374:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 375:../drivers/fsl_sai.h ****  * @param enable True means enable SAI Rx, false means disable.
 376:../drivers/fsl_sai.h ****  */
 377:../drivers/fsl_sai.h **** void SAI_RxEnable(I2S_Type *base, bool enable);
 378:../drivers/fsl_sai.h **** 
 379:../drivers/fsl_sai.h **** /*! @} */
 380:../drivers/fsl_sai.h **** 
 381:../drivers/fsl_sai.h **** /*!
 382:../drivers/fsl_sai.h ****  * @name Status
 383:../drivers/fsl_sai.h ****  * @{
 384:../drivers/fsl_sai.h ****  */
 385:../drivers/fsl_sai.h **** 
 386:../drivers/fsl_sai.h **** /*!
 387:../drivers/fsl_sai.h ****  * @brief Gets the SAI Tx status flag state.
 388:../drivers/fsl_sai.h ****  *
 389:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 390:../drivers/fsl_sai.h ****  * @return SAI Tx status flag value. Use the Status Mask to get the status value needed.
 391:../drivers/fsl_sai.h ****  */
 392:../drivers/fsl_sai.h **** static inline uint32_t SAI_TxGetStatusFlag(I2S_Type *base)
 393:../drivers/fsl_sai.h **** {
 394:../drivers/fsl_sai.h ****     return base->TCSR;
 395:../drivers/fsl_sai.h **** }
 396:../drivers/fsl_sai.h **** 
 397:../drivers/fsl_sai.h **** /*!
 398:../drivers/fsl_sai.h ****  * @brief Clears the SAI Tx status flag state.
 399:../drivers/fsl_sai.h ****  *
 400:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 401:../drivers/fsl_sai.h ****  * @param mask State mask. It can be a combination of the following source if defined:
 402:../drivers/fsl_sai.h ****  *        @arg kSAI_WordStartFlag
 403:../drivers/fsl_sai.h ****  *        @arg kSAI_SyncErrorFlag
 404:../drivers/fsl_sai.h ****  *        @arg kSAI_FIFOErrorFlag
 405:../drivers/fsl_sai.h ****  */
 406:../drivers/fsl_sai.h **** static inline void SAI_TxClearStatusFlags(I2S_Type *base, uint32_t mask)
 407:../drivers/fsl_sai.h **** {
 408:../drivers/fsl_sai.h ****     base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | mask);
 409:../drivers/fsl_sai.h **** }
 410:../drivers/fsl_sai.h **** 
 411:../drivers/fsl_sai.h **** /*!
 412:../drivers/fsl_sai.h ****  * @brief Gets the SAI Tx status flag state.
 413:../drivers/fsl_sai.h ****  *
 414:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 415:../drivers/fsl_sai.h ****  * @return SAI Rx status flag value. Use the Status Mask to get the status value needed.
 416:../drivers/fsl_sai.h ****  */
 417:../drivers/fsl_sai.h **** static inline uint32_t SAI_RxGetStatusFlag(I2S_Type *base)
 418:../drivers/fsl_sai.h **** {
 419:../drivers/fsl_sai.h ****     return base->RCSR;
 420:../drivers/fsl_sai.h **** }
 421:../drivers/fsl_sai.h **** 
 422:../drivers/fsl_sai.h **** /*!
 423:../drivers/fsl_sai.h ****  * @brief Clears the SAI Rx status flag state.
 424:../drivers/fsl_sai.h ****  *
 425:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 426:../drivers/fsl_sai.h ****  * @param mask State mask. It can be a combination of the following sources if defined.
 427:../drivers/fsl_sai.h ****  *        @arg kSAI_WordStartFlag
 428:../drivers/fsl_sai.h ****  *        @arg kSAI_SyncErrorFlag
 429:../drivers/fsl_sai.h ****  *        @arg kSAI_FIFOErrorFlag
 430:../drivers/fsl_sai.h ****  */
 431:../drivers/fsl_sai.h **** static inline void SAI_RxClearStatusFlags(I2S_Type *base, uint32_t mask)
 432:../drivers/fsl_sai.h **** {
 433:../drivers/fsl_sai.h ****     base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | mask);
 434:../drivers/fsl_sai.h **** }
 435:../drivers/fsl_sai.h **** 
 436:../drivers/fsl_sai.h **** /*!
 437:../drivers/fsl_sai.h ****  * @brief Do software reset or FIFO reset .
 438:../drivers/fsl_sai.h ****  *
 439:../drivers/fsl_sai.h ****  * FIFO reset means clear all the data in the FIFO, and make the FIFO pointer both to 0.
 440:../drivers/fsl_sai.h ****  * Software reset means claer the Tx internal logic, including the bit clock, frame count etc. But 
 441:../drivers/fsl_sai.h ****  * reset will not clear any configuration registers like TCR1~TCR5.
 442:../drivers/fsl_sai.h ****  * This function will also clear all the error flags such as FIFO error, sync error etc.
 443:../drivers/fsl_sai.h ****  *
 444:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 445:../drivers/fsl_sai.h ****  * @param type Reset type, FIFO reset or software reset
 446:../drivers/fsl_sai.h ****  */
 447:../drivers/fsl_sai.h **** void SAI_TxSoftwareReset(I2S_Type *base, sai_reset_type_t type);
 448:../drivers/fsl_sai.h **** 
 449:../drivers/fsl_sai.h **** /*!
 450:../drivers/fsl_sai.h ****  * @brief Do software reset or FIFO reset .
 451:../drivers/fsl_sai.h ****  *
 452:../drivers/fsl_sai.h ****  * FIFO reset means clear all the data in the FIFO, and make the FIFO pointer both to 0.
 453:../drivers/fsl_sai.h ****  * Software reset means claer the Rx internal logic, including the bit clock, frame count etc. But 
 454:../drivers/fsl_sai.h ****  * reset will not clear any configuration registers like RCR1~RCR5.
 455:../drivers/fsl_sai.h ****  * This function will also clear all the error flags such as FIFO error, sync error etc.
 456:../drivers/fsl_sai.h ****  *
 457:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 458:../drivers/fsl_sai.h ****  * @param type Reset type, FIFO reset or software reset
 459:../drivers/fsl_sai.h ****  */
 460:../drivers/fsl_sai.h **** void SAI_RxSoftwareReset(I2S_Type *base, sai_reset_type_t type);
 461:../drivers/fsl_sai.h **** 
 462:../drivers/fsl_sai.h **** /*!
 463:../drivers/fsl_sai.h ****  * @brief Set the Tx channel FIFO enable mask.
 464:../drivers/fsl_sai.h ****  *
 465:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 466:../drivers/fsl_sai.h ****  * @param mask Channel enable mask, 0 means all channel FIFO disabled, 1 means channel 0 enabled,
 467:../drivers/fsl_sai.h ****  * 3 means both channel 0 and channel 1 enabled.
 468:../drivers/fsl_sai.h ****  */
 469:../drivers/fsl_sai.h **** void SAI_TxSetChannelFIFOMask(I2S_Type *base, uint8_t mask);
 470:../drivers/fsl_sai.h **** 
 471:../drivers/fsl_sai.h **** /*!
 472:../drivers/fsl_sai.h ****  * @brief Set the Rx channel FIFO enable mask.
 473:../drivers/fsl_sai.h ****  *
 474:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 475:../drivers/fsl_sai.h ****  * @param mask Channel enable mask, 0 means all channel FIFO disabled, 1 means channel 0 enabled,
 476:../drivers/fsl_sai.h ****  * 3 means both channel 0 and channel 1 enabled.
 477:../drivers/fsl_sai.h ****  */
 478:../drivers/fsl_sai.h **** void SAI_RxSetChannelFIFOMask(I2S_Type *base, uint8_t mask);
 479:../drivers/fsl_sai.h **** 
 480:../drivers/fsl_sai.h **** /*! @} */
 481:../drivers/fsl_sai.h **** 
 482:../drivers/fsl_sai.h **** /*!
 483:../drivers/fsl_sai.h ****  * @name Interrupts
 484:../drivers/fsl_sai.h ****  * @{
 485:../drivers/fsl_sai.h ****  */
 486:../drivers/fsl_sai.h **** 
 487:../drivers/fsl_sai.h **** /*!
 488:../drivers/fsl_sai.h ****  * @brief Enables the SAI Tx interrupt requests.
 489:../drivers/fsl_sai.h ****  *
 490:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 491:../drivers/fsl_sai.h ****  * @param mask interrupt source
 492:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 493:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 494:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 495:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 496:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 497:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 498:../drivers/fsl_sai.h ****  */
 499:../drivers/fsl_sai.h **** static inline void SAI_TxEnableInterrupts(I2S_Type *base, uint32_t mask)
 500:../drivers/fsl_sai.h **** {
 501:../drivers/fsl_sai.h ****     base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | mask);
 502:../drivers/fsl_sai.h **** }
 503:../drivers/fsl_sai.h **** 
 504:../drivers/fsl_sai.h **** /*!
 505:../drivers/fsl_sai.h ****  * @brief Enables the SAI Rx interrupt requests.
 506:../drivers/fsl_sai.h ****  *
 507:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 508:../drivers/fsl_sai.h ****  * @param mask interrupt source
 509:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 510:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 511:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 512:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 513:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 514:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 515:../drivers/fsl_sai.h ****  */
 516:../drivers/fsl_sai.h **** static inline void SAI_RxEnableInterrupts(I2S_Type *base, uint32_t mask)
 517:../drivers/fsl_sai.h **** {
 518:../drivers/fsl_sai.h ****     base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | mask);
 519:../drivers/fsl_sai.h **** }
 520:../drivers/fsl_sai.h **** 
 521:../drivers/fsl_sai.h **** /*!
 522:../drivers/fsl_sai.h ****  * @brief Disables the SAI Tx interrupt requests.
 523:../drivers/fsl_sai.h ****  *
 524:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 525:../drivers/fsl_sai.h ****  * @param mask interrupt source
 526:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 527:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 528:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 529:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 530:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 531:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 532:../drivers/fsl_sai.h ****  */
 533:../drivers/fsl_sai.h **** static inline void SAI_TxDisableInterrupts(I2S_Type *base, uint32_t mask)
 534:../drivers/fsl_sai.h **** {
 535:../drivers/fsl_sai.h ****     base->TCSR = ((base->TCSR & 0xFFE3FFFFU) & (~mask));
 536:../drivers/fsl_sai.h **** }
 537:../drivers/fsl_sai.h **** 
 538:../drivers/fsl_sai.h **** /*!
 539:../drivers/fsl_sai.h ****  * @brief Disables the SAI Rx interrupt requests.
 540:../drivers/fsl_sai.h ****  *
 541:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 542:../drivers/fsl_sai.h ****  * @param mask interrupt source
 543:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 544:../drivers/fsl_sai.h ****  *     @arg kSAI_WordStartInterruptEnable
 545:../drivers/fsl_sai.h ****  *     @arg kSAI_SyncErrorInterruptEnable
 546:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningInterruptEnable
 547:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestInterruptEnable
 548:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOErrorInterruptEnable
 549:../drivers/fsl_sai.h ****  */
 550:../drivers/fsl_sai.h **** static inline void SAI_RxDisableInterrupts(I2S_Type *base, uint32_t mask)
 551:../drivers/fsl_sai.h **** {
 552:../drivers/fsl_sai.h ****     base->RCSR = ((base->RCSR & 0xFFE3FFFFU) & (~mask));
 553:../drivers/fsl_sai.h **** }
 554:../drivers/fsl_sai.h **** 
 555:../drivers/fsl_sai.h **** /*! @} */
 556:../drivers/fsl_sai.h **** 
 557:../drivers/fsl_sai.h **** /*!
 558:../drivers/fsl_sai.h ****  * @name DMA Control
 559:../drivers/fsl_sai.h ****  * @{
 560:../drivers/fsl_sai.h ****  */
 561:../drivers/fsl_sai.h **** 
 562:../drivers/fsl_sai.h **** /*!
 563:../drivers/fsl_sai.h ****  * @brief Enables/disables the SAI Tx DMA requests.
 564:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 565:../drivers/fsl_sai.h ****  * @param mask DMA source
 566:../drivers/fsl_sai.h ****  *     The parameter can be combination of the following sources if defined.
 567:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningDMAEnable
 568:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestDMAEnable
 569:../drivers/fsl_sai.h ****  * @param enable True means enable DMA, false means disable DMA.
 570:../drivers/fsl_sai.h ****  */
 571:../drivers/fsl_sai.h **** static inline void SAI_TxEnableDMA(I2S_Type *base, uint32_t mask, bool enable)
 572:../drivers/fsl_sai.h **** {
 573:../drivers/fsl_sai.h ****     if (enable)
 574:../drivers/fsl_sai.h ****     {
 575:../drivers/fsl_sai.h ****         base->TCSR = ((base->TCSR & 0xFFE3FFFFU) | mask);
 576:../drivers/fsl_sai.h ****     }
 577:../drivers/fsl_sai.h ****     else
 578:../drivers/fsl_sai.h ****     {
 579:../drivers/fsl_sai.h ****         base->TCSR = ((base->TCSR & 0xFFE3FFFFU) & (~mask));
 580:../drivers/fsl_sai.h ****     }
 581:../drivers/fsl_sai.h **** }
 582:../drivers/fsl_sai.h **** 
 583:../drivers/fsl_sai.h **** /*!
 584:../drivers/fsl_sai.h ****  * @brief Enables/disables the SAI Rx DMA requests.
 585:../drivers/fsl_sai.h ****  * @param base SAI base pointer
 586:../drivers/fsl_sai.h ****  * @param mask DMA source
 587:../drivers/fsl_sai.h ****  *     The parameter can be a combination of the following sources if defined.
 588:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFOWarningDMAEnable
 589:../drivers/fsl_sai.h ****  *     @arg kSAI_FIFORequestDMAEnable
 590:../drivers/fsl_sai.h ****  * @param enable True means enable DMA, false means disable DMA.
 591:../drivers/fsl_sai.h ****  */
 592:../drivers/fsl_sai.h **** static inline void SAI_RxEnableDMA(I2S_Type *base, uint32_t mask, bool enable)
 593:../drivers/fsl_sai.h **** {
 594:../drivers/fsl_sai.h ****     if (enable)
 595:../drivers/fsl_sai.h ****     {
 596:../drivers/fsl_sai.h ****         base->RCSR = ((base->RCSR & 0xFFE3FFFFU) | mask);
 597:../drivers/fsl_sai.h ****     }
 598:../drivers/fsl_sai.h ****     else
 599:../drivers/fsl_sai.h ****     {
 600:../drivers/fsl_sai.h ****         base->RCSR = ((base->RCSR & 0xFFE3FFFFU) & (~mask));
 601:../drivers/fsl_sai.h ****     }
 602:../drivers/fsl_sai.h **** }
 603:../drivers/fsl_sai.h **** 
 604:../drivers/fsl_sai.h **** /*!
 605:../drivers/fsl_sai.h ****  * @brief  Gets the SAI Tx data register address.
 606:../drivers/fsl_sai.h ****  *
 607:../drivers/fsl_sai.h ****  * This API is used to provide a transfer address for the SAI DMA transfer configuration.
 608:../drivers/fsl_sai.h ****  *
 609:../drivers/fsl_sai.h ****  * @param base SAI base pointer.
 610:../drivers/fsl_sai.h ****  * @param channel Which data channel used.
 611:../drivers/fsl_sai.h ****  * @return data register address.
 612:../drivers/fsl_sai.h ****  */
 613:../drivers/fsl_sai.h **** static inline uint32_t SAI_TxGetDataRegisterAddress(I2S_Type *base, uint32_t channel)
 614:../drivers/fsl_sai.h **** {
 615:../drivers/fsl_sai.h ****     return (uint32_t)(&(base->TDR)[channel]);
 245              		.loc 2 615 0
 246 0028 0830     		adds	r0, r0, #8
 247              	.LVL29:
 248 002a 8000     		lsls	r0, r0, #2
 249              	.LVL30:
 250 002c 2018     		adds	r0, r4, r0
 251              	.LVL31:
 252              	.LBE31:
 253              	.LBE30:
 254              		.loc 1 206 0
 255 002e 0190     		str	r0, [sp, #4]
 207:../drivers/fsl_sai_dma.c ****     config.enableDestIncrement = false;
 256              		.loc 1 207 0
 257 0030 0023     		movs	r3, #0
 258 0032 6A46     		mov	r2, sp
 259 0034 9372     		strb	r3, [r2, #10]
 208:../drivers/fsl_sai_dma.c ****     config.enableSrcIncrement = true;
 260              		.loc 1 208 0
 261 0036 0133     		adds	r3, r3, #1
 262 0038 1372     		strb	r3, [r2, #8]
 209:../drivers/fsl_sai_dma.c ****     switch (format->bitWidth)
 263              		.loc 1 209 0
 264 003a 6B68     		ldr	r3, [r5, #4]
 265 003c 082B     		cmp	r3, #8
 266 003e 08D0     		beq	.L9
 267 0040 102B     		cmp	r3, #16
 268 0042 12D0     		beq	.L10
 210:../drivers/fsl_sai_dma.c ****     {
 211:../drivers/fsl_sai_dma.c ****         case 8:
 212:../drivers/fsl_sai_dma.c ****             config.srcSize = kDMA_Transfersize8bits;
 213:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize8bits;
 214:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 1U;
 215:../drivers/fsl_sai_dma.c ****             break;
 216:../drivers/fsl_sai_dma.c ****         case 16:
 217:../drivers/fsl_sai_dma.c ****             config.srcSize = kDMA_Transfersize16bits;
 218:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize16bits;
 219:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 2U;
 220:../drivers/fsl_sai_dma.c ****             break;
 221:../drivers/fsl_sai_dma.c ****         default:
 222:../drivers/fsl_sai_dma.c ****             config.srcSize = kDMA_Transfersize32bits;
 269              		.loc 1 222 0
 270 0044 0023     		movs	r3, #0
 271 0046 6A46     		mov	r2, sp
 272 0048 5372     		strb	r3, [r2, #9]
 223:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize32bits;
 273              		.loc 1 223 0
 274 004a D372     		strb	r3, [r2, #11]
 224:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 4U;
 275              		.loc 1 224 0
 276 004c 0433     		adds	r3, r3, #4
 277 004e 3371     		strb	r3, [r6, #4]
 225:../drivers/fsl_sai_dma.c ****             break;
 278              		.loc 1 225 0
 279 0050 04E0     		b	.L11
 280              	.L9:
 212:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize8bits;
 281              		.loc 1 212 0
 282 0052 0123     		movs	r3, #1
 283 0054 6A46     		mov	r2, sp
 284 0056 5372     		strb	r3, [r2, #9]
 213:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 1U;
 285              		.loc 1 213 0
 286 0058 D372     		strb	r3, [r2, #11]
 214:../drivers/fsl_sai_dma.c ****             break;
 287              		.loc 1 214 0
 288 005a 3371     		strb	r3, [r6, #4]
 289              	.L11:
 226:../drivers/fsl_sai_dma.c ****     }
 227:../drivers/fsl_sai_dma.c **** 
 228:../drivers/fsl_sai_dma.c ****     /* Configure DMA channel */
 229:../drivers/fsl_sai_dma.c ****     DMA_SubmitTransfer(handle->dmaHandle, &config, true);
 290              		.loc 1 229 0
 291 005c 3068     		ldr	r0, [r6]
 292 005e 0122     		movs	r2, #1
 293 0060 6946     		mov	r1, sp
 294 0062 FFF7FEFF 		bl	DMA_SubmitTransfer
 295              	.LVL32:
 230:../drivers/fsl_sai_dma.c **** }
 296              		.loc 1 230 0
 297 0066 05B0     		add	sp, sp, #20
 298              		@ sp needed
 299              	.LVL33:
 300              	.LVL34:
 301              	.LVL35:
 302              	.LVL36:
 303 0068 F0BD     		pop	{r4, r5, r6, r7, pc}
 304              	.LVL37:
 305              	.L10:
 217:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize16bits;
 306              		.loc 1 217 0
 307 006a 0223     		movs	r3, #2
 308 006c 6A46     		mov	r2, sp
 309 006e 5372     		strb	r3, [r2, #9]
 218:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 2U;
 310              		.loc 1 218 0
 311 0070 D372     		strb	r3, [r2, #11]
 219:../drivers/fsl_sai_dma.c ****             break;
 312              		.loc 1 219 0
 313 0072 3371     		strb	r3, [r6, #4]
 220:../drivers/fsl_sai_dma.c ****         default:
 314              		.loc 1 220 0
 315 0074 F2E7     		b	.L11
 316              		.cfi_endproc
 317              	.LFE87:
 319              		.section	.text.SAI_TransferRxSetFormatDMA,"ax",%progbits
 320              		.align	1
 321              		.global	SAI_TransferRxSetFormatDMA
 322              		.syntax unified
 323              		.code	16
 324              		.thumb_func
 325              		.fpu softvfp
 327              	SAI_TransferRxSetFormatDMA:
 328              	.LFB88:
 231:../drivers/fsl_sai_dma.c **** 
 232:../drivers/fsl_sai_dma.c **** void SAI_TransferRxSetFormatDMA(I2S_Type *base,
 233:../drivers/fsl_sai_dma.c ****                                 sai_dma_handle_t *handle,
 234:../drivers/fsl_sai_dma.c ****                                 sai_transfer_format_t *format,
 235:../drivers/fsl_sai_dma.c ****                                 uint32_t mclkSourceClockHz,
 236:../drivers/fsl_sai_dma.c ****                                 uint32_t bclkSourceClockHz)
 237:../drivers/fsl_sai_dma.c **** {
 329              		.loc 1 237 0
 330              		.cfi_startproc
 331              		@ args = 4, pretend = 0, frame = 16
 332              		@ frame_needed = 0, uses_anonymous_args = 0
 333              	.LVL38:
 334 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 335              		.cfi_def_cfa_offset 20
 336              		.cfi_offset 4, -20
 337              		.cfi_offset 5, -16
 338              		.cfi_offset 6, -12
 339              		.cfi_offset 7, -8
 340              		.cfi_offset 14, -4
 341 0002 85B0     		sub	sp, sp, #20
 342              		.cfi_def_cfa_offset 40
 343 0004 0400     		movs	r4, r0
 344 0006 0E00     		movs	r6, r1
 345 0008 1500     		movs	r5, r2
 346 000a 1F00     		movs	r7, r3
 238:../drivers/fsl_sai_dma.c ****     assert(handle && format);
 239:../drivers/fsl_sai_dma.c **** 
 240:../drivers/fsl_sai_dma.c ****     dma_transfer_config_t config = {0};
 347              		.loc 1 240 0
 348 000c 1022     		movs	r2, #16
 349              	.LVL39:
 350 000e 0021     		movs	r1, #0
 351              	.LVL40:
 352 0010 6846     		mov	r0, sp
 353              	.LVL41:
 354 0012 FFF7FEFF 		bl	memset
 355              	.LVL42:
 241:../drivers/fsl_sai_dma.c **** 
 242:../drivers/fsl_sai_dma.c ****     /* Configure the audio format to SAI registers */
 243:../drivers/fsl_sai_dma.c ****     SAI_RxSetFormat(base, format, mclkSourceClockHz, bclkSourceClockHz);
 356              		.loc 1 243 0
 357 0016 0A9B     		ldr	r3, [sp, #40]
 358 0018 3A00     		movs	r2, r7
 359 001a 2900     		movs	r1, r5
 360 001c 2000     		movs	r0, r4
 361 001e FFF7FEFF 		bl	SAI_RxSetFormat
 362              	.LVL43:
 244:../drivers/fsl_sai_dma.c ****     handle->channel = format->channel;
 363              		.loc 1 244 0
 364 0022 2B7C     		ldrb	r3, [r5, #16]
 365 0024 7371     		strb	r3, [r6, #5]
 245:../drivers/fsl_sai_dma.c **** 
 246:../drivers/fsl_sai_dma.c ****     /* Configure the data format into DMA register */
 247:../drivers/fsl_sai_dma.c ****     config.srcAddr = SAI_RxGetDataRegisterAddress(base, format->channel);
 366              		.loc 1 247 0
 367 0026 287C     		ldrb	r0, [r5, #16]
 368              	.LVL44:
 369              	.LBB32:
 370              	.LBB33:
 616:../drivers/fsl_sai.h **** }
 617:../drivers/fsl_sai.h **** 
 618:../drivers/fsl_sai.h **** /*!
 619:../drivers/fsl_sai.h ****  * @brief  Gets the SAI Rx data register address.
 620:../drivers/fsl_sai.h ****  *
 621:../drivers/fsl_sai.h ****  * This API is used to provide a transfer address for the SAI DMA transfer configuration.
 622:../drivers/fsl_sai.h ****  *
 623:../drivers/fsl_sai.h ****  * @param base SAI base pointer.
 624:../drivers/fsl_sai.h ****  * @param channel Which data channel used.
 625:../drivers/fsl_sai.h ****  * @return data register address.
 626:../drivers/fsl_sai.h ****  */
 627:../drivers/fsl_sai.h **** static inline uint32_t SAI_RxGetDataRegisterAddress(I2S_Type *base, uint32_t channel)
 628:../drivers/fsl_sai.h **** {
 629:../drivers/fsl_sai.h ****     return (uint32_t)(&(base->RDR)[channel]);
 371              		.loc 2 629 0
 372 0028 2830     		adds	r0, r0, #40
 373              	.LVL45:
 374 002a 8000     		lsls	r0, r0, #2
 375              	.LVL46:
 376 002c 2018     		adds	r0, r4, r0
 377              	.LVL47:
 378              	.LBE33:
 379              	.LBE32:
 380              		.loc 1 247 0
 381 002e 0090     		str	r0, [sp]
 248:../drivers/fsl_sai_dma.c ****     config.enableDestIncrement = true;
 382              		.loc 1 248 0
 383 0030 0123     		movs	r3, #1
 384 0032 6A46     		mov	r2, sp
 385 0034 9372     		strb	r3, [r2, #10]
 249:../drivers/fsl_sai_dma.c ****     config.enableSrcIncrement = false;
 386              		.loc 1 249 0
 387 0036 0023     		movs	r3, #0
 388 0038 1372     		strb	r3, [r2, #8]
 250:../drivers/fsl_sai_dma.c ****     switch (format->bitWidth)
 389              		.loc 1 250 0
 390 003a 6B68     		ldr	r3, [r5, #4]
 391 003c 082B     		cmp	r3, #8
 392 003e 08D0     		beq	.L15
 393 0040 102B     		cmp	r3, #16
 394 0042 12D0     		beq	.L16
 251:../drivers/fsl_sai_dma.c ****     {
 252:../drivers/fsl_sai_dma.c ****         case 8:
 253:../drivers/fsl_sai_dma.c ****             config.srcSize = kDMA_Transfersize8bits;
 254:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize8bits;
 255:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 1U;
 256:../drivers/fsl_sai_dma.c ****             break;
 257:../drivers/fsl_sai_dma.c ****         case 16:
 258:../drivers/fsl_sai_dma.c ****             config.srcSize = kDMA_Transfersize16bits;
 259:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize16bits;
 260:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 2U;
 261:../drivers/fsl_sai_dma.c ****             break;
 262:../drivers/fsl_sai_dma.c ****         default:
 263:../drivers/fsl_sai_dma.c ****             config.srcSize = kDMA_Transfersize32bits;
 395              		.loc 1 263 0
 396 0044 0023     		movs	r3, #0
 397 0046 6A46     		mov	r2, sp
 398 0048 5372     		strb	r3, [r2, #9]
 264:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize32bits;
 399              		.loc 1 264 0
 400 004a D372     		strb	r3, [r2, #11]
 265:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 4U;
 401              		.loc 1 265 0
 402 004c 0433     		adds	r3, r3, #4
 403 004e 3371     		strb	r3, [r6, #4]
 266:../drivers/fsl_sai_dma.c ****             break;
 404              		.loc 1 266 0
 405 0050 04E0     		b	.L17
 406              	.L15:
 253:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize8bits;
 407              		.loc 1 253 0
 408 0052 0123     		movs	r3, #1
 409 0054 6A46     		mov	r2, sp
 410 0056 5372     		strb	r3, [r2, #9]
 254:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 1U;
 411              		.loc 1 254 0
 412 0058 D372     		strb	r3, [r2, #11]
 255:../drivers/fsl_sai_dma.c ****             break;
 413              		.loc 1 255 0
 414 005a 3371     		strb	r3, [r6, #4]
 415              	.L17:
 267:../drivers/fsl_sai_dma.c ****     }
 268:../drivers/fsl_sai_dma.c **** 
 269:../drivers/fsl_sai_dma.c ****     /* Configure DMA channel */
 270:../drivers/fsl_sai_dma.c ****     DMA_SubmitTransfer(handle->dmaHandle, &config, true);
 416              		.loc 1 270 0
 417 005c 3068     		ldr	r0, [r6]
 418 005e 0122     		movs	r2, #1
 419 0060 6946     		mov	r1, sp
 420 0062 FFF7FEFF 		bl	DMA_SubmitTransfer
 421              	.LVL48:
 271:../drivers/fsl_sai_dma.c **** }
 422              		.loc 1 271 0
 423 0066 05B0     		add	sp, sp, #20
 424              		@ sp needed
 425              	.LVL49:
 426              	.LVL50:
 427              	.LVL51:
 428              	.LVL52:
 429 0068 F0BD     		pop	{r4, r5, r6, r7, pc}
 430              	.LVL53:
 431              	.L16:
 258:../drivers/fsl_sai_dma.c ****             config.destSize = kDMA_Transfersize16bits;
 432              		.loc 1 258 0
 433 006a 0223     		movs	r3, #2
 434 006c 6A46     		mov	r2, sp
 435 006e 5372     		strb	r3, [r2, #9]
 259:../drivers/fsl_sai_dma.c ****             handle->bytesPerFrame = 2U;
 436              		.loc 1 259 0
 437 0070 D372     		strb	r3, [r2, #11]
 260:../drivers/fsl_sai_dma.c ****             break;
 438              		.loc 1 260 0
 439 0072 3371     		strb	r3, [r6, #4]
 261:../drivers/fsl_sai_dma.c ****         default:
 440              		.loc 1 261 0
 441 0074 F2E7     		b	.L17
 442              		.cfi_endproc
 443              	.LFE88:
 445              		.section	.text.SAI_TransferSendDMA,"ax",%progbits
 446              		.align	1
 447              		.global	SAI_TransferSendDMA
 448              		.syntax unified
 449              		.code	16
 450              		.thumb_func
 451              		.fpu softvfp
 453              	SAI_TransferSendDMA:
 454              	.LFB89:
 272:../drivers/fsl_sai_dma.c **** 
 273:../drivers/fsl_sai_dma.c **** status_t SAI_TransferSendDMA(I2S_Type *base, sai_dma_handle_t *handle, sai_transfer_t *xfer)
 274:../drivers/fsl_sai_dma.c **** {
 455              		.loc 1 274 0
 456              		.cfi_startproc
 457              		@ args = 0, pretend = 0, frame = 0
 458              		@ frame_needed = 0, uses_anonymous_args = 0
 459              	.LVL54:
 460 0000 70B5     		push	{r4, r5, r6, lr}
 461              		.cfi_def_cfa_offset 16
 462              		.cfi_offset 4, -16
 463              		.cfi_offset 5, -12
 464              		.cfi_offset 6, -8
 465              		.cfi_offset 14, -4
 275:../drivers/fsl_sai_dma.c ****     assert(handle && xfer);
 276:../drivers/fsl_sai_dma.c **** 
 277:../drivers/fsl_sai_dma.c ****     /* Check if input parameter invalid */
 278:../drivers/fsl_sai_dma.c ****     if ((xfer->data == NULL) || (xfer->dataSize == 0U))
 466              		.loc 1 278 0
 467 0002 1368     		ldr	r3, [r2]
 468 0004 002B     		cmp	r3, #0
 469 0006 4FD0     		beq	.L21
 470              		.loc 1 278 0 is_stmt 0 discriminator 1
 471 0008 5468     		ldr	r4, [r2, #4]
 472 000a 002C     		cmp	r4, #0
 473 000c 4ED0     		beq	.L22
 279:../drivers/fsl_sai_dma.c ****     {
 280:../drivers/fsl_sai_dma.c ****         return kStatus_InvalidArgument;
 281:../drivers/fsl_sai_dma.c ****     }
 282:../drivers/fsl_sai_dma.c **** 
 283:../drivers/fsl_sai_dma.c ****     if (handle->saiQueue[handle->queueUser].data)
 474              		.loc 1 283 0 is_stmt 1
 475 000e 4423     		movs	r3, #68
 476 0010 CB5C     		ldrb	r3, [r1, r3]
 477 0012 0233     		adds	r3, r3, #2
 478 0014 DB00     		lsls	r3, r3, #3
 479 0016 CB18     		adds	r3, r1, r3
 480 0018 5B68     		ldr	r3, [r3, #4]
 481 001a 002B     		cmp	r3, #0
 482 001c 02D0     		beq	.L24
 284:../drivers/fsl_sai_dma.c ****     {
 285:../drivers/fsl_sai_dma.c ****         return kStatus_SAI_QueueFull;
 483              		.loc 1 285 0
 484 001e EE20     		movs	r0, #238
 485              	.LVL55:
 486 0020 C000     		lsls	r0, r0, #3
 487              	.LVL56:
 488              	.L19:
 286:../drivers/fsl_sai_dma.c ****     }
 287:../drivers/fsl_sai_dma.c **** 
 288:../drivers/fsl_sai_dma.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 289:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 290:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 291:../drivers/fsl_sai_dma.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 292:../drivers/fsl_sai_dma.c **** 
 293:../drivers/fsl_sai_dma.c ****     /* Set the source address */
 294:../drivers/fsl_sai_dma.c ****     DMA_SetSourceAddress(handle->dmaHandle->base, handle->dmaHandle->channel, (uint32_t)(xfer->data
 295:../drivers/fsl_sai_dma.c **** 
 296:../drivers/fsl_sai_dma.c ****     /* Set the transfer size */
 297:../drivers/fsl_sai_dma.c ****     DMA_SetTransferSize(handle->dmaHandle->base, handle->dmaHandle->channel, xfer->dataSize);
 298:../drivers/fsl_sai_dma.c **** 
 299:../drivers/fsl_sai_dma.c ****     /* Change the state of handle */
 300:../drivers/fsl_sai_dma.c ****     handle->state = kSAI_Busy;
 301:../drivers/fsl_sai_dma.c **** 
 302:../drivers/fsl_sai_dma.c ****     /* Start DMA transfer */
 303:../drivers/fsl_sai_dma.c ****     DMA_StartTransfer(handle->dmaHandle);
 304:../drivers/fsl_sai_dma.c **** 
 305:../drivers/fsl_sai_dma.c **** /* Enable DMA request and start SAI */
 306:../drivers/fsl_sai_dma.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 307:../drivers/fsl_sai_dma.c ****     SAI_TxEnableDMA(base, kSAI_FIFORequestDMAEnable, true);
 308:../drivers/fsl_sai_dma.c **** #else
 309:../drivers/fsl_sai_dma.c ****     SAI_TxEnableDMA(base, kSAI_FIFOWarningDMAEnable, true);
 310:../drivers/fsl_sai_dma.c **** #endif
 311:../drivers/fsl_sai_dma.c ****     SAI_TxEnable(base, true);
 312:../drivers/fsl_sai_dma.c **** 
 313:../drivers/fsl_sai_dma.c ****     return kStatus_Success;
 314:../drivers/fsl_sai_dma.c **** }
 489              		.loc 1 314 0
 490              		@ sp needed
 491 0022 70BD     		pop	{r4, r5, r6, pc}
 492              	.LVL57:
 493              	.L24:
 288:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 494              		.loc 1 288 0
 495 0024 4425     		movs	r5, #68
 496 0026 4B5D     		ldrb	r3, [r1, r5]
 497 0028 0C33     		adds	r3, r3, #12
 498 002a 9B00     		lsls	r3, r3, #2
 499 002c CB18     		adds	r3, r1, r3
 500 002e 5C60     		str	r4, [r3, #4]
 289:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 501              		.loc 1 289 0
 502 0030 4B5D     		ldrb	r3, [r1, r5]
 503 0032 0233     		adds	r3, r3, #2
 504 0034 DB00     		lsls	r3, r3, #3
 505 0036 CB18     		adds	r3, r1, r3
 506 0038 1468     		ldr	r4, [r2]
 507 003a 5C60     		str	r4, [r3, #4]
 290:../drivers/fsl_sai_dma.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 508              		.loc 1 290 0
 509 003c 4B5D     		ldrb	r3, [r1, r5]
 510 003e 0233     		adds	r3, r3, #2
 511 0040 DB00     		lsls	r3, r3, #3
 512 0042 CB18     		adds	r3, r1, r3
 513 0044 5468     		ldr	r4, [r2, #4]
 514 0046 9C60     		str	r4, [r3, #8]
 291:../drivers/fsl_sai_dma.c **** 
 515              		.loc 1 291 0
 516 0048 4C5D     		ldrb	r4, [r1, r5]
 517 004a 0134     		adds	r4, r4, #1
 518 004c 0323     		movs	r3, #3
 519 004e 2340     		ands	r3, r4
 520 0050 4B55     		strb	r3, [r1, r5]
 294:../drivers/fsl_sai_dma.c **** 
 521              		.loc 1 294 0
 522 0052 0B68     		ldr	r3, [r1]
 523 0054 1C68     		ldr	r4, [r3]
 524 0056 1B79     		ldrb	r3, [r3, #4]
 525              	.LVL58:
 526              	.LBB34:
 527              	.LBB35:
 528              		.file 3 "../drivers/fsl_dma.h"
   1:../drivers/fsl_dma.h **** /*
   2:../drivers/fsl_dma.h ****  * The Clear BSD License
   3:../drivers/fsl_dma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dma.h ****  * All rights reserved.
   6:../drivers/fsl_dma.h ****  *
   7:../drivers/fsl_dma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dma.h ****  * that the following conditions are met:
  10:../drivers/fsl_dma.h ****  *
  11:../drivers/fsl_dma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dma.h ****  *
  14:../drivers/fsl_dma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dma.h ****  *
  18:../drivers/fsl_dma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dma.h ****  *
  22:../drivers/fsl_dma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dma.h ****  */
  34:../drivers/fsl_dma.h **** 
  35:../drivers/fsl_dma.h **** #ifndef _FSL_DMA_H_
  36:../drivers/fsl_dma.h **** #define _FSL_DMA_H_
  37:../drivers/fsl_dma.h **** 
  38:../drivers/fsl_dma.h **** #include "fsl_common.h"
  39:../drivers/fsl_dma.h **** 
  40:../drivers/fsl_dma.h **** /*!
  41:../drivers/fsl_dma.h ****  * @addtogroup dma
  42:../drivers/fsl_dma.h ****  * @{
  43:../drivers/fsl_dma.h ****  */
  44:../drivers/fsl_dma.h **** 
  45:../drivers/fsl_dma.h **** 
  46:../drivers/fsl_dma.h **** /*******************************************************************************
  47:../drivers/fsl_dma.h ****  * Definitions
  48:../drivers/fsl_dma.h ****  ******************************************************************************/
  49:../drivers/fsl_dma.h **** 
  50:../drivers/fsl_dma.h **** /*! @name Driver version */
  51:../drivers/fsl_dma.h **** /*@{*/
  52:../drivers/fsl_dma.h **** /*! @brief DMA driver version 2.0.1. */
  53:../drivers/fsl_dma.h **** #define FSL_DMA_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  54:../drivers/fsl_dma.h **** /*@}*/
  55:../drivers/fsl_dma.h **** 
  56:../drivers/fsl_dma.h **** /*! @brief status flag for the DMA driver. */
  57:../drivers/fsl_dma.h **** enum _dma_channel_status_flags
  58:../drivers/fsl_dma.h **** {
  59:../drivers/fsl_dma.h ****     kDMA_TransactionsBCRFlag = DMA_DSR_BCR_BCR_MASK,       /*!< Contains the number of bytes yet to
  60:../drivers/fsl_dma.h ****                                                                 transferred for a given block */
  61:../drivers/fsl_dma.h ****     kDMA_TransactionsDoneFlag = DMA_DSR_BCR_DONE_MASK,     /*!< Transactions Done */
  62:../drivers/fsl_dma.h ****     kDMA_TransactionsBusyFlag = DMA_DSR_BCR_BSY_MASK,      /*!< Transactions Busy */
  63:../drivers/fsl_dma.h ****     kDMA_TransactionsRequestFlag = DMA_DSR_BCR_REQ_MASK,   /*!< Transactions Request */
  64:../drivers/fsl_dma.h ****     kDMA_BusErrorOnDestinationFlag = DMA_DSR_BCR_BED_MASK, /*!< Bus Error on Destination */
  65:../drivers/fsl_dma.h ****     kDMA_BusErrorOnSourceFlag = DMA_DSR_BCR_BES_MASK,      /*!< Bus Error on Source */
  66:../drivers/fsl_dma.h ****     kDMA_ConfigurationErrorFlag = DMA_DSR_BCR_CE_MASK,     /*!< Configuration Error */
  67:../drivers/fsl_dma.h **** };
  68:../drivers/fsl_dma.h **** 
  69:../drivers/fsl_dma.h **** /*! @brief DMA transfer size type*/
  70:../drivers/fsl_dma.h **** typedef enum _dma_transfer_size
  71:../drivers/fsl_dma.h **** {
  72:../drivers/fsl_dma.h ****     kDMA_Transfersize32bits = 0x0U, /*!< 32 bits are transferred for every read/write */
  73:../drivers/fsl_dma.h ****     kDMA_Transfersize8bits,         /*!< 8 bits are transferred for every read/write */
  74:../drivers/fsl_dma.h ****     kDMA_Transfersize16bits,        /*!< 16b its are transferred for every read/write */
  75:../drivers/fsl_dma.h **** } dma_transfer_size_t;
  76:../drivers/fsl_dma.h **** 
  77:../drivers/fsl_dma.h **** /*! @brief Configuration type for the DMA modulo */
  78:../drivers/fsl_dma.h **** typedef enum _dma_modulo
  79:../drivers/fsl_dma.h **** {
  80:../drivers/fsl_dma.h ****     kDMA_ModuloDisable = 0x0U, /*!< Buffer disabled */
  81:../drivers/fsl_dma.h ****     kDMA_Modulo16Bytes,        /*!< Circular buffer size is 16 bytes. */
  82:../drivers/fsl_dma.h ****     kDMA_Modulo32Bytes,        /*!< Circular buffer size is 32 bytes. */
  83:../drivers/fsl_dma.h ****     kDMA_Modulo64Bytes,        /*!< Circular buffer size is 64 bytes. */
  84:../drivers/fsl_dma.h ****     kDMA_Modulo128Bytes,       /*!< Circular buffer size is 128 bytes. */
  85:../drivers/fsl_dma.h ****     kDMA_Modulo256Bytes,       /*!< Circular buffer size is 256 bytes. */
  86:../drivers/fsl_dma.h ****     kDMA_Modulo512Bytes,       /*!< Circular buffer size is 512 bytes. */
  87:../drivers/fsl_dma.h ****     kDMA_Modulo1KBytes,        /*!< Circular buffer size is 1 KB. */
  88:../drivers/fsl_dma.h ****     kDMA_Modulo2KBytes,        /*!< Circular buffer size is 2 KB. */
  89:../drivers/fsl_dma.h ****     kDMA_Modulo4KBytes,        /*!< Circular buffer size is 4 KB. */
  90:../drivers/fsl_dma.h ****     kDMA_Modulo8KBytes,        /*!< Circular buffer size is 8 KB. */
  91:../drivers/fsl_dma.h ****     kDMA_Modulo16KBytes,       /*!< Circular buffer size is 16 KB. */
  92:../drivers/fsl_dma.h ****     kDMA_Modulo32KBytes,       /*!< Circular buffer size is 32 KB. */
  93:../drivers/fsl_dma.h ****     kDMA_Modulo64KBytes,       /*!< Circular buffer size is 64 KB. */
  94:../drivers/fsl_dma.h ****     kDMA_Modulo128KBytes,      /*!< Circular buffer size is 128 KB. */
  95:../drivers/fsl_dma.h ****     kDMA_Modulo256KBytes,      /*!< Circular buffer size is 256 KB. */
  96:../drivers/fsl_dma.h **** } dma_modulo_t;
  97:../drivers/fsl_dma.h **** 
  98:../drivers/fsl_dma.h **** /*! @brief DMA channel link type */
  99:../drivers/fsl_dma.h **** typedef enum _dma_channel_link_type
 100:../drivers/fsl_dma.h **** {
 101:../drivers/fsl_dma.h ****     kDMA_ChannelLinkDisable = 0x0U,      /*!< No channel link. */
 102:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AndChannel2, /*!< Perform a link to channel LCH1 after each cycle-steal
 103:../drivers/fsl_dma.h ****                                               followed by a link to LCH2 after the BCR decrements t
 104:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1,            /*!< Perform a link to LCH1 after each cycle-steal transfe
 105:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AfterBCR0,   /*!< Perform a link to LCH1 after the BCR decrements. */
 106:../drivers/fsl_dma.h **** } dma_channel_link_type_t;
 107:../drivers/fsl_dma.h **** 
 108:../drivers/fsl_dma.h **** /*! @brief DMA transfer type */
 109:../drivers/fsl_dma.h **** typedef enum _dma_transfer_type
 110:../drivers/fsl_dma.h **** {
 111:../drivers/fsl_dma.h ****     kDMA_MemoryToMemory = 0x0U, /*!< Memory to Memory transfer. */
 112:../drivers/fsl_dma.h ****     kDMA_PeripheralToMemory,    /*!< Peripheral to Memory transfer. */
 113:../drivers/fsl_dma.h ****     kDMA_MemoryToPeripheral,    /*!< Memory to Peripheral transfer. */
 114:../drivers/fsl_dma.h **** } dma_transfer_type_t;
 115:../drivers/fsl_dma.h **** 
 116:../drivers/fsl_dma.h **** /*! @brief DMA transfer options */
 117:../drivers/fsl_dma.h **** typedef enum _dma_transfer_options
 118:../drivers/fsl_dma.h **** {
 119:../drivers/fsl_dma.h ****     kDMA_NoOptions = 0x0U, /*!< Transfer without options. */
 120:../drivers/fsl_dma.h ****     kDMA_EnableInterrupt,  /*!< Enable interrupt while transfer complete. */
 121:../drivers/fsl_dma.h **** } dma_transfer_options_t;
 122:../drivers/fsl_dma.h **** 
 123:../drivers/fsl_dma.h **** /*! @brief DMA transfer status */
 124:../drivers/fsl_dma.h **** enum _dma_transfer_status
 125:../drivers/fsl_dma.h **** {
 126:../drivers/fsl_dma.h ****     kStatus_DMA_Busy = MAKE_STATUS(kStatusGroup_DMA, 0),
 127:../drivers/fsl_dma.h **** };
 128:../drivers/fsl_dma.h **** 
 129:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 130:../drivers/fsl_dma.h **** typedef struct _dma_transfer_config
 131:../drivers/fsl_dma.h **** {
 132:../drivers/fsl_dma.h ****     uint32_t srcAddr;             /*!< DMA transfer source address. */
 133:../drivers/fsl_dma.h ****     uint32_t destAddr;            /*!< DMA destination address.*/
 134:../drivers/fsl_dma.h ****     bool enableSrcIncrement;      /*!< Source address increase after each transfer. */
 135:../drivers/fsl_dma.h ****     dma_transfer_size_t srcSize;  /*!< Source transfer size unit. */
 136:../drivers/fsl_dma.h ****     bool enableDestIncrement;     /*!< Destination address increase after each transfer. */
 137:../drivers/fsl_dma.h ****     dma_transfer_size_t destSize; /*!< Destination transfer unit.*/
 138:../drivers/fsl_dma.h ****     uint32_t transferSize;        /*!< The number of bytes to be transferred. */
 139:../drivers/fsl_dma.h **** } dma_transfer_config_t;
 140:../drivers/fsl_dma.h **** 
 141:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 142:../drivers/fsl_dma.h **** typedef struct _dma_channel_link_config
 143:../drivers/fsl_dma.h **** {
 144:../drivers/fsl_dma.h ****     dma_channel_link_type_t linkType; /*!< Channel link type. */
 145:../drivers/fsl_dma.h ****     uint32_t channel1;                /*!< The index of channel 1. */
 146:../drivers/fsl_dma.h ****     uint32_t channel2;                /*!< The index of channel 2. */
 147:../drivers/fsl_dma.h **** } dma_channel_link_config_t;
 148:../drivers/fsl_dma.h **** 
 149:../drivers/fsl_dma.h **** struct _dma_handle;
 150:../drivers/fsl_dma.h **** /*! @brief Callback function prototype for the DMA driver. */
 151:../drivers/fsl_dma.h **** typedef void (*dma_callback)(struct _dma_handle *handle, void *userData);
 152:../drivers/fsl_dma.h **** 
 153:../drivers/fsl_dma.h **** /*! @brief DMA DMA handle structure */
 154:../drivers/fsl_dma.h **** typedef struct _dma_handle
 155:../drivers/fsl_dma.h **** {
 156:../drivers/fsl_dma.h ****     DMA_Type *base;        /*!< DMA peripheral address. */
 157:../drivers/fsl_dma.h ****     uint8_t channel;       /*!< DMA channel used. */
 158:../drivers/fsl_dma.h ****     dma_callback callback; /*!< DMA callback function.*/
 159:../drivers/fsl_dma.h ****     void *userData;        /*!< Callback parameter. */
 160:../drivers/fsl_dma.h **** } dma_handle_t;
 161:../drivers/fsl_dma.h **** 
 162:../drivers/fsl_dma.h **** /*******************************************************************************
 163:../drivers/fsl_dma.h ****  * API
 164:../drivers/fsl_dma.h ****  ******************************************************************************/
 165:../drivers/fsl_dma.h **** #if defined(__cplusplus)
 166:../drivers/fsl_dma.h **** extern "C" {
 167:../drivers/fsl_dma.h **** #endif /* __cplusplus */
 168:../drivers/fsl_dma.h **** 
 169:../drivers/fsl_dma.h **** /*!
 170:../drivers/fsl_dma.h ****  * @name DMA Initialization and De-initialization
 171:../drivers/fsl_dma.h ****  * @{
 172:../drivers/fsl_dma.h ****  */
 173:../drivers/fsl_dma.h **** 
 174:../drivers/fsl_dma.h **** /*!
 175:../drivers/fsl_dma.h ****  * @brief Initializes the DMA peripheral.
 176:../drivers/fsl_dma.h ****  *
 177:../drivers/fsl_dma.h ****  * This function ungates the DMA clock.
 178:../drivers/fsl_dma.h ****  *
 179:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 180:../drivers/fsl_dma.h ****  */
 181:../drivers/fsl_dma.h **** void DMA_Init(DMA_Type *base);
 182:../drivers/fsl_dma.h **** 
 183:../drivers/fsl_dma.h **** /*!
 184:../drivers/fsl_dma.h ****  * @brief Deinitializes the DMA peripheral.
 185:../drivers/fsl_dma.h ****  *
 186:../drivers/fsl_dma.h ****  * This function gates the DMA clock.
 187:../drivers/fsl_dma.h ****  *
 188:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 189:../drivers/fsl_dma.h ****  */
 190:../drivers/fsl_dma.h **** void DMA_Deinit(DMA_Type *base);
 191:../drivers/fsl_dma.h **** 
 192:../drivers/fsl_dma.h **** /* @} */
 193:../drivers/fsl_dma.h **** /*!
 194:../drivers/fsl_dma.h ****  * @name DMA Channel Operation
 195:../drivers/fsl_dma.h ****  * @{
 196:../drivers/fsl_dma.h ****  */
 197:../drivers/fsl_dma.h **** 
 198:../drivers/fsl_dma.h **** /*!
 199:../drivers/fsl_dma.h ****  * @brief Resets the DMA channel.
 200:../drivers/fsl_dma.h ****  *
 201:../drivers/fsl_dma.h ****  * Sets all register values to reset values and enables
 202:../drivers/fsl_dma.h ****  * the cycle steal and auto stop channel request features.
 203:../drivers/fsl_dma.h ****  *
 204:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 205:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 206:../drivers/fsl_dma.h ****  */
 207:../drivers/fsl_dma.h **** void DMA_ResetChannel(DMA_Type *base, uint32_t channel);
 208:../drivers/fsl_dma.h **** 
 209:../drivers/fsl_dma.h **** /*!
 210:../drivers/fsl_dma.h ****  * @brief Configures the DMA transfer attribute.
 211:../drivers/fsl_dma.h ****  *
 212:../drivers/fsl_dma.h ****  * This function configures the transfer attribute including the source address,
 213:../drivers/fsl_dma.h ****  * destination address, transfer size, and so on.
 214:../drivers/fsl_dma.h ****  * This example shows how to set up the the dma_transfer_config_t
 215:../drivers/fsl_dma.h ****  * parameters and how to call the DMA_ConfigBasicTransfer function.
 216:../drivers/fsl_dma.h ****  * @code
 217:../drivers/fsl_dma.h ****  *   dma_transfer_config_t transferConfig;
 218:../drivers/fsl_dma.h ****  *   memset(&transferConfig, 0, sizeof(transferConfig));
 219:../drivers/fsl_dma.h ****  *   transferConfig.srcAddr = (uint32_t)srcAddr;
 220:../drivers/fsl_dma.h ****  *   transferConfig.destAddr = (uint32_t)destAddr;
 221:../drivers/fsl_dma.h ****  *   transferConfig.enbaleSrcIncrement = true;
 222:../drivers/fsl_dma.h ****  *   transferConfig.enableDestIncrement = true;
 223:../drivers/fsl_dma.h ****  *   transferConfig.srcSize = kDMA_Transfersize32bits;
 224:../drivers/fsl_dma.h ****  *   transferConfig.destSize = kDMA_Transfersize32bits;
 225:../drivers/fsl_dma.h ****  *   transferConfig.transferSize = sizeof(uint32_t) * BUFF_LENGTH;
 226:../drivers/fsl_dma.h ****  *   DMA_SetTransferConfig(DMA0, 0, &transferConfig);
 227:../drivers/fsl_dma.h ****  * @endcode
 228:../drivers/fsl_dma.h ****  *
 229:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 230:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 231:../drivers/fsl_dma.h ****  * @param config Pointer to the DMA transfer configuration structure.
 232:../drivers/fsl_dma.h ****  */
 233:../drivers/fsl_dma.h **** void DMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const dma_transfer_config_t *config);
 234:../drivers/fsl_dma.h **** 
 235:../drivers/fsl_dma.h **** /*!
 236:../drivers/fsl_dma.h ****  * @brief Configures the DMA channel link feature.
 237:../drivers/fsl_dma.h ****  *
 238:../drivers/fsl_dma.h ****  * This function allows DMA channels to have their transfers linked. The current DMA channel
 239:../drivers/fsl_dma.h ****  * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the channel link
 240:../drivers/fsl_dma.h ****  * type.
 241:../drivers/fsl_dma.h ****  * Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2
 242:../drivers/fsl_dma.h ****  * after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1AndChannel2.
 243:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after each cycle-steal transfer if the type is kDMA_ChannelLinkChannel1.
 244:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1Afte
 245:../drivers/fsl_dma.h ****  *
 246:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 247:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 248:../drivers/fsl_dma.h ****  * @param config Pointer to the channel link configuration structure.
 249:../drivers/fsl_dma.h ****  */
 250:../drivers/fsl_dma.h **** void DMA_SetChannelLinkConfig(DMA_Type *base, uint32_t channel, const dma_channel_link_config_t *co
 251:../drivers/fsl_dma.h **** 
 252:../drivers/fsl_dma.h **** /*!
 253:../drivers/fsl_dma.h ****  * @brief Sets the DMA source address for the DMA transfer.
 254:../drivers/fsl_dma.h ****  *
 255:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 256:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 257:../drivers/fsl_dma.h ****  * @param srcAddr DMA source address.
 258:../drivers/fsl_dma.h ****  */
 259:../drivers/fsl_dma.h **** static inline void DMA_SetSourceAddress(DMA_Type *base, uint32_t channel, uint32_t srcAddr)
 260:../drivers/fsl_dma.h **** {
 261:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 262:../drivers/fsl_dma.h **** 
 263:../drivers/fsl_dma.h ****     base->DMA[channel].SAR = srcAddr;
 529              		.loc 3 263 0
 530 0058 1033     		adds	r3, r3, #16
 531              	.LVL59:
 532 005a 1B01     		lsls	r3, r3, #4
 533              	.LVL60:
 534 005c 1568     		ldr	r5, [r2]
 535 005e 1D51     		str	r5, [r3, r4]
 536              	.LVL61:
 537              	.LBE35:
 538              	.LBE34:
 297:../drivers/fsl_sai_dma.c **** 
 539              		.loc 1 297 0
 540 0060 0C68     		ldr	r4, [r1]
 541 0062 2368     		ldr	r3, [r4]
 542 0064 2479     		ldrb	r4, [r4, #4]
 543 0066 5268     		ldr	r2, [r2, #4]
 544              	.LVL62:
 545              	.LBB36:
 546              	.LBB37:
 264:../drivers/fsl_dma.h **** }
 265:../drivers/fsl_dma.h **** 
 266:../drivers/fsl_dma.h **** /*!
 267:../drivers/fsl_dma.h ****  * @brief Sets the DMA destination address for the DMA transfer.
 268:../drivers/fsl_dma.h ****  *
 269:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 270:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 271:../drivers/fsl_dma.h ****  * @param destAddr DMA destination address.
 272:../drivers/fsl_dma.h ****  */
 273:../drivers/fsl_dma.h **** static inline void DMA_SetDestinationAddress(DMA_Type *base, uint32_t channel, uint32_t destAddr)
 274:../drivers/fsl_dma.h **** {
 275:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 276:../drivers/fsl_dma.h **** 
 277:../drivers/fsl_dma.h ****     base->DMA[channel].DAR = destAddr;
 278:../drivers/fsl_dma.h **** }
 279:../drivers/fsl_dma.h **** 
 280:../drivers/fsl_dma.h **** /*!
 281:../drivers/fsl_dma.h ****  * @brief Sets the DMA transfer size for the DMA transfer.
 282:../drivers/fsl_dma.h ****  *
 283:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 284:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 285:../drivers/fsl_dma.h ****  * @param size The number of bytes to be transferred.
 286:../drivers/fsl_dma.h ****  */
 287:../drivers/fsl_dma.h **** static inline void DMA_SetTransferSize(DMA_Type *base, uint32_t channel, uint32_t size)
 288:../drivers/fsl_dma.h **** {
 289:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 290:../drivers/fsl_dma.h **** 
 291:../drivers/fsl_dma.h ****     base->DMA[channel].DSR_BCR = DMA_DSR_BCR_BCR(size);
 547              		.loc 3 291 0
 548 0068 1202     		lsls	r2, r2, #8
 549              	.LVL63:
 550 006a 120A     		lsrs	r2, r2, #8
 551 006c 2401     		lsls	r4, r4, #4
 552              	.LVL64:
 553 006e 1B19     		adds	r3, r3, r4
 554              	.LVL65:
 555 0070 0933     		adds	r3, r3, #9
 556 0072 FF33     		adds	r3, r3, #255
 557 0074 1A60     		str	r2, [r3]
 558              	.LVL66:
 559              	.LBE37:
 560              	.LBE36:
 300:../drivers/fsl_sai_dma.c **** 
 561              		.loc 1 300 0
 562 0076 0123     		movs	r3, #1
 563 0078 8B60     		str	r3, [r1, #8]
 303:../drivers/fsl_sai_dma.c **** 
 564              		.loc 1 303 0
 565 007a 0A68     		ldr	r2, [r1]
 566              	.LVL67:
 567              	.LBB38:
 568              	.LBB39:
 292:../drivers/fsl_dma.h **** }
 293:../drivers/fsl_dma.h **** 
 294:../drivers/fsl_dma.h **** /*!
 295:../drivers/fsl_dma.h ****  * @brief Sets the DMA modulo for the DMA transfer.
 296:../drivers/fsl_dma.h ****  *
 297:../drivers/fsl_dma.h ****  * This function defines a specific address range specified to be the value after (SAR + SSIZE)/(DA
 298:../drivers/fsl_dma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 299:../drivers/fsl_dma.h ****  * data queue easily.
 300:../drivers/fsl_dma.h ****  *
 301:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 302:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 303:../drivers/fsl_dma.h ****  * @param srcModulo source address modulo.
 304:../drivers/fsl_dma.h ****  * @param destModulo destination address modulo.
 305:../drivers/fsl_dma.h ****  */
 306:../drivers/fsl_dma.h **** void DMA_SetModulo(DMA_Type *base, uint32_t channel, dma_modulo_t srcModulo, dma_modulo_t destModul
 307:../drivers/fsl_dma.h **** 
 308:../drivers/fsl_dma.h **** /*!
 309:../drivers/fsl_dma.h ****  * @brief Enables the DMA cycle steal for the DMA transfer.
 310:../drivers/fsl_dma.h ****  *
 311:../drivers/fsl_dma.h ****  * If the cycle steal feature is enabled (true), the DMA controller forces a single read/write tran
 312:../drivers/fsl_dma.h ****  *  or it continuously makes read/write transfers until the BCR decrements to 0.
 313:../drivers/fsl_dma.h ****  *
 314:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 315:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 316:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 317:../drivers/fsl_dma.h ****  */
 318:../drivers/fsl_dma.h **** static inline void DMA_EnableCycleSteal(DMA_Type *base, uint32_t channel, bool enable)
 319:../drivers/fsl_dma.h **** {
 320:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 321:../drivers/fsl_dma.h **** 
 322:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_CS_MASK)) | DMA_DCR_CS(enable);
 323:../drivers/fsl_dma.h **** }
 324:../drivers/fsl_dma.h **** 
 325:../drivers/fsl_dma.h **** /*!
 326:../drivers/fsl_dma.h ****  * @brief Enables the DMA auto align for the DMA transfer.
 327:../drivers/fsl_dma.h ****  *
 328:../drivers/fsl_dma.h ****  * If the auto align feature is enabled (true), the appropriate address register increments
 329:../drivers/fsl_dma.h ****  * regardless of DINC or SINC.
 330:../drivers/fsl_dma.h ****  *
 331:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 332:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 333:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 334:../drivers/fsl_dma.h ****  */
 335:../drivers/fsl_dma.h **** static inline void DMA_EnableAutoAlign(DMA_Type *base, uint32_t channel, bool enable)
 336:../drivers/fsl_dma.h **** {
 337:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 338:../drivers/fsl_dma.h **** 
 339:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_AA_MASK)) | DMA_DCR_AA(enable);
 340:../drivers/fsl_dma.h **** }
 341:../drivers/fsl_dma.h **** 
 342:../drivers/fsl_dma.h **** /*!
 343:../drivers/fsl_dma.h ****  * @brief Enables the DMA async request for the DMA transfer.
 344:../drivers/fsl_dma.h ****  *
 345:../drivers/fsl_dma.h ****  * If the async request feature is enabled (true), the DMA supports asynchronous DREQs
 346:../drivers/fsl_dma.h ****  * while the MCU is in stop mode.
 347:../drivers/fsl_dma.h ****  *
 348:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 349:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 350:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 351:../drivers/fsl_dma.h ****  */
 352:../drivers/fsl_dma.h **** static inline void DMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 353:../drivers/fsl_dma.h **** {
 354:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 355:../drivers/fsl_dma.h **** 
 356:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_EADREQ_MASK)) | DMA_DCR_EADREQ(ena
 357:../drivers/fsl_dma.h **** }
 358:../drivers/fsl_dma.h **** 
 359:../drivers/fsl_dma.h **** /*!
 360:../drivers/fsl_dma.h ****  * @brief Enables an interrupt for the DMA transfer.
 361:../drivers/fsl_dma.h ****  *
 362:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 363:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 364:../drivers/fsl_dma.h ****  */
 365:../drivers/fsl_dma.h **** static inline void DMA_EnableInterrupts(DMA_Type *base, uint32_t channel)
 366:../drivers/fsl_dma.h **** {
 367:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 368:../drivers/fsl_dma.h **** 
 369:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_EINT(true);
 370:../drivers/fsl_dma.h **** }
 371:../drivers/fsl_dma.h **** 
 372:../drivers/fsl_dma.h **** /*!
 373:../drivers/fsl_dma.h ****  * @brief Disables an interrupt for the DMA transfer.
 374:../drivers/fsl_dma.h ****  *
 375:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 376:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 377:../drivers/fsl_dma.h ****  */
 378:../drivers/fsl_dma.h **** static inline void DMA_DisableInterrupts(DMA_Type *base, uint32_t channel)
 379:../drivers/fsl_dma.h **** {
 380:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 381:../drivers/fsl_dma.h **** 
 382:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_EINT_MASK;
 383:../drivers/fsl_dma.h **** }
 384:../drivers/fsl_dma.h **** 
 385:../drivers/fsl_dma.h **** /* @} */
 386:../drivers/fsl_dma.h **** /*!
 387:../drivers/fsl_dma.h ****  * @name DMA Channel Transfer Operation
 388:../drivers/fsl_dma.h ****  * @{
 389:../drivers/fsl_dma.h ****  */
 390:../drivers/fsl_dma.h **** 
 391:../drivers/fsl_dma.h **** /*!
 392:../drivers/fsl_dma.h ****  * @brief Enables the DMA hardware channel request.
 393:../drivers/fsl_dma.h ****  *
 394:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 395:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 396:../drivers/fsl_dma.h ****  */
 397:../drivers/fsl_dma.h **** static inline void DMA_EnableChannelRequest(DMA_Type *base, uint32_t channel)
 398:../drivers/fsl_dma.h **** {
 399:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 400:../drivers/fsl_dma.h **** 
 401:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_ERQ_MASK;
 402:../drivers/fsl_dma.h **** }
 403:../drivers/fsl_dma.h **** 
 404:../drivers/fsl_dma.h **** /*!
 405:../drivers/fsl_dma.h ****  * @brief Disables the DMA hardware channel request.
 406:../drivers/fsl_dma.h ****  *
 407:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 408:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 409:../drivers/fsl_dma.h ****  */
 410:../drivers/fsl_dma.h **** static inline void DMA_DisableChannelRequest(DMA_Type *base, uint32_t channel)
 411:../drivers/fsl_dma.h **** {
 412:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 413:../drivers/fsl_dma.h **** 
 414:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_ERQ_MASK;
 415:../drivers/fsl_dma.h **** }
 416:../drivers/fsl_dma.h **** 
 417:../drivers/fsl_dma.h **** /*!
 418:../drivers/fsl_dma.h ****  * @brief Starts the DMA transfer with a software trigger.
 419:../drivers/fsl_dma.h ****  *
 420:../drivers/fsl_dma.h ****  * This function starts only one read/write iteration.
 421:../drivers/fsl_dma.h ****  *
 422:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 423:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 424:../drivers/fsl_dma.h ****  */
 425:../drivers/fsl_dma.h **** static inline void DMA_TriggerChannelStart(DMA_Type *base, uint32_t channel)
 426:../drivers/fsl_dma.h **** {
 427:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 428:../drivers/fsl_dma.h **** 
 429:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_START_MASK;
 430:../drivers/fsl_dma.h **** }
 431:../drivers/fsl_dma.h **** 
 432:../drivers/fsl_dma.h **** /* @} */
 433:../drivers/fsl_dma.h **** /*!
 434:../drivers/fsl_dma.h ****  * @name DMA Channel Status Operation
 435:../drivers/fsl_dma.h ****  * @{
 436:../drivers/fsl_dma.h ****  */
 437:../drivers/fsl_dma.h **** 
 438:../drivers/fsl_dma.h **** /*!
 439:../drivers/fsl_dma.h ****  * @brief Gets the remaining bytes of the current DMA transfer.
 440:../drivers/fsl_dma.h ****  *
 441:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 442:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 443:../drivers/fsl_dma.h ****  * @return The number of bytes which have not been transferred yet.
 444:../drivers/fsl_dma.h ****  */
 445:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetRemainingBytes(DMA_Type *base, uint32_t channel)
 446:../drivers/fsl_dma.h **** {
 447:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 448:../drivers/fsl_dma.h **** 
 449:../drivers/fsl_dma.h ****     return (base->DMA[channel].DSR_BCR & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT;
 450:../drivers/fsl_dma.h **** }
 451:../drivers/fsl_dma.h **** 
 452:../drivers/fsl_dma.h **** /*!
 453:../drivers/fsl_dma.h ****  * @brief Gets the DMA channel status flags.
 454:../drivers/fsl_dma.h ****  *
 455:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 456:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 457:../drivers/fsl_dma.h ****  * @return The mask of the channel status. Use the _dma_channel_status_flags
 458:../drivers/fsl_dma.h ****  *         type to decode the return 32 bit variables.
 459:../drivers/fsl_dma.h ****  */
 460:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetChannelStatusFlags(DMA_Type *base, uint32_t channel)
 461:../drivers/fsl_dma.h **** {
 462:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 463:../drivers/fsl_dma.h **** 
 464:../drivers/fsl_dma.h ****     return base->DMA[channel].DSR_BCR;
 465:../drivers/fsl_dma.h **** }
 466:../drivers/fsl_dma.h **** 
 467:../drivers/fsl_dma.h **** /*!
 468:../drivers/fsl_dma.h ****  * @brief Clears the DMA channel status flags.
 469:../drivers/fsl_dma.h ****  *
 470:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 471:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 472:../drivers/fsl_dma.h ****  * @param mask The mask of the channel status to be cleared. Use
 473:../drivers/fsl_dma.h ****  *             the defined _dma_channel_status_flags type.
 474:../drivers/fsl_dma.h ****  */
 475:../drivers/fsl_dma.h **** static inline void DMA_ClearChannelStatusFlags(DMA_Type *base, uint32_t channel, uint32_t mask)
 476:../drivers/fsl_dma.h **** {
 477:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 478:../drivers/fsl_dma.h **** 
 479:../drivers/fsl_dma.h ****     if (mask != 0U)
 480:../drivers/fsl_dma.h ****     {
 481:../drivers/fsl_dma.h ****         base->DMA[channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 482:../drivers/fsl_dma.h ****     }
 483:../drivers/fsl_dma.h **** }
 484:../drivers/fsl_dma.h **** 
 485:../drivers/fsl_dma.h **** /* @} */
 486:../drivers/fsl_dma.h **** /*!
 487:../drivers/fsl_dma.h ****  * @name DMA Channel Transactional Operation
 488:../drivers/fsl_dma.h ****  * @{
 489:../drivers/fsl_dma.h ****  */
 490:../drivers/fsl_dma.h **** 
 491:../drivers/fsl_dma.h **** /*!
 492:../drivers/fsl_dma.h ****  * @brief Creates the DMA handle.
 493:../drivers/fsl_dma.h ****  *
 494:../drivers/fsl_dma.h ****  * This function is called first if using the transactional API for the DMA. This function
 495:../drivers/fsl_dma.h ****  * initializes the internal state of the DMA handle.
 496:../drivers/fsl_dma.h ****  *
 497:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer. The DMA handle stores callback function and
 498:../drivers/fsl_dma.h ****  *               parameters.
 499:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 500:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 501:../drivers/fsl_dma.h ****  */
 502:../drivers/fsl_dma.h **** void DMA_CreateHandle(dma_handle_t *handle, DMA_Type *base, uint32_t channel);
 503:../drivers/fsl_dma.h **** 
 504:../drivers/fsl_dma.h **** /*!
 505:../drivers/fsl_dma.h ****  * @brief Sets the DMA callback function.
 506:../drivers/fsl_dma.h ****  *
 507:../drivers/fsl_dma.h ****  * This callback is called in the DMA IRQ handler. Use the callback to do something
 508:../drivers/fsl_dma.h ****  * after the current transfer complete.
 509:../drivers/fsl_dma.h ****  *
 510:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 511:../drivers/fsl_dma.h ****  * @param callback DMA callback function pointer.
 512:../drivers/fsl_dma.h ****  * @param userData Parameter for callback function. If it is not needed, just set to NULL.
 513:../drivers/fsl_dma.h ****  */
 514:../drivers/fsl_dma.h **** void DMA_SetCallback(dma_handle_t *handle, dma_callback callback, void *userData);
 515:../drivers/fsl_dma.h **** 
 516:../drivers/fsl_dma.h **** /*!
 517:../drivers/fsl_dma.h ****  * @brief Prepares the DMA transfer configuration structure.
 518:../drivers/fsl_dma.h ****  *
 519:../drivers/fsl_dma.h ****  * This function prepares the transfer configuration structure according to the user input.
 520:../drivers/fsl_dma.h ****  *
 521:../drivers/fsl_dma.h ****  * @param config Pointer to the user configuration structure of type dma_transfer_config_t.
 522:../drivers/fsl_dma.h ****  * @param srcAddr DMA transfer source address.
 523:../drivers/fsl_dma.h ****  * @param srcWidth DMA transfer source address width (byte).
 524:../drivers/fsl_dma.h ****  * @param destAddr DMA transfer destination address.
 525:../drivers/fsl_dma.h ****  * @param destWidth DMA transfer destination address width (byte).
 526:../drivers/fsl_dma.h ****  * @param transferBytes DMA transfer bytes to be transferred.
 527:../drivers/fsl_dma.h ****  * @param type DMA transfer type.
 528:../drivers/fsl_dma.h ****  */
 529:../drivers/fsl_dma.h **** void DMA_PrepareTransfer(dma_transfer_config_t *config,
 530:../drivers/fsl_dma.h ****                          void *srcAddr,
 531:../drivers/fsl_dma.h ****                          uint32_t srcWidth,
 532:../drivers/fsl_dma.h ****                          void *destAddr,
 533:../drivers/fsl_dma.h ****                          uint32_t destWidth,
 534:../drivers/fsl_dma.h ****                          uint32_t transferBytes,
 535:../drivers/fsl_dma.h ****                          dma_transfer_type_t type);
 536:../drivers/fsl_dma.h **** 
 537:../drivers/fsl_dma.h **** /*!
 538:../drivers/fsl_dma.h ****  * @brief Submits the DMA transfer request.
 539:../drivers/fsl_dma.h ****  *
 540:../drivers/fsl_dma.h ****  * This function submits the DMA transfer request according to the transfer configuration structure
 541:../drivers/fsl_dma.h ****  *
 542:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 543:../drivers/fsl_dma.h ****  * @param config Pointer to DMA transfer configuration structure.
 544:../drivers/fsl_dma.h ****  * @param options Additional configurations for transfer. Use
 545:../drivers/fsl_dma.h ****  *                the defined dma_transfer_options_t type.
 546:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA submit transfer request succeeded.
 547:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA is busy. Submit transfer request is not allow
 548:../drivers/fsl_dma.h ****  * @note This function can't process multi transfer request.
 549:../drivers/fsl_dma.h ****  */
 550:../drivers/fsl_dma.h **** status_t DMA_SubmitTransfer(dma_handle_t *handle, const dma_transfer_config_t *config, uint32_t opt
 551:../drivers/fsl_dma.h **** 
 552:../drivers/fsl_dma.h **** /*!
 553:../drivers/fsl_dma.h ****  * @brief DMA starts a transfer.
 554:../drivers/fsl_dma.h ****  *
 555:../drivers/fsl_dma.h ****  * This function enables the channel request. Call this function
 556:../drivers/fsl_dma.h ****  * after submitting a transfer request.
 557:../drivers/fsl_dma.h ****  *
 558:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 559:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA start transfer succeed.
 560:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA has started a transfer.
 561:../drivers/fsl_dma.h ****  */
 562:../drivers/fsl_dma.h **** static inline void DMA_StartTransfer(dma_handle_t *handle)
 563:../drivers/fsl_dma.h **** {
 564:../drivers/fsl_dma.h ****     assert(handle != NULL);
 565:../drivers/fsl_dma.h **** 
 566:../drivers/fsl_dma.h ****     handle->base->DMA[handle->channel].DCR |= DMA_DCR_ERQ_MASK;
 569              		.loc 3 566 0
 570 007c 1368     		ldr	r3, [r2]
 571 007e 1279     		ldrb	r2, [r2, #4]
 572              	.LVL68:
 573 0080 1201     		lsls	r2, r2, #4
 574 0082 9B18     		adds	r3, r3, r2
 575 0084 0D33     		adds	r3, r3, #13
 576 0086 FF33     		adds	r3, r3, #255
 577 0088 1968     		ldr	r1, [r3]
 578              	.LVL69:
 579 008a 8022     		movs	r2, #128
 580 008c D205     		lsls	r2, r2, #23
 581 008e 0A43     		orrs	r2, r1
 582 0090 1A60     		str	r2, [r3]
 583              	.LVL70:
 584              	.LBE39:
 585              	.LBE38:
 586              	.LBB40:
 587              	.LBB41:
 575:../drivers/fsl_sai.h ****     }
 588              		.loc 2 575 0
 589 0092 0368     		ldr	r3, [r0]
 590 0094 064A     		ldr	r2, .L25
 591 0096 1340     		ands	r3, r2
 592 0098 0222     		movs	r2, #2
 593 009a 1343     		orrs	r3, r2
 594 009c 0360     		str	r3, [r0]
 595              	.LVL71:
 596              	.LBE41:
 597              	.LBE40:
 311:../drivers/fsl_sai_dma.c **** 
 598              		.loc 1 311 0
 599 009e 0121     		movs	r1, #1
 600 00a0 FFF7FEFF 		bl	SAI_TxEnable
 601              	.LVL72:
 313:../drivers/fsl_sai_dma.c **** }
 602              		.loc 1 313 0
 603 00a4 0020     		movs	r0, #0
 604 00a6 BCE7     		b	.L19
 605              	.LVL73:
 606              	.L21:
 280:../drivers/fsl_sai_dma.c ****     }
 607              		.loc 1 280 0
 608 00a8 0420     		movs	r0, #4
 609              	.LVL74:
 610 00aa BAE7     		b	.L19
 611              	.LVL75:
 612              	.L22:
 613 00ac 0420     		movs	r0, #4
 614              	.LVL76:
 615 00ae B8E7     		b	.L19
 616              	.L26:
 617              		.align	2
 618              	.L25:
 619 00b0 FFFFE3FF 		.word	-1835009
 620              		.cfi_endproc
 621              	.LFE89:
 623              		.section	.text.SAI_TransferReceiveDMA,"ax",%progbits
 624              		.align	1
 625              		.global	SAI_TransferReceiveDMA
 626              		.syntax unified
 627              		.code	16
 628              		.thumb_func
 629              		.fpu softvfp
 631              	SAI_TransferReceiveDMA:
 632              	.LFB90:
 315:../drivers/fsl_sai_dma.c **** 
 316:../drivers/fsl_sai_dma.c **** status_t SAI_TransferReceiveDMA(I2S_Type *base, sai_dma_handle_t *handle, sai_transfer_t *xfer)
 317:../drivers/fsl_sai_dma.c **** {
 633              		.loc 1 317 0
 634              		.cfi_startproc
 635              		@ args = 0, pretend = 0, frame = 0
 636              		@ frame_needed = 0, uses_anonymous_args = 0
 637              	.LVL77:
 638 0000 70B5     		push	{r4, r5, r6, lr}
 639              		.cfi_def_cfa_offset 16
 640              		.cfi_offset 4, -16
 641              		.cfi_offset 5, -12
 642              		.cfi_offset 6, -8
 643              		.cfi_offset 14, -4
 318:../drivers/fsl_sai_dma.c ****     assert(handle && xfer);
 319:../drivers/fsl_sai_dma.c **** 
 320:../drivers/fsl_sai_dma.c ****     /* Check if input parameter invalid */
 321:../drivers/fsl_sai_dma.c ****     if ((xfer->data == NULL) || (xfer->dataSize == 0U))
 644              		.loc 1 321 0
 645 0002 1368     		ldr	r3, [r2]
 646 0004 002B     		cmp	r3, #0
 647 0006 51D0     		beq	.L29
 648              		.loc 1 321 0 is_stmt 0 discriminator 1
 649 0008 5468     		ldr	r4, [r2, #4]
 650 000a 002C     		cmp	r4, #0
 651 000c 50D0     		beq	.L30
 322:../drivers/fsl_sai_dma.c ****     {
 323:../drivers/fsl_sai_dma.c ****         return kStatus_InvalidArgument;
 324:../drivers/fsl_sai_dma.c ****     }
 325:../drivers/fsl_sai_dma.c **** 
 326:../drivers/fsl_sai_dma.c ****     if (handle->saiQueue[handle->queueUser].data)
 652              		.loc 1 326 0 is_stmt 1
 653 000e 4423     		movs	r3, #68
 654 0010 CB5C     		ldrb	r3, [r1, r3]
 655 0012 0233     		adds	r3, r3, #2
 656 0014 DB00     		lsls	r3, r3, #3
 657 0016 CB18     		adds	r3, r1, r3
 658 0018 5B68     		ldr	r3, [r3, #4]
 659 001a 002B     		cmp	r3, #0
 660 001c 02D0     		beq	.L32
 327:../drivers/fsl_sai_dma.c ****     {
 328:../drivers/fsl_sai_dma.c ****         return kStatus_SAI_QueueFull;
 661              		.loc 1 328 0
 662 001e EE20     		movs	r0, #238
 663              	.LVL78:
 664 0020 C000     		lsls	r0, r0, #3
 665              	.LVL79:
 666              	.L27:
 329:../drivers/fsl_sai_dma.c ****     }
 330:../drivers/fsl_sai_dma.c **** 
 331:../drivers/fsl_sai_dma.c ****     /* Add into queue */
 332:../drivers/fsl_sai_dma.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 333:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 334:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 335:../drivers/fsl_sai_dma.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 336:../drivers/fsl_sai_dma.c **** 
 337:../drivers/fsl_sai_dma.c ****     /* Set the source address */
 338:../drivers/fsl_sai_dma.c ****     DMA_SetDestinationAddress(handle->dmaHandle->base, handle->dmaHandle->channel, (uint32_t)(xfer-
 339:../drivers/fsl_sai_dma.c **** 
 340:../drivers/fsl_sai_dma.c ****     /* Set the transfer size */
 341:../drivers/fsl_sai_dma.c ****     DMA_SetTransferSize(handle->dmaHandle->base, handle->dmaHandle->channel, xfer->dataSize);
 342:../drivers/fsl_sai_dma.c **** 
 343:../drivers/fsl_sai_dma.c ****     /* Change the state of handle */
 344:../drivers/fsl_sai_dma.c ****     handle->state = kSAI_Busy;
 345:../drivers/fsl_sai_dma.c **** 
 346:../drivers/fsl_sai_dma.c ****     /* Start DMA transfer */
 347:../drivers/fsl_sai_dma.c ****     DMA_StartTransfer(handle->dmaHandle);
 348:../drivers/fsl_sai_dma.c **** 
 349:../drivers/fsl_sai_dma.c **** /* Enable DMA request and start SAI */
 350:../drivers/fsl_sai_dma.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 351:../drivers/fsl_sai_dma.c ****     SAI_RxEnableDMA(base, kSAI_FIFORequestDMAEnable, true);
 352:../drivers/fsl_sai_dma.c **** #else
 353:../drivers/fsl_sai_dma.c ****     SAI_RxEnableDMA(base, kSAI_FIFOWarningDMAEnable, true);
 354:../drivers/fsl_sai_dma.c **** #endif
 355:../drivers/fsl_sai_dma.c ****     SAI_RxEnable(base, true);
 356:../drivers/fsl_sai_dma.c **** 
 357:../drivers/fsl_sai_dma.c ****     return kStatus_Success;
 358:../drivers/fsl_sai_dma.c **** }
 667              		.loc 1 358 0
 668              		@ sp needed
 669 0022 70BD     		pop	{r4, r5, r6, pc}
 670              	.LVL80:
 671              	.L32:
 332:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].data = xfer->data;
 672              		.loc 1 332 0
 673 0024 4425     		movs	r5, #68
 674 0026 4B5D     		ldrb	r3, [r1, r5]
 675 0028 0C33     		adds	r3, r3, #12
 676 002a 9B00     		lsls	r3, r3, #2
 677 002c CB18     		adds	r3, r1, r3
 678 002e 5C60     		str	r4, [r3, #4]
 333:../drivers/fsl_sai_dma.c ****     handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;
 679              		.loc 1 333 0
 680 0030 4B5D     		ldrb	r3, [r1, r5]
 681 0032 0233     		adds	r3, r3, #2
 682 0034 DB00     		lsls	r3, r3, #3
 683 0036 CB18     		adds	r3, r1, r3
 684 0038 1468     		ldr	r4, [r2]
 685 003a 5C60     		str	r4, [r3, #4]
 334:../drivers/fsl_sai_dma.c ****     handle->queueUser = (handle->queueUser + 1) % SAI_XFER_QUEUE_SIZE;
 686              		.loc 1 334 0
 687 003c 4B5D     		ldrb	r3, [r1, r5]
 688 003e 0233     		adds	r3, r3, #2
 689 0040 DB00     		lsls	r3, r3, #3
 690 0042 CB18     		adds	r3, r1, r3
 691 0044 5468     		ldr	r4, [r2, #4]
 692 0046 9C60     		str	r4, [r3, #8]
 335:../drivers/fsl_sai_dma.c **** 
 693              		.loc 1 335 0
 694 0048 4C5D     		ldrb	r4, [r1, r5]
 695 004a 0134     		adds	r4, r4, #1
 696 004c 0323     		movs	r3, #3
 697 004e 2340     		ands	r3, r4
 698 0050 4B55     		strb	r3, [r1, r5]
 338:../drivers/fsl_sai_dma.c **** 
 699              		.loc 1 338 0
 700 0052 0B68     		ldr	r3, [r1]
 701 0054 1D68     		ldr	r5, [r3]
 702 0056 1B79     		ldrb	r3, [r3, #4]
 703              	.LVL81:
 704              	.LBB42:
 705              	.LBB43:
 277:../drivers/fsl_dma.h **** }
 706              		.loc 3 277 0
 707 0058 1033     		adds	r3, r3, #16
 708              	.LVL82:
 709 005a 1B01     		lsls	r3, r3, #4
 710              	.LVL83:
 711 005c EB18     		adds	r3, r5, r3
 712 005e 1468     		ldr	r4, [r2]
 713 0060 5C60     		str	r4, [r3, #4]
 714              	.LVL84:
 715              	.LBE43:
 716              	.LBE42:
 341:../drivers/fsl_sai_dma.c **** 
 717              		.loc 1 341 0
 718 0062 0C68     		ldr	r4, [r1]
 719 0064 2368     		ldr	r3, [r4]
 720 0066 2479     		ldrb	r4, [r4, #4]
 721 0068 5268     		ldr	r2, [r2, #4]
 722              	.LVL85:
 723              	.LBB44:
 724              	.LBB45:
 291:../drivers/fsl_dma.h **** }
 725              		.loc 3 291 0
 726 006a 1202     		lsls	r2, r2, #8
 727              	.LVL86:
 728 006c 120A     		lsrs	r2, r2, #8
 729 006e 2401     		lsls	r4, r4, #4
 730              	.LVL87:
 731 0070 1B19     		adds	r3, r3, r4
 732              	.LVL88:
 733 0072 0933     		adds	r3, r3, #9
 734 0074 FF33     		adds	r3, r3, #255
 735 0076 1A60     		str	r2, [r3]
 736              	.LVL89:
 737              	.LBE45:
 738              	.LBE44:
 344:../drivers/fsl_sai_dma.c **** 
 739              		.loc 1 344 0
 740 0078 0123     		movs	r3, #1
 741 007a 8B60     		str	r3, [r1, #8]
 347:../drivers/fsl_sai_dma.c **** 
 742              		.loc 1 347 0
 743 007c 0A68     		ldr	r2, [r1]
 744              	.LVL90:
 745              	.LBB46:
 746              	.LBB47:
 747              		.loc 3 566 0
 748 007e 1368     		ldr	r3, [r2]
 749 0080 1279     		ldrb	r2, [r2, #4]
 750              	.LVL91:
 751 0082 1201     		lsls	r2, r2, #4
 752 0084 9B18     		adds	r3, r3, r2
 753 0086 0D33     		adds	r3, r3, #13
 754 0088 FF33     		adds	r3, r3, #255
 755 008a 1968     		ldr	r1, [r3]
 756              	.LVL92:
 757 008c 8022     		movs	r2, #128
 758 008e D205     		lsls	r2, r2, #23
 759 0090 0A43     		orrs	r2, r1
 760 0092 1A60     		str	r2, [r3]
 761              	.LVL93:
 762              	.LBE47:
 763              	.LBE46:
 764              	.LBB48:
 765              	.LBB49:
 596:../drivers/fsl_sai.h ****     }
 766              		.loc 2 596 0
 767 0094 8022     		movs	r2, #128
 768 0096 8358     		ldr	r3, [r0, r2]
 769 0098 0649     		ldr	r1, .L33
 770 009a 0B40     		ands	r3, r1
 771 009c 0221     		movs	r1, #2
 772 009e 0B43     		orrs	r3, r1
 773 00a0 8350     		str	r3, [r0, r2]
 774              	.LVL94:
 775              	.LBE49:
 776              	.LBE48:
 355:../drivers/fsl_sai_dma.c **** 
 777              		.loc 1 355 0
 778 00a2 0139     		subs	r1, r1, #1
 779 00a4 FFF7FEFF 		bl	SAI_RxEnable
 780              	.LVL95:
 357:../drivers/fsl_sai_dma.c **** }
 781              		.loc 1 357 0
 782 00a8 0020     		movs	r0, #0
 783 00aa BAE7     		b	.L27
 784              	.LVL96:
 785              	.L29:
 323:../drivers/fsl_sai_dma.c ****     }
 786              		.loc 1 323 0
 787 00ac 0420     		movs	r0, #4
 788              	.LVL97:
 789 00ae B8E7     		b	.L27
 790              	.LVL98:
 791              	.L30:
 792 00b0 0420     		movs	r0, #4
 793              	.LVL99:
 794 00b2 B6E7     		b	.L27
 795              	.L34:
 796              		.align	2
 797              	.L33:
 798 00b4 FFFFE3FF 		.word	-1835009
 799              		.cfi_endproc
 800              	.LFE90:
 802              		.section	.text.SAI_TransferAbortSendDMA,"ax",%progbits
 803              		.align	1
 804              		.global	SAI_TransferAbortSendDMA
 805              		.syntax unified
 806              		.code	16
 807              		.thumb_func
 808              		.fpu softvfp
 810              	SAI_TransferAbortSendDMA:
 811              	.LFB91:
 359:../drivers/fsl_sai_dma.c **** 
 360:../drivers/fsl_sai_dma.c **** void SAI_TransferAbortSendDMA(I2S_Type *base, sai_dma_handle_t *handle)
 361:../drivers/fsl_sai_dma.c **** {
 812              		.loc 1 361 0
 813              		.cfi_startproc
 814              		@ args = 0, pretend = 0, frame = 0
 815              		@ frame_needed = 0, uses_anonymous_args = 0
 816              	.LVL100:
 817 0000 70B5     		push	{r4, r5, r6, lr}
 818              		.cfi_def_cfa_offset 16
 819              		.cfi_offset 4, -16
 820              		.cfi_offset 5, -12
 821              		.cfi_offset 6, -8
 822              		.cfi_offset 14, -4
 823 0002 0500     		movs	r5, r0
 824 0004 0C00     		movs	r4, r1
 362:../drivers/fsl_sai_dma.c ****     assert(handle);
 363:../drivers/fsl_sai_dma.c **** 
 364:../drivers/fsl_sai_dma.c ****     /* Disable dma */
 365:../drivers/fsl_sai_dma.c ****     DMA_AbortTransfer(handle->dmaHandle);
 825              		.loc 1 365 0
 826 0006 0868     		ldr	r0, [r1]
 827              	.LVL101:
 828 0008 FFF7FEFF 		bl	DMA_AbortTransfer
 829              	.LVL102:
 830              	.LBB50:
 831              	.LBB51:
 579:../drivers/fsl_sai.h ****     }
 832              		.loc 2 579 0
 833 000c 2B68     		ldr	r3, [r5]
 834 000e 0A4A     		ldr	r2, .L36
 835 0010 1340     		ands	r3, r2
 836 0012 2B60     		str	r3, [r5]
 837              	.LVL103:
 838              	.LBE51:
 839              	.LBE50:
 366:../drivers/fsl_sai_dma.c **** 
 367:../drivers/fsl_sai_dma.c **** /* Disable DMA enable bit */
 368:../drivers/fsl_sai_dma.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 369:../drivers/fsl_sai_dma.c ****     SAI_TxEnableDMA(base, kSAI_FIFORequestDMAEnable, false);
 370:../drivers/fsl_sai_dma.c **** #else
 371:../drivers/fsl_sai_dma.c ****     SAI_TxEnableDMA(base, kSAI_FIFOWarningDMAEnable, false);
 372:../drivers/fsl_sai_dma.c **** #endif
 373:../drivers/fsl_sai_dma.c **** 
 374:../drivers/fsl_sai_dma.c ****     /* Disable Tx */
 375:../drivers/fsl_sai_dma.c ****     SAI_TxEnable(base, false);
 840              		.loc 1 375 0
 841 0014 0021     		movs	r1, #0
 842 0016 2800     		movs	r0, r5
 843 0018 FFF7FEFF 		bl	SAI_TxEnable
 844              	.LVL104:
 376:../drivers/fsl_sai_dma.c **** 
 377:../drivers/fsl_sai_dma.c ****     /* Set the handle state */
 378:../drivers/fsl_sai_dma.c ****     handle->state = kSAI_Idle;
 845              		.loc 1 378 0
 846 001c 0025     		movs	r5, #0
 847              	.LVL105:
 848 001e A560     		str	r5, [r4, #8]
 379:../drivers/fsl_sai_dma.c **** 
 380:../drivers/fsl_sai_dma.c ****     /* Clear the queue */
 381:../drivers/fsl_sai_dma.c ****     memset(handle->saiQueue, 0, sizeof(sai_transfer_t) * SAI_XFER_QUEUE_SIZE);
 849              		.loc 1 381 0
 850 0020 2000     		movs	r0, r4
 851 0022 1430     		adds	r0, r0, #20
 852 0024 2022     		movs	r2, #32
 853 0026 0021     		movs	r1, #0
 854 0028 FFF7FEFF 		bl	memset
 855              	.LVL106:
 382:../drivers/fsl_sai_dma.c ****     handle->queueDriver = 0;
 856              		.loc 1 382 0
 857 002c 4523     		movs	r3, #69
 858 002e E554     		strb	r5, [r4, r3]
 383:../drivers/fsl_sai_dma.c ****     handle->queueUser = 0;
 859              		.loc 1 383 0
 860 0030 013B     		subs	r3, r3, #1
 861 0032 E554     		strb	r5, [r4, r3]
 384:../drivers/fsl_sai_dma.c **** }
 862              		.loc 1 384 0
 863              		@ sp needed
 864              	.LVL107:
 865 0034 70BD     		pop	{r4, r5, r6, pc}
 866              	.L37:
 867 0036 C046     		.align	2
 868              	.L36:
 869 0038 FDFFE3FF 		.word	-1835011
 870              		.cfi_endproc
 871              	.LFE91:
 873              		.section	.text.SAI_TxDMACallback,"ax",%progbits
 874              		.align	1
 875              		.syntax unified
 876              		.code	16
 877              		.thumb_func
 878              		.fpu softvfp
 880              	SAI_TxDMACallback:
 881              	.LFB83:
  86:../drivers/fsl_sai_dma.c ****     sai_dma_private_handle_t *privHandle = (sai_dma_private_handle_t *)userData;
 882              		.loc 1 86 0
 883              		.cfi_startproc
 884              		@ args = 0, pretend = 0, frame = 0
 885              		@ frame_needed = 0, uses_anonymous_args = 0
 886              	.LVL108:
 887 0000 70B5     		push	{r4, r5, r6, lr}
 888              		.cfi_def_cfa_offset 16
 889              		.cfi_offset 4, -16
 890              		.cfi_offset 5, -12
 891              		.cfi_offset 6, -8
 892              		.cfi_offset 14, -4
 893 0002 0D00     		movs	r5, r1
 894              	.LVL109:
  88:../drivers/fsl_sai_dma.c **** 
 895              		.loc 1 88 0
 896 0004 4C68     		ldr	r4, [r1, #4]
 897              	.LVL110:
  91:../drivers/fsl_sai_dma.c ****     saiHandle->queueDriver = (saiHandle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
 898              		.loc 1 91 0
 899 0006 4526     		movs	r6, #69
 900 0008 A05D     		ldrb	r0, [r4, r6]
 901              	.LVL111:
 902 000a 0230     		adds	r0, r0, #2
 903 000c C000     		lsls	r0, r0, #3
 904 000e 2018     		adds	r0, r4, r0
 905 0010 0430     		adds	r0, r0, #4
 906 0012 0822     		movs	r2, #8
 907 0014 0021     		movs	r1, #0
 908              	.LVL112:
 909 0016 FFF7FEFF 		bl	memset
 910              	.LVL113:
  92:../drivers/fsl_sai_dma.c **** 
 911              		.loc 1 92 0
 912 001a A25D     		ldrb	r2, [r4, r6]
 913 001c 0132     		adds	r2, r2, #1
 914 001e 0323     		movs	r3, #3
 915 0020 1340     		ands	r3, r2
 916 0022 A355     		strb	r3, [r4, r6]
  95:../drivers/fsl_sai_dma.c ****     {
 917              		.loc 1 95 0
 918 0024 E668     		ldr	r6, [r4, #12]
 919 0026 002E     		cmp	r6, #0
 920 0028 04D0     		beq	.L39
  97:../drivers/fsl_sai_dma.c ****     }
 921              		.loc 1 97 0
 922 002a 2369     		ldr	r3, [r4, #16]
 923 002c 084A     		ldr	r2, .L42
 924 002e 2100     		movs	r1, r4
 925 0030 2868     		ldr	r0, [r5]
 926 0032 B047     		blx	r6
 927              	.LVL114:
 928              	.L39:
 101:../drivers/fsl_sai_dma.c ****     {
 929              		.loc 1 101 0
 930 0034 4523     		movs	r3, #69
 931 0036 E35C     		ldrb	r3, [r4, r3]
 932 0038 0233     		adds	r3, r3, #2
 933 003a DB00     		lsls	r3, r3, #3
 934 003c E318     		adds	r3, r4, r3
 935 003e 5B68     		ldr	r3, [r3, #4]
 936 0040 002B     		cmp	r3, #0
 937 0042 00D0     		beq	.L41
 938              	.L38:
 105:../drivers/fsl_sai_dma.c **** 
 939              		.loc 1 105 0
 940              		@ sp needed
 941              	.LVL115:
 942              	.LVL116:
 943 0044 70BD     		pop	{r4, r5, r6, pc}
 944              	.LVL117:
 945              	.L41:
 103:../drivers/fsl_sai_dma.c ****     }
 946              		.loc 1 103 0
 947 0046 2868     		ldr	r0, [r5]
 948 0048 2100     		movs	r1, r4
 949 004a FFF7FEFF 		bl	SAI_TransferAbortSendDMA
 950              	.LVL118:
 105:../drivers/fsl_sai_dma.c **** 
 951              		.loc 1 105 0
 952 004e F9E7     		b	.L38
 953              	.L43:
 954              		.align	2
 955              	.L42:
 956 0050 71070000 		.word	1905
 957              		.cfi_endproc
 958              	.LFE83:
 960              		.section	.text.SAI_TransferAbortReceiveDMA,"ax",%progbits
 961              		.align	1
 962              		.global	SAI_TransferAbortReceiveDMA
 963              		.syntax unified
 964              		.code	16
 965              		.thumb_func
 966              		.fpu softvfp
 968              	SAI_TransferAbortReceiveDMA:
 969              	.LFB92:
 385:../drivers/fsl_sai_dma.c **** 
 386:../drivers/fsl_sai_dma.c **** void SAI_TransferAbortReceiveDMA(I2S_Type *base, sai_dma_handle_t *handle)
 387:../drivers/fsl_sai_dma.c **** {
 970              		.loc 1 387 0
 971              		.cfi_startproc
 972              		@ args = 0, pretend = 0, frame = 0
 973              		@ frame_needed = 0, uses_anonymous_args = 0
 974              	.LVL119:
 975 0000 70B5     		push	{r4, r5, r6, lr}
 976              		.cfi_def_cfa_offset 16
 977              		.cfi_offset 4, -16
 978              		.cfi_offset 5, -12
 979              		.cfi_offset 6, -8
 980              		.cfi_offset 14, -4
 981 0002 0500     		movs	r5, r0
 982 0004 0C00     		movs	r4, r1
 388:../drivers/fsl_sai_dma.c ****     assert(handle);
 389:../drivers/fsl_sai_dma.c **** 
 390:../drivers/fsl_sai_dma.c ****     /* Disable dma */
 391:../drivers/fsl_sai_dma.c ****     DMA_AbortTransfer(handle->dmaHandle);
 983              		.loc 1 391 0
 984 0006 0868     		ldr	r0, [r1]
 985              	.LVL120:
 986 0008 FFF7FEFF 		bl	DMA_AbortTransfer
 987              	.LVL121:
 988              	.LBB52:
 989              	.LBB53:
 600:../drivers/fsl_sai.h ****     }
 990              		.loc 2 600 0
 991 000c 8022     		movs	r2, #128
 992 000e AB58     		ldr	r3, [r5, r2]
 993 0010 0949     		ldr	r1, .L45
 994 0012 0B40     		ands	r3, r1
 995 0014 AB50     		str	r3, [r5, r2]
 996              	.LVL122:
 997              	.LBE53:
 998              	.LBE52:
 392:../drivers/fsl_sai_dma.c **** 
 393:../drivers/fsl_sai_dma.c **** /* Disable DMA enable bit */
 394:../drivers/fsl_sai_dma.c **** #if defined(FSL_FEATURE_SAI_FIFO_COUNT) && (FSL_FEATURE_SAI_FIFO_COUNT > 1)
 395:../drivers/fsl_sai_dma.c ****     SAI_RxEnableDMA(base, kSAI_FIFORequestDMAEnable, false);
 396:../drivers/fsl_sai_dma.c **** #else
 397:../drivers/fsl_sai_dma.c ****     SAI_RxEnableDMA(base, kSAI_FIFOWarningDMAEnable, false);
 398:../drivers/fsl_sai_dma.c **** #endif
 399:../drivers/fsl_sai_dma.c **** 
 400:../drivers/fsl_sai_dma.c ****     /* Disable Rx */
 401:../drivers/fsl_sai_dma.c ****     SAI_RxEnable(base, false);
 999              		.loc 1 401 0
 1000 0016 0021     		movs	r1, #0
 1001 0018 2800     		movs	r0, r5
 1002 001a FFF7FEFF 		bl	SAI_RxEnable
 1003              	.LVL123:
 402:../drivers/fsl_sai_dma.c **** 
 403:../drivers/fsl_sai_dma.c ****     /* Set the handle state */
 404:../drivers/fsl_sai_dma.c ****     handle->state = kSAI_Idle;
 1004              		.loc 1 404 0
 1005 001e 0025     		movs	r5, #0
 1006              	.LVL124:
 1007 0020 A560     		str	r5, [r4, #8]
 405:../drivers/fsl_sai_dma.c **** 
 406:../drivers/fsl_sai_dma.c ****     /* Clear the queue */
 407:../drivers/fsl_sai_dma.c ****     memset(handle->saiQueue, 0, sizeof(sai_transfer_t) * SAI_XFER_QUEUE_SIZE);
 1008              		.loc 1 407 0
 1009 0022 2000     		movs	r0, r4
 1010 0024 1430     		adds	r0, r0, #20
 1011 0026 2022     		movs	r2, #32
 1012 0028 0021     		movs	r1, #0
 1013 002a FFF7FEFF 		bl	memset
 1014              	.LVL125:
 408:../drivers/fsl_sai_dma.c ****     handle->queueDriver = 0;
 1015              		.loc 1 408 0
 1016 002e 4523     		movs	r3, #69
 1017 0030 E554     		strb	r5, [r4, r3]
 409:../drivers/fsl_sai_dma.c ****     handle->queueUser = 0;
 1018              		.loc 1 409 0
 1019 0032 013B     		subs	r3, r3, #1
 1020 0034 E554     		strb	r5, [r4, r3]
 410:../drivers/fsl_sai_dma.c **** }
 1021              		.loc 1 410 0
 1022              		@ sp needed
 1023              	.LVL126:
 1024 0036 70BD     		pop	{r4, r5, r6, pc}
 1025              	.L46:
 1026              		.align	2
 1027              	.L45:
 1028 0038 FDFFE3FF 		.word	-1835011
 1029              		.cfi_endproc
 1030              	.LFE92:
 1032              		.section	.text.SAI_RxDMACallback,"ax",%progbits
 1033              		.align	1
 1034              		.syntax unified
 1035              		.code	16
 1036              		.thumb_func
 1037              		.fpu softvfp
 1039              	SAI_RxDMACallback:
 1040              	.LFB84:
 108:../drivers/fsl_sai_dma.c ****     sai_dma_private_handle_t *privHandle = (sai_dma_private_handle_t *)userData;
 1041              		.loc 1 108 0
 1042              		.cfi_startproc
 1043              		@ args = 0, pretend = 0, frame = 0
 1044              		@ frame_needed = 0, uses_anonymous_args = 0
 1045              	.LVL127:
 1046 0000 70B5     		push	{r4, r5, r6, lr}
 1047              		.cfi_def_cfa_offset 16
 1048              		.cfi_offset 4, -16
 1049              		.cfi_offset 5, -12
 1050              		.cfi_offset 6, -8
 1051              		.cfi_offset 14, -4
 1052 0002 0D00     		movs	r5, r1
 1053              	.LVL128:
 110:../drivers/fsl_sai_dma.c **** 
 1054              		.loc 1 110 0
 1055 0004 4C68     		ldr	r4, [r1, #4]
 1056              	.LVL129:
 113:../drivers/fsl_sai_dma.c ****     saiHandle->queueDriver = (saiHandle->queueDriver + 1) % SAI_XFER_QUEUE_SIZE;
 1057              		.loc 1 113 0
 1058 0006 4526     		movs	r6, #69
 1059 0008 A05D     		ldrb	r0, [r4, r6]
 1060              	.LVL130:
 1061 000a 0230     		adds	r0, r0, #2
 1062 000c C000     		lsls	r0, r0, #3
 1063 000e 2018     		adds	r0, r4, r0
 1064 0010 0430     		adds	r0, r0, #4
 1065 0012 0822     		movs	r2, #8
 1066 0014 0021     		movs	r1, #0
 1067              	.LVL131:
 1068 0016 FFF7FEFF 		bl	memset
 1069              	.LVL132:
 114:../drivers/fsl_sai_dma.c **** 
 1070              		.loc 1 114 0
 1071 001a A25D     		ldrb	r2, [r4, r6]
 1072 001c 0132     		adds	r2, r2, #1
 1073 001e 0323     		movs	r3, #3
 1074 0020 1340     		ands	r3, r2
 1075 0022 A355     		strb	r3, [r4, r6]
 117:../drivers/fsl_sai_dma.c ****     {
 1076              		.loc 1 117 0
 1077 0024 E668     		ldr	r6, [r4, #12]
 1078 0026 002E     		cmp	r6, #0
 1079 0028 04D0     		beq	.L48
 119:../drivers/fsl_sai_dma.c ****     }
 1080              		.loc 1 119 0
 1081 002a 2369     		ldr	r3, [r4, #16]
 1082 002c 084A     		ldr	r2, .L51
 1083 002e 2100     		movs	r1, r4
 1084 0030 2868     		ldr	r0, [r5]
 1085 0032 B047     		blx	r6
 1086              	.LVL133:
 1087              	.L48:
 123:../drivers/fsl_sai_dma.c ****     {
 1088              		.loc 1 123 0
 1089 0034 4523     		movs	r3, #69
 1090 0036 E35C     		ldrb	r3, [r4, r3]
 1091 0038 0233     		adds	r3, r3, #2
 1092 003a DB00     		lsls	r3, r3, #3
 1093 003c E318     		adds	r3, r4, r3
 1094 003e 5B68     		ldr	r3, [r3, #4]
 1095 0040 002B     		cmp	r3, #0
 1096 0042 00D0     		beq	.L50
 1097              	.L47:
 127:../drivers/fsl_sai_dma.c **** 
 1098              		.loc 1 127 0
 1099              		@ sp needed
 1100              	.LVL134:
 1101              	.LVL135:
 1102 0044 70BD     		pop	{r4, r5, r6, pc}
 1103              	.LVL136:
 1104              	.L50:
 125:../drivers/fsl_sai_dma.c ****     }
 1105              		.loc 1 125 0
 1106 0046 2868     		ldr	r0, [r5]
 1107 0048 2100     		movs	r1, r4
 1108 004a FFF7FEFF 		bl	SAI_TransferAbortReceiveDMA
 1109              	.LVL137:
 127:../drivers/fsl_sai_dma.c **** 
 1110              		.loc 1 127 0
 1111 004e F9E7     		b	.L47
 1112              	.L52:
 1113              		.align	2
 1114              	.L51:
 1115 0050 72070000 		.word	1906
 1116              		.cfi_endproc
 1117              	.LFE84:
 1119              		.section	.text.SAI_TransferGetSendCountDMA,"ax",%progbits
 1120              		.align	1
 1121              		.global	SAI_TransferGetSendCountDMA
 1122              		.syntax unified
 1123              		.code	16
 1124              		.thumb_func
 1125              		.fpu softvfp
 1127              	SAI_TransferGetSendCountDMA:
 1128              	.LFB93:
 411:../drivers/fsl_sai_dma.c **** 
 412:../drivers/fsl_sai_dma.c **** status_t SAI_TransferGetSendCountDMA(I2S_Type *base, sai_dma_handle_t *handle, size_t *count)
 413:../drivers/fsl_sai_dma.c **** {
 1129              		.loc 1 413 0
 1130              		.cfi_startproc
 1131              		@ args = 0, pretend = 0, frame = 0
 1132              		@ frame_needed = 0, uses_anonymous_args = 0
 1133              		@ link register save eliminated.
 1134              	.LVL138:
 414:../drivers/fsl_sai_dma.c ****     assert(handle);
 415:../drivers/fsl_sai_dma.c **** 
 416:../drivers/fsl_sai_dma.c ****     status_t status = kStatus_Success;
 417:../drivers/fsl_sai_dma.c **** 
 418:../drivers/fsl_sai_dma.c ****     if (handle->state != kSAI_Busy)
 1135              		.loc 1 418 0
 1136 0000 8B68     		ldr	r3, [r1, #8]
 1137 0002 012B     		cmp	r3, #1
 1138 0004 13D1     		bne	.L55
 419:../drivers/fsl_sai_dma.c ****     {
 420:../drivers/fsl_sai_dma.c ****         status = kStatus_NoTransferInProgress;
 421:../drivers/fsl_sai_dma.c ****     }
 422:../drivers/fsl_sai_dma.c ****     else
 423:../drivers/fsl_sai_dma.c ****     {
 424:../drivers/fsl_sai_dma.c ****         *count = handle->transferSize[handle->queueDriver] -
 1139              		.loc 1 424 0
 1140 0006 4433     		adds	r3, r3, #68
 1141 0008 CB5C     		ldrb	r3, [r1, r3]
 1142 000a 0C33     		adds	r3, r3, #12
 1143 000c 9B00     		lsls	r3, r3, #2
 1144 000e CB18     		adds	r3, r1, r3
 1145 0010 5868     		ldr	r0, [r3, #4]
 1146              	.LVL139:
 425:../drivers/fsl_sai_dma.c ****                  DMA_GetRemainingBytes(handle->dmaHandle->base, handle->dmaHandle->channel);
 1147              		.loc 1 425 0
 1148 0012 0B68     		ldr	r3, [r1]
 1149 0014 1968     		ldr	r1, [r3]
 1150              	.LVL140:
 1151 0016 1B79     		ldrb	r3, [r3, #4]
 1152              	.LVL141:
 1153              	.LBB54:
 1154              	.LBB55:
 449:../drivers/fsl_dma.h **** }
 1155              		.loc 3 449 0
 1156 0018 1B01     		lsls	r3, r3, #4
 1157              	.LVL142:
 1158 001a C918     		adds	r1, r1, r3
 1159              	.LVL143:
 1160 001c 0931     		adds	r1, r1, #9
 1161 001e FF31     		adds	r1, r1, #255
 1162 0020 0B68     		ldr	r3, [r1]
 1163 0022 1B02     		lsls	r3, r3, #8
 1164 0024 1B0A     		lsrs	r3, r3, #8
 1165              	.LVL144:
 1166              	.LBE55:
 1167              	.LBE54:
 424:../drivers/fsl_sai_dma.c ****                  DMA_GetRemainingBytes(handle->dmaHandle->base, handle->dmaHandle->channel);
 1168              		.loc 1 424 0
 1169 0026 C31A     		subs	r3, r0, r3
 1170 0028 1360     		str	r3, [r2]
 416:../drivers/fsl_sai_dma.c **** 
 1171              		.loc 1 416 0
 1172 002a 0020     		movs	r0, #0
 1173              	.LVL145:
 1174              	.L53:
 426:../drivers/fsl_sai_dma.c ****     }
 427:../drivers/fsl_sai_dma.c **** 
 428:../drivers/fsl_sai_dma.c ****     return status;
 429:../drivers/fsl_sai_dma.c **** }
 1175              		.loc 1 429 0
 1176              		@ sp needed
 1177 002c 7047     		bx	lr
 1178              	.LVL146:
 1179              	.L55:
 420:../drivers/fsl_sai_dma.c ****     }
 1180              		.loc 1 420 0
 1181 002e 0620     		movs	r0, #6
 1182              	.LVL147:
 428:../drivers/fsl_sai_dma.c **** }
 1183              		.loc 1 428 0
 1184 0030 FCE7     		b	.L53
 1185              		.cfi_endproc
 1186              	.LFE93:
 1188              		.section	.text.SAI_TransferGetReceiveCountDMA,"ax",%progbits
 1189              		.align	1
 1190              		.global	SAI_TransferGetReceiveCountDMA
 1191              		.syntax unified
 1192              		.code	16
 1193              		.thumb_func
 1194              		.fpu softvfp
 1196              	SAI_TransferGetReceiveCountDMA:
 1197              	.LFB94:
 430:../drivers/fsl_sai_dma.c **** 
 431:../drivers/fsl_sai_dma.c **** status_t SAI_TransferGetReceiveCountDMA(I2S_Type *base, sai_dma_handle_t *handle, size_t *count)
 432:../drivers/fsl_sai_dma.c **** {
 1198              		.loc 1 432 0
 1199              		.cfi_startproc
 1200              		@ args = 0, pretend = 0, frame = 0
 1201              		@ frame_needed = 0, uses_anonymous_args = 0
 1202              		@ link register save eliminated.
 1203              	.LVL148:
 433:../drivers/fsl_sai_dma.c ****     assert(handle);
 434:../drivers/fsl_sai_dma.c **** 
 435:../drivers/fsl_sai_dma.c ****     status_t status = kStatus_Success;
 436:../drivers/fsl_sai_dma.c **** 
 437:../drivers/fsl_sai_dma.c ****     if (handle->state != kSAI_Busy)
 1204              		.loc 1 437 0
 1205 0000 8B68     		ldr	r3, [r1, #8]
 1206 0002 012B     		cmp	r3, #1
 1207 0004 13D1     		bne	.L58
 438:../drivers/fsl_sai_dma.c ****     {
 439:../drivers/fsl_sai_dma.c ****         status = kStatus_NoTransferInProgress;
 440:../drivers/fsl_sai_dma.c ****     }
 441:../drivers/fsl_sai_dma.c ****     else
 442:../drivers/fsl_sai_dma.c ****     {
 443:../drivers/fsl_sai_dma.c ****         *count = handle->transferSize[handle->queueDriver] -
 1208              		.loc 1 443 0
 1209 0006 4433     		adds	r3, r3, #68
 1210 0008 CB5C     		ldrb	r3, [r1, r3]
 1211 000a 0C33     		adds	r3, r3, #12
 1212 000c 9B00     		lsls	r3, r3, #2
 1213 000e CB18     		adds	r3, r1, r3
 1214 0010 5868     		ldr	r0, [r3, #4]
 1215              	.LVL149:
 444:../drivers/fsl_sai_dma.c ****                  DMA_GetRemainingBytes(handle->dmaHandle->base, handle->dmaHandle->channel);
 1216              		.loc 1 444 0
 1217 0012 0B68     		ldr	r3, [r1]
 1218 0014 1968     		ldr	r1, [r3]
 1219              	.LVL150:
 1220 0016 1B79     		ldrb	r3, [r3, #4]
 1221              	.LVL151:
 1222              	.LBB56:
 1223              	.LBB57:
 449:../drivers/fsl_dma.h **** }
 1224              		.loc 3 449 0
 1225 0018 1B01     		lsls	r3, r3, #4
 1226              	.LVL152:
 1227 001a C918     		adds	r1, r1, r3
 1228              	.LVL153:
 1229 001c 0931     		adds	r1, r1, #9
 1230 001e FF31     		adds	r1, r1, #255
 1231 0020 0B68     		ldr	r3, [r1]
 1232 0022 1B02     		lsls	r3, r3, #8
 1233 0024 1B0A     		lsrs	r3, r3, #8
 1234              	.LVL154:
 1235              	.LBE57:
 1236              	.LBE56:
 443:../drivers/fsl_sai_dma.c ****                  DMA_GetRemainingBytes(handle->dmaHandle->base, handle->dmaHandle->channel);
 1237              		.loc 1 443 0
 1238 0026 C31A     		subs	r3, r0, r3
 1239 0028 1360     		str	r3, [r2]
 435:../drivers/fsl_sai_dma.c **** 
 1240              		.loc 1 435 0
 1241 002a 0020     		movs	r0, #0
 1242              	.LVL155:
 1243              	.L56:
 445:../drivers/fsl_sai_dma.c ****     }
 446:../drivers/fsl_sai_dma.c **** 
 447:../drivers/fsl_sai_dma.c ****     return status;
 448:../drivers/fsl_sai_dma.c **** }
 1244              		.loc 1 448 0
 1245              		@ sp needed
 1246 002c 7047     		bx	lr
 1247              	.LVL156:
 1248              	.L58:
 439:../drivers/fsl_sai_dma.c ****     }
 1249              		.loc 1 439 0
 1250 002e 0620     		movs	r0, #6
 1251              	.LVL157:
 447:../drivers/fsl_sai_dma.c **** }
 1252              		.loc 1 447 0
 1253 0030 FCE7     		b	.L56
 1254              		.cfi_endproc
 1255              	.LFE94:
 1257              		.section	.bss.s_dmaPrivateHandle,"aw",%nobits
 1258              		.align	2
 1259              		.set	.LANCHOR0,. + 0
 1262              	s_dmaPrivateHandle:
 1263 0000 00000000 		.space	16
 1263      00000000 
 1263      00000000 
 1263      00000000 
 1264              		.text
 1265              	.Letext0:
 1266              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1267              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1268              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1269              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1270              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1271              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1272              		.file 10 "../CMSIS/system_MKL17Z4.h"
 1273              		.file 11 "../CMSIS/MKL17Z4.h"
 1274              		.file 12 "../drivers/fsl_common.h"
 1275              		.file 13 "../drivers/fsl_clock.h"
 1276              		.file 14 "../drivers/fsl_sai_dma.h"
 1277              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_sai_dma.c
     /tmp/ccM8AAyt.s:16     .text.SAI_TransferTxCreateHandleDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:23     .text.SAI_TransferTxCreateHandleDMA:0000000000000000 SAI_TransferTxCreateHandleDMA
     /tmp/ccM8AAyt.s:97     .text.SAI_TransferTxCreateHandleDMA:000000000000004c $d
     /tmp/ccM8AAyt.s:880    .text.SAI_TxDMACallback:0000000000000000 SAI_TxDMACallback
     /tmp/ccM8AAyt.s:103    .text.SAI_TransferRxCreateHandleDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:110    .text.SAI_TransferRxCreateHandleDMA:0000000000000000 SAI_TransferRxCreateHandleDMA
     /tmp/ccM8AAyt.s:187    .text.SAI_TransferRxCreateHandleDMA:0000000000000054 $d
     /tmp/ccM8AAyt.s:1039   .text.SAI_RxDMACallback:0000000000000000 SAI_RxDMACallback
     /tmp/ccM8AAyt.s:193    .text.SAI_TransferTxSetFormatDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:200    .text.SAI_TransferTxSetFormatDMA:0000000000000000 SAI_TransferTxSetFormatDMA
     /tmp/ccM8AAyt.s:320    .text.SAI_TransferRxSetFormatDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:327    .text.SAI_TransferRxSetFormatDMA:0000000000000000 SAI_TransferRxSetFormatDMA
     /tmp/ccM8AAyt.s:446    .text.SAI_TransferSendDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:453    .text.SAI_TransferSendDMA:0000000000000000 SAI_TransferSendDMA
     /tmp/ccM8AAyt.s:619    .text.SAI_TransferSendDMA:00000000000000b0 $d
     /tmp/ccM8AAyt.s:624    .text.SAI_TransferReceiveDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:631    .text.SAI_TransferReceiveDMA:0000000000000000 SAI_TransferReceiveDMA
     /tmp/ccM8AAyt.s:798    .text.SAI_TransferReceiveDMA:00000000000000b4 $d
     /tmp/ccM8AAyt.s:803    .text.SAI_TransferAbortSendDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:810    .text.SAI_TransferAbortSendDMA:0000000000000000 SAI_TransferAbortSendDMA
     /tmp/ccM8AAyt.s:869    .text.SAI_TransferAbortSendDMA:0000000000000038 $d
     /tmp/ccM8AAyt.s:874    .text.SAI_TxDMACallback:0000000000000000 $t
     /tmp/ccM8AAyt.s:956    .text.SAI_TxDMACallback:0000000000000050 $d
     /tmp/ccM8AAyt.s:961    .text.SAI_TransferAbortReceiveDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:968    .text.SAI_TransferAbortReceiveDMA:0000000000000000 SAI_TransferAbortReceiveDMA
     /tmp/ccM8AAyt.s:1028   .text.SAI_TransferAbortReceiveDMA:0000000000000038 $d
     /tmp/ccM8AAyt.s:1033   .text.SAI_RxDMACallback:0000000000000000 $t
     /tmp/ccM8AAyt.s:1115   .text.SAI_RxDMACallback:0000000000000050 $d
     /tmp/ccM8AAyt.s:1120   .text.SAI_TransferGetSendCountDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:1127   .text.SAI_TransferGetSendCountDMA:0000000000000000 SAI_TransferGetSendCountDMA
     /tmp/ccM8AAyt.s:1189   .text.SAI_TransferGetReceiveCountDMA:0000000000000000 $t
     /tmp/ccM8AAyt.s:1196   .text.SAI_TransferGetReceiveCountDMA:0000000000000000 SAI_TransferGetReceiveCountDMA
     /tmp/ccM8AAyt.s:1258   .bss.s_dmaPrivateHandle:0000000000000000 $d
     /tmp/ccM8AAyt.s:1262   .bss.s_dmaPrivateHandle:0000000000000000 s_dmaPrivateHandle

UNDEFINED SYMBOLS
SAI_GetInstance
memset
DMA_SetCallback
SAI_TxSetFormat
DMA_SubmitTransfer
SAI_RxSetFormat
SAI_TxEnable
SAI_RxEnable
DMA_AbortTransfer
