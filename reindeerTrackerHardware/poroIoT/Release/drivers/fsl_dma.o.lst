   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_dma.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.DMA_GetInstance,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	DMA_GetInstance:
  23              	.LFB69:
  24              		.file 1 "../drivers/fsl_dma.c"
   1:../drivers/fsl_dma.c **** /*
   2:../drivers/fsl_dma.c ****  * The Clear BSD License
   3:../drivers/fsl_dma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dma.c ****  * All rights reserved.
   6:../drivers/fsl_dma.c ****  *
   7:../drivers/fsl_dma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dma.c ****  * that the following conditions are met:
  10:../drivers/fsl_dma.c ****  *
  11:../drivers/fsl_dma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dma.c ****  *
  14:../drivers/fsl_dma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dma.c ****  *
  18:../drivers/fsl_dma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_dma.c ****  *
  22:../drivers/fsl_dma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dma.c ****  */
  34:../drivers/fsl_dma.c **** 
  35:../drivers/fsl_dma.c **** #include "fsl_dma.h"
  36:../drivers/fsl_dma.c **** 
  37:../drivers/fsl_dma.c **** /*******************************************************************************
  38:../drivers/fsl_dma.c ****  * Definitions
  39:../drivers/fsl_dma.c ****  ******************************************************************************/
  40:../drivers/fsl_dma.c **** 
  41:../drivers/fsl_dma.c **** /*******************************************************************************
  42:../drivers/fsl_dma.c ****  * Prototypes
  43:../drivers/fsl_dma.c ****  ******************************************************************************/
  44:../drivers/fsl_dma.c **** 
  45:../drivers/fsl_dma.c **** /*!
  46:../drivers/fsl_dma.c ****  * @brief Get instance number for DMA.
  47:../drivers/fsl_dma.c ****  *
  48:../drivers/fsl_dma.c ****  * @param base DMA peripheral base address.
  49:../drivers/fsl_dma.c ****  */
  50:../drivers/fsl_dma.c **** static uint32_t DMA_GetInstance(DMA_Type *base);
  51:../drivers/fsl_dma.c **** 
  52:../drivers/fsl_dma.c **** /*******************************************************************************
  53:../drivers/fsl_dma.c ****  * Variables
  54:../drivers/fsl_dma.c ****  ******************************************************************************/
  55:../drivers/fsl_dma.c **** 
  56:../drivers/fsl_dma.c **** /*! @brief Array to map DMA instance number to base pointer. */
  57:../drivers/fsl_dma.c **** static DMA_Type *const s_dmaBases[] = DMA_BASE_PTRS;
  58:../drivers/fsl_dma.c **** 
  59:../drivers/fsl_dma.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  60:../drivers/fsl_dma.c **** /*! @brief Array to map DMA instance number to clock name. */
  61:../drivers/fsl_dma.c **** static const clock_ip_name_t s_dmaClockName[] = DMA_CLOCKS;
  62:../drivers/fsl_dma.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  63:../drivers/fsl_dma.c **** 
  64:../drivers/fsl_dma.c **** /*! @brief Array to map DMA instance number to IRQ number. */
  65:../drivers/fsl_dma.c **** static const IRQn_Type s_dmaIRQNumber[][FSL_FEATURE_DMA_MODULE_CHANNEL] = DMA_CHN_IRQS;
  66:../drivers/fsl_dma.c **** 
  67:../drivers/fsl_dma.c **** /*! @brief Pointers to transfer handle for each DMA channel. */
  68:../drivers/fsl_dma.c **** static dma_handle_t *s_DMAHandle[FSL_FEATURE_DMA_MODULE_CHANNEL * FSL_FEATURE_SOC_DMA_COUNT];
  69:../drivers/fsl_dma.c **** 
  70:../drivers/fsl_dma.c **** /*******************************************************************************
  71:../drivers/fsl_dma.c ****  * Code
  72:../drivers/fsl_dma.c ****  ******************************************************************************/
  73:../drivers/fsl_dma.c **** static uint32_t DMA_GetInstance(DMA_Type *base)
  74:../drivers/fsl_dma.c **** {
  25              		.loc 1 74 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
  75:../drivers/fsl_dma.c ****     uint32_t instance;
  76:../drivers/fsl_dma.c **** 
  77:../drivers/fsl_dma.c ****     /* Find the instance index from base address mappings. */
  78:../drivers/fsl_dma.c ****     for (instance = 0; instance < ARRAY_SIZE(s_dmaBases); instance++)
  31              		.loc 1 78 0
  32 0000 0023     		movs	r3, #0
  33              	.LVL1:
  34              	.L2:
  35              		.loc 1 78 0 is_stmt 0 discriminator 1
  36 0002 002B     		cmp	r3, #0
  37 0004 01D0     		beq	.L4
  38              	.L1:
  79:../drivers/fsl_dma.c ****     {
  80:../drivers/fsl_dma.c ****         if (s_dmaBases[instance] == base)
  81:../drivers/fsl_dma.c ****         {
  82:../drivers/fsl_dma.c ****             break;
  83:../drivers/fsl_dma.c ****         }
  84:../drivers/fsl_dma.c ****     }
  85:../drivers/fsl_dma.c **** 
  86:../drivers/fsl_dma.c ****     assert(instance < ARRAY_SIZE(s_dmaBases));
  87:../drivers/fsl_dma.c **** 
  88:../drivers/fsl_dma.c ****     return instance;
  89:../drivers/fsl_dma.c **** }
  39              		.loc 1 89 0 is_stmt 1
  40 0006 1800     		movs	r0, r3
  41              	.LVL2:
  42              		@ sp needed
  43 0008 7047     		bx	lr
  44              	.LVL3:
  45              	.L4:
  80:../drivers/fsl_dma.c ****         {
  46              		.loc 1 80 0
  47 000a 024A     		ldr	r2, .L5
  48 000c 9042     		cmp	r0, r2
  49 000e FAD0     		beq	.L1
  78:../drivers/fsl_dma.c ****     {
  50              		.loc 1 78 0 discriminator 2
  51 0010 0133     		adds	r3, r3, #1
  52              	.LVL4:
  53 0012 F6E7     		b	.L2
  54              	.L6:
  55              		.align	2
  56              	.L5:
  57 0014 00800040 		.word	1073774592
  58              		.cfi_endproc
  59              	.LFE69:
  61              		.section	.text.DMA_Init,"ax",%progbits
  62              		.align	1
  63              		.global	DMA_Init
  64              		.syntax unified
  65              		.code	16
  66              		.thumb_func
  67              		.fpu softvfp
  69              	DMA_Init:
  70              	.LFB70:
  90:../drivers/fsl_dma.c **** 
  91:../drivers/fsl_dma.c **** void DMA_Init(DMA_Type *base)
  92:../drivers/fsl_dma.c **** {
  71              		.loc 1 92 0
  72              		.cfi_startproc
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              	.LVL5:
  76 0000 10B5     		push	{r4, lr}
  77              		.cfi_def_cfa_offset 8
  78              		.cfi_offset 4, -8
  79              		.cfi_offset 14, -4
  93:../drivers/fsl_dma.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  94:../drivers/fsl_dma.c ****     CLOCK_EnableClock(s_dmaClockName[DMA_GetInstance(base)]);
  80              		.loc 1 94 0
  81 0002 FFF7FEFF 		bl	DMA_GetInstance
  82              	.LVL6:
  83              	.LBB16:
  84              	.LBB17:
  85              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
  86              		.loc 2 450 0
  87 0006 034A     		ldr	r2, .L8
  88 0008 1168     		ldr	r1, [r2]
  89 000a 8023     		movs	r3, #128
  90 000c 5B00     		lsls	r3, r3, #1
  91 000e 0B43     		orrs	r3, r1
  92 0010 1360     		str	r3, [r2]
  93              	.LVL7:
  94              	.LBE17:
  95              	.LBE16:
  95:../drivers/fsl_dma.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  96:../drivers/fsl_dma.c **** }
  96              		.loc 1 96 0
  97              		@ sp needed
  98 0012 10BD     		pop	{r4, pc}
  99              	.L9:
 100              		.align	2
 101              	.L8:
 102 0014 40800440 		.word	1074036800
 103              		.cfi_endproc
 104              	.LFE70:
 106              		.section	.text.DMA_Deinit,"ax",%progbits
 107              		.align	1
 108              		.global	DMA_Deinit
 109              		.syntax unified
 110              		.code	16
 111              		.thumb_func
 112              		.fpu softvfp
 114              	DMA_Deinit:
 115              	.LFB71:
  97:../drivers/fsl_dma.c **** 
  98:../drivers/fsl_dma.c **** void DMA_Deinit(DMA_Type *base)
  99:../drivers/fsl_dma.c **** {
 116              		.loc 1 99 0
 117              		.cfi_startproc
 118              		@ args = 0, pretend = 0, frame = 0
 119              		@ frame_needed = 0, uses_anonymous_args = 0
 120              	.LVL8:
 121 0000 10B5     		push	{r4, lr}
 122              		.cfi_def_cfa_offset 8
 123              		.cfi_offset 4, -8
 124              		.cfi_offset 14, -4
 100:../drivers/fsl_dma.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 101:../drivers/fsl_dma.c ****     CLOCK_DisableClock(s_dmaClockName[DMA_GetInstance(base)]);
 125              		.loc 1 101 0
 126 0002 FFF7FEFF 		bl	DMA_GetInstance
 127              	.LVL9:
 128              	.LBB18:
 129              	.LBB19:
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 130              		.loc 2 461 0
 131 0006 034A     		ldr	r2, .L11
 132 0008 1368     		ldr	r3, [r2]
 133 000a 0349     		ldr	r1, .L11+4
 134 000c 0B40     		ands	r3, r1
 135 000e 1360     		str	r3, [r2]
 136              	.LVL10:
 137              	.LBE19:
 138              	.LBE18:
 102:../drivers/fsl_dma.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 103:../drivers/fsl_dma.c **** }
 139              		.loc 1 103 0
 140              		@ sp needed
 141 0010 10BD     		pop	{r4, pc}
 142              	.L12:
 143 0012 C046     		.align	2
 144              	.L11:
 145 0014 40800440 		.word	1074036800
 146 0018 FFFEFFFF 		.word	-257
 147              		.cfi_endproc
 148              	.LFE71:
 150              		.section	.text.DMA_ResetChannel,"ax",%progbits
 151              		.align	1
 152              		.global	DMA_ResetChannel
 153              		.syntax unified
 154              		.code	16
 155              		.thumb_func
 156              		.fpu softvfp
 158              	DMA_ResetChannel:
 159              	.LFB72:
 104:../drivers/fsl_dma.c **** 
 105:../drivers/fsl_dma.c **** void DMA_ResetChannel(DMA_Type *base, uint32_t channel)
 106:../drivers/fsl_dma.c **** {
 160              		.loc 1 106 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 0
 163              		@ frame_needed = 0, uses_anonymous_args = 0
 164              	.LVL11:
 165 0000 30B5     		push	{r4, r5, lr}
 166              		.cfi_def_cfa_offset 12
 167              		.cfi_offset 4, -12
 168              		.cfi_offset 5, -8
 169              		.cfi_offset 14, -4
 107:../drivers/fsl_dma.c ****     assert(channel < FSL_FEATURE_DMA_MODULE_CHANNEL);
 108:../drivers/fsl_dma.c **** 
 109:../drivers/fsl_dma.c ****     /* clear all status bit */
 110:../drivers/fsl_dma.c ****     base->DMA[channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 170              		.loc 1 110 0
 171 0002 0B01     		lsls	r3, r1, #4
 172 0004 C318     		adds	r3, r0, r3
 173 0006 1A00     		movs	r2, r3
 174 0008 0932     		adds	r2, r2, #9
 175 000a FF32     		adds	r2, r2, #255
 176 000c 1568     		ldr	r5, [r2]
 177 000e 8024     		movs	r4, #128
 178 0010 6404     		lsls	r4, r4, #17
 179 0012 2C43     		orrs	r4, r5
 180 0014 1460     		str	r4, [r2]
 111:../drivers/fsl_dma.c ****     /* clear all registers */
 112:../drivers/fsl_dma.c ****     base->DMA[channel].SAR = 0;
 181              		.loc 1 112 0
 182 0016 1031     		adds	r1, r1, #16
 183              	.LVL12:
 184 0018 0901     		lsls	r1, r1, #4
 185              	.LVL13:
 186 001a 0024     		movs	r4, #0
 187 001c 0C50     		str	r4, [r1, r0]
 113:../drivers/fsl_dma.c ****     base->DMA[channel].DAR = 0;
 188              		.loc 1 113 0
 189 001e 4118     		adds	r1, r0, r1
 190 0020 4C60     		str	r4, [r1, #4]
 114:../drivers/fsl_dma.c ****     base->DMA[channel].DSR_BCR = 0;
 191              		.loc 1 114 0
 192 0022 1460     		str	r4, [r2]
 115:../drivers/fsl_dma.c ****     /* enable cycle steal and enable auto disable channel request */
 116:../drivers/fsl_dma.c ****     base->DMA[channel].DCR = DMA_DCR_D_REQ(true) | DMA_DCR_CS(true);
 193              		.loc 1 116 0
 194 0024 0D33     		adds	r3, r3, #13
 195 0026 FF33     		adds	r3, r3, #255
 196 0028 014A     		ldr	r2, .L14
 197 002a 1A60     		str	r2, [r3]
 117:../drivers/fsl_dma.c **** }
 198              		.loc 1 117 0
 199              		@ sp needed
 200 002c 30BD     		pop	{r4, r5, pc}
 201              	.L15:
 202 002e C046     		.align	2
 203              	.L14:
 204 0030 80000020 		.word	536871040
 205              		.cfi_endproc
 206              	.LFE72:
 208              		.section	.text.DMA_SetTransferConfig,"ax",%progbits
 209              		.align	1
 210              		.global	DMA_SetTransferConfig
 211              		.syntax unified
 212              		.code	16
 213              		.thumb_func
 214              		.fpu softvfp
 216              	DMA_SetTransferConfig:
 217              	.LFB73:
 118:../drivers/fsl_dma.c **** 
 119:../drivers/fsl_dma.c **** void DMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const dma_transfer_config_t *config)
 120:../drivers/fsl_dma.c **** {
 218              		.loc 1 120 0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 0, uses_anonymous_args = 0
 222              	.LVL14:
 223 0000 30B5     		push	{r4, r5, lr}
 224              		.cfi_def_cfa_offset 12
 225              		.cfi_offset 4, -12
 226              		.cfi_offset 5, -8
 227              		.cfi_offset 14, -4
 121:../drivers/fsl_dma.c ****     assert(channel < FSL_FEATURE_DMA_MODULE_CHANNEL);
 122:../drivers/fsl_dma.c ****     assert(config != NULL);
 123:../drivers/fsl_dma.c **** 
 124:../drivers/fsl_dma.c ****     uint32_t tmpreg;
 125:../drivers/fsl_dma.c **** 
 126:../drivers/fsl_dma.c ****     /* Set source address */
 127:../drivers/fsl_dma.c ****     base->DMA[channel].SAR = config->srcAddr;
 228              		.loc 1 127 0
 229 0002 0B00     		movs	r3, r1
 230 0004 1033     		adds	r3, r3, #16
 231 0006 1B01     		lsls	r3, r3, #4
 232 0008 1468     		ldr	r4, [r2]
 233 000a 1C50     		str	r4, [r3, r0]
 128:../drivers/fsl_dma.c ****     /* Set destination address */
 129:../drivers/fsl_dma.c ****     base->DMA[channel].DAR = config->destAddr;
 234              		.loc 1 129 0
 235 000c C318     		adds	r3, r0, r3
 236 000e 5468     		ldr	r4, [r2, #4]
 237 0010 5C60     		str	r4, [r3, #4]
 130:../drivers/fsl_dma.c ****     /* Set transfer bytes */
 131:../drivers/fsl_dma.c ****     base->DMA[channel].DSR_BCR = DMA_DSR_BCR_BCR(config->transferSize);
 238              		.loc 1 131 0
 239 0012 D368     		ldr	r3, [r2, #12]
 240 0014 1B02     		lsls	r3, r3, #8
 241 0016 1B0A     		lsrs	r3, r3, #8
 242 0018 0901     		lsls	r1, r1, #4
 243              	.LVL15:
 244 001a 4018     		adds	r0, r0, r1
 245              	.LVL16:
 246 001c 0100     		movs	r1, r0
 247 001e 0931     		adds	r1, r1, #9
 248 0020 FF31     		adds	r1, r1, #255
 249 0022 0B60     		str	r3, [r1]
 132:../drivers/fsl_dma.c ****     /* Set DMA Control Register */
 133:../drivers/fsl_dma.c ****     tmpreg = base->DMA[channel].DCR;
 250              		.loc 1 133 0
 251 0024 0D30     		adds	r0, r0, #13
 252 0026 FF30     		adds	r0, r0, #255
 253 0028 0468     		ldr	r4, [r0]
 254              	.LVL17:
 134:../drivers/fsl_dma.c ****     tmpreg &= ~(DMA_DCR_DSIZE_MASK | DMA_DCR_DINC_MASK | DMA_DCR_SSIZE_MASK | DMA_DCR_SINC_MASK);
 255              		.loc 1 134 0
 256 002a 0E4B     		ldr	r3, .L17
 257 002c 1C40     		ands	r4, r3
 258              	.LVL18:
 135:../drivers/fsl_dma.c ****     tmpreg |= (DMA_DCR_DSIZE(config->destSize) | DMA_DCR_DINC(config->enableDestIncrement) |
 259              		.loc 1 135 0
 260 002e D37A     		ldrb	r3, [r2, #11]
 261 0030 5B04     		lsls	r3, r3, #17
 262 0032 C021     		movs	r1, #192
 263 0034 C902     		lsls	r1, r1, #11
 264 0036 0B40     		ands	r3, r1
 265 0038 917A     		ldrb	r1, [r2, #10]
 266 003a C904     		lsls	r1, r1, #19
 267 003c 8025     		movs	r5, #128
 268 003e 2D03     		lsls	r5, r5, #12
 269 0040 2940     		ands	r1, r5
 270 0042 0B43     		orrs	r3, r1
 136:../drivers/fsl_dma.c ****                DMA_DCR_SSIZE(config->srcSize) | DMA_DCR_SINC(config->enableSrcIncrement));
 271              		.loc 1 136 0
 272 0044 517A     		ldrb	r1, [r2, #9]
 273 0046 0905     		lsls	r1, r1, #20
 274 0048 C025     		movs	r5, #192
 275 004a AD03     		lsls	r5, r5, #14
 276 004c 2940     		ands	r1, r5
 135:../drivers/fsl_dma.c ****     tmpreg |= (DMA_DCR_DSIZE(config->destSize) | DMA_DCR_DINC(config->enableDestIncrement) |
 277              		.loc 1 135 0
 278 004e 0B43     		orrs	r3, r1
 279              		.loc 1 136 0
 280 0050 127A     		ldrb	r2, [r2, #8]
 281              	.LVL19:
 282 0052 9205     		lsls	r2, r2, #22
 283 0054 8021     		movs	r1, #128
 284 0056 C903     		lsls	r1, r1, #15
 285 0058 0A40     		ands	r2, r1
 286 005a 1343     		orrs	r3, r2
 135:../drivers/fsl_dma.c ****     tmpreg |= (DMA_DCR_DSIZE(config->destSize) | DMA_DCR_DINC(config->enableDestIncrement) |
 287              		.loc 1 135 0
 288 005c 2343     		orrs	r3, r4
 289              	.LVL20:
 137:../drivers/fsl_dma.c ****     base->DMA[channel].DCR = tmpreg;
 290              		.loc 1 137 0
 291 005e 0360     		str	r3, [r0]
 138:../drivers/fsl_dma.c **** }
 292              		.loc 1 138 0
 293              		@ sp needed
 294 0060 30BD     		pop	{r4, r5, pc}
 295              	.L18:
 296 0062 C046     		.align	2
 297              	.L17:
 298 0064 FFFF81FF 		.word	-8257537
 299              		.cfi_endproc
 300              	.LFE73:
 302              		.section	.text.DMA_SetChannelLinkConfig,"ax",%progbits
 303              		.align	1
 304              		.global	DMA_SetChannelLinkConfig
 305              		.syntax unified
 306              		.code	16
 307              		.thumb_func
 308              		.fpu softvfp
 310              	DMA_SetChannelLinkConfig:
 311              	.LFB74:
 139:../drivers/fsl_dma.c **** 
 140:../drivers/fsl_dma.c **** void DMA_SetChannelLinkConfig(DMA_Type *base, uint32_t channel, const dma_channel_link_config_t *co
 141:../drivers/fsl_dma.c **** {
 312              		.loc 1 141 0
 313              		.cfi_startproc
 314              		@ args = 0, pretend = 0, frame = 0
 315              		@ frame_needed = 0, uses_anonymous_args = 0
 316              	.LVL21:
 317 0000 30B5     		push	{r4, r5, lr}
 318              		.cfi_def_cfa_offset 12
 319              		.cfi_offset 4, -12
 320              		.cfi_offset 5, -8
 321              		.cfi_offset 14, -4
 142:../drivers/fsl_dma.c ****     assert(channel < FSL_FEATURE_DMA_MODULE_CHANNEL);
 143:../drivers/fsl_dma.c ****     assert(config != NULL);
 144:../drivers/fsl_dma.c **** 
 145:../drivers/fsl_dma.c ****     uint32_t tmpreg;
 146:../drivers/fsl_dma.c **** 
 147:../drivers/fsl_dma.c ****     tmpreg = base->DMA[channel].DCR;
 322              		.loc 1 147 0
 323 0002 0901     		lsls	r1, r1, #4
 324              	.LVL22:
 325 0004 4018     		adds	r0, r0, r1
 326              	.LVL23:
 327 0006 0D30     		adds	r0, r0, #13
 328 0008 FF30     		adds	r0, r0, #255
 329 000a 0368     		ldr	r3, [r0]
 330              	.LVL24:
 148:../drivers/fsl_dma.c ****     tmpreg &= ~(DMA_DCR_LINKCC_MASK | DMA_DCR_LCH1_MASK | DMA_DCR_LCH2_MASK);
 331              		.loc 1 148 0
 332 000c 3F21     		movs	r1, #63
 333 000e 8B43     		bics	r3, r1
 334              	.LVL25:
 335 0010 1900     		movs	r1, r3
 336              	.LVL26:
 149:../drivers/fsl_dma.c ****     tmpreg |= (DMA_DCR_LINKCC(config->linkType) | DMA_DCR_LCH1(config->channel1) | DMA_DCR_LCH2(con
 337              		.loc 1 149 0
 338 0012 1478     		ldrb	r4, [r2]
 339 0014 2401     		lsls	r4, r4, #4
 340 0016 3023     		movs	r3, #48
 341 0018 2340     		ands	r3, r4
 342 001a 5468     		ldr	r4, [r2, #4]
 343 001c A500     		lsls	r5, r4, #2
 344 001e 0C24     		movs	r4, #12
 345 0020 2C40     		ands	r4, r5
 346 0022 2343     		orrs	r3, r4
 347 0024 9468     		ldr	r4, [r2, #8]
 348 0026 0322     		movs	r2, #3
 349              	.LVL27:
 350 0028 2240     		ands	r2, r4
 351 002a 1343     		orrs	r3, r2
 352 002c 0B43     		orrs	r3, r1
 353              	.LVL28:
 150:../drivers/fsl_dma.c ****     base->DMA[channel].DCR = tmpreg;
 354              		.loc 1 150 0
 355 002e 0360     		str	r3, [r0]
 151:../drivers/fsl_dma.c **** }
 356              		.loc 1 151 0
 357              		@ sp needed
 358 0030 30BD     		pop	{r4, r5, pc}
 359              		.cfi_endproc
 360              	.LFE74:
 362              		.section	.text.DMA_SetModulo,"ax",%progbits
 363              		.align	1
 364              		.global	DMA_SetModulo
 365              		.syntax unified
 366              		.code	16
 367              		.thumb_func
 368              		.fpu softvfp
 370              	DMA_SetModulo:
 371              	.LFB75:
 152:../drivers/fsl_dma.c **** 
 153:../drivers/fsl_dma.c **** void DMA_SetModulo(DMA_Type *base, uint32_t channel, dma_modulo_t srcModulo, dma_modulo_t destModul
 154:../drivers/fsl_dma.c **** {
 372              		.loc 1 154 0
 373              		.cfi_startproc
 374              		@ args = 0, pretend = 0, frame = 0
 375              		@ frame_needed = 0, uses_anonymous_args = 0
 376              	.LVL29:
 377 0000 10B5     		push	{r4, lr}
 378              		.cfi_def_cfa_offset 8
 379              		.cfi_offset 4, -8
 380              		.cfi_offset 14, -4
 155:../drivers/fsl_dma.c ****     assert(channel < FSL_FEATURE_DMA_MODULE_CHANNEL);
 156:../drivers/fsl_dma.c **** 
 157:../drivers/fsl_dma.c ****     uint32_t tmpreg;
 158:../drivers/fsl_dma.c **** 
 159:../drivers/fsl_dma.c ****     tmpreg = base->DMA[channel].DCR;
 381              		.loc 1 159 0
 382 0002 0901     		lsls	r1, r1, #4
 383              	.LVL30:
 384 0004 4018     		adds	r0, r0, r1
 385              	.LVL31:
 386 0006 0D30     		adds	r0, r0, #13
 387 0008 FF30     		adds	r0, r0, #255
 388 000a 0168     		ldr	r1, [r0]
 389              	.LVL32:
 160:../drivers/fsl_dma.c ****     tmpreg &= ~(DMA_DCR_SMOD_MASK | DMA_DCR_DMOD_MASK);
 390              		.loc 1 160 0
 391 000c 054C     		ldr	r4, .L21
 392 000e 2140     		ands	r1, r4
 393              	.LVL33:
 161:../drivers/fsl_dma.c ****     tmpreg |= (DMA_DCR_SMOD(srcModulo) | DMA_DCR_DMOD(destModulo));
 394              		.loc 1 161 0
 395 0010 1207     		lsls	r2, r2, #28
 396              	.LVL34:
 397 0012 120C     		lsrs	r2, r2, #16
 398 0014 1B02     		lsls	r3, r3, #8
 399              	.LVL35:
 400 0016 F024     		movs	r4, #240
 401 0018 2401     		lsls	r4, r4, #4
 402 001a 2340     		ands	r3, r4
 403 001c 1A43     		orrs	r2, r3
 404 001e 0A43     		orrs	r2, r1
 405              	.LVL36:
 162:../drivers/fsl_dma.c ****     base->DMA[channel].DCR = tmpreg;
 406              		.loc 1 162 0
 407 0020 0260     		str	r2, [r0]
 163:../drivers/fsl_dma.c **** }
 408              		.loc 1 163 0
 409              		@ sp needed
 410 0022 10BD     		pop	{r4, pc}
 411              	.L22:
 412              		.align	2
 413              	.L21:
 414 0024 FF00FFFF 		.word	-65281
 415              		.cfi_endproc
 416              	.LFE75:
 418              		.section	.text.DMA_CreateHandle,"ax",%progbits
 419              		.align	1
 420              		.global	DMA_CreateHandle
 421              		.syntax unified
 422              		.code	16
 423              		.thumb_func
 424              		.fpu softvfp
 426              	DMA_CreateHandle:
 427              	.LFB76:
 164:../drivers/fsl_dma.c **** 
 165:../drivers/fsl_dma.c **** void DMA_CreateHandle(dma_handle_t *handle, DMA_Type *base, uint32_t channel)
 166:../drivers/fsl_dma.c **** {
 428              		.loc 1 166 0
 429              		.cfi_startproc
 430              		@ args = 0, pretend = 0, frame = 0
 431              		@ frame_needed = 0, uses_anonymous_args = 0
 432              	.LVL37:
 433 0000 70B5     		push	{r4, r5, r6, lr}
 434              		.cfi_def_cfa_offset 16
 435              		.cfi_offset 4, -16
 436              		.cfi_offset 5, -12
 437              		.cfi_offset 6, -8
 438              		.cfi_offset 14, -4
 439 0002 0500     		movs	r5, r0
 440 0004 0E00     		movs	r6, r1
 441 0006 1400     		movs	r4, r2
 167:../drivers/fsl_dma.c ****     assert(handle != NULL);
 168:../drivers/fsl_dma.c ****     assert(channel < FSL_FEATURE_DMA_MODULE_CHANNEL);
 169:../drivers/fsl_dma.c **** 
 170:../drivers/fsl_dma.c ****     uint32_t dmaInstance;
 171:../drivers/fsl_dma.c ****     uint32_t channelIndex;
 172:../drivers/fsl_dma.c **** 
 173:../drivers/fsl_dma.c ****     /* Zero the handle */
 174:../drivers/fsl_dma.c ****     memset(handle, 0, sizeof(*handle));
 442              		.loc 1 174 0
 443 0008 0430     		adds	r0, r0, #4
 444              	.LVL38:
 445 000a 0C22     		movs	r2, #12
 446              	.LVL39:
 447 000c 0021     		movs	r1, #0
 448              	.LVL40:
 449 000e FFF7FEFF 		bl	memset
 450              	.LVL41:
 175:../drivers/fsl_dma.c **** 
 176:../drivers/fsl_dma.c ****     handle->base = base;
 451              		.loc 1 176 0
 452 0012 2E60     		str	r6, [r5]
 177:../drivers/fsl_dma.c ****     handle->channel = channel;
 453              		.loc 1 177 0
 454 0014 2C71     		strb	r4, [r5, #4]
 178:../drivers/fsl_dma.c ****     /* Get the DMA instance number */
 179:../drivers/fsl_dma.c ****     dmaInstance = DMA_GetInstance(base);
 455              		.loc 1 179 0
 456 0016 3000     		movs	r0, r6
 457 0018 FFF7FEFF 		bl	DMA_GetInstance
 458              	.LVL42:
 180:../drivers/fsl_dma.c ****     channelIndex = (dmaInstance * FSL_FEATURE_DMA_MODULE_CHANNEL) + channel;
 459              		.loc 1 180 0
 460 001c 8000     		lsls	r0, r0, #2
 461              	.LVL43:
 462 001e 0419     		adds	r4, r0, r4
 463              	.LVL44:
 181:../drivers/fsl_dma.c ****     /* Store handle */
 182:../drivers/fsl_dma.c ****     s_DMAHandle[channelIndex] = handle;
 464              		.loc 1 182 0
 465 0020 A200     		lsls	r2, r4, #2
 466 0022 094B     		ldr	r3, .L25
 467 0024 D550     		str	r5, [r2, r3]
 183:../drivers/fsl_dma.c ****     /* Enable NVIC interrupt. */
 184:../drivers/fsl_dma.c ****     EnableIRQ(s_dmaIRQNumber[dmaInstance][channelIndex]);
 468              		.loc 1 184 0
 469 0026 094B     		ldr	r3, .L25+4
 470 0028 1818     		adds	r0, r3, r0
 471 002a 0357     		ldrsb	r3, [r0, r4]
 472              	.LVL45:
 473              	.LBB20:
 474              	.LBB21:
 475              		.file 3 "../drivers/fsl_common.h"
   1:../drivers/fsl_common.h **** /*
   2:../drivers/fsl_common.h ****  * The Clear BSD License
   3:../drivers/fsl_common.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_common.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_common.h ****  * All rights reserved.
   6:../drivers/fsl_common.h ****  *
   7:../drivers/fsl_common.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_common.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_common.h ****  * that the following conditions are met:
  10:../drivers/fsl_common.h ****  *
  11:../drivers/fsl_common.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_common.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_common.h ****  *
  14:../drivers/fsl_common.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_common.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_common.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_common.h ****  *
  18:../drivers/fsl_common.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_common.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_common.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_common.h ****  *
  22:../drivers/fsl_common.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_common.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_common.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_common.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_common.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_common.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_common.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_common.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_common.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_common.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_common.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_common.h ****  */
  34:../drivers/fsl_common.h **** 
  35:../drivers/fsl_common.h **** #ifndef _FSL_COMMON_H_
  36:../drivers/fsl_common.h **** #define _FSL_COMMON_H_
  37:../drivers/fsl_common.h **** 
  38:../drivers/fsl_common.h **** #include <assert.h>
  39:../drivers/fsl_common.h **** #include <stdbool.h>
  40:../drivers/fsl_common.h **** #include <stdint.h>
  41:../drivers/fsl_common.h **** #include <string.h>
  42:../drivers/fsl_common.h **** 
  43:../drivers/fsl_common.h **** #if defined(__ICCARM__)
  44:../drivers/fsl_common.h **** #include <stddef.h>
  45:../drivers/fsl_common.h **** #endif
  46:../drivers/fsl_common.h **** 
  47:../drivers/fsl_common.h **** #include "fsl_device_registers.h"
  48:../drivers/fsl_common.h **** 
  49:../drivers/fsl_common.h **** /*!
  50:../drivers/fsl_common.h ****  * @addtogroup ksdk_common
  51:../drivers/fsl_common.h ****  * @{
  52:../drivers/fsl_common.h ****  */
  53:../drivers/fsl_common.h **** 
  54:../drivers/fsl_common.h **** /*******************************************************************************
  55:../drivers/fsl_common.h ****  * Definitions
  56:../drivers/fsl_common.h ****  ******************************************************************************/
  57:../drivers/fsl_common.h **** 
  58:../drivers/fsl_common.h **** /*! @brief Construct a status code value from a group and code number. */
  59:../drivers/fsl_common.h **** #define MAKE_STATUS(group, code) ((((group)*100) + (code)))
  60:../drivers/fsl_common.h **** 
  61:../drivers/fsl_common.h **** /*! @brief Construct the version number for drivers. */
  62:../drivers/fsl_common.h **** #define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
  63:../drivers/fsl_common.h **** 
  64:../drivers/fsl_common.h **** /*! @name Driver version */
  65:../drivers/fsl_common.h **** /*@{*/
  66:../drivers/fsl_common.h **** /*! @brief common driver version 2.0.0. */
  67:../drivers/fsl_common.h **** #define FSL_COMMON_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
  68:../drivers/fsl_common.h **** /*@}*/
  69:../drivers/fsl_common.h **** 
  70:../drivers/fsl_common.h **** /* Debug console type definition. */
  71:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
  72:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
  73:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
  74:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
  75:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
  76:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
  77:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_IUART 6U    /*!< Debug console base on i.MX UART. */
  78:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_VUSART 7U   /*!< Debug console base on LPC_USART. */
  79:../drivers/fsl_common.h **** 
  80:../drivers/fsl_common.h **** /*! @brief Status group numbers. */
  81:../drivers/fsl_common.h **** enum _status_groups
  82:../drivers/fsl_common.h **** {
  83:../drivers/fsl_common.h ****     kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
  84:../drivers/fsl_common.h ****     kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
  85:../drivers/fsl_common.h ****     kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
  86:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
  87:../drivers/fsl_common.h ****     kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
  88:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
  89:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
  90:../drivers/fsl_common.h ****     kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
  91:../drivers/fsl_common.h ****     kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
  92:../drivers/fsl_common.h ****     kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
  93:../drivers/fsl_common.h ****     kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
  94:../drivers/fsl_common.h ****     kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
  95:../drivers/fsl_common.h ****     kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
  96:../drivers/fsl_common.h ****     kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
  97:../drivers/fsl_common.h ****     kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
  98:../drivers/fsl_common.h ****     kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
  99:../drivers/fsl_common.h ****     kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
 100:../drivers/fsl_common.h ****     kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
 101:../drivers/fsl_common.h ****     kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
 102:../drivers/fsl_common.h ****     kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
 103:../drivers/fsl_common.h ****     kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
 104:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
 105:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_MCULCD = 24,          /*!< Group number for FLEXIO LCD status codes */
 106:../drivers/fsl_common.h ****     kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
 107:../drivers/fsl_common.h ****     kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
 108:../drivers/fsl_common.h ****     kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
 109:../drivers/fsl_common.h ****     kStatusGroup_IUART = 28,                  /*!< Group number for IUART status codes */
 110:../drivers/fsl_common.h ****     kStatusGroup_CSI = 29,                    /*!< Group number for CSI status codes */
 111:../drivers/fsl_common.h ****     kStatusGroup_MIPI_DSI = 30,               /*!< Group number for MIPI DSI status codes */
 112:../drivers/fsl_common.h ****     kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
 113:../drivers/fsl_common.h ****     kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
 114:../drivers/fsl_common.h ****     kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
 115:../drivers/fsl_common.h ****     kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
 116:../drivers/fsl_common.h ****     kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
 117:../drivers/fsl_common.h ****     kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
 118:../drivers/fsl_common.h ****     kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
 119:../drivers/fsl_common.h ****     kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
 120:../drivers/fsl_common.h ****     kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
 121:../drivers/fsl_common.h ****     kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
 122:../drivers/fsl_common.h ****     kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
 123:../drivers/fsl_common.h ****     kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
 124:../drivers/fsl_common.h ****     kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
 125:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
 126:../drivers/fsl_common.h ****     kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
 127:../drivers/fsl_common.h ****     kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
 128:../drivers/fsl_common.h ****     kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
 129:../drivers/fsl_common.h ****     kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
 130:../drivers/fsl_common.h ****     kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
 131:../drivers/fsl_common.h ****     kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
 132:../drivers/fsl_common.h ****     kStatusGroup_MCAN = 62,                   /*!< Group number for MCAN status codes. */
 133:../drivers/fsl_common.h ****     kStatusGroup_CAAM = 63,                   /*!< Group number for CAAM status codes. */
 134:../drivers/fsl_common.h ****     kStatusGroup_ECSPI = 64,                  /*!< Group number for ECSPI status codes. */
 135:../drivers/fsl_common.h ****     kStatusGroup_USDHC = 65,                  /*!< Group number for USDHC status codes.*/
 136:../drivers/fsl_common.h ****     kStatusGroup_LPC_I2C = 66,                /*!< Group number for LPC_I2C status codes.*/
 137:../drivers/fsl_common.h ****     kStatusGroup_DCP = 67,                    /*!< Group number for DCP status codes.*/
 138:../drivers/fsl_common.h ****     kStatusGroup_MSCAN = 68,                  /*!< Group number for MSCAN status codes.*/
 139:../drivers/fsl_common.h ****     kStatusGroup_ESAI = 69,                   /*!< Group number for ESAI status codes. */
 140:../drivers/fsl_common.h ****     kStatusGroup_FLEXSPI = 70,                /*!< Group number for FLEXSPI status codes. */
 141:../drivers/fsl_common.h ****     kStatusGroup_MMDC = 71,                   /*!< Group number for MMDC status codes. */
 142:../drivers/fsl_common.h ****     kStatusGroup_MICFIL = 72,                 /*!< Group number for MIC status codes. */
 143:../drivers/fsl_common.h ****     kStatusGroup_SDMA = 73,                   /*!< Group number for SDMA status codes. */
 144:../drivers/fsl_common.h ****     kStatusGroup_ICS = 74,                    /*!< Group number for ICS status codes. */
 145:../drivers/fsl_common.h ****     kStatusGroup_SPDIF = 75,                  /*!< Group number for SPDIF status codes. */
 146:../drivers/fsl_common.h ****     kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
 147:../drivers/fsl_common.h ****     kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
 148:../drivers/fsl_common.h ****     kStatusGroup_SEMC = 100,                   /*!< Group number for SEMC status codes. */    
 149:../drivers/fsl_common.h ****     kStatusGroup_ApplicationRangeStart = 101, /*!< Starting number for application groups. */
 150:../drivers/fsl_common.h **** };
 151:../drivers/fsl_common.h **** 
 152:../drivers/fsl_common.h **** /*! @brief Generic status return codes. */
 153:../drivers/fsl_common.h **** enum _generic_status
 154:../drivers/fsl_common.h **** {
 155:../drivers/fsl_common.h ****     kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
 156:../drivers/fsl_common.h ****     kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
 157:../drivers/fsl_common.h ****     kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
 158:../drivers/fsl_common.h ****     kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
 159:../drivers/fsl_common.h ****     kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
 160:../drivers/fsl_common.h ****     kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
 161:../drivers/fsl_common.h ****     kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
 162:../drivers/fsl_common.h **** };
 163:../drivers/fsl_common.h **** 
 164:../drivers/fsl_common.h **** /*! @brief Type used for all status and error return values. */
 165:../drivers/fsl_common.h **** typedef int32_t status_t;
 166:../drivers/fsl_common.h **** 
 167:../drivers/fsl_common.h **** /*
 168:../drivers/fsl_common.h ****  * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
 169:../drivers/fsl_common.h ****  * defined in previous of this file.
 170:../drivers/fsl_common.h ****  */
 171:../drivers/fsl_common.h **** #include "fsl_clock.h"
 172:../drivers/fsl_common.h **** 
 173:../drivers/fsl_common.h **** /*
 174:../drivers/fsl_common.h ****  * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a 
 175:../drivers/fsl_common.h ****  */
 176:../drivers/fsl_common.h **** #if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
 177:../drivers/fsl_common.h ****      (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
 178:../drivers/fsl_common.h **** #include "fsl_reset.h"
 179:../drivers/fsl_common.h **** #endif
 180:../drivers/fsl_common.h **** 
 181:../drivers/fsl_common.h **** /*! @name Min/max macros */
 182:../drivers/fsl_common.h **** /* @{ */
 183:../drivers/fsl_common.h **** #if !defined(MIN)
 184:../drivers/fsl_common.h **** #define MIN(a, b) ((a) < (b) ? (a) : (b))
 185:../drivers/fsl_common.h **** #endif
 186:../drivers/fsl_common.h **** 
 187:../drivers/fsl_common.h **** #if !defined(MAX)
 188:../drivers/fsl_common.h **** #define MAX(a, b) ((a) > (b) ? (a) : (b))
 189:../drivers/fsl_common.h **** #endif
 190:../drivers/fsl_common.h **** /* @} */
 191:../drivers/fsl_common.h **** 
 192:../drivers/fsl_common.h **** /*! @brief Computes the number of elements in an array. */
 193:../drivers/fsl_common.h **** #if !defined(ARRAY_SIZE)
 194:../drivers/fsl_common.h **** #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 195:../drivers/fsl_common.h **** #endif
 196:../drivers/fsl_common.h **** 
 197:../drivers/fsl_common.h **** /*! @name UINT16_MAX/UINT32_MAX value */
 198:../drivers/fsl_common.h **** /* @{ */
 199:../drivers/fsl_common.h **** #if !defined(UINT16_MAX)
 200:../drivers/fsl_common.h **** #define UINT16_MAX ((uint16_t)-1)
 201:../drivers/fsl_common.h **** #endif
 202:../drivers/fsl_common.h **** 
 203:../drivers/fsl_common.h **** #if !defined(UINT32_MAX)
 204:../drivers/fsl_common.h **** #define UINT32_MAX ((uint32_t)-1)
 205:../drivers/fsl_common.h **** #endif
 206:../drivers/fsl_common.h **** /* @} */
 207:../drivers/fsl_common.h **** 
 208:../drivers/fsl_common.h **** /*! @name Timer utilities */
 209:../drivers/fsl_common.h **** /* @{ */
 210:../drivers/fsl_common.h **** /*! Macro to convert a microsecond period to raw count value */
 211:../drivers/fsl_common.h **** #define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
 212:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to microsecond */
 213:../drivers/fsl_common.h **** #define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
 214:../drivers/fsl_common.h **** 
 215:../drivers/fsl_common.h **** /*! Macro to convert a millisecond period to raw count value */
 216:../drivers/fsl_common.h **** #define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
 217:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to millisecond */
 218:../drivers/fsl_common.h **** #define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
 219:../drivers/fsl_common.h **** /* @} */
 220:../drivers/fsl_common.h **** 
 221:../drivers/fsl_common.h **** /*! @name Alignment variable definition macros */
 222:../drivers/fsl_common.h **** /* @{ */
 223:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 224:../drivers/fsl_common.h **** /**
 225:../drivers/fsl_common.h ****  * Workaround to disable MISRA C message suppress warnings for IAR compiler.
 226:../drivers/fsl_common.h ****  * http://supp.iar.com/Support/?note=24725
 227:../drivers/fsl_common.h ****  */
 228:../drivers/fsl_common.h **** _Pragma("diag_suppress=Pm120")
 229:../drivers/fsl_common.h **** #define SDK_PRAGMA(x) _Pragma(#x)
 230:../drivers/fsl_common.h ****     _Pragma("diag_error=Pm120")
 231:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 232:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 233:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 234:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 235:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 236:../drivers/fsl_common.h **** #endif
 237:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 238:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 239:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 240:../drivers/fsl_common.h **** #endif
 241:../drivers/fsl_common.h **** #elif defined(__ARMCC_VERSION)
 242:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 243:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) __align(alignbytes) var
 244:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 245:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 246:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) __align(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 247:../drivers/fsl_common.h **** #endif
 248:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 249:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 250:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) __align(FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 251:../drivers/fsl_common.h **** #endif
 252:../drivers/fsl_common.h **** #elif defined(__GNUC__)
 253:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 254:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 255:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 256:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 257:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)))
 258:../drivers/fsl_common.h **** #endif
 259:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 260:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 261:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)))
 262:../drivers/fsl_common.h **** #endif
 263:../drivers/fsl_common.h **** #else
 264:../drivers/fsl_common.h **** #error Toolchain not supported
 265:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var
 266:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 267:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var
 268:../drivers/fsl_common.h **** #endif
 269:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 270:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var
 271:../drivers/fsl_common.h **** #endif
 272:../drivers/fsl_common.h **** #endif
 273:../drivers/fsl_common.h **** 
 274:../drivers/fsl_common.h **** /*! Macro to change a value to a given size aligned value */
 275:../drivers/fsl_common.h **** #define SDK_SIZEALIGN(var, alignbytes) \
 276:../drivers/fsl_common.h ****     ((unsigned int)((var) + ((alignbytes)-1)) & (unsigned int)(~(unsigned int)((alignbytes)-1)))
 277:../drivers/fsl_common.h **** /* @} */
 278:../drivers/fsl_common.h **** 
 279:../drivers/fsl_common.h **** /*! @name Non-cacheable region definition macros */
 280:../drivers/fsl_common.h **** /* For initialized non-zero non-cacheable variables, please using "AT_NONCACHEABLE_SECTION_INIT(var
 281:../drivers/fsl_common.h ****  * "AT_NONCACHEABLE_SECTION_ALIGN_INIT(var) ={xx};" in your projects to define them, for zero-inite
 282:../drivers/fsl_common.h ****  * please using "AT_NONCACHEABLE_SECTION(var);" or "AT_NONCACHEABLE_SECTION_ALIGN(var);" to define 
 283:../drivers/fsl_common.h ****  * will be initialized to zero in system startup.
 284:../drivers/fsl_common.h ****  */
 285:../drivers/fsl_common.h **** /* @{ */
 286:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 287:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 288:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var @"NonCacheable"
 289:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var 
 290:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var @"NonCacheable.init"
 291:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 292:../drivers/fsl_common.h **** #else
 293:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 294:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 295:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 296:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 297:../drivers/fsl_common.h **** #endif
 298:../drivers/fsl_common.h **** #elif(defined(__ARMCC_VERSION))
 299:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 300:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable"), zero_init)) var
 301:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 302:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable"), zero_init)) __align(alignbytes) var
 303:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 304:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 305:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) __align(alignbytes) var
 306:../drivers/fsl_common.h **** #else
 307:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 308:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) __align(alignbytes) var
 309:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 310:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) __align(alignbytes) var
 311:../drivers/fsl_common.h **** #endif
 312:../drivers/fsl_common.h **** #elif(defined(__GNUC__))
 313:../drivers/fsl_common.h **** /* For GCC, when the non-cacheable section is required, please define "__STARTUP_INITIALIZE_NONCACH
 314:../drivers/fsl_common.h ****  * in your projects to make sure the non-cacheable section variables will be initialized in system 
 315:../drivers/fsl_common.h ****  */
 316:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 317:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 318:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 319:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) var __attribute__((aligned(alignbytes)))
 320:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var
 321:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 322:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var __attribute__((aligned(alignbytes
 323:../drivers/fsl_common.h **** #else
 324:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 325:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 326:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 327:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var __attribute__((aligned(alignbytes))
 328:../drivers/fsl_common.h **** #endif
 329:../drivers/fsl_common.h **** #else
 330:../drivers/fsl_common.h **** #error Toolchain not supported.
 331:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 332:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var
 333:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 334:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var
 335:../drivers/fsl_common.h **** #endif
 336:../drivers/fsl_common.h **** /* @} */
 337:../drivers/fsl_common.h **** 
 338:../drivers/fsl_common.h **** /*******************************************************************************
 339:../drivers/fsl_common.h ****  * API
 340:../drivers/fsl_common.h ****  ******************************************************************************/
 341:../drivers/fsl_common.h **** 
 342:../drivers/fsl_common.h **** #if defined(__cplusplus)
 343:../drivers/fsl_common.h ****         extern "C"
 344:../drivers/fsl_common.h **** {
 345:../drivers/fsl_common.h **** #endif
 346:../drivers/fsl_common.h **** 
 347:../drivers/fsl_common.h ****     /*!
 348:../drivers/fsl_common.h ****      * @brief Enable specific interrupt.
 349:../drivers/fsl_common.h ****      *
 350:../drivers/fsl_common.h ****      * Enable LEVEL1 interrupt. For some devices, there might be multiple interrupt
 351:../drivers/fsl_common.h ****      * levels. For example, there are NVIC and intmux. Here the interrupts connected
 352:../drivers/fsl_common.h ****      * to NVIC are the LEVEL1 interrupts, because they are routed to the core directly.
 353:../drivers/fsl_common.h ****      * The interrupts connected to intmux are the LEVEL2 interrupts, they are routed
 354:../drivers/fsl_common.h ****      * to NVIC first then routed to core.
 355:../drivers/fsl_common.h ****      *
 356:../drivers/fsl_common.h ****      * This function only enables the LEVEL1 interrupts. The number of LEVEL1 interrupts
 357:../drivers/fsl_common.h ****      * is indicated by the feature macro FSL_FEATURE_NUMBER_OF_LEVEL1_INT_VECTORS.
 358:../drivers/fsl_common.h ****      *
 359:../drivers/fsl_common.h ****      * @param interrupt The IRQ number.
 360:../drivers/fsl_common.h ****      * @retval kStatus_Success Interrupt enabled successfully
 361:../drivers/fsl_common.h ****      * @retval kStatus_Fail Failed to enable the interrupt
 362:../drivers/fsl_common.h ****      */
 363:../drivers/fsl_common.h ****     static inline status_t EnableIRQ(IRQn_Type interrupt)
 364:../drivers/fsl_common.h ****     {
 365:../drivers/fsl_common.h ****         if (NotAvail_IRQn == interrupt)
 476              		.loc 3 365 0
 477 002c 1A00     		movs	r2, r3
 478 002e 8032     		adds	r2, r2, #128
 479 0030 08D0     		beq	.L23
 480              	.LVL46:
 481              	.LBB22:
 482              	.LBB23:
 483              		.file 4 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 484              		.loc 4 733 0
 485 0032 002B     		cmp	r3, #0
 486 0034 06DB     		blt	.L23
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 487              		.loc 4 735 0
 488 0036 1F22     		movs	r2, #31
 489 0038 1340     		ands	r3, r2
 490              	.LVL47:
 491 003a 1E3A     		subs	r2, r2, #30
 492 003c 9A40     		lsls	r2, r2, r3
 493 003e 1300     		movs	r3, r2
 494 0040 034A     		ldr	r2, .L25+8
 495 0042 1360     		str	r3, [r2]
 496              	.LVL48:
 497              	.L23:
 498              	.LBE23:
 499              	.LBE22:
 500              	.LBE21:
 501              	.LBE20:
 185:../drivers/fsl_dma.c **** }
 502              		.loc 1 185 0
 503              		@ sp needed
 504              	.LVL49:
 505              	.LVL50:
 506              	.LVL51:
 507 0044 70BD     		pop	{r4, r5, r6, pc}
 508              	.L26:
 509 0046 C046     		.align	2
 510              	.L25:
 511 0048 00000000 		.word	.LANCHOR0
 512 004c 00000000 		.word	.LANCHOR1
 513 0050 00E100E0 		.word	-536813312
 514              		.cfi_endproc
 515              	.LFE76:
 517              		.section	.text.DMA_PrepareTransfer,"ax",%progbits
 518              		.align	1
 519              		.global	DMA_PrepareTransfer
 520              		.syntax unified
 521              		.code	16
 522              		.thumb_func
 523              		.fpu softvfp
 525              	DMA_PrepareTransfer:
 526              	.LFB77:
 186:../drivers/fsl_dma.c **** 
 187:../drivers/fsl_dma.c **** void DMA_PrepareTransfer(dma_transfer_config_t *config,
 188:../drivers/fsl_dma.c ****                          void *srcAddr,
 189:../drivers/fsl_dma.c ****                          uint32_t srcWidth,
 190:../drivers/fsl_dma.c ****                          void *destAddr,
 191:../drivers/fsl_dma.c ****                          uint32_t destWidth,
 192:../drivers/fsl_dma.c ****                          uint32_t transferBytes,
 193:../drivers/fsl_dma.c ****                          dma_transfer_type_t type)
 194:../drivers/fsl_dma.c **** {
 527              		.loc 1 194 0
 528              		.cfi_startproc
 529              		@ args = 12, pretend = 0, frame = 0
 530              		@ frame_needed = 0, uses_anonymous_args = 0
 531              	.LVL52:
 532 0000 30B5     		push	{r4, r5, lr}
 533              		.cfi_def_cfa_offset 12
 534              		.cfi_offset 4, -12
 535              		.cfi_offset 5, -8
 536              		.cfi_offset 14, -4
 537 0002 039D     		ldr	r5, [sp, #12]
 538 0004 05AC     		add	r4, sp, #20
 539              	.LVL53:
 540 0006 2478     		ldrb	r4, [r4]
 541              	.LVL54:
 195:../drivers/fsl_dma.c ****     assert(config != NULL);
 196:../drivers/fsl_dma.c ****     assert(srcAddr != NULL);
 197:../drivers/fsl_dma.c ****     assert(destAddr != NULL);
 198:../drivers/fsl_dma.c ****     assert((srcWidth == 1U) || (srcWidth == 2U) || (srcWidth == 4U));
 199:../drivers/fsl_dma.c ****     assert((destWidth == 1U) || (destWidth == 2U) || (destWidth == 4U));
 200:../drivers/fsl_dma.c **** 
 201:../drivers/fsl_dma.c ****     config->srcAddr = (uint32_t)srcAddr;
 542              		.loc 1 201 0
 543 0008 0160     		str	r1, [r0]
 202:../drivers/fsl_dma.c ****     config->destAddr = (uint32_t)destAddr;
 544              		.loc 1 202 0
 545 000a 4360     		str	r3, [r0, #4]
 203:../drivers/fsl_dma.c ****     config->transferSize = transferBytes;
 546              		.loc 1 203 0
 547 000c 049B     		ldr	r3, [sp, #16]
 548              	.LVL55:
 549 000e C360     		str	r3, [r0, #12]
 204:../drivers/fsl_dma.c ****     switch (srcWidth)
 550              		.loc 1 204 0
 551 0010 022A     		cmp	r2, #2
 552 0012 13D0     		beq	.L29
 553 0014 042A     		cmp	r2, #4
 554 0016 14D0     		beq	.L30
 555 0018 012A     		cmp	r2, #1
 556 001a 0CD0     		beq	.L40
 557              	.L28:
 205:../drivers/fsl_dma.c ****     {
 206:../drivers/fsl_dma.c ****         case 1U:
 207:../drivers/fsl_dma.c ****             config->srcSize = kDMA_Transfersize8bits;
 208:../drivers/fsl_dma.c ****             break;
 209:../drivers/fsl_dma.c ****         case 2U:
 210:../drivers/fsl_dma.c ****             config->srcSize = kDMA_Transfersize16bits;
 211:../drivers/fsl_dma.c ****             break;
 212:../drivers/fsl_dma.c ****         case 4U:
 213:../drivers/fsl_dma.c ****             config->srcSize = kDMA_Transfersize32bits;
 214:../drivers/fsl_dma.c ****             break;
 215:../drivers/fsl_dma.c ****         default:
 216:../drivers/fsl_dma.c ****             break;
 217:../drivers/fsl_dma.c ****     }
 218:../drivers/fsl_dma.c ****     switch (destWidth)
 558              		.loc 1 218 0
 559 001c 022D     		cmp	r5, #2
 560 001e 16D0     		beq	.L33
 561 0020 042D     		cmp	r5, #4
 562 0022 17D0     		beq	.L34
 563 0024 012D     		cmp	r5, #1
 564 0026 0FD0     		beq	.L41
 565              	.L32:
 219:../drivers/fsl_dma.c ****     {
 220:../drivers/fsl_dma.c ****         case 1U:
 221:../drivers/fsl_dma.c ****             config->destSize = kDMA_Transfersize8bits;
 222:../drivers/fsl_dma.c ****             break;
 223:../drivers/fsl_dma.c ****         case 2U:
 224:../drivers/fsl_dma.c ****             config->destSize = kDMA_Transfersize16bits;
 225:../drivers/fsl_dma.c ****             break;
 226:../drivers/fsl_dma.c ****         case 4U:
 227:../drivers/fsl_dma.c ****             config->destSize = kDMA_Transfersize32bits;
 228:../drivers/fsl_dma.c ****             break;
 229:../drivers/fsl_dma.c ****         default:
 230:../drivers/fsl_dma.c ****             break;
 231:../drivers/fsl_dma.c ****     }
 232:../drivers/fsl_dma.c ****     switch (type)
 566              		.loc 1 232 0
 567 0028 012C     		cmp	r4, #1
 568 002a 1AD0     		beq	.L37
 569 002c 002C     		cmp	r4, #0
 570 002e 14D0     		beq	.L38
 571 0030 022C     		cmp	r4, #2
 572 0032 1BD0     		beq	.L39
 573              	.L27:
 233:../drivers/fsl_dma.c ****     {
 234:../drivers/fsl_dma.c ****         case kDMA_MemoryToMemory:
 235:../drivers/fsl_dma.c ****             config->enableSrcIncrement = true;
 236:../drivers/fsl_dma.c ****             config->enableDestIncrement = true;
 237:../drivers/fsl_dma.c ****             break;
 238:../drivers/fsl_dma.c ****         case kDMA_PeripheralToMemory:
 239:../drivers/fsl_dma.c ****             config->enableSrcIncrement = false;
 240:../drivers/fsl_dma.c ****             config->enableDestIncrement = true;
 241:../drivers/fsl_dma.c ****             break;
 242:../drivers/fsl_dma.c ****         case kDMA_MemoryToPeripheral:
 243:../drivers/fsl_dma.c ****             config->enableSrcIncrement = true;
 244:../drivers/fsl_dma.c ****             config->enableDestIncrement = false;
 245:../drivers/fsl_dma.c ****             break;
 246:../drivers/fsl_dma.c ****         default:
 247:../drivers/fsl_dma.c ****             break;
 248:../drivers/fsl_dma.c ****     }
 249:../drivers/fsl_dma.c **** }
 574              		.loc 1 249 0
 575              		@ sp needed
 576 0034 30BD     		pop	{r4, r5, pc}
 577              	.L40:
 207:../drivers/fsl_dma.c ****             break;
 578              		.loc 1 207 0
 579 0036 0123     		movs	r3, #1
 580 0038 4372     		strb	r3, [r0, #9]
 208:../drivers/fsl_dma.c ****         case 2U:
 581              		.loc 1 208 0
 582 003a EFE7     		b	.L28
 583              	.L29:
 210:../drivers/fsl_dma.c ****             break;
 584              		.loc 1 210 0
 585 003c 0223     		movs	r3, #2
 586 003e 4372     		strb	r3, [r0, #9]
 211:../drivers/fsl_dma.c ****         case 4U:
 587              		.loc 1 211 0
 588 0040 ECE7     		b	.L28
 589              	.L30:
 213:../drivers/fsl_dma.c ****             break;
 590              		.loc 1 213 0
 591 0042 0023     		movs	r3, #0
 592 0044 4372     		strb	r3, [r0, #9]
 214:../drivers/fsl_dma.c ****         default:
 593              		.loc 1 214 0
 594 0046 E9E7     		b	.L28
 595              	.L41:
 221:../drivers/fsl_dma.c ****             break;
 596              		.loc 1 221 0
 597 0048 0123     		movs	r3, #1
 598 004a C372     		strb	r3, [r0, #11]
 222:../drivers/fsl_dma.c ****         case 2U:
 599              		.loc 1 222 0
 600 004c ECE7     		b	.L32
 601              	.L33:
 224:../drivers/fsl_dma.c ****             break;
 602              		.loc 1 224 0
 603 004e 0223     		movs	r3, #2
 604 0050 C372     		strb	r3, [r0, #11]
 225:../drivers/fsl_dma.c ****         case 4U:
 605              		.loc 1 225 0
 606 0052 E9E7     		b	.L32
 607              	.L34:
 227:../drivers/fsl_dma.c ****             break;
 608              		.loc 1 227 0
 609 0054 0023     		movs	r3, #0
 610 0056 C372     		strb	r3, [r0, #11]
 228:../drivers/fsl_dma.c ****         default:
 611              		.loc 1 228 0
 612 0058 E6E7     		b	.L32
 613              	.L38:
 235:../drivers/fsl_dma.c ****             config->enableDestIncrement = true;
 614              		.loc 1 235 0
 615 005a 0123     		movs	r3, #1
 616 005c 0372     		strb	r3, [r0, #8]
 236:../drivers/fsl_dma.c ****             break;
 617              		.loc 1 236 0
 618 005e 8372     		strb	r3, [r0, #10]
 237:../drivers/fsl_dma.c ****         case kDMA_PeripheralToMemory:
 619              		.loc 1 237 0
 620 0060 E8E7     		b	.L27
 621              	.L37:
 239:../drivers/fsl_dma.c ****             config->enableDestIncrement = true;
 622              		.loc 1 239 0
 623 0062 0023     		movs	r3, #0
 624 0064 0372     		strb	r3, [r0, #8]
 240:../drivers/fsl_dma.c ****             break;
 625              		.loc 1 240 0
 626 0066 0133     		adds	r3, r3, #1
 627 0068 8372     		strb	r3, [r0, #10]
 241:../drivers/fsl_dma.c ****         case kDMA_MemoryToPeripheral:
 628              		.loc 1 241 0
 629 006a E3E7     		b	.L27
 630              	.L39:
 243:../drivers/fsl_dma.c ****             config->enableDestIncrement = false;
 631              		.loc 1 243 0
 632 006c 0123     		movs	r3, #1
 633 006e 0372     		strb	r3, [r0, #8]
 244:../drivers/fsl_dma.c ****             break;
 634              		.loc 1 244 0
 635 0070 0023     		movs	r3, #0
 636 0072 8372     		strb	r3, [r0, #10]
 637              		.loc 1 249 0
 638 0074 DEE7     		b	.L27
 639              		.cfi_endproc
 640              	.LFE77:
 642              		.section	.text.DMA_SetCallback,"ax",%progbits
 643              		.align	1
 644              		.global	DMA_SetCallback
 645              		.syntax unified
 646              		.code	16
 647              		.thumb_func
 648              		.fpu softvfp
 650              	DMA_SetCallback:
 651              	.LFB78:
 250:../drivers/fsl_dma.c **** 
 251:../drivers/fsl_dma.c **** void DMA_SetCallback(dma_handle_t *handle, dma_callback callback, void *userData)
 252:../drivers/fsl_dma.c **** {
 652              		.loc 1 252 0
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 0
 655              		@ frame_needed = 0, uses_anonymous_args = 0
 656              		@ link register save eliminated.
 657              	.LVL56:
 253:../drivers/fsl_dma.c ****     assert(handle != NULL);
 254:../drivers/fsl_dma.c **** 
 255:../drivers/fsl_dma.c ****     handle->callback = callback;
 658              		.loc 1 255 0
 659 0000 8160     		str	r1, [r0, #8]
 256:../drivers/fsl_dma.c ****     handle->userData = userData;
 660              		.loc 1 256 0
 661 0002 C260     		str	r2, [r0, #12]
 257:../drivers/fsl_dma.c **** }
 662              		.loc 1 257 0
 663              		@ sp needed
 664 0004 7047     		bx	lr
 665              		.cfi_endproc
 666              	.LFE78:
 668              		.section	.text.DMA_SubmitTransfer,"ax",%progbits
 669              		.align	1
 670              		.global	DMA_SubmitTransfer
 671              		.syntax unified
 672              		.code	16
 673              		.thumb_func
 674              		.fpu softvfp
 676              	DMA_SubmitTransfer:
 677              	.LFB79:
 258:../drivers/fsl_dma.c **** 
 259:../drivers/fsl_dma.c **** status_t DMA_SubmitTransfer(dma_handle_t *handle, const dma_transfer_config_t *config, uint32_t opt
 260:../drivers/fsl_dma.c **** {
 678              		.loc 1 260 0
 679              		.cfi_startproc
 680              		@ args = 0, pretend = 0, frame = 0
 681              		@ frame_needed = 0, uses_anonymous_args = 0
 682              	.LVL57:
 683 0000 70B5     		push	{r4, r5, r6, lr}
 684              		.cfi_def_cfa_offset 16
 685              		.cfi_offset 4, -16
 686              		.cfi_offset 5, -12
 687              		.cfi_offset 6, -8
 688              		.cfi_offset 14, -4
 689 0002 0600     		movs	r6, r0
 690 0004 0D00     		movs	r5, r1
 691 0006 1400     		movs	r4, r2
 261:../drivers/fsl_dma.c ****     assert(handle != NULL);
 262:../drivers/fsl_dma.c ****     assert(config != NULL);
 263:../drivers/fsl_dma.c **** 
 264:../drivers/fsl_dma.c ****     /* Check if DMA is busy */
 265:../drivers/fsl_dma.c ****     if (handle->base->DMA[handle->channel].DSR_BCR & DMA_DSR_BCR_BSY_MASK)
 692              		.loc 1 265 0
 693 0008 0068     		ldr	r0, [r0]
 694              	.LVL58:
 695 000a 3179     		ldrb	r1, [r6, #4]
 696              	.LVL59:
 697 000c 0B01     		lsls	r3, r1, #4
 698 000e C318     		adds	r3, r0, r3
 699 0010 0933     		adds	r3, r3, #9
 700 0012 FF33     		adds	r3, r3, #255
 701 0014 1B68     		ldr	r3, [r3]
 702 0016 9B01     		lsls	r3, r3, #6
 703 0018 15D4     		bmi	.L45
 266:../drivers/fsl_dma.c ****     {
 267:../drivers/fsl_dma.c ****         return kStatus_DMA_Busy;
 268:../drivers/fsl_dma.c ****     }
 269:../drivers/fsl_dma.c ****     DMA_ResetChannel(handle->base, handle->channel);
 704              		.loc 1 269 0
 705 001a FFF7FEFF 		bl	DMA_ResetChannel
 706              	.LVL60:
 270:../drivers/fsl_dma.c ****     DMA_SetTransferConfig(handle->base, handle->channel, config);
 707              		.loc 1 270 0
 708 001e 3179     		ldrb	r1, [r6, #4]
 709 0020 2A00     		movs	r2, r5
 710 0022 3068     		ldr	r0, [r6]
 711 0024 FFF7FEFF 		bl	DMA_SetTransferConfig
 712              	.LVL61:
 271:../drivers/fsl_dma.c ****     if (options & kDMA_EnableInterrupt)
 713              		.loc 1 271 0
 714 0028 E307     		lsls	r3, r4, #31
 715 002a 0ED5     		bpl	.L46
 272:../drivers/fsl_dma.c ****     {
 273:../drivers/fsl_dma.c ****         DMA_EnableInterrupts(handle->base, handle->channel);
 716              		.loc 1 273 0
 717 002c 3368     		ldr	r3, [r6]
 718 002e 3279     		ldrb	r2, [r6, #4]
 719              	.LVL62:
 720              	.LBB24:
 721              	.LBB25:
 722              		.file 5 "../drivers/fsl_dma.h"
   1:../drivers/fsl_dma.h **** /*
   2:../drivers/fsl_dma.h ****  * The Clear BSD License
   3:../drivers/fsl_dma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dma.h ****  * All rights reserved.
   6:../drivers/fsl_dma.h ****  *
   7:../drivers/fsl_dma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dma.h ****  * that the following conditions are met:
  10:../drivers/fsl_dma.h ****  *
  11:../drivers/fsl_dma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dma.h ****  *
  14:../drivers/fsl_dma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dma.h ****  *
  18:../drivers/fsl_dma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dma.h ****  *
  22:../drivers/fsl_dma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dma.h ****  */
  34:../drivers/fsl_dma.h **** 
  35:../drivers/fsl_dma.h **** #ifndef _FSL_DMA_H_
  36:../drivers/fsl_dma.h **** #define _FSL_DMA_H_
  37:../drivers/fsl_dma.h **** 
  38:../drivers/fsl_dma.h **** #include "fsl_common.h"
  39:../drivers/fsl_dma.h **** 
  40:../drivers/fsl_dma.h **** /*!
  41:../drivers/fsl_dma.h ****  * @addtogroup dma
  42:../drivers/fsl_dma.h ****  * @{
  43:../drivers/fsl_dma.h ****  */
  44:../drivers/fsl_dma.h **** 
  45:../drivers/fsl_dma.h **** 
  46:../drivers/fsl_dma.h **** /*******************************************************************************
  47:../drivers/fsl_dma.h ****  * Definitions
  48:../drivers/fsl_dma.h ****  ******************************************************************************/
  49:../drivers/fsl_dma.h **** 
  50:../drivers/fsl_dma.h **** /*! @name Driver version */
  51:../drivers/fsl_dma.h **** /*@{*/
  52:../drivers/fsl_dma.h **** /*! @brief DMA driver version 2.0.1. */
  53:../drivers/fsl_dma.h **** #define FSL_DMA_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  54:../drivers/fsl_dma.h **** /*@}*/
  55:../drivers/fsl_dma.h **** 
  56:../drivers/fsl_dma.h **** /*! @brief status flag for the DMA driver. */
  57:../drivers/fsl_dma.h **** enum _dma_channel_status_flags
  58:../drivers/fsl_dma.h **** {
  59:../drivers/fsl_dma.h ****     kDMA_TransactionsBCRFlag = DMA_DSR_BCR_BCR_MASK,       /*!< Contains the number of bytes yet to
  60:../drivers/fsl_dma.h ****                                                                 transferred for a given block */
  61:../drivers/fsl_dma.h ****     kDMA_TransactionsDoneFlag = DMA_DSR_BCR_DONE_MASK,     /*!< Transactions Done */
  62:../drivers/fsl_dma.h ****     kDMA_TransactionsBusyFlag = DMA_DSR_BCR_BSY_MASK,      /*!< Transactions Busy */
  63:../drivers/fsl_dma.h ****     kDMA_TransactionsRequestFlag = DMA_DSR_BCR_REQ_MASK,   /*!< Transactions Request */
  64:../drivers/fsl_dma.h ****     kDMA_BusErrorOnDestinationFlag = DMA_DSR_BCR_BED_MASK, /*!< Bus Error on Destination */
  65:../drivers/fsl_dma.h ****     kDMA_BusErrorOnSourceFlag = DMA_DSR_BCR_BES_MASK,      /*!< Bus Error on Source */
  66:../drivers/fsl_dma.h ****     kDMA_ConfigurationErrorFlag = DMA_DSR_BCR_CE_MASK,     /*!< Configuration Error */
  67:../drivers/fsl_dma.h **** };
  68:../drivers/fsl_dma.h **** 
  69:../drivers/fsl_dma.h **** /*! @brief DMA transfer size type*/
  70:../drivers/fsl_dma.h **** typedef enum _dma_transfer_size
  71:../drivers/fsl_dma.h **** {
  72:../drivers/fsl_dma.h ****     kDMA_Transfersize32bits = 0x0U, /*!< 32 bits are transferred for every read/write */
  73:../drivers/fsl_dma.h ****     kDMA_Transfersize8bits,         /*!< 8 bits are transferred for every read/write */
  74:../drivers/fsl_dma.h ****     kDMA_Transfersize16bits,        /*!< 16b its are transferred for every read/write */
  75:../drivers/fsl_dma.h **** } dma_transfer_size_t;
  76:../drivers/fsl_dma.h **** 
  77:../drivers/fsl_dma.h **** /*! @brief Configuration type for the DMA modulo */
  78:../drivers/fsl_dma.h **** typedef enum _dma_modulo
  79:../drivers/fsl_dma.h **** {
  80:../drivers/fsl_dma.h ****     kDMA_ModuloDisable = 0x0U, /*!< Buffer disabled */
  81:../drivers/fsl_dma.h ****     kDMA_Modulo16Bytes,        /*!< Circular buffer size is 16 bytes. */
  82:../drivers/fsl_dma.h ****     kDMA_Modulo32Bytes,        /*!< Circular buffer size is 32 bytes. */
  83:../drivers/fsl_dma.h ****     kDMA_Modulo64Bytes,        /*!< Circular buffer size is 64 bytes. */
  84:../drivers/fsl_dma.h ****     kDMA_Modulo128Bytes,       /*!< Circular buffer size is 128 bytes. */
  85:../drivers/fsl_dma.h ****     kDMA_Modulo256Bytes,       /*!< Circular buffer size is 256 bytes. */
  86:../drivers/fsl_dma.h ****     kDMA_Modulo512Bytes,       /*!< Circular buffer size is 512 bytes. */
  87:../drivers/fsl_dma.h ****     kDMA_Modulo1KBytes,        /*!< Circular buffer size is 1 KB. */
  88:../drivers/fsl_dma.h ****     kDMA_Modulo2KBytes,        /*!< Circular buffer size is 2 KB. */
  89:../drivers/fsl_dma.h ****     kDMA_Modulo4KBytes,        /*!< Circular buffer size is 4 KB. */
  90:../drivers/fsl_dma.h ****     kDMA_Modulo8KBytes,        /*!< Circular buffer size is 8 KB. */
  91:../drivers/fsl_dma.h ****     kDMA_Modulo16KBytes,       /*!< Circular buffer size is 16 KB. */
  92:../drivers/fsl_dma.h ****     kDMA_Modulo32KBytes,       /*!< Circular buffer size is 32 KB. */
  93:../drivers/fsl_dma.h ****     kDMA_Modulo64KBytes,       /*!< Circular buffer size is 64 KB. */
  94:../drivers/fsl_dma.h ****     kDMA_Modulo128KBytes,      /*!< Circular buffer size is 128 KB. */
  95:../drivers/fsl_dma.h ****     kDMA_Modulo256KBytes,      /*!< Circular buffer size is 256 KB. */
  96:../drivers/fsl_dma.h **** } dma_modulo_t;
  97:../drivers/fsl_dma.h **** 
  98:../drivers/fsl_dma.h **** /*! @brief DMA channel link type */
  99:../drivers/fsl_dma.h **** typedef enum _dma_channel_link_type
 100:../drivers/fsl_dma.h **** {
 101:../drivers/fsl_dma.h ****     kDMA_ChannelLinkDisable = 0x0U,      /*!< No channel link. */
 102:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AndChannel2, /*!< Perform a link to channel LCH1 after each cycle-steal
 103:../drivers/fsl_dma.h ****                                               followed by a link to LCH2 after the BCR decrements t
 104:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1,            /*!< Perform a link to LCH1 after each cycle-steal transfe
 105:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AfterBCR0,   /*!< Perform a link to LCH1 after the BCR decrements. */
 106:../drivers/fsl_dma.h **** } dma_channel_link_type_t;
 107:../drivers/fsl_dma.h **** 
 108:../drivers/fsl_dma.h **** /*! @brief DMA transfer type */
 109:../drivers/fsl_dma.h **** typedef enum _dma_transfer_type
 110:../drivers/fsl_dma.h **** {
 111:../drivers/fsl_dma.h ****     kDMA_MemoryToMemory = 0x0U, /*!< Memory to Memory transfer. */
 112:../drivers/fsl_dma.h ****     kDMA_PeripheralToMemory,    /*!< Peripheral to Memory transfer. */
 113:../drivers/fsl_dma.h ****     kDMA_MemoryToPeripheral,    /*!< Memory to Peripheral transfer. */
 114:../drivers/fsl_dma.h **** } dma_transfer_type_t;
 115:../drivers/fsl_dma.h **** 
 116:../drivers/fsl_dma.h **** /*! @brief DMA transfer options */
 117:../drivers/fsl_dma.h **** typedef enum _dma_transfer_options
 118:../drivers/fsl_dma.h **** {
 119:../drivers/fsl_dma.h ****     kDMA_NoOptions = 0x0U, /*!< Transfer without options. */
 120:../drivers/fsl_dma.h ****     kDMA_EnableInterrupt,  /*!< Enable interrupt while transfer complete. */
 121:../drivers/fsl_dma.h **** } dma_transfer_options_t;
 122:../drivers/fsl_dma.h **** 
 123:../drivers/fsl_dma.h **** /*! @brief DMA transfer status */
 124:../drivers/fsl_dma.h **** enum _dma_transfer_status
 125:../drivers/fsl_dma.h **** {
 126:../drivers/fsl_dma.h ****     kStatus_DMA_Busy = MAKE_STATUS(kStatusGroup_DMA, 0),
 127:../drivers/fsl_dma.h **** };
 128:../drivers/fsl_dma.h **** 
 129:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 130:../drivers/fsl_dma.h **** typedef struct _dma_transfer_config
 131:../drivers/fsl_dma.h **** {
 132:../drivers/fsl_dma.h ****     uint32_t srcAddr;             /*!< DMA transfer source address. */
 133:../drivers/fsl_dma.h ****     uint32_t destAddr;            /*!< DMA destination address.*/
 134:../drivers/fsl_dma.h ****     bool enableSrcIncrement;      /*!< Source address increase after each transfer. */
 135:../drivers/fsl_dma.h ****     dma_transfer_size_t srcSize;  /*!< Source transfer size unit. */
 136:../drivers/fsl_dma.h ****     bool enableDestIncrement;     /*!< Destination address increase after each transfer. */
 137:../drivers/fsl_dma.h ****     dma_transfer_size_t destSize; /*!< Destination transfer unit.*/
 138:../drivers/fsl_dma.h ****     uint32_t transferSize;        /*!< The number of bytes to be transferred. */
 139:../drivers/fsl_dma.h **** } dma_transfer_config_t;
 140:../drivers/fsl_dma.h **** 
 141:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 142:../drivers/fsl_dma.h **** typedef struct _dma_channel_link_config
 143:../drivers/fsl_dma.h **** {
 144:../drivers/fsl_dma.h ****     dma_channel_link_type_t linkType; /*!< Channel link type. */
 145:../drivers/fsl_dma.h ****     uint32_t channel1;                /*!< The index of channel 1. */
 146:../drivers/fsl_dma.h ****     uint32_t channel2;                /*!< The index of channel 2. */
 147:../drivers/fsl_dma.h **** } dma_channel_link_config_t;
 148:../drivers/fsl_dma.h **** 
 149:../drivers/fsl_dma.h **** struct _dma_handle;
 150:../drivers/fsl_dma.h **** /*! @brief Callback function prototype for the DMA driver. */
 151:../drivers/fsl_dma.h **** typedef void (*dma_callback)(struct _dma_handle *handle, void *userData);
 152:../drivers/fsl_dma.h **** 
 153:../drivers/fsl_dma.h **** /*! @brief DMA DMA handle structure */
 154:../drivers/fsl_dma.h **** typedef struct _dma_handle
 155:../drivers/fsl_dma.h **** {
 156:../drivers/fsl_dma.h ****     DMA_Type *base;        /*!< DMA peripheral address. */
 157:../drivers/fsl_dma.h ****     uint8_t channel;       /*!< DMA channel used. */
 158:../drivers/fsl_dma.h ****     dma_callback callback; /*!< DMA callback function.*/
 159:../drivers/fsl_dma.h ****     void *userData;        /*!< Callback parameter. */
 160:../drivers/fsl_dma.h **** } dma_handle_t;
 161:../drivers/fsl_dma.h **** 
 162:../drivers/fsl_dma.h **** /*******************************************************************************
 163:../drivers/fsl_dma.h ****  * API
 164:../drivers/fsl_dma.h ****  ******************************************************************************/
 165:../drivers/fsl_dma.h **** #if defined(__cplusplus)
 166:../drivers/fsl_dma.h **** extern "C" {
 167:../drivers/fsl_dma.h **** #endif /* __cplusplus */
 168:../drivers/fsl_dma.h **** 
 169:../drivers/fsl_dma.h **** /*!
 170:../drivers/fsl_dma.h ****  * @name DMA Initialization and De-initialization
 171:../drivers/fsl_dma.h ****  * @{
 172:../drivers/fsl_dma.h ****  */
 173:../drivers/fsl_dma.h **** 
 174:../drivers/fsl_dma.h **** /*!
 175:../drivers/fsl_dma.h ****  * @brief Initializes the DMA peripheral.
 176:../drivers/fsl_dma.h ****  *
 177:../drivers/fsl_dma.h ****  * This function ungates the DMA clock.
 178:../drivers/fsl_dma.h ****  *
 179:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 180:../drivers/fsl_dma.h ****  */
 181:../drivers/fsl_dma.h **** void DMA_Init(DMA_Type *base);
 182:../drivers/fsl_dma.h **** 
 183:../drivers/fsl_dma.h **** /*!
 184:../drivers/fsl_dma.h ****  * @brief Deinitializes the DMA peripheral.
 185:../drivers/fsl_dma.h ****  *
 186:../drivers/fsl_dma.h ****  * This function gates the DMA clock.
 187:../drivers/fsl_dma.h ****  *
 188:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 189:../drivers/fsl_dma.h ****  */
 190:../drivers/fsl_dma.h **** void DMA_Deinit(DMA_Type *base);
 191:../drivers/fsl_dma.h **** 
 192:../drivers/fsl_dma.h **** /* @} */
 193:../drivers/fsl_dma.h **** /*!
 194:../drivers/fsl_dma.h ****  * @name DMA Channel Operation
 195:../drivers/fsl_dma.h ****  * @{
 196:../drivers/fsl_dma.h ****  */
 197:../drivers/fsl_dma.h **** 
 198:../drivers/fsl_dma.h **** /*!
 199:../drivers/fsl_dma.h ****  * @brief Resets the DMA channel.
 200:../drivers/fsl_dma.h ****  *
 201:../drivers/fsl_dma.h ****  * Sets all register values to reset values and enables
 202:../drivers/fsl_dma.h ****  * the cycle steal and auto stop channel request features.
 203:../drivers/fsl_dma.h ****  *
 204:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 205:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 206:../drivers/fsl_dma.h ****  */
 207:../drivers/fsl_dma.h **** void DMA_ResetChannel(DMA_Type *base, uint32_t channel);
 208:../drivers/fsl_dma.h **** 
 209:../drivers/fsl_dma.h **** /*!
 210:../drivers/fsl_dma.h ****  * @brief Configures the DMA transfer attribute.
 211:../drivers/fsl_dma.h ****  *
 212:../drivers/fsl_dma.h ****  * This function configures the transfer attribute including the source address,
 213:../drivers/fsl_dma.h ****  * destination address, transfer size, and so on.
 214:../drivers/fsl_dma.h ****  * This example shows how to set up the the dma_transfer_config_t
 215:../drivers/fsl_dma.h ****  * parameters and how to call the DMA_ConfigBasicTransfer function.
 216:../drivers/fsl_dma.h ****  * @code
 217:../drivers/fsl_dma.h ****  *   dma_transfer_config_t transferConfig;
 218:../drivers/fsl_dma.h ****  *   memset(&transferConfig, 0, sizeof(transferConfig));
 219:../drivers/fsl_dma.h ****  *   transferConfig.srcAddr = (uint32_t)srcAddr;
 220:../drivers/fsl_dma.h ****  *   transferConfig.destAddr = (uint32_t)destAddr;
 221:../drivers/fsl_dma.h ****  *   transferConfig.enbaleSrcIncrement = true;
 222:../drivers/fsl_dma.h ****  *   transferConfig.enableDestIncrement = true;
 223:../drivers/fsl_dma.h ****  *   transferConfig.srcSize = kDMA_Transfersize32bits;
 224:../drivers/fsl_dma.h ****  *   transferConfig.destSize = kDMA_Transfersize32bits;
 225:../drivers/fsl_dma.h ****  *   transferConfig.transferSize = sizeof(uint32_t) * BUFF_LENGTH;
 226:../drivers/fsl_dma.h ****  *   DMA_SetTransferConfig(DMA0, 0, &transferConfig);
 227:../drivers/fsl_dma.h ****  * @endcode
 228:../drivers/fsl_dma.h ****  *
 229:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 230:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 231:../drivers/fsl_dma.h ****  * @param config Pointer to the DMA transfer configuration structure.
 232:../drivers/fsl_dma.h ****  */
 233:../drivers/fsl_dma.h **** void DMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const dma_transfer_config_t *config);
 234:../drivers/fsl_dma.h **** 
 235:../drivers/fsl_dma.h **** /*!
 236:../drivers/fsl_dma.h ****  * @brief Configures the DMA channel link feature.
 237:../drivers/fsl_dma.h ****  *
 238:../drivers/fsl_dma.h ****  * This function allows DMA channels to have their transfers linked. The current DMA channel
 239:../drivers/fsl_dma.h ****  * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the channel link
 240:../drivers/fsl_dma.h ****  * type.
 241:../drivers/fsl_dma.h ****  * Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2
 242:../drivers/fsl_dma.h ****  * after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1AndChannel2.
 243:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after each cycle-steal transfer if the type is kDMA_ChannelLinkChannel1.
 244:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1Afte
 245:../drivers/fsl_dma.h ****  *
 246:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 247:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 248:../drivers/fsl_dma.h ****  * @param config Pointer to the channel link configuration structure.
 249:../drivers/fsl_dma.h ****  */
 250:../drivers/fsl_dma.h **** void DMA_SetChannelLinkConfig(DMA_Type *base, uint32_t channel, const dma_channel_link_config_t *co
 251:../drivers/fsl_dma.h **** 
 252:../drivers/fsl_dma.h **** /*!
 253:../drivers/fsl_dma.h ****  * @brief Sets the DMA source address for the DMA transfer.
 254:../drivers/fsl_dma.h ****  *
 255:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 256:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 257:../drivers/fsl_dma.h ****  * @param srcAddr DMA source address.
 258:../drivers/fsl_dma.h ****  */
 259:../drivers/fsl_dma.h **** static inline void DMA_SetSourceAddress(DMA_Type *base, uint32_t channel, uint32_t srcAddr)
 260:../drivers/fsl_dma.h **** {
 261:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 262:../drivers/fsl_dma.h **** 
 263:../drivers/fsl_dma.h ****     base->DMA[channel].SAR = srcAddr;
 264:../drivers/fsl_dma.h **** }
 265:../drivers/fsl_dma.h **** 
 266:../drivers/fsl_dma.h **** /*!
 267:../drivers/fsl_dma.h ****  * @brief Sets the DMA destination address for the DMA transfer.
 268:../drivers/fsl_dma.h ****  *
 269:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 270:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 271:../drivers/fsl_dma.h ****  * @param destAddr DMA destination address.
 272:../drivers/fsl_dma.h ****  */
 273:../drivers/fsl_dma.h **** static inline void DMA_SetDestinationAddress(DMA_Type *base, uint32_t channel, uint32_t destAddr)
 274:../drivers/fsl_dma.h **** {
 275:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 276:../drivers/fsl_dma.h **** 
 277:../drivers/fsl_dma.h ****     base->DMA[channel].DAR = destAddr;
 278:../drivers/fsl_dma.h **** }
 279:../drivers/fsl_dma.h **** 
 280:../drivers/fsl_dma.h **** /*!
 281:../drivers/fsl_dma.h ****  * @brief Sets the DMA transfer size for the DMA transfer.
 282:../drivers/fsl_dma.h ****  *
 283:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 284:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 285:../drivers/fsl_dma.h ****  * @param size The number of bytes to be transferred.
 286:../drivers/fsl_dma.h ****  */
 287:../drivers/fsl_dma.h **** static inline void DMA_SetTransferSize(DMA_Type *base, uint32_t channel, uint32_t size)
 288:../drivers/fsl_dma.h **** {
 289:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 290:../drivers/fsl_dma.h **** 
 291:../drivers/fsl_dma.h ****     base->DMA[channel].DSR_BCR = DMA_DSR_BCR_BCR(size);
 292:../drivers/fsl_dma.h **** }
 293:../drivers/fsl_dma.h **** 
 294:../drivers/fsl_dma.h **** /*!
 295:../drivers/fsl_dma.h ****  * @brief Sets the DMA modulo for the DMA transfer.
 296:../drivers/fsl_dma.h ****  *
 297:../drivers/fsl_dma.h ****  * This function defines a specific address range specified to be the value after (SAR + SSIZE)/(DA
 298:../drivers/fsl_dma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 299:../drivers/fsl_dma.h ****  * data queue easily.
 300:../drivers/fsl_dma.h ****  *
 301:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 302:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 303:../drivers/fsl_dma.h ****  * @param srcModulo source address modulo.
 304:../drivers/fsl_dma.h ****  * @param destModulo destination address modulo.
 305:../drivers/fsl_dma.h ****  */
 306:../drivers/fsl_dma.h **** void DMA_SetModulo(DMA_Type *base, uint32_t channel, dma_modulo_t srcModulo, dma_modulo_t destModul
 307:../drivers/fsl_dma.h **** 
 308:../drivers/fsl_dma.h **** /*!
 309:../drivers/fsl_dma.h ****  * @brief Enables the DMA cycle steal for the DMA transfer.
 310:../drivers/fsl_dma.h ****  *
 311:../drivers/fsl_dma.h ****  * If the cycle steal feature is enabled (true), the DMA controller forces a single read/write tran
 312:../drivers/fsl_dma.h ****  *  or it continuously makes read/write transfers until the BCR decrements to 0.
 313:../drivers/fsl_dma.h ****  *
 314:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 315:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 316:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 317:../drivers/fsl_dma.h ****  */
 318:../drivers/fsl_dma.h **** static inline void DMA_EnableCycleSteal(DMA_Type *base, uint32_t channel, bool enable)
 319:../drivers/fsl_dma.h **** {
 320:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 321:../drivers/fsl_dma.h **** 
 322:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_CS_MASK)) | DMA_DCR_CS(enable);
 323:../drivers/fsl_dma.h **** }
 324:../drivers/fsl_dma.h **** 
 325:../drivers/fsl_dma.h **** /*!
 326:../drivers/fsl_dma.h ****  * @brief Enables the DMA auto align for the DMA transfer.
 327:../drivers/fsl_dma.h ****  *
 328:../drivers/fsl_dma.h ****  * If the auto align feature is enabled (true), the appropriate address register increments
 329:../drivers/fsl_dma.h ****  * regardless of DINC or SINC.
 330:../drivers/fsl_dma.h ****  *
 331:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 332:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 333:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 334:../drivers/fsl_dma.h ****  */
 335:../drivers/fsl_dma.h **** static inline void DMA_EnableAutoAlign(DMA_Type *base, uint32_t channel, bool enable)
 336:../drivers/fsl_dma.h **** {
 337:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 338:../drivers/fsl_dma.h **** 
 339:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_AA_MASK)) | DMA_DCR_AA(enable);
 340:../drivers/fsl_dma.h **** }
 341:../drivers/fsl_dma.h **** 
 342:../drivers/fsl_dma.h **** /*!
 343:../drivers/fsl_dma.h ****  * @brief Enables the DMA async request for the DMA transfer.
 344:../drivers/fsl_dma.h ****  *
 345:../drivers/fsl_dma.h ****  * If the async request feature is enabled (true), the DMA supports asynchronous DREQs
 346:../drivers/fsl_dma.h ****  * while the MCU is in stop mode.
 347:../drivers/fsl_dma.h ****  *
 348:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 349:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 350:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 351:../drivers/fsl_dma.h ****  */
 352:../drivers/fsl_dma.h **** static inline void DMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 353:../drivers/fsl_dma.h **** {
 354:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 355:../drivers/fsl_dma.h **** 
 356:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_EADREQ_MASK)) | DMA_DCR_EADREQ(ena
 357:../drivers/fsl_dma.h **** }
 358:../drivers/fsl_dma.h **** 
 359:../drivers/fsl_dma.h **** /*!
 360:../drivers/fsl_dma.h ****  * @brief Enables an interrupt for the DMA transfer.
 361:../drivers/fsl_dma.h ****  *
 362:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 363:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 364:../drivers/fsl_dma.h ****  */
 365:../drivers/fsl_dma.h **** static inline void DMA_EnableInterrupts(DMA_Type *base, uint32_t channel)
 366:../drivers/fsl_dma.h **** {
 367:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 368:../drivers/fsl_dma.h **** 
 369:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_EINT(true);
 723              		.loc 5 369 0
 724 0030 1201     		lsls	r2, r2, #4
 725              	.LVL63:
 726 0032 9B18     		adds	r3, r3, r2
 727              	.LVL64:
 728 0034 0D33     		adds	r3, r3, #13
 729 0036 FF33     		adds	r3, r3, #255
 730 0038 1968     		ldr	r1, [r3]
 731 003a 8022     		movs	r2, #128
 732 003c 1206     		lsls	r2, r2, #24
 733 003e 0A43     		orrs	r2, r1
 734 0040 1A60     		str	r2, [r3]
 735              	.LVL65:
 736              	.LBE25:
 737              	.LBE24:
 274:../drivers/fsl_dma.c ****     }
 275:../drivers/fsl_dma.c ****     return kStatus_Success;
 738              		.loc 1 275 0
 739 0042 0020     		movs	r0, #0
 740 0044 00E0     		b	.L43
 741              	.LVL66:
 742              	.L45:
 267:../drivers/fsl_dma.c ****     }
 743              		.loc 1 267 0
 744 0046 0248     		ldr	r0, .L47
 745              	.LVL67:
 746              	.L43:
 276:../drivers/fsl_dma.c **** }
 747              		.loc 1 276 0
 748              		@ sp needed
 749              	.LVL68:
 750              	.LVL69:
 751              	.LVL70:
 752 0048 70BD     		pop	{r4, r5, r6, pc}
 753              	.LVL71:
 754              	.L46:
 275:../drivers/fsl_dma.c **** }
 755              		.loc 1 275 0
 756 004a 0020     		movs	r0, #0
 757 004c FCE7     		b	.L43
 758              	.L48:
 759 004e C046     		.align	2
 760              	.L47:
 761 0050 88130000 		.word	5000
 762              		.cfi_endproc
 763              	.LFE79:
 765              		.section	.text.DMA_AbortTransfer,"ax",%progbits
 766              		.align	1
 767              		.global	DMA_AbortTransfer
 768              		.syntax unified
 769              		.code	16
 770              		.thumb_func
 771              		.fpu softvfp
 773              	DMA_AbortTransfer:
 774              	.LFB80:
 277:../drivers/fsl_dma.c **** 
 278:../drivers/fsl_dma.c **** void DMA_AbortTransfer(dma_handle_t *handle)
 279:../drivers/fsl_dma.c **** {
 775              		.loc 1 279 0
 776              		.cfi_startproc
 777              		@ args = 0, pretend = 0, frame = 0
 778              		@ frame_needed = 0, uses_anonymous_args = 0
 779              		@ link register save eliminated.
 780              	.LVL72:
 280:../drivers/fsl_dma.c ****     assert(handle != NULL);
 281:../drivers/fsl_dma.c **** 
 282:../drivers/fsl_dma.c ****     handle->base->DMA[handle->channel].DCR &= ~DMA_DCR_ERQ_MASK;
 781              		.loc 1 282 0
 782 0000 0379     		ldrb	r3, [r0, #4]
 783 0002 1B01     		lsls	r3, r3, #4
 784 0004 0268     		ldr	r2, [r0]
 785 0006 9446     		mov	ip, r2
 786 0008 6344     		add	r3, r3, ip
 787 000a 0D33     		adds	r3, r3, #13
 788 000c FF33     		adds	r3, r3, #255
 789 000e 1A68     		ldr	r2, [r3]
 790 0010 0749     		ldr	r1, .L50
 791 0012 0A40     		ands	r2, r1
 792 0014 1A60     		str	r2, [r3]
 283:../drivers/fsl_dma.c ****     /* clear all status bit */
 284:../drivers/fsl_dma.c ****     handle->base->DMA[handle->channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 793              		.loc 1 284 0
 794 0016 0368     		ldr	r3, [r0]
 795 0018 0279     		ldrb	r2, [r0, #4]
 796 001a 1201     		lsls	r2, r2, #4
 797 001c 9B18     		adds	r3, r3, r2
 798 001e 0933     		adds	r3, r3, #9
 799 0020 FF33     		adds	r3, r3, #255
 800 0022 1968     		ldr	r1, [r3]
 801 0024 8022     		movs	r2, #128
 802 0026 5204     		lsls	r2, r2, #17
 803 0028 0A43     		orrs	r2, r1
 804 002a 1A60     		str	r2, [r3]
 285:../drivers/fsl_dma.c **** }
 805              		.loc 1 285 0
 806              		@ sp needed
 807 002c 7047     		bx	lr
 808              	.L51:
 809 002e C046     		.align	2
 810              	.L50:
 811 0030 FFFFFFBF 		.word	-1073741825
 812              		.cfi_endproc
 813              	.LFE80:
 815              		.section	.text.DMA_HandleIRQ,"ax",%progbits
 816              		.align	1
 817              		.global	DMA_HandleIRQ
 818              		.syntax unified
 819              		.code	16
 820              		.thumb_func
 821              		.fpu softvfp
 823              	DMA_HandleIRQ:
 824              	.LFB81:
 286:../drivers/fsl_dma.c **** 
 287:../drivers/fsl_dma.c **** void DMA_HandleIRQ(dma_handle_t *handle)
 288:../drivers/fsl_dma.c **** {
 825              		.loc 1 288 0
 826              		.cfi_startproc
 827              		@ args = 0, pretend = 0, frame = 0
 828              		@ frame_needed = 0, uses_anonymous_args = 0
 829              	.LVL73:
 830 0000 10B5     		push	{r4, lr}
 831              		.cfi_def_cfa_offset 8
 832              		.cfi_offset 4, -8
 833              		.cfi_offset 14, -4
 289:../drivers/fsl_dma.c ****     assert(handle != NULL);
 290:../drivers/fsl_dma.c **** 
 291:../drivers/fsl_dma.c ****     /* Clear interrupt pending bit */
 292:../drivers/fsl_dma.c ****     DMA_ClearChannelStatusFlags(handle->base, handle->channel, kDMA_TransactionsDoneFlag);
 834              		.loc 1 292 0
 835 0002 0379     		ldrb	r3, [r0, #4]
 836              	.LVL74:
 837              	.LBB26:
 838              	.LBB27:
 370:../drivers/fsl_dma.h **** }
 371:../drivers/fsl_dma.h **** 
 372:../drivers/fsl_dma.h **** /*!
 373:../drivers/fsl_dma.h ****  * @brief Disables an interrupt for the DMA transfer.
 374:../drivers/fsl_dma.h ****  *
 375:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 376:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 377:../drivers/fsl_dma.h ****  */
 378:../drivers/fsl_dma.h **** static inline void DMA_DisableInterrupts(DMA_Type *base, uint32_t channel)
 379:../drivers/fsl_dma.h **** {
 380:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 381:../drivers/fsl_dma.h **** 
 382:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_EINT_MASK;
 383:../drivers/fsl_dma.h **** }
 384:../drivers/fsl_dma.h **** 
 385:../drivers/fsl_dma.h **** /* @} */
 386:../drivers/fsl_dma.h **** /*!
 387:../drivers/fsl_dma.h ****  * @name DMA Channel Transfer Operation
 388:../drivers/fsl_dma.h ****  * @{
 389:../drivers/fsl_dma.h ****  */
 390:../drivers/fsl_dma.h **** 
 391:../drivers/fsl_dma.h **** /*!
 392:../drivers/fsl_dma.h ****  * @brief Enables the DMA hardware channel request.
 393:../drivers/fsl_dma.h ****  *
 394:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 395:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 396:../drivers/fsl_dma.h ****  */
 397:../drivers/fsl_dma.h **** static inline void DMA_EnableChannelRequest(DMA_Type *base, uint32_t channel)
 398:../drivers/fsl_dma.h **** {
 399:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 400:../drivers/fsl_dma.h **** 
 401:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_ERQ_MASK;
 402:../drivers/fsl_dma.h **** }
 403:../drivers/fsl_dma.h **** 
 404:../drivers/fsl_dma.h **** /*!
 405:../drivers/fsl_dma.h ****  * @brief Disables the DMA hardware channel request.
 406:../drivers/fsl_dma.h ****  *
 407:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 408:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 409:../drivers/fsl_dma.h ****  */
 410:../drivers/fsl_dma.h **** static inline void DMA_DisableChannelRequest(DMA_Type *base, uint32_t channel)
 411:../drivers/fsl_dma.h **** {
 412:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 413:../drivers/fsl_dma.h **** 
 414:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_ERQ_MASK;
 415:../drivers/fsl_dma.h **** }
 416:../drivers/fsl_dma.h **** 
 417:../drivers/fsl_dma.h **** /*!
 418:../drivers/fsl_dma.h ****  * @brief Starts the DMA transfer with a software trigger.
 419:../drivers/fsl_dma.h ****  *
 420:../drivers/fsl_dma.h ****  * This function starts only one read/write iteration.
 421:../drivers/fsl_dma.h ****  *
 422:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 423:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 424:../drivers/fsl_dma.h ****  */
 425:../drivers/fsl_dma.h **** static inline void DMA_TriggerChannelStart(DMA_Type *base, uint32_t channel)
 426:../drivers/fsl_dma.h **** {
 427:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 428:../drivers/fsl_dma.h **** 
 429:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_START_MASK;
 430:../drivers/fsl_dma.h **** }
 431:../drivers/fsl_dma.h **** 
 432:../drivers/fsl_dma.h **** /* @} */
 433:../drivers/fsl_dma.h **** /*!
 434:../drivers/fsl_dma.h ****  * @name DMA Channel Status Operation
 435:../drivers/fsl_dma.h ****  * @{
 436:../drivers/fsl_dma.h ****  */
 437:../drivers/fsl_dma.h **** 
 438:../drivers/fsl_dma.h **** /*!
 439:../drivers/fsl_dma.h ****  * @brief Gets the remaining bytes of the current DMA transfer.
 440:../drivers/fsl_dma.h ****  *
 441:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 442:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 443:../drivers/fsl_dma.h ****  * @return The number of bytes which have not been transferred yet.
 444:../drivers/fsl_dma.h ****  */
 445:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetRemainingBytes(DMA_Type *base, uint32_t channel)
 446:../drivers/fsl_dma.h **** {
 447:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 448:../drivers/fsl_dma.h **** 
 449:../drivers/fsl_dma.h ****     return (base->DMA[channel].DSR_BCR & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT;
 450:../drivers/fsl_dma.h **** }
 451:../drivers/fsl_dma.h **** 
 452:../drivers/fsl_dma.h **** /*!
 453:../drivers/fsl_dma.h ****  * @brief Gets the DMA channel status flags.
 454:../drivers/fsl_dma.h ****  *
 455:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 456:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 457:../drivers/fsl_dma.h ****  * @return The mask of the channel status. Use the _dma_channel_status_flags
 458:../drivers/fsl_dma.h ****  *         type to decode the return 32 bit variables.
 459:../drivers/fsl_dma.h ****  */
 460:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetChannelStatusFlags(DMA_Type *base, uint32_t channel)
 461:../drivers/fsl_dma.h **** {
 462:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 463:../drivers/fsl_dma.h **** 
 464:../drivers/fsl_dma.h ****     return base->DMA[channel].DSR_BCR;
 465:../drivers/fsl_dma.h **** }
 466:../drivers/fsl_dma.h **** 
 467:../drivers/fsl_dma.h **** /*!
 468:../drivers/fsl_dma.h ****  * @brief Clears the DMA channel status flags.
 469:../drivers/fsl_dma.h ****  *
 470:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 471:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 472:../drivers/fsl_dma.h ****  * @param mask The mask of the channel status to be cleared. Use
 473:../drivers/fsl_dma.h ****  *             the defined _dma_channel_status_flags type.
 474:../drivers/fsl_dma.h ****  */
 475:../drivers/fsl_dma.h **** static inline void DMA_ClearChannelStatusFlags(DMA_Type *base, uint32_t channel, uint32_t mask)
 476:../drivers/fsl_dma.h **** {
 477:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 478:../drivers/fsl_dma.h **** 
 479:../drivers/fsl_dma.h ****     if (mask != 0U)
 480:../drivers/fsl_dma.h ****     {
 481:../drivers/fsl_dma.h ****         base->DMA[channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 839              		.loc 5 481 0
 840 0004 1B01     		lsls	r3, r3, #4
 841              	.LVL75:
 842 0006 0268     		ldr	r2, [r0]
 843 0008 9446     		mov	ip, r2
 844 000a 6344     		add	r3, r3, ip
 845 000c 0933     		adds	r3, r3, #9
 846 000e FF33     		adds	r3, r3, #255
 847 0010 1968     		ldr	r1, [r3]
 848 0012 8022     		movs	r2, #128
 849 0014 5204     		lsls	r2, r2, #17
 850 0016 0A43     		orrs	r2, r1
 851 0018 1A60     		str	r2, [r3]
 852              	.LVL76:
 853              	.LBE27:
 854              	.LBE26:
 293:../drivers/fsl_dma.c ****     if (handle->callback)
 855              		.loc 1 293 0
 856 001a 8368     		ldr	r3, [r0, #8]
 857 001c 002B     		cmp	r3, #0
 858 001e 01D0     		beq	.L52
 294:../drivers/fsl_dma.c ****     {
 295:../drivers/fsl_dma.c ****         (handle->callback)(handle, handle->userData);
 859              		.loc 1 295 0
 860 0020 C168     		ldr	r1, [r0, #12]
 861 0022 9847     		blx	r3
 862              	.LVL77:
 863              	.L52:
 296:../drivers/fsl_dma.c ****     }
 297:../drivers/fsl_dma.c **** }
 864              		.loc 1 297 0
 865              		@ sp needed
 866 0024 10BD     		pop	{r4, pc}
 867              		.cfi_endproc
 868              	.LFE81:
 870              		.section	.text.DMA0_DriverIRQHandler,"ax",%progbits
 871              		.align	1
 872              		.global	DMA0_DriverIRQHandler
 873              		.syntax unified
 874              		.code	16
 875              		.thumb_func
 876              		.fpu softvfp
 878              	DMA0_DriverIRQHandler:
 879              	.LFB82:
 298:../drivers/fsl_dma.c **** 
 299:../drivers/fsl_dma.c **** #if defined(FSL_FEATURE_DMA_MODULE_CHANNEL) && (FSL_FEATURE_DMA_MODULE_CHANNEL == 4U)
 300:../drivers/fsl_dma.c **** void DMA0_DriverIRQHandler(void)
 301:../drivers/fsl_dma.c **** {
 880              		.loc 1 301 0
 881              		.cfi_startproc
 882              		@ args = 0, pretend = 0, frame = 0
 883              		@ frame_needed = 0, uses_anonymous_args = 0
 884 0000 10B5     		push	{r4, lr}
 885              		.cfi_def_cfa_offset 8
 886              		.cfi_offset 4, -8
 887              		.cfi_offset 14, -4
 302:../drivers/fsl_dma.c ****     DMA_HandleIRQ(s_DMAHandle[0]);
 888              		.loc 1 302 0
 889 0002 024B     		ldr	r3, .L55
 890 0004 1868     		ldr	r0, [r3]
 891 0006 FFF7FEFF 		bl	DMA_HandleIRQ
 892              	.LVL78:
 303:../drivers/fsl_dma.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
 304:../drivers/fsl_dma.c ****       exception return operation might vector to incorrect interrupt */
 305:../drivers/fsl_dma.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
 306:../drivers/fsl_dma.c ****     __DSB();
 307:../drivers/fsl_dma.c **** #endif
 308:../drivers/fsl_dma.c **** }
 893              		.loc 1 308 0
 894              		@ sp needed
 895 000a 10BD     		pop	{r4, pc}
 896              	.L56:
 897              		.align	2
 898              	.L55:
 899 000c 00000000 		.word	.LANCHOR0
 900              		.cfi_endproc
 901              	.LFE82:
 903              		.section	.text.DMA1_DriverIRQHandler,"ax",%progbits
 904              		.align	1
 905              		.global	DMA1_DriverIRQHandler
 906              		.syntax unified
 907              		.code	16
 908              		.thumb_func
 909              		.fpu softvfp
 911              	DMA1_DriverIRQHandler:
 912              	.LFB83:
 309:../drivers/fsl_dma.c **** 
 310:../drivers/fsl_dma.c **** void DMA1_DriverIRQHandler(void)
 311:../drivers/fsl_dma.c **** {
 913              		.loc 1 311 0
 914              		.cfi_startproc
 915              		@ args = 0, pretend = 0, frame = 0
 916              		@ frame_needed = 0, uses_anonymous_args = 0
 917 0000 10B5     		push	{r4, lr}
 918              		.cfi_def_cfa_offset 8
 919              		.cfi_offset 4, -8
 920              		.cfi_offset 14, -4
 312:../drivers/fsl_dma.c ****     DMA_HandleIRQ(s_DMAHandle[1]);
 921              		.loc 1 312 0
 922 0002 024B     		ldr	r3, .L58
 923 0004 5868     		ldr	r0, [r3, #4]
 924 0006 FFF7FEFF 		bl	DMA_HandleIRQ
 925              	.LVL79:
 313:../drivers/fsl_dma.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
 314:../drivers/fsl_dma.c ****       exception return operation might vector to incorrect interrupt */
 315:../drivers/fsl_dma.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
 316:../drivers/fsl_dma.c ****     __DSB();
 317:../drivers/fsl_dma.c **** #endif
 318:../drivers/fsl_dma.c **** }
 926              		.loc 1 318 0
 927              		@ sp needed
 928 000a 10BD     		pop	{r4, pc}
 929              	.L59:
 930              		.align	2
 931              	.L58:
 932 000c 00000000 		.word	.LANCHOR0
 933              		.cfi_endproc
 934              	.LFE83:
 936              		.section	.text.DMA2_DriverIRQHandler,"ax",%progbits
 937              		.align	1
 938              		.global	DMA2_DriverIRQHandler
 939              		.syntax unified
 940              		.code	16
 941              		.thumb_func
 942              		.fpu softvfp
 944              	DMA2_DriverIRQHandler:
 945              	.LFB84:
 319:../drivers/fsl_dma.c **** 
 320:../drivers/fsl_dma.c **** void DMA2_DriverIRQHandler(void)
 321:../drivers/fsl_dma.c **** {
 946              		.loc 1 321 0
 947              		.cfi_startproc
 948              		@ args = 0, pretend = 0, frame = 0
 949              		@ frame_needed = 0, uses_anonymous_args = 0
 950 0000 10B5     		push	{r4, lr}
 951              		.cfi_def_cfa_offset 8
 952              		.cfi_offset 4, -8
 953              		.cfi_offset 14, -4
 322:../drivers/fsl_dma.c ****     DMA_HandleIRQ(s_DMAHandle[2]);
 954              		.loc 1 322 0
 955 0002 024B     		ldr	r3, .L61
 956 0004 9868     		ldr	r0, [r3, #8]
 957 0006 FFF7FEFF 		bl	DMA_HandleIRQ
 958              	.LVL80:
 323:../drivers/fsl_dma.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
 324:../drivers/fsl_dma.c ****       exception return operation might vector to incorrect interrupt */
 325:../drivers/fsl_dma.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
 326:../drivers/fsl_dma.c ****     __DSB();
 327:../drivers/fsl_dma.c **** #endif
 328:../drivers/fsl_dma.c **** }
 959              		.loc 1 328 0
 960              		@ sp needed
 961 000a 10BD     		pop	{r4, pc}
 962              	.L62:
 963              		.align	2
 964              	.L61:
 965 000c 00000000 		.word	.LANCHOR0
 966              		.cfi_endproc
 967              	.LFE84:
 969              		.section	.text.DMA3_DriverIRQHandler,"ax",%progbits
 970              		.align	1
 971              		.global	DMA3_DriverIRQHandler
 972              		.syntax unified
 973              		.code	16
 974              		.thumb_func
 975              		.fpu softvfp
 977              	DMA3_DriverIRQHandler:
 978              	.LFB85:
 329:../drivers/fsl_dma.c **** 
 330:../drivers/fsl_dma.c **** void DMA3_DriverIRQHandler(void)
 331:../drivers/fsl_dma.c **** {
 979              		.loc 1 331 0
 980              		.cfi_startproc
 981              		@ args = 0, pretend = 0, frame = 0
 982              		@ frame_needed = 0, uses_anonymous_args = 0
 983 0000 10B5     		push	{r4, lr}
 984              		.cfi_def_cfa_offset 8
 985              		.cfi_offset 4, -8
 986              		.cfi_offset 14, -4
 332:../drivers/fsl_dma.c ****     DMA_HandleIRQ(s_DMAHandle[3]);
 987              		.loc 1 332 0
 988 0002 024B     		ldr	r3, .L64
 989 0004 D868     		ldr	r0, [r3, #12]
 990 0006 FFF7FEFF 		bl	DMA_HandleIRQ
 991              	.LVL81:
 333:../drivers/fsl_dma.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
 334:../drivers/fsl_dma.c ****       exception return operation might vector to incorrect interrupt */
 335:../drivers/fsl_dma.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
 336:../drivers/fsl_dma.c ****     __DSB();
 337:../drivers/fsl_dma.c **** #endif
 338:../drivers/fsl_dma.c **** }
 992              		.loc 1 338 0
 993              		@ sp needed
 994 000a 10BD     		pop	{r4, pc}
 995              	.L65:
 996              		.align	2
 997              	.L64:
 998 000c 00000000 		.word	.LANCHOR0
 999              		.cfi_endproc
 1000              	.LFE85:
 1002              		.section	.bss.s_DMAHandle,"aw",%nobits
 1003              		.align	2
 1004              		.set	.LANCHOR0,. + 0
 1007              	s_DMAHandle:
 1008 0000 00000000 		.space	16
 1008      00000000 
 1008      00000000 
 1008      00000000 
 1009              		.section	.rodata.s_dmaIRQNumber,"a",%progbits
 1010              		.align	2
 1011              		.set	.LANCHOR1,. + 0
 1014              	s_dmaIRQNumber:
 1015 0000 00       		.byte	0
 1016 0001 01       		.byte	1
 1017 0002 02       		.byte	2
 1018 0003 03       		.byte	3
 1019              		.text
 1020              	.Letext0:
 1021              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1022              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1023              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1024              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1025              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1026              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1027              		.file 12 "../CMSIS/MKL17Z4.h"
 1028              		.file 13 "../CMSIS/system_MKL17Z4.h"
 1029              		.file 14 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_dma.c
     /tmp/ccq0PCLJ.s:16     .text.DMA_GetInstance:0000000000000000 $t
     /tmp/ccq0PCLJ.s:22     .text.DMA_GetInstance:0000000000000000 DMA_GetInstance
     /tmp/ccq0PCLJ.s:57     .text.DMA_GetInstance:0000000000000014 $d
     /tmp/ccq0PCLJ.s:62     .text.DMA_Init:0000000000000000 $t
     /tmp/ccq0PCLJ.s:69     .text.DMA_Init:0000000000000000 DMA_Init
     /tmp/ccq0PCLJ.s:102    .text.DMA_Init:0000000000000014 $d
     /tmp/ccq0PCLJ.s:107    .text.DMA_Deinit:0000000000000000 $t
     /tmp/ccq0PCLJ.s:114    .text.DMA_Deinit:0000000000000000 DMA_Deinit
     /tmp/ccq0PCLJ.s:145    .text.DMA_Deinit:0000000000000014 $d
     /tmp/ccq0PCLJ.s:151    .text.DMA_ResetChannel:0000000000000000 $t
     /tmp/ccq0PCLJ.s:158    .text.DMA_ResetChannel:0000000000000000 DMA_ResetChannel
     /tmp/ccq0PCLJ.s:204    .text.DMA_ResetChannel:0000000000000030 $d
     /tmp/ccq0PCLJ.s:209    .text.DMA_SetTransferConfig:0000000000000000 $t
     /tmp/ccq0PCLJ.s:216    .text.DMA_SetTransferConfig:0000000000000000 DMA_SetTransferConfig
     /tmp/ccq0PCLJ.s:298    .text.DMA_SetTransferConfig:0000000000000064 $d
     /tmp/ccq0PCLJ.s:303    .text.DMA_SetChannelLinkConfig:0000000000000000 $t
     /tmp/ccq0PCLJ.s:310    .text.DMA_SetChannelLinkConfig:0000000000000000 DMA_SetChannelLinkConfig
     /tmp/ccq0PCLJ.s:363    .text.DMA_SetModulo:0000000000000000 $t
     /tmp/ccq0PCLJ.s:370    .text.DMA_SetModulo:0000000000000000 DMA_SetModulo
     /tmp/ccq0PCLJ.s:414    .text.DMA_SetModulo:0000000000000024 $d
     /tmp/ccq0PCLJ.s:419    .text.DMA_CreateHandle:0000000000000000 $t
     /tmp/ccq0PCLJ.s:426    .text.DMA_CreateHandle:0000000000000000 DMA_CreateHandle
     /tmp/ccq0PCLJ.s:511    .text.DMA_CreateHandle:0000000000000048 $d
     /tmp/ccq0PCLJ.s:518    .text.DMA_PrepareTransfer:0000000000000000 $t
     /tmp/ccq0PCLJ.s:525    .text.DMA_PrepareTransfer:0000000000000000 DMA_PrepareTransfer
     /tmp/ccq0PCLJ.s:643    .text.DMA_SetCallback:0000000000000000 $t
     /tmp/ccq0PCLJ.s:650    .text.DMA_SetCallback:0000000000000000 DMA_SetCallback
     /tmp/ccq0PCLJ.s:669    .text.DMA_SubmitTransfer:0000000000000000 $t
     /tmp/ccq0PCLJ.s:676    .text.DMA_SubmitTransfer:0000000000000000 DMA_SubmitTransfer
     /tmp/ccq0PCLJ.s:761    .text.DMA_SubmitTransfer:0000000000000050 $d
     /tmp/ccq0PCLJ.s:766    .text.DMA_AbortTransfer:0000000000000000 $t
     /tmp/ccq0PCLJ.s:773    .text.DMA_AbortTransfer:0000000000000000 DMA_AbortTransfer
     /tmp/ccq0PCLJ.s:811    .text.DMA_AbortTransfer:0000000000000030 $d
     /tmp/ccq0PCLJ.s:816    .text.DMA_HandleIRQ:0000000000000000 $t
     /tmp/ccq0PCLJ.s:823    .text.DMA_HandleIRQ:0000000000000000 DMA_HandleIRQ
     /tmp/ccq0PCLJ.s:871    .text.DMA0_DriverIRQHandler:0000000000000000 $t
     /tmp/ccq0PCLJ.s:878    .text.DMA0_DriverIRQHandler:0000000000000000 DMA0_DriverIRQHandler
     /tmp/ccq0PCLJ.s:899    .text.DMA0_DriverIRQHandler:000000000000000c $d
     /tmp/ccq0PCLJ.s:904    .text.DMA1_DriverIRQHandler:0000000000000000 $t
     /tmp/ccq0PCLJ.s:911    .text.DMA1_DriverIRQHandler:0000000000000000 DMA1_DriverIRQHandler
     /tmp/ccq0PCLJ.s:932    .text.DMA1_DriverIRQHandler:000000000000000c $d
     /tmp/ccq0PCLJ.s:937    .text.DMA2_DriverIRQHandler:0000000000000000 $t
     /tmp/ccq0PCLJ.s:944    .text.DMA2_DriverIRQHandler:0000000000000000 DMA2_DriverIRQHandler
     /tmp/ccq0PCLJ.s:965    .text.DMA2_DriverIRQHandler:000000000000000c $d
     /tmp/ccq0PCLJ.s:970    .text.DMA3_DriverIRQHandler:0000000000000000 $t
     /tmp/ccq0PCLJ.s:977    .text.DMA3_DriverIRQHandler:0000000000000000 DMA3_DriverIRQHandler
     /tmp/ccq0PCLJ.s:998    .text.DMA3_DriverIRQHandler:000000000000000c $d
     /tmp/ccq0PCLJ.s:1003   .bss.s_DMAHandle:0000000000000000 $d
     /tmp/ccq0PCLJ.s:1007   .bss.s_DMAHandle:0000000000000000 s_DMAHandle
     /tmp/ccq0PCLJ.s:1010   .rodata.s_dmaIRQNumber:0000000000000000 $d
     /tmp/ccq0PCLJ.s:1014   .rodata.s_dmaIRQNumber:0000000000000000 s_dmaIRQNumber

UNDEFINED SYMBOLS
memset
