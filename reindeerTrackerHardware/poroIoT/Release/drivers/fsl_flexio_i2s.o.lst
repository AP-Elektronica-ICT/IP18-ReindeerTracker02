   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_flexio_i2s.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_uidiv
  16              		.section	.text.FLEXIO_I2S_WriteNonBlocking,"ax",%progbits
  17              		.align	1
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	FLEXIO_I2S_WriteNonBlocking:
  24              	.LFB75:
  25              		.file 1 "../drivers/fsl_flexio_i2s.c"
   1:../drivers/fsl_flexio_i2s.c **** /*
   2:../drivers/fsl_flexio_i2s.c ****  * The Clear BSD License
   3:../drivers/fsl_flexio_i2s.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_flexio_i2s.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_flexio_i2s.c ****  * All rights reserved.
   6:../drivers/fsl_flexio_i2s.c ****  *
   7:../drivers/fsl_flexio_i2s.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_flexio_i2s.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_flexio_i2s.c ****  * that the following conditions are met:
  10:../drivers/fsl_flexio_i2s.c ****  *
  11:../drivers/fsl_flexio_i2s.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_flexio_i2s.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_flexio_i2s.c ****  *
  14:../drivers/fsl_flexio_i2s.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_flexio_i2s.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_flexio_i2s.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_flexio_i2s.c ****  *
  18:../drivers/fsl_flexio_i2s.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_flexio_i2s.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_flexio_i2s.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_flexio_i2s.c ****  *
  22:../drivers/fsl_flexio_i2s.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_flexio_i2s.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_flexio_i2s.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_flexio_i2s.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_flexio_i2s.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_flexio_i2s.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_flexio_i2s.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_flexio_i2s.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_flexio_i2s.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_flexio_i2s.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_flexio_i2s.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_flexio_i2s.c ****  */
  34:../drivers/fsl_flexio_i2s.c **** 
  35:../drivers/fsl_flexio_i2s.c **** #include "fsl_flexio_i2s.h"
  36:../drivers/fsl_flexio_i2s.c **** 
  37:../drivers/fsl_flexio_i2s.c **** /*******************************************************************************
  38:../drivers/fsl_flexio_i2s.c **** * Definitations
  39:../drivers/fsl_flexio_i2s.c **** ******************************************************************************/
  40:../drivers/fsl_flexio_i2s.c **** enum _sai_transfer_state
  41:../drivers/fsl_flexio_i2s.c **** {
  42:../drivers/fsl_flexio_i2s.c ****     kFLEXIO_I2S_Busy = 0x0U, /*!< FLEXIO_I2S is busy */
  43:../drivers/fsl_flexio_i2s.c ****     kFLEXIO_I2S_Idle,        /*!< Transfer is done. */
  44:../drivers/fsl_flexio_i2s.c **** };
  45:../drivers/fsl_flexio_i2s.c **** 
  46:../drivers/fsl_flexio_i2s.c **** /*******************************************************************************
  47:../drivers/fsl_flexio_i2s.c ****  * Prototypes
  48:../drivers/fsl_flexio_i2s.c ****  ******************************************************************************/
  49:../drivers/fsl_flexio_i2s.c **** 
  50:../drivers/fsl_flexio_i2s.c **** extern uint32_t FLEXIO_GetInstance(FLEXIO_Type *base);
  51:../drivers/fsl_flexio_i2s.c **** 
  52:../drivers/fsl_flexio_i2s.c **** /*!
  53:../drivers/fsl_flexio_i2s.c ****  * @brief Receive a piece of data in non-blocking way.
  54:../drivers/fsl_flexio_i2s.c ****  *
  55:../drivers/fsl_flexio_i2s.c ****  * @param base FLEXIO I2S base pointer
  56:../drivers/fsl_flexio_i2s.c ****  * @param bitWidth How many bits in a audio word, usually 8/16/24/32 bits.
  57:../drivers/fsl_flexio_i2s.c ****  * @param buffer Pointer to the data to be read.
  58:../drivers/fsl_flexio_i2s.c ****  * @param size Bytes to be read.
  59:../drivers/fsl_flexio_i2s.c ****  */
  60:../drivers/fsl_flexio_i2s.c **** static void FLEXIO_I2S_ReadNonBlocking(FLEXIO_I2S_Type *base, uint8_t bitWidth, uint8_t *rxData, si
  61:../drivers/fsl_flexio_i2s.c **** 
  62:../drivers/fsl_flexio_i2s.c **** /*!
  63:../drivers/fsl_flexio_i2s.c ****  * @brief sends a piece of data in non-blocking way.
  64:../drivers/fsl_flexio_i2s.c ****  *
  65:../drivers/fsl_flexio_i2s.c ****  * @param base FLEXIO I2S base pointer
  66:../drivers/fsl_flexio_i2s.c ****  * @param bitWidth How many bits in a audio word, usually 8/16/24/32 bits.
  67:../drivers/fsl_flexio_i2s.c ****  * @param buffer Pointer to the data to be written.
  68:../drivers/fsl_flexio_i2s.c ****  * @param size Bytes to be written.
  69:../drivers/fsl_flexio_i2s.c ****  */
  70:../drivers/fsl_flexio_i2s.c **** static void FLEXIO_I2S_WriteNonBlocking(FLEXIO_I2S_Type *base, uint8_t bitWidth, uint8_t *txData, s
  71:../drivers/fsl_flexio_i2s.c **** /*******************************************************************************
  72:../drivers/fsl_flexio_i2s.c ****  * Variables
  73:../drivers/fsl_flexio_i2s.c ****  ******************************************************************************/
  74:../drivers/fsl_flexio_i2s.c **** 
  75:../drivers/fsl_flexio_i2s.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  76:../drivers/fsl_flexio_i2s.c **** extern const clock_ip_name_t s_flexioClocks[];
  77:../drivers/fsl_flexio_i2s.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  78:../drivers/fsl_flexio_i2s.c **** 
  79:../drivers/fsl_flexio_i2s.c **** extern FLEXIO_Type *const s_flexioBases[];
  80:../drivers/fsl_flexio_i2s.c **** 
  81:../drivers/fsl_flexio_i2s.c **** /*******************************************************************************
  82:../drivers/fsl_flexio_i2s.c ****  * Code
  83:../drivers/fsl_flexio_i2s.c ****  ******************************************************************************/
  84:../drivers/fsl_flexio_i2s.c **** 
  85:../drivers/fsl_flexio_i2s.c **** uint32_t FLEXIO_I2S_GetInstance(FLEXIO_I2S_Type *base)
  86:../drivers/fsl_flexio_i2s.c **** {
  87:../drivers/fsl_flexio_i2s.c ****     return FLEXIO_GetInstance(base->flexioBase);
  88:../drivers/fsl_flexio_i2s.c **** }
  89:../drivers/fsl_flexio_i2s.c **** 
  90:../drivers/fsl_flexio_i2s.c **** static void FLEXIO_I2S_WriteNonBlocking(FLEXIO_I2S_Type *base, uint8_t bitWidth, uint8_t *txData, s
  91:../drivers/fsl_flexio_i2s.c **** {
  26              		.loc 1 91 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  32              		.cfi_def_cfa_offset 20
  33              		.cfi_offset 4, -20
  34              		.cfi_offset 5, -16
  35              		.cfi_offset 6, -12
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 C646     		mov	lr, r8
  39 0004 00B5     		push	{lr}
  40              		.cfi_def_cfa_offset 24
  41              		.cfi_offset 8, -24
  42 0006 82B0     		sub	sp, sp, #8
  43              		.cfi_def_cfa_offset 32
  44 0008 0500     		movs	r5, r0
  45 000a 8846     		mov	r8, r1
  46 000c 1400     		movs	r4, r2
  47 000e 0193     		str	r3, [sp, #4]
  48              	.LVL1:
  92:../drivers/fsl_flexio_i2s.c ****     uint32_t i = 0;
  93:../drivers/fsl_flexio_i2s.c ****     uint8_t j = 0;
  94:../drivers/fsl_flexio_i2s.c ****     uint8_t bytesPerWord = bitWidth / 8U;
  49              		.loc 1 94 0
  50 0010 CE08     		lsrs	r6, r1, #3
  51              	.LVL2:
  95:../drivers/fsl_flexio_i2s.c ****     uint32_t data = 0;
  96:../drivers/fsl_flexio_i2s.c ****     uint32_t temp = 0;
  97:../drivers/fsl_flexio_i2s.c **** 
  98:../drivers/fsl_flexio_i2s.c ****     for (i = 0; i < size / bytesPerWord; i++)
  52              		.loc 1 98 0
  53 0012 0027     		movs	r7, #0
  54 0014 12E0     		b	.L2
  55              	.LVL3:
  56              	.L3:
  99:../drivers/fsl_flexio_i2s.c ****     {
 100:../drivers/fsl_flexio_i2s.c ****         for (j = 0; j < bytesPerWord; j++)
 101:../drivers/fsl_flexio_i2s.c ****         {
 102:../drivers/fsl_flexio_i2s.c ****             temp = (uint32_t)(*txData);
  57              		.loc 1 102 0 discriminator 3
  58 0016 2278     		ldrb	r2, [r4]
  59              	.LVL4:
 103:../drivers/fsl_flexio_i2s.c ****             data |= (temp << (8U * j));
  60              		.loc 1 103 0 discriminator 3
  61 0018 D800     		lsls	r0, r3, #3
  62 001a 8240     		lsls	r2, r2, r0
  63              	.LVL5:
  64 001c 1143     		orrs	r1, r2
  65              	.LVL6:
 104:../drivers/fsl_flexio_i2s.c ****             txData++;
  66              		.loc 1 104 0 discriminator 3
  67 001e 0134     		adds	r4, r4, #1
  68              	.LVL7:
 100:../drivers/fsl_flexio_i2s.c ****         {
  69              		.loc 1 100 0 discriminator 3
  70 0020 0133     		adds	r3, r3, #1
  71              	.LVL8:
  72 0022 DBB2     		uxtb	r3, r3
  73              	.LVL9:
  74              	.L4:
 100:../drivers/fsl_flexio_i2s.c ****         {
  75              		.loc 1 100 0 is_stmt 0 discriminator 1
  76 0024 B342     		cmp	r3, r6
  77 0026 F6D3     		bcc	.L3
 105:../drivers/fsl_flexio_i2s.c ****         }
 106:../drivers/fsl_flexio_i2s.c ****         base->flexioBase->SHIFTBUFBIS[base->txShifterIndex] = (data << (32U - bitWidth));
  78              		.loc 1 106 0 is_stmt 1 discriminator 2
  79 0028 2022     		movs	r2, #32
  80 002a 4346     		mov	r3, r8
  81              	.LVL10:
  82 002c D21A     		subs	r2, r2, r3
  83 002e 2B7A     		ldrb	r3, [r5, #8]
  84 0030 9140     		lsls	r1, r1, r2
  85              	.LVL11:
  86 0032 A033     		adds	r3, r3, #160
  87 0034 9B00     		lsls	r3, r3, #2
  88 0036 2A68     		ldr	r2, [r5]
  89 0038 9950     		str	r1, [r3, r2]
  90              	.LVL12:
  98:../drivers/fsl_flexio_i2s.c ****     {
  91              		.loc 1 98 0 discriminator 2
  92 003a 0137     		adds	r7, r7, #1
  93              	.LVL13:
  94              	.L2:
  98:../drivers/fsl_flexio_i2s.c ****     {
  95              		.loc 1 98 0 is_stmt 0 discriminator 1
  96 003c 3100     		movs	r1, r6
  97 003e 0198     		ldr	r0, [sp, #4]
  98 0040 FFF7FEFF 		bl	__aeabi_uidiv
  99              	.LVL14:
 100 0044 B842     		cmp	r0, r7
 101 0046 02D9     		bls	.L6
 102 0048 0021     		movs	r1, #0
 100:../drivers/fsl_flexio_i2s.c ****         {
 103              		.loc 1 100 0 is_stmt 1
 104 004a 0023     		movs	r3, #0
 105 004c EAE7     		b	.L4
 106              	.L6:
 107:../drivers/fsl_flexio_i2s.c ****         data = 0;
 108:../drivers/fsl_flexio_i2s.c ****     }
 109:../drivers/fsl_flexio_i2s.c **** }
 107              		.loc 1 109 0
 108 004e 02B0     		add	sp, sp, #8
 109              		@ sp needed
 110              	.LVL15:
 111              	.LVL16:
 112              	.LVL17:
 113              	.LVL18:
 114              	.LVL19:
 115 0050 04BC     		pop	{r2}
 116 0052 9046     		mov	r8, r2
 117 0054 F0BD     		pop	{r4, r5, r6, r7, pc}
 118              		.cfi_endproc
 119              	.LFE75:
 121              		.section	.text.FLEXIO_I2S_ReadNonBlocking,"ax",%progbits
 122              		.align	1
 123              		.syntax unified
 124              		.code	16
 125              		.thumb_func
 126              		.fpu softvfp
 128              	FLEXIO_I2S_ReadNonBlocking:
 129              	.LFB76:
 110:../drivers/fsl_flexio_i2s.c **** 
 111:../drivers/fsl_flexio_i2s.c **** static void FLEXIO_I2S_ReadNonBlocking(FLEXIO_I2S_Type *base, uint8_t bitWidth, uint8_t *rxData, si
 112:../drivers/fsl_flexio_i2s.c **** {
 130              		.loc 1 112 0
 131              		.cfi_startproc
 132              		@ args = 0, pretend = 0, frame = 8
 133              		@ frame_needed = 0, uses_anonymous_args = 0
 134              	.LVL20:
 135 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 136              		.cfi_def_cfa_offset 20
 137              		.cfi_offset 4, -20
 138              		.cfi_offset 5, -16
 139              		.cfi_offset 6, -12
 140              		.cfi_offset 7, -8
 141              		.cfi_offset 14, -4
 142 0002 C646     		mov	lr, r8
 143 0004 00B5     		push	{lr}
 144              		.cfi_def_cfa_offset 24
 145              		.cfi_offset 8, -24
 146 0006 82B0     		sub	sp, sp, #8
 147              		.cfi_def_cfa_offset 32
 148 0008 0500     		movs	r5, r0
 149 000a 8846     		mov	r8, r1
 150 000c 1400     		movs	r4, r2
 151 000e 0193     		str	r3, [sp, #4]
 152              	.LVL21:
 113:../drivers/fsl_flexio_i2s.c ****     uint32_t i = 0;
 114:../drivers/fsl_flexio_i2s.c ****     uint8_t j = 0;
 115:../drivers/fsl_flexio_i2s.c ****     uint8_t bytesPerWord = bitWidth / 8U;
 153              		.loc 1 115 0
 154 0010 CE08     		lsrs	r6, r1, #3
 155              	.LVL22:
 116:../drivers/fsl_flexio_i2s.c ****     uint32_t data = 0;
 117:../drivers/fsl_flexio_i2s.c **** 
 118:../drivers/fsl_flexio_i2s.c ****     for (i = 0; i < size / bytesPerWord; i++)
 156              		.loc 1 118 0
 157 0012 0027     		movs	r7, #0
 158 0014 09E0     		b	.L8
 159              	.LVL23:
 160              	.L10:
 119:../drivers/fsl_flexio_i2s.c ****     {
 120:../drivers/fsl_flexio_i2s.c ****         data = (base->flexioBase->SHIFTBUFBIS[base->rxShifterIndex] >> (32U - bitWidth));
 121:../drivers/fsl_flexio_i2s.c ****         for (j = 0; j < bytesPerWord; j++)
 122:../drivers/fsl_flexio_i2s.c ****         {
 123:../drivers/fsl_flexio_i2s.c ****             *rxData = (data >> (8U * j)) & 0xFF;
 161              		.loc 1 123 0 discriminator 3
 162 0016 DA00     		lsls	r2, r3, #3
 163 0018 0800     		movs	r0, r1
 164 001a D040     		lsrs	r0, r0, r2
 165 001c 2070     		strb	r0, [r4]
 124:../drivers/fsl_flexio_i2s.c ****             rxData++;
 166              		.loc 1 124 0 discriminator 3
 167 001e 0134     		adds	r4, r4, #1
 168              	.LVL24:
 121:../drivers/fsl_flexio_i2s.c ****         {
 169              		.loc 1 121 0 discriminator 3
 170 0020 0133     		adds	r3, r3, #1
 171              	.LVL25:
 172 0022 DBB2     		uxtb	r3, r3
 173              	.LVL26:
 174              	.L9:
 121:../drivers/fsl_flexio_i2s.c ****         {
 175              		.loc 1 121 0 is_stmt 0 discriminator 1
 176 0024 B342     		cmp	r3, r6
 177 0026 F6D3     		bcc	.L10
 118:../drivers/fsl_flexio_i2s.c ****     {
 178              		.loc 1 118 0 is_stmt 1 discriminator 2
 179 0028 0137     		adds	r7, r7, #1
 180              	.LVL27:
 181              	.L8:
 118:../drivers/fsl_flexio_i2s.c ****     {
 182              		.loc 1 118 0 is_stmt 0 discriminator 1
 183 002a 3100     		movs	r1, r6
 184 002c 0198     		ldr	r0, [sp, #4]
 185 002e FFF7FEFF 		bl	__aeabi_uidiv
 186              	.LVL28:
 187 0032 B842     		cmp	r0, r7
 188 0034 0AD9     		bls	.L12
 120:../drivers/fsl_flexio_i2s.c ****         for (j = 0; j < bytesPerWord; j++)
 189              		.loc 1 120 0 is_stmt 1
 190 0036 6B7A     		ldrb	r3, [r5, #9]
 191 0038 A033     		adds	r3, r3, #160
 192 003a 9B00     		lsls	r3, r3, #2
 193 003c 2A68     		ldr	r2, [r5]
 194 003e 9958     		ldr	r1, [r3, r2]
 195 0040 2023     		movs	r3, #32
 196 0042 4246     		mov	r2, r8
 197 0044 9B1A     		subs	r3, r3, r2
 198 0046 D940     		lsrs	r1, r1, r3
 199              	.LVL29:
 121:../drivers/fsl_flexio_i2s.c ****         {
 200              		.loc 1 121 0
 201 0048 0023     		movs	r3, #0
 202 004a EBE7     		b	.L9
 203              	.LVL30:
 204              	.L12:
 125:../drivers/fsl_flexio_i2s.c ****         }
 126:../drivers/fsl_flexio_i2s.c ****     }
 127:../drivers/fsl_flexio_i2s.c **** }
 205              		.loc 1 127 0
 206 004c 02B0     		add	sp, sp, #8
 207              		@ sp needed
 208              	.LVL31:
 209              	.LVL32:
 210              	.LVL33:
 211              	.LVL34:
 212              	.LVL35:
 213 004e 04BC     		pop	{r2}
 214 0050 9046     		mov	r8, r2
 215 0052 F0BD     		pop	{r4, r5, r6, r7, pc}
 216              		.cfi_endproc
 217              	.LFE76:
 219              		.section	.text.FLEXIO_I2S_GetInstance,"ax",%progbits
 220              		.align	1
 221              		.global	FLEXIO_I2S_GetInstance
 222              		.syntax unified
 223              		.code	16
 224              		.thumb_func
 225              		.fpu softvfp
 227              	FLEXIO_I2S_GetInstance:
 228              	.LFB74:
  86:../drivers/fsl_flexio_i2s.c ****     return FLEXIO_GetInstance(base->flexioBase);
 229              		.loc 1 86 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              	.LVL36:
 234 0000 10B5     		push	{r4, lr}
 235              		.cfi_def_cfa_offset 8
 236              		.cfi_offset 4, -8
 237              		.cfi_offset 14, -4
  87:../drivers/fsl_flexio_i2s.c **** }
 238              		.loc 1 87 0
 239 0002 0068     		ldr	r0, [r0]
 240              	.LVL37:
 241 0004 FFF7FEFF 		bl	FLEXIO_GetInstance
 242              	.LVL38:
  88:../drivers/fsl_flexio_i2s.c **** 
 243              		.loc 1 88 0
 244              		@ sp needed
 245 0008 10BD     		pop	{r4, pc}
 246              		.cfi_endproc
 247              	.LFE74:
 249              		.section	.text.FLEXIO_I2S_Init,"ax",%progbits
 250              		.align	1
 251              		.global	FLEXIO_I2S_Init
 252              		.syntax unified
 253              		.code	16
 254              		.thumb_func
 255              		.fpu softvfp
 257              	FLEXIO_I2S_Init:
 258              	.LFB77:
 128:../drivers/fsl_flexio_i2s.c **** 
 129:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_Init(FLEXIO_I2S_Type *base, const flexio_i2s_config_t *config)
 130:../drivers/fsl_flexio_i2s.c **** {
 259              		.loc 1 130 0
 260              		.cfi_startproc
 261              		@ args = 0, pretend = 0, frame = 48
 262              		@ frame_needed = 0, uses_anonymous_args = 0
 263              	.LVL39:
 264 0000 70B5     		push	{r4, r5, r6, lr}
 265              		.cfi_def_cfa_offset 16
 266              		.cfi_offset 4, -16
 267              		.cfi_offset 5, -12
 268              		.cfi_offset 6, -8
 269              		.cfi_offset 14, -4
 270 0002 8CB0     		sub	sp, sp, #48
 271              		.cfi_def_cfa_offset 64
 272 0004 0400     		movs	r4, r0
 273 0006 0D00     		movs	r5, r1
 131:../drivers/fsl_flexio_i2s.c ****     assert(base && config);
 132:../drivers/fsl_flexio_i2s.c **** 
 133:../drivers/fsl_flexio_i2s.c ****     flexio_shifter_config_t shifterConfig = {0};
 274              		.loc 1 133 0
 275 0008 07AE     		add	r6, sp, #28
 276 000a 1422     		movs	r2, #20
 277 000c 0021     		movs	r1, #0
 278              	.LVL40:
 279 000e 3000     		movs	r0, r6
 280              	.LVL41:
 281 0010 FFF7FEFF 		bl	memset
 282              	.LVL42:
 134:../drivers/fsl_flexio_i2s.c ****     flexio_timer_config_t timerConfig = {0};
 283              		.loc 1 134 0
 284 0014 1C22     		movs	r2, #28
 285 0016 0021     		movs	r1, #0
 286 0018 6846     		mov	r0, sp
 287 001a FFF7FEFF 		bl	memset
 288              	.LVL43:
 135:../drivers/fsl_flexio_i2s.c **** 
 136:../drivers/fsl_flexio_i2s.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 137:../drivers/fsl_flexio_i2s.c ****     /* Ungate flexio clock. */
 138:../drivers/fsl_flexio_i2s.c ****     CLOCK_EnableClock(s_flexioClocks[FLEXIO_I2S_GetInstance(base)]);
 289              		.loc 1 138 0
 290 001e 2000     		movs	r0, r4
 291 0020 FFF7FEFF 		bl	FLEXIO_I2S_GetInstance
 292              	.LVL44:
 293 0024 8000     		lsls	r0, r0, #2
 294 0026 644B     		ldr	r3, .L24
 295 0028 C358     		ldr	r3, [r0, r3]
 296              	.LVL45:
 297              	.LBB36:
 298              	.LBB37:
 299              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 300              		.loc 2 449 0
 301 002a 1A0C     		lsrs	r2, r3, #16
 302 002c 6349     		ldr	r1, .L24+4
 303 002e 8C46     		mov	ip, r1
 304 0030 6244     		add	r2, r2, ip
 305              	.LVL46:
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 306              		.loc 2 450 0
 307 0032 1168     		ldr	r1, [r2]
 308 0034 1B04     		lsls	r3, r3, #16
 309              	.LVL47:
 310 0036 1B0C     		lsrs	r3, r3, #16
 311 0038 0120     		movs	r0, #1
 312              	.LVL48:
 313 003a 9840     		lsls	r0, r0, r3
 314 003c 0300     		movs	r3, r0
 315 003e 0B43     		orrs	r3, r1
 316 0040 1360     		str	r3, [r2]
 317              	.LVL49:
 318              	.LBE37:
 319              	.LBE36:
 139:../drivers/fsl_flexio_i2s.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 140:../drivers/fsl_flexio_i2s.c **** 
 141:../drivers/fsl_flexio_i2s.c ****     /* Set shifter for I2S Tx data */
 142:../drivers/fsl_flexio_i2s.c ****     shifterConfig.timerSelect = base->bclkTimerIndex;
 320              		.loc 1 142 0
 321 0042 A37A     		ldrb	r3, [r4, #10]
 322 0044 0793     		str	r3, [sp, #28]
 143:../drivers/fsl_flexio_i2s.c ****     shifterConfig.pinSelect = base->txPinIndex;
 323              		.loc 1 143 0
 324 0046 2379     		ldrb	r3, [r4, #4]
 325 0048 B360     		str	r3, [r6, #8]
 144:../drivers/fsl_flexio_i2s.c ****     shifterConfig.timerPolarity = config->txTimerPolarity;
 326              		.loc 1 144 0
 327 004a AB79     		ldrb	r3, [r5, #6]
 328 004c 3371     		strb	r3, [r6, #4]
 145:../drivers/fsl_flexio_i2s.c ****     shifterConfig.pinConfig = kFLEXIO_PinConfigOutput;
 329              		.loc 1 145 0
 330 004e 0323     		movs	r3, #3
 331 0050 7371     		strb	r3, [r6, #5]
 146:../drivers/fsl_flexio_i2s.c ****     shifterConfig.pinPolarity = config->txPinPolarity;
 332              		.loc 1 146 0
 333 0052 AB78     		ldrb	r3, [r5, #2]
 334 0054 3373     		strb	r3, [r6, #12]
 147:../drivers/fsl_flexio_i2s.c ****     shifterConfig.shifterMode = kFLEXIO_ShifterModeTransmit;
 335              		.loc 1 147 0
 336 0056 0223     		movs	r3, #2
 337 0058 7373     		strb	r3, [r6, #13]
 148:../drivers/fsl_flexio_i2s.c ****     shifterConfig.inputSource = kFLEXIO_ShifterInputFromPin;
 338              		.loc 1 148 0
 339 005a 0023     		movs	r3, #0
 340 005c B373     		strb	r3, [r6, #14]
 149:../drivers/fsl_flexio_i2s.c ****     shifterConfig.shifterStop = kFLEXIO_ShifterStopBitDisable;
 341              		.loc 1 149 0
 342 005e F373     		strb	r3, [r6, #15]
 150:../drivers/fsl_flexio_i2s.c ****     if (config->masterSlave == kFLEXIO_I2S_Master)
 343              		.loc 1 150 0
 344 0060 6B78     		ldrb	r3, [r5, #1]
 345 0062 002B     		cmp	r3, #0
 346 0064 68D1     		bne	.L15
 151:../drivers/fsl_flexio_i2s.c ****     {
 152:../drivers/fsl_flexio_i2s.c ****         shifterConfig.shifterStart = kFLEXIO_ShifterStartBitDisabledLoadDataOnShift;
 347              		.loc 1 152 0
 348 0066 07AB     		add	r3, sp, #28
 349 0068 0122     		movs	r2, #1
 350 006a 1A74     		strb	r2, [r3, #16]
 351              	.L16:
 153:../drivers/fsl_flexio_i2s.c ****     }
 154:../drivers/fsl_flexio_i2s.c ****     else
 155:../drivers/fsl_flexio_i2s.c ****     {
 156:../drivers/fsl_flexio_i2s.c ****         shifterConfig.shifterStart = kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable;
 157:../drivers/fsl_flexio_i2s.c ****     }
 158:../drivers/fsl_flexio_i2s.c **** 
 159:../drivers/fsl_flexio_i2s.c ****     FLEXIO_SetShifterConfig(base->flexioBase, base->txShifterIndex, &shifterConfig);
 352              		.loc 1 159 0
 353 006c 07AE     		add	r6, sp, #28
 354 006e 217A     		ldrb	r1, [r4, #8]
 355 0070 3200     		movs	r2, r6
 356 0072 2068     		ldr	r0, [r4]
 357 0074 FFF7FEFF 		bl	FLEXIO_SetShifterConfig
 358              	.LVL50:
 160:../drivers/fsl_flexio_i2s.c **** 
 161:../drivers/fsl_flexio_i2s.c ****     /* Set shifter for I2S Rx Data */
 162:../drivers/fsl_flexio_i2s.c ****     shifterConfig.timerSelect = base->bclkTimerIndex;
 359              		.loc 1 162 0
 360 0078 A37A     		ldrb	r3, [r4, #10]
 361 007a 0793     		str	r3, [sp, #28]
 163:../drivers/fsl_flexio_i2s.c ****     shifterConfig.pinSelect = base->rxPinIndex;
 362              		.loc 1 163 0
 363 007c 6379     		ldrb	r3, [r4, #5]
 364 007e B360     		str	r3, [r6, #8]
 164:../drivers/fsl_flexio_i2s.c ****     shifterConfig.timerPolarity = config->rxTimerPolarity;
 365              		.loc 1 164 0
 366 0080 EB79     		ldrb	r3, [r5, #7]
 367 0082 3371     		strb	r3, [r6, #4]
 165:../drivers/fsl_flexio_i2s.c ****     shifterConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 368              		.loc 1 165 0
 369 0084 0023     		movs	r3, #0
 370 0086 7371     		strb	r3, [r6, #5]
 166:../drivers/fsl_flexio_i2s.c ****     shifterConfig.pinPolarity = config->rxPinPolarity;
 371              		.loc 1 166 0
 372 0088 EA78     		ldrb	r2, [r5, #3]
 373 008a 3273     		strb	r2, [r6, #12]
 167:../drivers/fsl_flexio_i2s.c ****     shifterConfig.shifterMode = kFLEXIO_ShifterModeReceive;
 374              		.loc 1 167 0
 375 008c 0122     		movs	r2, #1
 376 008e 7273     		strb	r2, [r6, #13]
 168:../drivers/fsl_flexio_i2s.c ****     shifterConfig.inputSource = kFLEXIO_ShifterInputFromPin;
 377              		.loc 1 168 0
 378 0090 B373     		strb	r3, [r6, #14]
 169:../drivers/fsl_flexio_i2s.c ****     shifterConfig.shifterStop = kFLEXIO_ShifterStopBitDisable;
 379              		.loc 1 169 0
 380 0092 F373     		strb	r3, [r6, #15]
 170:../drivers/fsl_flexio_i2s.c ****     shifterConfig.shifterStart = kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable;
 381              		.loc 1 170 0
 382 0094 3374     		strb	r3, [r6, #16]
 171:../drivers/fsl_flexio_i2s.c **** 
 172:../drivers/fsl_flexio_i2s.c ****     FLEXIO_SetShifterConfig(base->flexioBase, base->rxShifterIndex, &shifterConfig);
 383              		.loc 1 172 0
 384 0096 617A     		ldrb	r1, [r4, #9]
 385 0098 3200     		movs	r2, r6
 386 009a 2068     		ldr	r0, [r4]
 387 009c FFF7FEFF 		bl	FLEXIO_SetShifterConfig
 388              	.LVL51:
 173:../drivers/fsl_flexio_i2s.c **** 
 174:../drivers/fsl_flexio_i2s.c ****     /* Set Timer to I2S frame sync */
 175:../drivers/fsl_flexio_i2s.c ****     if (config->masterSlave == kFLEXIO_I2S_Master)
 389              		.loc 1 175 0
 390 00a0 6B78     		ldrb	r3, [r5, #1]
 391 00a2 002B     		cmp	r3, #0
 392 00a4 4CD1     		bne	.L17
 176:../drivers/fsl_flexio_i2s.c ****     {
 177:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_PININPUT(base->txPinIndex);
 393              		.loc 1 177 0
 394 00a6 2379     		ldrb	r3, [r4, #4]
 395 00a8 5B00     		lsls	r3, r3, #1
 396 00aa 0093     		str	r3, [sp]
 178:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
 397              		.loc 1 178 0
 398 00ac 0023     		movs	r3, #0
 399 00ae 6A46     		mov	r2, sp
 400 00b0 1371     		strb	r3, [r2, #4]
 179:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceExternal;
 401              		.loc 1 179 0
 402 00b2 5371     		strb	r3, [r2, #5]
 180:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinConfig = kFLEXIO_PinConfigOutput;
 403              		.loc 1 180 0
 404 00b4 0322     		movs	r2, #3
 405 00b6 6946     		mov	r1, sp
 406 00b8 8A71     		strb	r2, [r1, #6]
 181:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinSelect = base->fsPinIndex;
 407              		.loc 1 181 0
 408 00ba E179     		ldrb	r1, [r4, #7]
 409 00bc 0291     		str	r1, [sp, #8]
 182:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinPolarity = config->fsPinPolarity;
 410              		.loc 1 182 0
 411 00be 6979     		ldrb	r1, [r5, #5]
 412 00c0 6846     		mov	r0, sp
 413 00c2 0173     		strb	r1, [r0, #12]
 183:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerMode = kFLEXIO_TimerModeSingle16Bit;
 414              		.loc 1 183 0
 415 00c4 4273     		strb	r2, [r0, #13]
 184:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 416              		.loc 1 184 0
 417 00c6 8373     		strb	r3, [r0, #14]
 185:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput;
 418              		.loc 1 185 0
 419 00c8 C373     		strb	r3, [r0, #15]
 186:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerReset = kFLEXIO_TimerResetNever;
 420              		.loc 1 186 0
 421 00ca 0374     		strb	r3, [r0, #16]
 187:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDisable = kFLEXIO_TimerDisableNever;
 422              		.loc 1 187 0
 423 00cc 4374     		strb	r3, [r0, #17]
 188:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerEnable = kFLEXIO_TimerEnableOnPrevTimerEnable;
 424              		.loc 1 188 0
 425 00ce 0122     		movs	r2, #1
 426 00d0 8274     		strb	r2, [r0, #18]
 189:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStart = kFLEXIO_TimerStartBitDisabled;
 427              		.loc 1 189 0
 428 00d2 0375     		strb	r3, [r0, #20]
 190:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStop = kFLEXIO_TimerStopBitDisabled;
 429              		.loc 1 190 0
 430 00d4 C374     		strb	r3, [r0, #19]
 431              	.L18:
 191:../drivers/fsl_flexio_i2s.c ****     }
 192:../drivers/fsl_flexio_i2s.c ****     else
 193:../drivers/fsl_flexio_i2s.c ****     {
 194:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_PININPUT(base->bclkPinIndex);
 195:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
 196:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceInternal;
 197:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 198:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinSelect = base->fsPinIndex;
 199:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinPolarity = config->fsPinPolarity;
 200:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerMode = kFLEXIO_TimerModeSingle16Bit;
 201:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 202:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnTriggerInputShiftTriggerInput;
 203:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerReset = kFLEXIO_TimerResetNever;
 204:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompare;
 205:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerEnable = kFLEXIO_TimerEnableOnPinRisingEdge;
 206:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStart = kFLEXIO_TimerStartBitDisabled;
 207:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStop = kFLEXIO_TimerStopBitDisabled;
 208:../drivers/fsl_flexio_i2s.c ****     }
 209:../drivers/fsl_flexio_i2s.c ****     FLEXIO_SetTimerConfig(base->flexioBase, base->fsTimerIndex, &timerConfig);
 432              		.loc 1 209 0
 433 00d6 E17A     		ldrb	r1, [r4, #11]
 434 00d8 6A46     		mov	r2, sp
 435 00da 2068     		ldr	r0, [r4]
 436 00dc FFF7FEFF 		bl	FLEXIO_SetTimerConfig
 437              	.LVL52:
 210:../drivers/fsl_flexio_i2s.c **** 
 211:../drivers/fsl_flexio_i2s.c ****     /* Set Timer to I2S bit clock */
 212:../drivers/fsl_flexio_i2s.c ****     if (config->masterSlave == kFLEXIO_I2S_Master)
 438              		.loc 1 212 0
 439 00e0 6B78     		ldrb	r3, [r5, #1]
 440 00e2 002B     		cmp	r3, #0
 441 00e4 46D1     		bne	.L19
 213:../drivers/fsl_flexio_i2s.c ****     {
 214:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(base->txShifterIndex);
 442              		.loc 1 214 0
 443 00e6 237A     		ldrb	r3, [r4, #8]
 444 00e8 9B00     		lsls	r3, r3, #2
 445 00ea 0122     		movs	r2, #1
 446 00ec 1343     		orrs	r3, r2
 447 00ee 0093     		str	r3, [sp]
 215:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveLow;
 448              		.loc 1 215 0
 449 00f0 6B46     		mov	r3, sp
 450 00f2 1A71     		strb	r2, [r3, #4]
 216:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceInternal;
 451              		.loc 1 216 0
 452 00f4 5A71     		strb	r2, [r3, #5]
 217:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinSelect = base->bclkPinIndex;
 453              		.loc 1 217 0
 454 00f6 A379     		ldrb	r3, [r4, #6]
 455 00f8 0293     		str	r3, [sp, #8]
 218:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinConfig = kFLEXIO_PinConfigOutput;
 456              		.loc 1 218 0
 457 00fa 0323     		movs	r3, #3
 458 00fc 6946     		mov	r1, sp
 459 00fe 8B71     		strb	r3, [r1, #6]
 219:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinPolarity = config->bclkPinPolarity;
 460              		.loc 1 219 0
 461 0100 2B79     		ldrb	r3, [r5, #4]
 462 0102 0B73     		strb	r3, [r1, #12]
 220:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerMode = kFLEXIO_TimerModeDual8BitBaudBit;
 463              		.loc 1 220 0
 464 0104 4A73     		strb	r2, [r1, #13]
 221:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 465              		.loc 1 221 0
 466 0106 0023     		movs	r3, #0
 467 0108 8B73     		strb	r3, [r1, #14]
 222:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput;
 468              		.loc 1 222 0
 469 010a CB73     		strb	r3, [r1, #15]
 223:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerReset = kFLEXIO_TimerResetNever;
 470              		.loc 1 223 0
 471 010c 0B74     		strb	r3, [r1, #16]
 224:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDisable = kFLEXIO_TimerDisableNever;
 472              		.loc 1 224 0
 473 010e 4B74     		strb	r3, [r1, #17]
 225:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerEnable = kFLEXIO_TimerEnableOnTriggerHigh;
 474              		.loc 1 225 0
 475 0110 0221     		movs	r1, #2
 476 0112 6846     		mov	r0, sp
 477 0114 8174     		strb	r1, [r0, #18]
 226:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStart = kFLEXIO_TimerStartBitEnabled;
 478              		.loc 1 226 0
 479 0116 0275     		strb	r2, [r0, #20]
 227:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStop = kFLEXIO_TimerStopBitDisabled;
 480              		.loc 1 227 0
 481 0118 C374     		strb	r3, [r0, #19]
 482              	.L20:
 228:../drivers/fsl_flexio_i2s.c ****     }
 229:../drivers/fsl_flexio_i2s.c ****     else
 230:../drivers/fsl_flexio_i2s.c ****     {
 231:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_TIMn(base->fsTimerIndex);
 232:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
 233:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceInternal;
 234:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinSelect = base->bclkPinIndex;
 235:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 236:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinPolarity = config->bclkPinPolarity;
 237:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerMode = kFLEXIO_TimerModeSingle16Bit;
 238:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 239:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnPinInputShiftPinInput;
 240:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerReset = kFLEXIO_TimerResetNever;
 241:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompareTriggerLow;
 242:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerEnable = kFLEXIO_TimerEnableOnPinRisingEdgeTriggerHigh;
 243:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStart = kFLEXIO_TimerStartBitDisabled;
 244:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStop = kFLEXIO_TimerStopBitDisabled;
 245:../drivers/fsl_flexio_i2s.c ****     }
 246:../drivers/fsl_flexio_i2s.c ****     FLEXIO_SetTimerConfig(base->flexioBase, base->bclkTimerIndex, &timerConfig);
 483              		.loc 1 246 0
 484 011a A17A     		ldrb	r1, [r4, #10]
 485 011c 6A46     		mov	r2, sp
 486 011e 2068     		ldr	r0, [r4]
 487 0120 FFF7FEFF 		bl	FLEXIO_SetTimerConfig
 488              	.LVL53:
 247:../drivers/fsl_flexio_i2s.c **** 
 248:../drivers/fsl_flexio_i2s.c ****     /* If enable flexio I2S */
 249:../drivers/fsl_flexio_i2s.c ****     if (config->enableI2S)
 489              		.loc 1 249 0
 490 0124 2B78     		ldrb	r3, [r5]
 491 0126 002B     		cmp	r3, #0
 492 0128 3FD1     		bne	.L23
 250:../drivers/fsl_flexio_i2s.c ****     {
 251:../drivers/fsl_flexio_i2s.c ****         base->flexioBase->CTRL |= FLEXIO_CTRL_FLEXEN_MASK;
 252:../drivers/fsl_flexio_i2s.c ****     }
 253:../drivers/fsl_flexio_i2s.c ****     else
 254:../drivers/fsl_flexio_i2s.c ****     {
 255:../drivers/fsl_flexio_i2s.c ****         base->flexioBase->CTRL &= ~FLEXIO_CTRL_FLEXEN_MASK;
 493              		.loc 1 255 0
 494 012a 2268     		ldr	r2, [r4]
 495 012c 9368     		ldr	r3, [r2, #8]
 496 012e 0121     		movs	r1, #1
 497 0130 8B43     		bics	r3, r1
 498 0132 9360     		str	r3, [r2, #8]
 499              	.L14:
 256:../drivers/fsl_flexio_i2s.c ****     }
 257:../drivers/fsl_flexio_i2s.c **** }
 500              		.loc 1 257 0
 501 0134 0CB0     		add	sp, sp, #48
 502              		@ sp needed
 503              	.LVL54:
 504              	.LVL55:
 505 0136 70BD     		pop	{r4, r5, r6, pc}
 506              	.LVL56:
 507              	.L15:
 156:../drivers/fsl_flexio_i2s.c ****     }
 508              		.loc 1 156 0
 509 0138 07AB     		add	r3, sp, #28
 510 013a 0022     		movs	r2, #0
 511 013c 1A74     		strb	r2, [r3, #16]
 512 013e 95E7     		b	.L16
 513              	.L17:
 194:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
 514              		.loc 1 194 0
 515 0140 A379     		ldrb	r3, [r4, #6]
 516 0142 5B00     		lsls	r3, r3, #1
 517 0144 0093     		str	r3, [sp]
 195:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceInternal;
 518              		.loc 1 195 0
 519 0146 0023     		movs	r3, #0
 520 0148 6A46     		mov	r2, sp
 521 014a 1371     		strb	r3, [r2, #4]
 196:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 522              		.loc 1 196 0
 523 014c 0122     		movs	r2, #1
 524 014e 6946     		mov	r1, sp
 525 0150 4A71     		strb	r2, [r1, #5]
 197:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinSelect = base->fsPinIndex;
 526              		.loc 1 197 0
 527 0152 8B71     		strb	r3, [r1, #6]
 198:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinPolarity = config->fsPinPolarity;
 528              		.loc 1 198 0
 529 0154 E279     		ldrb	r2, [r4, #7]
 530 0156 0292     		str	r2, [sp, #8]
 199:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerMode = kFLEXIO_TimerModeSingle16Bit;
 531              		.loc 1 199 0
 532 0158 6A79     		ldrb	r2, [r5, #5]
 533 015a 0A73     		strb	r2, [r1, #12]
 200:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 534              		.loc 1 200 0
 535 015c 0322     		movs	r2, #3
 536 015e 4A73     		strb	r2, [r1, #13]
 201:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnTriggerInputShiftTriggerInput;
 537              		.loc 1 201 0
 538 0160 8B73     		strb	r3, [r1, #14]
 202:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerReset = kFLEXIO_TimerResetNever;
 539              		.loc 1 202 0
 540 0162 CA73     		strb	r2, [r1, #15]
 203:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompare;
 541              		.loc 1 203 0
 542 0164 0B74     		strb	r3, [r1, #16]
 204:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerEnable = kFLEXIO_TimerEnableOnPinRisingEdge;
 543              		.loc 1 204 0
 544 0166 0222     		movs	r2, #2
 545 0168 4A74     		strb	r2, [r1, #17]
 205:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStart = kFLEXIO_TimerStartBitDisabled;
 546              		.loc 1 205 0
 547 016a 0232     		adds	r2, r2, #2
 548 016c 8A74     		strb	r2, [r1, #18]
 206:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStop = kFLEXIO_TimerStopBitDisabled;
 549              		.loc 1 206 0
 550 016e 0B75     		strb	r3, [r1, #20]
 207:../drivers/fsl_flexio_i2s.c ****     }
 551              		.loc 1 207 0
 552 0170 CB74     		strb	r3, [r1, #19]
 553 0172 B0E7     		b	.L18
 554              	.L19:
 231:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
 555              		.loc 1 231 0
 556 0174 E37A     		ldrb	r3, [r4, #11]
 557 0176 9B00     		lsls	r3, r3, #2
 558 0178 0322     		movs	r2, #3
 559 017a 1343     		orrs	r3, r2
 560 017c 0093     		str	r3, [sp]
 232:../drivers/fsl_flexio_i2s.c ****         timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceInternal;
 561              		.loc 1 232 0
 562 017e 0023     		movs	r3, #0
 563 0180 6946     		mov	r1, sp
 564 0182 0B71     		strb	r3, [r1, #4]
 233:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinSelect = base->bclkPinIndex;
 565              		.loc 1 233 0
 566 0184 0121     		movs	r1, #1
 567 0186 6846     		mov	r0, sp
 568 0188 4171     		strb	r1, [r0, #5]
 234:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 569              		.loc 1 234 0
 570 018a A179     		ldrb	r1, [r4, #6]
 571 018c 0291     		str	r1, [sp, #8]
 235:../drivers/fsl_flexio_i2s.c ****         timerConfig.pinPolarity = config->bclkPinPolarity;
 572              		.loc 1 235 0
 573 018e 8371     		strb	r3, [r0, #6]
 236:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerMode = kFLEXIO_TimerModeSingle16Bit;
 574              		.loc 1 236 0
 575 0190 2979     		ldrb	r1, [r5, #4]
 576 0192 0173     		strb	r1, [r0, #12]
 237:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 577              		.loc 1 237 0
 578 0194 4273     		strb	r2, [r0, #13]
 238:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnPinInputShiftPinInput;
 579              		.loc 1 238 0
 580 0196 8373     		strb	r3, [r0, #14]
 239:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerReset = kFLEXIO_TimerResetNever;
 581              		.loc 1 239 0
 582 0198 0221     		movs	r1, #2
 583 019a C173     		strb	r1, [r0, #15]
 240:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompareTriggerLow;
 584              		.loc 1 240 0
 585 019c 0374     		strb	r3, [r0, #16]
 241:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerEnable = kFLEXIO_TimerEnableOnPinRisingEdgeTriggerHigh;
 586              		.loc 1 241 0
 587 019e 4274     		strb	r2, [r0, #17]
 242:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStart = kFLEXIO_TimerStartBitDisabled;
 588              		.loc 1 242 0
 589 01a0 0232     		adds	r2, r2, #2
 590 01a2 8274     		strb	r2, [r0, #18]
 243:../drivers/fsl_flexio_i2s.c ****         timerConfig.timerStop = kFLEXIO_TimerStopBitDisabled;
 591              		.loc 1 243 0
 592 01a4 0375     		strb	r3, [r0, #20]
 244:../drivers/fsl_flexio_i2s.c ****     }
 593              		.loc 1 244 0
 594 01a6 C374     		strb	r3, [r0, #19]
 595 01a8 B7E7     		b	.L20
 596              	.L23:
 251:../drivers/fsl_flexio_i2s.c ****     }
 597              		.loc 1 251 0
 598 01aa 2268     		ldr	r2, [r4]
 599 01ac 9368     		ldr	r3, [r2, #8]
 600 01ae 0121     		movs	r1, #1
 601 01b0 0B43     		orrs	r3, r1
 602 01b2 9360     		str	r3, [r2, #8]
 603 01b4 BEE7     		b	.L14
 604              	.L25:
 605 01b6 C046     		.align	2
 606              	.L24:
 607 01b8 00000000 		.word	s_flexioClocks
 608 01bc 00700440 		.word	1074032640
 609              		.cfi_endproc
 610              	.LFE77:
 612              		.section	.text.FLEXIO_I2S_GetDefaultConfig,"ax",%progbits
 613              		.align	1
 614              		.global	FLEXIO_I2S_GetDefaultConfig
 615              		.syntax unified
 616              		.code	16
 617              		.thumb_func
 618              		.fpu softvfp
 620              	FLEXIO_I2S_GetDefaultConfig:
 621              	.LFB78:
 258:../drivers/fsl_flexio_i2s.c **** 
 259:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_GetDefaultConfig(flexio_i2s_config_t *config)
 260:../drivers/fsl_flexio_i2s.c **** {
 622              		.loc 1 260 0
 623              		.cfi_startproc
 624              		@ args = 0, pretend = 0, frame = 0
 625              		@ frame_needed = 0, uses_anonymous_args = 0
 626              		@ link register save eliminated.
 627              	.LVL57:
 261:../drivers/fsl_flexio_i2s.c ****     config->masterSlave = kFLEXIO_I2S_Master;
 628              		.loc 1 261 0
 629 0000 0023     		movs	r3, #0
 630 0002 4370     		strb	r3, [r0, #1]
 262:../drivers/fsl_flexio_i2s.c ****     config->enableI2S = true;
 631              		.loc 1 262 0
 632 0004 0122     		movs	r2, #1
 633 0006 0270     		strb	r2, [r0]
 263:../drivers/fsl_flexio_i2s.c ****     config->txPinPolarity = kFLEXIO_PinActiveHigh;
 634              		.loc 1 263 0
 635 0008 8370     		strb	r3, [r0, #2]
 264:../drivers/fsl_flexio_i2s.c ****     config->rxPinPolarity = kFLEXIO_PinActiveHigh;
 636              		.loc 1 264 0
 637 000a C370     		strb	r3, [r0, #3]
 265:../drivers/fsl_flexio_i2s.c ****     config->bclkPinPolarity = kFLEXIO_PinActiveHigh;
 638              		.loc 1 265 0
 639 000c 0371     		strb	r3, [r0, #4]
 266:../drivers/fsl_flexio_i2s.c ****     config->fsPinPolarity = kFLEXIO_PinActiveLow;
 640              		.loc 1 266 0
 641 000e 4271     		strb	r2, [r0, #5]
 267:../drivers/fsl_flexio_i2s.c ****     config->txTimerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive;
 642              		.loc 1 267 0
 643 0010 8371     		strb	r3, [r0, #6]
 268:../drivers/fsl_flexio_i2s.c ****     config->rxTimerPolarity = kFLEXIO_ShifterTimerPolarityOnNegitive;
 644              		.loc 1 268 0
 645 0012 C271     		strb	r2, [r0, #7]
 269:../drivers/fsl_flexio_i2s.c **** }
 646              		.loc 1 269 0
 647              		@ sp needed
 648 0014 7047     		bx	lr
 649              		.cfi_endproc
 650              	.LFE78:
 652              		.section	.text.FLEXIO_I2S_Deinit,"ax",%progbits
 653              		.align	1
 654              		.global	FLEXIO_I2S_Deinit
 655              		.syntax unified
 656              		.code	16
 657              		.thumb_func
 658              		.fpu softvfp
 660              	FLEXIO_I2S_Deinit:
 661              	.LFB79:
 270:../drivers/fsl_flexio_i2s.c **** 
 271:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_Deinit(FLEXIO_I2S_Type *base)
 272:../drivers/fsl_flexio_i2s.c **** {
 662              		.loc 1 272 0
 663              		.cfi_startproc
 664              		@ args = 0, pretend = 0, frame = 0
 665              		@ frame_needed = 0, uses_anonymous_args = 0
 666              		@ link register save eliminated.
 667              	.LVL58:
 273:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->SHIFTCFG[base->txShifterIndex] = 0;
 668              		.loc 1 273 0
 669 0000 027A     		ldrb	r2, [r0, #8]
 670 0002 4032     		adds	r2, r2, #64
 671 0004 9200     		lsls	r2, r2, #2
 672 0006 0023     		movs	r3, #0
 673 0008 0168     		ldr	r1, [r0]
 674 000a 5350     		str	r3, [r2, r1]
 274:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->SHIFTCTL[base->txShifterIndex] = 0;
 675              		.loc 1 274 0
 676 000c 027A     		ldrb	r2, [r0, #8]
 677 000e 2032     		adds	r2, r2, #32
 678 0010 9200     		lsls	r2, r2, #2
 679 0012 0168     		ldr	r1, [r0]
 680 0014 5350     		str	r3, [r2, r1]
 275:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->SHIFTCFG[base->rxShifterIndex] = 0;
 681              		.loc 1 275 0
 682 0016 427A     		ldrb	r2, [r0, #9]
 683 0018 4032     		adds	r2, r2, #64
 684 001a 9200     		lsls	r2, r2, #2
 685 001c 0168     		ldr	r1, [r0]
 686 001e 5350     		str	r3, [r2, r1]
 276:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->SHIFTCTL[base->rxShifterIndex] = 0;
 687              		.loc 1 276 0
 688 0020 427A     		ldrb	r2, [r0, #9]
 689 0022 2032     		adds	r2, r2, #32
 690 0024 9200     		lsls	r2, r2, #2
 691 0026 0168     		ldr	r1, [r0]
 692 0028 5350     		str	r3, [r2, r1]
 277:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCFG[base->fsTimerIndex] = 0;
 693              		.loc 1 277 0
 694 002a C27A     		ldrb	r2, [r0, #11]
 695 002c 2132     		adds	r2, r2, #33
 696 002e FF32     		adds	r2, r2, #255
 697 0030 9200     		lsls	r2, r2, #2
 698 0032 0168     		ldr	r1, [r0]
 699 0034 5350     		str	r3, [r2, r1]
 278:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCMP[base->fsTimerIndex] = 0;
 700              		.loc 1 278 0
 701 0036 C27A     		ldrb	r2, [r0, #11]
 702 0038 4132     		adds	r2, r2, #65
 703 003a FF32     		adds	r2, r2, #255
 704 003c 9200     		lsls	r2, r2, #2
 705 003e 0168     		ldr	r1, [r0]
 706 0040 5350     		str	r3, [r2, r1]
 279:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCTL[base->fsTimerIndex] = 0;
 707              		.loc 1 279 0
 708 0042 C27A     		ldrb	r2, [r0, #11]
 709 0044 0132     		adds	r2, r2, #1
 710 0046 FF32     		adds	r2, r2, #255
 711 0048 9200     		lsls	r2, r2, #2
 712 004a 0168     		ldr	r1, [r0]
 713 004c 5350     		str	r3, [r2, r1]
 280:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCFG[base->bclkTimerIndex] = 0;
 714              		.loc 1 280 0
 715 004e 827A     		ldrb	r2, [r0, #10]
 716 0050 2132     		adds	r2, r2, #33
 717 0052 FF32     		adds	r2, r2, #255
 718 0054 9200     		lsls	r2, r2, #2
 719 0056 0168     		ldr	r1, [r0]
 720 0058 5350     		str	r3, [r2, r1]
 281:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCMP[base->bclkTimerIndex] = 0;
 721              		.loc 1 281 0
 722 005a 827A     		ldrb	r2, [r0, #10]
 723 005c 4132     		adds	r2, r2, #65
 724 005e FF32     		adds	r2, r2, #255
 725 0060 9200     		lsls	r2, r2, #2
 726 0062 0168     		ldr	r1, [r0]
 727 0064 5350     		str	r3, [r2, r1]
 282:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCTL[base->bclkTimerIndex] = 0;
 728              		.loc 1 282 0
 729 0066 0168     		ldr	r1, [r0]
 730 0068 827A     		ldrb	r2, [r0, #10]
 731 006a 0132     		adds	r2, r2, #1
 732 006c FF32     		adds	r2, r2, #255
 733 006e 9200     		lsls	r2, r2, #2
 734 0070 5350     		str	r3, [r2, r1]
 283:../drivers/fsl_flexio_i2s.c **** }
 735              		.loc 1 283 0
 736              		@ sp needed
 737 0072 7047     		bx	lr
 738              		.cfi_endproc
 739              	.LFE79:
 741              		.section	.text.FLEXIO_I2S_EnableInterrupts,"ax",%progbits
 742              		.align	1
 743              		.global	FLEXIO_I2S_EnableInterrupts
 744              		.syntax unified
 745              		.code	16
 746              		.thumb_func
 747              		.fpu softvfp
 749              	FLEXIO_I2S_EnableInterrupts:
 750              	.LFB80:
 284:../drivers/fsl_flexio_i2s.c **** 
 285:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_EnableInterrupts(FLEXIO_I2S_Type *base, uint32_t mask)
 286:../drivers/fsl_flexio_i2s.c **** {
 751              		.loc 1 286 0
 752              		.cfi_startproc
 753              		@ args = 0, pretend = 0, frame = 0
 754              		@ frame_needed = 0, uses_anonymous_args = 0
 755              	.LVL59:
 756 0000 10B5     		push	{r4, lr}
 757              		.cfi_def_cfa_offset 8
 758              		.cfi_offset 4, -8
 759              		.cfi_offset 14, -4
 287:../drivers/fsl_flexio_i2s.c ****     if (mask & kFLEXIO_I2S_TxDataRegEmptyInterruptEnable)
 760              		.loc 1 287 0
 761 0002 CB07     		lsls	r3, r1, #31
 762 0004 06D5     		bpl	.L29
 288:../drivers/fsl_flexio_i2s.c ****     {
 289:../drivers/fsl_flexio_i2s.c ****         FLEXIO_EnableShifterStatusInterrupts(base->flexioBase, 1U << base->txShifterIndex);
 763              		.loc 1 289 0
 764 0006 0268     		ldr	r2, [r0]
 765 0008 047A     		ldrb	r4, [r0, #8]
 766 000a 0123     		movs	r3, #1
 767 000c A340     		lsls	r3, r3, r4
 768              	.LVL60:
 769              	.LBB38:
 770              	.LBB39:
 771              		.file 3 "../drivers/fsl_flexio.h"
   1:../drivers/fsl_flexio.h **** /*
   2:../drivers/fsl_flexio.h ****  * The Clear BSD License
   3:../drivers/fsl_flexio.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_flexio.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_flexio.h ****  * All rights reserved.
   6:../drivers/fsl_flexio.h ****  *
   7:../drivers/fsl_flexio.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_flexio.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_flexio.h ****  * that the following conditions are met:
  10:../drivers/fsl_flexio.h ****  *
  11:../drivers/fsl_flexio.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_flexio.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_flexio.h ****  *
  14:../drivers/fsl_flexio.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_flexio.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_flexio.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_flexio.h ****  *
  18:../drivers/fsl_flexio.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_flexio.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_flexio.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_flexio.h ****  *
  22:../drivers/fsl_flexio.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_flexio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_flexio.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_flexio.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_flexio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_flexio.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_flexio.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_flexio.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_flexio.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_flexio.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_flexio.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_flexio.h ****  */
  34:../drivers/fsl_flexio.h **** #ifndef _FSL_FLEXIO_H_
  35:../drivers/fsl_flexio.h **** #define _FSL_FLEXIO_H_
  36:../drivers/fsl_flexio.h **** 
  37:../drivers/fsl_flexio.h **** #include "fsl_common.h"
  38:../drivers/fsl_flexio.h **** 
  39:../drivers/fsl_flexio.h **** /*!
  40:../drivers/fsl_flexio.h ****  * @addtogroup flexio_driver
  41:../drivers/fsl_flexio.h ****  * @{
  42:../drivers/fsl_flexio.h ****  */
  43:../drivers/fsl_flexio.h **** 
  44:../drivers/fsl_flexio.h **** /*******************************************************************************
  45:../drivers/fsl_flexio.h ****  * Definitions
  46:../drivers/fsl_flexio.h ****  ******************************************************************************/
  47:../drivers/fsl_flexio.h **** 
  48:../drivers/fsl_flexio.h **** /*! @name Driver version */
  49:../drivers/fsl_flexio.h **** /*@{*/
  50:../drivers/fsl_flexio.h **** /*! @brief FlexIO driver version 2.0.2. */
  51:../drivers/fsl_flexio.h **** #define FSL_FLEXIO_DRIVER_VERSION (MAKE_VERSION(2, 0, 2))
  52:../drivers/fsl_flexio.h **** /*@}*/
  53:../drivers/fsl_flexio.h **** 
  54:../drivers/fsl_flexio.h **** /*! @brief Calculate FlexIO timer trigger.*/
  55:../drivers/fsl_flexio.h **** #define FLEXIO_TIMER_TRIGGER_SEL_PININPUT(x) ((uint32_t)(x) << 1U)
  56:../drivers/fsl_flexio.h **** #define FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(x) (((uint32_t)(x) << 2U) | 0x1U)
  57:../drivers/fsl_flexio.h **** #define FLEXIO_TIMER_TRIGGER_SEL_TIMn(x) (((uint32_t)(x) << 2U) | 0x3U)
  58:../drivers/fsl_flexio.h **** 
  59:../drivers/fsl_flexio.h **** /*! @brief Define time of timer trigger polarity.*/
  60:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_trigger_polarity
  61:../drivers/fsl_flexio.h **** {
  62:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerPolarityActiveHigh = 0x0U, /*!< Active high. */
  63:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerPolarityActiveLow = 0x1U,  /*!< Active low. */
  64:../drivers/fsl_flexio.h **** } flexio_timer_trigger_polarity_t;
  65:../drivers/fsl_flexio.h **** 
  66:../drivers/fsl_flexio.h **** /*! @brief Define type of timer trigger source.*/
  67:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_trigger_source
  68:../drivers/fsl_flexio.h **** {
  69:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerSourceExternal = 0x0U, /*!< External trigger selected. */
  70:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerSourceInternal = 0x1U, /*!< Internal trigger selected. */
  71:../drivers/fsl_flexio.h **** } flexio_timer_trigger_source_t;
  72:../drivers/fsl_flexio.h **** 
  73:../drivers/fsl_flexio.h **** /*! @brief Define type of timer/shifter pin configuration.*/
  74:../drivers/fsl_flexio.h **** typedef enum _flexio_pin_config
  75:../drivers/fsl_flexio.h **** {
  76:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigOutputDisabled = 0x0U,         /*!< Pin output disabled. */
  77:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigOpenDrainOrBidirection = 0x1U, /*!< Pin open drain or bidirectional output ena
  78:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigBidirectionOutputData = 0x2U,  /*!< Pin bidirectional output data. */
  79:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigOutput = 0x3U,                 /*!< Pin output. */
  80:../drivers/fsl_flexio.h **** } flexio_pin_config_t;
  81:../drivers/fsl_flexio.h **** 
  82:../drivers/fsl_flexio.h **** /*! @brief Definition of pin polarity.*/
  83:../drivers/fsl_flexio.h **** typedef enum _flexio_pin_polarity
  84:../drivers/fsl_flexio.h **** {
  85:../drivers/fsl_flexio.h ****     kFLEXIO_PinActiveHigh = 0x0U, /*!< Active high. */
  86:../drivers/fsl_flexio.h ****     kFLEXIO_PinActiveLow = 0x1U,  /*!< Active low. */
  87:../drivers/fsl_flexio.h **** } flexio_pin_polarity_t;
  88:../drivers/fsl_flexio.h **** 
  89:../drivers/fsl_flexio.h **** /*! @brief Define type of timer work mode.*/
  90:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_mode
  91:../drivers/fsl_flexio.h **** {
  92:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeDisabled = 0x0U,        /*!< Timer Disabled. */
  93:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeDual8BitBaudBit = 0x1U, /*!< Dual 8-bit counters baud/bit mode. */
  94:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeDual8BitPWM = 0x2U,     /*!< Dual 8-bit counters PWM mode. */
  95:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeSingle16Bit = 0x3U,     /*!< Single 16-bit counter mode. */
  96:../drivers/fsl_flexio.h **** } flexio_timer_mode_t;
  97:../drivers/fsl_flexio.h **** 
  98:../drivers/fsl_flexio.h **** /*! @brief Define type of timer initial output or timer reset condition.*/
  99:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_output
 100:../drivers/fsl_flexio.h **** {
 101:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputOneNotAffectedByReset = 0x0U,  /*!< Logic one when enabled and is not affect
 102:../drivers/fsl_flexio.h ****                                                        reset. */
 103:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputZeroNotAffectedByReset = 0x1U, /*!< Logic zero when enabled and is not affec
 104:../drivers/fsl_flexio.h ****                                                        reset. */
 105:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputOneAffectedByReset = 0x2U,     /*!< Logic one when enabled and on timer rese
 106:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputZeroAffectedByReset = 0x3U,    /*!< Logic zero when enabled and on timer res
 107:../drivers/fsl_flexio.h **** } flexio_timer_output_t;
 108:../drivers/fsl_flexio.h **** 
 109:../drivers/fsl_flexio.h **** /*! @brief Define type of timer decrement.*/
 110:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_decrement_source
 111:../drivers/fsl_flexio.h **** {
 112:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput = 0x0U,   /*!< Decrement counter on FlexIO clo
 113:../drivers/fsl_flexio.h ****                                                                 equals Timer output. */
 114:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnTriggerInputShiftTimerOutput = 0x1U,  /*!< Decrement counter on Trigger in
 115:../drivers/fsl_flexio.h ****                                                                 Shift clock equals Timer output. */
 116:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnPinInputShiftPinInput = 0x2U,         /*!< Decrement counter on Pin input 
 117:../drivers/fsl_flexio.h ****                                                                 Shift clock equals Pin input. */
 118:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnTriggerInputShiftTriggerInput = 0x3U, /*!< Decrement counter on Trigger in
 119:../drivers/fsl_flexio.h ****                                                                 Shift clock equals Trigger input. *
 120:../drivers/fsl_flexio.h **** } flexio_timer_decrement_source_t;
 121:../drivers/fsl_flexio.h **** 
 122:../drivers/fsl_flexio.h **** /*! @brief Define type of timer reset condition.*/
 123:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_reset_condition
 124:../drivers/fsl_flexio.h **** {
 125:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetNever = 0x0U,                            /*!< Timer never reset. */
 126:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerPinEqualToTimerOutput = 0x2U,     /*!< Timer reset on Timer Pin equal 
 127:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerTriggerEqualToTimerOutput = 0x3U, /*!< Timer reset on Timer Trigger eq
 128:../drivers/fsl_flexio.h ****                                                                 Timer Output. */
 129:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerPinRisingEdge = 0x4U,             /*!< Timer reset on Timer Pin rising
 130:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerTriggerRisingEdge = 0x6U,         /*!< Timer reset on Trigger rising e
 131:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerTriggerBothEdge = 0x7U,           /*!< Timer reset on Trigger rising o
 132:../drivers/fsl_flexio.h **** } flexio_timer_reset_condition_t;
 133:../drivers/fsl_flexio.h **** 
 134:../drivers/fsl_flexio.h **** /*! @brief Define type of timer disable condition.*/
 135:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_disable_condition
 136:../drivers/fsl_flexio.h **** {
 137:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableNever = 0x0U,                    /*!< Timer never disabled. */
 138:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnPreTimerDisable = 0x1U,        /*!< Timer disabled on Timer N-1 disable. 
 139:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnTimerCompare = 0x2U,           /*!< Timer disabled on Timer compare. */
 140:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnTimerCompareTriggerLow = 0x3U, /*!< Timer disabled on Timer compare and T
 141:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnPinBothEdge = 0x4U,            /*!< Timer disabled on Pin rising or falli
 142:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnPinBothEdgeTriggerHigh = 0x5U, /*!< Timer disabled on Pin rising or falli
 143:../drivers/fsl_flexio.h ****                                                           Trigger is high. */
 144:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnTriggerFallingEdge = 0x6U,     /*!< Timer disabled on Trigger falling edg
 145:../drivers/fsl_flexio.h **** } flexio_timer_disable_condition_t;
 146:../drivers/fsl_flexio.h **** 
 147:../drivers/fsl_flexio.h **** /*! @brief Define type of timer enable condition.*/
 148:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_enable_condition
 149:../drivers/fsl_flexio.h **** {
 150:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnabledAlways = 0x0U,                    /*!< Timer always enabled. */
 151:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnPrevTimerEnable = 0x1U,          /*!< Timer enabled on Timer N-1 enable. *
 152:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerHigh = 0x2U,              /*!< Timer enabled on Trigger high. */
 153:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerHighPinHigh = 0x3U,       /*!< Timer enabled on Trigger high and Pi
 154:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnPinRisingEdge = 0x4U,            /*!< Timer enabled on Pin rising edge. */
 155:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnPinRisingEdgeTriggerHigh = 0x5U, /*!< Timer enabled on Pin rising edge and
 156:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerRisingEdge = 0x6U,        /*!< Timer enabled on Trigger rising edge
 157:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerBothEdge = 0x7U,          /*!< Timer enabled on Trigger rising or f
 158:../drivers/fsl_flexio.h **** } flexio_timer_enable_condition_t;
 159:../drivers/fsl_flexio.h **** 
 160:../drivers/fsl_flexio.h **** /*! @brief Define type of timer stop bit generate condition.*/
 161:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_stop_bit_condition
 162:../drivers/fsl_flexio.h **** {
 163:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitDisabled = 0x0U,                    /*!< Stop bit disabled. */
 164:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitEnableOnTimerCompare = 0x1U,        /*!< Stop bit is enabled on timer compa
 165:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitEnableOnTimerDisable = 0x2U,        /*!< Stop bit is enabled on timer disab
 166:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitEnableOnTimerCompareDisable = 0x3U, /*!< Stop bit is enabled on timer compa
 167:../drivers/fsl_flexio.h ****                                                              disable. */
 168:../drivers/fsl_flexio.h **** } flexio_timer_stop_bit_condition_t;
 169:../drivers/fsl_flexio.h **** 
 170:../drivers/fsl_flexio.h **** /*! @brief Define type of timer start bit generate condition.*/
 171:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_start_bit_condition
 172:../drivers/fsl_flexio.h **** {
 173:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStartBitDisabled = 0x0U, /*!< Start bit disabled. */
 174:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStartBitEnabled = 0x1U,  /*!< Start bit enabled. */
 175:../drivers/fsl_flexio.h **** } flexio_timer_start_bit_condition_t;
 176:../drivers/fsl_flexio.h **** 
 177:../drivers/fsl_flexio.h **** /*! @brief Define type of timer polarity for shifter control. */
 178:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_timer_polarity
 179:../drivers/fsl_flexio.h **** {
 180:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterTimerPolarityOnPositive = 0x0U, /* Shift on positive edge of shift clock. */
 181:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterTimerPolarityOnNegitive = 0x1U, /* Shift on negative edge of shift clock. */
 182:../drivers/fsl_flexio.h **** } flexio_shifter_timer_polarity_t;
 183:../drivers/fsl_flexio.h **** 
 184:../drivers/fsl_flexio.h **** /*! @brief Define type of shifter working mode.*/
 185:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_mode
 186:../drivers/fsl_flexio.h **** {
 187:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterDisabled = 0x0U,            /*!< Shifter is disabled. */
 188:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeReceive = 0x1U,         /*!< Receive mode. */
 189:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeTransmit = 0x2U,        /*!< Transmit mode. */
 190:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeMatchStore = 0x4U,      /*!< Match store mode. */
 191:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeMatchContinuous = 0x5U, /*!< Match continuous mode. */
 192:../drivers/fsl_flexio.h **** #if FSL_FEATURE_FLEXIO_HAS_STATE_MODE
 193:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeState = 0x6U, /*!< SHIFTBUF contents are used for storing
 194:../drivers/fsl_flexio.h ****                                       programmable state attributes. */
 195:../drivers/fsl_flexio.h **** #endif                               /* FSL_FEATURE_FLEXIO_HAS_STATE_MODE */
 196:../drivers/fsl_flexio.h **** #if FSL_FEATURE_FLEXIO_HAS_LOGIC_MODE
 197:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeLogic = 0x7U, /*!< SHIFTBUF contents are used for implementing
 198:../drivers/fsl_flexio.h ****                                      programmable logic look up table. */
 199:../drivers/fsl_flexio.h **** #endif                               /* FSL_FEATURE_FLEXIO_HAS_LOGIC_MODE */
 200:../drivers/fsl_flexio.h **** } flexio_shifter_mode_t;
 201:../drivers/fsl_flexio.h **** 
 202:../drivers/fsl_flexio.h **** /*! @brief Define type of shifter input source.*/
 203:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_input_source
 204:../drivers/fsl_flexio.h **** {
 205:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterInputFromPin = 0x0U,               /*!< Shifter input from pin. */
 206:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterInputFromNextShifterOutput = 0x1U, /*!< Shifter input from Shifter N+1. */
 207:../drivers/fsl_flexio.h **** } flexio_shifter_input_source_t;
 208:../drivers/fsl_flexio.h **** 
 209:../drivers/fsl_flexio.h **** /*! @brief Define of STOP bit configuration.*/
 210:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_stop_bit
 211:../drivers/fsl_flexio.h **** {
 212:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStopBitDisable = 0x0U, /*!< Disable shifter stop bit. */
 213:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStopBitLow = 0x2U,     /*!< Set shifter stop bit to logic low level. */
 214:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStopBitHigh = 0x3U,    /*!< Set shifter stop bit to logic high level. */
 215:../drivers/fsl_flexio.h **** } flexio_shifter_stop_bit_t;
 216:../drivers/fsl_flexio.h **** 
 217:../drivers/fsl_flexio.h **** /*! @brief Define type of START bit configuration.*/
 218:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_start_bit
 219:../drivers/fsl_flexio.h **** {
 220:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable = 0x0U, /*!< Disable shifter start bit, transmi
 221:../drivers/fsl_flexio.h ****                                                              data on enable. */
 222:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitDisabledLoadDataOnShift = 0x1U,  /*!< Disable shifter start bit, transmi
 223:../drivers/fsl_flexio.h ****                                                              data on first shift. */
 224:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitLow = 0x2U,                      /*!< Set shifter start bit to logic low
 225:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitHigh = 0x3U,                     /*!< Set shifter start bit to logic hig
 226:../drivers/fsl_flexio.h **** } flexio_shifter_start_bit_t;
 227:../drivers/fsl_flexio.h **** 
 228:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO shifter buffer type*/
 229:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_buffer_type
 230:../drivers/fsl_flexio.h **** {
 231:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBuffer = 0x0U,               /*!< Shifter Buffer N Register. */
 232:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferBitSwapped = 0x1U,     /*!< Shifter Buffer N Bit Byte Swapped Register. */
 233:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferByteSwapped = 0x2U,    /*!< Shifter Buffer N Byte Swapped Register. */
 234:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferBitByteSwapped = 0x3U, /*!< Shifter Buffer N Bit Swapped Register. */
 235:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_NIBBLE_BYTE_SWAP) && FSL_FEATURE_FLEXIO_HAS_SHFT_BUF
 236:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferNibbleByteSwapped = 0x4U, /*!< Shifter Buffer N Nibble Byte Swapped Regist
 237:../drivers/fsl_flexio.h **** #endif                                             /*FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_NIBBLE_BYTE
 238:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_HALF_WORD_SWAP) && FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFE
 239:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferHalfWordSwapped = 0x5U, /*!< Shifter Buffer N Half Word Swapped Register. 
 240:../drivers/fsl_flexio.h **** #endif
 241:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_NIBBLE_SWAP) && FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_N
 242:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferNibbleSwapped = 0x6U, /*!< Shifter Buffer N Nibble Swapped Register. */
 243:../drivers/fsl_flexio.h **** #endif
 244:../drivers/fsl_flexio.h **** } flexio_shifter_buffer_type_t;
 245:../drivers/fsl_flexio.h **** 
 246:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO user configuration structure. */
 247:../drivers/fsl_flexio.h **** typedef struct _flexio_config_
 248:../drivers/fsl_flexio.h **** {
 249:../drivers/fsl_flexio.h ****     bool enableFlexio;     /*!< Enable/disable FlexIO module */
 250:../drivers/fsl_flexio.h ****     bool enableInDoze;     /*!< Enable/disable FlexIO operation in doze mode */
 251:../drivers/fsl_flexio.h ****     bool enableInDebug;    /*!< Enable/disable FlexIO operation in debug mode */
 252:../drivers/fsl_flexio.h ****     bool enableFastAccess; /*!< Enable/disable fast access to FlexIO registers, fast access require
 253:../drivers/fsl_flexio.h ****                            the FlexIO clock to be at least twice the frequency of the bus clock. */
 254:../drivers/fsl_flexio.h **** } flexio_config_t;
 255:../drivers/fsl_flexio.h **** 
 256:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO timer configuration structure. */
 257:../drivers/fsl_flexio.h **** typedef struct _flexio_timer_config
 258:../drivers/fsl_flexio.h **** {
 259:../drivers/fsl_flexio.h ****     /* Trigger. */
 260:../drivers/fsl_flexio.h ****     uint32_t triggerSelect;                          /*!< The internal trigger selection number usi
 261:../drivers/fsl_flexio.h ****     flexio_timer_trigger_polarity_t triggerPolarity; /*!< Trigger Polarity. */
 262:../drivers/fsl_flexio.h ****     flexio_timer_trigger_source_t triggerSource;     /*!< Trigger Source, internal (see 'trgsel') o
 263:../drivers/fsl_flexio.h ****     /* Pin. */
 264:../drivers/fsl_flexio.h ****     flexio_pin_config_t pinConfig;     /*!< Timer Pin Configuration. */
 265:../drivers/fsl_flexio.h ****     uint32_t pinSelect;                /*!< Timer Pin number Select. */
 266:../drivers/fsl_flexio.h ****     flexio_pin_polarity_t pinPolarity; /*!< Timer Pin Polarity. */
 267:../drivers/fsl_flexio.h ****     /* Timer. */
 268:../drivers/fsl_flexio.h ****     flexio_timer_mode_t timerMode;                  /*!< Timer work Mode. */
 269:../drivers/fsl_flexio.h ****     flexio_timer_output_t timerOutput;              /*!< Configures the initial state of the Timer 
 270:../drivers/fsl_flexio.h ****                                                     whether it is affected by the Timer reset. */
 271:../drivers/fsl_flexio.h ****     flexio_timer_decrement_source_t timerDecrement; /*!< Configures the source of the Timer decreme
 272:../drivers/fsl_flexio.h ****                                                     source of the Shift clock. */
 273:../drivers/fsl_flexio.h ****     flexio_timer_reset_condition_t timerReset;      /*!< Configures the condition that causes the t
 274:../drivers/fsl_flexio.h ****                                                     (and optionally the timer output) to be reset. 
 275:../drivers/fsl_flexio.h ****     flexio_timer_disable_condition_t timerDisable;  /*!< Configures the condition that causes the T
 276:../drivers/fsl_flexio.h ****                                                     disabled and stop decrementing. */
 277:../drivers/fsl_flexio.h ****     flexio_timer_enable_condition_t timerEnable;    /*!< Configures the condition that causes the T
 278:../drivers/fsl_flexio.h ****                                                     enabled and start decrementing. */
 279:../drivers/fsl_flexio.h ****     flexio_timer_stop_bit_condition_t timerStop;    /*!< Timer STOP Bit generation. */
 280:../drivers/fsl_flexio.h ****     flexio_timer_start_bit_condition_t timerStart;  /*!< Timer STRAT Bit generation. */
 281:../drivers/fsl_flexio.h ****     uint32_t timerCompare;                          /*!< Value for Timer Compare N Register. */
 282:../drivers/fsl_flexio.h **** } flexio_timer_config_t;
 283:../drivers/fsl_flexio.h **** 
 284:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO shifter configuration structure. */
 285:../drivers/fsl_flexio.h **** typedef struct _flexio_shifter_config
 286:../drivers/fsl_flexio.h **** {
 287:../drivers/fsl_flexio.h ****     /* Timer. */
 288:../drivers/fsl_flexio.h ****     uint32_t timerSelect;                          /*!< Selects which Timer is used for controlling
 289:../drivers/fsl_flexio.h ****                                                     logic/shift register and generating the Shift c
 290:../drivers/fsl_flexio.h ****     flexio_shifter_timer_polarity_t timerPolarity; /*!< Timer Polarity. */
 291:../drivers/fsl_flexio.h ****     /* Pin. */
 292:../drivers/fsl_flexio.h ****     flexio_pin_config_t pinConfig;     /*!< Shifter Pin Configuration. */
 293:../drivers/fsl_flexio.h ****     uint32_t pinSelect;                /*!< Shifter Pin number Select. */
 294:../drivers/fsl_flexio.h ****     flexio_pin_polarity_t pinPolarity; /*!< Shifter Pin Polarity. */
 295:../drivers/fsl_flexio.h ****     /* Shifter. */
 296:../drivers/fsl_flexio.h ****     flexio_shifter_mode_t shifterMode; /*!< Configures the mode of the Shifter. */
 297:../drivers/fsl_flexio.h **** #if FSL_FEATURE_FLEXIO_HAS_PARALLEL_WIDTH
 298:../drivers/fsl_flexio.h ****     uint32_t parallelWidth;                    /*!< Configures the parallel width when using parall
 299:../drivers/fsl_flexio.h **** #endif                                         /* FSL_FEATURE_FLEXIO_HAS_PARALLEL_WIDTH */
 300:../drivers/fsl_flexio.h ****     flexio_shifter_input_source_t inputSource; /*!< Selects the input source for the shifter. */
 301:../drivers/fsl_flexio.h ****     flexio_shifter_stop_bit_t shifterStop;     /*!< Shifter STOP bit. */
 302:../drivers/fsl_flexio.h ****     flexio_shifter_start_bit_t shifterStart;   /*!< Shifter START bit. */
 303:../drivers/fsl_flexio.h **** } flexio_shifter_config_t;
 304:../drivers/fsl_flexio.h **** 
 305:../drivers/fsl_flexio.h **** /*! @brief typedef for FlexIO simulated driver interrupt handler.*/
 306:../drivers/fsl_flexio.h **** typedef void (*flexio_isr_t)(void *base, void *handle);
 307:../drivers/fsl_flexio.h **** 
 308:../drivers/fsl_flexio.h **** /*******************************************************************************
 309:../drivers/fsl_flexio.h ****  * API
 310:../drivers/fsl_flexio.h ****  ******************************************************************************/
 311:../drivers/fsl_flexio.h **** 
 312:../drivers/fsl_flexio.h **** #if defined(__cplusplus)
 313:../drivers/fsl_flexio.h **** extern "C" {
 314:../drivers/fsl_flexio.h **** #endif /*_cplusplus*/
 315:../drivers/fsl_flexio.h **** 
 316:../drivers/fsl_flexio.h **** /*!
 317:../drivers/fsl_flexio.h ****  * @name FlexIO Initialization and De-initialization
 318:../drivers/fsl_flexio.h ****  * @{
 319:../drivers/fsl_flexio.h ****  */
 320:../drivers/fsl_flexio.h **** 
 321:../drivers/fsl_flexio.h **** /*!
 322:../drivers/fsl_flexio.h ****  * @brief Gets the default configuration to configure the FlexIO module. The configuration
 323:../drivers/fsl_flexio.h ****  * can used directly to call the FLEXIO_Configure().
 324:../drivers/fsl_flexio.h ****  *
 325:../drivers/fsl_flexio.h ****  * Example:
 326:../drivers/fsl_flexio.h ****    @code
 327:../drivers/fsl_flexio.h ****    flexio_config_t config;
 328:../drivers/fsl_flexio.h ****    FLEXIO_GetDefaultConfig(&config);
 329:../drivers/fsl_flexio.h ****    @endcode
 330:../drivers/fsl_flexio.h ****  *
 331:../drivers/fsl_flexio.h ****  * @param userConfig pointer to flexio_config_t structure
 332:../drivers/fsl_flexio.h **** */
 333:../drivers/fsl_flexio.h **** void FLEXIO_GetDefaultConfig(flexio_config_t *userConfig);
 334:../drivers/fsl_flexio.h **** 
 335:../drivers/fsl_flexio.h **** /*!
 336:../drivers/fsl_flexio.h ****  * @brief Configures the FlexIO with a FlexIO configuration. The configuration structure
 337:../drivers/fsl_flexio.h ****  * can be filled by the user or be set with default values by FLEXIO_GetDefaultConfig().
 338:../drivers/fsl_flexio.h ****  *
 339:../drivers/fsl_flexio.h ****  * Example
 340:../drivers/fsl_flexio.h ****    @code
 341:../drivers/fsl_flexio.h ****    flexio_config_t config = {
 342:../drivers/fsl_flexio.h ****    .enableFlexio = true,
 343:../drivers/fsl_flexio.h ****    .enableInDoze = false,
 344:../drivers/fsl_flexio.h ****    .enableInDebug = true,
 345:../drivers/fsl_flexio.h ****    .enableFastAccess = false
 346:../drivers/fsl_flexio.h ****    };
 347:../drivers/fsl_flexio.h ****    FLEXIO_Configure(base, &config);
 348:../drivers/fsl_flexio.h ****    @endcode
 349:../drivers/fsl_flexio.h ****  *
 350:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 351:../drivers/fsl_flexio.h ****  * @param userConfig pointer to flexio_config_t structure
 352:../drivers/fsl_flexio.h **** */
 353:../drivers/fsl_flexio.h **** void FLEXIO_Init(FLEXIO_Type *base, const flexio_config_t *userConfig);
 354:../drivers/fsl_flexio.h **** 
 355:../drivers/fsl_flexio.h **** /*!
 356:../drivers/fsl_flexio.h ****  * @brief Gates the FlexIO clock. Call this API to stop the FlexIO clock.
 357:../drivers/fsl_flexio.h ****  *
 358:../drivers/fsl_flexio.h ****  * @note After calling this API, call the FLEXO_Init to use the FlexIO module.
 359:../drivers/fsl_flexio.h ****  *
 360:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 361:../drivers/fsl_flexio.h **** */
 362:../drivers/fsl_flexio.h **** void FLEXIO_Deinit(FLEXIO_Type *base);
 363:../drivers/fsl_flexio.h **** 
 364:../drivers/fsl_flexio.h **** /* @} */
 365:../drivers/fsl_flexio.h **** 
 366:../drivers/fsl_flexio.h **** /*!
 367:../drivers/fsl_flexio.h ****  * @name FlexIO Basic Operation
 368:../drivers/fsl_flexio.h ****  * @{
 369:../drivers/fsl_flexio.h ****  */
 370:../drivers/fsl_flexio.h **** 
 371:../drivers/fsl_flexio.h **** /*!
 372:../drivers/fsl_flexio.h ****  * @brief Resets the FlexIO module.
 373:../drivers/fsl_flexio.h ****  *
 374:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 375:../drivers/fsl_flexio.h **** */
 376:../drivers/fsl_flexio.h **** void FLEXIO_Reset(FLEXIO_Type *base);
 377:../drivers/fsl_flexio.h **** 
 378:../drivers/fsl_flexio.h **** /*!
 379:../drivers/fsl_flexio.h ****  * @brief Enables the FlexIO module operation.
 380:../drivers/fsl_flexio.h ****  *
 381:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 382:../drivers/fsl_flexio.h ****  * @param enable true to enable, false to disable.
 383:../drivers/fsl_flexio.h **** */
 384:../drivers/fsl_flexio.h **** static inline void FLEXIO_Enable(FLEXIO_Type *base, bool enable)
 385:../drivers/fsl_flexio.h **** {
 386:../drivers/fsl_flexio.h ****     if (enable)
 387:../drivers/fsl_flexio.h ****     {
 388:../drivers/fsl_flexio.h ****         base->CTRL |= FLEXIO_CTRL_FLEXEN_MASK;
 389:../drivers/fsl_flexio.h ****     }
 390:../drivers/fsl_flexio.h ****     else
 391:../drivers/fsl_flexio.h ****     {
 392:../drivers/fsl_flexio.h ****         base->CTRL &= ~FLEXIO_CTRL_FLEXEN_MASK;
 393:../drivers/fsl_flexio.h ****     }
 394:../drivers/fsl_flexio.h **** }
 395:../drivers/fsl_flexio.h **** 
 396:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_PIN_STATUS) && FSL_FEATURE_FLEXIO_HAS_PIN_STATUS
 397:../drivers/fsl_flexio.h **** /*!
 398:../drivers/fsl_flexio.h ****  * @brief Reads the input data on each of the FlexIO pins.
 399:../drivers/fsl_flexio.h ****  *
 400:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 401:../drivers/fsl_flexio.h ****  * @return FlexIO pin input data
 402:../drivers/fsl_flexio.h **** */
 403:../drivers/fsl_flexio.h **** static inline uint32_t FLEXIO_ReadPinInput(FLEXIO_Type *base)
 404:../drivers/fsl_flexio.h **** {
 405:../drivers/fsl_flexio.h ****     return base->PIN;
 406:../drivers/fsl_flexio.h **** }
 407:../drivers/fsl_flexio.h **** #endif /*FSL_FEATURE_FLEXIO_HAS_PIN_STATUS*/
 408:../drivers/fsl_flexio.h **** 
 409:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_STATE_MODE) && FSL_FEATURE_FLEXIO_HAS_STATE_MODE
 410:../drivers/fsl_flexio.h **** /*!
 411:../drivers/fsl_flexio.h ****  * @brief Gets the current state pointer for state mode use.
 412:../drivers/fsl_flexio.h ****  *
 413:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 414:../drivers/fsl_flexio.h ****  * @return current State pointer
 415:../drivers/fsl_flexio.h **** */
 416:../drivers/fsl_flexio.h **** static inline uint8_t FLEXIO_GetShifterState(FLEXIO_Type *base)
 417:../drivers/fsl_flexio.h **** {
 418:../drivers/fsl_flexio.h ****     return ((base->SHIFTSTATE) & FLEXIO_SHIFTSTATE_STATE_MASK);
 419:../drivers/fsl_flexio.h **** }
 420:../drivers/fsl_flexio.h **** #endif /*FSL_FEATURE_FLEXIO_HAS_STATE_MODE*/
 421:../drivers/fsl_flexio.h **** 
 422:../drivers/fsl_flexio.h **** /*!
 423:../drivers/fsl_flexio.h ****  * @brief Configures the shifter with the shifter configuration. The configuration structure
 424:../drivers/fsl_flexio.h ****  * covers both the SHIFTCTL and SHIFTCFG registers. To configure the shifter to the proper
 425:../drivers/fsl_flexio.h ****  * mode, select which timer controls the shifter to shift, whether to generate start bit/stop
 426:../drivers/fsl_flexio.h ****  *  bit, and the polarity of start bit and stop bit.
 427:../drivers/fsl_flexio.h ****  *
 428:../drivers/fsl_flexio.h ****  * Example
 429:../drivers/fsl_flexio.h ****    @code
 430:../drivers/fsl_flexio.h ****    flexio_shifter_config_t config = {
 431:../drivers/fsl_flexio.h ****    .timerSelect = 0,
 432:../drivers/fsl_flexio.h ****    .timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive,
 433:../drivers/fsl_flexio.h ****    .pinConfig = kFLEXIO_PinConfigOpenDrainOrBidirection,
 434:../drivers/fsl_flexio.h ****    .pinPolarity = kFLEXIO_PinActiveLow,
 435:../drivers/fsl_flexio.h ****    .shifterMode = kFLEXIO_ShifterModeTransmit,
 436:../drivers/fsl_flexio.h ****    .inputSource = kFLEXIO_ShifterInputFromPin,
 437:../drivers/fsl_flexio.h ****    .shifterStop = kFLEXIO_ShifterStopBitHigh,
 438:../drivers/fsl_flexio.h ****    .shifterStart = kFLEXIO_ShifterStartBitLow
 439:../drivers/fsl_flexio.h ****    };
 440:../drivers/fsl_flexio.h ****    FLEXIO_SetShifterConfig(base, &config);
 441:../drivers/fsl_flexio.h ****    @endcode
 442:../drivers/fsl_flexio.h ****  *
 443:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 444:../drivers/fsl_flexio.h ****  * @param index Shifter index
 445:../drivers/fsl_flexio.h ****  * @param shifterConfig Pointer to flexio_shifter_config_t structure
 446:../drivers/fsl_flexio.h **** */
 447:../drivers/fsl_flexio.h **** void FLEXIO_SetShifterConfig(FLEXIO_Type *base, uint8_t index, const flexio_shifter_config_t *shift
 448:../drivers/fsl_flexio.h **** /*!
 449:../drivers/fsl_flexio.h ****  * @brief Configures the timer with the timer configuration. The configuration structure
 450:../drivers/fsl_flexio.h ****  * covers both the TIMCTL and TIMCFG registers. To configure the timer to the proper
 451:../drivers/fsl_flexio.h ****  * mode, select trigger source for timer and the timer pin output and the timing for timer.
 452:../drivers/fsl_flexio.h ****  *
 453:../drivers/fsl_flexio.h ****  * Example
 454:../drivers/fsl_flexio.h ****    @code
 455:../drivers/fsl_flexio.h ****    flexio_timer_config_t config = {
 456:../drivers/fsl_flexio.h ****    .triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(0),
 457:../drivers/fsl_flexio.h ****    .triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveLow,
 458:../drivers/fsl_flexio.h ****    .triggerSource = kFLEXIO_TimerTriggerSourceInternal,
 459:../drivers/fsl_flexio.h ****    .pinConfig = kFLEXIO_PinConfigOpenDrainOrBidirection,
 460:../drivers/fsl_flexio.h ****    .pinSelect = 0,
 461:../drivers/fsl_flexio.h ****    .pinPolarity = kFLEXIO_PinActiveHigh,
 462:../drivers/fsl_flexio.h ****    .timerMode = kFLEXIO_TimerModeDual8BitBaudBit,
 463:../drivers/fsl_flexio.h ****    .timerOutput = kFLEXIO_TimerOutputZeroNotAffectedByReset,
 464:../drivers/fsl_flexio.h ****    .timerDecrement = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput,
 465:../drivers/fsl_flexio.h ****    .timerReset = kFLEXIO_TimerResetOnTimerPinEqualToTimerOutput,
 466:../drivers/fsl_flexio.h ****    .timerDisable = kFLEXIO_TimerDisableOnTimerCompare,
 467:../drivers/fsl_flexio.h ****    .timerEnable = kFLEXIO_TimerEnableOnTriggerHigh,
 468:../drivers/fsl_flexio.h ****    .timerStop = kFLEXIO_TimerStopBitEnableOnTimerDisable,
 469:../drivers/fsl_flexio.h ****    .timerStart = kFLEXIO_TimerStartBitEnabled
 470:../drivers/fsl_flexio.h ****    };
 471:../drivers/fsl_flexio.h ****    FLEXIO_SetTimerConfig(base, &config);
 472:../drivers/fsl_flexio.h ****    @endcode
 473:../drivers/fsl_flexio.h ****  *
 474:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 475:../drivers/fsl_flexio.h ****  * @param index Timer index
 476:../drivers/fsl_flexio.h ****  * @param timerConfig Pointer to the flexio_timer_config_t structure
 477:../drivers/fsl_flexio.h **** */
 478:../drivers/fsl_flexio.h **** void FLEXIO_SetTimerConfig(FLEXIO_Type *base, uint8_t index, const flexio_timer_config_t *timerConf
 479:../drivers/fsl_flexio.h **** 
 480:../drivers/fsl_flexio.h **** /* @} */
 481:../drivers/fsl_flexio.h **** 
 482:../drivers/fsl_flexio.h **** /*!
 483:../drivers/fsl_flexio.h ****  * @name FlexIO Interrupt Operation
 484:../drivers/fsl_flexio.h ****  * @{
 485:../drivers/fsl_flexio.h ****  */
 486:../drivers/fsl_flexio.h **** 
 487:../drivers/fsl_flexio.h **** /*!
 488:../drivers/fsl_flexio.h ****  * @brief Enables the shifter status interrupt. The interrupt generates when the corresponding SSF 
 489:../drivers/fsl_flexio.h ****  *
 490:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 491:../drivers/fsl_flexio.h ****  * @param mask The shifter status mask which can be calculated by (1 << shifter index)
 492:../drivers/fsl_flexio.h ****  * @note For multiple shifter status interrupt enable, for example, two shifter status enable, can 
 493:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 494:../drivers/fsl_flexio.h **** */
 495:../drivers/fsl_flexio.h **** static inline void FLEXIO_EnableShifterStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 496:../drivers/fsl_flexio.h **** {
 497:../drivers/fsl_flexio.h ****     base->SHIFTSIEN |= mask;
 772              		.loc 3 497 0
 773 000e 146A     		ldr	r4, [r2, #32]
 774 0010 2343     		orrs	r3, r4
 775              	.LVL61:
 776 0012 1362     		str	r3, [r2, #32]
 777              	.LVL62:
 778              	.L29:
 779              	.LBE39:
 780              	.LBE38:
 290:../drivers/fsl_flexio_i2s.c ****     }
 291:../drivers/fsl_flexio_i2s.c ****     if (mask & kFLEXIO_I2S_RxDataRegFullInterruptEnable)
 781              		.loc 1 291 0
 782 0014 8B07     		lsls	r3, r1, #30
 783 0016 06D5     		bpl	.L28
 292:../drivers/fsl_flexio_i2s.c ****     {
 293:../drivers/fsl_flexio_i2s.c ****         FLEXIO_EnableShifterStatusInterrupts(base->flexioBase, 1U << base->rxShifterIndex);
 784              		.loc 1 293 0
 785 0018 0268     		ldr	r2, [r0]
 786 001a 417A     		ldrb	r1, [r0, #9]
 787              	.LVL63:
 788 001c 0123     		movs	r3, #1
 789 001e 8B40     		lsls	r3, r3, r1
 790              	.LVL64:
 791              	.LBB40:
 792              	.LBB41:
 793              		.loc 3 497 0
 794 0020 116A     		ldr	r1, [r2, #32]
 795 0022 0B43     		orrs	r3, r1
 796              	.LVL65:
 797 0024 1362     		str	r3, [r2, #32]
 798              	.LVL66:
 799              	.L28:
 800              	.LBE41:
 801              	.LBE40:
 294:../drivers/fsl_flexio_i2s.c ****     }
 295:../drivers/fsl_flexio_i2s.c **** }
 802              		.loc 1 295 0
 803              		@ sp needed
 804 0026 10BD     		pop	{r4, pc}
 805              		.cfi_endproc
 806              	.LFE80:
 808              		.section	.text.FLEXIO_I2S_GetStatusFlags,"ax",%progbits
 809              		.align	1
 810              		.global	FLEXIO_I2S_GetStatusFlags
 811              		.syntax unified
 812              		.code	16
 813              		.thumb_func
 814              		.fpu softvfp
 816              	FLEXIO_I2S_GetStatusFlags:
 817              	.LFB81:
 296:../drivers/fsl_flexio_i2s.c **** 
 297:../drivers/fsl_flexio_i2s.c **** uint32_t FLEXIO_I2S_GetStatusFlags(FLEXIO_I2S_Type *base)
 298:../drivers/fsl_flexio_i2s.c **** {
 818              		.loc 1 298 0
 819              		.cfi_startproc
 820              		@ args = 0, pretend = 0, frame = 0
 821              		@ frame_needed = 0, uses_anonymous_args = 0
 822              	.LVL67:
 823 0000 70B5     		push	{r4, r5, r6, lr}
 824              		.cfi_def_cfa_offset 16
 825              		.cfi_offset 4, -16
 826              		.cfi_offset 5, -12
 827              		.cfi_offset 6, -8
 828              		.cfi_offset 14, -4
 829              	.LVL68:
 299:../drivers/fsl_flexio_i2s.c ****     uint32_t status = 0;
 300:../drivers/fsl_flexio_i2s.c ****     status = ((FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->txShifterIndex)) >> ba
 830              		.loc 1 300 0
 831 0002 0468     		ldr	r4, [r0]
 832              	.LVL69:
 833              	.LBB42:
 834              	.LBB43:
 498:../drivers/fsl_flexio.h **** }
 499:../drivers/fsl_flexio.h **** 
 500:../drivers/fsl_flexio.h **** /*!
 501:../drivers/fsl_flexio.h ****  * @brief Disables the shifter status interrupt. The interrupt won't generate when the correspondin
 502:../drivers/fsl_flexio.h ****  *
 503:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 504:../drivers/fsl_flexio.h ****  * @param mask The shifter status mask which can be calculated by (1 << shifter index)
 505:../drivers/fsl_flexio.h ****  * @note For multiple shifter status interrupt enable, for example, two shifter status enable, can 
 506:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 507:../drivers/fsl_flexio.h **** */
 508:../drivers/fsl_flexio.h **** static inline void FLEXIO_DisableShifterStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 509:../drivers/fsl_flexio.h **** {
 510:../drivers/fsl_flexio.h ****     base->SHIFTSIEN &= ~mask;
 511:../drivers/fsl_flexio.h **** }
 512:../drivers/fsl_flexio.h **** 
 513:../drivers/fsl_flexio.h **** /*!
 514:../drivers/fsl_flexio.h ****  * @brief Enables the shifter error interrupt. The interrupt generates when the corresponding SEF i
 515:../drivers/fsl_flexio.h ****  *
 516:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 517:../drivers/fsl_flexio.h ****  * @param mask The shifter error mask which can be calculated by (1 << shifter index)
 518:../drivers/fsl_flexio.h ****  * @note For multiple shifter error interrupt enable, for example, two shifter error enable, can ca
 519:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 520:../drivers/fsl_flexio.h **** */
 521:../drivers/fsl_flexio.h **** static inline void FLEXIO_EnableShifterErrorInterrupts(FLEXIO_Type *base, uint32_t mask)
 522:../drivers/fsl_flexio.h **** {
 523:../drivers/fsl_flexio.h ****     base->SHIFTEIEN |= mask;
 524:../drivers/fsl_flexio.h **** }
 525:../drivers/fsl_flexio.h **** 
 526:../drivers/fsl_flexio.h **** /*!
 527:../drivers/fsl_flexio.h ****  * @brief Disables the shifter error interrupt. The interrupt won't generate when the corresponding
 528:../drivers/fsl_flexio.h ****  *
 529:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 530:../drivers/fsl_flexio.h ****  * @param mask The shifter error mask which can be calculated by (1 << shifter index)
 531:../drivers/fsl_flexio.h ****  * @note For multiple shifter error interrupt enable, for example, two shifter error enable, can ca
 532:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 533:../drivers/fsl_flexio.h **** */
 534:../drivers/fsl_flexio.h **** static inline void FLEXIO_DisableShifterErrorInterrupts(FLEXIO_Type *base, uint32_t mask)
 535:../drivers/fsl_flexio.h **** {
 536:../drivers/fsl_flexio.h ****     base->SHIFTEIEN &= ~mask;
 537:../drivers/fsl_flexio.h **** }
 538:../drivers/fsl_flexio.h **** 
 539:../drivers/fsl_flexio.h **** /*!
 540:../drivers/fsl_flexio.h ****  * @brief Enables the timer status interrupt. The interrupt generates when the corresponding SSF is
 541:../drivers/fsl_flexio.h ****  *
 542:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 543:../drivers/fsl_flexio.h ****  * @param mask The timer status mask which can be calculated by (1 << timer index)
 544:../drivers/fsl_flexio.h ****  * @note For multiple timer status interrupt enable, for example, two timer status enable, can calc
 545:../drivers/fsl_flexio.h ****  * the mask by using ((1 << timer index0) | (1 << timer index1))
 546:../drivers/fsl_flexio.h **** */
 547:../drivers/fsl_flexio.h **** static inline void FLEXIO_EnableTimerStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 548:../drivers/fsl_flexio.h **** {
 549:../drivers/fsl_flexio.h ****     base->TIMIEN |= mask;
 550:../drivers/fsl_flexio.h **** }
 551:../drivers/fsl_flexio.h **** 
 552:../drivers/fsl_flexio.h **** /*!
 553:../drivers/fsl_flexio.h ****  * @brief Disables the timer status interrupt. The interrupt won't generate when the corresponding 
 554:../drivers/fsl_flexio.h ****  *
 555:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 556:../drivers/fsl_flexio.h ****  * @param mask The timer status mask which can be calculated by (1 << timer index)
 557:../drivers/fsl_flexio.h ****  * @note For multiple timer status interrupt enable, for example, two timer status enable, can calc
 558:../drivers/fsl_flexio.h ****  * the mask by using ((1 << timer index0) | (1 << timer index1))
 559:../drivers/fsl_flexio.h **** */
 560:../drivers/fsl_flexio.h **** static inline void FLEXIO_DisableTimerStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 561:../drivers/fsl_flexio.h **** {
 562:../drivers/fsl_flexio.h ****     base->TIMIEN &= ~mask;
 563:../drivers/fsl_flexio.h **** }
 564:../drivers/fsl_flexio.h **** 
 565:../drivers/fsl_flexio.h **** /* @} */
 566:../drivers/fsl_flexio.h **** 
 567:../drivers/fsl_flexio.h **** /*!
 568:../drivers/fsl_flexio.h ****  * @name FlexIO Status Operation
 569:../drivers/fsl_flexio.h ****  * @{
 570:../drivers/fsl_flexio.h ****  */
 571:../drivers/fsl_flexio.h **** 
 572:../drivers/fsl_flexio.h **** /*!
 573:../drivers/fsl_flexio.h ****  * @brief Gets the shifter status flags.
 574:../drivers/fsl_flexio.h ****  *
 575:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 576:../drivers/fsl_flexio.h ****  * @return Shifter status flags
 577:../drivers/fsl_flexio.h **** */
 578:../drivers/fsl_flexio.h **** static inline uint32_t FLEXIO_GetShifterStatusFlags(FLEXIO_Type *base)
 579:../drivers/fsl_flexio.h **** {
 580:../drivers/fsl_flexio.h ****     return ((base->SHIFTSTAT) & FLEXIO_SHIFTSTAT_SSF_MASK);
 835              		.loc 3 580 0
 836 0004 2269     		ldr	r2, [r4, #16]
 837 0006 0F23     		movs	r3, #15
 838 0008 1A40     		ands	r2, r3
 839              	.LVL70:
 840              	.LBE43:
 841              	.LBE42:
 842              		.loc 1 300 0
 843 000a 057A     		ldrb	r5, [r0, #8]
 844 000c 0121     		movs	r1, #1
 845 000e 0E00     		movs	r6, r1
 846 0010 AE40     		lsls	r6, r6, r5
 847 0012 3240     		ands	r2, r6
 848 0014 EA40     		lsrs	r2, r2, r5
 849              	.LVL71:
 850              	.LBB44:
 851              	.LBB45:
 852              		.loc 3 580 0
 853 0016 2469     		ldr	r4, [r4, #16]
 854              	.LVL72:
 855 0018 2340     		ands	r3, r4
 856              	.LVL73:
 857              	.LBE45:
 858              	.LBE44:
 301:../drivers/fsl_flexio_i2s.c ****     status |=
 302:../drivers/fsl_flexio_i2s.c ****         (((FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->rxShifterIndex)) >> (base-
 859              		.loc 1 302 0
 860 001a 447A     		ldrb	r4, [r0, #9]
 861 001c A140     		lsls	r1, r1, r4
 862 001e 0800     		movs	r0, r1
 863              	.LVL74:
 864 0020 1840     		ands	r0, r3
 865 0022 E040     		lsrs	r0, r0, r4
 303:../drivers/fsl_flexio_i2s.c ****          << 1U);
 866              		.loc 1 303 0
 867 0024 4000     		lsls	r0, r0, #1
 301:../drivers/fsl_flexio_i2s.c ****     status |=
 868              		.loc 1 301 0
 869 0026 1043     		orrs	r0, r2
 870              	.LVL75:
 304:../drivers/fsl_flexio_i2s.c ****     return status;
 305:../drivers/fsl_flexio_i2s.c **** }
 871              		.loc 1 305 0
 872              		@ sp needed
 873 0028 70BD     		pop	{r4, r5, r6, pc}
 874              		.cfi_endproc
 875              	.LFE81:
 877              		.section	.text.FLEXIO_I2S_DisableInterrupts,"ax",%progbits
 878              		.align	1
 879              		.global	FLEXIO_I2S_DisableInterrupts
 880              		.syntax unified
 881              		.code	16
 882              		.thumb_func
 883              		.fpu softvfp
 885              	FLEXIO_I2S_DisableInterrupts:
 886              	.LFB82:
 306:../drivers/fsl_flexio_i2s.c **** 
 307:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_DisableInterrupts(FLEXIO_I2S_Type *base, uint32_t mask)
 308:../drivers/fsl_flexio_i2s.c **** {
 887              		.loc 1 308 0
 888              		.cfi_startproc
 889              		@ args = 0, pretend = 0, frame = 0
 890              		@ frame_needed = 0, uses_anonymous_args = 0
 891              	.LVL76:
 892 0000 10B5     		push	{r4, lr}
 893              		.cfi_def_cfa_offset 8
 894              		.cfi_offset 4, -8
 895              		.cfi_offset 14, -4
 309:../drivers/fsl_flexio_i2s.c ****     if (mask & kFLEXIO_I2S_TxDataRegEmptyInterruptEnable)
 896              		.loc 1 309 0
 897 0002 CB07     		lsls	r3, r1, #31
 898 0004 06D5     		bpl	.L33
 310:../drivers/fsl_flexio_i2s.c ****     {
 311:../drivers/fsl_flexio_i2s.c ****         FLEXIO_DisableShifterStatusInterrupts(base->flexioBase, 1U << base->txShifterIndex);
 899              		.loc 1 311 0
 900 0006 0468     		ldr	r4, [r0]
 901 0008 037A     		ldrb	r3, [r0, #8]
 902 000a 0122     		movs	r2, #1
 903 000c 9A40     		lsls	r2, r2, r3
 904              	.LVL77:
 905              	.LBB46:
 906              	.LBB47:
 510:../drivers/fsl_flexio.h **** }
 907              		.loc 3 510 0
 908 000e 236A     		ldr	r3, [r4, #32]
 909 0010 9343     		bics	r3, r2
 910 0012 2362     		str	r3, [r4, #32]
 911              	.LVL78:
 912              	.L33:
 913              	.LBE47:
 914              	.LBE46:
 312:../drivers/fsl_flexio_i2s.c ****     }
 313:../drivers/fsl_flexio_i2s.c ****     if (mask & kFLEXIO_I2S_RxDataRegFullInterruptEnable)
 915              		.loc 1 313 0
 916 0014 8B07     		lsls	r3, r1, #30
 917 0016 06D5     		bpl	.L32
 314:../drivers/fsl_flexio_i2s.c ****     {
 315:../drivers/fsl_flexio_i2s.c ****         FLEXIO_DisableShifterStatusInterrupts(base->flexioBase, 1U << base->rxShifterIndex);
 918              		.loc 1 315 0
 919 0018 0168     		ldr	r1, [r0]
 920              	.LVL79:
 921 001a 437A     		ldrb	r3, [r0, #9]
 922 001c 0122     		movs	r2, #1
 923 001e 9A40     		lsls	r2, r2, r3
 924              	.LVL80:
 925              	.LBB48:
 926              	.LBB49:
 510:../drivers/fsl_flexio.h **** }
 927              		.loc 3 510 0
 928 0020 0B6A     		ldr	r3, [r1, #32]
 929 0022 9343     		bics	r3, r2
 930 0024 0B62     		str	r3, [r1, #32]
 931              	.LVL81:
 932              	.L32:
 933              	.LBE49:
 934              	.LBE48:
 316:../drivers/fsl_flexio_i2s.c ****     }
 317:../drivers/fsl_flexio_i2s.c **** }
 935              		.loc 1 317 0
 936              		@ sp needed
 937 0026 10BD     		pop	{r4, pc}
 938              		.cfi_endproc
 939              	.LFE82:
 941              		.section	.text.FLEXIO_I2S_MasterSetFormat,"ax",%progbits
 942              		.align	1
 943              		.global	FLEXIO_I2S_MasterSetFormat
 944              		.syntax unified
 945              		.code	16
 946              		.thumb_func
 947              		.fpu softvfp
 949              	FLEXIO_I2S_MasterSetFormat:
 950              	.LFB83:
 318:../drivers/fsl_flexio_i2s.c **** 
 319:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_MasterSetFormat(FLEXIO_I2S_Type *base, flexio_i2s_format_t *format, uint32_t srcClo
 320:../drivers/fsl_flexio_i2s.c **** {
 951              		.loc 1 320 0
 952              		.cfi_startproc
 953              		@ args = 0, pretend = 0, frame = 0
 954              		@ frame_needed = 0, uses_anonymous_args = 0
 955              	.LVL82:
 956 0000 10B5     		push	{r4, lr}
 957              		.cfi_def_cfa_offset 8
 958              		.cfi_offset 4, -8
 959              		.cfi_offset 14, -4
 960 0002 0400     		movs	r4, r0
 321:../drivers/fsl_flexio_i2s.c ****     uint32_t timDiv = srcClock_Hz / (format->sampleRate_Hz * 32U * 2U);
 961              		.loc 1 321 0
 962 0004 4968     		ldr	r1, [r1, #4]
 963              	.LVL83:
 964 0006 8901     		lsls	r1, r1, #6
 965 0008 1000     		movs	r0, r2
 966              	.LVL84:
 967 000a FFF7FEFF 		bl	__aeabi_uidiv
 968              	.LVL85:
 322:../drivers/fsl_flexio_i2s.c ****     uint32_t bclkDiv = 0;
 323:../drivers/fsl_flexio_i2s.c **** 
 324:../drivers/fsl_flexio_i2s.c ****     /* Shall keep bclk and fs div an integer */
 325:../drivers/fsl_flexio_i2s.c ****     if (timDiv % 2)
 969              		.loc 1 325 0
 970 000e C307     		lsls	r3, r0, #31
 971 0010 00D5     		bpl	.L36
 326:../drivers/fsl_flexio_i2s.c ****     {
 327:../drivers/fsl_flexio_i2s.c ****         timDiv += 1U;
 972              		.loc 1 327 0
 973 0012 0130     		adds	r0, r0, #1
 974              	.LVL86:
 975              	.L36:
 328:../drivers/fsl_flexio_i2s.c ****     }
 329:../drivers/fsl_flexio_i2s.c ****     /* Set Frame sync timer cmp */
 330:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCMP[base->fsTimerIndex] = FLEXIO_TIMCMP_CMP(32U * timDiv - 1U);
 976              		.loc 1 330 0
 977 0014 4301     		lsls	r3, r0, #5
 978 0016 013B     		subs	r3, r3, #1
 979 0018 E27A     		ldrb	r2, [r4, #11]
 980 001a 1B04     		lsls	r3, r3, #16
 981 001c 1B0C     		lsrs	r3, r3, #16
 982 001e 4132     		adds	r2, r2, #65
 983 0020 FF32     		adds	r2, r2, #255
 984 0022 9200     		lsls	r2, r2, #2
 985 0024 2168     		ldr	r1, [r4]
 986 0026 5350     		str	r3, [r2, r1]
 331:../drivers/fsl_flexio_i2s.c **** 
 332:../drivers/fsl_flexio_i2s.c ****     /* Set bit clock timer cmp */
 333:../drivers/fsl_flexio_i2s.c ****     bclkDiv = ((timDiv / 2U - 1U) | (63U << 8U));
 987              		.loc 1 333 0
 988 0028 4008     		lsrs	r0, r0, #1
 989              	.LVL87:
 990 002a 0138     		subs	r0, r0, #1
 991              	.LVL88:
 334:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCMP[base->bclkTimerIndex] = FLEXIO_TIMCMP_CMP(bclkDiv);
 992              		.loc 1 334 0
 993 002c 2168     		ldr	r1, [r4]
 994 002e A37A     		ldrb	r3, [r4, #10]
 995 0030 0004     		lsls	r0, r0, #16
 996              	.LVL89:
 997 0032 000C     		lsrs	r0, r0, #16
 998 0034 FC22     		movs	r2, #252
 999 0036 9201     		lsls	r2, r2, #6
 1000 0038 1043     		orrs	r0, r2
 1001 003a 4133     		adds	r3, r3, #65
 1002 003c FF33     		adds	r3, r3, #255
 1003 003e 9B00     		lsls	r3, r3, #2
 1004 0040 5850     		str	r0, [r3, r1]
 335:../drivers/fsl_flexio_i2s.c **** }
 1005              		.loc 1 335 0
 1006              		@ sp needed
 1007              	.LVL90:
 1008 0042 10BD     		pop	{r4, pc}
 1009              		.cfi_endproc
 1010              	.LFE83:
 1012              		.section	.text.FLEXIO_I2S_SlaveSetFormat,"ax",%progbits
 1013              		.align	1
 1014              		.global	FLEXIO_I2S_SlaveSetFormat
 1015              		.syntax unified
 1016              		.code	16
 1017              		.thumb_func
 1018              		.fpu softvfp
 1020              	FLEXIO_I2S_SlaveSetFormat:
 1021              	.LFB84:
 336:../drivers/fsl_flexio_i2s.c **** 
 337:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_SlaveSetFormat(FLEXIO_I2S_Type *base, flexio_i2s_format_t *format)
 338:../drivers/fsl_flexio_i2s.c **** {
 1022              		.loc 1 338 0
 1023              		.cfi_startproc
 1024              		@ args = 0, pretend = 0, frame = 0
 1025              		@ frame_needed = 0, uses_anonymous_args = 0
 1026              		@ link register save eliminated.
 1027              	.LVL91:
 339:../drivers/fsl_flexio_i2s.c ****     /* Set Frame sync timer cmp */
 340:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCMP[base->fsTimerIndex] = FLEXIO_TIMCMP_CMP(32U * 4U - 3U);
 1028              		.loc 1 340 0
 1029 0000 C37A     		ldrb	r3, [r0, #11]
 1030 0002 4133     		adds	r3, r3, #65
 1031 0004 FF33     		adds	r3, r3, #255
 1032 0006 9B00     		lsls	r3, r3, #2
 1033 0008 7D22     		movs	r2, #125
 1034 000a 0168     		ldr	r1, [r0]
 1035              	.LVL92:
 1036 000c 5A50     		str	r2, [r3, r1]
 341:../drivers/fsl_flexio_i2s.c **** 
 342:../drivers/fsl_flexio_i2s.c ****     /* Set bit clock timer cmp */
 343:../drivers/fsl_flexio_i2s.c ****     base->flexioBase->TIMCMP[base->bclkTimerIndex] = FLEXIO_TIMCMP_CMP(32U * 2U - 1U);
 1037              		.loc 1 343 0
 1038 000e 0268     		ldr	r2, [r0]
 1039 0010 837A     		ldrb	r3, [r0, #10]
 1040 0012 4133     		adds	r3, r3, #65
 1041 0014 FF33     		adds	r3, r3, #255
 1042 0016 9B00     		lsls	r3, r3, #2
 1043 0018 3F21     		movs	r1, #63
 1044 001a 9950     		str	r1, [r3, r2]
 344:../drivers/fsl_flexio_i2s.c **** }
 1045              		.loc 1 344 0
 1046              		@ sp needed
 1047 001c 7047     		bx	lr
 1048              		.cfi_endproc
 1049              	.LFE84:
 1051              		.section	.text.FLEXIO_I2S_WriteBlocking,"ax",%progbits
 1052              		.align	1
 1053              		.global	FLEXIO_I2S_WriteBlocking
 1054              		.syntax unified
 1055              		.code	16
 1056              		.thumb_func
 1057              		.fpu softvfp
 1059              	FLEXIO_I2S_WriteBlocking:
 1060              	.LFB85:
 345:../drivers/fsl_flexio_i2s.c **** 
 346:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_WriteBlocking(FLEXIO_I2S_Type *base, uint8_t bitWidth, uint8_t *txData, size_t size
 347:../drivers/fsl_flexio_i2s.c **** {
 1061              		.loc 1 347 0
 1062              		.cfi_startproc
 1063              		@ args = 0, pretend = 0, frame = 8
 1064              		@ frame_needed = 0, uses_anonymous_args = 0
 1065              	.LVL93:
 1066 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1067              		.cfi_def_cfa_offset 20
 1068              		.cfi_offset 4, -20
 1069              		.cfi_offset 5, -16
 1070              		.cfi_offset 6, -12
 1071              		.cfi_offset 7, -8
 1072              		.cfi_offset 14, -4
 1073 0002 83B0     		sub	sp, sp, #12
 1074              		.cfi_def_cfa_offset 32
 1075 0004 0400     		movs	r4, r0
 1076 0006 0191     		str	r1, [sp, #4]
 1077 0008 1600     		movs	r6, r2
 1078 000a 0093     		str	r3, [sp]
 1079              	.LVL94:
 348:../drivers/fsl_flexio_i2s.c ****     uint32_t i = 0;
 349:../drivers/fsl_flexio_i2s.c ****     uint8_t bytesPerWord = bitWidth / 8U;
 1080              		.loc 1 349 0
 1081 000c CD08     		lsrs	r5, r1, #3
 1082              	.LVL95:
 350:../drivers/fsl_flexio_i2s.c **** 
 351:../drivers/fsl_flexio_i2s.c ****     for (i = 0; i < size / bytesPerWord; i++)
 1083              		.loc 1 351 0
 1084 000e 0027     		movs	r7, #0
 1085 0010 0CE0     		b	.L39
 1086              	.LVL96:
 1087              	.L40:
 352:../drivers/fsl_flexio_i2s.c ****     {
 353:../drivers/fsl_flexio_i2s.c ****         /* Wait until it can write data */
 354:../drivers/fsl_flexio_i2s.c ****         while ((FLEXIO_I2S_GetStatusFlags(base) & kFLEXIO_I2S_TxDataRegEmptyFlag) == 0)
 1088              		.loc 1 354 0 discriminator 1
 1089 0012 2000     		movs	r0, r4
 1090 0014 FFF7FEFF 		bl	FLEXIO_I2S_GetStatusFlags
 1091              	.LVL97:
 1092 0018 C307     		lsls	r3, r0, #31
 1093 001a FAD5     		bpl	.L40
 355:../drivers/fsl_flexio_i2s.c ****         {
 356:../drivers/fsl_flexio_i2s.c ****         }
 357:../drivers/fsl_flexio_i2s.c **** 
 358:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_WriteNonBlocking(base, bitWidth, txData, bytesPerWord);
 1094              		.loc 1 358 0 discriminator 2
 1095 001c 2B00     		movs	r3, r5
 1096 001e 3200     		movs	r2, r6
 1097 0020 0199     		ldr	r1, [sp, #4]
 1098 0022 2000     		movs	r0, r4
 1099 0024 FFF7FEFF 		bl	FLEXIO_I2S_WriteNonBlocking
 1100              	.LVL98:
 359:../drivers/fsl_flexio_i2s.c ****         txData += bytesPerWord;
 1101              		.loc 1 359 0 discriminator 2
 1102 0028 7619     		adds	r6, r6, r5
 1103              	.LVL99:
 351:../drivers/fsl_flexio_i2s.c ****     {
 1104              		.loc 1 351 0 discriminator 2
 1105 002a 0137     		adds	r7, r7, #1
 1106              	.LVL100:
 1107              	.L39:
 351:../drivers/fsl_flexio_i2s.c ****     {
 1108              		.loc 1 351 0 is_stmt 0 discriminator 1
 1109 002c 2900     		movs	r1, r5
 1110 002e 0098     		ldr	r0, [sp]
 1111 0030 FFF7FEFF 		bl	__aeabi_uidiv
 1112              	.LVL101:
 1113 0034 B842     		cmp	r0, r7
 1114 0036 ECD8     		bhi	.L40
 1115              	.L41:
 360:../drivers/fsl_flexio_i2s.c ****     }
 361:../drivers/fsl_flexio_i2s.c **** 
 362:../drivers/fsl_flexio_i2s.c ****     /* Wait until the last data is sent */
 363:../drivers/fsl_flexio_i2s.c ****     while ((FLEXIO_I2S_GetStatusFlags(base) & kFLEXIO_I2S_TxDataRegEmptyFlag) == 0)
 1116              		.loc 1 363 0 is_stmt 1 discriminator 1
 1117 0038 2000     		movs	r0, r4
 1118 003a FFF7FEFF 		bl	FLEXIO_I2S_GetStatusFlags
 1119              	.LVL102:
 1120 003e C307     		lsls	r3, r0, #31
 1121 0040 FAD5     		bpl	.L41
 364:../drivers/fsl_flexio_i2s.c ****     {
 365:../drivers/fsl_flexio_i2s.c ****     }
 366:../drivers/fsl_flexio_i2s.c **** }
 1122              		.loc 1 366 0
 1123 0042 03B0     		add	sp, sp, #12
 1124              	.LVL103:
 1125              		@ sp needed
 1126              	.LVL104:
 1127              	.LVL105:
 1128              	.LVL106:
 1129              	.LVL107:
 1130 0044 F0BD     		pop	{r4, r5, r6, r7, pc}
 1131              		.cfi_endproc
 1132              	.LFE85:
 1134              		.section	.text.FLEXIO_I2S_ReadBlocking,"ax",%progbits
 1135              		.align	1
 1136              		.global	FLEXIO_I2S_ReadBlocking
 1137              		.syntax unified
 1138              		.code	16
 1139              		.thumb_func
 1140              		.fpu softvfp
 1142              	FLEXIO_I2S_ReadBlocking:
 1143              	.LFB86:
 367:../drivers/fsl_flexio_i2s.c **** 
 368:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_ReadBlocking(FLEXIO_I2S_Type *base, uint8_t bitWidth, uint8_t *rxData, size_t size)
 369:../drivers/fsl_flexio_i2s.c **** {
 1144              		.loc 1 369 0
 1145              		.cfi_startproc
 1146              		@ args = 0, pretend = 0, frame = 8
 1147              		@ frame_needed = 0, uses_anonymous_args = 0
 1148              	.LVL108:
 1149 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1150              		.cfi_def_cfa_offset 20
 1151              		.cfi_offset 4, -20
 1152              		.cfi_offset 5, -16
 1153              		.cfi_offset 6, -12
 1154              		.cfi_offset 7, -8
 1155              		.cfi_offset 14, -4
 1156 0002 83B0     		sub	sp, sp, #12
 1157              		.cfi_def_cfa_offset 32
 1158 0004 0700     		movs	r7, r0
 1159 0006 0191     		str	r1, [sp, #4]
 1160 0008 1500     		movs	r5, r2
 1161 000a 0093     		str	r3, [sp]
 1162              	.LVL109:
 370:../drivers/fsl_flexio_i2s.c ****     uint32_t i = 0;
 371:../drivers/fsl_flexio_i2s.c ****     uint8_t bytesPerWord = bitWidth / 8U;
 1163              		.loc 1 371 0
 1164 000c CC08     		lsrs	r4, r1, #3
 1165              	.LVL110:
 372:../drivers/fsl_flexio_i2s.c **** 
 373:../drivers/fsl_flexio_i2s.c ****     for (i = 0; i < size / bytesPerWord; i++)
 1166              		.loc 1 373 0
 1167 000e 0026     		movs	r6, #0
 1168 0010 10E0     		b	.L43
 1169              	.LVL111:
 1170              	.L44:
 374:../drivers/fsl_flexio_i2s.c ****     {
 375:../drivers/fsl_flexio_i2s.c ****         /* Wait until data is received */
 376:../drivers/fsl_flexio_i2s.c ****         while (!(FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->rxShifterIndex)))
 1171              		.loc 1 376 0 discriminator 1
 1172 0012 3B68     		ldr	r3, [r7]
 1173              	.LVL112:
 1174              	.LBB50:
 1175              	.LBB51:
 1176              		.loc 3 580 0 discriminator 1
 1177 0014 1B69     		ldr	r3, [r3, #16]
 1178              	.LVL113:
 1179 0016 0F22     		movs	r2, #15
 1180 0018 1A40     		ands	r2, r3
 1181              	.LVL114:
 1182              	.LBE51:
 1183              	.LBE50:
 1184              		.loc 1 376 0 discriminator 1
 1185 001a 797A     		ldrb	r1, [r7, #9]
 1186 001c 0123     		movs	r3, #1
 1187 001e 8B40     		lsls	r3, r3, r1
 1188 0020 1A42     		tst	r2, r3
 1189 0022 F6D0     		beq	.L44
 377:../drivers/fsl_flexio_i2s.c ****         {
 378:../drivers/fsl_flexio_i2s.c ****         }
 379:../drivers/fsl_flexio_i2s.c **** 
 380:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_ReadNonBlocking(base, bitWidth, rxData, bytesPerWord);
 1190              		.loc 1 380 0 discriminator 2
 1191 0024 2300     		movs	r3, r4
 1192 0026 2A00     		movs	r2, r5
 1193 0028 0199     		ldr	r1, [sp, #4]
 1194 002a 3800     		movs	r0, r7
 1195 002c FFF7FEFF 		bl	FLEXIO_I2S_ReadNonBlocking
 1196              	.LVL115:
 381:../drivers/fsl_flexio_i2s.c ****         rxData += bytesPerWord;
 1197              		.loc 1 381 0 discriminator 2
 1198 0030 2D19     		adds	r5, r5, r4
 1199              	.LVL116:
 373:../drivers/fsl_flexio_i2s.c ****     {
 1200              		.loc 1 373 0 discriminator 2
 1201 0032 0136     		adds	r6, r6, #1
 1202              	.LVL117:
 1203              	.L43:
 373:../drivers/fsl_flexio_i2s.c ****     {
 1204              		.loc 1 373 0 is_stmt 0 discriminator 1
 1205 0034 2100     		movs	r1, r4
 1206 0036 0098     		ldr	r0, [sp]
 1207 0038 FFF7FEFF 		bl	__aeabi_uidiv
 1208              	.LVL118:
 1209 003c B042     		cmp	r0, r6
 1210 003e E8D8     		bhi	.L44
 382:../drivers/fsl_flexio_i2s.c ****     }
 383:../drivers/fsl_flexio_i2s.c **** }
 1211              		.loc 1 383 0 is_stmt 1
 1212 0040 03B0     		add	sp, sp, #12
 1213              	.LVL119:
 1214              		@ sp needed
 1215              	.LVL120:
 1216              	.LVL121:
 1217              	.LVL122:
 1218              	.LVL123:
 1219 0042 F0BD     		pop	{r4, r5, r6, r7, pc}
 1220              		.cfi_endproc
 1221              	.LFE86:
 1223              		.section	.text.FLEXIO_I2S_TransferTxCreateHandle,"ax",%progbits
 1224              		.align	1
 1225              		.global	FLEXIO_I2S_TransferTxCreateHandle
 1226              		.syntax unified
 1227              		.code	16
 1228              		.thumb_func
 1229              		.fpu softvfp
 1231              	FLEXIO_I2S_TransferTxCreateHandle:
 1232              	.LFB87:
 384:../drivers/fsl_flexio_i2s.c **** 
 385:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferTxCreateHandle(FLEXIO_I2S_Type *base,
 386:../drivers/fsl_flexio_i2s.c ****                                        flexio_i2s_handle_t *handle,
 387:../drivers/fsl_flexio_i2s.c ****                                        flexio_i2s_callback_t callback,
 388:../drivers/fsl_flexio_i2s.c ****                                        void *userData)
 389:../drivers/fsl_flexio_i2s.c **** {
 1233              		.loc 1 389 0
 1234              		.cfi_startproc
 1235              		@ args = 0, pretend = 0, frame = 0
 1236              		@ frame_needed = 0, uses_anonymous_args = 0
 1237              	.LVL124:
 1238 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1239              		.cfi_def_cfa_offset 24
 1240              		.cfi_offset 3, -24
 1241              		.cfi_offset 4, -20
 1242              		.cfi_offset 5, -16
 1243              		.cfi_offset 6, -12
 1244              		.cfi_offset 7, -8
 1245              		.cfi_offset 14, -4
 1246 0002 0500     		movs	r5, r0
 1247 0004 0C00     		movs	r4, r1
 1248 0006 1700     		movs	r7, r2
 1249 0008 1E00     		movs	r6, r3
 390:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 391:../drivers/fsl_flexio_i2s.c **** 
 392:../drivers/fsl_flexio_i2s.c ****     IRQn_Type flexio_irqs[] = FLEXIO_IRQS;
 393:../drivers/fsl_flexio_i2s.c **** 
 394:../drivers/fsl_flexio_i2s.c ****     /* Zero the handle. */
 395:../drivers/fsl_flexio_i2s.c ****     memset(handle, 0, sizeof(*handle));
 1250              		.loc 1 395 0
 1251 000a 4422     		movs	r2, #68
 1252              	.LVL125:
 1253 000c 0021     		movs	r1, #0
 1254              	.LVL126:
 1255 000e 2000     		movs	r0, r4
 1256              	.LVL127:
 1257 0010 FFF7FEFF 		bl	memset
 1258              	.LVL128:
 396:../drivers/fsl_flexio_i2s.c **** 
 397:../drivers/fsl_flexio_i2s.c ****     /* Store callback and user data. */
 398:../drivers/fsl_flexio_i2s.c ****     handle->callback = callback;
 1259              		.loc 1 398 0
 1260 0014 6760     		str	r7, [r4, #4]
 399:../drivers/fsl_flexio_i2s.c ****     handle->userData = userData;
 1261              		.loc 1 399 0
 1262 0016 A660     		str	r6, [r4, #8]
 400:../drivers/fsl_flexio_i2s.c **** 
 401:../drivers/fsl_flexio_i2s.c ****     /* Save the context in global variables to support the double weak mechanism. */
 402:../drivers/fsl_flexio_i2s.c ****     FLEXIO_RegisterHandleIRQ(base, handle, FLEXIO_I2S_TransferTxHandleIRQ);
 1263              		.loc 1 402 0
 1264 0018 074A     		ldr	r2, .L46
 1265 001a 2100     		movs	r1, r4
 1266 001c 2800     		movs	r0, r5
 1267 001e FFF7FEFF 		bl	FLEXIO_RegisterHandleIRQ
 1268              	.LVL129:
 403:../drivers/fsl_flexio_i2s.c **** 
 404:../drivers/fsl_flexio_i2s.c ****     /* Set the TX/RX state. */
 405:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Idle;
 1269              		.loc 1 405 0
 1270 0022 0123     		movs	r3, #1
 1271 0024 2360     		str	r3, [r4]
 406:../drivers/fsl_flexio_i2s.c **** 
 407:../drivers/fsl_flexio_i2s.c ****     /* Enable interrupt in NVIC. */
 408:../drivers/fsl_flexio_i2s.c ****     EnableIRQ(flexio_irqs[FLEXIO_I2S_GetInstance(base)]);
 1272              		.loc 1 408 0
 1273 0026 2800     		movs	r0, r5
 1274 0028 FFF7FEFF 		bl	FLEXIO_I2S_GetInstance
 1275              	.LVL130:
 1276              	.LBB52:
 1277              	.LBB53:
 1278              	.LBB54:
 1279              		.file 4 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 1280              		.loc 4 735 0
 1281 002c 034B     		ldr	r3, .L46+4
 1282 002e 8022     		movs	r2, #128
 1283 0030 D201     		lsls	r2, r2, #7
 1284 0032 1A60     		str	r2, [r3]
 1285              	.LVL131:
 1286              	.LBE54:
 1287              	.LBE53:
 1288              	.LBE52:
 409:../drivers/fsl_flexio_i2s.c **** }
 1289              		.loc 1 409 0
 1290              		@ sp needed
 1291              	.LVL132:
 1292              	.LVL133:
 1293              	.LVL134:
 1294              	.LVL135:
 1295 0034 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1296              	.L47:
 1297 0036 C046     		.align	2
 1298              	.L46:
 1299 0038 00000000 		.word	FLEXIO_I2S_TransferTxHandleIRQ
 1300 003c 00E100E0 		.word	-536813312
 1301              		.cfi_endproc
 1302              	.LFE87:
 1304              		.section	.text.FLEXIO_I2S_TransferRxCreateHandle,"ax",%progbits
 1305              		.align	1
 1306              		.global	FLEXIO_I2S_TransferRxCreateHandle
 1307              		.syntax unified
 1308              		.code	16
 1309              		.thumb_func
 1310              		.fpu softvfp
 1312              	FLEXIO_I2S_TransferRxCreateHandle:
 1313              	.LFB88:
 410:../drivers/fsl_flexio_i2s.c **** 
 411:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferRxCreateHandle(FLEXIO_I2S_Type *base,
 412:../drivers/fsl_flexio_i2s.c ****                                        flexio_i2s_handle_t *handle,
 413:../drivers/fsl_flexio_i2s.c ****                                        flexio_i2s_callback_t callback,
 414:../drivers/fsl_flexio_i2s.c ****                                        void *userData)
 415:../drivers/fsl_flexio_i2s.c **** {
 1314              		.loc 1 415 0
 1315              		.cfi_startproc
 1316              		@ args = 0, pretend = 0, frame = 0
 1317              		@ frame_needed = 0, uses_anonymous_args = 0
 1318              	.LVL136:
 1319 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1320              		.cfi_def_cfa_offset 24
 1321              		.cfi_offset 3, -24
 1322              		.cfi_offset 4, -20
 1323              		.cfi_offset 5, -16
 1324              		.cfi_offset 6, -12
 1325              		.cfi_offset 7, -8
 1326              		.cfi_offset 14, -4
 1327 0002 0500     		movs	r5, r0
 1328 0004 0C00     		movs	r4, r1
 1329 0006 1700     		movs	r7, r2
 1330 0008 1E00     		movs	r6, r3
 416:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 417:../drivers/fsl_flexio_i2s.c **** 
 418:../drivers/fsl_flexio_i2s.c ****     IRQn_Type flexio_irqs[] = FLEXIO_IRQS;
 419:../drivers/fsl_flexio_i2s.c **** 
 420:../drivers/fsl_flexio_i2s.c ****     /* Zero the handle. */
 421:../drivers/fsl_flexio_i2s.c ****     memset(handle, 0, sizeof(*handle));
 1331              		.loc 1 421 0
 1332 000a 4422     		movs	r2, #68
 1333              	.LVL137:
 1334 000c 0021     		movs	r1, #0
 1335              	.LVL138:
 1336 000e 2000     		movs	r0, r4
 1337              	.LVL139:
 1338 0010 FFF7FEFF 		bl	memset
 1339              	.LVL140:
 422:../drivers/fsl_flexio_i2s.c **** 
 423:../drivers/fsl_flexio_i2s.c ****     /* Store callback and user data. */
 424:../drivers/fsl_flexio_i2s.c ****     handle->callback = callback;
 1340              		.loc 1 424 0
 1341 0014 6760     		str	r7, [r4, #4]
 425:../drivers/fsl_flexio_i2s.c ****     handle->userData = userData;
 1342              		.loc 1 425 0
 1343 0016 A660     		str	r6, [r4, #8]
 426:../drivers/fsl_flexio_i2s.c **** 
 427:../drivers/fsl_flexio_i2s.c ****     /* Save the context in global variables to support the double weak mechanism. */
 428:../drivers/fsl_flexio_i2s.c ****     FLEXIO_RegisterHandleIRQ(base, handle, FLEXIO_I2S_TransferRxHandleIRQ);
 1344              		.loc 1 428 0
 1345 0018 074A     		ldr	r2, .L49
 1346 001a 2100     		movs	r1, r4
 1347 001c 2800     		movs	r0, r5
 1348 001e FFF7FEFF 		bl	FLEXIO_RegisterHandleIRQ
 1349              	.LVL141:
 429:../drivers/fsl_flexio_i2s.c **** 
 430:../drivers/fsl_flexio_i2s.c ****     /* Set the TX/RX state. */
 431:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Idle;
 1350              		.loc 1 431 0
 1351 0022 0123     		movs	r3, #1
 1352 0024 2360     		str	r3, [r4]
 432:../drivers/fsl_flexio_i2s.c **** 
 433:../drivers/fsl_flexio_i2s.c ****     /* Enable interrupt in NVIC. */
 434:../drivers/fsl_flexio_i2s.c ****     EnableIRQ(flexio_irqs[FLEXIO_I2S_GetInstance(base)]);
 1353              		.loc 1 434 0
 1354 0026 2800     		movs	r0, r5
 1355 0028 FFF7FEFF 		bl	FLEXIO_I2S_GetInstance
 1356              	.LVL142:
 1357              	.LBB55:
 1358              	.LBB56:
 1359              	.LBB57:
 1360              		.loc 4 735 0
 1361 002c 034B     		ldr	r3, .L49+4
 1362 002e 8022     		movs	r2, #128
 1363 0030 D201     		lsls	r2, r2, #7
 1364 0032 1A60     		str	r2, [r3]
 1365              	.LVL143:
 1366              	.LBE57:
 1367              	.LBE56:
 1368              	.LBE55:
 435:../drivers/fsl_flexio_i2s.c **** }
 1369              		.loc 1 435 0
 1370              		@ sp needed
 1371              	.LVL144:
 1372              	.LVL145:
 1373              	.LVL146:
 1374              	.LVL147:
 1375 0034 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1376              	.L50:
 1377 0036 C046     		.align	2
 1378              	.L49:
 1379 0038 00000000 		.word	FLEXIO_I2S_TransferRxHandleIRQ
 1380 003c 00E100E0 		.word	-536813312
 1381              		.cfi_endproc
 1382              	.LFE88:
 1384              		.section	.text.FLEXIO_I2S_TransferSetFormat,"ax",%progbits
 1385              		.align	1
 1386              		.global	FLEXIO_I2S_TransferSetFormat
 1387              		.syntax unified
 1388              		.code	16
 1389              		.thumb_func
 1390              		.fpu softvfp
 1392              	FLEXIO_I2S_TransferSetFormat:
 1393              	.LFB89:
 436:../drivers/fsl_flexio_i2s.c **** 
 437:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferSetFormat(FLEXIO_I2S_Type *base,
 438:../drivers/fsl_flexio_i2s.c ****                                   flexio_i2s_handle_t *handle,
 439:../drivers/fsl_flexio_i2s.c ****                                   flexio_i2s_format_t *format,
 440:../drivers/fsl_flexio_i2s.c ****                                   uint32_t srcClock_Hz)
 441:../drivers/fsl_flexio_i2s.c **** {
 1394              		.loc 1 441 0
 1395              		.cfi_startproc
 1396              		@ args = 0, pretend = 0, frame = 0
 1397              		@ frame_needed = 0, uses_anonymous_args = 0
 1398              	.LVL148:
 1399 0000 10B5     		push	{r4, lr}
 1400              		.cfi_def_cfa_offset 8
 1401              		.cfi_offset 4, -8
 1402              		.cfi_offset 14, -4
 1403 0002 1400     		movs	r4, r2
 442:../drivers/fsl_flexio_i2s.c ****     assert(handle && format);
 443:../drivers/fsl_flexio_i2s.c **** 
 444:../drivers/fsl_flexio_i2s.c ****     /* Set the bitWidth to handle */
 445:../drivers/fsl_flexio_i2s.c ****     handle->bitWidth = format->bitWidth;
 1404              		.loc 1 445 0
 1405 0004 1278     		ldrb	r2, [r2]
 1406              	.LVL149:
 1407 0006 0A73     		strb	r2, [r1, #12]
 446:../drivers/fsl_flexio_i2s.c **** 
 447:../drivers/fsl_flexio_i2s.c ****     /* Set sample rate */
 448:../drivers/fsl_flexio_i2s.c ****     if (srcClock_Hz != 0)
 1408              		.loc 1 448 0
 1409 0008 002B     		cmp	r3, #0
 1410 000a 03D1     		bne	.L54
 449:../drivers/fsl_flexio_i2s.c ****     {
 450:../drivers/fsl_flexio_i2s.c ****         /* It is master */
 451:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_MasterSetFormat(base, format, srcClock_Hz);
 452:../drivers/fsl_flexio_i2s.c ****     }
 453:../drivers/fsl_flexio_i2s.c ****     else
 454:../drivers/fsl_flexio_i2s.c ****     {
 455:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_SlaveSetFormat(base, format);
 1411              		.loc 1 455 0
 1412 000c 2100     		movs	r1, r4
 1413              	.LVL150:
 1414 000e FFF7FEFF 		bl	FLEXIO_I2S_SlaveSetFormat
 1415              	.LVL151:
 1416              	.L51:
 456:../drivers/fsl_flexio_i2s.c ****     }
 457:../drivers/fsl_flexio_i2s.c **** }
 1417              		.loc 1 457 0
 1418              		@ sp needed
 1419              	.LVL152:
 1420 0012 10BD     		pop	{r4, pc}
 1421              	.LVL153:
 1422              	.L54:
 451:../drivers/fsl_flexio_i2s.c ****     }
 1423              		.loc 1 451 0
 1424 0014 1A00     		movs	r2, r3
 1425 0016 2100     		movs	r1, r4
 1426              	.LVL154:
 1427 0018 FFF7FEFF 		bl	FLEXIO_I2S_MasterSetFormat
 1428              	.LVL155:
 1429 001c F9E7     		b	.L51
 1430              		.cfi_endproc
 1431              	.LFE89:
 1433              		.section	.text.FLEXIO_I2S_TransferSendNonBlocking,"ax",%progbits
 1434              		.align	1
 1435              		.global	FLEXIO_I2S_TransferSendNonBlocking
 1436              		.syntax unified
 1437              		.code	16
 1438              		.thumb_func
 1439              		.fpu softvfp
 1441              	FLEXIO_I2S_TransferSendNonBlocking:
 1442              	.LFB90:
 458:../drivers/fsl_flexio_i2s.c **** 
 459:../drivers/fsl_flexio_i2s.c **** status_t FLEXIO_I2S_TransferSendNonBlocking(FLEXIO_I2S_Type *base,
 460:../drivers/fsl_flexio_i2s.c ****                                             flexio_i2s_handle_t *handle,
 461:../drivers/fsl_flexio_i2s.c ****                                             flexio_i2s_transfer_t *xfer)
 462:../drivers/fsl_flexio_i2s.c **** {
 1443              		.loc 1 462 0
 1444              		.cfi_startproc
 1445              		@ args = 0, pretend = 0, frame = 0
 1446              		@ frame_needed = 0, uses_anonymous_args = 0
 1447              	.LVL156:
 1448 0000 70B5     		push	{r4, r5, r6, lr}
 1449              		.cfi_def_cfa_offset 16
 1450              		.cfi_offset 4, -16
 1451              		.cfi_offset 5, -12
 1452              		.cfi_offset 6, -8
 1453              		.cfi_offset 14, -4
 1454 0002 0400     		movs	r4, r0
 463:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 464:../drivers/fsl_flexio_i2s.c **** 
 465:../drivers/fsl_flexio_i2s.c ****     /* Check if the queue is full */
 466:../drivers/fsl_flexio_i2s.c ****     if (handle->queue[handle->queueUser].data)
 1455              		.loc 1 466 0
 1456 0004 4023     		movs	r3, #64
 1457 0006 CB5C     		ldrb	r3, [r1, r3]
 1458 0008 0233     		adds	r3, r3, #2
 1459 000a DB00     		lsls	r3, r3, #3
 1460 000c 5B58     		ldr	r3, [r3, r1]
 1461 000e 002B     		cmp	r3, #0
 1462 0010 02D0     		beq	.L60
 467:../drivers/fsl_flexio_i2s.c ****     {
 468:../drivers/fsl_flexio_i2s.c ****         return kStatus_FLEXIO_I2S_QueueFull;
 1463              		.loc 1 468 0
 1464 0012 9020     		movs	r0, #144
 1465              	.LVL157:
 1466 0014 0001     		lsls	r0, r0, #4
 1467              	.LVL158:
 1468              	.L55:
 469:../drivers/fsl_flexio_i2s.c ****     }
 470:../drivers/fsl_flexio_i2s.c ****     if ((xfer->dataSize == 0) || (xfer->data == NULL))
 471:../drivers/fsl_flexio_i2s.c ****     {
 472:../drivers/fsl_flexio_i2s.c ****         return kStatus_InvalidArgument;
 473:../drivers/fsl_flexio_i2s.c ****     }
 474:../drivers/fsl_flexio_i2s.c **** 
 475:../drivers/fsl_flexio_i2s.c ****     /* Add into queue */
 476:../drivers/fsl_flexio_i2s.c ****     handle->queue[handle->queueUser].data = xfer->data;
 477:../drivers/fsl_flexio_i2s.c ****     handle->queue[handle->queueUser].dataSize = xfer->dataSize;
 478:../drivers/fsl_flexio_i2s.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 479:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = (handle->queueUser + 1) % FLEXIO_I2S_XFER_QUEUE_SIZE;
 480:../drivers/fsl_flexio_i2s.c **** 
 481:../drivers/fsl_flexio_i2s.c ****     /* Set the state to busy */
 482:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Busy;
 483:../drivers/fsl_flexio_i2s.c **** 
 484:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_EnableInterrupts(base, kFLEXIO_I2S_TxDataRegEmptyInterruptEnable);
 485:../drivers/fsl_flexio_i2s.c **** 
 486:../drivers/fsl_flexio_i2s.c ****     /* Enable Tx transfer */
 487:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_Enable(base, true);
 488:../drivers/fsl_flexio_i2s.c **** 
 489:../drivers/fsl_flexio_i2s.c ****     return kStatus_Success;
 490:../drivers/fsl_flexio_i2s.c **** }
 1469              		.loc 1 490 0
 1470              		@ sp needed
 1471              	.LVL159:
 1472 0016 70BD     		pop	{r4, r5, r6, pc}
 1473              	.LVL160:
 1474              	.L60:
 470:../drivers/fsl_flexio_i2s.c ****     {
 1475              		.loc 1 470 0
 1476 0018 5368     		ldr	r3, [r2, #4]
 1477 001a 002B     		cmp	r3, #0
 1478 001c 24D0     		beq	.L58
 470:../drivers/fsl_flexio_i2s.c ****     {
 1479              		.loc 1 470 0 is_stmt 0 discriminator 1
 1480 001e 1568     		ldr	r5, [r2]
 1481 0020 002D     		cmp	r5, #0
 1482 0022 23D0     		beq	.L59
 476:../drivers/fsl_flexio_i2s.c ****     handle->queue[handle->queueUser].dataSize = xfer->dataSize;
 1483              		.loc 1 476 0 is_stmt 1
 1484 0024 4020     		movs	r0, #64
 1485              	.LVL161:
 1486 0026 0B5C     		ldrb	r3, [r1, r0]
 1487 0028 0233     		adds	r3, r3, #2
 1488 002a DB00     		lsls	r3, r3, #3
 1489 002c 5D50     		str	r5, [r3, r1]
 477:../drivers/fsl_flexio_i2s.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 1490              		.loc 1 477 0
 1491 002e 0B5C     		ldrb	r3, [r1, r0]
 1492 0030 0233     		adds	r3, r3, #2
 1493 0032 DB00     		lsls	r3, r3, #3
 1494 0034 CB18     		adds	r3, r1, r3
 1495 0036 5568     		ldr	r5, [r2, #4]
 1496 0038 5D60     		str	r5, [r3, #4]
 478:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = (handle->queueUser + 1) % FLEXIO_I2S_XFER_QUEUE_SIZE;
 1497              		.loc 1 478 0
 1498 003a 0B5C     		ldrb	r3, [r1, r0]
 1499 003c 5268     		ldr	r2, [r2, #4]
 1500              	.LVL162:
 1501 003e 0C33     		adds	r3, r3, #12
 1502 0040 9B00     		lsls	r3, r3, #2
 1503 0042 5A50     		str	r2, [r3, r1]
 479:../drivers/fsl_flexio_i2s.c **** 
 1504              		.loc 1 479 0
 1505 0044 0A5C     		ldrb	r2, [r1, r0]
 1506 0046 0132     		adds	r2, r2, #1
 1507 0048 0323     		movs	r3, #3
 1508 004a 1340     		ands	r3, r2
 1509 004c 0B54     		strb	r3, [r1, r0]
 482:../drivers/fsl_flexio_i2s.c **** 
 1510              		.loc 1 482 0
 1511 004e 0023     		movs	r3, #0
 1512 0050 0B60     		str	r3, [r1]
 484:../drivers/fsl_flexio_i2s.c **** 
 1513              		.loc 1 484 0
 1514 0052 0121     		movs	r1, #1
 1515              	.LVL163:
 1516 0054 2000     		movs	r0, r4
 1517 0056 FFF7FEFF 		bl	FLEXIO_I2S_EnableInterrupts
 1518              	.LVL164:
 1519              	.LBB58:
 1520              	.LBB59:
 1521              		.file 5 "../drivers/fsl_flexio_i2s.h"
   1:../drivers/fsl_flexio_i2s.h **** /*
   2:../drivers/fsl_flexio_i2s.h ****  * The Clear BSD License
   3:../drivers/fsl_flexio_i2s.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_flexio_i2s.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_flexio_i2s.h ****  * All rights reserved.
   6:../drivers/fsl_flexio_i2s.h ****  *
   7:../drivers/fsl_flexio_i2s.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_flexio_i2s.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_flexio_i2s.h ****  * that the following conditions are met:
  10:../drivers/fsl_flexio_i2s.h ****  *
  11:../drivers/fsl_flexio_i2s.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_flexio_i2s.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_flexio_i2s.h ****  *
  14:../drivers/fsl_flexio_i2s.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_flexio_i2s.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_flexio_i2s.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_flexio_i2s.h ****  *
  18:../drivers/fsl_flexio_i2s.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_flexio_i2s.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_flexio_i2s.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_flexio_i2s.h ****  *
  22:../drivers/fsl_flexio_i2s.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_flexio_i2s.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_flexio_i2s.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_flexio_i2s.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_flexio_i2s.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_flexio_i2s.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_flexio_i2s.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_flexio_i2s.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_flexio_i2s.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_flexio_i2s.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_flexio_i2s.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_flexio_i2s.h ****  */
  34:../drivers/fsl_flexio_i2s.h **** #ifndef _FSL_FLEXIO_I2S_H_
  35:../drivers/fsl_flexio_i2s.h **** #define _FSL_FLEXIO_I2S_H_
  36:../drivers/fsl_flexio_i2s.h **** 
  37:../drivers/fsl_flexio_i2s.h **** #include "fsl_common.h"
  38:../drivers/fsl_flexio_i2s.h **** #include "fsl_flexio.h"
  39:../drivers/fsl_flexio_i2s.h **** 
  40:../drivers/fsl_flexio_i2s.h **** /*!
  41:../drivers/fsl_flexio_i2s.h ****  * @addtogroup flexio_i2s
  42:../drivers/fsl_flexio_i2s.h ****  * @{
  43:../drivers/fsl_flexio_i2s.h ****  */
  44:../drivers/fsl_flexio_i2s.h **** 
  45:../drivers/fsl_flexio_i2s.h **** /*******************************************************************************
  46:../drivers/fsl_flexio_i2s.h ****  * Definitions
  47:../drivers/fsl_flexio_i2s.h ****  ******************************************************************************/
  48:../drivers/fsl_flexio_i2s.h **** 
  49:../drivers/fsl_flexio_i2s.h **** /*! @name Driver version */
  50:../drivers/fsl_flexio_i2s.h **** /*@{*/
  51:../drivers/fsl_flexio_i2s.h **** /*! @brief FlexIO I2S driver version 2.1.3. */
  52:../drivers/fsl_flexio_i2s.h **** #define FSL_FLEXIO_I2S_DRIVER_VERSION (MAKE_VERSION(2, 1, 3))
  53:../drivers/fsl_flexio_i2s.h **** /*@}*/
  54:../drivers/fsl_flexio_i2s.h **** 
  55:../drivers/fsl_flexio_i2s.h **** /*! @brief FlexIO I2S transfer status */
  56:../drivers/fsl_flexio_i2s.h **** enum _flexio_i2s_status
  57:../drivers/fsl_flexio_i2s.h **** {
  58:../drivers/fsl_flexio_i2s.h ****     kStatus_FLEXIO_I2S_Idle = MAKE_STATUS(kStatusGroup_FLEXIO_I2S, 0),      /*!< FlexIO I2S is in i
  59:../drivers/fsl_flexio_i2s.h ****     kStatus_FLEXIO_I2S_TxBusy = MAKE_STATUS(kStatusGroup_FLEXIO_I2S, 1),    /*!< FlexIO I2S Tx is b
  60:../drivers/fsl_flexio_i2s.h ****     kStatus_FLEXIO_I2S_RxBusy = MAKE_STATUS(kStatusGroup_FLEXIO_I2S, 2),    /*!< FlexIO I2S Tx is b
  61:../drivers/fsl_flexio_i2s.h ****     kStatus_FLEXIO_I2S_Error = MAKE_STATUS(kStatusGroup_FLEXIO_I2S, 3),     /*!< FlexIO I2S error o
  62:../drivers/fsl_flexio_i2s.h ****     kStatus_FLEXIO_I2S_QueueFull = MAKE_STATUS(kStatusGroup_FLEXIO_I2S, 4), /*!< FlexIO I2S transfe
  63:../drivers/fsl_flexio_i2s.h **** };
  64:../drivers/fsl_flexio_i2s.h **** 
  65:../drivers/fsl_flexio_i2s.h **** /*! @brief Define FlexIO I2S access structure typedef */
  66:../drivers/fsl_flexio_i2s.h **** typedef struct _flexio_i2s_type
  67:../drivers/fsl_flexio_i2s.h **** {
  68:../drivers/fsl_flexio_i2s.h ****     FLEXIO_Type *flexioBase; /*!< FlexIO base pointer */
  69:../drivers/fsl_flexio_i2s.h ****     uint8_t txPinIndex;      /*!< Tx data pin index in FlexIO pins */
  70:../drivers/fsl_flexio_i2s.h ****     uint8_t rxPinIndex;      /*!< Rx data pin index */
  71:../drivers/fsl_flexio_i2s.h ****     uint8_t bclkPinIndex;    /*!< Bit clock pin index */
  72:../drivers/fsl_flexio_i2s.h ****     uint8_t fsPinIndex;      /*!< Frame sync pin index */
  73:../drivers/fsl_flexio_i2s.h ****     uint8_t txShifterIndex;  /*!< Tx data shifter index */
  74:../drivers/fsl_flexio_i2s.h ****     uint8_t rxShifterIndex;  /*!< Rx data shifter index */
  75:../drivers/fsl_flexio_i2s.h ****     uint8_t bclkTimerIndex;  /*!< Bit clock timer index */
  76:../drivers/fsl_flexio_i2s.h ****     uint8_t fsTimerIndex;    /*!< Frame sync timer index */
  77:../drivers/fsl_flexio_i2s.h **** } FLEXIO_I2S_Type;
  78:../drivers/fsl_flexio_i2s.h **** 
  79:../drivers/fsl_flexio_i2s.h **** /*! @brief Master or slave mode */
  80:../drivers/fsl_flexio_i2s.h **** typedef enum _flexio_i2s_master_slave
  81:../drivers/fsl_flexio_i2s.h **** {
  82:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_Master = 0x0U, /*!< Master mode */
  83:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_Slave = 0x1U   /*!< Slave mode */
  84:../drivers/fsl_flexio_i2s.h **** } flexio_i2s_master_slave_t;
  85:../drivers/fsl_flexio_i2s.h **** 
  86:../drivers/fsl_flexio_i2s.h **** /*! @brief Define FlexIO FlexIO I2S interrupt mask. */
  87:../drivers/fsl_flexio_i2s.h **** enum _flexio_i2s_interrupt_enable
  88:../drivers/fsl_flexio_i2s.h **** {
  89:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_TxDataRegEmptyInterruptEnable = 0x1U, /*!< Transmit buffer empty interrupt enable. 
  90:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_RxDataRegFullInterruptEnable = 0x2U,  /*!< Receive buffer full interrupt enable. */
  91:../drivers/fsl_flexio_i2s.h **** };
  92:../drivers/fsl_flexio_i2s.h **** 
  93:../drivers/fsl_flexio_i2s.h **** /*! @brief Define FlexIO FlexIO I2S status mask. */
  94:../drivers/fsl_flexio_i2s.h **** enum _flexio_i2s_status_flags
  95:../drivers/fsl_flexio_i2s.h **** {
  96:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_TxDataRegEmptyFlag = 0x1U, /*!< Transmit buffer empty flag. */
  97:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_RxDataRegFullFlag = 0x2U,  /*!< Receive buffer full flag. */
  98:../drivers/fsl_flexio_i2s.h **** };
  99:../drivers/fsl_flexio_i2s.h **** 
 100:../drivers/fsl_flexio_i2s.h **** /*! @brief FlexIO I2S configure structure */
 101:../drivers/fsl_flexio_i2s.h **** typedef struct _flexio_i2s_config
 102:../drivers/fsl_flexio_i2s.h **** {
 103:../drivers/fsl_flexio_i2s.h ****     bool enableI2S;                                  /*!< Enable FlexIO I2S */
 104:../drivers/fsl_flexio_i2s.h ****     flexio_i2s_master_slave_t masterSlave;           /*!< Master or slave */
 105:../drivers/fsl_flexio_i2s.h ****     flexio_pin_polarity_t txPinPolarity;             /*!< Tx data pin polarity, active high or low 
 106:../drivers/fsl_flexio_i2s.h ****     flexio_pin_polarity_t rxPinPolarity;             /*!< Rx data pin polarity */
 107:../drivers/fsl_flexio_i2s.h ****     flexio_pin_polarity_t bclkPinPolarity;           /*!< Bit clock pin polarity */
 108:../drivers/fsl_flexio_i2s.h ****     flexio_pin_polarity_t fsPinPolarity;             /*!< Frame sync pin polarity */
 109:../drivers/fsl_flexio_i2s.h ****     flexio_shifter_timer_polarity_t txTimerPolarity; /*!< Tx data valid on bclk rising or falling e
 110:../drivers/fsl_flexio_i2s.h ****     flexio_shifter_timer_polarity_t rxTimerPolarity; /*!< Rx data valid on bclk rising or falling e
 111:../drivers/fsl_flexio_i2s.h **** } flexio_i2s_config_t;
 112:../drivers/fsl_flexio_i2s.h **** 
 113:../drivers/fsl_flexio_i2s.h **** /*! @brief FlexIO I2S audio format, FlexIO I2S only support the same format in Tx and Rx */
 114:../drivers/fsl_flexio_i2s.h **** typedef struct _flexio_i2s_format
 115:../drivers/fsl_flexio_i2s.h **** {
 116:../drivers/fsl_flexio_i2s.h ****     uint8_t bitWidth;       /*!< Bit width of audio data, always 8/16/24/32 bits */
 117:../drivers/fsl_flexio_i2s.h ****     uint32_t sampleRate_Hz; /*!< Sample rate of the audio data */
 118:../drivers/fsl_flexio_i2s.h **** } flexio_i2s_format_t;
 119:../drivers/fsl_flexio_i2s.h **** 
 120:../drivers/fsl_flexio_i2s.h **** /*!@brief FlexIO I2S transfer queue size, user can refine it according to use case. */
 121:../drivers/fsl_flexio_i2s.h **** #define FLEXIO_I2S_XFER_QUEUE_SIZE (4)
 122:../drivers/fsl_flexio_i2s.h **** 
 123:../drivers/fsl_flexio_i2s.h **** /*! @brief Audio sample rate */
 124:../drivers/fsl_flexio_i2s.h **** typedef enum _flexio_i2s_sample_rate
 125:../drivers/fsl_flexio_i2s.h **** {
 126:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate8KHz = 8000U,     /*!< Sample rate 8000Hz */
 127:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate11025Hz = 11025U, /*!< Sample rate 11025Hz */
 128:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate12KHz = 12000U,   /*!< Sample rate 12000Hz */
 129:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate16KHz = 16000U,   /*!< Sample rate 16000Hz */
 130:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate22050Hz = 22050U, /*!< Sample rate 22050Hz */
 131:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate24KHz = 24000U,   /*!< Sample rate 24000Hz */
 132:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate32KHz = 32000U,   /*!< Sample rate 32000Hz */
 133:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate44100Hz = 44100U, /*!< Sample rate 44100Hz */
 134:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate48KHz = 48000U,   /*!< Sample rate 48000Hz */
 135:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_SampleRate96KHz = 96000U    /*!< Sample rate 96000Hz */
 136:../drivers/fsl_flexio_i2s.h **** } flexio_i2s_sample_rate_t;
 137:../drivers/fsl_flexio_i2s.h **** 
 138:../drivers/fsl_flexio_i2s.h **** /*! @brief Audio word width */
 139:../drivers/fsl_flexio_i2s.h **** typedef enum _flexio_i2s_word_width
 140:../drivers/fsl_flexio_i2s.h **** {
 141:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_WordWidth8bits = 8U,   /*!< Audio data width 8 bits */
 142:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_WordWidth16bits = 16U, /*!< Audio data width 16 bits */
 143:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_WordWidth24bits = 24U, /*!< Audio data width 24 bits */
 144:../drivers/fsl_flexio_i2s.h ****     kFLEXIO_I2S_WordWidth32bits = 32U  /*!< Audio data width 32 bits */
 145:../drivers/fsl_flexio_i2s.h **** } flexio_i2s_word_width_t;
 146:../drivers/fsl_flexio_i2s.h **** 
 147:../drivers/fsl_flexio_i2s.h **** /*! @brief Define FlexIO I2S transfer structure. */
 148:../drivers/fsl_flexio_i2s.h **** typedef struct _flexio_i2s_transfer
 149:../drivers/fsl_flexio_i2s.h **** {
 150:../drivers/fsl_flexio_i2s.h ****     uint8_t *data;   /*!< Data buffer start pointer */
 151:../drivers/fsl_flexio_i2s.h ****     size_t dataSize; /*!< Bytes to be transferred. */
 152:../drivers/fsl_flexio_i2s.h **** } flexio_i2s_transfer_t;
 153:../drivers/fsl_flexio_i2s.h **** 
 154:../drivers/fsl_flexio_i2s.h **** typedef struct _flexio_i2s_handle flexio_i2s_handle_t;
 155:../drivers/fsl_flexio_i2s.h **** 
 156:../drivers/fsl_flexio_i2s.h **** /*! @brief FlexIO I2S xfer callback prototype */
 157:../drivers/fsl_flexio_i2s.h **** typedef void (*flexio_i2s_callback_t)(FLEXIO_I2S_Type *base,
 158:../drivers/fsl_flexio_i2s.h ****                                       flexio_i2s_handle_t *handle,
 159:../drivers/fsl_flexio_i2s.h ****                                       status_t status,
 160:../drivers/fsl_flexio_i2s.h ****                                       void *userData);
 161:../drivers/fsl_flexio_i2s.h **** 
 162:../drivers/fsl_flexio_i2s.h **** /*! @brief Define FlexIO I2S handle structure. */
 163:../drivers/fsl_flexio_i2s.h **** struct _flexio_i2s_handle
 164:../drivers/fsl_flexio_i2s.h **** {
 165:../drivers/fsl_flexio_i2s.h ****     uint32_t state;                                          /*!< Internal state */
 166:../drivers/fsl_flexio_i2s.h ****     flexio_i2s_callback_t callback;                          /*!< Callback function called at trans
 167:../drivers/fsl_flexio_i2s.h ****     void *userData;                                          /*!< Callback parameter passed to call
 168:../drivers/fsl_flexio_i2s.h ****     uint8_t bitWidth;                                        /*!< Bit width for transfer, 8/16/24/3
 169:../drivers/fsl_flexio_i2s.h ****     flexio_i2s_transfer_t queue[FLEXIO_I2S_XFER_QUEUE_SIZE]; /*!< Transfer queue storing queued tra
 170:../drivers/fsl_flexio_i2s.h ****     size_t transferSize[FLEXIO_I2S_XFER_QUEUE_SIZE];         /*!< Data bytes need to transfer */
 171:../drivers/fsl_flexio_i2s.h ****     volatile uint8_t queueUser;                              /*!< Index for user to queue transfer 
 172:../drivers/fsl_flexio_i2s.h ****     volatile uint8_t queueDriver;                            /*!< Index for driver to get the trans
 173:../drivers/fsl_flexio_i2s.h **** };
 174:../drivers/fsl_flexio_i2s.h **** 
 175:../drivers/fsl_flexio_i2s.h **** /*******************************************************************************
 176:../drivers/fsl_flexio_i2s.h ****  * API
 177:../drivers/fsl_flexio_i2s.h ****  ******************************************************************************/
 178:../drivers/fsl_flexio_i2s.h **** 
 179:../drivers/fsl_flexio_i2s.h **** #if defined(__cplusplus)
 180:../drivers/fsl_flexio_i2s.h **** extern "C" {
 181:../drivers/fsl_flexio_i2s.h **** #endif /*_cplusplus*/
 182:../drivers/fsl_flexio_i2s.h **** 
 183:../drivers/fsl_flexio_i2s.h **** /*!
 184:../drivers/fsl_flexio_i2s.h ****  * @name Initialization and deinitialization
 185:../drivers/fsl_flexio_i2s.h ****  * @{
 186:../drivers/fsl_flexio_i2s.h ****  */
 187:../drivers/fsl_flexio_i2s.h **** 
 188:../drivers/fsl_flexio_i2s.h **** /*!
 189:../drivers/fsl_flexio_i2s.h ****  * @brief Initializes the FlexIO I2S.
 190:../drivers/fsl_flexio_i2s.h ****  *
 191:../drivers/fsl_flexio_i2s.h ****  * This API configures FlexIO pins and shifter to I2S and configures the FlexIO I2S with a configur
 192:../drivers/fsl_flexio_i2s.h ****  * The configuration structure can be filled by the user, or be set with default values by
 193:../drivers/fsl_flexio_i2s.h ****  * FLEXIO_I2S_GetDefaultConfig().
 194:../drivers/fsl_flexio_i2s.h ****  *
 195:../drivers/fsl_flexio_i2s.h ****  * @note  This API should be called at the beginning of the application to use
 196:../drivers/fsl_flexio_i2s.h ****  * the FlexIO I2S driver. Otherwise, any access to the FlexIO I2S module can cause hard fault
 197:../drivers/fsl_flexio_i2s.h ****  * because the clock is not enabled.
 198:../drivers/fsl_flexio_i2s.h ****  *
 199:../drivers/fsl_flexio_i2s.h ****  * @param base FlexIO I2S base pointer
 200:../drivers/fsl_flexio_i2s.h ****  * @param config FlexIO I2S configure structure.
 201:../drivers/fsl_flexio_i2s.h **** */
 202:../drivers/fsl_flexio_i2s.h **** void FLEXIO_I2S_Init(FLEXIO_I2S_Type *base, const flexio_i2s_config_t *config);
 203:../drivers/fsl_flexio_i2s.h **** 
 204:../drivers/fsl_flexio_i2s.h **** /*!
 205:../drivers/fsl_flexio_i2s.h ****  * @brief  Sets the FlexIO I2S configuration structure to default values.
 206:../drivers/fsl_flexio_i2s.h ****  *
 207:../drivers/fsl_flexio_i2s.h ****  * The purpose of this API is to get the configuration structure initialized for use in FLEXIO_I2S_
 208:../drivers/fsl_flexio_i2s.h ****  * Users may use the initialized structure unchanged in FLEXIO_I2S_Init() or modify
 209:../drivers/fsl_flexio_i2s.h ****  * some fields of the structure before calling FLEXIO_I2S_Init().
 210:../drivers/fsl_flexio_i2s.h ****  *
 211:../drivers/fsl_flexio_i2s.h ****  * @param config pointer to master configuration structure
 212:../drivers/fsl_flexio_i2s.h ****  */
 213:../drivers/fsl_flexio_i2s.h **** void FLEXIO_I2S_GetDefaultConfig(flexio_i2s_config_t *config);
 214:../drivers/fsl_flexio_i2s.h **** 
 215:../drivers/fsl_flexio_i2s.h **** /*!
 216:../drivers/fsl_flexio_i2s.h ****  * @brief De-initializes the FlexIO I2S.
 217:../drivers/fsl_flexio_i2s.h ****  *
 218:../drivers/fsl_flexio_i2s.h ****  * Calling this API resets the FlexIO I2S shifter and timer config. After calling this API,
 219:../drivers/fsl_flexio_i2s.h ****  * call the FLEXO_I2S_Init to use the FlexIO I2S module.
 220:../drivers/fsl_flexio_i2s.h ****  *
 221:../drivers/fsl_flexio_i2s.h ****  * @param base FlexIO I2S base pointer
 222:../drivers/fsl_flexio_i2s.h **** */
 223:../drivers/fsl_flexio_i2s.h **** void FLEXIO_I2S_Deinit(FLEXIO_I2S_Type *base);
 224:../drivers/fsl_flexio_i2s.h **** 
 225:../drivers/fsl_flexio_i2s.h **** /*!
 226:../drivers/fsl_flexio_i2s.h ****  * @brief Enables/disables the FlexIO I2S module operation.
 227:../drivers/fsl_flexio_i2s.h ****  *
 228:../drivers/fsl_flexio_i2s.h ****  * @param base Pointer to FLEXIO_I2S_Type
 229:../drivers/fsl_flexio_i2s.h ****  * @param enable True to enable, false dose not have any effect.
 230:../drivers/fsl_flexio_i2s.h **** */
 231:../drivers/fsl_flexio_i2s.h **** static inline void FLEXIO_I2S_Enable(FLEXIO_I2S_Type *base, bool enable)
 232:../drivers/fsl_flexio_i2s.h **** {
 233:../drivers/fsl_flexio_i2s.h ****     if (enable)
 234:../drivers/fsl_flexio_i2s.h ****     {
 235:../drivers/fsl_flexio_i2s.h ****         base->flexioBase->CTRL |= FLEXIO_CTRL_FLEXEN_MASK;
 1522              		.loc 5 235 0
 1523 005a 2268     		ldr	r2, [r4]
 1524 005c 9368     		ldr	r3, [r2, #8]
 1525 005e 0121     		movs	r1, #1
 1526 0060 0B43     		orrs	r3, r1
 1527 0062 9360     		str	r3, [r2, #8]
 1528              	.LVL165:
 1529              	.LBE59:
 1530              	.LBE58:
 489:../drivers/fsl_flexio_i2s.c **** }
 1531              		.loc 1 489 0
 1532 0064 0020     		movs	r0, #0
 1533 0066 D6E7     		b	.L55
 1534              	.LVL166:
 1535              	.L58:
 472:../drivers/fsl_flexio_i2s.c ****     }
 1536              		.loc 1 472 0
 1537 0068 0420     		movs	r0, #4
 1538              	.LVL167:
 1539 006a D4E7     		b	.L55
 1540              	.LVL168:
 1541              	.L59:
 1542 006c 0420     		movs	r0, #4
 1543              	.LVL169:
 1544 006e D2E7     		b	.L55
 1545              		.cfi_endproc
 1546              	.LFE90:
 1548              		.section	.text.FLEXIO_I2S_TransferReceiveNonBlocking,"ax",%progbits
 1549              		.align	1
 1550              		.global	FLEXIO_I2S_TransferReceiveNonBlocking
 1551              		.syntax unified
 1552              		.code	16
 1553              		.thumb_func
 1554              		.fpu softvfp
 1556              	FLEXIO_I2S_TransferReceiveNonBlocking:
 1557              	.LFB91:
 491:../drivers/fsl_flexio_i2s.c **** 
 492:../drivers/fsl_flexio_i2s.c **** status_t FLEXIO_I2S_TransferReceiveNonBlocking(FLEXIO_I2S_Type *base,
 493:../drivers/fsl_flexio_i2s.c ****                                                flexio_i2s_handle_t *handle,
 494:../drivers/fsl_flexio_i2s.c ****                                                flexio_i2s_transfer_t *xfer)
 495:../drivers/fsl_flexio_i2s.c **** {
 1558              		.loc 1 495 0
 1559              		.cfi_startproc
 1560              		@ args = 0, pretend = 0, frame = 0
 1561              		@ frame_needed = 0, uses_anonymous_args = 0
 1562              	.LVL170:
 1563 0000 70B5     		push	{r4, r5, r6, lr}
 1564              		.cfi_def_cfa_offset 16
 1565              		.cfi_offset 4, -16
 1566              		.cfi_offset 5, -12
 1567              		.cfi_offset 6, -8
 1568              		.cfi_offset 14, -4
 1569 0002 0400     		movs	r4, r0
 496:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 497:../drivers/fsl_flexio_i2s.c **** 
 498:../drivers/fsl_flexio_i2s.c ****     /* Check if the queue is full */
 499:../drivers/fsl_flexio_i2s.c ****     if (handle->queue[handle->queueUser].data)
 1570              		.loc 1 499 0
 1571 0004 4023     		movs	r3, #64
 1572 0006 CB5C     		ldrb	r3, [r1, r3]
 1573 0008 0233     		adds	r3, r3, #2
 1574 000a DB00     		lsls	r3, r3, #3
 1575 000c 5B58     		ldr	r3, [r3, r1]
 1576 000e 002B     		cmp	r3, #0
 1577 0010 02D0     		beq	.L66
 500:../drivers/fsl_flexio_i2s.c ****     {
 501:../drivers/fsl_flexio_i2s.c ****         return kStatus_FLEXIO_I2S_QueueFull;
 1578              		.loc 1 501 0
 1579 0012 9020     		movs	r0, #144
 1580              	.LVL171:
 1581 0014 0001     		lsls	r0, r0, #4
 1582              	.LVL172:
 1583              	.L61:
 502:../drivers/fsl_flexio_i2s.c ****     }
 503:../drivers/fsl_flexio_i2s.c **** 
 504:../drivers/fsl_flexio_i2s.c ****     if ((xfer->dataSize == 0) || (xfer->data == NULL))
 505:../drivers/fsl_flexio_i2s.c ****     {
 506:../drivers/fsl_flexio_i2s.c ****         return kStatus_InvalidArgument;
 507:../drivers/fsl_flexio_i2s.c ****     }
 508:../drivers/fsl_flexio_i2s.c **** 
 509:../drivers/fsl_flexio_i2s.c ****     /* Add into queue */
 510:../drivers/fsl_flexio_i2s.c ****     handle->queue[handle->queueUser].data = xfer->data;
 511:../drivers/fsl_flexio_i2s.c ****     handle->queue[handle->queueUser].dataSize = xfer->dataSize;
 512:../drivers/fsl_flexio_i2s.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 513:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = (handle->queueUser + 1) % FLEXIO_I2S_XFER_QUEUE_SIZE;
 514:../drivers/fsl_flexio_i2s.c **** 
 515:../drivers/fsl_flexio_i2s.c ****     /* Set state to busy */
 516:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Busy;
 517:../drivers/fsl_flexio_i2s.c **** 
 518:../drivers/fsl_flexio_i2s.c ****     /* Enable interrupt */
 519:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_EnableInterrupts(base, kFLEXIO_I2S_RxDataRegFullInterruptEnable);
 520:../drivers/fsl_flexio_i2s.c **** 
 521:../drivers/fsl_flexio_i2s.c ****     /* Enable Rx transfer */
 522:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_Enable(base, true);
 523:../drivers/fsl_flexio_i2s.c **** 
 524:../drivers/fsl_flexio_i2s.c ****     return kStatus_Success;
 525:../drivers/fsl_flexio_i2s.c **** }
 1584              		.loc 1 525 0
 1585              		@ sp needed
 1586              	.LVL173:
 1587 0016 70BD     		pop	{r4, r5, r6, pc}
 1588              	.LVL174:
 1589              	.L66:
 504:../drivers/fsl_flexio_i2s.c ****     {
 1590              		.loc 1 504 0
 1591 0018 5368     		ldr	r3, [r2, #4]
 1592 001a 002B     		cmp	r3, #0
 1593 001c 24D0     		beq	.L64
 504:../drivers/fsl_flexio_i2s.c ****     {
 1594              		.loc 1 504 0 is_stmt 0 discriminator 1
 1595 001e 1568     		ldr	r5, [r2]
 1596 0020 002D     		cmp	r5, #0
 1597 0022 23D0     		beq	.L65
 510:../drivers/fsl_flexio_i2s.c ****     handle->queue[handle->queueUser].dataSize = xfer->dataSize;
 1598              		.loc 1 510 0 is_stmt 1
 1599 0024 4020     		movs	r0, #64
 1600              	.LVL175:
 1601 0026 0B5C     		ldrb	r3, [r1, r0]
 1602 0028 0233     		adds	r3, r3, #2
 1603 002a DB00     		lsls	r3, r3, #3
 1604 002c 5D50     		str	r5, [r3, r1]
 511:../drivers/fsl_flexio_i2s.c ****     handle->transferSize[handle->queueUser] = xfer->dataSize;
 1605              		.loc 1 511 0
 1606 002e 0B5C     		ldrb	r3, [r1, r0]
 1607 0030 0233     		adds	r3, r3, #2
 1608 0032 DB00     		lsls	r3, r3, #3
 1609 0034 CB18     		adds	r3, r1, r3
 1610 0036 5568     		ldr	r5, [r2, #4]
 1611 0038 5D60     		str	r5, [r3, #4]
 512:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = (handle->queueUser + 1) % FLEXIO_I2S_XFER_QUEUE_SIZE;
 1612              		.loc 1 512 0
 1613 003a 0B5C     		ldrb	r3, [r1, r0]
 1614 003c 5268     		ldr	r2, [r2, #4]
 1615              	.LVL176:
 1616 003e 0C33     		adds	r3, r3, #12
 1617 0040 9B00     		lsls	r3, r3, #2
 1618 0042 5A50     		str	r2, [r3, r1]
 513:../drivers/fsl_flexio_i2s.c **** 
 1619              		.loc 1 513 0
 1620 0044 0A5C     		ldrb	r2, [r1, r0]
 1621 0046 0132     		adds	r2, r2, #1
 1622 0048 0323     		movs	r3, #3
 1623 004a 1340     		ands	r3, r2
 1624 004c 0B54     		strb	r3, [r1, r0]
 516:../drivers/fsl_flexio_i2s.c **** 
 1625              		.loc 1 516 0
 1626 004e 0023     		movs	r3, #0
 1627 0050 0B60     		str	r3, [r1]
 519:../drivers/fsl_flexio_i2s.c **** 
 1628              		.loc 1 519 0
 1629 0052 0221     		movs	r1, #2
 1630              	.LVL177:
 1631 0054 2000     		movs	r0, r4
 1632 0056 FFF7FEFF 		bl	FLEXIO_I2S_EnableInterrupts
 1633              	.LVL178:
 1634              	.LBB60:
 1635              	.LBB61:
 1636              		.loc 5 235 0
 1637 005a 2268     		ldr	r2, [r4]
 1638 005c 9368     		ldr	r3, [r2, #8]
 1639 005e 0121     		movs	r1, #1
 1640 0060 0B43     		orrs	r3, r1
 1641 0062 9360     		str	r3, [r2, #8]
 1642              	.LVL179:
 1643              	.LBE61:
 1644              	.LBE60:
 524:../drivers/fsl_flexio_i2s.c **** }
 1645              		.loc 1 524 0
 1646 0064 0020     		movs	r0, #0
 1647 0066 D6E7     		b	.L61
 1648              	.LVL180:
 1649              	.L64:
 506:../drivers/fsl_flexio_i2s.c ****     }
 1650              		.loc 1 506 0
 1651 0068 0420     		movs	r0, #4
 1652              	.LVL181:
 1653 006a D4E7     		b	.L61
 1654              	.LVL182:
 1655              	.L65:
 1656 006c 0420     		movs	r0, #4
 1657              	.LVL183:
 1658 006e D2E7     		b	.L61
 1659              		.cfi_endproc
 1660              	.LFE91:
 1662              		.section	.text.FLEXIO_I2S_TransferAbortSend,"ax",%progbits
 1663              		.align	1
 1664              		.global	FLEXIO_I2S_TransferAbortSend
 1665              		.syntax unified
 1666              		.code	16
 1667              		.thumb_func
 1668              		.fpu softvfp
 1670              	FLEXIO_I2S_TransferAbortSend:
 1671              	.LFB92:
 526:../drivers/fsl_flexio_i2s.c **** 
 527:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferAbortSend(FLEXIO_I2S_Type *base, flexio_i2s_handle_t *handle)
 528:../drivers/fsl_flexio_i2s.c **** {
 1672              		.loc 1 528 0
 1673              		.cfi_startproc
 1674              		@ args = 0, pretend = 0, frame = 0
 1675              		@ frame_needed = 0, uses_anonymous_args = 0
 1676              	.LVL184:
 1677 0000 10B5     		push	{r4, lr}
 1678              		.cfi_def_cfa_offset 8
 1679              		.cfi_offset 4, -8
 1680              		.cfi_offset 14, -4
 1681 0002 0C00     		movs	r4, r1
 529:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 530:../drivers/fsl_flexio_i2s.c **** 
 531:../drivers/fsl_flexio_i2s.c ****     /* Stop Tx transfer and disable interrupt */
 532:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_DisableInterrupts(base, kFLEXIO_I2S_TxDataRegEmptyInterruptEnable);
 1682              		.loc 1 532 0
 1683 0004 0121     		movs	r1, #1
 1684              	.LVL185:
 1685 0006 FFF7FEFF 		bl	FLEXIO_I2S_DisableInterrupts
 1686              	.LVL186:
 533:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Idle;
 1687              		.loc 1 533 0
 1688 000a 0123     		movs	r3, #1
 1689 000c 2360     		str	r3, [r4]
 534:../drivers/fsl_flexio_i2s.c **** 
 535:../drivers/fsl_flexio_i2s.c ****     /* Clear the queue */
 536:../drivers/fsl_flexio_i2s.c ****     memset(handle->queue, 0, sizeof(flexio_i2s_transfer_t) * FLEXIO_I2S_XFER_QUEUE_SIZE);
 1690              		.loc 1 536 0
 1691 000e 2000     		movs	r0, r4
 1692 0010 1030     		adds	r0, r0, #16
 1693 0012 2022     		movs	r2, #32
 1694 0014 0021     		movs	r1, #0
 1695 0016 FFF7FEFF 		bl	memset
 1696              	.LVL187:
 537:../drivers/fsl_flexio_i2s.c ****     handle->queueDriver = 0;
 1697              		.loc 1 537 0
 1698 001a 0023     		movs	r3, #0
 1699 001c 4122     		movs	r2, #65
 1700 001e A354     		strb	r3, [r4, r2]
 538:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = 0;
 1701              		.loc 1 538 0
 1702 0020 013A     		subs	r2, r2, #1
 1703 0022 A354     		strb	r3, [r4, r2]
 539:../drivers/fsl_flexio_i2s.c **** }
 1704              		.loc 1 539 0
 1705              		@ sp needed
 1706              	.LVL188:
 1707 0024 10BD     		pop	{r4, pc}
 1708              		.cfi_endproc
 1709              	.LFE92:
 1711              		.section	.text.FLEXIO_I2S_TransferTxHandleIRQ,"ax",%progbits
 1712              		.align	1
 1713              		.global	FLEXIO_I2S_TransferTxHandleIRQ
 1714              		.syntax unified
 1715              		.code	16
 1716              		.thumb_func
 1717              		.fpu softvfp
 1719              	FLEXIO_I2S_TransferTxHandleIRQ:
 1720              	.LFB96:
 540:../drivers/fsl_flexio_i2s.c **** 
 541:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferAbortReceive(FLEXIO_I2S_Type *base, flexio_i2s_handle_t *handle)
 542:../drivers/fsl_flexio_i2s.c **** {
 543:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 544:../drivers/fsl_flexio_i2s.c **** 
 545:../drivers/fsl_flexio_i2s.c ****     /* Stop rx transfer and disable interrupt */
 546:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_DisableInterrupts(base, kFLEXIO_I2S_RxDataRegFullInterruptEnable);
 547:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Idle;
 548:../drivers/fsl_flexio_i2s.c **** 
 549:../drivers/fsl_flexio_i2s.c ****     /* Clear the queue */
 550:../drivers/fsl_flexio_i2s.c ****     memset(handle->queue, 0, sizeof(flexio_i2s_transfer_t) * FLEXIO_I2S_XFER_QUEUE_SIZE);
 551:../drivers/fsl_flexio_i2s.c ****     handle->queueDriver = 0;
 552:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = 0;
 553:../drivers/fsl_flexio_i2s.c **** }
 554:../drivers/fsl_flexio_i2s.c **** 
 555:../drivers/fsl_flexio_i2s.c **** status_t FLEXIO_I2S_TransferGetSendCount(FLEXIO_I2S_Type *base, flexio_i2s_handle_t *handle, size_t
 556:../drivers/fsl_flexio_i2s.c **** {
 557:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 558:../drivers/fsl_flexio_i2s.c **** 
 559:../drivers/fsl_flexio_i2s.c ****     status_t status = kStatus_Success;
 560:../drivers/fsl_flexio_i2s.c **** 
 561:../drivers/fsl_flexio_i2s.c ****     if (handle->state != kFLEXIO_I2S_Busy)
 562:../drivers/fsl_flexio_i2s.c ****     {
 563:../drivers/fsl_flexio_i2s.c ****         status = kStatus_NoTransferInProgress;
 564:../drivers/fsl_flexio_i2s.c ****     }
 565:../drivers/fsl_flexio_i2s.c ****     else
 566:../drivers/fsl_flexio_i2s.c ****     {
 567:../drivers/fsl_flexio_i2s.c ****         *count = (handle->transferSize[handle->queueDriver] - handle->queue[handle->queueDriver].da
 568:../drivers/fsl_flexio_i2s.c ****     }
 569:../drivers/fsl_flexio_i2s.c **** 
 570:../drivers/fsl_flexio_i2s.c ****     return status;
 571:../drivers/fsl_flexio_i2s.c **** }
 572:../drivers/fsl_flexio_i2s.c **** 
 573:../drivers/fsl_flexio_i2s.c **** status_t FLEXIO_I2S_TransferGetReceiveCount(FLEXIO_I2S_Type *base, flexio_i2s_handle_t *handle, siz
 574:../drivers/fsl_flexio_i2s.c **** {
 575:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 576:../drivers/fsl_flexio_i2s.c **** 
 577:../drivers/fsl_flexio_i2s.c ****     status_t status = kStatus_Success;
 578:../drivers/fsl_flexio_i2s.c **** 
 579:../drivers/fsl_flexio_i2s.c ****     if (handle->state != kFLEXIO_I2S_Busy)
 580:../drivers/fsl_flexio_i2s.c ****     {
 581:../drivers/fsl_flexio_i2s.c ****         status = kStatus_NoTransferInProgress;
 582:../drivers/fsl_flexio_i2s.c ****     }
 583:../drivers/fsl_flexio_i2s.c ****     else
 584:../drivers/fsl_flexio_i2s.c ****     {
 585:../drivers/fsl_flexio_i2s.c ****         *count = (handle->transferSize[handle->queueDriver] - handle->queue[handle->queueDriver].da
 586:../drivers/fsl_flexio_i2s.c ****     }
 587:../drivers/fsl_flexio_i2s.c **** 
 588:../drivers/fsl_flexio_i2s.c ****     return status;
 589:../drivers/fsl_flexio_i2s.c **** }
 590:../drivers/fsl_flexio_i2s.c **** 
 591:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferTxHandleIRQ(void *i2sBase, void *i2sHandle)
 592:../drivers/fsl_flexio_i2s.c **** {
 1721              		.loc 1 592 0
 1722              		.cfi_startproc
 1723              		@ args = 0, pretend = 0, frame = 0
 1724              		@ frame_needed = 0, uses_anonymous_args = 0
 1725              	.LVL189:
 1726 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1727              		.cfi_def_cfa_offset 24
 1728              		.cfi_offset 3, -24
 1729              		.cfi_offset 4, -20
 1730              		.cfi_offset 5, -16
 1731              		.cfi_offset 6, -12
 1732              		.cfi_offset 7, -8
 1733              		.cfi_offset 14, -4
 1734 0002 0500     		movs	r5, r0
 1735 0004 0C00     		movs	r4, r1
 1736              	.LVL190:
 593:../drivers/fsl_flexio_i2s.c ****     assert(i2sHandle);
 594:../drivers/fsl_flexio_i2s.c **** 
 595:../drivers/fsl_flexio_i2s.c ****     flexio_i2s_handle_t *handle = (flexio_i2s_handle_t *)i2sHandle;
 596:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_Type *base = (FLEXIO_I2S_Type *)i2sBase;
 597:../drivers/fsl_flexio_i2s.c ****     uint8_t *buffer = handle->queue[handle->queueDriver].data;
 1737              		.loc 1 597 0
 1738 0006 4123     		movs	r3, #65
 1739 0008 CB5C     		ldrb	r3, [r1, r3]
 1740 000a 0233     		adds	r3, r3, #2
 1741 000c DB00     		lsls	r3, r3, #3
 1742 000e 5F58     		ldr	r7, [r3, r1]
 1743              	.LVL191:
 598:../drivers/fsl_flexio_i2s.c ****     uint8_t dataSize = handle->bitWidth / 8U;
 1744              		.loc 1 598 0
 1745 0010 0E7B     		ldrb	r6, [r1, #12]
 1746 0012 F608     		lsrs	r6, r6, #3
 1747              	.LVL192:
 599:../drivers/fsl_flexio_i2s.c **** 
 600:../drivers/fsl_flexio_i2s.c ****     /* Handle error */
 601:../drivers/fsl_flexio_i2s.c ****     if (FLEXIO_GetShifterErrorFlags(base->flexioBase) & (1U << base->txShifterIndex))
 1748              		.loc 1 601 0
 1749 0014 0168     		ldr	r1, [r0]
 1750              	.LVL193:
 1751              	.LBB62:
 1752              	.LBB63:
 581:../drivers/fsl_flexio.h **** }
 582:../drivers/fsl_flexio.h **** 
 583:../drivers/fsl_flexio.h **** /*!
 584:../drivers/fsl_flexio.h ****  * @brief Clears the shifter status flags.
 585:../drivers/fsl_flexio.h ****  *
 586:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 587:../drivers/fsl_flexio.h ****  * @param mask The shifter status mask which can be calculated by (1 << shifter index)
 588:../drivers/fsl_flexio.h ****  * @note For clearing multiple shifter status flags, for example, two shifter status flags, can cal
 589:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 590:../drivers/fsl_flexio.h **** */
 591:../drivers/fsl_flexio.h **** static inline void FLEXIO_ClearShifterStatusFlags(FLEXIO_Type *base, uint32_t mask)
 592:../drivers/fsl_flexio.h **** {
 593:../drivers/fsl_flexio.h ****     base->SHIFTSTAT = mask;
 594:../drivers/fsl_flexio.h **** }
 595:../drivers/fsl_flexio.h **** 
 596:../drivers/fsl_flexio.h **** /*!
 597:../drivers/fsl_flexio.h ****  * @brief Gets the shifter error flags.
 598:../drivers/fsl_flexio.h ****  *
 599:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 600:../drivers/fsl_flexio.h ****  * @return Shifter error flags
 601:../drivers/fsl_flexio.h **** */
 602:../drivers/fsl_flexio.h **** static inline uint32_t FLEXIO_GetShifterErrorFlags(FLEXIO_Type *base)
 603:../drivers/fsl_flexio.h **** {
 604:../drivers/fsl_flexio.h ****     return ((base->SHIFTERR) & FLEXIO_SHIFTERR_SEF_MASK);
 1753              		.loc 3 604 0
 1754 0016 4B69     		ldr	r3, [r1, #20]
 1755 0018 0F22     		movs	r2, #15
 1756 001a 1A40     		ands	r2, r3
 1757              	.LVL194:
 1758              	.LBE63:
 1759              	.LBE62:
 1760              		.loc 1 601 0
 1761 001c 007A     		ldrb	r0, [r0, #8]
 1762              	.LVL195:
 1763 001e 0123     		movs	r3, #1
 1764 0020 8340     		lsls	r3, r3, r0
 1765 0022 1A42     		tst	r2, r3
 1766 0024 00D0     		beq	.L69
 1767              	.LVL196:
 1768              	.LBB64:
 1769              	.LBB65:
 605:../drivers/fsl_flexio.h **** }
 606:../drivers/fsl_flexio.h **** 
 607:../drivers/fsl_flexio.h **** /*!
 608:../drivers/fsl_flexio.h ****  * @brief Clears the shifter error flags.
 609:../drivers/fsl_flexio.h ****  *
 610:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 611:../drivers/fsl_flexio.h ****  * @param mask The shifter error mask which can be calculated by (1 << shifter index)
 612:../drivers/fsl_flexio.h ****  * @note For clearing multiple shifter error flags, for example, two shifter error flags, can calcu
 613:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 614:../drivers/fsl_flexio.h **** */
 615:../drivers/fsl_flexio.h **** static inline void FLEXIO_ClearShifterErrorFlags(FLEXIO_Type *base, uint32_t mask)
 616:../drivers/fsl_flexio.h **** {
 617:../drivers/fsl_flexio.h ****     base->SHIFTERR = mask;
 1770              		.loc 3 617 0
 1771 0026 4B61     		str	r3, [r1, #20]
 1772              	.LVL197:
 1773              	.L69:
 1774              	.LBE65:
 1775              	.LBE64:
 602:../drivers/fsl_flexio_i2s.c ****     {
 603:../drivers/fsl_flexio_i2s.c ****         FLEXIO_ClearShifterErrorFlags(base->flexioBase, (1U << base->txShifterIndex));
 604:../drivers/fsl_flexio_i2s.c ****     }
 605:../drivers/fsl_flexio_i2s.c ****     /* Handle transfer */
 606:../drivers/fsl_flexio_i2s.c ****     if (((FLEXIO_I2S_GetStatusFlags(base) & kFLEXIO_I2S_TxDataRegEmptyFlag) != 0) &&
 1776              		.loc 1 606 0
 1777 0028 2800     		movs	r0, r5
 1778 002a FFF7FEFF 		bl	FLEXIO_I2S_GetStatusFlags
 1779              	.LVL198:
 1780 002e C307     		lsls	r3, r0, #31
 1781 0030 1BD5     		bpl	.L70
 607:../drivers/fsl_flexio_i2s.c ****         (handle->queue[handle->queueDriver].data != NULL))
 1782              		.loc 1 607 0 discriminator 1
 1783 0032 4123     		movs	r3, #65
 1784 0034 E35C     		ldrb	r3, [r4, r3]
 1785 0036 0233     		adds	r3, r3, #2
 1786 0038 DB00     		lsls	r3, r3, #3
 1787 003a 1B59     		ldr	r3, [r3, r4]
 606:../drivers/fsl_flexio_i2s.c ****         (handle->queue[handle->queueDriver].data != NULL))
 1788              		.loc 1 606 0 discriminator 1
 1789 003c 002B     		cmp	r3, #0
 1790 003e 14D0     		beq	.L70
 608:../drivers/fsl_flexio_i2s.c ****     {
 609:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_WriteNonBlocking(base, handle->bitWidth, buffer, dataSize);
 1791              		.loc 1 609 0
 1792 0040 217B     		ldrb	r1, [r4, #12]
 1793 0042 3300     		movs	r3, r6
 1794 0044 3A00     		movs	r2, r7
 1795 0046 2800     		movs	r0, r5
 1796 0048 FFF7FEFF 		bl	FLEXIO_I2S_WriteNonBlocking
 1797              	.LVL199:
 610:../drivers/fsl_flexio_i2s.c **** 
 611:../drivers/fsl_flexio_i2s.c ****         /* Update internal counter */
 612:../drivers/fsl_flexio_i2s.c ****         handle->queue[handle->queueDriver].dataSize -= dataSize;
 1798              		.loc 1 612 0
 1799 004c 4121     		movs	r1, #65
 1800 004e 635C     		ldrb	r3, [r4, r1]
 1801 0050 0233     		adds	r3, r3, #2
 1802 0052 DB00     		lsls	r3, r3, #3
 1803 0054 E318     		adds	r3, r4, r3
 1804 0056 5A68     		ldr	r2, [r3, #4]
 1805 0058 921B     		subs	r2, r2, r6
 1806 005a 5A60     		str	r2, [r3, #4]
 613:../drivers/fsl_flexio_i2s.c ****         handle->queue[handle->queueDriver].data += dataSize;
 1807              		.loc 1 613 0
 1808 005c 635C     		ldrb	r3, [r4, r1]
 1809 005e 0233     		adds	r3, r3, #2
 1810 0060 DB00     		lsls	r3, r3, #3
 1811 0062 1A59     		ldr	r2, [r3, r4]
 1812 0064 9446     		mov	ip, r2
 1813 0066 6644     		add	r6, r6, ip
 1814              	.LVL200:
 1815 0068 1E51     		str	r6, [r3, r4]
 1816              	.L70:
 614:../drivers/fsl_flexio_i2s.c ****     }
 615:../drivers/fsl_flexio_i2s.c **** 
 616:../drivers/fsl_flexio_i2s.c ****     /* If finished a blcok, call the callback function */
 617:../drivers/fsl_flexio_i2s.c ****     if ((handle->queue[handle->queueDriver].dataSize == 0U) && (handle->queue[handle->queueDriver].
 1817              		.loc 1 617 0
 1818 006a 4123     		movs	r3, #65
 1819 006c E35C     		ldrb	r3, [r4, r3]
 1820 006e 0233     		adds	r3, r3, #2
 1821 0070 DB00     		lsls	r3, r3, #3
 1822 0072 E318     		adds	r3, r4, r3
 1823 0074 5B68     		ldr	r3, [r3, #4]
 1824 0076 002B     		cmp	r3, #0
 1825 0078 1CD1     		bne	.L71
 1826              		.loc 1 617 0 is_stmt 0 discriminator 1
 1827 007a 4133     		adds	r3, r3, #65
 1828 007c E35C     		ldrb	r3, [r4, r3]
 1829 007e 0233     		adds	r3, r3, #2
 1830 0080 DB00     		lsls	r3, r3, #3
 1831 0082 1B59     		ldr	r3, [r3, r4]
 1832 0084 002B     		cmp	r3, #0
 1833 0086 15D0     		beq	.L71
 618:../drivers/fsl_flexio_i2s.c ****     {
 619:../drivers/fsl_flexio_i2s.c ****         memset(&handle->queue[handle->queueDriver], 0, sizeof(flexio_i2s_transfer_t));
 1834              		.loc 1 619 0 is_stmt 1
 1835 0088 4126     		movs	r6, #65
 1836 008a A05D     		ldrb	r0, [r4, r6]
 1837 008c 0230     		adds	r0, r0, #2
 1838 008e C000     		lsls	r0, r0, #3
 1839 0090 2018     		adds	r0, r4, r0
 1840 0092 0822     		movs	r2, #8
 1841 0094 0021     		movs	r1, #0
 1842 0096 FFF7FEFF 		bl	memset
 1843              	.LVL201:
 620:../drivers/fsl_flexio_i2s.c ****         handle->queueDriver = (handle->queueDriver + 1) % FLEXIO_I2S_XFER_QUEUE_SIZE;
 1844              		.loc 1 620 0
 1845 009a A25D     		ldrb	r2, [r4, r6]
 1846 009c 0132     		adds	r2, r2, #1
 1847 009e 0323     		movs	r3, #3
 1848 00a0 1340     		ands	r3, r2
 1849 00a2 A355     		strb	r3, [r4, r6]
 621:../drivers/fsl_flexio_i2s.c ****         if (handle->callback)
 1850              		.loc 1 621 0
 1851 00a4 6668     		ldr	r6, [r4, #4]
 1852 00a6 002E     		cmp	r6, #0
 1853 00a8 04D0     		beq	.L71
 622:../drivers/fsl_flexio_i2s.c ****         {
 623:../drivers/fsl_flexio_i2s.c ****             (handle->callback)(base, handle, kStatus_Success, handle->userData);
 1854              		.loc 1 623 0
 1855 00aa A368     		ldr	r3, [r4, #8]
 1856 00ac 0022     		movs	r2, #0
 1857 00ae 2100     		movs	r1, r4
 1858 00b0 2800     		movs	r0, r5
 1859 00b2 B047     		blx	r6
 1860              	.LVL202:
 1861              	.L71:
 624:../drivers/fsl_flexio_i2s.c ****         }
 625:../drivers/fsl_flexio_i2s.c ****     }
 626:../drivers/fsl_flexio_i2s.c **** 
 627:../drivers/fsl_flexio_i2s.c ****     /* If all data finished, just stop the transfer */
 628:../drivers/fsl_flexio_i2s.c ****     if (handle->queue[handle->queueDriver].data == NULL)
 1862              		.loc 1 628 0
 1863 00b4 4123     		movs	r3, #65
 1864 00b6 E35C     		ldrb	r3, [r4, r3]
 1865 00b8 0233     		adds	r3, r3, #2
 1866 00ba DB00     		lsls	r3, r3, #3
 1867 00bc 1B59     		ldr	r3, [r3, r4]
 1868 00be 002B     		cmp	r3, #0
 1869 00c0 00D0     		beq	.L73
 1870              	.L68:
 629:../drivers/fsl_flexio_i2s.c ****     {
 630:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_TransferAbortSend(base, handle);
 631:../drivers/fsl_flexio_i2s.c ****     }
 632:../drivers/fsl_flexio_i2s.c **** }
 1871              		.loc 1 632 0
 1872              		@ sp needed
 1873              	.LVL203:
 1874              	.LVL204:
 1875              	.LVL205:
 1876 00c2 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1877              	.LVL206:
 1878              	.L73:
 630:../drivers/fsl_flexio_i2s.c ****     }
 1879              		.loc 1 630 0
 1880 00c4 2100     		movs	r1, r4
 1881 00c6 2800     		movs	r0, r5
 1882 00c8 FFF7FEFF 		bl	FLEXIO_I2S_TransferAbortSend
 1883              	.LVL207:
 1884              		.loc 1 632 0
 1885 00cc F9E7     		b	.L68
 1886              		.cfi_endproc
 1887              	.LFE96:
 1889              		.section	.text.FLEXIO_I2S_TransferAbortReceive,"ax",%progbits
 1890              		.align	1
 1891              		.global	FLEXIO_I2S_TransferAbortReceive
 1892              		.syntax unified
 1893              		.code	16
 1894              		.thumb_func
 1895              		.fpu softvfp
 1897              	FLEXIO_I2S_TransferAbortReceive:
 1898              	.LFB93:
 542:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 1899              		.loc 1 542 0
 1900              		.cfi_startproc
 1901              		@ args = 0, pretend = 0, frame = 0
 1902              		@ frame_needed = 0, uses_anonymous_args = 0
 1903              	.LVL208:
 1904 0000 10B5     		push	{r4, lr}
 1905              		.cfi_def_cfa_offset 8
 1906              		.cfi_offset 4, -8
 1907              		.cfi_offset 14, -4
 1908 0002 0C00     		movs	r4, r1
 546:../drivers/fsl_flexio_i2s.c ****     handle->state = kFLEXIO_I2S_Idle;
 1909              		.loc 1 546 0
 1910 0004 0221     		movs	r1, #2
 1911              	.LVL209:
 1912 0006 FFF7FEFF 		bl	FLEXIO_I2S_DisableInterrupts
 1913              	.LVL210:
 547:../drivers/fsl_flexio_i2s.c **** 
 1914              		.loc 1 547 0
 1915 000a 0123     		movs	r3, #1
 1916 000c 2360     		str	r3, [r4]
 550:../drivers/fsl_flexio_i2s.c ****     handle->queueDriver = 0;
 1917              		.loc 1 550 0
 1918 000e 2000     		movs	r0, r4
 1919 0010 1030     		adds	r0, r0, #16
 1920 0012 2022     		movs	r2, #32
 1921 0014 0021     		movs	r1, #0
 1922 0016 FFF7FEFF 		bl	memset
 1923              	.LVL211:
 551:../drivers/fsl_flexio_i2s.c ****     handle->queueUser = 0;
 1924              		.loc 1 551 0
 1925 001a 0023     		movs	r3, #0
 1926 001c 4122     		movs	r2, #65
 1927 001e A354     		strb	r3, [r4, r2]
 552:../drivers/fsl_flexio_i2s.c **** }
 1928              		.loc 1 552 0
 1929 0020 013A     		subs	r2, r2, #1
 1930 0022 A354     		strb	r3, [r4, r2]
 553:../drivers/fsl_flexio_i2s.c **** 
 1931              		.loc 1 553 0
 1932              		@ sp needed
 1933              	.LVL212:
 1934 0024 10BD     		pop	{r4, pc}
 1935              		.cfi_endproc
 1936              	.LFE93:
 1938              		.section	.text.FLEXIO_I2S_TransferRxHandleIRQ,"ax",%progbits
 1939              		.align	1
 1940              		.global	FLEXIO_I2S_TransferRxHandleIRQ
 1941              		.syntax unified
 1942              		.code	16
 1943              		.thumb_func
 1944              		.fpu softvfp
 1946              	FLEXIO_I2S_TransferRxHandleIRQ:
 1947              	.LFB97:
 633:../drivers/fsl_flexio_i2s.c **** 
 634:../drivers/fsl_flexio_i2s.c **** void FLEXIO_I2S_TransferRxHandleIRQ(void *i2sBase, void *i2sHandle)
 635:../drivers/fsl_flexio_i2s.c **** {
 1948              		.loc 1 635 0
 1949              		.cfi_startproc
 1950              		@ args = 0, pretend = 0, frame = 0
 1951              		@ frame_needed = 0, uses_anonymous_args = 0
 1952              	.LVL213:
 1953 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1954              		.cfi_def_cfa_offset 24
 1955              		.cfi_offset 3, -24
 1956              		.cfi_offset 4, -20
 1957              		.cfi_offset 5, -16
 1958              		.cfi_offset 6, -12
 1959              		.cfi_offset 7, -8
 1960              		.cfi_offset 14, -4
 1961 0002 0500     		movs	r5, r0
 1962 0004 0C00     		movs	r4, r1
 1963              	.LVL214:
 636:../drivers/fsl_flexio_i2s.c ****     assert(i2sHandle);
 637:../drivers/fsl_flexio_i2s.c **** 
 638:../drivers/fsl_flexio_i2s.c ****     flexio_i2s_handle_t *handle = (flexio_i2s_handle_t *)i2sHandle;
 639:../drivers/fsl_flexio_i2s.c ****     FLEXIO_I2S_Type *base = (FLEXIO_I2S_Type *)i2sBase;
 640:../drivers/fsl_flexio_i2s.c ****     uint8_t *buffer = handle->queue[handle->queueDriver].data;
 1964              		.loc 1 640 0
 1965 0006 4123     		movs	r3, #65
 1966 0008 CB5C     		ldrb	r3, [r1, r3]
 1967 000a 0233     		adds	r3, r3, #2
 1968 000c DB00     		lsls	r3, r3, #3
 1969 000e 5F58     		ldr	r7, [r3, r1]
 1970              	.LVL215:
 641:../drivers/fsl_flexio_i2s.c ****     uint8_t dataSize = handle->bitWidth / 8U;
 1971              		.loc 1 641 0
 1972 0010 0E7B     		ldrb	r6, [r1, #12]
 1973 0012 F608     		lsrs	r6, r6, #3
 1974              	.LVL216:
 642:../drivers/fsl_flexio_i2s.c **** 
 643:../drivers/fsl_flexio_i2s.c ****     /* Handle transfer */
 644:../drivers/fsl_flexio_i2s.c ****     if (((FLEXIO_I2S_GetStatusFlags(base) & kFLEXIO_I2S_RxDataRegFullFlag) != 0) &&
 1975              		.loc 1 644 0
 1976 0014 FFF7FEFF 		bl	FLEXIO_I2S_GetStatusFlags
 1977              	.LVL217:
 1978 0018 8307     		lsls	r3, r0, #30
 1979 001a 1BD5     		bpl	.L76
 645:../drivers/fsl_flexio_i2s.c ****         (handle->queue[handle->queueDriver].data != NULL))
 1980              		.loc 1 645 0 discriminator 1
 1981 001c 4123     		movs	r3, #65
 1982 001e E35C     		ldrb	r3, [r4, r3]
 1983 0020 0233     		adds	r3, r3, #2
 1984 0022 DB00     		lsls	r3, r3, #3
 1985 0024 1B59     		ldr	r3, [r3, r4]
 644:../drivers/fsl_flexio_i2s.c ****         (handle->queue[handle->queueDriver].data != NULL))
 1986              		.loc 1 644 0 discriminator 1
 1987 0026 002B     		cmp	r3, #0
 1988 0028 14D0     		beq	.L76
 646:../drivers/fsl_flexio_i2s.c ****     {
 647:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_ReadNonBlocking(base, handle->bitWidth, buffer, dataSize);
 1989              		.loc 1 647 0
 1990 002a 217B     		ldrb	r1, [r4, #12]
 1991 002c 3300     		movs	r3, r6
 1992 002e 3A00     		movs	r2, r7
 1993 0030 2800     		movs	r0, r5
 1994 0032 FFF7FEFF 		bl	FLEXIO_I2S_ReadNonBlocking
 1995              	.LVL218:
 648:../drivers/fsl_flexio_i2s.c **** 
 649:../drivers/fsl_flexio_i2s.c ****         /* Update internal state */
 650:../drivers/fsl_flexio_i2s.c ****         handle->queue[handle->queueDriver].dataSize -= dataSize;
 1996              		.loc 1 650 0
 1997 0036 4121     		movs	r1, #65
 1998 0038 635C     		ldrb	r3, [r4, r1]
 1999 003a 0233     		adds	r3, r3, #2
 2000 003c DB00     		lsls	r3, r3, #3
 2001 003e E318     		adds	r3, r4, r3
 2002 0040 5A68     		ldr	r2, [r3, #4]
 2003 0042 921B     		subs	r2, r2, r6
 2004 0044 5A60     		str	r2, [r3, #4]
 651:../drivers/fsl_flexio_i2s.c ****         handle->queue[handle->queueDriver].data += dataSize;
 2005              		.loc 1 651 0
 2006 0046 635C     		ldrb	r3, [r4, r1]
 2007 0048 0233     		adds	r3, r3, #2
 2008 004a DB00     		lsls	r3, r3, #3
 2009 004c 1A59     		ldr	r2, [r3, r4]
 2010 004e 9446     		mov	ip, r2
 2011 0050 6644     		add	r6, r6, ip
 2012              	.LVL219:
 2013 0052 1E51     		str	r6, [r3, r4]
 2014              	.L76:
 652:../drivers/fsl_flexio_i2s.c ****     }
 653:../drivers/fsl_flexio_i2s.c **** 
 654:../drivers/fsl_flexio_i2s.c ****     /* If finished a blcok, call the callback function */
 655:../drivers/fsl_flexio_i2s.c ****     if ((handle->queue[handle->queueDriver].dataSize == 0U) && (handle->queue[handle->queueDriver].
 2015              		.loc 1 655 0
 2016 0054 4123     		movs	r3, #65
 2017 0056 E35C     		ldrb	r3, [r4, r3]
 2018 0058 0233     		adds	r3, r3, #2
 2019 005a DB00     		lsls	r3, r3, #3
 2020 005c E318     		adds	r3, r4, r3
 2021 005e 5B68     		ldr	r3, [r3, #4]
 2022 0060 002B     		cmp	r3, #0
 2023 0062 1CD1     		bne	.L77
 2024              		.loc 1 655 0 is_stmt 0 discriminator 1
 2025 0064 4133     		adds	r3, r3, #65
 2026 0066 E35C     		ldrb	r3, [r4, r3]
 2027 0068 0233     		adds	r3, r3, #2
 2028 006a DB00     		lsls	r3, r3, #3
 2029 006c 1B59     		ldr	r3, [r3, r4]
 2030 006e 002B     		cmp	r3, #0
 2031 0070 15D0     		beq	.L77
 656:../drivers/fsl_flexio_i2s.c ****     {
 657:../drivers/fsl_flexio_i2s.c ****         memset(&handle->queue[handle->queueDriver], 0, sizeof(flexio_i2s_transfer_t));
 2032              		.loc 1 657 0 is_stmt 1
 2033 0072 4126     		movs	r6, #65
 2034 0074 A05D     		ldrb	r0, [r4, r6]
 2035 0076 0230     		adds	r0, r0, #2
 2036 0078 C000     		lsls	r0, r0, #3
 2037 007a 2018     		adds	r0, r4, r0
 2038 007c 0822     		movs	r2, #8
 2039 007e 0021     		movs	r1, #0
 2040 0080 FFF7FEFF 		bl	memset
 2041              	.LVL220:
 658:../drivers/fsl_flexio_i2s.c ****         handle->queueDriver = (handle->queueDriver + 1) % FLEXIO_I2S_XFER_QUEUE_SIZE;
 2042              		.loc 1 658 0
 2043 0084 A25D     		ldrb	r2, [r4, r6]
 2044 0086 0132     		adds	r2, r2, #1
 2045 0088 0323     		movs	r3, #3
 2046 008a 1340     		ands	r3, r2
 2047 008c A355     		strb	r3, [r4, r6]
 659:../drivers/fsl_flexio_i2s.c ****         if (handle->callback)
 2048              		.loc 1 659 0
 2049 008e 6668     		ldr	r6, [r4, #4]
 2050 0090 002E     		cmp	r6, #0
 2051 0092 04D0     		beq	.L77
 660:../drivers/fsl_flexio_i2s.c ****         {
 661:../drivers/fsl_flexio_i2s.c ****             (handle->callback)(base, handle, kStatus_Success, handle->userData);
 2052              		.loc 1 661 0
 2053 0094 A368     		ldr	r3, [r4, #8]
 2054 0096 0022     		movs	r2, #0
 2055 0098 2100     		movs	r1, r4
 2056 009a 2800     		movs	r0, r5
 2057 009c B047     		blx	r6
 2058              	.LVL221:
 2059              	.L77:
 662:../drivers/fsl_flexio_i2s.c ****         }
 663:../drivers/fsl_flexio_i2s.c ****     }
 664:../drivers/fsl_flexio_i2s.c **** 
 665:../drivers/fsl_flexio_i2s.c ****     /* If all data finished, just stop the transfer */
 666:../drivers/fsl_flexio_i2s.c ****     if (handle->queue[handle->queueDriver].data == NULL)
 2060              		.loc 1 666 0
 2061 009e 4123     		movs	r3, #65
 2062 00a0 E35C     		ldrb	r3, [r4, r3]
 2063 00a2 0233     		adds	r3, r3, #2
 2064 00a4 DB00     		lsls	r3, r3, #3
 2065 00a6 1B59     		ldr	r3, [r3, r4]
 2066 00a8 002B     		cmp	r3, #0
 2067 00aa 00D0     		beq	.L79
 2068              	.L75:
 667:../drivers/fsl_flexio_i2s.c ****     {
 668:../drivers/fsl_flexio_i2s.c ****         FLEXIO_I2S_TransferAbortReceive(base, handle);
 669:../drivers/fsl_flexio_i2s.c ****     }
 670:../drivers/fsl_flexio_i2s.c **** }
 2069              		.loc 1 670 0
 2070              		@ sp needed
 2071              	.LVL222:
 2072              	.LVL223:
 2073              	.LVL224:
 2074 00ac F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2075              	.LVL225:
 2076              	.L79:
 668:../drivers/fsl_flexio_i2s.c ****     }
 2077              		.loc 1 668 0
 2078 00ae 2100     		movs	r1, r4
 2079 00b0 2800     		movs	r0, r5
 2080 00b2 FFF7FEFF 		bl	FLEXIO_I2S_TransferAbortReceive
 2081              	.LVL226:
 2082              		.loc 1 670 0
 2083 00b6 F9E7     		b	.L75
 2084              		.cfi_endproc
 2085              	.LFE97:
 2087              		.section	.text.FLEXIO_I2S_TransferGetSendCount,"ax",%progbits
 2088              		.align	1
 2089              		.global	FLEXIO_I2S_TransferGetSendCount
 2090              		.syntax unified
 2091              		.code	16
 2092              		.thumb_func
 2093              		.fpu softvfp
 2095              	FLEXIO_I2S_TransferGetSendCount:
 2096              	.LFB94:
 556:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 2097              		.loc 1 556 0
 2098              		.cfi_startproc
 2099              		@ args = 0, pretend = 0, frame = 0
 2100              		@ frame_needed = 0, uses_anonymous_args = 0
 2101              	.LVL227:
 2102 0000 10B5     		push	{r4, lr}
 2103              		.cfi_def_cfa_offset 8
 2104              		.cfi_offset 4, -8
 2105              		.cfi_offset 14, -4
 2106              	.LVL228:
 561:../drivers/fsl_flexio_i2s.c ****     {
 2107              		.loc 1 561 0
 2108 0002 0B68     		ldr	r3, [r1]
 2109 0004 002B     		cmp	r3, #0
 2110 0006 0DD1     		bne	.L82
 567:../drivers/fsl_flexio_i2s.c ****     }
 2111              		.loc 1 567 0
 2112 0008 4124     		movs	r4, #65
 2113 000a 0B5D     		ldrb	r3, [r1, r4]
 2114 000c 0C33     		adds	r3, r3, #12
 2115 000e 9B00     		lsls	r3, r3, #2
 2116 0010 5858     		ldr	r0, [r3, r1]
 2117              	.LVL229:
 2118 0012 0B5D     		ldrb	r3, [r1, r4]
 2119 0014 0233     		adds	r3, r3, #2
 2120 0016 DB00     		lsls	r3, r3, #3
 2121 0018 C918     		adds	r1, r1, r3
 2122              	.LVL230:
 2123 001a 4B68     		ldr	r3, [r1, #4]
 2124 001c C31A     		subs	r3, r0, r3
 2125 001e 1360     		str	r3, [r2]
 559:../drivers/fsl_flexio_i2s.c **** 
 2126              		.loc 1 559 0
 2127 0020 0020     		movs	r0, #0
 2128              	.LVL231:
 2129              	.L80:
 571:../drivers/fsl_flexio_i2s.c **** 
 2130              		.loc 1 571 0
 2131              		@ sp needed
 2132 0022 10BD     		pop	{r4, pc}
 2133              	.LVL232:
 2134              	.L82:
 563:../drivers/fsl_flexio_i2s.c ****     }
 2135              		.loc 1 563 0
 2136 0024 0620     		movs	r0, #6
 2137              	.LVL233:
 570:../drivers/fsl_flexio_i2s.c **** }
 2138              		.loc 1 570 0
 2139 0026 FCE7     		b	.L80
 2140              		.cfi_endproc
 2141              	.LFE94:
 2143              		.section	.text.FLEXIO_I2S_TransferGetReceiveCount,"ax",%progbits
 2144              		.align	1
 2145              		.global	FLEXIO_I2S_TransferGetReceiveCount
 2146              		.syntax unified
 2147              		.code	16
 2148              		.thumb_func
 2149              		.fpu softvfp
 2151              	FLEXIO_I2S_TransferGetReceiveCount:
 2152              	.LFB95:
 574:../drivers/fsl_flexio_i2s.c ****     assert(handle);
 2153              		.loc 1 574 0
 2154              		.cfi_startproc
 2155              		@ args = 0, pretend = 0, frame = 0
 2156              		@ frame_needed = 0, uses_anonymous_args = 0
 2157              	.LVL234:
 2158 0000 10B5     		push	{r4, lr}
 2159              		.cfi_def_cfa_offset 8
 2160              		.cfi_offset 4, -8
 2161              		.cfi_offset 14, -4
 2162              	.LVL235:
 579:../drivers/fsl_flexio_i2s.c ****     {
 2163              		.loc 1 579 0
 2164 0002 0B68     		ldr	r3, [r1]
 2165 0004 002B     		cmp	r3, #0
 2166 0006 0DD1     		bne	.L85
 585:../drivers/fsl_flexio_i2s.c ****     }
 2167              		.loc 1 585 0
 2168 0008 4124     		movs	r4, #65
 2169 000a 0B5D     		ldrb	r3, [r1, r4]
 2170 000c 0C33     		adds	r3, r3, #12
 2171 000e 9B00     		lsls	r3, r3, #2
 2172 0010 5858     		ldr	r0, [r3, r1]
 2173              	.LVL236:
 2174 0012 0B5D     		ldrb	r3, [r1, r4]
 2175 0014 0233     		adds	r3, r3, #2
 2176 0016 DB00     		lsls	r3, r3, #3
 2177 0018 C918     		adds	r1, r1, r3
 2178              	.LVL237:
 2179 001a 4B68     		ldr	r3, [r1, #4]
 2180 001c C31A     		subs	r3, r0, r3
 2181 001e 1360     		str	r3, [r2]
 577:../drivers/fsl_flexio_i2s.c **** 
 2182              		.loc 1 577 0
 2183 0020 0020     		movs	r0, #0
 2184              	.LVL238:
 2185              	.L83:
 589:../drivers/fsl_flexio_i2s.c **** 
 2186              		.loc 1 589 0
 2187              		@ sp needed
 2188 0022 10BD     		pop	{r4, pc}
 2189              	.LVL239:
 2190              	.L85:
 581:../drivers/fsl_flexio_i2s.c ****     }
 2191              		.loc 1 581 0
 2192 0024 0620     		movs	r0, #6
 2193              	.LVL240:
 588:../drivers/fsl_flexio_i2s.c **** }
 2194              		.loc 1 588 0
 2195 0026 FCE7     		b	.L83
 2196              		.cfi_endproc
 2197              	.LFE95:
 2199              		.text
 2200              	.Letext0:
 2201              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 2202              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2203              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 2204              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 2205              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 2206              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 2207              		.file 12 "../CMSIS/MKL17Z4.h"
 2208              		.file 13 "../CMSIS/system_MKL17Z4.h"
 2209              		.file 14 "../drivers/fsl_common.h"
 2210              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_flexio_i2s.c
     /tmp/cck1row0.s:17     .text.FLEXIO_I2S_WriteNonBlocking:0000000000000000 $t
     /tmp/cck1row0.s:23     .text.FLEXIO_I2S_WriteNonBlocking:0000000000000000 FLEXIO_I2S_WriteNonBlocking
     /tmp/cck1row0.s:122    .text.FLEXIO_I2S_ReadNonBlocking:0000000000000000 $t
     /tmp/cck1row0.s:128    .text.FLEXIO_I2S_ReadNonBlocking:0000000000000000 FLEXIO_I2S_ReadNonBlocking
     /tmp/cck1row0.s:220    .text.FLEXIO_I2S_GetInstance:0000000000000000 $t
     /tmp/cck1row0.s:227    .text.FLEXIO_I2S_GetInstance:0000000000000000 FLEXIO_I2S_GetInstance
     /tmp/cck1row0.s:250    .text.FLEXIO_I2S_Init:0000000000000000 $t
     /tmp/cck1row0.s:257    .text.FLEXIO_I2S_Init:0000000000000000 FLEXIO_I2S_Init
     /tmp/cck1row0.s:607    .text.FLEXIO_I2S_Init:00000000000001b8 $d
     /tmp/cck1row0.s:613    .text.FLEXIO_I2S_GetDefaultConfig:0000000000000000 $t
     /tmp/cck1row0.s:620    .text.FLEXIO_I2S_GetDefaultConfig:0000000000000000 FLEXIO_I2S_GetDefaultConfig
     /tmp/cck1row0.s:653    .text.FLEXIO_I2S_Deinit:0000000000000000 $t
     /tmp/cck1row0.s:660    .text.FLEXIO_I2S_Deinit:0000000000000000 FLEXIO_I2S_Deinit
     /tmp/cck1row0.s:742    .text.FLEXIO_I2S_EnableInterrupts:0000000000000000 $t
     /tmp/cck1row0.s:749    .text.FLEXIO_I2S_EnableInterrupts:0000000000000000 FLEXIO_I2S_EnableInterrupts
     /tmp/cck1row0.s:809    .text.FLEXIO_I2S_GetStatusFlags:0000000000000000 $t
     /tmp/cck1row0.s:816    .text.FLEXIO_I2S_GetStatusFlags:0000000000000000 FLEXIO_I2S_GetStatusFlags
     /tmp/cck1row0.s:878    .text.FLEXIO_I2S_DisableInterrupts:0000000000000000 $t
     /tmp/cck1row0.s:885    .text.FLEXIO_I2S_DisableInterrupts:0000000000000000 FLEXIO_I2S_DisableInterrupts
     /tmp/cck1row0.s:942    .text.FLEXIO_I2S_MasterSetFormat:0000000000000000 $t
     /tmp/cck1row0.s:949    .text.FLEXIO_I2S_MasterSetFormat:0000000000000000 FLEXIO_I2S_MasterSetFormat
     /tmp/cck1row0.s:1013   .text.FLEXIO_I2S_SlaveSetFormat:0000000000000000 $t
     /tmp/cck1row0.s:1020   .text.FLEXIO_I2S_SlaveSetFormat:0000000000000000 FLEXIO_I2S_SlaveSetFormat
     /tmp/cck1row0.s:1052   .text.FLEXIO_I2S_WriteBlocking:0000000000000000 $t
     /tmp/cck1row0.s:1059   .text.FLEXIO_I2S_WriteBlocking:0000000000000000 FLEXIO_I2S_WriteBlocking
     /tmp/cck1row0.s:1135   .text.FLEXIO_I2S_ReadBlocking:0000000000000000 $t
     /tmp/cck1row0.s:1142   .text.FLEXIO_I2S_ReadBlocking:0000000000000000 FLEXIO_I2S_ReadBlocking
     /tmp/cck1row0.s:1224   .text.FLEXIO_I2S_TransferTxCreateHandle:0000000000000000 $t
     /tmp/cck1row0.s:1231   .text.FLEXIO_I2S_TransferTxCreateHandle:0000000000000000 FLEXIO_I2S_TransferTxCreateHandle
     /tmp/cck1row0.s:1299   .text.FLEXIO_I2S_TransferTxCreateHandle:0000000000000038 $d
     /tmp/cck1row0.s:1719   .text.FLEXIO_I2S_TransferTxHandleIRQ:0000000000000000 FLEXIO_I2S_TransferTxHandleIRQ
     /tmp/cck1row0.s:1305   .text.FLEXIO_I2S_TransferRxCreateHandle:0000000000000000 $t
     /tmp/cck1row0.s:1312   .text.FLEXIO_I2S_TransferRxCreateHandle:0000000000000000 FLEXIO_I2S_TransferRxCreateHandle
     /tmp/cck1row0.s:1379   .text.FLEXIO_I2S_TransferRxCreateHandle:0000000000000038 $d
     /tmp/cck1row0.s:1946   .text.FLEXIO_I2S_TransferRxHandleIRQ:0000000000000000 FLEXIO_I2S_TransferRxHandleIRQ
     /tmp/cck1row0.s:1385   .text.FLEXIO_I2S_TransferSetFormat:0000000000000000 $t
     /tmp/cck1row0.s:1392   .text.FLEXIO_I2S_TransferSetFormat:0000000000000000 FLEXIO_I2S_TransferSetFormat
     /tmp/cck1row0.s:1434   .text.FLEXIO_I2S_TransferSendNonBlocking:0000000000000000 $t
     /tmp/cck1row0.s:1441   .text.FLEXIO_I2S_TransferSendNonBlocking:0000000000000000 FLEXIO_I2S_TransferSendNonBlocking
     /tmp/cck1row0.s:1549   .text.FLEXIO_I2S_TransferReceiveNonBlocking:0000000000000000 $t
     /tmp/cck1row0.s:1556   .text.FLEXIO_I2S_TransferReceiveNonBlocking:0000000000000000 FLEXIO_I2S_TransferReceiveNonBlocking
     /tmp/cck1row0.s:1663   .text.FLEXIO_I2S_TransferAbortSend:0000000000000000 $t
     /tmp/cck1row0.s:1670   .text.FLEXIO_I2S_TransferAbortSend:0000000000000000 FLEXIO_I2S_TransferAbortSend
     /tmp/cck1row0.s:1712   .text.FLEXIO_I2S_TransferTxHandleIRQ:0000000000000000 $t
     /tmp/cck1row0.s:1890   .text.FLEXIO_I2S_TransferAbortReceive:0000000000000000 $t
     /tmp/cck1row0.s:1897   .text.FLEXIO_I2S_TransferAbortReceive:0000000000000000 FLEXIO_I2S_TransferAbortReceive
     /tmp/cck1row0.s:1939   .text.FLEXIO_I2S_TransferRxHandleIRQ:0000000000000000 $t
     /tmp/cck1row0.s:2088   .text.FLEXIO_I2S_TransferGetSendCount:0000000000000000 $t
     /tmp/cck1row0.s:2095   .text.FLEXIO_I2S_TransferGetSendCount:0000000000000000 FLEXIO_I2S_TransferGetSendCount
     /tmp/cck1row0.s:2144   .text.FLEXIO_I2S_TransferGetReceiveCount:0000000000000000 $t
     /tmp/cck1row0.s:2151   .text.FLEXIO_I2S_TransferGetReceiveCount:0000000000000000 FLEXIO_I2S_TransferGetReceiveCount

UNDEFINED SYMBOLS
__aeabi_uidiv
FLEXIO_GetInstance
memset
FLEXIO_SetShifterConfig
FLEXIO_SetTimerConfig
s_flexioClocks
FLEXIO_RegisterHandleIRQ
