   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_spi.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.SPI_GetWatermark,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	SPI_GetWatermark:
  23              	.LFB66:
  24              		.file 1 "../drivers/fsl_spi.c"
   1:../drivers/fsl_spi.c **** /*
   2:../drivers/fsl_spi.c ****  * The Clear BSD License
   3:../drivers/fsl_spi.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_spi.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_spi.c ****  * All rights reserved.
   6:../drivers/fsl_spi.c ****  *
   7:../drivers/fsl_spi.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_spi.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_spi.c ****  * that the following conditions are met:
  10:../drivers/fsl_spi.c ****  *
  11:../drivers/fsl_spi.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_spi.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_spi.c ****  *
  14:../drivers/fsl_spi.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_spi.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_spi.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_spi.c ****  *
  18:../drivers/fsl_spi.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_spi.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_spi.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_spi.c ****  *
  22:../drivers/fsl_spi.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_spi.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_spi.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_spi.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_spi.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_spi.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_spi.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_spi.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_spi.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_spi.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_spi.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_spi.c ****  */
  34:../drivers/fsl_spi.c **** 
  35:../drivers/fsl_spi.c **** #include "fsl_spi.h"
  36:../drivers/fsl_spi.c **** 
  37:../drivers/fsl_spi.c **** /*******************************************************************************
  38:../drivers/fsl_spi.c ****  * Definitons
  39:../drivers/fsl_spi.c ****  ******************************************************************************/
  40:../drivers/fsl_spi.c **** /*! @brief SPI transfer state, which is used for SPI transactiaonl APIs' internal state. */
  41:../drivers/fsl_spi.c **** enum _spi_transfer_states_t
  42:../drivers/fsl_spi.c **** {
  43:../drivers/fsl_spi.c ****     kSPI_Idle = 0x0, /*!< SPI is idle state */
  44:../drivers/fsl_spi.c ****     kSPI_Busy        /*!< SPI is busy tranferring data. */
  45:../drivers/fsl_spi.c **** };
  46:../drivers/fsl_spi.c **** 
  47:../drivers/fsl_spi.c **** /*! @brief Typedef for spi master interrupt handler. spi master and slave handle is the same. */
  48:../drivers/fsl_spi.c **** typedef void (*spi_isr_t)(SPI_Type *base, spi_master_handle_t *spiHandle);
  49:../drivers/fsl_spi.c **** 
  50:../drivers/fsl_spi.c **** /*******************************************************************************
  51:../drivers/fsl_spi.c ****  * Prototypes
  52:../drivers/fsl_spi.c ****  ******************************************************************************/
  53:../drivers/fsl_spi.c **** /*!
  54:../drivers/fsl_spi.c ****  * @brief Get the instance for SPI module.
  55:../drivers/fsl_spi.c ****  *
  56:../drivers/fsl_spi.c ****  * @param base SPI base address
  57:../drivers/fsl_spi.c ****  */
  58:../drivers/fsl_spi.c **** uint32_t SPI_GetInstance(SPI_Type *base);
  59:../drivers/fsl_spi.c **** 
  60:../drivers/fsl_spi.c **** /*!
  61:../drivers/fsl_spi.c ****  * @brief Sends a buffer of data bytes in non-blocking way.
  62:../drivers/fsl_spi.c ****  *
  63:../drivers/fsl_spi.c ****  * @param base SPI base pointer
  64:../drivers/fsl_spi.c ****  * @param buffer The data bytes to send
  65:../drivers/fsl_spi.c ****  * @param size The number of data bytes to send
  66:../drivers/fsl_spi.c ****  */
  67:../drivers/fsl_spi.c **** static void SPI_WriteNonBlocking(SPI_Type *base, uint8_t *buffer, size_t size);
  68:../drivers/fsl_spi.c **** 
  69:../drivers/fsl_spi.c **** /*!
  70:../drivers/fsl_spi.c ****  * @brief Receive a buffer of data bytes in non-blocking way.
  71:../drivers/fsl_spi.c ****  *
  72:../drivers/fsl_spi.c ****  * @param base SPI base pointer
  73:../drivers/fsl_spi.c ****  * @param buffer The data bytes to send
  74:../drivers/fsl_spi.c ****  * @param size The number of data bytes to send
  75:../drivers/fsl_spi.c ****  */
  76:../drivers/fsl_spi.c **** static void SPI_ReadNonBlocking(SPI_Type *base, uint8_t *buffer, size_t size);
  77:../drivers/fsl_spi.c **** 
  78:../drivers/fsl_spi.c **** /*!
  79:../drivers/fsl_spi.c ****  * @brief Get the waterrmark value for this SPI instance.
  80:../drivers/fsl_spi.c ****  *
  81:../drivers/fsl_spi.c ****  * @param base SPI base pointer
  82:../drivers/fsl_spi.c ****  * @return Watermark value for the SPI instance.
  83:../drivers/fsl_spi.c ****  */
  84:../drivers/fsl_spi.c **** static uint8_t SPI_GetWatermark(SPI_Type *base);
  85:../drivers/fsl_spi.c **** 
  86:../drivers/fsl_spi.c **** /*!
  87:../drivers/fsl_spi.c ****  * @brief Send a piece of data for SPI.
  88:../drivers/fsl_spi.c ****  *
  89:../drivers/fsl_spi.c ****  * This function computes the number of data to be written into D register or Tx FIFO,
  90:../drivers/fsl_spi.c ****  * and write the data into it. At the same time, this function updates the values in
  91:../drivers/fsl_spi.c ****  * master handle structure.
  92:../drivers/fsl_spi.c ****  *
  93:../drivers/fsl_spi.c ****  * @param base SPI base pointer
  94:../drivers/fsl_spi.c ****  * @param handle Pointer to SPI master handle structure.
  95:../drivers/fsl_spi.c ****  */
  96:../drivers/fsl_spi.c **** static void SPI_SendTransfer(SPI_Type *base, spi_master_handle_t *handle);
  97:../drivers/fsl_spi.c **** 
  98:../drivers/fsl_spi.c **** /*!
  99:../drivers/fsl_spi.c ****  * @brief Receive a piece of data for SPI master.
 100:../drivers/fsl_spi.c ****  *
 101:../drivers/fsl_spi.c ****  * This function computes the number of data to receive from D register or Rx FIFO,
 102:../drivers/fsl_spi.c ****  * and write the data to destination address. At the same time, this function updates
 103:../drivers/fsl_spi.c ****  * the values in master handle structure.
 104:../drivers/fsl_spi.c ****  *
 105:../drivers/fsl_spi.c ****  * @param base SPI base pointer
 106:../drivers/fsl_spi.c ****  * @param handle Pointer to SPI master handle structure.
 107:../drivers/fsl_spi.c ****  */
 108:../drivers/fsl_spi.c **** static void SPI_ReceiveTransfer(SPI_Type *base, spi_master_handle_t *handle);
 109:../drivers/fsl_spi.c **** 
 110:../drivers/fsl_spi.c **** /*!
 111:../drivers/fsl_spi.c ****  * @brief Common IRQ handler for SPI.
 112:../drivers/fsl_spi.c ****  *
 113:../drivers/fsl_spi.c ****  * @param base SPI base pointer.
 114:../drivers/fsl_spi.c ****  * @param instance SPI instance number.
 115:../drivers/fsl_spi.c ****  */
 116:../drivers/fsl_spi.c **** static void SPI_CommonIRQHandler(SPI_Type *base, uint32_t instance);
 117:../drivers/fsl_spi.c **** /*******************************************************************************
 118:../drivers/fsl_spi.c ****  * Variables
 119:../drivers/fsl_spi.c ****  ******************************************************************************/
 120:../drivers/fsl_spi.c **** /*! @brief SPI internal handle pointer array */
 121:../drivers/fsl_spi.c **** static spi_master_handle_t *s_spiHandle[FSL_FEATURE_SOC_SPI_COUNT];
 122:../drivers/fsl_spi.c **** /*! @brief Base pointer array */
 123:../drivers/fsl_spi.c **** static SPI_Type *const s_spiBases[] = SPI_BASE_PTRS;
 124:../drivers/fsl_spi.c **** /*! @brief IRQ name array */
 125:../drivers/fsl_spi.c **** static const IRQn_Type s_spiIRQ[] = SPI_IRQS;
 126:../drivers/fsl_spi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 127:../drivers/fsl_spi.c **** /*! @brief Clock array name */
 128:../drivers/fsl_spi.c **** static const clock_ip_name_t s_spiClock[] = SPI_CLOCKS;
 129:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 130:../drivers/fsl_spi.c **** 
 131:../drivers/fsl_spi.c **** /*! @brief Pointer to master IRQ handler for each instance. */
 132:../drivers/fsl_spi.c **** static spi_isr_t s_spiMasterIsr;
 133:../drivers/fsl_spi.c **** static spi_isr_t s_spiSlaveIsr;
 134:../drivers/fsl_spi.c **** 
 135:../drivers/fsl_spi.c **** /* @brief Dummy data for each instance. This data is used when user's tx buffer is NULL*/
 136:../drivers/fsl_spi.c **** volatile uint8_t s_dummyData[ARRAY_SIZE(s_spiBases)] = {0};
 137:../drivers/fsl_spi.c **** /*******************************************************************************
 138:../drivers/fsl_spi.c ****  * Code
 139:../drivers/fsl_spi.c ****  ******************************************************************************/
 140:../drivers/fsl_spi.c **** uint32_t SPI_GetInstance(SPI_Type *base)
 141:../drivers/fsl_spi.c **** {
 142:../drivers/fsl_spi.c ****     uint32_t instance;
 143:../drivers/fsl_spi.c **** 
 144:../drivers/fsl_spi.c ****     /* Find the instance index from base address mappings. */
 145:../drivers/fsl_spi.c ****     for (instance = 0; instance < ARRAY_SIZE(s_spiBases); instance++)
 146:../drivers/fsl_spi.c ****     {
 147:../drivers/fsl_spi.c ****         if (s_spiBases[instance] == base)
 148:../drivers/fsl_spi.c ****         {
 149:../drivers/fsl_spi.c ****             break;
 150:../drivers/fsl_spi.c ****         }
 151:../drivers/fsl_spi.c ****     }
 152:../drivers/fsl_spi.c **** 
 153:../drivers/fsl_spi.c ****     assert(instance < ARRAY_SIZE(s_spiBases));
 154:../drivers/fsl_spi.c **** 
 155:../drivers/fsl_spi.c ****     return instance;
 156:../drivers/fsl_spi.c **** }
 157:../drivers/fsl_spi.c **** 
 158:../drivers/fsl_spi.c **** void SPI_SetDummyData(SPI_Type *base, uint8_t dummyData)
 159:../drivers/fsl_spi.c **** {
 160:../drivers/fsl_spi.c ****     uint32_t instance = SPI_GetInstance(base);
 161:../drivers/fsl_spi.c ****     s_dummyData[instance] = dummyData;
 162:../drivers/fsl_spi.c **** }
 163:../drivers/fsl_spi.c **** 
 164:../drivers/fsl_spi.c **** static void SPI_WriteNonBlocking(SPI_Type *base, uint8_t *buffer, size_t size)
 165:../drivers/fsl_spi.c **** {
 166:../drivers/fsl_spi.c ****     uint32_t i = 0;
 167:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 168:../drivers/fsl_spi.c ****     uint32_t instance = SPI_GetInstance(base);
 169:../drivers/fsl_spi.c **** 
 170:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 171:../drivers/fsl_spi.c ****     /* Check if 16 bits or 8 bits */
 172:../drivers/fsl_spi.c ****     bytesPerFrame = ((base->C2 & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT) + 1U;
 173:../drivers/fsl_spi.c **** #endif
 174:../drivers/fsl_spi.c **** 
 175:../drivers/fsl_spi.c ****     while (i < size)
 176:../drivers/fsl_spi.c ****     {
 177:../drivers/fsl_spi.c ****         if (buffer != NULL)
 178:../drivers/fsl_spi.c ****         {
 179:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 180:../drivers/fsl_spi.c ****             /*16 bit mode*/
 181:../drivers/fsl_spi.c ****             if (base->C2 & SPI_C2_SPIMODE_MASK)
 182:../drivers/fsl_spi.c ****             {
 183:../drivers/fsl_spi.c ****                 base->DL = *buffer++;
 184:../drivers/fsl_spi.c ****                 base->DH = *buffer++;
 185:../drivers/fsl_spi.c ****             }
 186:../drivers/fsl_spi.c ****             /* 8 bit mode */
 187:../drivers/fsl_spi.c ****             else
 188:../drivers/fsl_spi.c ****             {
 189:../drivers/fsl_spi.c ****                 base->DL = *buffer++;
 190:../drivers/fsl_spi.c ****             }
 191:../drivers/fsl_spi.c **** #else
 192:../drivers/fsl_spi.c ****             base->D = *buffer++;
 193:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 194:../drivers/fsl_spi.c ****         }
 195:../drivers/fsl_spi.c ****         /* Send dummy data */
 196:../drivers/fsl_spi.c ****         else
 197:../drivers/fsl_spi.c ****         {
 198:../drivers/fsl_spi.c ****             SPI_WriteData(base, ((uint32_t)s_dummyData[instance] << 8 | s_dummyData[instance]));
 199:../drivers/fsl_spi.c ****         }
 200:../drivers/fsl_spi.c ****         i += bytesPerFrame;
 201:../drivers/fsl_spi.c ****     }
 202:../drivers/fsl_spi.c **** }
 203:../drivers/fsl_spi.c **** 
 204:../drivers/fsl_spi.c **** static void SPI_ReadNonBlocking(SPI_Type *base, uint8_t *buffer, size_t size)
 205:../drivers/fsl_spi.c **** {
 206:../drivers/fsl_spi.c ****     uint32_t i = 0;
 207:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 208:../drivers/fsl_spi.c **** 
 209:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 210:../drivers/fsl_spi.c ****     /* Check if 16 bits or 8 bits */
 211:../drivers/fsl_spi.c ****     bytesPerFrame = ((base->C2 & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT) + 1U;
 212:../drivers/fsl_spi.c **** #endif
 213:../drivers/fsl_spi.c **** 
 214:../drivers/fsl_spi.c ****     while (i < size)
 215:../drivers/fsl_spi.c ****     {
 216:../drivers/fsl_spi.c ****         if (buffer != NULL)
 217:../drivers/fsl_spi.c ****         {
 218:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 219:../drivers/fsl_spi.c ****             /*16 bit mode*/
 220:../drivers/fsl_spi.c ****             if (base->C2 & SPI_C2_SPIMODE_MASK)
 221:../drivers/fsl_spi.c ****             {
 222:../drivers/fsl_spi.c ****                 *buffer++ = base->DL;
 223:../drivers/fsl_spi.c ****                 *buffer++ = base->DH;
 224:../drivers/fsl_spi.c ****             }
 225:../drivers/fsl_spi.c ****             /* 8 bit mode */
 226:../drivers/fsl_spi.c ****             else
 227:../drivers/fsl_spi.c ****             {
 228:../drivers/fsl_spi.c ****                 *buffer++ = base->DL;
 229:../drivers/fsl_spi.c ****             }
 230:../drivers/fsl_spi.c **** #else
 231:../drivers/fsl_spi.c ****             *buffer++ = base->D;
 232:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 233:../drivers/fsl_spi.c ****         }
 234:../drivers/fsl_spi.c ****         else
 235:../drivers/fsl_spi.c ****         {
 236:../drivers/fsl_spi.c ****             SPI_ReadData(base);
 237:../drivers/fsl_spi.c ****         }
 238:../drivers/fsl_spi.c ****         i += bytesPerFrame;
 239:../drivers/fsl_spi.c ****     }
 240:../drivers/fsl_spi.c **** }
 241:../drivers/fsl_spi.c **** 
 242:../drivers/fsl_spi.c **** /* Get the watermark value of transfer. Please note that the entery width of FIFO is 16 bits. */
 243:../drivers/fsl_spi.c **** static uint8_t SPI_GetWatermark(SPI_Type *base)
 244:../drivers/fsl_spi.c **** {
  25              		.loc 1 244 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
 245:../drivers/fsl_spi.c ****     uint8_t ret = 0;
 246:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 247:../drivers/fsl_spi.c ****     uint8_t rxSize = 0U;
 248:../drivers/fsl_spi.c ****     /* Get the number to be sent if there is FIFO */
 249:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
  31              		.loc 1 249 0
  32 0000 0A4B     		ldr	r3, .L9
  33 0002 9842     		cmp	r0, r3
  34 0004 10D0     		beq	.L4
 250:../drivers/fsl_spi.c ****     {
 251:../drivers/fsl_spi.c ****         rxSize = (base->C3 & SPI_C3_RNFULLF_MARK_MASK) >> SPI_C3_RNFULLF_MARK_SHIFT;
  35              		.loc 1 251 0
  36 0006 C37A     		ldrb	r3, [r0, #11]
  37              	.LVL1:
 252:../drivers/fsl_spi.c ****         if (rxSize == 0U)
  38              		.loc 1 252 0
  39 0008 DB06     		lsls	r3, r3, #27
  40 000a 06D4     		bmi	.L3
  41              	.LVL2:
 253:../drivers/fsl_spi.c ****         {
 254:../drivers/fsl_spi.c ****             ret = FSL_FEATURE_SPI_FIFO_SIZEn(base) * 3U / 4U;
  42              		.loc 1 254 0 discriminator 1
  43 000c 084B     		ldr	r3, .L9+4
  44 000e 9842     		cmp	r0, r3
  45 0010 01D0     		beq	.L7
  46              		.loc 1 254 0 is_stmt 0
  47 0012 FF20     		movs	r0, #255
  48              	.LVL3:
  49 0014 09E0     		b	.L2
  50              	.LVL4:
  51              	.L7:
  52 0016 0320     		movs	r0, #3
  53              	.LVL5:
  54 0018 07E0     		b	.L2
  55              	.LVL6:
  56              	.L3:
 255:../drivers/fsl_spi.c ****         }
 256:../drivers/fsl_spi.c ****         else
 257:../drivers/fsl_spi.c ****         {
 258:../drivers/fsl_spi.c ****             ret = FSL_FEATURE_SPI_FIFO_SIZEn(base) / 2U;
  57              		.loc 1 258 0 is_stmt 1 discriminator 1
  58 001a 054B     		ldr	r3, .L9+4
  59 001c 9842     		cmp	r0, r3
  60 001e 01D0     		beq	.L8
  61              		.loc 1 258 0 is_stmt 0
  62 0020 FF20     		movs	r0, #255
  63              	.LVL7:
  64 0022 02E0     		b	.L2
  65              	.LVL8:
  66              	.L8:
  67 0024 0220     		movs	r0, #2
  68              	.LVL9:
  69 0026 00E0     		b	.L2
  70              	.LVL10:
  71              	.L4:
 259:../drivers/fsl_spi.c ****         }
 260:../drivers/fsl_spi.c ****     }
 261:../drivers/fsl_spi.c ****     /* If no FIFO, just set the watermark to 1 */
 262:../drivers/fsl_spi.c ****     else
 263:../drivers/fsl_spi.c ****     {
 264:../drivers/fsl_spi.c ****         ret = 1U;
  72              		.loc 1 264 0 is_stmt 1
  73 0028 0120     		movs	r0, #1
  74              	.LVL11:
  75              	.L2:
 265:../drivers/fsl_spi.c ****     }
 266:../drivers/fsl_spi.c **** #else
 267:../drivers/fsl_spi.c ****     ret = 1U;
 268:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 269:../drivers/fsl_spi.c ****     return ret;
 270:../drivers/fsl_spi.c **** }
  76              		.loc 1 270 0
  77              		@ sp needed
  78 002a 7047     		bx	lr
  79              	.L10:
  80              		.align	2
  81              	.L9:
  82 002c 00600740 		.word	1074225152
  83 0030 00700740 		.word	1074229248
  84              		.cfi_endproc
  85              	.LFE66:
  87              		.section	.text.SPI_CommonIRQHandler,"ax",%progbits
  88              		.align	1
  89              		.syntax unified
  90              		.code	16
  91              		.thumb_func
  92              		.fpu softvfp
  94              	SPI_CommonIRQHandler:
  95              	.LFB91:
 271:../drivers/fsl_spi.c **** 
 272:../drivers/fsl_spi.c **** static void SPI_SendInitialTransfer(SPI_Type *base, spi_master_handle_t *handle)
 273:../drivers/fsl_spi.c **** {
 274:../drivers/fsl_spi.c ****     uint8_t bytestoTransfer = handle->bytePerFrame;
 275:../drivers/fsl_spi.c **** 
 276:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && (FSL_FEATURE_SPI_HAS_FIFO)
 277:../drivers/fsl_spi.c ****     if (handle->watermark > 1)
 278:../drivers/fsl_spi.c ****     {
 279:../drivers/fsl_spi.c ****         /* In the first time to send data to FIFO, if transfer size is not larger than
 280:../drivers/fsl_spi.c ****          * the FIFO size, send all data to FIFO, or send data to make the FIFO full.
 281:../drivers/fsl_spi.c ****          * Besides, The FIFO's entry width is 16 bits, need to translate it to bytes.
 282:../drivers/fsl_spi.c ****          */
 283:../drivers/fsl_spi.c ****         bytestoTransfer = MIN(handle->txRemainingBytes, (FSL_FEATURE_SPI_FIFO_SIZEn(base) * 2));
 284:../drivers/fsl_spi.c ****     }
 285:../drivers/fsl_spi.c **** #endif
 286:../drivers/fsl_spi.c **** 
 287:../drivers/fsl_spi.c ****     SPI_WriteNonBlocking(base, handle->txData, bytestoTransfer);
 288:../drivers/fsl_spi.c **** 
 289:../drivers/fsl_spi.c ****     /* Update handle information */
 290:../drivers/fsl_spi.c ****     if (handle->txData)
 291:../drivers/fsl_spi.c ****     {
 292:../drivers/fsl_spi.c ****         handle->txData += bytestoTransfer;
 293:../drivers/fsl_spi.c ****     }
 294:../drivers/fsl_spi.c ****     handle->txRemainingBytes -= bytestoTransfer;
 295:../drivers/fsl_spi.c **** }
 296:../drivers/fsl_spi.c **** 
 297:../drivers/fsl_spi.c **** static void SPI_SendTransfer(SPI_Type *base, spi_master_handle_t *handle)
 298:../drivers/fsl_spi.c **** {
 299:../drivers/fsl_spi.c ****     uint8_t bytes = handle->bytePerFrame;
 300:../drivers/fsl_spi.c **** 
 301:../drivers/fsl_spi.c ****     /* Read S register and ensure SPTEF is 1, otherwise the write would be ignored. */
 302:../drivers/fsl_spi.c ****     if (handle->watermark == 1U)
 303:../drivers/fsl_spi.c ****     {
 304:../drivers/fsl_spi.c ****         /* Send data */
 305:../drivers/fsl_spi.c ****         if (base->C1 & SPI_C1_MSTR_MASK)
 306:../drivers/fsl_spi.c ****         {
 307:../drivers/fsl_spi.c ****             /* As a master, only write once */
 308:../drivers/fsl_spi.c ****             if (base->S & SPI_S_SPTEF_MASK)
 309:../drivers/fsl_spi.c ****             {
 310:../drivers/fsl_spi.c ****                 SPI_WriteNonBlocking(base, handle->txData, bytes);
 311:../drivers/fsl_spi.c ****                 /* Update handle information */
 312:../drivers/fsl_spi.c ****                 if (handle->txData)
 313:../drivers/fsl_spi.c ****                 {
 314:../drivers/fsl_spi.c ****                     handle->txData += bytes;
 315:../drivers/fsl_spi.c ****                 }
 316:../drivers/fsl_spi.c ****                 handle->txRemainingBytes -= bytes;
 317:../drivers/fsl_spi.c ****             }
 318:../drivers/fsl_spi.c ****         }
 319:../drivers/fsl_spi.c ****         else
 320:../drivers/fsl_spi.c ****         {
 321:../drivers/fsl_spi.c ****             /* As a slave, send data until SPTEF cleared */
 322:../drivers/fsl_spi.c ****             while ((base->S & SPI_S_SPTEF_MASK) && (handle->txRemainingBytes >= bytes))
 323:../drivers/fsl_spi.c ****             {
 324:../drivers/fsl_spi.c ****                 SPI_WriteNonBlocking(base, handle->txData, bytes);
 325:../drivers/fsl_spi.c **** 
 326:../drivers/fsl_spi.c ****                 /* Update handle information */
 327:../drivers/fsl_spi.c ****                 if (handle->txData)
 328:../drivers/fsl_spi.c ****                 {
 329:../drivers/fsl_spi.c ****                     handle->txData += bytes;
 330:../drivers/fsl_spi.c ****                 }
 331:../drivers/fsl_spi.c ****                 handle->txRemainingBytes -= bytes;
 332:../drivers/fsl_spi.c ****             }
 333:../drivers/fsl_spi.c ****         }
 334:../drivers/fsl_spi.c ****     }
 335:../drivers/fsl_spi.c **** 
 336:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && (FSL_FEATURE_SPI_HAS_FIFO)
 337:../drivers/fsl_spi.c ****     /* If use FIFO */
 338:../drivers/fsl_spi.c ****     else
 339:../drivers/fsl_spi.c ****     {
 340:../drivers/fsl_spi.c ****         /* The FIFO's entry width is 16 bits, need to translate it to bytes. */
 341:../drivers/fsl_spi.c ****         uint8_t bytestoTransfer = handle->watermark * 2;
 342:../drivers/fsl_spi.c **** 
 343:../drivers/fsl_spi.c ****         if (handle->txRemainingBytes < 8U)
 344:../drivers/fsl_spi.c ****         {
 345:../drivers/fsl_spi.c ****             bytestoTransfer = handle->txRemainingBytes;
 346:../drivers/fsl_spi.c ****         }
 347:../drivers/fsl_spi.c **** 
 348:../drivers/fsl_spi.c ****         SPI_WriteNonBlocking(base, handle->txData, bytestoTransfer);
 349:../drivers/fsl_spi.c **** 
 350:../drivers/fsl_spi.c ****         /* Update handle information */
 351:../drivers/fsl_spi.c ****         if (handle->txData)
 352:../drivers/fsl_spi.c ****         {
 353:../drivers/fsl_spi.c ****             handle->txData += bytestoTransfer;
 354:../drivers/fsl_spi.c ****         }
 355:../drivers/fsl_spi.c ****         handle->txRemainingBytes -= bytestoTransfer;
 356:../drivers/fsl_spi.c ****     }
 357:../drivers/fsl_spi.c **** #endif
 358:../drivers/fsl_spi.c **** }
 359:../drivers/fsl_spi.c **** 
 360:../drivers/fsl_spi.c **** static void SPI_ReceiveTransfer(SPI_Type *base, spi_master_handle_t *handle)
 361:../drivers/fsl_spi.c **** {
 362:../drivers/fsl_spi.c ****     uint8_t bytes = handle->bytePerFrame;
 363:../drivers/fsl_spi.c **** 
 364:../drivers/fsl_spi.c ****     /* Read S register and ensure SPRF is 1, otherwise the write would be ignored. */
 365:../drivers/fsl_spi.c ****     if (handle->watermark == 1U)
 366:../drivers/fsl_spi.c ****     {
 367:../drivers/fsl_spi.c ****         if (base->S & SPI_S_SPRF_MASK)
 368:../drivers/fsl_spi.c ****         {
 369:../drivers/fsl_spi.c ****             SPI_ReadNonBlocking(base, handle->rxData, bytes);
 370:../drivers/fsl_spi.c **** 
 371:../drivers/fsl_spi.c ****             /* Update information in handle */
 372:../drivers/fsl_spi.c ****             if (handle->rxData)
 373:../drivers/fsl_spi.c ****             {
 374:../drivers/fsl_spi.c ****                 handle->rxData += bytes;
 375:../drivers/fsl_spi.c ****             }
 376:../drivers/fsl_spi.c ****             handle->rxRemainingBytes -= bytes;
 377:../drivers/fsl_spi.c ****         }
 378:../drivers/fsl_spi.c ****     }
 379:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && (FSL_FEATURE_SPI_HAS_FIFO)
 380:../drivers/fsl_spi.c ****     /* If use FIFO */
 381:../drivers/fsl_spi.c ****     else
 382:../drivers/fsl_spi.c ****     {
 383:../drivers/fsl_spi.c ****         /* While rx fifo not empty and remaining data can also trigger the last interrupt */
 384:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_RFIFOEF_MASK) == 0U)
 385:../drivers/fsl_spi.c ****         {
 386:../drivers/fsl_spi.c ****             SPI_ReadNonBlocking(base, handle->rxData, bytes);
 387:../drivers/fsl_spi.c **** 
 388:../drivers/fsl_spi.c ****             /* Update information in handle */
 389:../drivers/fsl_spi.c ****             if (handle->rxData)
 390:../drivers/fsl_spi.c ****             {
 391:../drivers/fsl_spi.c ****                 handle->rxData += bytes;
 392:../drivers/fsl_spi.c ****             }
 393:../drivers/fsl_spi.c ****             handle->rxRemainingBytes -= bytes;
 394:../drivers/fsl_spi.c **** 
 395:../drivers/fsl_spi.c ****             /* If the reamining data equals to watermark, leave to last interrupt */
 396:../drivers/fsl_spi.c ****             if (handle->rxRemainingBytes == (handle->watermark * 2U))
 397:../drivers/fsl_spi.c ****             {
 398:../drivers/fsl_spi.c ****                 break;
 399:../drivers/fsl_spi.c ****             }
 400:../drivers/fsl_spi.c ****         }
 401:../drivers/fsl_spi.c ****     }
 402:../drivers/fsl_spi.c **** #endif
 403:../drivers/fsl_spi.c **** }
 404:../drivers/fsl_spi.c **** 
 405:../drivers/fsl_spi.c **** void SPI_MasterGetDefaultConfig(spi_master_config_t *config)
 406:../drivers/fsl_spi.c **** {
 407:../drivers/fsl_spi.c ****     config->enableMaster = true;
 408:../drivers/fsl_spi.c ****     config->enableStopInWaitMode = false;
 409:../drivers/fsl_spi.c ****     config->polarity = kSPI_ClockPolarityActiveHigh;
 410:../drivers/fsl_spi.c ****     config->phase = kSPI_ClockPhaseFirstEdge;
 411:../drivers/fsl_spi.c ****     config->direction = kSPI_MsbFirst;
 412:../drivers/fsl_spi.c **** 
 413:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 414:../drivers/fsl_spi.c ****     config->dataMode = kSPI_8BitMode;
 415:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 416:../drivers/fsl_spi.c **** 
 417:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 418:../drivers/fsl_spi.c ****     config->txWatermark = kSPI_TxFifoOneHalfEmpty;
 419:../drivers/fsl_spi.c ****     config->rxWatermark = kSPI_RxFifoOneHalfFull;
 420:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 421:../drivers/fsl_spi.c **** 
 422:../drivers/fsl_spi.c ****     config->pinMode = kSPI_PinModeNormal;
 423:../drivers/fsl_spi.c ****     config->outputMode = kSPI_SlaveSelectAutomaticOutput;
 424:../drivers/fsl_spi.c ****     config->baudRate_Bps = 500000U;
 425:../drivers/fsl_spi.c **** }
 426:../drivers/fsl_spi.c **** 
 427:../drivers/fsl_spi.c **** void SPI_MasterInit(SPI_Type *base, const spi_master_config_t *config, uint32_t srcClock_Hz)
 428:../drivers/fsl_spi.c **** {
 429:../drivers/fsl_spi.c ****     assert(config && srcClock_Hz);
 430:../drivers/fsl_spi.c **** 
 431:../drivers/fsl_spi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 432:../drivers/fsl_spi.c ****     /* Open clock gate for SPI and open interrupt */
 433:../drivers/fsl_spi.c ****     CLOCK_EnableClock(s_spiClock[SPI_GetInstance(base)]);
 434:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 435:../drivers/fsl_spi.c **** 
 436:../drivers/fsl_spi.c ****     /* Disable SPI before configuration */
 437:../drivers/fsl_spi.c ****     base->C1 &= ~SPI_C1_SPE_MASK;
 438:../drivers/fsl_spi.c **** 
 439:../drivers/fsl_spi.c ****     /* Configure clock polarity and phase, set SPI to master */
 440:../drivers/fsl_spi.c ****     base->C1 = SPI_C1_MSTR(1U) | SPI_C1_CPOL(config->polarity) | SPI_C1_CPHA(config->phase) |
 441:../drivers/fsl_spi.c ****                SPI_C1_SSOE(config->outputMode & 1U) | SPI_C1_LSBFE(config->direction);
 442:../drivers/fsl_spi.c **** 
 443:../drivers/fsl_spi.c **** /* Set data mode, and also pin mode and mode fault settings */
 444:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 445:../drivers/fsl_spi.c ****     base->C2 = SPI_C2_MODFEN(config->outputMode >> 1U) | SPI_C2_BIDIROE(config->pinMode >> 1U) |
 446:../drivers/fsl_spi.c ****                SPI_C2_SPISWAI(config->enableStopInWaitMode) | SPI_C2_SPC0(config->pinMode & 1U) |
 447:../drivers/fsl_spi.c ****                SPI_C2_SPIMODE(config->dataMode);
 448:../drivers/fsl_spi.c **** #else
 449:../drivers/fsl_spi.c ****     base->C2 = SPI_C2_MODFEN(config->outputMode >> 1U) | SPI_C2_BIDIROE(config->pinMode >> 1U) |
 450:../drivers/fsl_spi.c ****                SPI_C2_SPISWAI(config->enableStopInWaitMode) | SPI_C2_SPC0(config->pinMode & 1U);
 451:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 452:../drivers/fsl_spi.c **** 
 453:../drivers/fsl_spi.c **** /* Set watermark, FIFO is enabled */
 454:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 455:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
 456:../drivers/fsl_spi.c ****     {
 457:../drivers/fsl_spi.c ****         base->C3 = SPI_C3_TNEAREF_MARK(config->txWatermark) | SPI_C3_RNFULLF_MARK(config->rxWaterma
 458:../drivers/fsl_spi.c ****                    SPI_C3_INTCLR(0U) | SPI_C3_FIFOMODE(1U);
 459:../drivers/fsl_spi.c ****     }
 460:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 461:../drivers/fsl_spi.c **** 
 462:../drivers/fsl_spi.c ****     /* Set baud rate */
 463:../drivers/fsl_spi.c ****     SPI_MasterSetBaudRate(base, config->baudRate_Bps, srcClock_Hz);
 464:../drivers/fsl_spi.c **** 
 465:../drivers/fsl_spi.c ****     /* Set the dummy data, this data will usefull when tx buffer is NULL. */
 466:../drivers/fsl_spi.c ****     SPI_SetDummyData(base, SPI_DUMMYDATA);
 467:../drivers/fsl_spi.c **** 
 468:../drivers/fsl_spi.c ****     /* Enable SPI */
 469:../drivers/fsl_spi.c ****     if (config->enableMaster)
 470:../drivers/fsl_spi.c ****     {
 471:../drivers/fsl_spi.c ****         base->C1 |= SPI_C1_SPE_MASK;
 472:../drivers/fsl_spi.c ****     }
 473:../drivers/fsl_spi.c **** }
 474:../drivers/fsl_spi.c **** 
 475:../drivers/fsl_spi.c **** void SPI_SlaveGetDefaultConfig(spi_slave_config_t *config)
 476:../drivers/fsl_spi.c **** {
 477:../drivers/fsl_spi.c ****     config->enableSlave = true;
 478:../drivers/fsl_spi.c ****     config->polarity = kSPI_ClockPolarityActiveHigh;
 479:../drivers/fsl_spi.c ****     config->phase = kSPI_ClockPhaseFirstEdge;
 480:../drivers/fsl_spi.c ****     config->direction = kSPI_MsbFirst;
 481:../drivers/fsl_spi.c ****     config->enableStopInWaitMode = false;
 482:../drivers/fsl_spi.c **** 
 483:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 484:../drivers/fsl_spi.c ****     config->dataMode = kSPI_8BitMode;
 485:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 486:../drivers/fsl_spi.c **** 
 487:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 488:../drivers/fsl_spi.c ****     config->txWatermark = kSPI_TxFifoOneHalfEmpty;
 489:../drivers/fsl_spi.c ****     config->rxWatermark = kSPI_RxFifoOneHalfFull;
 490:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 491:../drivers/fsl_spi.c ****     config->pinMode = kSPI_PinModeNormal;
 492:../drivers/fsl_spi.c **** }
 493:../drivers/fsl_spi.c **** 
 494:../drivers/fsl_spi.c **** void SPI_SlaveInit(SPI_Type *base, const spi_slave_config_t *config)
 495:../drivers/fsl_spi.c **** {
 496:../drivers/fsl_spi.c ****     assert(config);
 497:../drivers/fsl_spi.c **** 
 498:../drivers/fsl_spi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 499:../drivers/fsl_spi.c ****     /* Open clock gate for SPI and open interrupt */
 500:../drivers/fsl_spi.c ****     CLOCK_EnableClock(s_spiClock[SPI_GetInstance(base)]);
 501:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 502:../drivers/fsl_spi.c **** 
 503:../drivers/fsl_spi.c ****     /* Disable SPI before configuration */
 504:../drivers/fsl_spi.c ****     base->C1 &= ~SPI_C1_SPE_MASK;
 505:../drivers/fsl_spi.c **** 
 506:../drivers/fsl_spi.c ****     /* Configure master and clock polarity and phase */
 507:../drivers/fsl_spi.c ****     base->C1 =
 508:../drivers/fsl_spi.c ****         SPI_C1_MSTR(0U) | SPI_C1_CPOL(config->polarity) | SPI_C1_CPHA(config->phase) | SPI_C1_LSBFE
 509:../drivers/fsl_spi.c **** 
 510:../drivers/fsl_spi.c **** /* Configure data mode if needed */
 511:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 512:../drivers/fsl_spi.c ****     base->C2 = SPI_C2_SPIMODE(config->dataMode) | SPI_C2_SPISWAI(config->enableStopInWaitMode) |
 513:../drivers/fsl_spi.c ****                SPI_C2_BIDIROE(config->pinMode >> 1U) | SPI_C2_SPC0(config->pinMode & 1U);
 514:../drivers/fsl_spi.c **** #else
 515:../drivers/fsl_spi.c ****     base->C2 = SPI_C2_SPISWAI(config->enableStopInWaitMode) | SPI_C2_BIDIROE(config->pinMode >> 1U)
 516:../drivers/fsl_spi.c ****                SPI_C2_SPC0(config->pinMode & 1U);
 517:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 518:../drivers/fsl_spi.c **** 
 519:../drivers/fsl_spi.c **** /* Set watermark */
 520:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 521:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0U)
 522:../drivers/fsl_spi.c ****     {
 523:../drivers/fsl_spi.c ****         base->C3 = SPI_C3_TNEAREF_MARK(config->txWatermark) | SPI_C3_RNFULLF_MARK(config->rxWaterma
 524:../drivers/fsl_spi.c ****                    SPI_C3_INTCLR(0U) | SPI_C3_FIFOMODE(1U);
 525:../drivers/fsl_spi.c ****     }
 526:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 527:../drivers/fsl_spi.c **** 
 528:../drivers/fsl_spi.c ****     /* Set the dummy data, this data will usefull when tx buffer is NULL. */
 529:../drivers/fsl_spi.c ****     SPI_SetDummyData(base, SPI_DUMMYDATA);
 530:../drivers/fsl_spi.c **** 
 531:../drivers/fsl_spi.c ****     /* Enable SPI */
 532:../drivers/fsl_spi.c ****     if (config->enableSlave)
 533:../drivers/fsl_spi.c ****     {
 534:../drivers/fsl_spi.c ****         base->C1 |= SPI_C1_SPE_MASK;
 535:../drivers/fsl_spi.c ****     }
 536:../drivers/fsl_spi.c **** }
 537:../drivers/fsl_spi.c **** 
 538:../drivers/fsl_spi.c **** void SPI_Deinit(SPI_Type *base)
 539:../drivers/fsl_spi.c **** {
 540:../drivers/fsl_spi.c ****     /* Disable SPI module before shutting down */
 541:../drivers/fsl_spi.c ****     base->C1 &= ~SPI_C1_SPE_MASK;
 542:../drivers/fsl_spi.c **** 
 543:../drivers/fsl_spi.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 544:../drivers/fsl_spi.c ****     /* Gate the clock */
 545:../drivers/fsl_spi.c ****     CLOCK_DisableClock(s_spiClock[SPI_GetInstance(base)]);
 546:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 547:../drivers/fsl_spi.c **** }
 548:../drivers/fsl_spi.c **** 
 549:../drivers/fsl_spi.c **** uint32_t SPI_GetStatusFlags(SPI_Type *base)
 550:../drivers/fsl_spi.c **** {
 551:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 552:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
 553:../drivers/fsl_spi.c ****     {
 554:../drivers/fsl_spi.c ****         return ((base->S) | (((uint32_t)base->CI) << 8U));
 555:../drivers/fsl_spi.c ****     }
 556:../drivers/fsl_spi.c ****     else
 557:../drivers/fsl_spi.c ****     {
 558:../drivers/fsl_spi.c ****         return (base->S);
 559:../drivers/fsl_spi.c ****     }
 560:../drivers/fsl_spi.c **** #else
 561:../drivers/fsl_spi.c ****     return (base->S);
 562:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 563:../drivers/fsl_spi.c **** }
 564:../drivers/fsl_spi.c **** 
 565:../drivers/fsl_spi.c **** void SPI_EnableInterrupts(SPI_Type *base, uint32_t mask)
 566:../drivers/fsl_spi.c **** {
 567:../drivers/fsl_spi.c ****     /* Rx full interrupt */
 568:../drivers/fsl_spi.c ****     if (mask & kSPI_RxFullAndModfInterruptEnable)
 569:../drivers/fsl_spi.c ****     {
 570:../drivers/fsl_spi.c ****         base->C1 |= SPI_C1_SPIE_MASK;
 571:../drivers/fsl_spi.c ****     }
 572:../drivers/fsl_spi.c **** 
 573:../drivers/fsl_spi.c ****     /* Tx empty interrupt */
 574:../drivers/fsl_spi.c ****     if (mask & kSPI_TxEmptyInterruptEnable)
 575:../drivers/fsl_spi.c ****     {
 576:../drivers/fsl_spi.c ****         base->C1 |= SPI_C1_SPTIE_MASK;
 577:../drivers/fsl_spi.c ****     }
 578:../drivers/fsl_spi.c **** 
 579:../drivers/fsl_spi.c ****     /* Data match interrupt */
 580:../drivers/fsl_spi.c ****     if (mask & kSPI_MatchInterruptEnable)
 581:../drivers/fsl_spi.c ****     {
 582:../drivers/fsl_spi.c ****         base->C2 |= SPI_C2_SPMIE_MASK;
 583:../drivers/fsl_spi.c ****     }
 584:../drivers/fsl_spi.c **** 
 585:../drivers/fsl_spi.c **** /* FIFO related interrupts */
 586:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 587:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
 588:../drivers/fsl_spi.c ****     {
 589:../drivers/fsl_spi.c ****         /* Rx FIFO near full interrupt */
 590:../drivers/fsl_spi.c ****         if (mask & kSPI_RxFifoNearFullInterruptEnable)
 591:../drivers/fsl_spi.c ****         {
 592:../drivers/fsl_spi.c ****             base->C3 |= SPI_C3_RNFULLIEN_MASK;
 593:../drivers/fsl_spi.c ****         }
 594:../drivers/fsl_spi.c **** 
 595:../drivers/fsl_spi.c ****         /* Tx FIFO near empty interrupt */
 596:../drivers/fsl_spi.c ****         if (mask & kSPI_TxFifoNearEmptyInterruptEnable)
 597:../drivers/fsl_spi.c ****         {
 598:../drivers/fsl_spi.c ****             base->C3 |= SPI_C3_TNEARIEN_MASK;
 599:../drivers/fsl_spi.c ****         }
 600:../drivers/fsl_spi.c ****     }
 601:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 602:../drivers/fsl_spi.c **** }
 603:../drivers/fsl_spi.c **** 
 604:../drivers/fsl_spi.c **** void SPI_DisableInterrupts(SPI_Type *base, uint32_t mask)
 605:../drivers/fsl_spi.c **** {
 606:../drivers/fsl_spi.c ****     /* Rx full interrupt */
 607:../drivers/fsl_spi.c ****     if (mask & kSPI_RxFullAndModfInterruptEnable)
 608:../drivers/fsl_spi.c ****     {
 609:../drivers/fsl_spi.c ****         base->C1 &= (~SPI_C1_SPIE_MASK);
 610:../drivers/fsl_spi.c ****     }
 611:../drivers/fsl_spi.c **** 
 612:../drivers/fsl_spi.c ****     /* Tx empty interrupt */
 613:../drivers/fsl_spi.c ****     if (mask & kSPI_TxEmptyInterruptEnable)
 614:../drivers/fsl_spi.c ****     {
 615:../drivers/fsl_spi.c ****         base->C1 &= (~SPI_C1_SPTIE_MASK);
 616:../drivers/fsl_spi.c ****     }
 617:../drivers/fsl_spi.c **** 
 618:../drivers/fsl_spi.c ****     /* Data match interrupt */
 619:../drivers/fsl_spi.c ****     if (mask & kSPI_MatchInterruptEnable)
 620:../drivers/fsl_spi.c ****     {
 621:../drivers/fsl_spi.c ****         base->C2 &= (~SPI_C2_SPMIE_MASK);
 622:../drivers/fsl_spi.c ****     }
 623:../drivers/fsl_spi.c **** 
 624:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 625:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
 626:../drivers/fsl_spi.c ****     {
 627:../drivers/fsl_spi.c ****         /* Rx FIFO near full interrupt */
 628:../drivers/fsl_spi.c ****         if (mask & kSPI_RxFifoNearFullInterruptEnable)
 629:../drivers/fsl_spi.c ****         {
 630:../drivers/fsl_spi.c ****             base->C3 &= ~SPI_C3_RNFULLIEN_MASK;
 631:../drivers/fsl_spi.c ****         }
 632:../drivers/fsl_spi.c **** 
 633:../drivers/fsl_spi.c ****         /* Tx FIFO near empty interrupt */
 634:../drivers/fsl_spi.c ****         if (mask & kSPI_TxFifoNearEmptyInterruptEnable)
 635:../drivers/fsl_spi.c ****         {
 636:../drivers/fsl_spi.c ****             base->C3 &= ~SPI_C3_TNEARIEN_MASK;
 637:../drivers/fsl_spi.c ****         }
 638:../drivers/fsl_spi.c ****     }
 639:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 640:../drivers/fsl_spi.c **** }
 641:../drivers/fsl_spi.c **** 
 642:../drivers/fsl_spi.c **** void SPI_MasterSetBaudRate(SPI_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
 643:../drivers/fsl_spi.c **** {
 644:../drivers/fsl_spi.c ****     uint32_t prescaler;
 645:../drivers/fsl_spi.c ****     uint32_t bestPrescaler;
 646:../drivers/fsl_spi.c ****     uint32_t rateDivisor;
 647:../drivers/fsl_spi.c ****     uint32_t bestDivisor;
 648:../drivers/fsl_spi.c ****     uint32_t rateDivisorValue;
 649:../drivers/fsl_spi.c ****     uint32_t realBaudrate;
 650:../drivers/fsl_spi.c ****     uint32_t diff;
 651:../drivers/fsl_spi.c ****     uint32_t min_diff;
 652:../drivers/fsl_spi.c ****     uint32_t freq = baudRate_Bps;
 653:../drivers/fsl_spi.c **** 
 654:../drivers/fsl_spi.c ****     /* Find combination of prescaler and scaler resulting in baudrate closest to the requested valu
 655:../drivers/fsl_spi.c ****     min_diff = 0xFFFFFFFFU;
 656:../drivers/fsl_spi.c **** 
 657:../drivers/fsl_spi.c ****     /* Set the maximum divisor bit settings for each of the following divisors */
 658:../drivers/fsl_spi.c ****     bestPrescaler = 7U;
 659:../drivers/fsl_spi.c ****     bestDivisor = 8U;
 660:../drivers/fsl_spi.c **** 
 661:../drivers/fsl_spi.c ****     /* In all for loops, if min_diff = 0, the exit for loop*/
 662:../drivers/fsl_spi.c ****     for (prescaler = 0; (prescaler <= 7) && min_diff; prescaler++)
 663:../drivers/fsl_spi.c ****     {
 664:../drivers/fsl_spi.c ****         /* Initialize to div-by-2 */
 665:../drivers/fsl_spi.c ****         rateDivisorValue = 2U;
 666:../drivers/fsl_spi.c **** 
 667:../drivers/fsl_spi.c ****         for (rateDivisor = 0; (rateDivisor <= 8U) && min_diff; rateDivisor++)
 668:../drivers/fsl_spi.c ****         {
 669:../drivers/fsl_spi.c ****             /* Calculate actual baud rate, note need to add 1 to prescaler */
 670:../drivers/fsl_spi.c ****             realBaudrate = ((srcClock_Hz) / ((prescaler + 1) * rateDivisorValue));
 671:../drivers/fsl_spi.c **** 
 672:../drivers/fsl_spi.c ****             /* Calculate the baud rate difference based on the conditional statement ,that states t
 673:../drivers/fsl_spi.c ****             calculated baud rate must not exceed the desired baud rate */
 674:../drivers/fsl_spi.c ****             if (freq >= realBaudrate)
 675:../drivers/fsl_spi.c ****             {
 676:../drivers/fsl_spi.c ****                 diff = freq - realBaudrate;
 677:../drivers/fsl_spi.c ****                 if (min_diff > diff)
 678:../drivers/fsl_spi.c ****                 {
 679:../drivers/fsl_spi.c ****                     /* A better match found */
 680:../drivers/fsl_spi.c ****                     min_diff = diff;
 681:../drivers/fsl_spi.c ****                     bestPrescaler = prescaler;
 682:../drivers/fsl_spi.c ****                     bestDivisor = rateDivisor;
 683:../drivers/fsl_spi.c ****                 }
 684:../drivers/fsl_spi.c ****             }
 685:../drivers/fsl_spi.c **** 
 686:../drivers/fsl_spi.c ****             /* Multiply by 2 for each iteration, possible divisor values: 2, 4, 8, 16, ... 512 */
 687:../drivers/fsl_spi.c ****             rateDivisorValue *= 2U;
 688:../drivers/fsl_spi.c ****         }
 689:../drivers/fsl_spi.c ****     }
 690:../drivers/fsl_spi.c **** 
 691:../drivers/fsl_spi.c ****     /* Write the best prescalar and baud rate scalar */
 692:../drivers/fsl_spi.c ****     base->BR = SPI_BR_SPR(bestDivisor) | SPI_BR_SPPR(bestPrescaler);
 693:../drivers/fsl_spi.c **** }
 694:../drivers/fsl_spi.c **** 
 695:../drivers/fsl_spi.c **** void SPI_WriteBlocking(SPI_Type *base, uint8_t *buffer, size_t size)
 696:../drivers/fsl_spi.c **** {
 697:../drivers/fsl_spi.c ****     uint32_t i = 0;
 698:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 699:../drivers/fsl_spi.c **** 
 700:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 701:../drivers/fsl_spi.c ****     /* Check if 16 bits or 8 bits */
 702:../drivers/fsl_spi.c ****     bytesPerFrame = ((base->C2 & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT) + 1U;
 703:../drivers/fsl_spi.c **** #endif
 704:../drivers/fsl_spi.c **** 
 705:../drivers/fsl_spi.c ****     while (i < size)
 706:../drivers/fsl_spi.c ****     {
 707:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_SPTEF_MASK) == 0)
 708:../drivers/fsl_spi.c ****         {
 709:../drivers/fsl_spi.c ****         }
 710:../drivers/fsl_spi.c **** 
 711:../drivers/fsl_spi.c ****         /* Send a frame of data */
 712:../drivers/fsl_spi.c ****         SPI_WriteNonBlocking(base, buffer, bytesPerFrame);
 713:../drivers/fsl_spi.c **** 
 714:../drivers/fsl_spi.c ****         i += bytesPerFrame;
 715:../drivers/fsl_spi.c ****         buffer += bytesPerFrame;
 716:../drivers/fsl_spi.c ****     }
 717:../drivers/fsl_spi.c **** }
 718:../drivers/fsl_spi.c **** 
 719:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 720:../drivers/fsl_spi.c **** void SPI_EnableFIFO(SPI_Type *base, bool enable)
 721:../drivers/fsl_spi.c **** {
 722:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0U)
 723:../drivers/fsl_spi.c ****     {
 724:../drivers/fsl_spi.c ****         if (enable)
 725:../drivers/fsl_spi.c ****         {
 726:../drivers/fsl_spi.c ****             base->C3 |= SPI_C3_FIFOMODE_MASK;
 727:../drivers/fsl_spi.c ****         }
 728:../drivers/fsl_spi.c ****         else
 729:../drivers/fsl_spi.c ****         {
 730:../drivers/fsl_spi.c ****             base->C3 &= ~SPI_C3_FIFOMODE_MASK;
 731:../drivers/fsl_spi.c ****         }
 732:../drivers/fsl_spi.c ****     }
 733:../drivers/fsl_spi.c **** }
 734:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 735:../drivers/fsl_spi.c **** 
 736:../drivers/fsl_spi.c **** void SPI_WriteData(SPI_Type *base, uint16_t data)
 737:../drivers/fsl_spi.c **** {
 738:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && (FSL_FEATURE_SPI_16BIT_TRANSFERS)
 739:../drivers/fsl_spi.c ****     base->DL = data & 0xFFU;
 740:../drivers/fsl_spi.c ****     base->DH = (data >> 8U) & 0xFFU;
 741:../drivers/fsl_spi.c **** #else
 742:../drivers/fsl_spi.c ****     base->D = data & 0xFFU;
 743:../drivers/fsl_spi.c **** #endif
 744:../drivers/fsl_spi.c **** }
 745:../drivers/fsl_spi.c **** 
 746:../drivers/fsl_spi.c **** uint16_t SPI_ReadData(SPI_Type *base)
 747:../drivers/fsl_spi.c **** {
 748:../drivers/fsl_spi.c ****     uint16_t val = 0;
 749:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && (FSL_FEATURE_SPI_16BIT_TRANSFERS)
 750:../drivers/fsl_spi.c ****     val = base->DL;
 751:../drivers/fsl_spi.c ****     val |= (uint16_t)((uint16_t)(base->DH) << 8U);
 752:../drivers/fsl_spi.c **** #else
 753:../drivers/fsl_spi.c ****     val = base->D;
 754:../drivers/fsl_spi.c **** #endif
 755:../drivers/fsl_spi.c ****     return val;
 756:../drivers/fsl_spi.c **** }
 757:../drivers/fsl_spi.c **** 
 758:../drivers/fsl_spi.c **** status_t SPI_MasterTransferBlocking(SPI_Type *base, spi_transfer_t *xfer)
 759:../drivers/fsl_spi.c **** {
 760:../drivers/fsl_spi.c ****     assert(xfer);
 761:../drivers/fsl_spi.c **** 
 762:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 763:../drivers/fsl_spi.c **** 
 764:../drivers/fsl_spi.c ****     /* Check if the argument is legal */
 765:../drivers/fsl_spi.c ****     if ((xfer->txData == NULL) && (xfer->rxData == NULL))
 766:../drivers/fsl_spi.c ****     {
 767:../drivers/fsl_spi.c ****         return kStatus_InvalidArgument;
 768:../drivers/fsl_spi.c ****     }
 769:../drivers/fsl_spi.c **** 
 770:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 771:../drivers/fsl_spi.c ****     /* Check if 16 bits or 8 bits */
 772:../drivers/fsl_spi.c ****     bytesPerFrame = ((base->C2 & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT) + 1U;
 773:../drivers/fsl_spi.c **** #endif
 774:../drivers/fsl_spi.c **** 
 775:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 776:../drivers/fsl_spi.c **** 
 777:../drivers/fsl_spi.c ****     /* Disable FIFO, as the FIFO may cause data loss if the data size is not integer
 778:../drivers/fsl_spi.c ****        times of 2bytes. As SPI cannot set watermark to 0, only can set to 1/2 FIFO size or 3/4 FIFO
 779:../drivers/fsl_spi.c ****        size. */
 780:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0)
 781:../drivers/fsl_spi.c ****     {
 782:../drivers/fsl_spi.c ****         base->C3 &= ~SPI_C3_FIFOMODE_MASK;
 783:../drivers/fsl_spi.c ****     }
 784:../drivers/fsl_spi.c **** 
 785:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 786:../drivers/fsl_spi.c **** 
 787:../drivers/fsl_spi.c ****     /* Begin the polling transfer until all data sent */
 788:../drivers/fsl_spi.c ****     while (xfer->dataSize > 0)
 789:../drivers/fsl_spi.c ****     {
 790:../drivers/fsl_spi.c ****         /* Data send */
 791:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_SPTEF_MASK) == 0U)
 792:../drivers/fsl_spi.c ****         {
 793:../drivers/fsl_spi.c ****         }
 794:../drivers/fsl_spi.c ****         SPI_WriteNonBlocking(base, xfer->txData, bytesPerFrame);
 795:../drivers/fsl_spi.c ****         if (xfer->txData)
 796:../drivers/fsl_spi.c ****         {
 797:../drivers/fsl_spi.c ****             xfer->txData += bytesPerFrame;
 798:../drivers/fsl_spi.c ****         }
 799:../drivers/fsl_spi.c **** 
 800:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_SPRF_MASK) == 0U)
 801:../drivers/fsl_spi.c ****         {
 802:../drivers/fsl_spi.c ****         }
 803:../drivers/fsl_spi.c ****         SPI_ReadNonBlocking(base, xfer->rxData, bytesPerFrame);
 804:../drivers/fsl_spi.c ****         if (xfer->rxData)
 805:../drivers/fsl_spi.c ****         {
 806:../drivers/fsl_spi.c ****             xfer->rxData += bytesPerFrame;
 807:../drivers/fsl_spi.c ****         }
 808:../drivers/fsl_spi.c **** 
 809:../drivers/fsl_spi.c ****         /* Decrease the number */
 810:../drivers/fsl_spi.c ****         xfer->dataSize -= bytesPerFrame;
 811:../drivers/fsl_spi.c ****     }
 812:../drivers/fsl_spi.c **** 
 813:../drivers/fsl_spi.c ****     return kStatus_Success;
 814:../drivers/fsl_spi.c **** }
 815:../drivers/fsl_spi.c **** 
 816:../drivers/fsl_spi.c **** void SPI_MasterTransferCreateHandle(SPI_Type *base,
 817:../drivers/fsl_spi.c ****                                     spi_master_handle_t *handle,
 818:../drivers/fsl_spi.c ****                                     spi_master_callback_t callback,
 819:../drivers/fsl_spi.c ****                                     void *userData)
 820:../drivers/fsl_spi.c **** {
 821:../drivers/fsl_spi.c ****     assert(handle);
 822:../drivers/fsl_spi.c **** 
 823:../drivers/fsl_spi.c ****     uint8_t instance = SPI_GetInstance(base);
 824:../drivers/fsl_spi.c **** 
 825:../drivers/fsl_spi.c ****     /* Zero the handle */
 826:../drivers/fsl_spi.c ****     memset(handle, 0, sizeof(*handle));
 827:../drivers/fsl_spi.c **** 
 828:../drivers/fsl_spi.c ****     /* Initialize the handle */
 829:../drivers/fsl_spi.c ****     s_spiHandle[instance] = handle;
 830:../drivers/fsl_spi.c ****     handle->callback = callback;
 831:../drivers/fsl_spi.c ****     handle->userData = userData;
 832:../drivers/fsl_spi.c ****     s_spiMasterIsr = SPI_MasterTransferHandleIRQ;
 833:../drivers/fsl_spi.c ****     handle->watermark = SPI_GetWatermark(base);
 834:../drivers/fsl_spi.c **** 
 835:../drivers/fsl_spi.c **** /* Get the bytes per frame */
 836:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && (FSL_FEATURE_SPI_16BIT_TRANSFERS)
 837:../drivers/fsl_spi.c ****     handle->bytePerFrame = ((base->C2 & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT) + 1U;
 838:../drivers/fsl_spi.c **** #else
 839:../drivers/fsl_spi.c ****     handle->bytePerFrame = 1U;
 840:../drivers/fsl_spi.c **** #endif
 841:../drivers/fsl_spi.c **** 
 842:../drivers/fsl_spi.c ****     /* Enable SPI NVIC */
 843:../drivers/fsl_spi.c ****     EnableIRQ(s_spiIRQ[instance]);
 844:../drivers/fsl_spi.c **** }
 845:../drivers/fsl_spi.c **** 
 846:../drivers/fsl_spi.c **** status_t SPI_MasterTransferNonBlocking(SPI_Type *base, spi_master_handle_t *handle, spi_transfer_t 
 847:../drivers/fsl_spi.c **** {
 848:../drivers/fsl_spi.c ****     assert(handle && xfer);
 849:../drivers/fsl_spi.c **** 
 850:../drivers/fsl_spi.c ****     /* Check if SPI is busy */
 851:../drivers/fsl_spi.c ****     if (handle->state == kSPI_Busy)
 852:../drivers/fsl_spi.c ****     {
 853:../drivers/fsl_spi.c ****         return kStatus_SPI_Busy;
 854:../drivers/fsl_spi.c ****     }
 855:../drivers/fsl_spi.c **** 
 856:../drivers/fsl_spi.c ****     /* Check if the input arguments valid */
 857:../drivers/fsl_spi.c ****     if (((xfer->txData == NULL) && (xfer->rxData == NULL)) || (xfer->dataSize == 0U))
 858:../drivers/fsl_spi.c ****     {
 859:../drivers/fsl_spi.c ****         return kStatus_InvalidArgument;
 860:../drivers/fsl_spi.c ****     }
 861:../drivers/fsl_spi.c **** 
 862:../drivers/fsl_spi.c ****     /* Set the handle information */
 863:../drivers/fsl_spi.c ****     handle->txData = xfer->txData;
 864:../drivers/fsl_spi.c ****     handle->rxData = xfer->rxData;
 865:../drivers/fsl_spi.c ****     handle->transferSize = xfer->dataSize;
 866:../drivers/fsl_spi.c ****     handle->txRemainingBytes = xfer->dataSize;
 867:../drivers/fsl_spi.c ****     handle->rxRemainingBytes = xfer->dataSize;
 868:../drivers/fsl_spi.c **** 
 869:../drivers/fsl_spi.c ****     /* Set the SPI state to busy */
 870:../drivers/fsl_spi.c ****     handle->state = kSPI_Busy;
 871:../drivers/fsl_spi.c **** 
 872:../drivers/fsl_spi.c **** /* Enable Interrupt, only enable Rx interrupt, use rx interrupt to driver SPI transfer */
 873:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 874:../drivers/fsl_spi.c **** 
 875:../drivers/fsl_spi.c ****     handle->watermark = SPI_GetWatermark(base);
 876:../drivers/fsl_spi.c **** 
 877:../drivers/fsl_spi.c ****     /* If the size of the transfer size less than watermark, set watermark to 1 */
 878:../drivers/fsl_spi.c ****     if (xfer->dataSize < handle->watermark * 2U)
 879:../drivers/fsl_spi.c ****     {
 880:../drivers/fsl_spi.c ****         handle->watermark = 1U;
 881:../drivers/fsl_spi.c ****     }
 882:../drivers/fsl_spi.c **** 
 883:../drivers/fsl_spi.c ****     /* According to watermark size, enable interrupts */
 884:../drivers/fsl_spi.c ****     if (handle->watermark > 1U)
 885:../drivers/fsl_spi.c ****     {
 886:../drivers/fsl_spi.c ****         SPI_EnableFIFO(base, true);
 887:../drivers/fsl_spi.c ****         /* First send a piece of data to Tx Data or FIFO to start a SPI transfer */
 888:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_TNEAREF_MASK) != SPI_S_TNEAREF_MASK)
 889:../drivers/fsl_spi.c ****         {
 890:../drivers/fsl_spi.c ****         }
 891:../drivers/fsl_spi.c ****         SPI_SendInitialTransfer(base, handle);
 892:../drivers/fsl_spi.c ****         /* Enable Rx near full interrupt */
 893:../drivers/fsl_spi.c ****         SPI_EnableInterrupts(base, kSPI_RxFifoNearFullInterruptEnable);
 894:../drivers/fsl_spi.c ****     }
 895:../drivers/fsl_spi.c ****     else
 896:../drivers/fsl_spi.c ****     {
 897:../drivers/fsl_spi.c ****         SPI_EnableFIFO(base, false);
 898:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_SPTEF_MASK) != SPI_S_SPTEF_MASK)
 899:../drivers/fsl_spi.c ****         {
 900:../drivers/fsl_spi.c ****         }
 901:../drivers/fsl_spi.c ****         /* First send a piece of data to Tx Data or FIFO to start a SPI transfer */
 902:../drivers/fsl_spi.c ****         SPI_SendInitialTransfer(base, handle);
 903:../drivers/fsl_spi.c ****         SPI_EnableInterrupts(base, kSPI_RxFullAndModfInterruptEnable);
 904:../drivers/fsl_spi.c ****     }
 905:../drivers/fsl_spi.c **** #else
 906:../drivers/fsl_spi.c ****     while ((base->S & SPI_S_SPTEF_MASK) != SPI_S_SPTEF_MASK)
 907:../drivers/fsl_spi.c ****         ;
 908:../drivers/fsl_spi.c ****     /* First send a piece of data to Tx Data or FIFO to start a SPI transfer */
 909:../drivers/fsl_spi.c ****     SPI_SendInitialTransfer(base, handle);
 910:../drivers/fsl_spi.c ****     SPI_EnableInterrupts(base, kSPI_RxFullAndModfInterruptEnable);
 911:../drivers/fsl_spi.c **** #endif
 912:../drivers/fsl_spi.c **** 
 913:../drivers/fsl_spi.c ****     return kStatus_Success;
 914:../drivers/fsl_spi.c **** }
 915:../drivers/fsl_spi.c **** 
 916:../drivers/fsl_spi.c **** status_t SPI_MasterTransferGetCount(SPI_Type *base, spi_master_handle_t *handle, size_t *count)
 917:../drivers/fsl_spi.c **** {
 918:../drivers/fsl_spi.c ****     assert(handle);
 919:../drivers/fsl_spi.c **** 
 920:../drivers/fsl_spi.c ****     status_t status = kStatus_Success;
 921:../drivers/fsl_spi.c **** 
 922:../drivers/fsl_spi.c ****     if (handle->state != kStatus_SPI_Busy)
 923:../drivers/fsl_spi.c ****     {
 924:../drivers/fsl_spi.c ****         status = kStatus_NoTransferInProgress;
 925:../drivers/fsl_spi.c ****     }
 926:../drivers/fsl_spi.c ****     else
 927:../drivers/fsl_spi.c ****     {
 928:../drivers/fsl_spi.c ****         /* Return remaing bytes in different cases */
 929:../drivers/fsl_spi.c ****         if (handle->rxData)
 930:../drivers/fsl_spi.c ****         {
 931:../drivers/fsl_spi.c ****             *count = handle->transferSize - handle->rxRemainingBytes;
 932:../drivers/fsl_spi.c ****         }
 933:../drivers/fsl_spi.c ****         else
 934:../drivers/fsl_spi.c ****         {
 935:../drivers/fsl_spi.c ****             *count = handle->transferSize - handle->txRemainingBytes;
 936:../drivers/fsl_spi.c ****         }
 937:../drivers/fsl_spi.c ****     }
 938:../drivers/fsl_spi.c **** 
 939:../drivers/fsl_spi.c ****     return status;
 940:../drivers/fsl_spi.c **** }
 941:../drivers/fsl_spi.c **** 
 942:../drivers/fsl_spi.c **** void SPI_MasterTransferAbort(SPI_Type *base, spi_master_handle_t *handle)
 943:../drivers/fsl_spi.c **** {
 944:../drivers/fsl_spi.c ****     assert(handle);
 945:../drivers/fsl_spi.c **** 
 946:../drivers/fsl_spi.c **** /* Stop interrupts */
 947:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 948:../drivers/fsl_spi.c ****     if (handle->watermark > 1U)
 949:../drivers/fsl_spi.c ****     {
 950:../drivers/fsl_spi.c ****         SPI_DisableInterrupts(base, kSPI_RxFifoNearFullInterruptEnable | kSPI_RxFullAndModfInterrup
 951:../drivers/fsl_spi.c ****     }
 952:../drivers/fsl_spi.c ****     else
 953:../drivers/fsl_spi.c ****     {
 954:../drivers/fsl_spi.c ****         SPI_DisableInterrupts(base, kSPI_RxFullAndModfInterruptEnable);
 955:../drivers/fsl_spi.c ****     }
 956:../drivers/fsl_spi.c **** #else
 957:../drivers/fsl_spi.c ****     SPI_DisableInterrupts(base, kSPI_RxFullAndModfInterruptEnable);
 958:../drivers/fsl_spi.c **** #endif
 959:../drivers/fsl_spi.c **** 
 960:../drivers/fsl_spi.c ****     /* Transfer finished, set the state to Done*/
 961:../drivers/fsl_spi.c ****     handle->state = kSPI_Idle;
 962:../drivers/fsl_spi.c **** 
 963:../drivers/fsl_spi.c ****     /* Clear the internal state */
 964:../drivers/fsl_spi.c ****     handle->rxRemainingBytes = 0;
 965:../drivers/fsl_spi.c ****     handle->txRemainingBytes = 0;
 966:../drivers/fsl_spi.c **** }
 967:../drivers/fsl_spi.c **** 
 968:../drivers/fsl_spi.c **** void SPI_MasterTransferHandleIRQ(SPI_Type *base, spi_master_handle_t *handle)
 969:../drivers/fsl_spi.c **** {
 970:../drivers/fsl_spi.c ****     assert(handle);
 971:../drivers/fsl_spi.c **** 
 972:../drivers/fsl_spi.c ****     /* If needs to receive data, do a receive */
 973:../drivers/fsl_spi.c ****     if (handle->rxRemainingBytes)
 974:../drivers/fsl_spi.c ****     {
 975:../drivers/fsl_spi.c ****         SPI_ReceiveTransfer(base, handle);
 976:../drivers/fsl_spi.c ****     }
 977:../drivers/fsl_spi.c **** 
 978:../drivers/fsl_spi.c ****     /* We always need to send a data to make the SPI run */
 979:../drivers/fsl_spi.c ****     if (handle->txRemainingBytes)
 980:../drivers/fsl_spi.c ****     {
 981:../drivers/fsl_spi.c ****         SPI_SendTransfer(base, handle);
 982:../drivers/fsl_spi.c ****     }
 983:../drivers/fsl_spi.c **** 
 984:../drivers/fsl_spi.c ****     /* All the transfer finished */
 985:../drivers/fsl_spi.c ****     if ((handle->txRemainingBytes == 0) && (handle->rxRemainingBytes == 0))
 986:../drivers/fsl_spi.c ****     {
 987:../drivers/fsl_spi.c ****         /* Complete the transfer */
 988:../drivers/fsl_spi.c ****         SPI_MasterTransferAbort(base, handle);
 989:../drivers/fsl_spi.c **** 
 990:../drivers/fsl_spi.c ****         if (handle->callback)
 991:../drivers/fsl_spi.c ****         {
 992:../drivers/fsl_spi.c ****             (handle->callback)(base, handle, kStatus_SPI_Idle, handle->userData);
 993:../drivers/fsl_spi.c ****         }
 994:../drivers/fsl_spi.c ****     }
 995:../drivers/fsl_spi.c **** }
 996:../drivers/fsl_spi.c **** 
 997:../drivers/fsl_spi.c **** void SPI_SlaveTransferCreateHandle(SPI_Type *base,
 998:../drivers/fsl_spi.c ****                                    spi_slave_handle_t *handle,
 999:../drivers/fsl_spi.c ****                                    spi_slave_callback_t callback,
1000:../drivers/fsl_spi.c ****                                    void *userData)
1001:../drivers/fsl_spi.c **** {
1002:../drivers/fsl_spi.c ****     assert(handle);
1003:../drivers/fsl_spi.c **** 
1004:../drivers/fsl_spi.c ****     /* Slave create handle share same logic with master create handle, the only difference
1005:../drivers/fsl_spi.c ****     is the Isr pointer. */
1006:../drivers/fsl_spi.c ****     SPI_MasterTransferCreateHandle(base, handle, callback, userData);
1007:../drivers/fsl_spi.c ****     s_spiSlaveIsr = SPI_SlaveTransferHandleIRQ;
1008:../drivers/fsl_spi.c **** }
1009:../drivers/fsl_spi.c **** 
1010:../drivers/fsl_spi.c **** void SPI_SlaveTransferHandleIRQ(SPI_Type *base, spi_slave_handle_t *handle)
1011:../drivers/fsl_spi.c **** {
1012:../drivers/fsl_spi.c ****     assert(handle);
1013:../drivers/fsl_spi.c **** 
1014:../drivers/fsl_spi.c ****     /* Do data send first in case of data missing. */
1015:../drivers/fsl_spi.c ****     if (handle->txRemainingBytes)
1016:../drivers/fsl_spi.c ****     {
1017:../drivers/fsl_spi.c ****         SPI_SendTransfer(base, handle);
1018:../drivers/fsl_spi.c ****     }
1019:../drivers/fsl_spi.c **** 
1020:../drivers/fsl_spi.c ****     /* If needs to receive data, do a receive */
1021:../drivers/fsl_spi.c ****     if (handle->rxRemainingBytes)
1022:../drivers/fsl_spi.c ****     {
1023:../drivers/fsl_spi.c ****         SPI_ReceiveTransfer(base, handle);
1024:../drivers/fsl_spi.c ****     }
1025:../drivers/fsl_spi.c **** 
1026:../drivers/fsl_spi.c ****     /* All the transfer finished */
1027:../drivers/fsl_spi.c ****     if ((handle->txRemainingBytes == 0) && (handle->rxRemainingBytes == 0))
1028:../drivers/fsl_spi.c ****     {
1029:../drivers/fsl_spi.c ****         /* Complete the transfer */
1030:../drivers/fsl_spi.c ****         SPI_SlaveTransferAbort(base, handle);
1031:../drivers/fsl_spi.c **** 
1032:../drivers/fsl_spi.c ****         if (handle->callback)
1033:../drivers/fsl_spi.c ****         {
1034:../drivers/fsl_spi.c ****             (handle->callback)(base, handle, kStatus_SPI_Idle, handle->userData);
1035:../drivers/fsl_spi.c ****         }
1036:../drivers/fsl_spi.c ****     }
1037:../drivers/fsl_spi.c **** }
1038:../drivers/fsl_spi.c **** 
1039:../drivers/fsl_spi.c **** static void SPI_CommonIRQHandler(SPI_Type *base, uint32_t instance)
1040:../drivers/fsl_spi.c **** {
  96              		.loc 1 1040 0
  97              		.cfi_startproc
  98              		@ args = 0, pretend = 0, frame = 0
  99              		@ frame_needed = 0, uses_anonymous_args = 0
 100              	.LVL12:
 101 0000 10B5     		push	{r4, lr}
 102              		.cfi_def_cfa_offset 8
 103              		.cfi_offset 4, -8
 104              		.cfi_offset 14, -4
1041:../drivers/fsl_spi.c ****     if (base->C1 & SPI_C1_MSTR_MASK)
 105              		.loc 1 1041 0
 106 0002 C378     		ldrb	r3, [r0, #3]
 107 0004 DB06     		lsls	r3, r3, #27
 108 0006 06D4     		bmi	.L14
1042:../drivers/fsl_spi.c ****     {
1043:../drivers/fsl_spi.c ****         s_spiMasterIsr(base, s_spiHandle[instance]);
1044:../drivers/fsl_spi.c ****     }
1045:../drivers/fsl_spi.c ****     else
1046:../drivers/fsl_spi.c ****     {
1047:../drivers/fsl_spi.c ****         s_spiSlaveIsr(base, s_spiHandle[instance]);
 109              		.loc 1 1047 0
 110 0008 8900     		lsls	r1, r1, #2
 111              	.LVL13:
 112 000a 064B     		ldr	r3, .L15
 113 000c C958     		ldr	r1, [r1, r3]
 114 000e 064B     		ldr	r3, .L15+4
 115 0010 1B68     		ldr	r3, [r3]
 116 0012 9847     		blx	r3
 117              	.LVL14:
 118              	.L11:
1048:../drivers/fsl_spi.c ****     }
1049:../drivers/fsl_spi.c ****     /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
1050:../drivers/fsl_spi.c ****       exception return operation might vector to incorrect interrupt */
1051:../drivers/fsl_spi.c **** #if defined __CORTEX_M && (__CORTEX_M == 4U)
1052:../drivers/fsl_spi.c ****     __DSB();
1053:../drivers/fsl_spi.c **** #endif
1054:../drivers/fsl_spi.c **** }
 119              		.loc 1 1054 0
 120              		@ sp needed
 121 0014 10BD     		pop	{r4, pc}
 122              	.LVL15:
 123              	.L14:
1043:../drivers/fsl_spi.c ****     }
 124              		.loc 1 1043 0
 125 0016 8900     		lsls	r1, r1, #2
 126              	.LVL16:
 127 0018 024B     		ldr	r3, .L15
 128 001a C958     		ldr	r1, [r1, r3]
 129 001c 034B     		ldr	r3, .L15+8
 130 001e 1B68     		ldr	r3, [r3]
 131 0020 9847     		blx	r3
 132              	.LVL17:
 133 0022 F7E7     		b	.L11
 134              	.L16:
 135              		.align	2
 136              	.L15:
 137 0024 00000000 		.word	.LANCHOR0
 138 0028 00000000 		.word	.LANCHOR2
 139 002c 00000000 		.word	.LANCHOR1
 140              		.cfi_endproc
 141              	.LFE91:
 143              		.section	.text.SPI_GetInstance,"ax",%progbits
 144              		.align	1
 145              		.global	SPI_GetInstance
 146              		.syntax unified
 147              		.code	16
 148              		.thumb_func
 149              		.fpu softvfp
 151              	SPI_GetInstance:
 152              	.LFB62:
 141:../drivers/fsl_spi.c ****     uint32_t instance;
 153              		.loc 1 141 0
 154              		.cfi_startproc
 155              		@ args = 0, pretend = 0, frame = 0
 156              		@ frame_needed = 0, uses_anonymous_args = 0
 157              		@ link register save eliminated.
 158              	.LVL18:
 145:../drivers/fsl_spi.c ****     {
 159              		.loc 1 145 0
 160 0000 0023     		movs	r3, #0
 161              	.LVL19:
 162              	.L18:
 145:../drivers/fsl_spi.c ****     {
 163              		.loc 1 145 0 is_stmt 0 discriminator 1
 164 0002 012B     		cmp	r3, #1
 165 0004 06D8     		bhi	.L17
 147:../drivers/fsl_spi.c ****         {
 166              		.loc 1 147 0 is_stmt 1
 167 0006 9A00     		lsls	r2, r3, #2
 168 0008 0349     		ldr	r1, .L21
 169 000a 5258     		ldr	r2, [r2, r1]
 170 000c 8242     		cmp	r2, r0
 171 000e 01D0     		beq	.L17
 145:../drivers/fsl_spi.c ****     {
 172              		.loc 1 145 0 discriminator 2
 173 0010 0133     		adds	r3, r3, #1
 174              	.LVL20:
 175 0012 F6E7     		b	.L18
 176              	.L17:
 156:../drivers/fsl_spi.c **** 
 177              		.loc 1 156 0
 178 0014 1800     		movs	r0, r3
 179              	.LVL21:
 180              		@ sp needed
 181 0016 7047     		bx	lr
 182              	.L22:
 183              		.align	2
 184              	.L21:
 185 0018 00000000 		.word	.LANCHOR3
 186              		.cfi_endproc
 187              	.LFE62:
 189              		.section	.text.SPI_SetDummyData,"ax",%progbits
 190              		.align	1
 191              		.global	SPI_SetDummyData
 192              		.syntax unified
 193              		.code	16
 194              		.thumb_func
 195              		.fpu softvfp
 197              	SPI_SetDummyData:
 198              	.LFB63:
 159:../drivers/fsl_spi.c ****     uint32_t instance = SPI_GetInstance(base);
 199              		.loc 1 159 0
 200              		.cfi_startproc
 201              		@ args = 0, pretend = 0, frame = 0
 202              		@ frame_needed = 0, uses_anonymous_args = 0
 203              	.LVL22:
 204 0000 10B5     		push	{r4, lr}
 205              		.cfi_def_cfa_offset 8
 206              		.cfi_offset 4, -8
 207              		.cfi_offset 14, -4
 208 0002 0C00     		movs	r4, r1
 160:../drivers/fsl_spi.c ****     s_dummyData[instance] = dummyData;
 209              		.loc 1 160 0
 210 0004 FFF7FEFF 		bl	SPI_GetInstance
 211              	.LVL23:
 161:../drivers/fsl_spi.c **** }
 212              		.loc 1 161 0
 213 0008 014B     		ldr	r3, .L24
 214 000a 1C54     		strb	r4, [r3, r0]
 162:../drivers/fsl_spi.c **** 
 215              		.loc 1 162 0
 216              		@ sp needed
 217 000c 10BD     		pop	{r4, pc}
 218              	.L25:
 219 000e C046     		.align	2
 220              	.L24:
 221 0010 00000000 		.word	.LANCHOR4
 222              		.cfi_endproc
 223              	.LFE63:
 225              		.section	.text.SPI_MasterGetDefaultConfig,"ax",%progbits
 226              		.align	1
 227              		.global	SPI_MasterGetDefaultConfig
 228              		.syntax unified
 229              		.code	16
 230              		.thumb_func
 231              		.fpu softvfp
 233              	SPI_MasterGetDefaultConfig:
 234              	.LFB70:
 406:../drivers/fsl_spi.c ****     config->enableMaster = true;
 235              		.loc 1 406 0
 236              		.cfi_startproc
 237              		@ args = 0, pretend = 0, frame = 0
 238              		@ frame_needed = 0, uses_anonymous_args = 0
 239              		@ link register save eliminated.
 240              	.LVL24:
 407:../drivers/fsl_spi.c ****     config->enableStopInWaitMode = false;
 241              		.loc 1 407 0
 242 0000 0122     		movs	r2, #1
 243 0002 0270     		strb	r2, [r0]
 408:../drivers/fsl_spi.c ****     config->polarity = kSPI_ClockPolarityActiveHigh;
 244              		.loc 1 408 0
 245 0004 0023     		movs	r3, #0
 246 0006 4370     		strb	r3, [r0, #1]
 409:../drivers/fsl_spi.c ****     config->phase = kSPI_ClockPhaseFirstEdge;
 247              		.loc 1 409 0
 248 0008 8370     		strb	r3, [r0, #2]
 410:../drivers/fsl_spi.c ****     config->direction = kSPI_MsbFirst;
 249              		.loc 1 410 0
 250 000a C370     		strb	r3, [r0, #3]
 411:../drivers/fsl_spi.c **** 
 251              		.loc 1 411 0
 252 000c 0371     		strb	r3, [r0, #4]
 414:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 253              		.loc 1 414 0
 254 000e 4371     		strb	r3, [r0, #5]
 418:../drivers/fsl_spi.c ****     config->rxWatermark = kSPI_RxFifoOneHalfFull;
 255              		.loc 1 418 0
 256 0010 8271     		strb	r2, [r0, #6]
 419:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 257              		.loc 1 419 0
 258 0012 C271     		strb	r2, [r0, #7]
 422:../drivers/fsl_spi.c ****     config->outputMode = kSPI_SlaveSelectAutomaticOutput;
 259              		.loc 1 422 0
 260 0014 4372     		strb	r3, [r0, #9]
 423:../drivers/fsl_spi.c ****     config->baudRate_Bps = 500000U;
 261              		.loc 1 423 0
 262 0016 0333     		adds	r3, r3, #3
 263 0018 0372     		strb	r3, [r0, #8]
 424:../drivers/fsl_spi.c **** }
 264              		.loc 1 424 0
 265 001a 014B     		ldr	r3, .L27
 266 001c C360     		str	r3, [r0, #12]
 425:../drivers/fsl_spi.c **** 
 267              		.loc 1 425 0
 268              		@ sp needed
 269 001e 7047     		bx	lr
 270              	.L28:
 271              		.align	2
 272              	.L27:
 273 0020 20A10700 		.word	500000
 274              		.cfi_endproc
 275              	.LFE70:
 277              		.section	.text.SPI_SlaveGetDefaultConfig,"ax",%progbits
 278              		.align	1
 279              		.global	SPI_SlaveGetDefaultConfig
 280              		.syntax unified
 281              		.code	16
 282              		.thumb_func
 283              		.fpu softvfp
 285              	SPI_SlaveGetDefaultConfig:
 286              	.LFB72:
 476:../drivers/fsl_spi.c ****     config->enableSlave = true;
 287              		.loc 1 476 0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 0
 290              		@ frame_needed = 0, uses_anonymous_args = 0
 291              		@ link register save eliminated.
 292              	.LVL25:
 477:../drivers/fsl_spi.c ****     config->polarity = kSPI_ClockPolarityActiveHigh;
 293              		.loc 1 477 0
 294 0000 0122     		movs	r2, #1
 295 0002 0270     		strb	r2, [r0]
 478:../drivers/fsl_spi.c ****     config->phase = kSPI_ClockPhaseFirstEdge;
 296              		.loc 1 478 0
 297 0004 0023     		movs	r3, #0
 298 0006 8370     		strb	r3, [r0, #2]
 479:../drivers/fsl_spi.c ****     config->direction = kSPI_MsbFirst;
 299              		.loc 1 479 0
 300 0008 C370     		strb	r3, [r0, #3]
 480:../drivers/fsl_spi.c ****     config->enableStopInWaitMode = false;
 301              		.loc 1 480 0
 302 000a 0371     		strb	r3, [r0, #4]
 481:../drivers/fsl_spi.c **** 
 303              		.loc 1 481 0
 304 000c 4370     		strb	r3, [r0, #1]
 484:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 305              		.loc 1 484 0
 306 000e 4371     		strb	r3, [r0, #5]
 488:../drivers/fsl_spi.c ****     config->rxWatermark = kSPI_RxFifoOneHalfFull;
 307              		.loc 1 488 0
 308 0010 8271     		strb	r2, [r0, #6]
 489:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 309              		.loc 1 489 0
 310 0012 C271     		strb	r2, [r0, #7]
 491:../drivers/fsl_spi.c **** }
 311              		.loc 1 491 0
 312 0014 0372     		strb	r3, [r0, #8]
 492:../drivers/fsl_spi.c **** 
 313              		.loc 1 492 0
 314              		@ sp needed
 315 0016 7047     		bx	lr
 316              		.cfi_endproc
 317              	.LFE72:
 319              		.section	.text.SPI_SlaveInit,"ax",%progbits
 320              		.align	1
 321              		.global	SPI_SlaveInit
 322              		.syntax unified
 323              		.code	16
 324              		.thumb_func
 325              		.fpu softvfp
 327              	SPI_SlaveInit:
 328              	.LFB73:
 495:../drivers/fsl_spi.c ****     assert(config);
 329              		.loc 1 495 0
 330              		.cfi_startproc
 331              		@ args = 0, pretend = 0, frame = 0
 332              		@ frame_needed = 0, uses_anonymous_args = 0
 333              	.LVL26:
 334 0000 70B5     		push	{r4, r5, r6, lr}
 335              		.cfi_def_cfa_offset 16
 336              		.cfi_offset 4, -16
 337              		.cfi_offset 5, -12
 338              		.cfi_offset 6, -8
 339              		.cfi_offset 14, -4
 340 0002 0400     		movs	r4, r0
 341 0004 0D00     		movs	r5, r1
 500:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 342              		.loc 1 500 0
 343 0006 FFF7FEFF 		bl	SPI_GetInstance
 344              	.LVL27:
 345 000a 8000     		lsls	r0, r0, #2
 346 000c 254B     		ldr	r3, .L33
 347 000e C358     		ldr	r3, [r0, r3]
 348              	.LVL28:
 349              	.LBB16:
 350              	.LBB17:
 351              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 352              		.loc 2 449 0
 353 0010 1A0C     		lsrs	r2, r3, #16
 354 0012 2549     		ldr	r1, .L33+4
 355 0014 8C46     		mov	ip, r1
 356 0016 6244     		add	r2, r2, ip
 357              	.LVL29:
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 358              		.loc 2 450 0
 359 0018 1168     		ldr	r1, [r2]
 360 001a 1B04     		lsls	r3, r3, #16
 361              	.LVL30:
 362 001c 1B0C     		lsrs	r3, r3, #16
 363 001e 0120     		movs	r0, #1
 364              	.LVL31:
 365 0020 9840     		lsls	r0, r0, r3
 366 0022 0300     		movs	r3, r0
 367 0024 0B43     		orrs	r3, r1
 368 0026 1360     		str	r3, [r2]
 369              	.LVL32:
 370              	.LBE17:
 371              	.LBE16:
 504:../drivers/fsl_spi.c **** 
 372              		.loc 1 504 0
 373 0028 E378     		ldrb	r3, [r4, #3]
 374 002a 4022     		movs	r2, #64
 375 002c 9343     		bics	r3, r2
 376 002e E370     		strb	r3, [r4, #3]
 508:../drivers/fsl_spi.c **** 
 377              		.loc 1 508 0
 378 0030 AA78     		ldrb	r2, [r5, #2]
 379 0032 D200     		lsls	r2, r2, #3
 380 0034 0820     		movs	r0, #8
 381 0036 0240     		ands	r2, r0
 382 0038 EB78     		ldrb	r3, [r5, #3]
 383 003a 9B00     		lsls	r3, r3, #2
 384 003c 0421     		movs	r1, #4
 385 003e 0B40     		ands	r3, r1
 386 0040 1A43     		orrs	r2, r3
 387 0042 2B79     		ldrb	r3, [r5, #4]
 388 0044 0339     		subs	r1, r1, #3
 389 0046 0B40     		ands	r3, r1
 390 0048 1A43     		orrs	r2, r3
 507:../drivers/fsl_spi.c ****         SPI_C1_MSTR(0U) | SPI_C1_CPOL(config->polarity) | SPI_C1_CPHA(config->phase) | SPI_C1_LSBFE
 391              		.loc 1 507 0
 392 004a E270     		strb	r2, [r4, #3]
 512:../drivers/fsl_spi.c ****                SPI_C2_BIDIROE(config->pinMode >> 1U) | SPI_C2_SPC0(config->pinMode & 1U);
 393              		.loc 1 512 0
 394 004c 6B79     		ldrb	r3, [r5, #5]
 395 004e 9B01     		lsls	r3, r3, #6
 396 0050 4022     		movs	r2, #64
 397 0052 1340     		ands	r3, r2
 398 0054 6A78     		ldrb	r2, [r5, #1]
 399 0056 5200     		lsls	r2, r2, #1
 400 0058 0226     		movs	r6, #2
 401 005a 3240     		ands	r2, r6
 402 005c 1343     		orrs	r3, r2
 513:../drivers/fsl_spi.c **** #else
 403              		.loc 1 513 0
 404 005e 2E7A     		ldrb	r6, [r5, #8]
 405 0060 7208     		lsrs	r2, r6, #1
 406 0062 D200     		lsls	r2, r2, #3
 407 0064 0240     		ands	r2, r0
 512:../drivers/fsl_spi.c ****                SPI_C2_BIDIROE(config->pinMode >> 1U) | SPI_C2_SPC0(config->pinMode & 1U);
 408              		.loc 1 512 0
 409 0066 1343     		orrs	r3, r2
 513:../drivers/fsl_spi.c **** #else
 410              		.loc 1 513 0
 411 0068 3140     		ands	r1, r6
 412 006a 0B43     		orrs	r3, r1
 512:../drivers/fsl_spi.c ****                SPI_C2_BIDIROE(config->pinMode >> 1U) | SPI_C2_SPC0(config->pinMode & 1U);
 413              		.loc 1 512 0
 414 006c A370     		strb	r3, [r4, #2]
 521:../drivers/fsl_spi.c ****     {
 415              		.loc 1 521 0
 416 006e 0F4B     		ldr	r3, .L33+8
 417 0070 9C42     		cmp	r4, r3
 418 0072 0BD0     		beq	.L31
 523:../drivers/fsl_spi.c ****                    SPI_C3_INTCLR(0U) | SPI_C3_FIFOMODE(1U);
 419              		.loc 1 523 0
 420 0074 AB79     		ldrb	r3, [r5, #6]
 421 0076 5B01     		lsls	r3, r3, #5
 422 0078 2022     		movs	r2, #32
 423 007a 1340     		ands	r3, r2
 424 007c EA79     		ldrb	r2, [r5, #7]
 425 007e 1201     		lsls	r2, r2, #4
 426 0080 1021     		movs	r1, #16
 427 0082 0A40     		ands	r2, r1
 428 0084 1343     		orrs	r3, r2
 524:../drivers/fsl_spi.c ****     }
 429              		.loc 1 524 0
 430 0086 0122     		movs	r2, #1
 431 0088 1343     		orrs	r3, r2
 523:../drivers/fsl_spi.c ****                    SPI_C3_INTCLR(0U) | SPI_C3_FIFOMODE(1U);
 432              		.loc 1 523 0
 433 008a E372     		strb	r3, [r4, #11]
 434              	.L31:
 529:../drivers/fsl_spi.c **** 
 435              		.loc 1 529 0
 436 008c FF21     		movs	r1, #255
 437 008e 2000     		movs	r0, r4
 438 0090 FFF7FEFF 		bl	SPI_SetDummyData
 439              	.LVL33:
 532:../drivers/fsl_spi.c ****     {
 440              		.loc 1 532 0
 441 0094 2B78     		ldrb	r3, [r5]
 442 0096 002B     		cmp	r3, #0
 443 0098 03D0     		beq	.L30
 534:../drivers/fsl_spi.c ****     }
 444              		.loc 1 534 0
 445 009a E378     		ldrb	r3, [r4, #3]
 446 009c 4022     		movs	r2, #64
 447 009e 1343     		orrs	r3, r2
 448 00a0 E370     		strb	r3, [r4, #3]
 449              	.L30:
 536:../drivers/fsl_spi.c **** 
 450              		.loc 1 536 0
 451              		@ sp needed
 452              	.LVL34:
 453              	.LVL35:
 454 00a2 70BD     		pop	{r4, r5, r6, pc}
 455              	.L34:
 456              		.align	2
 457              	.L33:
 458 00a4 00000000 		.word	.LANCHOR5
 459 00a8 00700440 		.word	1074032640
 460 00ac 00600740 		.word	1074225152
 461              		.cfi_endproc
 462              	.LFE73:
 464              		.section	.text.SPI_Deinit,"ax",%progbits
 465              		.align	1
 466              		.global	SPI_Deinit
 467              		.syntax unified
 468              		.code	16
 469              		.thumb_func
 470              		.fpu softvfp
 472              	SPI_Deinit:
 473              	.LFB74:
 539:../drivers/fsl_spi.c ****     /* Disable SPI module before shutting down */
 474              		.loc 1 539 0
 475              		.cfi_startproc
 476              		@ args = 0, pretend = 0, frame = 0
 477              		@ frame_needed = 0, uses_anonymous_args = 0
 478              	.LVL36:
 479 0000 10B5     		push	{r4, lr}
 480              		.cfi_def_cfa_offset 8
 481              		.cfi_offset 4, -8
 482              		.cfi_offset 14, -4
 541:../drivers/fsl_spi.c **** 
 483              		.loc 1 541 0
 484 0002 C378     		ldrb	r3, [r0, #3]
 485 0004 4022     		movs	r2, #64
 486 0006 9343     		bics	r3, r2
 487 0008 C370     		strb	r3, [r0, #3]
 545:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 488              		.loc 1 545 0
 489 000a FFF7FEFF 		bl	SPI_GetInstance
 490              	.LVL37:
 491 000e 8000     		lsls	r0, r0, #2
 492 0010 064B     		ldr	r3, .L36
 493 0012 C358     		ldr	r3, [r0, r3]
 494              	.LVL38:
 495              	.LBB18:
 496              	.LBB19:
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 497              		.loc 2 460 0
 498 0014 1A0C     		lsrs	r2, r3, #16
 499 0016 0649     		ldr	r1, .L36+4
 500 0018 8C46     		mov	ip, r1
 501 001a 6244     		add	r2, r2, ip
 502              	.LVL39:
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 503              		.loc 2 461 0
 504 001c 1168     		ldr	r1, [r2]
 505 001e 1B04     		lsls	r3, r3, #16
 506              	.LVL40:
 507 0020 1B0C     		lsrs	r3, r3, #16
 508 0022 0120     		movs	r0, #1
 509              	.LVL41:
 510 0024 9840     		lsls	r0, r0, r3
 511 0026 8143     		bics	r1, r0
 512 0028 1160     		str	r1, [r2]
 513              	.LVL42:
 514              	.LBE19:
 515              	.LBE18:
 547:../drivers/fsl_spi.c **** 
 516              		.loc 1 547 0
 517              		@ sp needed
 518 002a 10BD     		pop	{r4, pc}
 519              	.L37:
 520              		.align	2
 521              	.L36:
 522 002c 00000000 		.word	.LANCHOR5
 523 0030 00700440 		.word	1074032640
 524              		.cfi_endproc
 525              	.LFE74:
 527              		.section	.text.SPI_GetStatusFlags,"ax",%progbits
 528              		.align	1
 529              		.global	SPI_GetStatusFlags
 530              		.syntax unified
 531              		.code	16
 532              		.thumb_func
 533              		.fpu softvfp
 535              	SPI_GetStatusFlags:
 536              	.LFB75:
 550:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 537              		.loc 1 550 0
 538              		.cfi_startproc
 539              		@ args = 0, pretend = 0, frame = 0
 540              		@ frame_needed = 0, uses_anonymous_args = 0
 541              		@ link register save eliminated.
 542              	.LVL43:
 552:../drivers/fsl_spi.c ****     {
 543              		.loc 1 552 0
 544 0000 054B     		ldr	r3, .L41
 545 0002 9842     		cmp	r0, r3
 546 0004 04D0     		beq	.L39
 554:../drivers/fsl_spi.c ****     }
 547              		.loc 1 554 0
 548 0006 0378     		ldrb	r3, [r0]
 549 0008 807A     		ldrb	r0, [r0, #10]
 550              	.LVL44:
 551 000a 0002     		lsls	r0, r0, #8
 552 000c 1843     		orrs	r0, r3
 553              	.L38:
 563:../drivers/fsl_spi.c **** 
 554              		.loc 1 563 0
 555              		@ sp needed
 556 000e 7047     		bx	lr
 557              	.LVL45:
 558              	.L39:
 558:../drivers/fsl_spi.c ****     }
 559              		.loc 1 558 0
 560 0010 0078     		ldrb	r0, [r0]
 561              	.LVL46:
 562 0012 C0B2     		uxtb	r0, r0
 563 0014 FBE7     		b	.L38
 564              	.L42:
 565 0016 C046     		.align	2
 566              	.L41:
 567 0018 00600740 		.word	1074225152
 568              		.cfi_endproc
 569              	.LFE75:
 571              		.section	.text.SPI_EnableInterrupts,"ax",%progbits
 572              		.align	1
 573              		.global	SPI_EnableInterrupts
 574              		.syntax unified
 575              		.code	16
 576              		.thumb_func
 577              		.fpu softvfp
 579              	SPI_EnableInterrupts:
 580              	.LFB76:
 566:../drivers/fsl_spi.c ****     /* Rx full interrupt */
 581              		.loc 1 566 0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 0
 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              		@ link register save eliminated.
 586              	.LVL47:
 568:../drivers/fsl_spi.c ****     {
 587              		.loc 1 568 0
 588 0000 CB07     		lsls	r3, r1, #31
 589 0002 05D5     		bpl	.L44
 570:../drivers/fsl_spi.c ****     }
 590              		.loc 1 570 0
 591 0004 C378     		ldrb	r3, [r0, #3]
 592 0006 8022     		movs	r2, #128
 593 0008 5242     		rsbs	r2, r2, #0
 594 000a 1343     		orrs	r3, r2
 595 000c DBB2     		uxtb	r3, r3
 596 000e C370     		strb	r3, [r0, #3]
 597              	.L44:
 574:../drivers/fsl_spi.c ****     {
 598              		.loc 1 574 0
 599 0010 8B07     		lsls	r3, r1, #30
 600 0012 03D5     		bpl	.L45
 576:../drivers/fsl_spi.c ****     }
 601              		.loc 1 576 0
 602 0014 C378     		ldrb	r3, [r0, #3]
 603 0016 2022     		movs	r2, #32
 604 0018 1343     		orrs	r3, r2
 605 001a C370     		strb	r3, [r0, #3]
 606              	.L45:
 580:../drivers/fsl_spi.c ****     {
 607              		.loc 1 580 0
 608 001c 4B07     		lsls	r3, r1, #29
 609 001e 05D5     		bpl	.L46
 582:../drivers/fsl_spi.c ****     }
 610              		.loc 1 582 0
 611 0020 8378     		ldrb	r3, [r0, #2]
 612 0022 8022     		movs	r2, #128
 613 0024 5242     		rsbs	r2, r2, #0
 614 0026 1343     		orrs	r3, r2
 615 0028 DBB2     		uxtb	r3, r3
 616 002a 8370     		strb	r3, [r0, #2]
 617              	.L46:
 587:../drivers/fsl_spi.c ****     {
 618              		.loc 1 587 0
 619 002c 074B     		ldr	r3, .L49
 620 002e 9842     		cmp	r0, r3
 621 0030 0BD0     		beq	.L43
 590:../drivers/fsl_spi.c ****         {
 622              		.loc 1 590 0
 623 0032 0B07     		lsls	r3, r1, #28
 624 0034 03D5     		bpl	.L48
 592:../drivers/fsl_spi.c ****         }
 625              		.loc 1 592 0
 626 0036 C37A     		ldrb	r3, [r0, #11]
 627 0038 0222     		movs	r2, #2
 628 003a 1343     		orrs	r3, r2
 629 003c C372     		strb	r3, [r0, #11]
 630              	.L48:
 596:../drivers/fsl_spi.c ****         {
 631              		.loc 1 596 0
 632 003e CB06     		lsls	r3, r1, #27
 633 0040 03D5     		bpl	.L43
 598:../drivers/fsl_spi.c ****         }
 634              		.loc 1 598 0
 635 0042 C37A     		ldrb	r3, [r0, #11]
 636 0044 0422     		movs	r2, #4
 637 0046 1343     		orrs	r3, r2
 638 0048 C372     		strb	r3, [r0, #11]
 639              	.L43:
 602:../drivers/fsl_spi.c **** 
 640              		.loc 1 602 0
 641              		@ sp needed
 642 004a 7047     		bx	lr
 643              	.L50:
 644              		.align	2
 645              	.L49:
 646 004c 00600740 		.word	1074225152
 647              		.cfi_endproc
 648              	.LFE76:
 650              		.section	.text.SPI_DisableInterrupts,"ax",%progbits
 651              		.align	1
 652              		.global	SPI_DisableInterrupts
 653              		.syntax unified
 654              		.code	16
 655              		.thumb_func
 656              		.fpu softvfp
 658              	SPI_DisableInterrupts:
 659              	.LFB77:
 605:../drivers/fsl_spi.c ****     /* Rx full interrupt */
 660              		.loc 1 605 0
 661              		.cfi_startproc
 662              		@ args = 0, pretend = 0, frame = 0
 663              		@ frame_needed = 0, uses_anonymous_args = 0
 664              		@ link register save eliminated.
 665              	.LVL48:
 607:../drivers/fsl_spi.c ****     {
 666              		.loc 1 607 0
 667 0000 CB07     		lsls	r3, r1, #31
 668 0002 03D5     		bpl	.L52
 609:../drivers/fsl_spi.c ****     }
 669              		.loc 1 609 0
 670 0004 C378     		ldrb	r3, [r0, #3]
 671 0006 7F22     		movs	r2, #127
 672 0008 1340     		ands	r3, r2
 673 000a C370     		strb	r3, [r0, #3]
 674              	.L52:
 613:../drivers/fsl_spi.c ****     {
 675              		.loc 1 613 0
 676 000c 8B07     		lsls	r3, r1, #30
 677 000e 03D5     		bpl	.L53
 615:../drivers/fsl_spi.c ****     }
 678              		.loc 1 615 0
 679 0010 C378     		ldrb	r3, [r0, #3]
 680 0012 2022     		movs	r2, #32
 681 0014 9343     		bics	r3, r2
 682 0016 C370     		strb	r3, [r0, #3]
 683              	.L53:
 619:../drivers/fsl_spi.c ****     {
 684              		.loc 1 619 0
 685 0018 4B07     		lsls	r3, r1, #29
 686 001a 03D5     		bpl	.L54
 621:../drivers/fsl_spi.c ****     }
 687              		.loc 1 621 0
 688 001c 8378     		ldrb	r3, [r0, #2]
 689 001e 7F22     		movs	r2, #127
 690 0020 1340     		ands	r3, r2
 691 0022 8370     		strb	r3, [r0, #2]
 692              	.L54:
 625:../drivers/fsl_spi.c ****     {
 693              		.loc 1 625 0
 694 0024 074B     		ldr	r3, .L57
 695 0026 9842     		cmp	r0, r3
 696 0028 0BD0     		beq	.L51
 628:../drivers/fsl_spi.c ****         {
 697              		.loc 1 628 0
 698 002a 0B07     		lsls	r3, r1, #28
 699 002c 03D5     		bpl	.L56
 630:../drivers/fsl_spi.c ****         }
 700              		.loc 1 630 0
 701 002e C37A     		ldrb	r3, [r0, #11]
 702 0030 0222     		movs	r2, #2
 703 0032 9343     		bics	r3, r2
 704 0034 C372     		strb	r3, [r0, #11]
 705              	.L56:
 634:../drivers/fsl_spi.c ****         {
 706              		.loc 1 634 0
 707 0036 CB06     		lsls	r3, r1, #27
 708 0038 03D5     		bpl	.L51
 636:../drivers/fsl_spi.c ****         }
 709              		.loc 1 636 0
 710 003a C37A     		ldrb	r3, [r0, #11]
 711 003c 0422     		movs	r2, #4
 712 003e 9343     		bics	r3, r2
 713 0040 C372     		strb	r3, [r0, #11]
 714              	.L51:
 640:../drivers/fsl_spi.c **** 
 715              		.loc 1 640 0
 716              		@ sp needed
 717 0042 7047     		bx	lr
 718              	.L58:
 719              		.align	2
 720              	.L57:
 721 0044 00600740 		.word	1074225152
 722              		.cfi_endproc
 723              	.LFE77:
 725              		.global	__aeabi_uidiv
 726              		.section	.text.SPI_MasterSetBaudRate,"ax",%progbits
 727              		.align	1
 728              		.global	SPI_MasterSetBaudRate
 729              		.syntax unified
 730              		.code	16
 731              		.thumb_func
 732              		.fpu softvfp
 734              	SPI_MasterSetBaudRate:
 735              	.LFB78:
 643:../drivers/fsl_spi.c ****     uint32_t prescaler;
 736              		.loc 1 643 0
 737              		.cfi_startproc
 738              		@ args = 0, pretend = 0, frame = 16
 739              		@ frame_needed = 0, uses_anonymous_args = 0
 740              	.LVL49:
 741 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 742              		.cfi_def_cfa_offset 20
 743              		.cfi_offset 4, -20
 744              		.cfi_offset 5, -16
 745              		.cfi_offset 6, -12
 746              		.cfi_offset 7, -8
 747              		.cfi_offset 14, -4
 748 0002 DE46     		mov	lr, fp
 749 0004 5746     		mov	r7, r10
 750 0006 80B5     		push	{r7, lr}
 751              		.cfi_def_cfa_offset 28
 752              		.cfi_offset 10, -28
 753              		.cfi_offset 11, -24
 754 0008 85B0     		sub	sp, sp, #20
 755              		.cfi_def_cfa_offset 48
 756 000a 8346     		mov	fp, r0
 757 000c 8A46     		mov	r10, r1
 758 000e 0192     		str	r2, [sp, #4]
 759              	.LVL50:
 655:../drivers/fsl_spi.c **** 
 760              		.loc 1 655 0
 761 0010 0126     		movs	r6, #1
 762 0012 7642     		rsbs	r6, r6, #0
 659:../drivers/fsl_spi.c **** 
 763              		.loc 1 659 0
 764 0014 0823     		movs	r3, #8
 765 0016 0393     		str	r3, [sp, #12]
 658:../drivers/fsl_spi.c ****     bestDivisor = 8U;
 766              		.loc 1 658 0
 767 0018 013B     		subs	r3, r3, #1
 768 001a 0293     		str	r3, [sp, #8]
 662:../drivers/fsl_spi.c ****     {
 769              		.loc 1 662 0
 770 001c 0027     		movs	r7, #0
 771 001e 15E0     		b	.L60
 772              	.LVL51:
 773              	.L61:
 687:../drivers/fsl_spi.c ****         }
 774              		.loc 1 687 0 discriminator 2
 775 0020 6D00     		lsls	r5, r5, #1
 776              	.LVL52:
 667:../drivers/fsl_spi.c ****         {
 777              		.loc 1 667 0 discriminator 2
 778 0022 0134     		adds	r4, r4, #1
 779              	.LVL53:
 780              	.L65:
 667:../drivers/fsl_spi.c ****         {
 781              		.loc 1 667 0 is_stmt 0 discriminator 1
 782 0024 082C     		cmp	r4, #8
 783 0026 10D8     		bhi	.L62
 667:../drivers/fsl_spi.c ****         {
 784              		.loc 1 667 0 discriminator 3
 785 0028 002E     		cmp	r6, #0
 786 002a 0ED0     		beq	.L62
 670:../drivers/fsl_spi.c **** 
 787              		.loc 1 670 0 is_stmt 1
 788 002c 791C     		adds	r1, r7, #1
 789 002e 6943     		muls	r1, r5
 790 0030 0198     		ldr	r0, [sp, #4]
 791 0032 FFF7FEFF 		bl	__aeabi_uidiv
 792              	.LVL54:
 674:../drivers/fsl_spi.c ****             {
 793              		.loc 1 674 0
 794 0036 8245     		cmp	r10, r0
 795 0038 F2D3     		bcc	.L61
 676:../drivers/fsl_spi.c ****                 if (min_diff > diff)
 796              		.loc 1 676 0
 797 003a 5346     		mov	r3, r10
 798 003c 181A     		subs	r0, r3, r0
 799              	.LVL55:
 677:../drivers/fsl_spi.c ****                 {
 800              		.loc 1 677 0
 801 003e 8642     		cmp	r6, r0
 802 0040 EED9     		bls	.L61
 803              	.LVL56:
 680:../drivers/fsl_spi.c ****                     bestPrescaler = prescaler;
 804              		.loc 1 680 0
 805 0042 0600     		movs	r6, r0
 806              	.LVL57:
 682:../drivers/fsl_spi.c ****                 }
 807              		.loc 1 682 0
 808 0044 0394     		str	r4, [sp, #12]
 809              	.LVL58:
 681:../drivers/fsl_spi.c ****                     bestDivisor = rateDivisor;
 810              		.loc 1 681 0
 811 0046 0297     		str	r7, [sp, #8]
 812              	.LVL59:
 813 0048 EAE7     		b	.L61
 814              	.LVL60:
 815              	.L62:
 662:../drivers/fsl_spi.c ****     {
 816              		.loc 1 662 0 discriminator 2
 817 004a 0137     		adds	r7, r7, #1
 818              	.LVL61:
 819              	.L60:
 662:../drivers/fsl_spi.c ****     {
 820              		.loc 1 662 0 is_stmt 0 discriminator 1
 821 004c 072F     		cmp	r7, #7
 822 004e 04D8     		bhi	.L64
 662:../drivers/fsl_spi.c ****     {
 823              		.loc 1 662 0 discriminator 3
 824 0050 002E     		cmp	r6, #0
 825 0052 02D0     		beq	.L64
 665:../drivers/fsl_spi.c **** 
 826              		.loc 1 665 0 is_stmt 1
 827 0054 0225     		movs	r5, #2
 667:../drivers/fsl_spi.c ****         {
 828              		.loc 1 667 0
 829 0056 0024     		movs	r4, #0
 830 0058 E4E7     		b	.L65
 831              	.L64:
 692:../drivers/fsl_spi.c **** }
 832              		.loc 1 692 0
 833 005a 0F23     		movs	r3, #15
 834 005c 039F     		ldr	r7, [sp, #12]
 835              	.LVL62:
 836 005e 1F40     		ands	r7, r3
 837 0060 6B46     		mov	r3, sp
 838 0062 1B7A     		ldrb	r3, [r3, #8]
 839 0064 1B01     		lsls	r3, r3, #4
 840 0066 7022     		movs	r2, #112
 841 0068 1340     		ands	r3, r2
 842 006a 3B43     		orrs	r3, r7
 843 006c 5A46     		mov	r2, fp
 844 006e 5370     		strb	r3, [r2, #1]
 693:../drivers/fsl_spi.c **** 
 845              		.loc 1 693 0
 846 0070 05B0     		add	sp, sp, #20
 847              		@ sp needed
 848              	.LVL63:
 849              	.LVL64:
 850              	.LVL65:
 851 0072 0CBC     		pop	{r2, r3}
 852 0074 9246     		mov	r10, r2
 853 0076 9B46     		mov	fp, r3
 854 0078 F0BD     		pop	{r4, r5, r6, r7, pc}
 855              		.cfi_endproc
 856              	.LFE78:
 858              		.section	.text.SPI_MasterInit,"ax",%progbits
 859              		.align	1
 860              		.global	SPI_MasterInit
 861              		.syntax unified
 862              		.code	16
 863              		.thumb_func
 864              		.fpu softvfp
 866              	SPI_MasterInit:
 867              	.LFB71:
 428:../drivers/fsl_spi.c ****     assert(config && srcClock_Hz);
 868              		.loc 1 428 0
 869              		.cfi_startproc
 870              		@ args = 0, pretend = 0, frame = 8
 871              		@ frame_needed = 0, uses_anonymous_args = 0
 872              	.LVL66:
 873 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 874              		.cfi_def_cfa_offset 20
 875              		.cfi_offset 4, -20
 876              		.cfi_offset 5, -16
 877              		.cfi_offset 6, -12
 878              		.cfi_offset 7, -8
 879              		.cfi_offset 14, -4
 880 0002 83B0     		sub	sp, sp, #12
 881              		.cfi_def_cfa_offset 32
 882 0004 0600     		movs	r6, r0
 883 0006 0D00     		movs	r5, r1
 884 0008 0192     		str	r2, [sp, #4]
 433:../drivers/fsl_spi.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 885              		.loc 1 433 0
 886 000a FFF7FEFF 		bl	SPI_GetInstance
 887              	.LVL67:
 888 000e 8000     		lsls	r0, r0, #2
 889 0010 2E4B     		ldr	r3, .L71
 890 0012 C358     		ldr	r3, [r0, r3]
 891              	.LVL68:
 892              	.LBB20:
 893              	.LBB21:
 449:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 894              		.loc 2 449 0
 895 0014 1A0C     		lsrs	r2, r3, #16
 896 0016 2E49     		ldr	r1, .L71+4
 897 0018 8C46     		mov	ip, r1
 898 001a 6244     		add	r2, r2, ip
 899              	.LVL69:
 450:../drivers/fsl_clock.h **** }
 900              		.loc 2 450 0
 901 001c 1168     		ldr	r1, [r2]
 902 001e 1B04     		lsls	r3, r3, #16
 903              	.LVL70:
 904 0020 1B0C     		lsrs	r3, r3, #16
 905 0022 0120     		movs	r0, #1
 906              	.LVL71:
 907 0024 9840     		lsls	r0, r0, r3
 908 0026 0300     		movs	r3, r0
 909 0028 0B43     		orrs	r3, r1
 910 002a 1360     		str	r3, [r2]
 911              	.LVL72:
 912              	.LBE21:
 913              	.LBE20:
 437:../drivers/fsl_spi.c **** 
 914              		.loc 1 437 0
 915 002c F378     		ldrb	r3, [r6, #3]
 916 002e 4022     		movs	r2, #64
 917 0030 9343     		bics	r3, r2
 918 0032 F370     		strb	r3, [r6, #3]
 440:../drivers/fsl_spi.c ****                SPI_C1_SSOE(config->outputMode & 1U) | SPI_C1_LSBFE(config->direction);
 919              		.loc 1 440 0
 920 0034 AA78     		ldrb	r2, [r5, #2]
 921 0036 D200     		lsls	r2, r2, #3
 922 0038 0827     		movs	r7, #8
 923 003a 3A40     		ands	r2, r7
 924 003c EB78     		ldrb	r3, [r5, #3]
 925 003e 9B00     		lsls	r3, r3, #2
 926 0040 0421     		movs	r1, #4
 927 0042 0B40     		ands	r3, r1
 928 0044 1A43     		orrs	r2, r3
 441:../drivers/fsl_spi.c **** 
 929              		.loc 1 441 0
 930 0046 2B7A     		ldrb	r3, [r5, #8]
 931 0048 5B00     		lsls	r3, r3, #1
 932 004a 0220     		movs	r0, #2
 933 004c 0340     		ands	r3, r0
 440:../drivers/fsl_spi.c ****                SPI_C1_SSOE(config->outputMode & 1U) | SPI_C1_LSBFE(config->direction);
 934              		.loc 1 440 0
 935 004e 1A43     		orrs	r2, r3
 441:../drivers/fsl_spi.c **** 
 936              		.loc 1 441 0
 937 0050 2B79     		ldrb	r3, [r5, #4]
 938 0052 0339     		subs	r1, r1, #3
 939 0054 0B40     		ands	r3, r1
 940 0056 1A43     		orrs	r2, r3
 941 0058 1023     		movs	r3, #16
 942 005a 1A43     		orrs	r2, r3
 440:../drivers/fsl_spi.c ****                SPI_C1_SSOE(config->outputMode & 1U) | SPI_C1_LSBFE(config->direction);
 943              		.loc 1 440 0
 944 005c F270     		strb	r2, [r6, #3]
 445:../drivers/fsl_spi.c ****                SPI_C2_SPISWAI(config->enableStopInWaitMode) | SPI_C2_SPC0(config->pinMode & 1U) |
 945              		.loc 1 445 0
 946 005e 2A7A     		ldrb	r2, [r5, #8]
 947 0060 5208     		lsrs	r2, r2, #1
 948 0062 1201     		lsls	r2, r2, #4
 949 0064 1023     		movs	r3, #16
 950 0066 1A40     		ands	r2, r3
 951 0068 6C7A     		ldrb	r4, [r5, #9]
 952 006a 6308     		lsrs	r3, r4, #1
 953 006c DB00     		lsls	r3, r3, #3
 954 006e 3B40     		ands	r3, r7
 955 0070 1343     		orrs	r3, r2
 446:../drivers/fsl_spi.c ****                SPI_C2_SPIMODE(config->dataMode);
 956              		.loc 1 446 0
 957 0072 6A78     		ldrb	r2, [r5, #1]
 958 0074 5200     		lsls	r2, r2, #1
 959 0076 1040     		ands	r0, r2
 445:../drivers/fsl_spi.c ****                SPI_C2_SPISWAI(config->enableStopInWaitMode) | SPI_C2_SPC0(config->pinMode & 1U) |
 960              		.loc 1 445 0
 961 0078 0343     		orrs	r3, r0
 446:../drivers/fsl_spi.c ****                SPI_C2_SPIMODE(config->dataMode);
 962              		.loc 1 446 0
 963 007a 2140     		ands	r1, r4
 964 007c 0B43     		orrs	r3, r1
 447:../drivers/fsl_spi.c **** #else
 965              		.loc 1 447 0
 966 007e 6A79     		ldrb	r2, [r5, #5]
 967 0080 9201     		lsls	r2, r2, #6
 968 0082 4021     		movs	r1, #64
 969 0084 0A40     		ands	r2, r1
 446:../drivers/fsl_spi.c ****                SPI_C2_SPIMODE(config->dataMode);
 970              		.loc 1 446 0
 971 0086 1343     		orrs	r3, r2
 445:../drivers/fsl_spi.c ****                SPI_C2_SPISWAI(config->enableStopInWaitMode) | SPI_C2_SPC0(config->pinMode & 1U) |
 972              		.loc 1 445 0
 973 0088 B370     		strb	r3, [r6, #2]
 455:../drivers/fsl_spi.c ****     {
 974              		.loc 1 455 0
 975 008a 124B     		ldr	r3, .L71+8
 976 008c 9E42     		cmp	r6, r3
 977 008e 0BD0     		beq	.L69
 457:../drivers/fsl_spi.c ****                    SPI_C3_INTCLR(0U) | SPI_C3_FIFOMODE(1U);
 978              		.loc 1 457 0
 979 0090 AB79     		ldrb	r3, [r5, #6]
 980 0092 5B01     		lsls	r3, r3, #5
 981 0094 2022     		movs	r2, #32
 982 0096 1340     		ands	r3, r2
 983 0098 EA79     		ldrb	r2, [r5, #7]
 984 009a 1201     		lsls	r2, r2, #4
 985 009c 3039     		subs	r1, r1, #48
 986 009e 0A40     		ands	r2, r1
 987 00a0 1343     		orrs	r3, r2
 458:../drivers/fsl_spi.c ****     }
 988              		.loc 1 458 0
 989 00a2 0122     		movs	r2, #1
 990 00a4 1343     		orrs	r3, r2
 457:../drivers/fsl_spi.c ****                    SPI_C3_INTCLR(0U) | SPI_C3_FIFOMODE(1U);
 991              		.loc 1 457 0
 992 00a6 F372     		strb	r3, [r6, #11]
 993              	.L69:
 463:../drivers/fsl_spi.c **** 
 994              		.loc 1 463 0
 995 00a8 019A     		ldr	r2, [sp, #4]
 996 00aa E968     		ldr	r1, [r5, #12]
 997 00ac 3000     		movs	r0, r6
 998 00ae FFF7FEFF 		bl	SPI_MasterSetBaudRate
 999              	.LVL73:
 466:../drivers/fsl_spi.c **** 
 1000              		.loc 1 466 0
 1001 00b2 FF21     		movs	r1, #255
 1002 00b4 3000     		movs	r0, r6
 1003 00b6 FFF7FEFF 		bl	SPI_SetDummyData
 1004              	.LVL74:
 469:../drivers/fsl_spi.c ****     {
 1005              		.loc 1 469 0
 1006 00ba 2B78     		ldrb	r3, [r5]
 1007 00bc 002B     		cmp	r3, #0
 1008 00be 03D0     		beq	.L68
 471:../drivers/fsl_spi.c ****     }
 1009              		.loc 1 471 0
 1010 00c0 F378     		ldrb	r3, [r6, #3]
 1011 00c2 4022     		movs	r2, #64
 1012 00c4 1343     		orrs	r3, r2
 1013 00c6 F370     		strb	r3, [r6, #3]
 1014              	.L68:
 473:../drivers/fsl_spi.c **** 
 1015              		.loc 1 473 0
 1016 00c8 03B0     		add	sp, sp, #12
 1017              		@ sp needed
 1018              	.LVL75:
 1019              	.LVL76:
 1020 00ca F0BD     		pop	{r4, r5, r6, r7, pc}
 1021              	.L72:
 1022              		.align	2
 1023              	.L71:
 1024 00cc 00000000 		.word	.LANCHOR5
 1025 00d0 00700440 		.word	1074032640
 1026 00d4 00600740 		.word	1074225152
 1027              		.cfi_endproc
 1028              	.LFE71:
 1030              		.section	.text.SPI_EnableFIFO,"ax",%progbits
 1031              		.align	1
 1032              		.global	SPI_EnableFIFO
 1033              		.syntax unified
 1034              		.code	16
 1035              		.thumb_func
 1036              		.fpu softvfp
 1038              	SPI_EnableFIFO:
 1039              	.LFB80:
 721:../drivers/fsl_spi.c ****     if (FSL_FEATURE_SPI_FIFO_SIZEn(base) != 0U)
 1040              		.loc 1 721 0
 1041              		.cfi_startproc
 1042              		@ args = 0, pretend = 0, frame = 0
 1043              		@ frame_needed = 0, uses_anonymous_args = 0
 1044              		@ link register save eliminated.
 1045              	.LVL77:
 722:../drivers/fsl_spi.c ****     {
 1046              		.loc 1 722 0
 1047 0000 074B     		ldr	r3, .L77
 1048 0002 9842     		cmp	r0, r3
 1049 0004 05D0     		beq	.L73
 724:../drivers/fsl_spi.c ****         {
 1050              		.loc 1 724 0
 1051 0006 0029     		cmp	r1, #0
 1052 0008 04D1     		bne	.L76
 730:../drivers/fsl_spi.c ****         }
 1053              		.loc 1 730 0
 1054 000a C37A     		ldrb	r3, [r0, #11]
 1055 000c 0122     		movs	r2, #1
 1056 000e 9343     		bics	r3, r2
 1057 0010 C372     		strb	r3, [r0, #11]
 1058              	.L73:
 733:../drivers/fsl_spi.c **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 1059              		.loc 1 733 0
 1060              		@ sp needed
 1061 0012 7047     		bx	lr
 1062              	.L76:
 726:../drivers/fsl_spi.c ****         }
 1063              		.loc 1 726 0
 1064 0014 C37A     		ldrb	r3, [r0, #11]
 1065 0016 0122     		movs	r2, #1
 1066 0018 1343     		orrs	r3, r2
 1067 001a C372     		strb	r3, [r0, #11]
 1068 001c F9E7     		b	.L73
 1069              	.L78:
 1070 001e C046     		.align	2
 1071              	.L77:
 1072 0020 00600740 		.word	1074225152
 1073              		.cfi_endproc
 1074              	.LFE80:
 1076              		.section	.text.SPI_WriteData,"ax",%progbits
 1077              		.align	1
 1078              		.global	SPI_WriteData
 1079              		.syntax unified
 1080              		.code	16
 1081              		.thumb_func
 1082              		.fpu softvfp
 1084              	SPI_WriteData:
 1085              	.LFB81:
 737:../drivers/fsl_spi.c **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && (FSL_FEATURE_SPI_16BIT_TRANSFERS)
 1086              		.loc 1 737 0
 1087              		.cfi_startproc
 1088              		@ args = 0, pretend = 0, frame = 0
 1089              		@ frame_needed = 0, uses_anonymous_args = 0
 1090              		@ link register save eliminated.
 1091              	.LVL78:
 739:../drivers/fsl_spi.c ****     base->DH = (data >> 8U) & 0xFFU;
 1092              		.loc 1 739 0
 1093 0000 CBB2     		uxtb	r3, r1
 1094 0002 8371     		strb	r3, [r0, #6]
 740:../drivers/fsl_spi.c **** #else
 1095              		.loc 1 740 0
 1096 0004 090A     		lsrs	r1, r1, #8
 1097              	.LVL79:
 1098 0006 C171     		strb	r1, [r0, #7]
 744:../drivers/fsl_spi.c **** 
 1099              		.loc 1 744 0
 1100              		@ sp needed
 1101 0008 7047     		bx	lr
 1102              		.cfi_endproc
 1103              	.LFE81:
 1105              		.section	.text.SPI_WriteNonBlocking,"ax",%progbits
 1106              		.align	1
 1107              		.syntax unified
 1108              		.code	16
 1109              		.thumb_func
 1110              		.fpu softvfp
 1112              	SPI_WriteNonBlocking:
 1113              	.LFB64:
 165:../drivers/fsl_spi.c ****     uint32_t i = 0;
 1114              		.loc 1 165 0
 1115              		.cfi_startproc
 1116              		@ args = 0, pretend = 0, frame = 0
 1117              		@ frame_needed = 0, uses_anonymous_args = 0
 1118              	.LVL80:
 1119 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1120              		.cfi_def_cfa_offset 24
 1121              		.cfi_offset 3, -24
 1122              		.cfi_offset 4, -20
 1123              		.cfi_offset 5, -16
 1124              		.cfi_offset 6, -12
 1125              		.cfi_offset 7, -8
 1126              		.cfi_offset 14, -4
 1127 0002 CE46     		mov	lr, r9
 1128 0004 4746     		mov	r7, r8
 1129 0006 80B5     		push	{r7, lr}
 1130              		.cfi_def_cfa_offset 32
 1131              		.cfi_offset 8, -32
 1132              		.cfi_offset 9, -28
 1133 0008 0600     		movs	r6, r0
 1134 000a 0C00     		movs	r4, r1
 1135 000c 9046     		mov	r8, r2
 1136              	.LVL81:
 168:../drivers/fsl_spi.c **** 
 1137              		.loc 1 168 0
 1138 000e FFF7FEFF 		bl	SPI_GetInstance
 1139              	.LVL82:
 1140 0012 8146     		mov	r9, r0
 1141              	.LVL83:
 172:../drivers/fsl_spi.c **** #endif
 1142              		.loc 1 172 0
 1143 0014 B378     		ldrb	r3, [r6, #2]
 1144 0016 9B09     		lsrs	r3, r3, #6
 1145 0018 0127     		movs	r7, #1
 1146 001a 1F40     		ands	r7, r3
 1147 001c 0137     		adds	r7, r7, #1
 1148              	.LVL84:
 166:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 1149              		.loc 1 166 0
 1150 001e 0025     		movs	r5, #0
 175:../drivers/fsl_spi.c ****     {
 1151              		.loc 1 175 0
 1152 0020 03E0     		b	.L81
 1153              	.LVL85:
 1154              	.L83:
 189:../drivers/fsl_spi.c ****             }
 1155              		.loc 1 189 0
 1156 0022 2378     		ldrb	r3, [r4]
 1157 0024 B371     		strb	r3, [r6, #6]
 1158 0026 0134     		adds	r4, r4, #1
 1159              	.LVL86:
 1160              	.L84:
 200:../drivers/fsl_spi.c ****     }
 1161              		.loc 1 200 0
 1162 0028 ED19     		adds	r5, r5, r7
 1163              	.LVL87:
 1164              	.L81:
 175:../drivers/fsl_spi.c ****     {
 1165              		.loc 1 175 0
 1166 002a 4545     		cmp	r5, r8
 1167 002c 14D2     		bcs	.L86
 177:../drivers/fsl_spi.c ****         {
 1168              		.loc 1 177 0
 1169 002e 002C     		cmp	r4, #0
 1170 0030 08D0     		beq	.L82
 181:../drivers/fsl_spi.c ****             {
 1171              		.loc 1 181 0
 1172 0032 B378     		ldrb	r3, [r6, #2]
 1173 0034 5B06     		lsls	r3, r3, #25
 1174 0036 F4D5     		bpl	.L83
 1175              	.LVL88:
 183:../drivers/fsl_spi.c ****                 base->DH = *buffer++;
 1176              		.loc 1 183 0
 1177 0038 2378     		ldrb	r3, [r4]
 1178 003a B371     		strb	r3, [r6, #6]
 1179              	.LVL89:
 184:../drivers/fsl_spi.c ****             }
 1180              		.loc 1 184 0
 1181 003c 6378     		ldrb	r3, [r4, #1]
 1182 003e F371     		strb	r3, [r6, #7]
 1183 0040 0234     		adds	r4, r4, #2
 1184              	.LVL90:
 1185 0042 F1E7     		b	.L84
 1186              	.L82:
 198:../drivers/fsl_spi.c ****         }
 1187              		.loc 1 198 0
 1188 0044 064B     		ldr	r3, .L87
 1189 0046 4A46     		mov	r2, r9
 1190 0048 995C     		ldrb	r1, [r3, r2]
 1191 004a 0902     		lsls	r1, r1, #8
 1192 004c 9B5C     		ldrb	r3, [r3, r2]
 1193 004e 1943     		orrs	r1, r3
 1194 0050 3000     		movs	r0, r6
 1195 0052 FFF7FEFF 		bl	SPI_WriteData
 1196              	.LVL91:
 1197 0056 E7E7     		b	.L84
 1198              	.L86:
 202:../drivers/fsl_spi.c **** 
 1199              		.loc 1 202 0
 1200              		@ sp needed
 1201              	.LVL92:
 1202              	.LVL93:
 1203              	.LVL94:
 1204              	.LVL95:
 1205              	.LVL96:
 1206              	.LVL97:
 1207 0058 0CBC     		pop	{r2, r3}
 1208 005a 9046     		mov	r8, r2
 1209 005c 9946     		mov	r9, r3
 1210 005e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1211              	.L88:
 1212              		.align	2
 1213              	.L87:
 1214 0060 00000000 		.word	.LANCHOR4
 1215              		.cfi_endproc
 1216              	.LFE64:
 1218              		.section	.text.SPI_WriteBlocking,"ax",%progbits
 1219              		.align	1
 1220              		.global	SPI_WriteBlocking
 1221              		.syntax unified
 1222              		.code	16
 1223              		.thumb_func
 1224              		.fpu softvfp
 1226              	SPI_WriteBlocking:
 1227              	.LFB79:
 696:../drivers/fsl_spi.c ****     uint32_t i = 0;
 1228              		.loc 1 696 0
 1229              		.cfi_startproc
 1230              		@ args = 0, pretend = 0, frame = 0
 1231              		@ frame_needed = 0, uses_anonymous_args = 0
 1232              	.LVL98:
 1233 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1234              		.cfi_def_cfa_offset 20
 1235              		.cfi_offset 4, -20
 1236              		.cfi_offset 5, -16
 1237              		.cfi_offset 6, -12
 1238              		.cfi_offset 7, -8
 1239              		.cfi_offset 14, -4
 1240 0002 C646     		mov	lr, r8
 1241 0004 00B5     		push	{lr}
 1242              		.cfi_def_cfa_offset 24
 1243              		.cfi_offset 8, -24
 1244 0006 0400     		movs	r4, r0
 1245 0008 0F00     		movs	r7, r1
 1246 000a 9046     		mov	r8, r2
 1247              	.LVL99:
 702:../drivers/fsl_spi.c **** #endif
 1248              		.loc 1 702 0
 1249 000c 8378     		ldrb	r3, [r0, #2]
 1250 000e 9B09     		lsrs	r3, r3, #6
 1251 0010 0125     		movs	r5, #1
 1252 0012 1D40     		ands	r5, r3
 1253 0014 0135     		adds	r5, r5, #1
 1254              	.LVL100:
 697:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 1255              		.loc 1 697 0
 1256 0016 0026     		movs	r6, #0
 705:../drivers/fsl_spi.c ****     {
 1257              		.loc 1 705 0
 1258 0018 09E0     		b	.L90
 1259              	.LVL101:
 1260              	.L91:
 707:../drivers/fsl_spi.c ****         {
 1261              		.loc 1 707 0 discriminator 1
 1262 001a 2378     		ldrb	r3, [r4]
 1263 001c 9B06     		lsls	r3, r3, #26
 1264 001e FCD5     		bpl	.L91
 712:../drivers/fsl_spi.c **** 
 1265              		.loc 1 712 0
 1266 0020 2A00     		movs	r2, r5
 1267 0022 3900     		movs	r1, r7
 1268 0024 2000     		movs	r0, r4
 1269 0026 FFF7FEFF 		bl	SPI_WriteNonBlocking
 1270              	.LVL102:
 714:../drivers/fsl_spi.c ****         buffer += bytesPerFrame;
 1271              		.loc 1 714 0
 1272 002a 7619     		adds	r6, r6, r5
 1273              	.LVL103:
 715:../drivers/fsl_spi.c ****     }
 1274              		.loc 1 715 0
 1275 002c 7F19     		adds	r7, r7, r5
 1276              	.LVL104:
 1277              	.L90:
 705:../drivers/fsl_spi.c ****     {
 1278              		.loc 1 705 0
 1279 002e 4645     		cmp	r6, r8
 1280 0030 F3D3     		bcc	.L91
 717:../drivers/fsl_spi.c **** 
 1281              		.loc 1 717 0
 1282              		@ sp needed
 1283              	.LVL105:
 1284              	.LVL106:
 1285              	.LVL107:
 1286              	.LVL108:
 1287              	.LVL109:
 1288 0032 04BC     		pop	{r2}
 1289 0034 9046     		mov	r8, r2
 1290 0036 F0BD     		pop	{r4, r5, r6, r7, pc}
 1291              		.cfi_endproc
 1292              	.LFE79:
 1294              		.section	.text.SPI_SendInitialTransfer,"ax",%progbits
 1295              		.align	1
 1296              		.syntax unified
 1297              		.code	16
 1298              		.thumb_func
 1299              		.fpu softvfp
 1301              	SPI_SendInitialTransfer:
 1302              	.LFB67:
 273:../drivers/fsl_spi.c ****     uint8_t bytestoTransfer = handle->bytePerFrame;
 1303              		.loc 1 273 0
 1304              		.cfi_startproc
 1305              		@ args = 0, pretend = 0, frame = 0
 1306              		@ frame_needed = 0, uses_anonymous_args = 0
 1307              	.LVL110:
 1308 0000 70B5     		push	{r4, r5, r6, lr}
 1309              		.cfi_def_cfa_offset 16
 1310              		.cfi_offset 4, -16
 1311              		.cfi_offset 5, -12
 1312              		.cfi_offset 6, -8
 1313              		.cfi_offset 14, -4
 1314 0002 0C00     		movs	r4, r1
 274:../drivers/fsl_spi.c **** 
 1315              		.loc 1 274 0
 1316 0004 0D7E     		ldrb	r5, [r1, #24]
 1317              	.LVL111:
 277:../drivers/fsl_spi.c ****     {
 1318              		.loc 1 277 0
 1319 0006 4B7E     		ldrb	r3, [r1, #25]
 1320 0008 012B     		cmp	r3, #1
 1321 000a 0CD9     		bls	.L93
 283:../drivers/fsl_spi.c ****     }
 1322              		.loc 1 283 0
 1323 000c 8B68     		ldr	r3, [r1, #8]
 1324 000e 154A     		ldr	r2, .L103
 1325 0010 9042     		cmp	r0, r2
 1326 0012 19D0     		beq	.L97
 283:../drivers/fsl_spi.c ****     }
 1327              		.loc 1 283 0 is_stmt 0 discriminator 1
 1328 0014 144A     		ldr	r2, .L103+4
 1329 0016 9042     		cmp	r0, r2
 1330 0018 14D0     		beq	.L101
 283:../drivers/fsl_spi.c ****     }
 1331              		.loc 1 283 0
 1332 001a 0222     		movs	r2, #2
 1333 001c 5242     		rsbs	r2, r2, #0
 1334              	.L94:
 283:../drivers/fsl_spi.c ****     }
 1335              		.loc 1 283 0 discriminator 8
 1336 001e 9342     		cmp	r3, r2
 1337 0020 14D2     		bcs	.L95
 283:../drivers/fsl_spi.c ****     }
 1338              		.loc 1 283 0 discriminator 9
 1339 0022 A568     		ldr	r5, [r4, #8]
 1340              	.LVL112:
 1341 0024 EDB2     		uxtb	r5, r5
 1342              	.L93:
 1343              	.LVL113:
 287:../drivers/fsl_spi.c **** 
 1344              		.loc 1 287 0 is_stmt 1
 1345 0026 2168     		ldr	r1, [r4]
 1346              	.LVL114:
 1347 0028 2E00     		movs	r6, r5
 1348 002a 2A00     		movs	r2, r5
 1349 002c FFF7FEFF 		bl	SPI_WriteNonBlocking
 1350              	.LVL115:
 290:../drivers/fsl_spi.c ****     {
 1351              		.loc 1 290 0
 1352 0030 2368     		ldr	r3, [r4]
 1353 0032 002B     		cmp	r3, #0
 1354 0034 02D0     		beq	.L96
 292:../drivers/fsl_spi.c ****     }
 1355              		.loc 1 292 0
 1356 0036 2368     		ldr	r3, [r4]
 1357 0038 5D19     		adds	r5, r3, r5
 1358              	.LVL116:
 1359 003a 2560     		str	r5, [r4]
 1360              	.L96:
 294:../drivers/fsl_spi.c **** }
 1361              		.loc 1 294 0
 1362 003c A368     		ldr	r3, [r4, #8]
 1363 003e 9B1B     		subs	r3, r3, r6
 1364 0040 A360     		str	r3, [r4, #8]
 295:../drivers/fsl_spi.c **** 
 1365              		.loc 1 295 0
 1366              		@ sp needed
 1367              	.LVL117:
 1368 0042 70BD     		pop	{r4, r5, r6, pc}
 1369              	.LVL118:
 1370              	.L101:
 283:../drivers/fsl_spi.c ****     }
 1371              		.loc 1 283 0
 1372 0044 0822     		movs	r2, #8
 1373 0046 EAE7     		b	.L94
 1374              	.L97:
 1375 0048 0022     		movs	r2, #0
 1376 004a E8E7     		b	.L94
 1377              	.L95:
 283:../drivers/fsl_spi.c ****     }
 1378              		.loc 1 283 0 is_stmt 0 discriminator 10
 1379 004c 054B     		ldr	r3, .L103
 1380 004e 9842     		cmp	r0, r3
 1381 0050 06D0     		beq	.L99
 283:../drivers/fsl_spi.c ****     }
 1382              		.loc 1 283 0 discriminator 12
 1383 0052 054B     		ldr	r3, .L103+4
 1384 0054 9842     		cmp	r0, r3
 1385 0056 01D0     		beq	.L102
 283:../drivers/fsl_spi.c ****     }
 1386              		.loc 1 283 0
 1387 0058 FE25     		movs	r5, #254
 1388              	.LVL119:
 1389 005a E4E7     		b	.L93
 1390              	.LVL120:
 1391              	.L102:
 1392 005c 0825     		movs	r5, #8
 1393              	.LVL121:
 1394 005e E2E7     		b	.L93
 1395              	.LVL122:
 1396              	.L99:
 1397 0060 0025     		movs	r5, #0
 1398              	.LVL123:
 1399 0062 E0E7     		b	.L93
 1400              	.L104:
 1401              		.align	2
 1402              	.L103:
 1403 0064 00600740 		.word	1074225152
 1404 0068 00700740 		.word	1074229248
 1405              		.cfi_endproc
 1406              	.LFE67:
 1408              		.section	.text.SPI_SendTransfer,"ax",%progbits
 1409              		.align	1
 1410              		.syntax unified
 1411              		.code	16
 1412              		.thumb_func
 1413              		.fpu softvfp
 1415              	SPI_SendTransfer:
 1416              	.LFB68:
 298:../drivers/fsl_spi.c ****     uint8_t bytes = handle->bytePerFrame;
 1417              		.loc 1 298 0 is_stmt 1
 1418              		.cfi_startproc
 1419              		@ args = 0, pretend = 0, frame = 0
 1420              		@ frame_needed = 0, uses_anonymous_args = 0
 1421              	.LVL124:
 1422 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1423              		.cfi_def_cfa_offset 24
 1424              		.cfi_offset 3, -24
 1425              		.cfi_offset 4, -20
 1426              		.cfi_offset 5, -16
 1427              		.cfi_offset 6, -12
 1428              		.cfi_offset 7, -8
 1429              		.cfi_offset 14, -4
 1430 0002 0600     		movs	r6, r0
 1431 0004 0C00     		movs	r4, r1
 299:../drivers/fsl_spi.c **** 
 1432              		.loc 1 299 0
 1433 0006 0F7E     		ldrb	r7, [r1, #24]
 1434              	.LVL125:
 302:../drivers/fsl_spi.c ****     {
 1435              		.loc 1 302 0
 1436 0008 4D7E     		ldrb	r5, [r1, #25]
 1437 000a 012D     		cmp	r5, #1
 1438 000c 16D0     		beq	.L114
 1439              	.LBB22:
 341:../drivers/fsl_spi.c **** 
 1440              		.loc 1 341 0
 1441 000e 6D00     		lsls	r5, r5, #1
 1442 0010 EDB2     		uxtb	r5, r5
 1443              	.LVL126:
 343:../drivers/fsl_spi.c ****         {
 1444              		.loc 1 343 0
 1445 0012 8B68     		ldr	r3, [r1, #8]
 1446 0014 072B     		cmp	r3, #7
 1447 0016 01D8     		bhi	.L112
 345:../drivers/fsl_spi.c ****         }
 1448              		.loc 1 345 0
 1449 0018 8D68     		ldr	r5, [r1, #8]
 1450              	.LVL127:
 1451 001a EDB2     		uxtb	r5, r5
 1452              	.LVL128:
 1453              	.L112:
 348:../drivers/fsl_spi.c **** 
 1454              		.loc 1 348 0
 1455 001c 2168     		ldr	r1, [r4]
 1456              	.LVL129:
 1457 001e 2F00     		movs	r7, r5
 1458              	.LVL130:
 1459 0020 2A00     		movs	r2, r5
 1460 0022 3000     		movs	r0, r6
 1461              	.LVL131:
 1462 0024 FFF7FEFF 		bl	SPI_WriteNonBlocking
 1463              	.LVL132:
 351:../drivers/fsl_spi.c ****         {
 1464              		.loc 1 351 0
 1465 0028 2368     		ldr	r3, [r4]
 1466 002a 002B     		cmp	r3, #0
 1467 002c 02D0     		beq	.L113
 353:../drivers/fsl_spi.c ****         }
 1468              		.loc 1 353 0
 1469 002e 2368     		ldr	r3, [r4]
 1470 0030 5D19     		adds	r5, r3, r5
 1471              	.LVL133:
 1472 0032 2560     		str	r5, [r4]
 1473              	.L113:
 355:../drivers/fsl_spi.c ****     }
 1474              		.loc 1 355 0
 1475 0034 A368     		ldr	r3, [r4, #8]
 1476 0036 DB1B     		subs	r3, r3, r7
 1477 0038 A360     		str	r3, [r4, #8]
 1478              	.L105:
 1479              	.LBE22:
 358:../drivers/fsl_spi.c **** 
 1480              		.loc 1 358 0
 1481              		@ sp needed
 1482              	.LVL134:
 1483              	.LVL135:
 1484 003a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1485              	.LVL136:
 1486              	.L114:
 305:../drivers/fsl_spi.c ****         {
 1487              		.loc 1 305 0
 1488 003c C378     		ldrb	r3, [r0, #3]
 1489 003e DB06     		lsls	r3, r3, #27
 1490 0040 13D5     		bpl	.L107
 308:../drivers/fsl_spi.c ****             {
 1491              		.loc 1 308 0
 1492 0042 0378     		ldrb	r3, [r0]
 1493 0044 9B06     		lsls	r3, r3, #26
 1494 0046 F8D5     		bpl	.L105
 310:../drivers/fsl_spi.c ****                 /* Update handle information */
 1495              		.loc 1 310 0
 1496 0048 0968     		ldr	r1, [r1]
 1497              	.LVL137:
 1498 004a 3A00     		movs	r2, r7
 1499 004c FFF7FEFF 		bl	SPI_WriteNonBlocking
 1500              	.LVL138:
 312:../drivers/fsl_spi.c ****                 {
 1501              		.loc 1 312 0
 1502 0050 2368     		ldr	r3, [r4]
 1503 0052 002B     		cmp	r3, #0
 1504 0054 02D0     		beq	.L109
 314:../drivers/fsl_spi.c ****                 }
 1505              		.loc 1 314 0
 1506 0056 2368     		ldr	r3, [r4]
 1507 0058 DB19     		adds	r3, r3, r7
 1508 005a 2360     		str	r3, [r4]
 1509              	.L109:
 316:../drivers/fsl_spi.c ****             }
 1510              		.loc 1 316 0
 1511 005c A368     		ldr	r3, [r4, #8]
 1512 005e DF1B     		subs	r7, r3, r7
 1513              	.LVL139:
 1514 0060 A760     		str	r7, [r4, #8]
 1515 0062 EAE7     		b	.L105
 1516              	.LVL140:
 1517              	.L110:
 331:../drivers/fsl_spi.c ****             }
 1518              		.loc 1 331 0
 1519 0064 A368     		ldr	r3, [r4, #8]
 1520 0066 DB1B     		subs	r3, r3, r7
 1521 0068 A360     		str	r3, [r4, #8]
 1522              	.L107:
 322:../drivers/fsl_spi.c ****             {
 1523              		.loc 1 322 0
 1524 006a 3378     		ldrb	r3, [r6]
 1525 006c 9B06     		lsls	r3, r3, #26
 1526 006e E4D5     		bpl	.L105
 322:../drivers/fsl_spi.c ****             {
 1527              		.loc 1 322 0 is_stmt 0 discriminator 1
 1528 0070 A368     		ldr	r3, [r4, #8]
 1529 0072 BB42     		cmp	r3, r7
 1530 0074 E1D3     		bcc	.L105
 324:../drivers/fsl_spi.c **** 
 1531              		.loc 1 324 0 is_stmt 1
 1532 0076 2168     		ldr	r1, [r4]
 1533 0078 3A00     		movs	r2, r7
 1534 007a 3000     		movs	r0, r6
 1535 007c FFF7FEFF 		bl	SPI_WriteNonBlocking
 1536              	.LVL141:
 327:../drivers/fsl_spi.c ****                 {
 1537              		.loc 1 327 0
 1538 0080 2368     		ldr	r3, [r4]
 1539 0082 002B     		cmp	r3, #0
 1540 0084 EED0     		beq	.L110
 329:../drivers/fsl_spi.c ****                 }
 1541              		.loc 1 329 0
 1542 0086 2368     		ldr	r3, [r4]
 1543 0088 DB19     		adds	r3, r3, r7
 1544 008a 2360     		str	r3, [r4]
 1545 008c EAE7     		b	.L110
 1546              		.cfi_endproc
 1547              	.LFE68:
 1549              		.section	.text.SPI_ReadData,"ax",%progbits
 1550              		.align	1
 1551              		.global	SPI_ReadData
 1552              		.syntax unified
 1553              		.code	16
 1554              		.thumb_func
 1555              		.fpu softvfp
 1557              	SPI_ReadData:
 1558              	.LFB82:
 747:../drivers/fsl_spi.c ****     uint16_t val = 0;
 1559              		.loc 1 747 0
 1560              		.cfi_startproc
 1561              		@ args = 0, pretend = 0, frame = 0
 1562              		@ frame_needed = 0, uses_anonymous_args = 0
 1563              		@ link register save eliminated.
 1564              	.LVL142:
 750:../drivers/fsl_spi.c ****     val |= (uint16_t)((uint16_t)(base->DH) << 8U);
 1565              		.loc 1 750 0
 1566 0000 8379     		ldrb	r3, [r0, #6]
 1567              	.LVL143:
 751:../drivers/fsl_spi.c **** #else
 1568              		.loc 1 751 0
 1569 0002 C079     		ldrb	r0, [r0, #7]
 1570              	.LVL144:
 1571 0004 0002     		lsls	r0, r0, #8
 1572 0006 1843     		orrs	r0, r3
 1573              	.LVL145:
 756:../drivers/fsl_spi.c **** 
 1574              		.loc 1 756 0
 1575              		@ sp needed
 1576 0008 7047     		bx	lr
 1577              		.cfi_endproc
 1578              	.LFE82:
 1580              		.section	.text.SPI_ReadNonBlocking,"ax",%progbits
 1581              		.align	1
 1582              		.syntax unified
 1583              		.code	16
 1584              		.thumb_func
 1585              		.fpu softvfp
 1587              	SPI_ReadNonBlocking:
 1588              	.LFB65:
 205:../drivers/fsl_spi.c ****     uint32_t i = 0;
 1589              		.loc 1 205 0
 1590              		.cfi_startproc
 1591              		@ args = 0, pretend = 0, frame = 0
 1592              		@ frame_needed = 0, uses_anonymous_args = 0
 1593              	.LVL146:
 1594 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1595              		.cfi_def_cfa_offset 20
 1596              		.cfi_offset 4, -20
 1597              		.cfi_offset 5, -16
 1598              		.cfi_offset 6, -12
 1599              		.cfi_offset 7, -8
 1600              		.cfi_offset 14, -4
 1601 0002 C646     		mov	lr, r8
 1602 0004 00B5     		push	{lr}
 1603              		.cfi_def_cfa_offset 24
 1604              		.cfi_offset 8, -24
 1605 0006 0600     		movs	r6, r0
 1606 0008 0C00     		movs	r4, r1
 1607 000a 9046     		mov	r8, r2
 1608              	.LVL147:
 211:../drivers/fsl_spi.c **** #endif
 1609              		.loc 1 211 0
 1610 000c 8378     		ldrb	r3, [r0, #2]
 1611 000e 9B09     		lsrs	r3, r3, #6
 1612 0010 0127     		movs	r7, #1
 1613 0012 1F40     		ands	r7, r3
 1614 0014 0137     		adds	r7, r7, #1
 1615              	.LVL148:
 206:../drivers/fsl_spi.c ****     uint8_t bytesPerFrame = 1U;
 1616              		.loc 1 206 0
 1617 0016 0025     		movs	r5, #0
 214:../drivers/fsl_spi.c ****     {
 1618              		.loc 1 214 0
 1619 0018 03E0     		b	.L117
 1620              	.LVL149:
 1621              	.L119:
 228:../drivers/fsl_spi.c ****             }
 1622              		.loc 1 228 0
 1623 001a B379     		ldrb	r3, [r6, #6]
 1624 001c 2370     		strb	r3, [r4]
 1625 001e 0134     		adds	r4, r4, #1
 1626              	.LVL150:
 1627              	.L120:
 238:../drivers/fsl_spi.c ****     }
 1628              		.loc 1 238 0
 1629 0020 ED19     		adds	r5, r5, r7
 1630              	.LVL151:
 1631              	.L117:
 214:../drivers/fsl_spi.c ****     {
 1632              		.loc 1 214 0
 1633 0022 4545     		cmp	r5, r8
 1634 0024 0ED2     		bcs	.L122
 216:../drivers/fsl_spi.c ****         {
 1635              		.loc 1 216 0
 1636 0026 002C     		cmp	r4, #0
 1637 0028 08D0     		beq	.L118
 220:../drivers/fsl_spi.c ****             {
 1638              		.loc 1 220 0
 1639 002a B378     		ldrb	r3, [r6, #2]
 1640 002c 5B06     		lsls	r3, r3, #25
 1641 002e F4D5     		bpl	.L119
 1642              	.LVL152:
 222:../drivers/fsl_spi.c ****                 *buffer++ = base->DH;
 1643              		.loc 1 222 0
 1644 0030 B379     		ldrb	r3, [r6, #6]
 1645 0032 2370     		strb	r3, [r4]
 1646              	.LVL153:
 223:../drivers/fsl_spi.c ****             }
 1647              		.loc 1 223 0
 1648 0034 F379     		ldrb	r3, [r6, #7]
 1649 0036 6370     		strb	r3, [r4, #1]
 1650 0038 0234     		adds	r4, r4, #2
 1651              	.LVL154:
 1652 003a F1E7     		b	.L120
 1653              	.L118:
 236:../drivers/fsl_spi.c ****         }
 1654              		.loc 1 236 0
 1655 003c 3000     		movs	r0, r6
 1656 003e FFF7FEFF 		bl	SPI_ReadData
 1657              	.LVL155:
 1658 0042 EDE7     		b	.L120
 1659              	.L122:
 240:../drivers/fsl_spi.c **** 
 1660              		.loc 1 240 0
 1661              		@ sp needed
 1662              	.LVL156:
 1663              	.LVL157:
 1664              	.LVL158:
 1665              	.LVL159:
 1666              	.LVL160:
 1667 0044 04BC     		pop	{r2}
 1668 0046 9046     		mov	r8, r2
 1669 0048 F0BD     		pop	{r4, r5, r6, r7, pc}
 1670              		.cfi_endproc
 1671              	.LFE65:
 1673              		.section	.text.SPI_ReceiveTransfer,"ax",%progbits
 1674              		.align	1
 1675              		.syntax unified
 1676              		.code	16
 1677              		.thumb_func
 1678              		.fpu softvfp
 1680              	SPI_ReceiveTransfer:
 1681              	.LFB69:
 361:../drivers/fsl_spi.c ****     uint8_t bytes = handle->bytePerFrame;
 1682              		.loc 1 361 0
 1683              		.cfi_startproc
 1684              		@ args = 0, pretend = 0, frame = 0
 1685              		@ frame_needed = 0, uses_anonymous_args = 0
 1686              	.LVL161:
 1687 0000 70B5     		push	{r4, r5, r6, lr}
 1688              		.cfi_def_cfa_offset 16
 1689              		.cfi_offset 4, -16
 1690              		.cfi_offset 5, -12
 1691              		.cfi_offset 6, -8
 1692              		.cfi_offset 14, -4
 1693 0002 0600     		movs	r6, r0
 1694 0004 0C00     		movs	r4, r1
 362:../drivers/fsl_spi.c **** 
 1695              		.loc 1 362 0
 1696 0006 0D7E     		ldrb	r5, [r1, #24]
 1697              	.LVL162:
 365:../drivers/fsl_spi.c ****     {
 1698              		.loc 1 365 0
 1699 0008 4B7E     		ldrb	r3, [r1, #25]
 1700 000a 012B     		cmp	r3, #1
 1701 000c 1AD1     		bne	.L124
 367:../drivers/fsl_spi.c ****         {
 1702              		.loc 1 367 0
 1703 000e 0378     		ldrb	r3, [r0]
 1704 0010 5BB2     		sxtb	r3, r3
 1705 0012 002B     		cmp	r3, #0
 1706 0014 00DB     		blt	.L129
 1707              	.LVL163:
 1708              	.L123:
 403:../drivers/fsl_spi.c **** 
 1709              		.loc 1 403 0
 1710              		@ sp needed
 1711              	.LVL164:
 1712              	.LVL165:
 1713 0016 70BD     		pop	{r4, r5, r6, pc}
 1714              	.LVL166:
 1715              	.L129:
 369:../drivers/fsl_spi.c **** 
 1716              		.loc 1 369 0
 1717 0018 4968     		ldr	r1, [r1, #4]
 1718              	.LVL167:
 1719 001a 2A00     		movs	r2, r5
 1720 001c FFF7FEFF 		bl	SPI_ReadNonBlocking
 1721              	.LVL168:
 372:../drivers/fsl_spi.c ****             {
 1722              		.loc 1 372 0
 1723 0020 6368     		ldr	r3, [r4, #4]
 1724 0022 002B     		cmp	r3, #0
 1725 0024 02D0     		beq	.L126
 374:../drivers/fsl_spi.c ****             }
 1726              		.loc 1 374 0
 1727 0026 6368     		ldr	r3, [r4, #4]
 1728 0028 5B19     		adds	r3, r3, r5
 1729 002a 6360     		str	r3, [r4, #4]
 1730              	.L126:
 376:../drivers/fsl_spi.c ****         }
 1731              		.loc 1 376 0
 1732 002c E368     		ldr	r3, [r4, #12]
 1733 002e 5D1B     		subs	r5, r3, r5
 1734              	.LVL169:
 1735 0030 E560     		str	r5, [r4, #12]
 1736 0032 F0E7     		b	.L123
 1737              	.LVL170:
 1738              	.L127:
 393:../drivers/fsl_spi.c **** 
 1739              		.loc 1 393 0
 1740 0034 E368     		ldr	r3, [r4, #12]
 1741 0036 5B1B     		subs	r3, r3, r5
 1742 0038 E360     		str	r3, [r4, #12]
 396:../drivers/fsl_spi.c ****             {
 1743              		.loc 1 396 0
 1744 003a E268     		ldr	r2, [r4, #12]
 1745 003c 637E     		ldrb	r3, [r4, #25]
 1746 003e 5B00     		lsls	r3, r3, #1
 1747 0040 9A42     		cmp	r2, r3
 1748 0042 E8D0     		beq	.L123
 1749              	.L124:
 384:../drivers/fsl_spi.c ****         {
 1750              		.loc 1 384 0
 1751 0044 3378     		ldrb	r3, [r6]
 1752 0046 DB07     		lsls	r3, r3, #31
 1753 0048 E5D4     		bmi	.L123
 386:../drivers/fsl_spi.c **** 
 1754              		.loc 1 386 0
 1755 004a 6168     		ldr	r1, [r4, #4]
 1756 004c 2A00     		movs	r2, r5
 1757 004e 3000     		movs	r0, r6
 1758 0050 FFF7FEFF 		bl	SPI_ReadNonBlocking
 1759              	.LVL171:
 389:../drivers/fsl_spi.c ****             {
 1760              		.loc 1 389 0
 1761 0054 6368     		ldr	r3, [r4, #4]
 1762 0056 002B     		cmp	r3, #0
 1763 0058 ECD0     		beq	.L127
 391:../drivers/fsl_spi.c ****             }
 1764              		.loc 1 391 0
 1765 005a 6368     		ldr	r3, [r4, #4]
 1766 005c 5B19     		adds	r3, r3, r5
 1767 005e 6360     		str	r3, [r4, #4]
 1768 0060 E8E7     		b	.L127
 1769              		.cfi_endproc
 1770              	.LFE69:
 1772              		.section	.text.SPI_MasterTransferBlocking,"ax",%progbits
 1773              		.align	1
 1774              		.global	SPI_MasterTransferBlocking
 1775              		.syntax unified
 1776              		.code	16
 1777              		.thumb_func
 1778              		.fpu softvfp
 1780              	SPI_MasterTransferBlocking:
 1781              	.LFB83:
 759:../drivers/fsl_spi.c ****     assert(xfer);
 1782              		.loc 1 759 0
 1783              		.cfi_startproc
 1784              		@ args = 0, pretend = 0, frame = 0
 1785              		@ frame_needed = 0, uses_anonymous_args = 0
 1786              	.LVL172:
 1787 0000 70B5     		push	{r4, r5, r6, lr}
 1788              		.cfi_def_cfa_offset 16
 1789              		.cfi_offset 4, -16
 1790              		.cfi_offset 5, -12
 1791              		.cfi_offset 6, -8
 1792              		.cfi_offset 14, -4
 1793 0002 0400     		movs	r4, r0
 1794 0004 0D00     		movs	r5, r1
 1795              	.LVL173:
 765:../drivers/fsl_spi.c ****     {
 1796              		.loc 1 765 0
 1797 0006 0B68     		ldr	r3, [r1]
 1798 0008 002B     		cmp	r3, #0
 1799 000a 0CD0     		beq	.L140
 1800              	.L131:
 772:../drivers/fsl_spi.c **** #endif
 1801              		.loc 1 772 0
 1802 000c A378     		ldrb	r3, [r4, #2]
 1803 000e 9B09     		lsrs	r3, r3, #6
 1804 0010 0126     		movs	r6, #1
 1805 0012 1E40     		ands	r6, r3
 1806 0014 0136     		adds	r6, r6, #1
 1807              	.LVL174:
 780:../drivers/fsl_spi.c ****     {
 1808              		.loc 1 780 0
 1809 0016 184B     		ldr	r3, .L142
 1810 0018 9C42     		cmp	r4, r3
 1811 001a 0CD0     		beq	.L138
 782:../drivers/fsl_spi.c ****     }
 1812              		.loc 1 782 0
 1813 001c E37A     		ldrb	r3, [r4, #11]
 1814 001e 0122     		movs	r2, #1
 1815 0020 9343     		bics	r3, r2
 1816 0022 E372     		strb	r3, [r4, #11]
 1817 0024 07E0     		b	.L138
 1818              	.LVL175:
 1819              	.L140:
 765:../drivers/fsl_spi.c ****     {
 1820              		.loc 1 765 0 discriminator 1
 1821 0026 4B68     		ldr	r3, [r1, #4]
 1822 0028 002B     		cmp	r3, #0
 1823 002a EFD1     		bne	.L131
 767:../drivers/fsl_spi.c ****     }
 1824              		.loc 1 767 0
 1825 002c 0420     		movs	r0, #4
 1826              	.LVL176:
 1827 002e 22E0     		b	.L130
 1828              	.LVL177:
 1829              	.L137:
 810:../drivers/fsl_spi.c ****     }
 1830              		.loc 1 810 0
 1831 0030 AB68     		ldr	r3, [r5, #8]
 1832 0032 9B1B     		subs	r3, r3, r6
 1833 0034 AB60     		str	r3, [r5, #8]
 1834              	.L138:
 788:../drivers/fsl_spi.c ****     {
 1835              		.loc 1 788 0
 1836 0036 AB68     		ldr	r3, [r5, #8]
 1837 0038 002B     		cmp	r3, #0
 1838 003a 1BD0     		beq	.L141
 1839              	.L134:
 791:../drivers/fsl_spi.c ****         {
 1840              		.loc 1 791 0 discriminator 1
 1841 003c 2378     		ldrb	r3, [r4]
 1842 003e 9B06     		lsls	r3, r3, #26
 1843 0040 FCD5     		bpl	.L134
 794:../drivers/fsl_spi.c ****         if (xfer->txData)
 1844              		.loc 1 794 0
 1845 0042 3200     		movs	r2, r6
 1846 0044 2968     		ldr	r1, [r5]
 1847 0046 2000     		movs	r0, r4
 1848 0048 FFF7FEFF 		bl	SPI_WriteNonBlocking
 1849              	.LVL178:
 795:../drivers/fsl_spi.c ****         {
 1850              		.loc 1 795 0
 1851 004c 2B68     		ldr	r3, [r5]
 1852 004e 002B     		cmp	r3, #0
 1853 0050 01D0     		beq	.L136
 797:../drivers/fsl_spi.c ****         }
 1854              		.loc 1 797 0
 1855 0052 9B19     		adds	r3, r3, r6
 1856 0054 2B60     		str	r3, [r5]
 1857              	.L136:
 800:../drivers/fsl_spi.c ****         {
 1858              		.loc 1 800 0 discriminator 1
 1859 0056 2378     		ldrb	r3, [r4]
 1860 0058 5BB2     		sxtb	r3, r3
 1861 005a 002B     		cmp	r3, #0
 1862 005c FBDA     		bge	.L136
 803:../drivers/fsl_spi.c ****         if (xfer->rxData)
 1863              		.loc 1 803 0
 1864 005e 3200     		movs	r2, r6
 1865 0060 6968     		ldr	r1, [r5, #4]
 1866 0062 2000     		movs	r0, r4
 1867 0064 FFF7FEFF 		bl	SPI_ReadNonBlocking
 1868              	.LVL179:
 804:../drivers/fsl_spi.c ****         {
 1869              		.loc 1 804 0
 1870 0068 6B68     		ldr	r3, [r5, #4]
 1871 006a 002B     		cmp	r3, #0
 1872 006c E0D0     		beq	.L137
 806:../drivers/fsl_spi.c ****         }
 1873              		.loc 1 806 0
 1874 006e 9B19     		adds	r3, r3, r6
 1875 0070 6B60     		str	r3, [r5, #4]
 1876 0072 DDE7     		b	.L137
 1877              	.L141:
 813:../drivers/fsl_spi.c **** }
 1878              		.loc 1 813 0
 1879 0074 0020     		movs	r0, #0
 1880              	.LVL180:
 1881              	.L130:
 814:../drivers/fsl_spi.c **** 
 1882              		.loc 1 814 0
 1883              		@ sp needed
 1884              	.LVL181:
 1885              	.LVL182:
 1886 0076 70BD     		pop	{r4, r5, r6, pc}
 1887              	.L143:
 1888              		.align	2
 1889              	.L142:
 1890 0078 00600740 		.word	1074225152
 1891              		.cfi_endproc
 1892              	.LFE83:
 1894              		.section	.text.SPI_MasterTransferCreateHandle,"ax",%progbits
 1895              		.align	1
 1896              		.global	SPI_MasterTransferCreateHandle
 1897              		.syntax unified
 1898              		.code	16
 1899              		.thumb_func
 1900              		.fpu softvfp
 1902              	SPI_MasterTransferCreateHandle:
 1903              	.LFB84:
 820:../drivers/fsl_spi.c ****     assert(handle);
 1904              		.loc 1 820 0
 1905              		.cfi_startproc
 1906              		@ args = 0, pretend = 0, frame = 0
 1907              		@ frame_needed = 0, uses_anonymous_args = 0
 1908              	.LVL183:
 1909 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1910              		.cfi_def_cfa_offset 20
 1911              		.cfi_offset 4, -20
 1912              		.cfi_offset 5, -16
 1913              		.cfi_offset 6, -12
 1914              		.cfi_offset 7, -8
 1915              		.cfi_offset 14, -4
 1916 0002 C646     		mov	lr, r8
 1917 0004 00B5     		push	{lr}
 1918              		.cfi_def_cfa_offset 24
 1919              		.cfi_offset 8, -24
 1920 0006 0600     		movs	r6, r0
 1921 0008 0C00     		movs	r4, r1
 1922 000a 9046     		mov	r8, r2
 1923 000c 1F00     		movs	r7, r3
 823:../drivers/fsl_spi.c **** 
 1924              		.loc 1 823 0
 1925 000e FFF7FEFF 		bl	SPI_GetInstance
 1926              	.LVL184:
 1927 0012 0500     		movs	r5, r0
 1928              	.LVL185:
 826:../drivers/fsl_spi.c **** 
 1929              		.loc 1 826 0
 1930 0014 1C22     		movs	r2, #28
 1931 0016 0021     		movs	r1, #0
 1932 0018 2000     		movs	r0, r4
 1933 001a FFF7FEFF 		bl	memset
 1934              	.LVL186:
 829:../drivers/fsl_spi.c ****     handle->callback = callback;
 1935              		.loc 1 829 0
 1936 001e FF23     		movs	r3, #255
 1937 0020 1D40     		ands	r5, r3
 1938              	.LVL187:
 1939 0022 AA00     		lsls	r2, r5, #2
 1940 0024 114B     		ldr	r3, .L146
 1941 0026 D450     		str	r4, [r2, r3]
 830:../drivers/fsl_spi.c ****     handle->userData = userData;
 1942              		.loc 1 830 0
 1943 0028 4346     		mov	r3, r8
 1944 002a E361     		str	r3, [r4, #28]
 831:../drivers/fsl_spi.c ****     s_spiMasterIsr = SPI_MasterTransferHandleIRQ;
 1945              		.loc 1 831 0
 1946 002c 2762     		str	r7, [r4, #32]
 832:../drivers/fsl_spi.c ****     handle->watermark = SPI_GetWatermark(base);
 1947              		.loc 1 832 0
 1948 002e 104B     		ldr	r3, .L146+4
 1949 0030 104A     		ldr	r2, .L146+8
 1950 0032 1A60     		str	r2, [r3]
 833:../drivers/fsl_spi.c **** 
 1951              		.loc 1 833 0
 1952 0034 3000     		movs	r0, r6
 1953 0036 FFF7FEFF 		bl	SPI_GetWatermark
 1954              	.LVL188:
 1955 003a 6076     		strb	r0, [r4, #25]
 837:../drivers/fsl_spi.c **** #else
 1956              		.loc 1 837 0
 1957 003c B278     		ldrb	r2, [r6, #2]
 1958 003e 9209     		lsrs	r2, r2, #6
 1959 0040 0123     		movs	r3, #1
 1960 0042 1340     		ands	r3, r2
 1961 0044 0133     		adds	r3, r3, #1
 1962 0046 2376     		strb	r3, [r4, #24]
 843:../drivers/fsl_spi.c **** }
 1963              		.loc 1 843 0
 1964 0048 0B4B     		ldr	r3, .L146+12
 1965 004a 5B57     		ldrsb	r3, [r3, r5]
 1966              	.LVL189:
 1967              	.LBB23:
 1968              	.LBB24:
 1969              		.file 3 "../drivers/fsl_common.h"
   1:../drivers/fsl_common.h **** /*
   2:../drivers/fsl_common.h ****  * The Clear BSD License
   3:../drivers/fsl_common.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_common.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_common.h ****  * All rights reserved.
   6:../drivers/fsl_common.h ****  *
   7:../drivers/fsl_common.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_common.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_common.h ****  * that the following conditions are met:
  10:../drivers/fsl_common.h ****  *
  11:../drivers/fsl_common.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_common.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_common.h ****  *
  14:../drivers/fsl_common.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_common.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_common.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_common.h ****  *
  18:../drivers/fsl_common.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_common.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_common.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_common.h ****  *
  22:../drivers/fsl_common.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_common.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_common.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_common.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_common.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_common.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_common.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_common.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_common.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_common.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_common.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_common.h ****  */
  34:../drivers/fsl_common.h **** 
  35:../drivers/fsl_common.h **** #ifndef _FSL_COMMON_H_
  36:../drivers/fsl_common.h **** #define _FSL_COMMON_H_
  37:../drivers/fsl_common.h **** 
  38:../drivers/fsl_common.h **** #include <assert.h>
  39:../drivers/fsl_common.h **** #include <stdbool.h>
  40:../drivers/fsl_common.h **** #include <stdint.h>
  41:../drivers/fsl_common.h **** #include <string.h>
  42:../drivers/fsl_common.h **** 
  43:../drivers/fsl_common.h **** #if defined(__ICCARM__)
  44:../drivers/fsl_common.h **** #include <stddef.h>
  45:../drivers/fsl_common.h **** #endif
  46:../drivers/fsl_common.h **** 
  47:../drivers/fsl_common.h **** #include "fsl_device_registers.h"
  48:../drivers/fsl_common.h **** 
  49:../drivers/fsl_common.h **** /*!
  50:../drivers/fsl_common.h ****  * @addtogroup ksdk_common
  51:../drivers/fsl_common.h ****  * @{
  52:../drivers/fsl_common.h ****  */
  53:../drivers/fsl_common.h **** 
  54:../drivers/fsl_common.h **** /*******************************************************************************
  55:../drivers/fsl_common.h ****  * Definitions
  56:../drivers/fsl_common.h ****  ******************************************************************************/
  57:../drivers/fsl_common.h **** 
  58:../drivers/fsl_common.h **** /*! @brief Construct a status code value from a group and code number. */
  59:../drivers/fsl_common.h **** #define MAKE_STATUS(group, code) ((((group)*100) + (code)))
  60:../drivers/fsl_common.h **** 
  61:../drivers/fsl_common.h **** /*! @brief Construct the version number for drivers. */
  62:../drivers/fsl_common.h **** #define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
  63:../drivers/fsl_common.h **** 
  64:../drivers/fsl_common.h **** /*! @name Driver version */
  65:../drivers/fsl_common.h **** /*@{*/
  66:../drivers/fsl_common.h **** /*! @brief common driver version 2.0.0. */
  67:../drivers/fsl_common.h **** #define FSL_COMMON_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
  68:../drivers/fsl_common.h **** /*@}*/
  69:../drivers/fsl_common.h **** 
  70:../drivers/fsl_common.h **** /* Debug console type definition. */
  71:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
  72:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
  73:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
  74:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
  75:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
  76:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
  77:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_IUART 6U    /*!< Debug console base on i.MX UART. */
  78:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_VUSART 7U   /*!< Debug console base on LPC_USART. */
  79:../drivers/fsl_common.h **** 
  80:../drivers/fsl_common.h **** /*! @brief Status group numbers. */
  81:../drivers/fsl_common.h **** enum _status_groups
  82:../drivers/fsl_common.h **** {
  83:../drivers/fsl_common.h ****     kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
  84:../drivers/fsl_common.h ****     kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
  85:../drivers/fsl_common.h ****     kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
  86:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
  87:../drivers/fsl_common.h ****     kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
  88:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
  89:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
  90:../drivers/fsl_common.h ****     kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
  91:../drivers/fsl_common.h ****     kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
  92:../drivers/fsl_common.h ****     kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
  93:../drivers/fsl_common.h ****     kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
  94:../drivers/fsl_common.h ****     kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
  95:../drivers/fsl_common.h ****     kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
  96:../drivers/fsl_common.h ****     kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
  97:../drivers/fsl_common.h ****     kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
  98:../drivers/fsl_common.h ****     kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
  99:../drivers/fsl_common.h ****     kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
 100:../drivers/fsl_common.h ****     kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
 101:../drivers/fsl_common.h ****     kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
 102:../drivers/fsl_common.h ****     kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
 103:../drivers/fsl_common.h ****     kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
 104:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
 105:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_MCULCD = 24,          /*!< Group number for FLEXIO LCD status codes */
 106:../drivers/fsl_common.h ****     kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
 107:../drivers/fsl_common.h ****     kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
 108:../drivers/fsl_common.h ****     kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
 109:../drivers/fsl_common.h ****     kStatusGroup_IUART = 28,                  /*!< Group number for IUART status codes */
 110:../drivers/fsl_common.h ****     kStatusGroup_CSI = 29,                    /*!< Group number for CSI status codes */
 111:../drivers/fsl_common.h ****     kStatusGroup_MIPI_DSI = 30,               /*!< Group number for MIPI DSI status codes */
 112:../drivers/fsl_common.h ****     kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
 113:../drivers/fsl_common.h ****     kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
 114:../drivers/fsl_common.h ****     kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
 115:../drivers/fsl_common.h ****     kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
 116:../drivers/fsl_common.h ****     kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
 117:../drivers/fsl_common.h ****     kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
 118:../drivers/fsl_common.h ****     kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
 119:../drivers/fsl_common.h ****     kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
 120:../drivers/fsl_common.h ****     kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
 121:../drivers/fsl_common.h ****     kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
 122:../drivers/fsl_common.h ****     kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
 123:../drivers/fsl_common.h ****     kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
 124:../drivers/fsl_common.h ****     kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
 125:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
 126:../drivers/fsl_common.h ****     kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
 127:../drivers/fsl_common.h ****     kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
 128:../drivers/fsl_common.h ****     kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
 129:../drivers/fsl_common.h ****     kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
 130:../drivers/fsl_common.h ****     kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
 131:../drivers/fsl_common.h ****     kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
 132:../drivers/fsl_common.h ****     kStatusGroup_MCAN = 62,                   /*!< Group number for MCAN status codes. */
 133:../drivers/fsl_common.h ****     kStatusGroup_CAAM = 63,                   /*!< Group number for CAAM status codes. */
 134:../drivers/fsl_common.h ****     kStatusGroup_ECSPI = 64,                  /*!< Group number for ECSPI status codes. */
 135:../drivers/fsl_common.h ****     kStatusGroup_USDHC = 65,                  /*!< Group number for USDHC status codes.*/
 136:../drivers/fsl_common.h ****     kStatusGroup_LPC_I2C = 66,                /*!< Group number for LPC_I2C status codes.*/
 137:../drivers/fsl_common.h ****     kStatusGroup_DCP = 67,                    /*!< Group number for DCP status codes.*/
 138:../drivers/fsl_common.h ****     kStatusGroup_MSCAN = 68,                  /*!< Group number for MSCAN status codes.*/
 139:../drivers/fsl_common.h ****     kStatusGroup_ESAI = 69,                   /*!< Group number for ESAI status codes. */
 140:../drivers/fsl_common.h ****     kStatusGroup_FLEXSPI = 70,                /*!< Group number for FLEXSPI status codes. */
 141:../drivers/fsl_common.h ****     kStatusGroup_MMDC = 71,                   /*!< Group number for MMDC status codes. */
 142:../drivers/fsl_common.h ****     kStatusGroup_MICFIL = 72,                 /*!< Group number for MIC status codes. */
 143:../drivers/fsl_common.h ****     kStatusGroup_SDMA = 73,                   /*!< Group number for SDMA status codes. */
 144:../drivers/fsl_common.h ****     kStatusGroup_ICS = 74,                    /*!< Group number for ICS status codes. */
 145:../drivers/fsl_common.h ****     kStatusGroup_SPDIF = 75,                  /*!< Group number for SPDIF status codes. */
 146:../drivers/fsl_common.h ****     kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
 147:../drivers/fsl_common.h ****     kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
 148:../drivers/fsl_common.h ****     kStatusGroup_SEMC = 100,                   /*!< Group number for SEMC status codes. */    
 149:../drivers/fsl_common.h ****     kStatusGroup_ApplicationRangeStart = 101, /*!< Starting number for application groups. */
 150:../drivers/fsl_common.h **** };
 151:../drivers/fsl_common.h **** 
 152:../drivers/fsl_common.h **** /*! @brief Generic status return codes. */
 153:../drivers/fsl_common.h **** enum _generic_status
 154:../drivers/fsl_common.h **** {
 155:../drivers/fsl_common.h ****     kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
 156:../drivers/fsl_common.h ****     kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
 157:../drivers/fsl_common.h ****     kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
 158:../drivers/fsl_common.h ****     kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
 159:../drivers/fsl_common.h ****     kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
 160:../drivers/fsl_common.h ****     kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
 161:../drivers/fsl_common.h ****     kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
 162:../drivers/fsl_common.h **** };
 163:../drivers/fsl_common.h **** 
 164:../drivers/fsl_common.h **** /*! @brief Type used for all status and error return values. */
 165:../drivers/fsl_common.h **** typedef int32_t status_t;
 166:../drivers/fsl_common.h **** 
 167:../drivers/fsl_common.h **** /*
 168:../drivers/fsl_common.h ****  * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
 169:../drivers/fsl_common.h ****  * defined in previous of this file.
 170:../drivers/fsl_common.h ****  */
 171:../drivers/fsl_common.h **** #include "fsl_clock.h"
 172:../drivers/fsl_common.h **** 
 173:../drivers/fsl_common.h **** /*
 174:../drivers/fsl_common.h ****  * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a 
 175:../drivers/fsl_common.h ****  */
 176:../drivers/fsl_common.h **** #if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
 177:../drivers/fsl_common.h ****      (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
 178:../drivers/fsl_common.h **** #include "fsl_reset.h"
 179:../drivers/fsl_common.h **** #endif
 180:../drivers/fsl_common.h **** 
 181:../drivers/fsl_common.h **** /*! @name Min/max macros */
 182:../drivers/fsl_common.h **** /* @{ */
 183:../drivers/fsl_common.h **** #if !defined(MIN)
 184:../drivers/fsl_common.h **** #define MIN(a, b) ((a) < (b) ? (a) : (b))
 185:../drivers/fsl_common.h **** #endif
 186:../drivers/fsl_common.h **** 
 187:../drivers/fsl_common.h **** #if !defined(MAX)
 188:../drivers/fsl_common.h **** #define MAX(a, b) ((a) > (b) ? (a) : (b))
 189:../drivers/fsl_common.h **** #endif
 190:../drivers/fsl_common.h **** /* @} */
 191:../drivers/fsl_common.h **** 
 192:../drivers/fsl_common.h **** /*! @brief Computes the number of elements in an array. */
 193:../drivers/fsl_common.h **** #if !defined(ARRAY_SIZE)
 194:../drivers/fsl_common.h **** #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 195:../drivers/fsl_common.h **** #endif
 196:../drivers/fsl_common.h **** 
 197:../drivers/fsl_common.h **** /*! @name UINT16_MAX/UINT32_MAX value */
 198:../drivers/fsl_common.h **** /* @{ */
 199:../drivers/fsl_common.h **** #if !defined(UINT16_MAX)
 200:../drivers/fsl_common.h **** #define UINT16_MAX ((uint16_t)-1)
 201:../drivers/fsl_common.h **** #endif
 202:../drivers/fsl_common.h **** 
 203:../drivers/fsl_common.h **** #if !defined(UINT32_MAX)
 204:../drivers/fsl_common.h **** #define UINT32_MAX ((uint32_t)-1)
 205:../drivers/fsl_common.h **** #endif
 206:../drivers/fsl_common.h **** /* @} */
 207:../drivers/fsl_common.h **** 
 208:../drivers/fsl_common.h **** /*! @name Timer utilities */
 209:../drivers/fsl_common.h **** /* @{ */
 210:../drivers/fsl_common.h **** /*! Macro to convert a microsecond period to raw count value */
 211:../drivers/fsl_common.h **** #define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
 212:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to microsecond */
 213:../drivers/fsl_common.h **** #define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
 214:../drivers/fsl_common.h **** 
 215:../drivers/fsl_common.h **** /*! Macro to convert a millisecond period to raw count value */
 216:../drivers/fsl_common.h **** #define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
 217:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to millisecond */
 218:../drivers/fsl_common.h **** #define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
 219:../drivers/fsl_common.h **** /* @} */
 220:../drivers/fsl_common.h **** 
 221:../drivers/fsl_common.h **** /*! @name Alignment variable definition macros */
 222:../drivers/fsl_common.h **** /* @{ */
 223:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 224:../drivers/fsl_common.h **** /**
 225:../drivers/fsl_common.h ****  * Workaround to disable MISRA C message suppress warnings for IAR compiler.
 226:../drivers/fsl_common.h ****  * http://supp.iar.com/Support/?note=24725
 227:../drivers/fsl_common.h ****  */
 228:../drivers/fsl_common.h **** _Pragma("diag_suppress=Pm120")
 229:../drivers/fsl_common.h **** #define SDK_PRAGMA(x) _Pragma(#x)
 230:../drivers/fsl_common.h ****     _Pragma("diag_error=Pm120")
 231:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 232:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 233:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 234:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 235:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 236:../drivers/fsl_common.h **** #endif
 237:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 238:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 239:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) SDK_PRAGMA(data_alignment = FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 240:../drivers/fsl_common.h **** #endif
 241:../drivers/fsl_common.h **** #elif defined(__ARMCC_VERSION)
 242:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 243:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) __align(alignbytes) var
 244:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 245:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 246:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) __align(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) var
 247:../drivers/fsl_common.h **** #endif
 248:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 249:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 250:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) __align(FSL_FEATURE_L2CACHE_LINESIZE_BYTE) var
 251:../drivers/fsl_common.h **** #endif
 252:../drivers/fsl_common.h **** #elif defined(__GNUC__)
 253:../drivers/fsl_common.h **** /*! Macro to define a variable with alignbytes alignment */
 254:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 255:../drivers/fsl_common.h **** /*! Macro to define a variable with L1 d-cache line size alignment */
 256:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 257:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)))
 258:../drivers/fsl_common.h **** #endif
 259:../drivers/fsl_common.h **** /*! Macro to define a variable with L2 cache line size alignment */
 260:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 261:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var __attribute__((aligned(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)))
 262:../drivers/fsl_common.h **** #endif
 263:../drivers/fsl_common.h **** #else
 264:../drivers/fsl_common.h **** #error Toolchain not supported
 265:../drivers/fsl_common.h **** #define SDK_ALIGN(var, alignbytes) var
 266:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
 267:../drivers/fsl_common.h **** #define SDK_L1DCACHE_ALIGN(var) var
 268:../drivers/fsl_common.h **** #endif
 269:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
 270:../drivers/fsl_common.h **** #define SDK_L2CACHE_ALIGN(var) var
 271:../drivers/fsl_common.h **** #endif
 272:../drivers/fsl_common.h **** #endif
 273:../drivers/fsl_common.h **** 
 274:../drivers/fsl_common.h **** /*! Macro to change a value to a given size aligned value */
 275:../drivers/fsl_common.h **** #define SDK_SIZEALIGN(var, alignbytes) \
 276:../drivers/fsl_common.h ****     ((unsigned int)((var) + ((alignbytes)-1)) & (unsigned int)(~(unsigned int)((alignbytes)-1)))
 277:../drivers/fsl_common.h **** /* @} */
 278:../drivers/fsl_common.h **** 
 279:../drivers/fsl_common.h **** /*! @name Non-cacheable region definition macros */
 280:../drivers/fsl_common.h **** /* For initialized non-zero non-cacheable variables, please using "AT_NONCACHEABLE_SECTION_INIT(var
 281:../drivers/fsl_common.h ****  * "AT_NONCACHEABLE_SECTION_ALIGN_INIT(var) ={xx};" in your projects to define them, for zero-inite
 282:../drivers/fsl_common.h ****  * please using "AT_NONCACHEABLE_SECTION(var);" or "AT_NONCACHEABLE_SECTION_ALIGN(var);" to define 
 283:../drivers/fsl_common.h ****  * will be initialized to zero in system startup.
 284:../drivers/fsl_common.h ****  */
 285:../drivers/fsl_common.h **** /* @{ */
 286:../drivers/fsl_common.h **** #if (defined(__ICCARM__))
 287:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 288:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var @"NonCacheable"
 289:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var 
 290:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var @"NonCacheable.init"
 291:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 292:../drivers/fsl_common.h **** #else
 293:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 294:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes) var
 295:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 296:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) SDK_PRAGMA(data_alignment = alignbytes)
 297:../drivers/fsl_common.h **** #endif
 298:../drivers/fsl_common.h **** #elif(defined(__ARMCC_VERSION))
 299:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 300:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable"), zero_init)) var
 301:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 302:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable"), zero_init)) __align(alignbytes) var
 303:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 304:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 305:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) __align(alignbytes) var
 306:../drivers/fsl_common.h **** #else
 307:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 308:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) __align(alignbytes) var
 309:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 310:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) __align(alignbytes) var
 311:../drivers/fsl_common.h **** #endif
 312:../drivers/fsl_common.h **** #elif(defined(__GNUC__))
 313:../drivers/fsl_common.h **** /* For GCC, when the non-cacheable section is required, please define "__STARTUP_INITIALIZE_NONCACH
 314:../drivers/fsl_common.h ****  * in your projects to make sure the non-cacheable section variables will be initialized in system 
 315:../drivers/fsl_common.h ****  */
 316:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE)
 317:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) __attribute__((section("NonCacheable.init"))) var
 318:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) \
 319:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable.init"))) var __attribute__((aligned(alignbytes)))
 320:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var
 321:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) \
 322:../drivers/fsl_common.h ****     __attribute__((section("NonCacheable,\"aw\",%nobits @"))) var __attribute__((aligned(alignbytes
 323:../drivers/fsl_common.h **** #else
 324:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 325:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var __attribute__((aligned(alignbytes)))
 326:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 327:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var __attribute__((aligned(alignbytes))
 328:../drivers/fsl_common.h **** #endif
 329:../drivers/fsl_common.h **** #else
 330:../drivers/fsl_common.h **** #error Toolchain not supported.
 331:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION(var) var
 332:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN(var, alignbytes) var
 333:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_INIT(var) var
 334:../drivers/fsl_common.h **** #define AT_NONCACHEABLE_SECTION_ALIGN_INIT(var, alignbytes) var
 335:../drivers/fsl_common.h **** #endif
 336:../drivers/fsl_common.h **** /* @} */
 337:../drivers/fsl_common.h **** 
 338:../drivers/fsl_common.h **** /*******************************************************************************
 339:../drivers/fsl_common.h ****  * API
 340:../drivers/fsl_common.h ****  ******************************************************************************/
 341:../drivers/fsl_common.h **** 
 342:../drivers/fsl_common.h **** #if defined(__cplusplus)
 343:../drivers/fsl_common.h ****         extern "C"
 344:../drivers/fsl_common.h **** {
 345:../drivers/fsl_common.h **** #endif
 346:../drivers/fsl_common.h **** 
 347:../drivers/fsl_common.h ****     /*!
 348:../drivers/fsl_common.h ****      * @brief Enable specific interrupt.
 349:../drivers/fsl_common.h ****      *
 350:../drivers/fsl_common.h ****      * Enable LEVEL1 interrupt. For some devices, there might be multiple interrupt
 351:../drivers/fsl_common.h ****      * levels. For example, there are NVIC and intmux. Here the interrupts connected
 352:../drivers/fsl_common.h ****      * to NVIC are the LEVEL1 interrupts, because they are routed to the core directly.
 353:../drivers/fsl_common.h ****      * The interrupts connected to intmux are the LEVEL2 interrupts, they are routed
 354:../drivers/fsl_common.h ****      * to NVIC first then routed to core.
 355:../drivers/fsl_common.h ****      *
 356:../drivers/fsl_common.h ****      * This function only enables the LEVEL1 interrupts. The number of LEVEL1 interrupts
 357:../drivers/fsl_common.h ****      * is indicated by the feature macro FSL_FEATURE_NUMBER_OF_LEVEL1_INT_VECTORS.
 358:../drivers/fsl_common.h ****      *
 359:../drivers/fsl_common.h ****      * @param interrupt The IRQ number.
 360:../drivers/fsl_common.h ****      * @retval kStatus_Success Interrupt enabled successfully
 361:../drivers/fsl_common.h ****      * @retval kStatus_Fail Failed to enable the interrupt
 362:../drivers/fsl_common.h ****      */
 363:../drivers/fsl_common.h ****     static inline status_t EnableIRQ(IRQn_Type interrupt)
 364:../drivers/fsl_common.h ****     {
 365:../drivers/fsl_common.h ****         if (NotAvail_IRQn == interrupt)
 1970              		.loc 3 365 0
 1971 004c 1A00     		movs	r2, r3
 1972 004e 8032     		adds	r2, r2, #128
 1973 0050 08D0     		beq	.L144
 1974              	.LVL190:
 1975              	.LBB25:
 1976              	.LBB26:
 1977              		.file 4 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 1978              		.loc 4 733 0
 1979 0052 002B     		cmp	r3, #0
 1980 0054 06DB     		blt	.L144
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 1981              		.loc 4 735 0
 1982 0056 1F22     		movs	r2, #31
 1983 0058 1340     		ands	r3, r2
 1984              	.LVL191:
 1985 005a 1E3A     		subs	r2, r2, #30
 1986 005c 9A40     		lsls	r2, r2, r3
 1987 005e 1300     		movs	r3, r2
 1988 0060 064A     		ldr	r2, .L146+16
 1989 0062 1360     		str	r3, [r2]
 1990              	.LVL192:
 1991              	.L144:
 1992              	.LBE26:
 1993              	.LBE25:
 1994              	.LBE24:
 1995              	.LBE23:
 844:../drivers/fsl_spi.c **** 
 1996              		.loc 1 844 0
 1997              		@ sp needed
 1998              	.LVL193:
 1999              	.LVL194:
 2000              	.LVL195:
 2001              	.LVL196:
 2002 0064 04BC     		pop	{r2}
 2003 0066 9046     		mov	r8, r2
 2004 0068 F0BD     		pop	{r4, r5, r6, r7, pc}
 2005              	.L147:
 2006 006a C046     		.align	2
 2007              	.L146:
 2008 006c 00000000 		.word	.LANCHOR0
 2009 0070 00000000 		.word	.LANCHOR1
 2010 0074 00000000 		.word	SPI_MasterTransferHandleIRQ
 2011 0078 00000000 		.word	.LANCHOR6
 2012 007c 00E100E0 		.word	-536813312
 2013              		.cfi_endproc
 2014              	.LFE84:
 2016              		.section	.text.SPI_MasterTransferNonBlocking,"ax",%progbits
 2017              		.align	1
 2018              		.global	SPI_MasterTransferNonBlocking
 2019              		.syntax unified
 2020              		.code	16
 2021              		.thumb_func
 2022              		.fpu softvfp
 2024              	SPI_MasterTransferNonBlocking:
 2025              	.LFB85:
 847:../drivers/fsl_spi.c ****     assert(handle && xfer);
 2026              		.loc 1 847 0
 2027              		.cfi_startproc
 2028              		@ args = 0, pretend = 0, frame = 0
 2029              		@ frame_needed = 0, uses_anonymous_args = 0
 2030              	.LVL197:
 2031 0000 70B5     		push	{r4, r5, r6, lr}
 2032              		.cfi_def_cfa_offset 16
 2033              		.cfi_offset 4, -16
 2034              		.cfi_offset 5, -12
 2035              		.cfi_offset 6, -8
 2036              		.cfi_offset 14, -4
 2037 0002 0500     		movs	r5, r0
 2038 0004 0C00     		movs	r4, r1
 2039 0006 1600     		movs	r6, r2
 851:../drivers/fsl_spi.c ****     {
 2040              		.loc 1 851 0
 2041 0008 0B69     		ldr	r3, [r1, #16]
 2042 000a 012B     		cmp	r3, #1
 2043 000c 44D0     		beq	.L155
 857:../drivers/fsl_spi.c ****     {
 2044              		.loc 1 857 0
 2045 000e 1368     		ldr	r3, [r2]
 2046 0010 002B     		cmp	r3, #0
 2047 0012 2BD0     		beq	.L158
 2048              	.LVL198:
 2049              	.L150:
 857:../drivers/fsl_spi.c ****     {
 2050              		.loc 1 857 0 is_stmt 0 discriminator 3
 2051 0014 B268     		ldr	r2, [r6, #8]
 2052 0016 002A     		cmp	r2, #0
 2053 0018 41D0     		beq	.L157
 863:../drivers/fsl_spi.c ****     handle->rxData = xfer->rxData;
 2054              		.loc 1 863 0 is_stmt 1
 2055 001a 2360     		str	r3, [r4]
 864:../drivers/fsl_spi.c ****     handle->transferSize = xfer->dataSize;
 2056              		.loc 1 864 0
 2057 001c 7368     		ldr	r3, [r6, #4]
 2058 001e 6360     		str	r3, [r4, #4]
 865:../drivers/fsl_spi.c ****     handle->txRemainingBytes = xfer->dataSize;
 2059              		.loc 1 865 0
 2060 0020 B368     		ldr	r3, [r6, #8]
 2061 0022 6361     		str	r3, [r4, #20]
 866:../drivers/fsl_spi.c ****     handle->rxRemainingBytes = xfer->dataSize;
 2062              		.loc 1 866 0
 2063 0024 B368     		ldr	r3, [r6, #8]
 2064 0026 A360     		str	r3, [r4, #8]
 867:../drivers/fsl_spi.c **** 
 2065              		.loc 1 867 0
 2066 0028 B368     		ldr	r3, [r6, #8]
 2067 002a E360     		str	r3, [r4, #12]
 870:../drivers/fsl_spi.c **** 
 2068              		.loc 1 870 0
 2069 002c 0123     		movs	r3, #1
 2070 002e 2361     		str	r3, [r4, #16]
 875:../drivers/fsl_spi.c **** 
 2071              		.loc 1 875 0
 2072 0030 2800     		movs	r0, r5
 2073              	.LVL199:
 2074 0032 FFF7FEFF 		bl	SPI_GetWatermark
 2075              	.LVL200:
 2076 0036 6076     		strb	r0, [r4, #25]
 878:../drivers/fsl_spi.c ****     {
 2077              		.loc 1 878 0
 2078 0038 B368     		ldr	r3, [r6, #8]
 2079 003a 4000     		lsls	r0, r0, #1
 2080 003c 8342     		cmp	r3, r0
 2081 003e 01D2     		bcs	.L151
 880:../drivers/fsl_spi.c ****     }
 2082              		.loc 1 880 0
 2083 0040 0123     		movs	r3, #1
 2084 0042 6376     		strb	r3, [r4, #25]
 2085              	.L151:
 884:../drivers/fsl_spi.c ****     {
 2086              		.loc 1 884 0
 2087 0044 637E     		ldrb	r3, [r4, #25]
 2088 0046 012B     		cmp	r3, #1
 2089 0048 15D9     		bls	.L152
 886:../drivers/fsl_spi.c ****         /* First send a piece of data to Tx Data or FIFO to start a SPI transfer */
 2090              		.loc 1 886 0
 2091 004a 0121     		movs	r1, #1
 2092 004c 2800     		movs	r0, r5
 2093 004e FFF7FEFF 		bl	SPI_EnableFIFO
 2094              	.LVL201:
 2095              	.L153:
 888:../drivers/fsl_spi.c ****         {
 2096              		.loc 1 888 0 discriminator 1
 2097 0052 2B78     		ldrb	r3, [r5]
 2098 0054 5B07     		lsls	r3, r3, #29
 2099 0056 FCD5     		bpl	.L153
 891:../drivers/fsl_spi.c ****         /* Enable Rx near full interrupt */
 2100              		.loc 1 891 0
 2101 0058 2100     		movs	r1, r4
 2102 005a 2800     		movs	r0, r5
 2103 005c FFF7FEFF 		bl	SPI_SendInitialTransfer
 2104              	.LVL202:
 893:../drivers/fsl_spi.c ****     }
 2105              		.loc 1 893 0
 2106 0060 0821     		movs	r1, #8
 2107 0062 2800     		movs	r0, r5
 2108 0064 FFF7FEFF 		bl	SPI_EnableInterrupts
 2109              	.LVL203:
 913:../drivers/fsl_spi.c **** }
 2110              		.loc 1 913 0
 2111 0068 0020     		movs	r0, #0
 2112 006a 19E0     		b	.L148
 2113              	.LVL204:
 2114              	.L158:
 857:../drivers/fsl_spi.c ****     {
 2115              		.loc 1 857 0 discriminator 1
 2116 006c 5268     		ldr	r2, [r2, #4]
 2117              	.LVL205:
 2118 006e 002A     		cmp	r2, #0
 2119 0070 D0D1     		bne	.L150
 859:../drivers/fsl_spi.c ****     }
 2120              		.loc 1 859 0
 2121 0072 0420     		movs	r0, #4
 2122              	.LVL206:
 2123 0074 14E0     		b	.L148
 2124              	.LVL207:
 2125              	.L152:
 897:../drivers/fsl_spi.c ****         while ((base->S & SPI_S_SPTEF_MASK) != SPI_S_SPTEF_MASK)
 2126              		.loc 1 897 0
 2127 0076 0021     		movs	r1, #0
 2128 0078 2800     		movs	r0, r5
 2129 007a FFF7FEFF 		bl	SPI_EnableFIFO
 2130              	.LVL208:
 2131              	.L154:
 898:../drivers/fsl_spi.c ****         {
 2132              		.loc 1 898 0 discriminator 1
 2133 007e 2B78     		ldrb	r3, [r5]
 2134 0080 9B06     		lsls	r3, r3, #26
 2135 0082 FCD5     		bpl	.L154
 902:../drivers/fsl_spi.c ****         SPI_EnableInterrupts(base, kSPI_RxFullAndModfInterruptEnable);
 2136              		.loc 1 902 0
 2137 0084 2100     		movs	r1, r4
 2138 0086 2800     		movs	r0, r5
 2139 0088 FFF7FEFF 		bl	SPI_SendInitialTransfer
 2140              	.LVL209:
 903:../drivers/fsl_spi.c ****     }
 2141              		.loc 1 903 0
 2142 008c 0121     		movs	r1, #1
 2143 008e 2800     		movs	r0, r5
 2144 0090 FFF7FEFF 		bl	SPI_EnableInterrupts
 2145              	.LVL210:
 913:../drivers/fsl_spi.c **** }
 2146              		.loc 1 913 0
 2147 0094 0020     		movs	r0, #0
 2148 0096 03E0     		b	.L148
 2149              	.LVL211:
 2150              	.L155:
 853:../drivers/fsl_spi.c ****     }
 2151              		.loc 1 853 0
 2152 0098 AF20     		movs	r0, #175
 2153              	.LVL212:
 2154 009a C000     		lsls	r0, r0, #3
 2155 009c 00E0     		b	.L148
 2156              	.LVL213:
 2157              	.L157:
 859:../drivers/fsl_spi.c ****     }
 2158              		.loc 1 859 0
 2159 009e 0420     		movs	r0, #4
 2160              	.LVL214:
 2161              	.L148:
 914:../drivers/fsl_spi.c **** 
 2162              		.loc 1 914 0
 2163              		@ sp needed
 2164              	.LVL215:
 2165              	.LVL216:
 2166              	.LVL217:
 2167 00a0 70BD     		pop	{r4, r5, r6, pc}
 2168              		.cfi_endproc
 2169              	.LFE85:
 2171              		.section	.text.SPI_MasterTransferGetCount,"ax",%progbits
 2172              		.align	1
 2173              		.global	SPI_MasterTransferGetCount
 2174              		.syntax unified
 2175              		.code	16
 2176              		.thumb_func
 2177              		.fpu softvfp
 2179              	SPI_MasterTransferGetCount:
 2180              	.LFB86:
 917:../drivers/fsl_spi.c ****     assert(handle);
 2181              		.loc 1 917 0
 2182              		.cfi_startproc
 2183              		@ args = 0, pretend = 0, frame = 0
 2184              		@ frame_needed = 0, uses_anonymous_args = 0
 2185              		@ link register save eliminated.
 2186              	.LVL218:
 922:../drivers/fsl_spi.c ****     {
 2187              		.loc 1 922 0
 2188 0000 0869     		ldr	r0, [r1, #16]
 2189              	.LVL219:
 2190 0002 AF23     		movs	r3, #175
 2191 0004 DB00     		lsls	r3, r3, #3
 2192 0006 9842     		cmp	r0, r3
 2193 0008 0ED1     		bne	.L162
 929:../drivers/fsl_spi.c ****         {
 2194              		.loc 1 929 0
 2195 000a 4B68     		ldr	r3, [r1, #4]
 2196 000c 002B     		cmp	r3, #0
 2197 000e 05D0     		beq	.L161
 931:../drivers/fsl_spi.c ****         }
 2198              		.loc 1 931 0
 2199 0010 4B69     		ldr	r3, [r1, #20]
 2200 0012 C968     		ldr	r1, [r1, #12]
 2201              	.LVL220:
 2202 0014 5B1A     		subs	r3, r3, r1
 2203 0016 1360     		str	r3, [r2]
 920:../drivers/fsl_spi.c **** 
 2204              		.loc 1 920 0
 2205 0018 0020     		movs	r0, #0
 2206 001a 06E0     		b	.L159
 2207              	.LVL221:
 2208              	.L161:
 935:../drivers/fsl_spi.c ****         }
 2209              		.loc 1 935 0
 2210 001c 4B69     		ldr	r3, [r1, #20]
 2211 001e 8968     		ldr	r1, [r1, #8]
 2212              	.LVL222:
 2213 0020 5B1A     		subs	r3, r3, r1
 2214 0022 1360     		str	r3, [r2]
 920:../drivers/fsl_spi.c **** 
 2215              		.loc 1 920 0
 2216 0024 0020     		movs	r0, #0
 2217 0026 00E0     		b	.L159
 2218              	.LVL223:
 2219              	.L162:
 924:../drivers/fsl_spi.c ****     }
 2220              		.loc 1 924 0
 2221 0028 0620     		movs	r0, #6
 2222              	.LVL224:
 2223              	.L159:
 940:../drivers/fsl_spi.c **** 
 2224              		.loc 1 940 0
 2225              		@ sp needed
 2226 002a 7047     		bx	lr
 2227              		.cfi_endproc
 2228              	.LFE86:
 2230              		.section	.text.SPI_MasterTransferAbort,"ax",%progbits
 2231              		.align	1
 2232              		.global	SPI_MasterTransferAbort
 2233              		.syntax unified
 2234              		.code	16
 2235              		.thumb_func
 2236              		.fpu softvfp
 2238              	SPI_MasterTransferAbort:
 2239              	.LFB87:
 943:../drivers/fsl_spi.c ****     assert(handle);
 2240              		.loc 1 943 0
 2241              		.cfi_startproc
 2242              		@ args = 0, pretend = 0, frame = 0
 2243              		@ frame_needed = 0, uses_anonymous_args = 0
 2244              	.LVL225:
 2245 0000 10B5     		push	{r4, lr}
 2246              		.cfi_def_cfa_offset 8
 2247              		.cfi_offset 4, -8
 2248              		.cfi_offset 14, -4
 2249 0002 0C00     		movs	r4, r1
 948:../drivers/fsl_spi.c ****     {
 2250              		.loc 1 948 0
 2251 0004 4B7E     		ldrb	r3, [r1, #25]
 2252 0006 012B     		cmp	r3, #1
 2253 0008 07D9     		bls	.L164
 950:../drivers/fsl_spi.c ****     }
 2254              		.loc 1 950 0
 2255 000a 0921     		movs	r1, #9
 2256              	.LVL226:
 2257 000c FFF7FEFF 		bl	SPI_DisableInterrupts
 2258              	.LVL227:
 2259              	.L165:
 961:../drivers/fsl_spi.c **** 
 2260              		.loc 1 961 0
 2261 0010 0023     		movs	r3, #0
 2262 0012 2361     		str	r3, [r4, #16]
 964:../drivers/fsl_spi.c ****     handle->txRemainingBytes = 0;
 2263              		.loc 1 964 0
 2264 0014 E360     		str	r3, [r4, #12]
 965:../drivers/fsl_spi.c **** }
 2265              		.loc 1 965 0
 2266 0016 A360     		str	r3, [r4, #8]
 966:../drivers/fsl_spi.c **** 
 2267              		.loc 1 966 0
 2268              		@ sp needed
 2269              	.LVL228:
 2270 0018 10BD     		pop	{r4, pc}
 2271              	.LVL229:
 2272              	.L164:
 954:../drivers/fsl_spi.c ****     }
 2273              		.loc 1 954 0
 2274 001a 0121     		movs	r1, #1
 2275              	.LVL230:
 2276 001c FFF7FEFF 		bl	SPI_DisableInterrupts
 2277              	.LVL231:
 2278 0020 F6E7     		b	.L165
 2279              		.cfi_endproc
 2280              	.LFE87:
 2282              		.section	.text.SPI_MasterTransferHandleIRQ,"ax",%progbits
 2283              		.align	1
 2284              		.global	SPI_MasterTransferHandleIRQ
 2285              		.syntax unified
 2286              		.code	16
 2287              		.thumb_func
 2288              		.fpu softvfp
 2290              	SPI_MasterTransferHandleIRQ:
 2291              	.LFB88:
 969:../drivers/fsl_spi.c ****     assert(handle);
 2292              		.loc 1 969 0
 2293              		.cfi_startproc
 2294              		@ args = 0, pretend = 0, frame = 0
 2295              		@ frame_needed = 0, uses_anonymous_args = 0
 2296              	.LVL232:
 2297 0000 70B5     		push	{r4, r5, r6, lr}
 2298              		.cfi_def_cfa_offset 16
 2299              		.cfi_offset 4, -16
 2300              		.cfi_offset 5, -12
 2301              		.cfi_offset 6, -8
 2302              		.cfi_offset 14, -4
 2303 0002 0500     		movs	r5, r0
 2304 0004 0C00     		movs	r4, r1
 973:../drivers/fsl_spi.c ****     {
 2305              		.loc 1 973 0
 2306 0006 CB68     		ldr	r3, [r1, #12]
 2307 0008 002B     		cmp	r3, #0
 2308 000a 09D1     		bne	.L170
 2309              	.LVL233:
 2310              	.L167:
 979:../drivers/fsl_spi.c ****     {
 2311              		.loc 1 979 0
 2312 000c A368     		ldr	r3, [r4, #8]
 2313 000e 002B     		cmp	r3, #0
 2314 0010 09D1     		bne	.L171
 2315              	.L168:
 985:../drivers/fsl_spi.c ****     {
 2316              		.loc 1 985 0
 2317 0012 A368     		ldr	r3, [r4, #8]
 2318 0014 002B     		cmp	r3, #0
 2319 0016 02D1     		bne	.L166
 985:../drivers/fsl_spi.c ****     {
 2320              		.loc 1 985 0 is_stmt 0 discriminator 1
 2321 0018 E368     		ldr	r3, [r4, #12]
 2322 001a 002B     		cmp	r3, #0
 2323 001c 08D0     		beq	.L172
 2324              	.L166:
 995:../drivers/fsl_spi.c **** 
 2325              		.loc 1 995 0 is_stmt 1
 2326              		@ sp needed
 2327              	.LVL234:
 2328              	.LVL235:
 2329 001e 70BD     		pop	{r4, r5, r6, pc}
 2330              	.LVL236:
 2331              	.L170:
 975:../drivers/fsl_spi.c ****     }
 2332              		.loc 1 975 0
 2333 0020 FFF7FEFF 		bl	SPI_ReceiveTransfer
 2334              	.LVL237:
 2335 0024 F2E7     		b	.L167
 2336              	.L171:
 981:../drivers/fsl_spi.c ****     }
 2337              		.loc 1 981 0
 2338 0026 2100     		movs	r1, r4
 2339 0028 2800     		movs	r0, r5
 2340 002a FFF7FEFF 		bl	SPI_SendTransfer
 2341              	.LVL238:
 2342 002e F0E7     		b	.L168
 2343              	.L172:
 988:../drivers/fsl_spi.c **** 
 2344              		.loc 1 988 0
 2345 0030 2100     		movs	r1, r4
 2346 0032 2800     		movs	r0, r5
 2347 0034 FFF7FEFF 		bl	SPI_MasterTransferAbort
 2348              	.LVL239:
 990:../drivers/fsl_spi.c ****         {
 2349              		.loc 1 990 0
 2350 0038 E669     		ldr	r6, [r4, #28]
 2351 003a 002E     		cmp	r6, #0
 2352 003c EFD0     		beq	.L166
 992:../drivers/fsl_spi.c ****         }
 2353              		.loc 1 992 0
 2354 003e 236A     		ldr	r3, [r4, #32]
 2355 0040 024A     		ldr	r2, .L173
 2356 0042 2100     		movs	r1, r4
 2357 0044 2800     		movs	r0, r5
 2358 0046 B047     		blx	r6
 2359              	.LVL240:
 995:../drivers/fsl_spi.c **** 
 2360              		.loc 1 995 0
 2361 0048 E9E7     		b	.L166
 2362              	.L174:
 2363 004a C046     		.align	2
 2364              	.L173:
 2365 004c 79050000 		.word	1401
 2366              		.cfi_endproc
 2367              	.LFE88:
 2369              		.section	.text.SPI_SlaveTransferHandleIRQ,"ax",%progbits
 2370              		.align	1
 2371              		.global	SPI_SlaveTransferHandleIRQ
 2372              		.syntax unified
 2373              		.code	16
 2374              		.thumb_func
 2375              		.fpu softvfp
 2377              	SPI_SlaveTransferHandleIRQ:
 2378              	.LFB90:
1011:../drivers/fsl_spi.c ****     assert(handle);
 2379              		.loc 1 1011 0
 2380              		.cfi_startproc
 2381              		@ args = 0, pretend = 0, frame = 0
 2382              		@ frame_needed = 0, uses_anonymous_args = 0
 2383              	.LVL241:
 2384 0000 70B5     		push	{r4, r5, r6, lr}
 2385              		.cfi_def_cfa_offset 16
 2386              		.cfi_offset 4, -16
 2387              		.cfi_offset 5, -12
 2388              		.cfi_offset 6, -8
 2389              		.cfi_offset 14, -4
 2390 0002 0500     		movs	r5, r0
 2391 0004 0C00     		movs	r4, r1
1015:../drivers/fsl_spi.c ****     {
 2392              		.loc 1 1015 0
 2393 0006 8B68     		ldr	r3, [r1, #8]
 2394 0008 002B     		cmp	r3, #0
 2395 000a 09D1     		bne	.L179
 2396              	.LVL242:
 2397              	.L176:
1021:../drivers/fsl_spi.c ****     {
 2398              		.loc 1 1021 0
 2399 000c E368     		ldr	r3, [r4, #12]
 2400 000e 002B     		cmp	r3, #0
 2401 0010 09D1     		bne	.L180
 2402              	.L177:
1027:../drivers/fsl_spi.c ****     {
 2403              		.loc 1 1027 0
 2404 0012 A368     		ldr	r3, [r4, #8]
 2405 0014 002B     		cmp	r3, #0
 2406 0016 02D1     		bne	.L175
1027:../drivers/fsl_spi.c ****     {
 2407              		.loc 1 1027 0 is_stmt 0 discriminator 1
 2408 0018 E368     		ldr	r3, [r4, #12]
 2409 001a 002B     		cmp	r3, #0
 2410 001c 08D0     		beq	.L181
 2411              	.L175:
1037:../drivers/fsl_spi.c **** 
 2412              		.loc 1 1037 0 is_stmt 1
 2413              		@ sp needed
 2414              	.LVL243:
 2415              	.LVL244:
 2416 001e 70BD     		pop	{r4, r5, r6, pc}
 2417              	.LVL245:
 2418              	.L179:
1017:../drivers/fsl_spi.c ****     }
 2419              		.loc 1 1017 0
 2420 0020 FFF7FEFF 		bl	SPI_SendTransfer
 2421              	.LVL246:
 2422 0024 F2E7     		b	.L176
 2423              	.L180:
1023:../drivers/fsl_spi.c ****     }
 2424              		.loc 1 1023 0
 2425 0026 2100     		movs	r1, r4
 2426 0028 2800     		movs	r0, r5
 2427 002a FFF7FEFF 		bl	SPI_ReceiveTransfer
 2428              	.LVL247:
 2429 002e F0E7     		b	.L177
 2430              	.L181:
 2431              	.LVL248:
 2432              	.LBB27:
 2433              	.LBB28:
 2434              		.file 5 "../drivers/fsl_spi.h"
   1:../drivers/fsl_spi.h **** /*
   2:../drivers/fsl_spi.h ****  * The Clear BSD License
   3:../drivers/fsl_spi.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_spi.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_spi.h ****  * All rights reserved.
   6:../drivers/fsl_spi.h ****  *
   7:../drivers/fsl_spi.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_spi.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_spi.h ****  * that the following conditions are met:
  10:../drivers/fsl_spi.h ****  *
  11:../drivers/fsl_spi.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_spi.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_spi.h ****  *
  14:../drivers/fsl_spi.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_spi.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_spi.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_spi.h ****  *
  18:../drivers/fsl_spi.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_spi.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_spi.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_spi.h ****  *
  22:../drivers/fsl_spi.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_spi.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_spi.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_spi.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_spi.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_spi.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_spi.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_spi.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_spi.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_spi.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_spi.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_spi.h ****  */
  34:../drivers/fsl_spi.h **** #ifndef _FSL_SPI_H_
  35:../drivers/fsl_spi.h **** #define _FSL_SPI_H_
  36:../drivers/fsl_spi.h **** 
  37:../drivers/fsl_spi.h **** #include "fsl_common.h"
  38:../drivers/fsl_spi.h **** 
  39:../drivers/fsl_spi.h **** /*!
  40:../drivers/fsl_spi.h ****  * @addtogroup spi_driver
  41:../drivers/fsl_spi.h ****  * @{
  42:../drivers/fsl_spi.h ****  */
  43:../drivers/fsl_spi.h **** 
  44:../drivers/fsl_spi.h **** /*******************************************************************************
  45:../drivers/fsl_spi.h ****  * Definitions
  46:../drivers/fsl_spi.h ****  ******************************************************************************/
  47:../drivers/fsl_spi.h **** 
  48:../drivers/fsl_spi.h **** /*! @name Driver version */
  49:../drivers/fsl_spi.h **** /*@{*/
  50:../drivers/fsl_spi.h **** /*! @brief SPI driver version 2.0.4. */
  51:../drivers/fsl_spi.h **** #define FSL_SPI_DRIVER_VERSION (MAKE_VERSION(2, 0, 4))
  52:../drivers/fsl_spi.h **** /*@}*/
  53:../drivers/fsl_spi.h **** 
  54:../drivers/fsl_spi.h **** #ifndef SPI_DUMMYDATA
  55:../drivers/fsl_spi.h **** /*! @brief SPI dummy transfer data, the data is sent while txBuff is NULL. */
  56:../drivers/fsl_spi.h **** #define SPI_DUMMYDATA (0xFFU)
  57:../drivers/fsl_spi.h **** #endif
  58:../drivers/fsl_spi.h **** 
  59:../drivers/fsl_spi.h **** /*! @brief Return status for the SPI driver.*/
  60:../drivers/fsl_spi.h **** enum _spi_status
  61:../drivers/fsl_spi.h **** {
  62:../drivers/fsl_spi.h ****     kStatus_SPI_Busy = MAKE_STATUS(kStatusGroup_SPI, 0), /*!< SPI bus is busy */
  63:../drivers/fsl_spi.h ****     kStatus_SPI_Idle = MAKE_STATUS(kStatusGroup_SPI, 1), /*!< SPI is idle */
  64:../drivers/fsl_spi.h ****     kStatus_SPI_Error = MAKE_STATUS(kStatusGroup_SPI, 2) /*!< SPI  error */
  65:../drivers/fsl_spi.h **** };
  66:../drivers/fsl_spi.h **** 
  67:../drivers/fsl_spi.h **** /*! @brief SPI clock polarity configuration.*/
  68:../drivers/fsl_spi.h **** typedef enum _spi_clock_polarity
  69:../drivers/fsl_spi.h **** {
  70:../drivers/fsl_spi.h ****     kSPI_ClockPolarityActiveHigh = 0x0U, /*!< Active-high SPI clock (idles low). */
  71:../drivers/fsl_spi.h ****     kSPI_ClockPolarityActiveLow          /*!< Active-low SPI clock (idles high). */
  72:../drivers/fsl_spi.h **** } spi_clock_polarity_t;
  73:../drivers/fsl_spi.h **** 
  74:../drivers/fsl_spi.h **** /*! @brief SPI clock phase configuration.*/
  75:../drivers/fsl_spi.h **** typedef enum _spi_clock_phase
  76:../drivers/fsl_spi.h **** {
  77:../drivers/fsl_spi.h ****     kSPI_ClockPhaseFirstEdge = 0x0U, /*!< First edge on SPSCK occurs at the middle of the first
  78:../drivers/fsl_spi.h ****                                       *   cycle of a data transfer. */
  79:../drivers/fsl_spi.h ****     kSPI_ClockPhaseSecondEdge        /*!< First edge on SPSCK occurs at the start of the
  80:../drivers/fsl_spi.h ****                                       *   first cycle of a data transfer. */
  81:../drivers/fsl_spi.h **** } spi_clock_phase_t;
  82:../drivers/fsl_spi.h **** 
  83:../drivers/fsl_spi.h **** /*! @brief SPI data shifter direction options.*/
  84:../drivers/fsl_spi.h **** typedef enum _spi_shift_direction
  85:../drivers/fsl_spi.h **** {
  86:../drivers/fsl_spi.h ****     kSPI_MsbFirst = 0x0U, /*!< Data transfers start with most significant bit. */
  87:../drivers/fsl_spi.h ****     kSPI_LsbFirst         /*!< Data transfers start with least significant bit. */
  88:../drivers/fsl_spi.h **** } spi_shift_direction_t;
  89:../drivers/fsl_spi.h **** 
  90:../drivers/fsl_spi.h **** /*! @brief SPI slave select output mode options.*/
  91:../drivers/fsl_spi.h **** typedef enum _spi_ss_output_mode
  92:../drivers/fsl_spi.h **** {
  93:../drivers/fsl_spi.h ****     kSPI_SlaveSelectAsGpio = 0x0U,         /*!< Slave select pin configured as GPIO. */
  94:../drivers/fsl_spi.h ****     kSPI_SlaveSelectFaultInput = 0x2U,     /*!< Slave select pin configured for fault detection. */
  95:../drivers/fsl_spi.h ****     kSPI_SlaveSelectAutomaticOutput = 0x3U /*!< Slave select pin configured for automatic SPI outpu
  96:../drivers/fsl_spi.h **** } spi_ss_output_mode_t;
  97:../drivers/fsl_spi.h **** 
  98:../drivers/fsl_spi.h **** /*! @brief SPI pin mode options.*/
  99:../drivers/fsl_spi.h **** typedef enum _spi_pin_mode
 100:../drivers/fsl_spi.h **** {
 101:../drivers/fsl_spi.h ****     kSPI_PinModeNormal = 0x0U, /*!< Pins operate in normal, single-direction mode.*/
 102:../drivers/fsl_spi.h ****     kSPI_PinModeInput = 0x1U,  /*!< Bidirectional mode. Master: MOSI pin is input;
 103:../drivers/fsl_spi.h ****                                 *   Slave: MISO pin is input. */
 104:../drivers/fsl_spi.h ****     kSPI_PinModeOutput = 0x3U  /*!< Bidirectional mode. Master: MOSI pin is output;
 105:../drivers/fsl_spi.h ****                                 *   Slave: MISO pin is output. */
 106:../drivers/fsl_spi.h **** } spi_pin_mode_t;
 107:../drivers/fsl_spi.h **** 
 108:../drivers/fsl_spi.h **** /*! @brief SPI data length mode options.*/
 109:../drivers/fsl_spi.h **** typedef enum _spi_data_bitcount_mode
 110:../drivers/fsl_spi.h **** {
 111:../drivers/fsl_spi.h ****     kSPI_8BitMode = 0x0U, /*!< 8-bit data transmission mode*/
 112:../drivers/fsl_spi.h ****     kSPI_16BitMode        /*!< 16-bit data transmission mode*/
 113:../drivers/fsl_spi.h **** } spi_data_bitcount_mode_t;
 114:../drivers/fsl_spi.h **** 
 115:../drivers/fsl_spi.h **** /*! @brief SPI interrupt sources.*/
 116:../drivers/fsl_spi.h **** enum _spi_interrupt_enable
 117:../drivers/fsl_spi.h **** {
 118:../drivers/fsl_spi.h ****     kSPI_RxFullAndModfInterruptEnable = 0x1U, /*!< Receive buffer full (SPRF) and mode fault (MODF)
 119:../drivers/fsl_spi.h ****     kSPI_TxEmptyInterruptEnable = 0x2U,       /*!< Transmit buffer empty interrupt */
 120:../drivers/fsl_spi.h ****     kSPI_MatchInterruptEnable = 0x4U,         /*!< Match interrupt */
 121:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 122:../drivers/fsl_spi.h ****     kSPI_RxFifoNearFullInterruptEnable = 0x8U,   /*!< Receive FIFO nearly full interrupt */
 123:../drivers/fsl_spi.h ****     kSPI_TxFifoNearEmptyInterruptEnable = 0x10U, /*!< Transmit FIFO nearly empty interrupt */
 124:../drivers/fsl_spi.h **** #endif                                           /* FSL_FEATURE_SPI_HAS_FIFO */
 125:../drivers/fsl_spi.h **** };
 126:../drivers/fsl_spi.h **** 
 127:../drivers/fsl_spi.h **** /*! @brief SPI status flags.*/
 128:../drivers/fsl_spi.h **** enum _spi_flags
 129:../drivers/fsl_spi.h **** {
 130:../drivers/fsl_spi.h ****     kSPI_RxBufferFullFlag = SPI_S_SPRF_MASK,   /*!< Read buffer full flag */
 131:../drivers/fsl_spi.h ****     kSPI_MatchFlag = SPI_S_SPMF_MASK,          /*!< Match flag */
 132:../drivers/fsl_spi.h ****     kSPI_TxBufferEmptyFlag = SPI_S_SPTEF_MASK, /*!< Transmit buffer empty flag */
 133:../drivers/fsl_spi.h ****     kSPI_ModeFaultFlag = SPI_S_MODF_MASK,      /*!< Mode fault flag */
 134:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 135:../drivers/fsl_spi.h ****     kSPI_RxFifoNearFullFlag = SPI_S_RNFULLF_MASK,  /*!< Rx FIFO near full */
 136:../drivers/fsl_spi.h ****     kSPI_TxFifoNearEmptyFlag = SPI_S_TNEAREF_MASK, /*!< Tx FIFO near empty */
 137:../drivers/fsl_spi.h ****     kSPI_TxFifoFullFlag = SPI_S_TXFULLF_MASK,      /*!< Tx FIFO full */
 138:../drivers/fsl_spi.h ****     kSPI_RxFifoEmptyFlag = SPI_S_RFIFOEF_MASK,     /*!< Rx FIFO empty */
 139:../drivers/fsl_spi.h ****     kSPI_TxFifoError = SPI_CI_TXFERR_MASK << 8U,   /*!< Tx FIFO error */
 140:../drivers/fsl_spi.h ****     kSPI_RxFifoError = SPI_CI_RXFERR_MASK << 8U,   /*!< Rx FIFO error */
 141:../drivers/fsl_spi.h ****     kSPI_TxOverflow = SPI_CI_TXFOF_MASK << 8U,     /*!< Tx FIFO Overflow */
 142:../drivers/fsl_spi.h ****     kSPI_RxOverflow = SPI_CI_RXFOF_MASK << 8U      /*!< Rx FIFO Overflow */
 143:../drivers/fsl_spi.h **** #endif                                             /* FSL_FEATURE_SPI_HAS_FIFO */
 144:../drivers/fsl_spi.h **** };
 145:../drivers/fsl_spi.h **** 
 146:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 147:../drivers/fsl_spi.h **** /*! @brief SPI FIFO write-1-to-clear interrupt flags.*/
 148:../drivers/fsl_spi.h **** typedef enum _spi_w1c_interrupt
 149:../drivers/fsl_spi.h **** {
 150:../drivers/fsl_spi.h ****     kSPI_RxFifoFullClearInterrupt = SPI_CI_SPRFCI_MASK,    /*!< Receive FIFO full interrupt */
 151:../drivers/fsl_spi.h ****     kSPI_TxFifoEmptyClearInterrupt = SPI_CI_SPTEFCI_MASK,  /*!< Transmit FIFO empty interrupt */
 152:../drivers/fsl_spi.h ****     kSPI_RxNearFullClearInterrupt = SPI_CI_RNFULLFCI_MASK, /*!< Receive FIFO nearly full interrupt 
 153:../drivers/fsl_spi.h ****     kSPI_TxNearEmptyClearInterrupt = SPI_CI_TNEAREFCI_MASK /*!< Transmit FIFO nearly empty interrup
 154:../drivers/fsl_spi.h **** } spi_w1c_interrupt_t;
 155:../drivers/fsl_spi.h **** 
 156:../drivers/fsl_spi.h **** /*! @brief SPI TX FIFO watermark settings.*/
 157:../drivers/fsl_spi.h **** typedef enum _spi_txfifo_watermark
 158:../drivers/fsl_spi.h **** {
 159:../drivers/fsl_spi.h ****     kSPI_TxFifoOneFourthEmpty = 0, /*!< SPI tx watermark at 1/4 FIFO size */
 160:../drivers/fsl_spi.h ****     kSPI_TxFifoOneHalfEmpty = 1    /*!< SPI tx watermark at 1/2 FIFO size */
 161:../drivers/fsl_spi.h **** } spi_txfifo_watermark_t;
 162:../drivers/fsl_spi.h **** 
 163:../drivers/fsl_spi.h **** /*! @brief SPI RX FIFO watermark settings.*/
 164:../drivers/fsl_spi.h **** typedef enum _spi_rxfifo_watermark
 165:../drivers/fsl_spi.h **** {
 166:../drivers/fsl_spi.h ****     kSPI_RxFifoThreeFourthsFull = 0, /*!< SPI rx watermark at 3/4 FIFO size */
 167:../drivers/fsl_spi.h ****     kSPI_RxFifoOneHalfFull = 1       /*!< SPI rx watermark at 1/2 FIFO size */
 168:../drivers/fsl_spi.h **** } spi_rxfifo_watermark_t;
 169:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 170:../drivers/fsl_spi.h **** 
 171:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_DMA_SUPPORT) && FSL_FEATURE_SPI_HAS_DMA_SUPPORT
 172:../drivers/fsl_spi.h **** /*! @brief SPI DMA source*/
 173:../drivers/fsl_spi.h **** enum _spi_dma_enable_t
 174:../drivers/fsl_spi.h **** {
 175:../drivers/fsl_spi.h ****     kSPI_TxDmaEnable = SPI_C2_TXDMAE_MASK,                        /*!< Tx DMA request source */
 176:../drivers/fsl_spi.h ****     kSPI_RxDmaEnable = SPI_C2_RXDMAE_MASK,                        /*!< Rx DMA request source */
 177:../drivers/fsl_spi.h ****     kSPI_DmaAllEnable = (SPI_C2_TXDMAE_MASK | SPI_C2_RXDMAE_MASK) /*!< All DMA request source*/
 178:../drivers/fsl_spi.h **** };
 179:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_DMA_SUPPORT */
 180:../drivers/fsl_spi.h **** 
 181:../drivers/fsl_spi.h **** /*! @brief SPI master user configure structure.*/
 182:../drivers/fsl_spi.h **** typedef struct _spi_master_config
 183:../drivers/fsl_spi.h **** {
 184:../drivers/fsl_spi.h ****     bool enableMaster;               /*!< Enable SPI at initialization time */
 185:../drivers/fsl_spi.h ****     bool enableStopInWaitMode;       /*!< SPI stop in wait mode */
 186:../drivers/fsl_spi.h ****     spi_clock_polarity_t polarity;   /*!< Clock polarity */
 187:../drivers/fsl_spi.h ****     spi_clock_phase_t phase;         /*!< Clock phase */
 188:../drivers/fsl_spi.h ****     spi_shift_direction_t direction; /*!< MSB or LSB */
 189:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 190:../drivers/fsl_spi.h ****     spi_data_bitcount_mode_t dataMode; /*!< 8bit or 16bit mode */
 191:../drivers/fsl_spi.h **** #endif                                 /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 192:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 193:../drivers/fsl_spi.h ****     spi_txfifo_watermark_t txWatermark; /*!< Tx watermark settings */
 194:../drivers/fsl_spi.h ****     spi_rxfifo_watermark_t rxWatermark; /*!< Rx watermark settings */
 195:../drivers/fsl_spi.h **** #endif                                  /* FSL_FEATURE_SPI_HAS_FIFO */
 196:../drivers/fsl_spi.h ****     spi_ss_output_mode_t outputMode;    /*!< SS pin setting */
 197:../drivers/fsl_spi.h ****     spi_pin_mode_t pinMode;             /*!< SPI pin mode select */
 198:../drivers/fsl_spi.h ****     uint32_t baudRate_Bps;              /*!< Baud Rate for SPI in Hz */
 199:../drivers/fsl_spi.h **** } spi_master_config_t;
 200:../drivers/fsl_spi.h **** 
 201:../drivers/fsl_spi.h **** /*! @brief SPI slave user configure structure.*/
 202:../drivers/fsl_spi.h **** typedef struct _spi_slave_config
 203:../drivers/fsl_spi.h **** {
 204:../drivers/fsl_spi.h ****     bool enableSlave;                /*!< Enable SPI at initialization time */
 205:../drivers/fsl_spi.h ****     bool enableStopInWaitMode;       /*!< SPI stop in wait mode */
 206:../drivers/fsl_spi.h ****     spi_clock_polarity_t polarity;   /*!< Clock polarity */
 207:../drivers/fsl_spi.h ****     spi_clock_phase_t phase;         /*!< Clock phase */
 208:../drivers/fsl_spi.h ****     spi_shift_direction_t direction; /*!< MSB or LSB */
 209:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 210:../drivers/fsl_spi.h ****     spi_data_bitcount_mode_t dataMode; /*!< 8bit or 16bit mode */
 211:../drivers/fsl_spi.h **** #endif                                 /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 212:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 213:../drivers/fsl_spi.h ****     spi_txfifo_watermark_t txWatermark; /*!< Tx watermark settings */
 214:../drivers/fsl_spi.h ****     spi_rxfifo_watermark_t rxWatermark; /*!< Rx watermark settings */
 215:../drivers/fsl_spi.h **** #endif                                  /* FSL_FEATURE_SPI_HAS_FIFO */
 216:../drivers/fsl_spi.h ****     spi_pin_mode_t pinMode;             /*!< SPI pin mode select */
 217:../drivers/fsl_spi.h **** } spi_slave_config_t;
 218:../drivers/fsl_spi.h **** 
 219:../drivers/fsl_spi.h **** /*! @brief SPI transfer structure */
 220:../drivers/fsl_spi.h **** typedef struct _spi_transfer
 221:../drivers/fsl_spi.h **** {
 222:../drivers/fsl_spi.h ****     uint8_t *txData; /*!< Send buffer */
 223:../drivers/fsl_spi.h ****     uint8_t *rxData; /*!< Receive buffer */
 224:../drivers/fsl_spi.h ****     size_t dataSize; /*!< Transfer bytes */
 225:../drivers/fsl_spi.h ****     uint32_t flags;  /*!< SPI control flag, useless to SPI.*/
 226:../drivers/fsl_spi.h **** } spi_transfer_t;
 227:../drivers/fsl_spi.h **** 
 228:../drivers/fsl_spi.h **** typedef struct _spi_master_handle spi_master_handle_t;
 229:../drivers/fsl_spi.h **** 
 230:../drivers/fsl_spi.h **** /*! @brief  Slave handle is the same with master handle  */
 231:../drivers/fsl_spi.h **** typedef spi_master_handle_t spi_slave_handle_t;
 232:../drivers/fsl_spi.h **** 
 233:../drivers/fsl_spi.h **** /*! @brief SPI master callback for finished transmit */
 234:../drivers/fsl_spi.h **** typedef void (*spi_master_callback_t)(SPI_Type *base, spi_master_handle_t *handle, status_t status,
 235:../drivers/fsl_spi.h **** 
 236:../drivers/fsl_spi.h **** /*! @brief SPI master callback for finished transmit */
 237:../drivers/fsl_spi.h **** typedef void (*spi_slave_callback_t)(SPI_Type *base, spi_slave_handle_t *handle, status_t status, v
 238:../drivers/fsl_spi.h **** 
 239:../drivers/fsl_spi.h **** /*! @brief SPI transfer handle structure */
 240:../drivers/fsl_spi.h **** struct _spi_master_handle
 241:../drivers/fsl_spi.h **** {
 242:../drivers/fsl_spi.h ****     uint8_t *volatile txData;         /*!< Transfer buffer */
 243:../drivers/fsl_spi.h ****     uint8_t *volatile rxData;         /*!< Receive buffer */
 244:../drivers/fsl_spi.h ****     volatile size_t txRemainingBytes; /*!< Send data remaining in bytes */
 245:../drivers/fsl_spi.h ****     volatile size_t rxRemainingBytes; /*!< Receive data remaining in bytes */
 246:../drivers/fsl_spi.h ****     volatile uint32_t state;          /*!< SPI internal state */
 247:../drivers/fsl_spi.h ****     size_t transferSize;              /*!< Bytes to be transferred */
 248:../drivers/fsl_spi.h ****     uint8_t bytePerFrame;             /*!< SPI mode, 2bytes or 1byte in a frame */
 249:../drivers/fsl_spi.h ****     uint8_t watermark;                /*!< Watermark value for SPI transfer */
 250:../drivers/fsl_spi.h ****     spi_master_callback_t callback;   /*!< SPI callback */
 251:../drivers/fsl_spi.h ****     void *userData;                   /*!< Callback parameter */
 252:../drivers/fsl_spi.h **** };
 253:../drivers/fsl_spi.h **** 
 254:../drivers/fsl_spi.h **** #if defined(__cplusplus)
 255:../drivers/fsl_spi.h **** extern "C" {
 256:../drivers/fsl_spi.h **** #endif
 257:../drivers/fsl_spi.h **** /*******************************************************************************
 258:../drivers/fsl_spi.h ****  * APIs
 259:../drivers/fsl_spi.h ****  ******************************************************************************/
 260:../drivers/fsl_spi.h **** /*!
 261:../drivers/fsl_spi.h ****  * @name Initialization and deinitialization
 262:../drivers/fsl_spi.h ****  * @{
 263:../drivers/fsl_spi.h ****  */
 264:../drivers/fsl_spi.h **** 
 265:../drivers/fsl_spi.h **** /*!
 266:../drivers/fsl_spi.h ****  * @brief  Sets the SPI master configuration structure to default values.
 267:../drivers/fsl_spi.h ****  *
 268:../drivers/fsl_spi.h ****  * The purpose of this API is to get the configuration structure initialized for use in SPI_MasterI
 269:../drivers/fsl_spi.h ****  * User may use the initialized structure unchanged in SPI_MasterInit(), or modify
 270:../drivers/fsl_spi.h ****  * some fields of the structure before calling SPI_MasterInit(). After calling this API,
 271:../drivers/fsl_spi.h ****  * the master is ready to transfer.
 272:../drivers/fsl_spi.h ****  * Example:
 273:../drivers/fsl_spi.h ****    @code
 274:../drivers/fsl_spi.h ****    spi_master_config_t config;
 275:../drivers/fsl_spi.h ****    SPI_MasterGetDefaultConfig(&config);
 276:../drivers/fsl_spi.h ****    @endcode
 277:../drivers/fsl_spi.h ****  *
 278:../drivers/fsl_spi.h ****  * @param config pointer to master config structure
 279:../drivers/fsl_spi.h ****  */
 280:../drivers/fsl_spi.h **** void SPI_MasterGetDefaultConfig(spi_master_config_t *config);
 281:../drivers/fsl_spi.h **** 
 282:../drivers/fsl_spi.h **** /*!
 283:../drivers/fsl_spi.h ****  * @brief Initializes the SPI with master configuration.
 284:../drivers/fsl_spi.h ****  *
 285:../drivers/fsl_spi.h ****  * The configuration structure can be filled by user from scratch, or be set with default
 286:../drivers/fsl_spi.h ****  * values by SPI_MasterGetDefaultConfig(). After calling this API, the slave is ready to transfer.
 287:../drivers/fsl_spi.h ****  * Example
 288:../drivers/fsl_spi.h ****    @code
 289:../drivers/fsl_spi.h ****    spi_master_config_t config = {
 290:../drivers/fsl_spi.h ****    .baudRate_Bps = 400000,
 291:../drivers/fsl_spi.h ****    ...
 292:../drivers/fsl_spi.h ****    };
 293:../drivers/fsl_spi.h ****    SPI_MasterInit(SPI0, &config);
 294:../drivers/fsl_spi.h ****    @endcode
 295:../drivers/fsl_spi.h ****  *
 296:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 297:../drivers/fsl_spi.h ****  * @param config pointer to master configuration structure
 298:../drivers/fsl_spi.h ****  * @param srcClock_Hz Source clock frequency.
 299:../drivers/fsl_spi.h ****  */
 300:../drivers/fsl_spi.h **** void SPI_MasterInit(SPI_Type *base, const spi_master_config_t *config, uint32_t srcClock_Hz);
 301:../drivers/fsl_spi.h **** 
 302:../drivers/fsl_spi.h **** /*!
 303:../drivers/fsl_spi.h ****  * @brief  Sets the SPI slave configuration structure to default values.
 304:../drivers/fsl_spi.h ****  *
 305:../drivers/fsl_spi.h ****  * The purpose of this API is to get the configuration structure initialized for use in SPI_SlaveIn
 306:../drivers/fsl_spi.h ****  * Modify some fields of the structure before calling SPI_SlaveInit().
 307:../drivers/fsl_spi.h ****  * Example:
 308:../drivers/fsl_spi.h ****    @code
 309:../drivers/fsl_spi.h ****    spi_slave_config_t config;
 310:../drivers/fsl_spi.h ****    SPI_SlaveGetDefaultConfig(&config);
 311:../drivers/fsl_spi.h ****    @endcode
 312:../drivers/fsl_spi.h ****  *
 313:../drivers/fsl_spi.h ****  * @param config pointer to slave configuration structure
 314:../drivers/fsl_spi.h ****  */
 315:../drivers/fsl_spi.h **** void SPI_SlaveGetDefaultConfig(spi_slave_config_t *config);
 316:../drivers/fsl_spi.h **** 
 317:../drivers/fsl_spi.h **** /*!
 318:../drivers/fsl_spi.h ****  * @brief Initializes the SPI with slave configuration.
 319:../drivers/fsl_spi.h ****  *
 320:../drivers/fsl_spi.h ****  * The configuration structure can be filled by user from scratch or be set with
 321:../drivers/fsl_spi.h ****  * default values by SPI_SlaveGetDefaultConfig().
 322:../drivers/fsl_spi.h ****  * After calling this API, the slave is ready to transfer.
 323:../drivers/fsl_spi.h ****  * Example
 324:../drivers/fsl_spi.h ****    @code
 325:../drivers/fsl_spi.h ****     spi_slave_config_t config = {
 326:../drivers/fsl_spi.h ****     .polarity = kSPIClockPolarity_ActiveHigh;
 327:../drivers/fsl_spi.h ****     .phase = kSPIClockPhase_FirstEdge;
 328:../drivers/fsl_spi.h ****     .direction = kSPIMsbFirst;
 329:../drivers/fsl_spi.h ****     ...
 330:../drivers/fsl_spi.h ****     };
 331:../drivers/fsl_spi.h ****     SPI_MasterInit(SPI0, &config);
 332:../drivers/fsl_spi.h ****    @endcode
 333:../drivers/fsl_spi.h ****  *
 334:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 335:../drivers/fsl_spi.h ****  * @param config pointer to master configuration structure
 336:../drivers/fsl_spi.h ****  */
 337:../drivers/fsl_spi.h **** void SPI_SlaveInit(SPI_Type *base, const spi_slave_config_t *config);
 338:../drivers/fsl_spi.h **** 
 339:../drivers/fsl_spi.h **** /*!
 340:../drivers/fsl_spi.h ****  * @brief De-initializes the SPI.
 341:../drivers/fsl_spi.h ****  *
 342:../drivers/fsl_spi.h ****  * Calling this API resets the SPI module, gates the SPI clock.
 343:../drivers/fsl_spi.h ****  * The SPI module can't work unless calling the SPI_MasterInit/SPI_SlaveInit to initialize module.
 344:../drivers/fsl_spi.h ****  *
 345:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 346:../drivers/fsl_spi.h ****  */
 347:../drivers/fsl_spi.h **** void SPI_Deinit(SPI_Type *base);
 348:../drivers/fsl_spi.h **** 
 349:../drivers/fsl_spi.h **** /*!
 350:../drivers/fsl_spi.h ****  * @brief Enables or disables the SPI.
 351:../drivers/fsl_spi.h ****  *
 352:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 353:../drivers/fsl_spi.h ****  * @param enable pass true to enable module, false to disable module
 354:../drivers/fsl_spi.h ****  */
 355:../drivers/fsl_spi.h **** static inline void SPI_Enable(SPI_Type *base, bool enable)
 356:../drivers/fsl_spi.h **** {
 357:../drivers/fsl_spi.h ****     if (enable)
 358:../drivers/fsl_spi.h ****     {
 359:../drivers/fsl_spi.h ****         base->C1 |= SPI_C1_SPE_MASK;
 360:../drivers/fsl_spi.h ****     }
 361:../drivers/fsl_spi.h ****     else
 362:../drivers/fsl_spi.h ****     {
 363:../drivers/fsl_spi.h ****         base->C1 &= ~SPI_C1_SPE_MASK;
 364:../drivers/fsl_spi.h ****     }
 365:../drivers/fsl_spi.h **** }
 366:../drivers/fsl_spi.h **** 
 367:../drivers/fsl_spi.h **** /*! @} */
 368:../drivers/fsl_spi.h **** 
 369:../drivers/fsl_spi.h **** /*!
 370:../drivers/fsl_spi.h ****  * @name Status
 371:../drivers/fsl_spi.h ****  * @{
 372:../drivers/fsl_spi.h ****  */
 373:../drivers/fsl_spi.h **** 
 374:../drivers/fsl_spi.h **** /*!
 375:../drivers/fsl_spi.h ****  * @brief Gets the status flag.
 376:../drivers/fsl_spi.h ****  *
 377:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 378:../drivers/fsl_spi.h ****  * @return SPI Status, use status flag to AND #_spi_flags could get the related status.
 379:../drivers/fsl_spi.h ****  */
 380:../drivers/fsl_spi.h **** uint32_t SPI_GetStatusFlags(SPI_Type *base);
 381:../drivers/fsl_spi.h **** 
 382:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 383:../drivers/fsl_spi.h **** /*!
 384:../drivers/fsl_spi.h ****  * @brief Clear the interrupt if enable INCTLR.
 385:../drivers/fsl_spi.h ****  *
 386:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 387:../drivers/fsl_spi.h ****  * @param interrupt Interrupt need to be cleared
 388:../drivers/fsl_spi.h ****  *      The parameter could be any combination of the following values:
 389:../drivers/fsl_spi.h ****  *          @arg kSPIRxFifoFullClearInt
 390:../drivers/fsl_spi.h ****  *          @arg kSPITxFifoEmptyClearInt
 391:../drivers/fsl_spi.h ****  *          @arg kSPIRxNearFullClearInt
 392:../drivers/fsl_spi.h ****  *          @arg kSPITxNearEmptyClearInt
 393:../drivers/fsl_spi.h ****  */
 394:../drivers/fsl_spi.h **** static inline void SPI_ClearInterrupt(SPI_Type *base, uint32_t mask)
 395:../drivers/fsl_spi.h **** {
 396:../drivers/fsl_spi.h ****     base->CI |= mask;
 397:../drivers/fsl_spi.h **** }
 398:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_FIFO */
 399:../drivers/fsl_spi.h **** 
 400:../drivers/fsl_spi.h **** /*! @} */
 401:../drivers/fsl_spi.h **** 
 402:../drivers/fsl_spi.h **** /*!
 403:../drivers/fsl_spi.h ****  * @name Interrupts
 404:../drivers/fsl_spi.h ****  * @{
 405:../drivers/fsl_spi.h ****  */
 406:../drivers/fsl_spi.h **** 
 407:../drivers/fsl_spi.h **** /*!
 408:../drivers/fsl_spi.h ****  * @brief Enables the interrupt for the SPI.
 409:../drivers/fsl_spi.h ****  *
 410:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 411:../drivers/fsl_spi.h ****  * @param mask SPI interrupt source. The parameter can be any combination of the following values:
 412:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFullAndModfInterruptEnable
 413:../drivers/fsl_spi.h ****  *        @arg kSPI_TxEmptyInterruptEnable
 414:../drivers/fsl_spi.h ****  *        @arg kSPI_MatchInterruptEnable
 415:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFifoNearFullInterruptEnable
 416:../drivers/fsl_spi.h ****  *        @arg kSPI_TxFifoNearEmptyInterruptEnable
 417:../drivers/fsl_spi.h ****  */
 418:../drivers/fsl_spi.h **** void SPI_EnableInterrupts(SPI_Type *base, uint32_t mask);
 419:../drivers/fsl_spi.h **** 
 420:../drivers/fsl_spi.h **** /*!
 421:../drivers/fsl_spi.h ****  * @brief Disables the interrupt for the SPI.
 422:../drivers/fsl_spi.h ****  *
 423:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 424:../drivers/fsl_spi.h ****  * @param mask SPI interrupt source. The parameter can be any combination of the following values:
 425:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFullAndModfInterruptEnable
 426:../drivers/fsl_spi.h ****  *        @arg kSPI_TxEmptyInterruptEnable
 427:../drivers/fsl_spi.h ****  *        @arg kSPI_MatchInterruptEnable
 428:../drivers/fsl_spi.h ****  *        @arg kSPI_RxFifoNearFullInterruptEnable
 429:../drivers/fsl_spi.h ****  *        @arg kSPI_TxFifoNearEmptyInterruptEnable
 430:../drivers/fsl_spi.h ****  */
 431:../drivers/fsl_spi.h **** void SPI_DisableInterrupts(SPI_Type *base, uint32_t mask);
 432:../drivers/fsl_spi.h **** 
 433:../drivers/fsl_spi.h **** /*! @} */
 434:../drivers/fsl_spi.h **** 
 435:../drivers/fsl_spi.h **** /*!
 436:../drivers/fsl_spi.h ****  * @name DMA Control
 437:../drivers/fsl_spi.h ****  * @{
 438:../drivers/fsl_spi.h ****  */
 439:../drivers/fsl_spi.h **** 
 440:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_DMA_SUPPORT) && FSL_FEATURE_SPI_HAS_DMA_SUPPORT
 441:../drivers/fsl_spi.h **** /*!
 442:../drivers/fsl_spi.h ****  * @brief Enables the DMA source for SPI.
 443:../drivers/fsl_spi.h ****  *
 444:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 445:../drivers/fsl_spi.h ****  * @param source SPI DMA source.
 446:../drivers/fsl_spi.h ****  * @param enable True means enable DMA, false means disable DMA
 447:../drivers/fsl_spi.h ****  */
 448:../drivers/fsl_spi.h **** static inline void SPI_EnableDMA(SPI_Type *base, uint32_t mask, bool enable)
 449:../drivers/fsl_spi.h **** {
 450:../drivers/fsl_spi.h ****     if (enable)
 451:../drivers/fsl_spi.h ****     {
 452:../drivers/fsl_spi.h ****         base->C2 |= mask;
 453:../drivers/fsl_spi.h ****     }
 454:../drivers/fsl_spi.h ****     else
 455:../drivers/fsl_spi.h ****     {
 456:../drivers/fsl_spi.h ****         base->C2 &= ~mask;
 457:../drivers/fsl_spi.h ****     }
 458:../drivers/fsl_spi.h **** }
 459:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_HAS_DMA_SUPPORT */
 460:../drivers/fsl_spi.h **** 
 461:../drivers/fsl_spi.h **** /*!
 462:../drivers/fsl_spi.h ****  * @brief  Gets the SPI tx/rx data register address.
 463:../drivers/fsl_spi.h ****  *
 464:../drivers/fsl_spi.h ****  * This API is used to provide a transfer address for the SPI DMA transfer configuration.
 465:../drivers/fsl_spi.h ****  *
 466:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 467:../drivers/fsl_spi.h ****  * @return data register address
 468:../drivers/fsl_spi.h ****  */
 469:../drivers/fsl_spi.h **** static inline uint32_t SPI_GetDataRegisterAddress(SPI_Type *base)
 470:../drivers/fsl_spi.h **** {
 471:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 472:../drivers/fsl_spi.h ****     return (uint32_t)(&(base->DL));
 473:../drivers/fsl_spi.h **** #else
 474:../drivers/fsl_spi.h ****     return (uint32_t)(&(base->D));
 475:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 476:../drivers/fsl_spi.h **** }
 477:../drivers/fsl_spi.h **** 
 478:../drivers/fsl_spi.h **** /*! @} */
 479:../drivers/fsl_spi.h **** 
 480:../drivers/fsl_spi.h **** /*!
 481:../drivers/fsl_spi.h ****  * @name Bus Operations
 482:../drivers/fsl_spi.h ****  * @{
 483:../drivers/fsl_spi.h ****  */
 484:../drivers/fsl_spi.h **** 
 485:../drivers/fsl_spi.h **** /*!
 486:../drivers/fsl_spi.h ****  * @brief Sets the pin mode for transfer.
 487:../drivers/fsl_spi.h ****  *
 488:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 489:../drivers/fsl_spi.h ****  * @param pinMode pin mode for transfer AND #_spi_pin_mode could get the related configuration.
 490:../drivers/fsl_spi.h ****  */
 491:../drivers/fsl_spi.h **** static inline void SPI_SetPinMode(SPI_Type *base, spi_pin_mode_t pinMode)
 492:../drivers/fsl_spi.h **** {
 493:../drivers/fsl_spi.h ****     /* Clear SPC0 and BIDIROE bit. */
 494:../drivers/fsl_spi.h ****     base->C2 &= ~(SPI_C2_BIDIROE_MASK | SPI_C2_SPC0_MASK);
 495:../drivers/fsl_spi.h ****     /* Set pin mode for transfer. */
 496:../drivers/fsl_spi.h ****     base->C2 |= SPI_C2_BIDIROE(pinMode >> 1U) | SPI_C2_SPC0(pinMode & 1U);
 497:../drivers/fsl_spi.h **** }
 498:../drivers/fsl_spi.h **** 
 499:../drivers/fsl_spi.h **** /*!
 500:../drivers/fsl_spi.h ****  * @brief Sets the baud rate for SPI transfer. This is only used in master.
 501:../drivers/fsl_spi.h ****  *
 502:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 503:../drivers/fsl_spi.h ****  * @param baudRate_Bps baud rate needed in Hz.
 504:../drivers/fsl_spi.h ****  * @param srcClock_Hz SPI source clock frequency in Hz.
 505:../drivers/fsl_spi.h ****  */
 506:../drivers/fsl_spi.h **** void SPI_MasterSetBaudRate(SPI_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz);
 507:../drivers/fsl_spi.h **** 
 508:../drivers/fsl_spi.h **** /*!
 509:../drivers/fsl_spi.h ****  * @brief Sets the match data for SPI.
 510:../drivers/fsl_spi.h ****  *
 511:../drivers/fsl_spi.h ****  * The match data is a hardware comparison value. When the value received in the SPI receive data
 512:../drivers/fsl_spi.h ****  * buffer equals the hardware comparison value, the SPI Match Flag in the S register (S[SPMF]) sets
 513:../drivers/fsl_spi.h ****  * This can also generate an interrupt if the enable bit sets.
 514:../drivers/fsl_spi.h ****  *
 515:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 516:../drivers/fsl_spi.h ****  * @param matchData Match data.
 517:../drivers/fsl_spi.h ****  */
 518:../drivers/fsl_spi.h **** static inline void SPI_SetMatchData(SPI_Type *base, uint32_t matchData)
 519:../drivers/fsl_spi.h **** {
 520:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_16BIT_TRANSFERS) && FSL_FEATURE_SPI_16BIT_TRANSFERS
 521:../drivers/fsl_spi.h ****     base->ML = matchData & 0xFFU;
 522:../drivers/fsl_spi.h ****     base->MH = (matchData >> 8U) & 0xFFU;
 523:../drivers/fsl_spi.h **** #else
 524:../drivers/fsl_spi.h ****     base->M = matchData;
 525:../drivers/fsl_spi.h **** #endif /* FSL_FEATURE_SPI_16BIT_TRANSFERS */
 526:../drivers/fsl_spi.h **** }
 527:../drivers/fsl_spi.h **** 
 528:../drivers/fsl_spi.h **** #if defined(FSL_FEATURE_SPI_HAS_FIFO) && FSL_FEATURE_SPI_HAS_FIFO
 529:../drivers/fsl_spi.h **** /*!
 530:../drivers/fsl_spi.h ****  * @brief Enables or disables the FIFO if there is a FIFO.
 531:../drivers/fsl_spi.h ****  *
 532:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 533:../drivers/fsl_spi.h ****  * @param enable True means enable FIFO, false means disable FIFO.
 534:../drivers/fsl_spi.h ****  */
 535:../drivers/fsl_spi.h **** void SPI_EnableFIFO(SPI_Type *base, bool enable);
 536:../drivers/fsl_spi.h **** #endif
 537:../drivers/fsl_spi.h **** 
 538:../drivers/fsl_spi.h **** /*!
 539:../drivers/fsl_spi.h ****  * @brief Sends a buffer of data bytes using a blocking method.
 540:../drivers/fsl_spi.h ****  *
 541:../drivers/fsl_spi.h ****  * @note This function blocks via polling until all bytes have been sent.
 542:../drivers/fsl_spi.h ****  *
 543:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 544:../drivers/fsl_spi.h ****  * @param buffer The data bytes to send
 545:../drivers/fsl_spi.h ****  * @param size The number of data bytes to send
 546:../drivers/fsl_spi.h ****  */
 547:../drivers/fsl_spi.h **** void SPI_WriteBlocking(SPI_Type *base, uint8_t *buffer, size_t size);
 548:../drivers/fsl_spi.h **** 
 549:../drivers/fsl_spi.h **** /*!
 550:../drivers/fsl_spi.h ****  * @brief Writes a data into the SPI data register.
 551:../drivers/fsl_spi.h ****  *
 552:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 553:../drivers/fsl_spi.h ****  * @param data needs to be write.
 554:../drivers/fsl_spi.h ****  */
 555:../drivers/fsl_spi.h **** void SPI_WriteData(SPI_Type *base, uint16_t data);
 556:../drivers/fsl_spi.h **** 
 557:../drivers/fsl_spi.h **** /*!
 558:../drivers/fsl_spi.h ****  * @brief Gets a data from the SPI data register.
 559:../drivers/fsl_spi.h ****  *
 560:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 561:../drivers/fsl_spi.h ****  * @return Data in the register.
 562:../drivers/fsl_spi.h ****  */
 563:../drivers/fsl_spi.h **** uint16_t SPI_ReadData(SPI_Type *base);
 564:../drivers/fsl_spi.h **** 
 565:../drivers/fsl_spi.h **** /*!
 566:../drivers/fsl_spi.h ****  * @brief Set up the dummy data.
 567:../drivers/fsl_spi.h ****  *
 568:../drivers/fsl_spi.h ****  * @param base SPI peripheral address.
 569:../drivers/fsl_spi.h ****  * @param dummyData Data to be transferred when tx buffer is NULL.
 570:../drivers/fsl_spi.h ****  */
 571:../drivers/fsl_spi.h **** void SPI_SetDummyData(SPI_Type *base, uint8_t dummyData);
 572:../drivers/fsl_spi.h **** /*! @} */
 573:../drivers/fsl_spi.h **** 
 574:../drivers/fsl_spi.h **** /*!
 575:../drivers/fsl_spi.h ****  * @name Transactional
 576:../drivers/fsl_spi.h ****  * @{
 577:../drivers/fsl_spi.h ****  */
 578:../drivers/fsl_spi.h **** 
 579:../drivers/fsl_spi.h **** /*!
 580:../drivers/fsl_spi.h ****  * @brief Initializes the SPI master handle.
 581:../drivers/fsl_spi.h ****  *
 582:../drivers/fsl_spi.h ****  * This function initializes the SPI master handle which can be used for other SPI master transacti
 583:../drivers/fsl_spi.h ****  * for a specified SPI instance, call this API once to get the initialized handle.
 584:../drivers/fsl_spi.h ****  *
 585:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 586:../drivers/fsl_spi.h ****  * @param handle SPI handle pointer.
 587:../drivers/fsl_spi.h ****  * @param callback Callback function.
 588:../drivers/fsl_spi.h ****  * @param userData User data.
 589:../drivers/fsl_spi.h ****  */
 590:../drivers/fsl_spi.h **** void SPI_MasterTransferCreateHandle(SPI_Type *base,
 591:../drivers/fsl_spi.h ****                                     spi_master_handle_t *handle,
 592:../drivers/fsl_spi.h ****                                     spi_master_callback_t callback,
 593:../drivers/fsl_spi.h ****                                     void *userData);
 594:../drivers/fsl_spi.h **** 
 595:../drivers/fsl_spi.h **** /*!
 596:../drivers/fsl_spi.h ****  * @brief Transfers a block of data using a polling method.
 597:../drivers/fsl_spi.h ****  *
 598:../drivers/fsl_spi.h ****  * @param base SPI base pointer
 599:../drivers/fsl_spi.h ****  * @param xfer pointer to spi_xfer_config_t structure
 600:../drivers/fsl_spi.h ****  * @retval kStatus_Success Successfully start a transfer.
 601:../drivers/fsl_spi.h ****  * @retval kStatus_InvalidArgument Input argument is invalid.
 602:../drivers/fsl_spi.h ****  */
 603:../drivers/fsl_spi.h **** status_t SPI_MasterTransferBlocking(SPI_Type *base, spi_transfer_t *xfer);
 604:../drivers/fsl_spi.h **** 
 605:../drivers/fsl_spi.h **** /*!
 606:../drivers/fsl_spi.h ****  * @brief Performs a non-blocking SPI interrupt transfer.
 607:../drivers/fsl_spi.h ****  *
 608:../drivers/fsl_spi.h ****  * @note The API immediately returns after transfer initialization is finished.
 609:../drivers/fsl_spi.h ****  * Call SPI_GetStatusIRQ() to get the transfer status.
 610:../drivers/fsl_spi.h ****  * @note If SPI transfer data frame size is 16 bits, the transfer size cannot be an odd number.
 611:../drivers/fsl_spi.h ****  *
 612:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 613:../drivers/fsl_spi.h ****  * @param handle pointer to spi_master_handle_t structure which stores the transfer state
 614:../drivers/fsl_spi.h ****  * @param xfer pointer to spi_xfer_config_t structure
 615:../drivers/fsl_spi.h ****  * @retval kStatus_Success Successfully start a transfer.
 616:../drivers/fsl_spi.h ****  * @retval kStatus_InvalidArgument Input argument is invalid.
 617:../drivers/fsl_spi.h ****  * @retval kStatus_SPI_Busy SPI is not idle, is running another transfer.
 618:../drivers/fsl_spi.h ****  */
 619:../drivers/fsl_spi.h **** status_t SPI_MasterTransferNonBlocking(SPI_Type *base, spi_master_handle_t *handle, spi_transfer_t 
 620:../drivers/fsl_spi.h **** 
 621:../drivers/fsl_spi.h **** /*!
 622:../drivers/fsl_spi.h ****  * @brief Gets the bytes of the SPI interrupt transferred.
 623:../drivers/fsl_spi.h ****  *
 624:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 625:../drivers/fsl_spi.h ****  * @param handle Pointer to SPI transfer handle, this should be a static variable.
 626:../drivers/fsl_spi.h ****  * @param count Transferred bytes of SPI master.
 627:../drivers/fsl_spi.h ****  * @retval kStatus_SPI_Success Succeed get the transfer count.
 628:../drivers/fsl_spi.h ****  * @retval kStatus_NoTransferInProgress There is not a non-blocking transaction currently in progre
 629:../drivers/fsl_spi.h ****  */
 630:../drivers/fsl_spi.h **** status_t SPI_MasterTransferGetCount(SPI_Type *base, spi_master_handle_t *handle, size_t *count);
 631:../drivers/fsl_spi.h **** 
 632:../drivers/fsl_spi.h **** /*!
 633:../drivers/fsl_spi.h ****  * @brief Aborts an SPI transfer using interrupt.
 634:../drivers/fsl_spi.h ****  *
 635:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 636:../drivers/fsl_spi.h ****  * @param handle Pointer to SPI transfer handle, this should be a static variable.
 637:../drivers/fsl_spi.h ****  */
 638:../drivers/fsl_spi.h **** void SPI_MasterTransferAbort(SPI_Type *base, spi_master_handle_t *handle);
 639:../drivers/fsl_spi.h **** 
 640:../drivers/fsl_spi.h **** /*!
 641:../drivers/fsl_spi.h ****  * @brief Interrupts the handler for the SPI.
 642:../drivers/fsl_spi.h ****  *
 643:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 644:../drivers/fsl_spi.h ****  * @param handle pointer to spi_master_handle_t structure which stores the transfer state.
 645:../drivers/fsl_spi.h ****  */
 646:../drivers/fsl_spi.h **** void SPI_MasterTransferHandleIRQ(SPI_Type *base, spi_master_handle_t *handle);
 647:../drivers/fsl_spi.h **** 
 648:../drivers/fsl_spi.h **** /*!
 649:../drivers/fsl_spi.h ****  * @brief Initializes the SPI slave handle.
 650:../drivers/fsl_spi.h ****  *
 651:../drivers/fsl_spi.h ****  * This function initializes the SPI slave handle which can be used for other SPI slave transaction
 652:../drivers/fsl_spi.h ****  * for a specified SPI instance, call this API once to get the initialized handle.
 653:../drivers/fsl_spi.h ****  *
 654:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 655:../drivers/fsl_spi.h ****  * @param handle SPI handle pointer.
 656:../drivers/fsl_spi.h ****  * @param callback Callback function.
 657:../drivers/fsl_spi.h ****  * @param userData User data.
 658:../drivers/fsl_spi.h ****  */
 659:../drivers/fsl_spi.h **** void SPI_SlaveTransferCreateHandle(SPI_Type *base,
 660:../drivers/fsl_spi.h ****                                    spi_slave_handle_t *handle,
 661:../drivers/fsl_spi.h ****                                    spi_slave_callback_t callback,
 662:../drivers/fsl_spi.h ****                                    void *userData);
 663:../drivers/fsl_spi.h **** 
 664:../drivers/fsl_spi.h **** /*!
 665:../drivers/fsl_spi.h ****  * @brief Performs a non-blocking SPI slave interrupt transfer.
 666:../drivers/fsl_spi.h ****  *
 667:../drivers/fsl_spi.h ****  * @note The API returns immediately after the transfer initialization is finished.
 668:../drivers/fsl_spi.h ****  * Call SPI_GetStatusIRQ() to get the transfer status.
 669:../drivers/fsl_spi.h ****  * @note If SPI transfer data frame size is 16 bits, the transfer size cannot be an odd number.
 670:../drivers/fsl_spi.h ****  *
 671:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 672:../drivers/fsl_spi.h ****  * @param handle pointer to spi_master_handle_t structure which stores the transfer state
 673:../drivers/fsl_spi.h ****  * @param xfer pointer to spi_xfer_config_t structure
 674:../drivers/fsl_spi.h ****  * @retval kStatus_Success Successfully start a transfer.
 675:../drivers/fsl_spi.h ****  * @retval kStatus_InvalidArgument Input argument is invalid.
 676:../drivers/fsl_spi.h ****  * @retval kStatus_SPI_Busy SPI is not idle, is running another transfer.
 677:../drivers/fsl_spi.h ****  */
 678:../drivers/fsl_spi.h **** static inline status_t SPI_SlaveTransferNonBlocking(SPI_Type *base, spi_slave_handle_t *handle, spi
 679:../drivers/fsl_spi.h **** {
 680:../drivers/fsl_spi.h ****     return SPI_MasterTransferNonBlocking(base, handle, xfer);
 681:../drivers/fsl_spi.h **** }
 682:../drivers/fsl_spi.h **** 
 683:../drivers/fsl_spi.h **** /*!
 684:../drivers/fsl_spi.h ****  * @brief Gets the bytes of the SPI interrupt transferred.
 685:../drivers/fsl_spi.h ****  *
 686:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 687:../drivers/fsl_spi.h ****  * @param handle Pointer to SPI transfer handle, this should be a static variable.
 688:../drivers/fsl_spi.h ****  * @param count Transferred bytes of SPI slave.
 689:../drivers/fsl_spi.h ****  * @retval kStatus_SPI_Success Succeed get the transfer count.
 690:../drivers/fsl_spi.h ****  * @retval kStatus_NoTransferInProgress There is not a non-blocking transaction currently in progre
 691:../drivers/fsl_spi.h ****  */
 692:../drivers/fsl_spi.h **** static inline status_t SPI_SlaveTransferGetCount(SPI_Type *base, spi_slave_handle_t *handle, size_t
 693:../drivers/fsl_spi.h **** {
 694:../drivers/fsl_spi.h ****     return SPI_MasterTransferGetCount(base, handle, count);
 695:../drivers/fsl_spi.h **** }
 696:../drivers/fsl_spi.h **** 
 697:../drivers/fsl_spi.h **** /*!
 698:../drivers/fsl_spi.h ****  * @brief Aborts an SPI slave transfer using interrupt.
 699:../drivers/fsl_spi.h ****  *
 700:../drivers/fsl_spi.h ****  * @param base SPI peripheral base address.
 701:../drivers/fsl_spi.h ****  * @param handle Pointer to SPI transfer handle, this should be a static variable.
 702:../drivers/fsl_spi.h ****  */
 703:../drivers/fsl_spi.h **** static inline void SPI_SlaveTransferAbort(SPI_Type *base, spi_slave_handle_t *handle)
 704:../drivers/fsl_spi.h **** {
 705:../drivers/fsl_spi.h ****     SPI_MasterTransferAbort(base, handle);
 2435              		.loc 5 705 0
 2436 0030 2100     		movs	r1, r4
 2437 0032 2800     		movs	r0, r5
 2438 0034 FFF7FEFF 		bl	SPI_MasterTransferAbort
 2439              	.LVL249:
 2440              	.LBE28:
 2441              	.LBE27:
1032:../drivers/fsl_spi.c ****         {
 2442              		.loc 1 1032 0
 2443 0038 E669     		ldr	r6, [r4, #28]
 2444 003a 002E     		cmp	r6, #0
 2445 003c EFD0     		beq	.L175
1034:../drivers/fsl_spi.c ****         }
 2446              		.loc 1 1034 0
 2447 003e 236A     		ldr	r3, [r4, #32]
 2448 0040 024A     		ldr	r2, .L182
 2449 0042 2100     		movs	r1, r4
 2450 0044 2800     		movs	r0, r5
 2451 0046 B047     		blx	r6
 2452              	.LVL250:
1037:../drivers/fsl_spi.c **** 
 2453              		.loc 1 1037 0
 2454 0048 E9E7     		b	.L175
 2455              	.L183:
 2456 004a C046     		.align	2
 2457              	.L182:
 2458 004c 79050000 		.word	1401
 2459              		.cfi_endproc
 2460              	.LFE90:
 2462              		.section	.text.SPI_SlaveTransferCreateHandle,"ax",%progbits
 2463              		.align	1
 2464              		.global	SPI_SlaveTransferCreateHandle
 2465              		.syntax unified
 2466              		.code	16
 2467              		.thumb_func
 2468              		.fpu softvfp
 2470              	SPI_SlaveTransferCreateHandle:
 2471              	.LFB89:
1001:../drivers/fsl_spi.c ****     assert(handle);
 2472              		.loc 1 1001 0
 2473              		.cfi_startproc
 2474              		@ args = 0, pretend = 0, frame = 0
 2475              		@ frame_needed = 0, uses_anonymous_args = 0
 2476              	.LVL251:
 2477 0000 10B5     		push	{r4, lr}
 2478              		.cfi_def_cfa_offset 8
 2479              		.cfi_offset 4, -8
 2480              		.cfi_offset 14, -4
1006:../drivers/fsl_spi.c ****     s_spiSlaveIsr = SPI_SlaveTransferHandleIRQ;
 2481              		.loc 1 1006 0
 2482 0002 FFF7FEFF 		bl	SPI_MasterTransferCreateHandle
 2483              	.LVL252:
1007:../drivers/fsl_spi.c **** }
 2484              		.loc 1 1007 0
 2485 0006 024B     		ldr	r3, .L185
 2486 0008 024A     		ldr	r2, .L185+4
 2487 000a 1A60     		str	r2, [r3]
1008:../drivers/fsl_spi.c **** 
 2488              		.loc 1 1008 0
 2489              		@ sp needed
 2490 000c 10BD     		pop	{r4, pc}
 2491              	.L186:
 2492 000e C046     		.align	2
 2493              	.L185:
 2494 0010 00000000 		.word	.LANCHOR2
 2495 0014 00000000 		.word	SPI_SlaveTransferHandleIRQ
 2496              		.cfi_endproc
 2497              	.LFE89:
 2499              		.section	.text.SPI0_DriverIRQHandler,"ax",%progbits
 2500              		.align	1
 2501              		.global	SPI0_DriverIRQHandler
 2502              		.syntax unified
 2503              		.code	16
 2504              		.thumb_func
 2505              		.fpu softvfp
 2507              	SPI0_DriverIRQHandler:
 2508              	.LFB92:
1055:../drivers/fsl_spi.c **** 
1056:../drivers/fsl_spi.c **** #if defined(SPI0)
1057:../drivers/fsl_spi.c **** void SPI0_DriverIRQHandler(void)
1058:../drivers/fsl_spi.c **** {
 2509              		.loc 1 1058 0
 2510              		.cfi_startproc
 2511              		@ args = 0, pretend = 0, frame = 0
 2512              		@ frame_needed = 0, uses_anonymous_args = 0
 2513 0000 10B5     		push	{r4, lr}
 2514              		.cfi_def_cfa_offset 8
 2515              		.cfi_offset 4, -8
 2516              		.cfi_offset 14, -4
1059:../drivers/fsl_spi.c ****     assert(s_spiHandle[0]);
1060:../drivers/fsl_spi.c ****     SPI_CommonIRQHandler(SPI0, 0);
 2517              		.loc 1 1060 0
 2518 0002 0021     		movs	r1, #0
 2519 0004 0148     		ldr	r0, .L188
 2520 0006 FFF7FEFF 		bl	SPI_CommonIRQHandler
 2521              	.LVL253:
1061:../drivers/fsl_spi.c **** }
 2522              		.loc 1 1061 0
 2523              		@ sp needed
 2524 000a 10BD     		pop	{r4, pc}
 2525              	.L189:
 2526              		.align	2
 2527              	.L188:
 2528 000c 00600740 		.word	1074225152
 2529              		.cfi_endproc
 2530              	.LFE92:
 2532              		.section	.text.SPI1_DriverIRQHandler,"ax",%progbits
 2533              		.align	1
 2534              		.global	SPI1_DriverIRQHandler
 2535              		.syntax unified
 2536              		.code	16
 2537              		.thumb_func
 2538              		.fpu softvfp
 2540              	SPI1_DriverIRQHandler:
 2541              	.LFB93:
1062:../drivers/fsl_spi.c **** #endif
1063:../drivers/fsl_spi.c **** 
1064:../drivers/fsl_spi.c **** #if defined(SPI1)
1065:../drivers/fsl_spi.c **** void SPI1_DriverIRQHandler(void)
1066:../drivers/fsl_spi.c **** {
 2542              		.loc 1 1066 0
 2543              		.cfi_startproc
 2544              		@ args = 0, pretend = 0, frame = 0
 2545              		@ frame_needed = 0, uses_anonymous_args = 0
 2546 0000 10B5     		push	{r4, lr}
 2547              		.cfi_def_cfa_offset 8
 2548              		.cfi_offset 4, -8
 2549              		.cfi_offset 14, -4
1067:../drivers/fsl_spi.c ****     assert(s_spiHandle[1]);
1068:../drivers/fsl_spi.c ****     SPI_CommonIRQHandler(SPI1, 1);
 2550              		.loc 1 1068 0
 2551 0002 0121     		movs	r1, #1
 2552 0004 0148     		ldr	r0, .L191
 2553 0006 FFF7FEFF 		bl	SPI_CommonIRQHandler
 2554              	.LVL254:
1069:../drivers/fsl_spi.c **** }
 2555              		.loc 1 1069 0
 2556              		@ sp needed
 2557 000a 10BD     		pop	{r4, pc}
 2558              	.L192:
 2559              		.align	2
 2560              	.L191:
 2561 000c 00700740 		.word	1074229248
 2562              		.cfi_endproc
 2563              	.LFE93:
 2565              		.global	s_dummyData
 2566              		.section	.bss.s_dummyData,"aw",%nobits
 2567              		.align	2
 2568              		.set	.LANCHOR4,. + 0
 2571              	s_dummyData:
 2572 0000 0000     		.space	2
 2573              		.section	.bss.s_spiHandle,"aw",%nobits
 2574              		.align	2
 2575              		.set	.LANCHOR0,. + 0
 2578              	s_spiHandle:
 2579 0000 00000000 		.space	8
 2579      00000000 
 2580              		.section	.bss.s_spiMasterIsr,"aw",%nobits
 2581              		.align	2
 2582              		.set	.LANCHOR1,. + 0
 2585              	s_spiMasterIsr:
 2586 0000 00000000 		.space	4
 2587              		.section	.bss.s_spiSlaveIsr,"aw",%nobits
 2588              		.align	2
 2589              		.set	.LANCHOR2,. + 0
 2592              	s_spiSlaveIsr:
 2593 0000 00000000 		.space	4
 2594              		.section	.rodata.s_spiBases,"a",%progbits
 2595              		.align	2
 2596              		.set	.LANCHOR3,. + 0
 2599              	s_spiBases:
 2600 0000 00600740 		.word	1074225152
 2601 0004 00700740 		.word	1074229248
 2602              		.section	.rodata.s_spiClock,"a",%progbits
 2603              		.align	2
 2604              		.set	.LANCHOR5,. + 0
 2607              	s_spiClock:
 2608 0000 16003410 		.word	271843350
 2609 0004 17003410 		.word	271843351
 2610              		.section	.rodata.s_spiIRQ,"a",%progbits
 2611              		.align	2
 2612              		.set	.LANCHOR6,. + 0
 2615              	s_spiIRQ:
 2616 0000 0A       		.byte	10
 2617 0001 0B       		.byte	11
 2618              		.text
 2619              	.Letext0:
 2620              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 2621              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2622              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 2623              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 2624              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 2625              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 2626              		.file 12 "../CMSIS/MKL17Z4.h"
 2627              		.file 13 "../CMSIS/system_MKL17Z4.h"
 2628              		.file 14 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_spi.c
     /tmp/ccsifHaE.s:16     .text.SPI_GetWatermark:0000000000000000 $t
     /tmp/ccsifHaE.s:22     .text.SPI_GetWatermark:0000000000000000 SPI_GetWatermark
     /tmp/ccsifHaE.s:82     .text.SPI_GetWatermark:000000000000002c $d
     /tmp/ccsifHaE.s:88     .text.SPI_CommonIRQHandler:0000000000000000 $t
     /tmp/ccsifHaE.s:94     .text.SPI_CommonIRQHandler:0000000000000000 SPI_CommonIRQHandler
     /tmp/ccsifHaE.s:137    .text.SPI_CommonIRQHandler:0000000000000024 $d
     /tmp/ccsifHaE.s:144    .text.SPI_GetInstance:0000000000000000 $t
     /tmp/ccsifHaE.s:151    .text.SPI_GetInstance:0000000000000000 SPI_GetInstance
     /tmp/ccsifHaE.s:185    .text.SPI_GetInstance:0000000000000018 $d
     /tmp/ccsifHaE.s:190    .text.SPI_SetDummyData:0000000000000000 $t
     /tmp/ccsifHaE.s:197    .text.SPI_SetDummyData:0000000000000000 SPI_SetDummyData
     /tmp/ccsifHaE.s:221    .text.SPI_SetDummyData:0000000000000010 $d
     /tmp/ccsifHaE.s:226    .text.SPI_MasterGetDefaultConfig:0000000000000000 $t
     /tmp/ccsifHaE.s:233    .text.SPI_MasterGetDefaultConfig:0000000000000000 SPI_MasterGetDefaultConfig
     /tmp/ccsifHaE.s:273    .text.SPI_MasterGetDefaultConfig:0000000000000020 $d
     /tmp/ccsifHaE.s:278    .text.SPI_SlaveGetDefaultConfig:0000000000000000 $t
     /tmp/ccsifHaE.s:285    .text.SPI_SlaveGetDefaultConfig:0000000000000000 SPI_SlaveGetDefaultConfig
     /tmp/ccsifHaE.s:320    .text.SPI_SlaveInit:0000000000000000 $t
     /tmp/ccsifHaE.s:327    .text.SPI_SlaveInit:0000000000000000 SPI_SlaveInit
     /tmp/ccsifHaE.s:458    .text.SPI_SlaveInit:00000000000000a4 $d
     /tmp/ccsifHaE.s:465    .text.SPI_Deinit:0000000000000000 $t
     /tmp/ccsifHaE.s:472    .text.SPI_Deinit:0000000000000000 SPI_Deinit
     /tmp/ccsifHaE.s:522    .text.SPI_Deinit:000000000000002c $d
     /tmp/ccsifHaE.s:528    .text.SPI_GetStatusFlags:0000000000000000 $t
     /tmp/ccsifHaE.s:535    .text.SPI_GetStatusFlags:0000000000000000 SPI_GetStatusFlags
     /tmp/ccsifHaE.s:567    .text.SPI_GetStatusFlags:0000000000000018 $d
     /tmp/ccsifHaE.s:572    .text.SPI_EnableInterrupts:0000000000000000 $t
     /tmp/ccsifHaE.s:579    .text.SPI_EnableInterrupts:0000000000000000 SPI_EnableInterrupts
     /tmp/ccsifHaE.s:646    .text.SPI_EnableInterrupts:000000000000004c $d
     /tmp/ccsifHaE.s:651    .text.SPI_DisableInterrupts:0000000000000000 $t
     /tmp/ccsifHaE.s:658    .text.SPI_DisableInterrupts:0000000000000000 SPI_DisableInterrupts
     /tmp/ccsifHaE.s:721    .text.SPI_DisableInterrupts:0000000000000044 $d
     /tmp/ccsifHaE.s:727    .text.SPI_MasterSetBaudRate:0000000000000000 $t
     /tmp/ccsifHaE.s:734    .text.SPI_MasterSetBaudRate:0000000000000000 SPI_MasterSetBaudRate
     /tmp/ccsifHaE.s:859    .text.SPI_MasterInit:0000000000000000 $t
     /tmp/ccsifHaE.s:866    .text.SPI_MasterInit:0000000000000000 SPI_MasterInit
     /tmp/ccsifHaE.s:1024   .text.SPI_MasterInit:00000000000000cc $d
     /tmp/ccsifHaE.s:1031   .text.SPI_EnableFIFO:0000000000000000 $t
     /tmp/ccsifHaE.s:1038   .text.SPI_EnableFIFO:0000000000000000 SPI_EnableFIFO
     /tmp/ccsifHaE.s:1072   .text.SPI_EnableFIFO:0000000000000020 $d
     /tmp/ccsifHaE.s:1077   .text.SPI_WriteData:0000000000000000 $t
     /tmp/ccsifHaE.s:1084   .text.SPI_WriteData:0000000000000000 SPI_WriteData
     /tmp/ccsifHaE.s:1106   .text.SPI_WriteNonBlocking:0000000000000000 $t
     /tmp/ccsifHaE.s:1112   .text.SPI_WriteNonBlocking:0000000000000000 SPI_WriteNonBlocking
     /tmp/ccsifHaE.s:1214   .text.SPI_WriteNonBlocking:0000000000000060 $d
     /tmp/ccsifHaE.s:1219   .text.SPI_WriteBlocking:0000000000000000 $t
     /tmp/ccsifHaE.s:1226   .text.SPI_WriteBlocking:0000000000000000 SPI_WriteBlocking
     /tmp/ccsifHaE.s:1295   .text.SPI_SendInitialTransfer:0000000000000000 $t
     /tmp/ccsifHaE.s:1301   .text.SPI_SendInitialTransfer:0000000000000000 SPI_SendInitialTransfer
     /tmp/ccsifHaE.s:1403   .text.SPI_SendInitialTransfer:0000000000000064 $d
     /tmp/ccsifHaE.s:1409   .text.SPI_SendTransfer:0000000000000000 $t
     /tmp/ccsifHaE.s:1415   .text.SPI_SendTransfer:0000000000000000 SPI_SendTransfer
     /tmp/ccsifHaE.s:1550   .text.SPI_ReadData:0000000000000000 $t
     /tmp/ccsifHaE.s:1557   .text.SPI_ReadData:0000000000000000 SPI_ReadData
     /tmp/ccsifHaE.s:1581   .text.SPI_ReadNonBlocking:0000000000000000 $t
     /tmp/ccsifHaE.s:1587   .text.SPI_ReadNonBlocking:0000000000000000 SPI_ReadNonBlocking
     /tmp/ccsifHaE.s:1674   .text.SPI_ReceiveTransfer:0000000000000000 $t
     /tmp/ccsifHaE.s:1680   .text.SPI_ReceiveTransfer:0000000000000000 SPI_ReceiveTransfer
     /tmp/ccsifHaE.s:1773   .text.SPI_MasterTransferBlocking:0000000000000000 $t
     /tmp/ccsifHaE.s:1780   .text.SPI_MasterTransferBlocking:0000000000000000 SPI_MasterTransferBlocking
     /tmp/ccsifHaE.s:1890   .text.SPI_MasterTransferBlocking:0000000000000078 $d
     /tmp/ccsifHaE.s:1895   .text.SPI_MasterTransferCreateHandle:0000000000000000 $t
     /tmp/ccsifHaE.s:1902   .text.SPI_MasterTransferCreateHandle:0000000000000000 SPI_MasterTransferCreateHandle
     /tmp/ccsifHaE.s:2008   .text.SPI_MasterTransferCreateHandle:000000000000006c $d
     /tmp/ccsifHaE.s:2290   .text.SPI_MasterTransferHandleIRQ:0000000000000000 SPI_MasterTransferHandleIRQ
     /tmp/ccsifHaE.s:2017   .text.SPI_MasterTransferNonBlocking:0000000000000000 $t
     /tmp/ccsifHaE.s:2024   .text.SPI_MasterTransferNonBlocking:0000000000000000 SPI_MasterTransferNonBlocking
     /tmp/ccsifHaE.s:2172   .text.SPI_MasterTransferGetCount:0000000000000000 $t
     /tmp/ccsifHaE.s:2179   .text.SPI_MasterTransferGetCount:0000000000000000 SPI_MasterTransferGetCount
     /tmp/ccsifHaE.s:2231   .text.SPI_MasterTransferAbort:0000000000000000 $t
     /tmp/ccsifHaE.s:2238   .text.SPI_MasterTransferAbort:0000000000000000 SPI_MasterTransferAbort
     /tmp/ccsifHaE.s:2283   .text.SPI_MasterTransferHandleIRQ:0000000000000000 $t
     /tmp/ccsifHaE.s:2365   .text.SPI_MasterTransferHandleIRQ:000000000000004c $d
     /tmp/ccsifHaE.s:2370   .text.SPI_SlaveTransferHandleIRQ:0000000000000000 $t
     /tmp/ccsifHaE.s:2377   .text.SPI_SlaveTransferHandleIRQ:0000000000000000 SPI_SlaveTransferHandleIRQ
     /tmp/ccsifHaE.s:2458   .text.SPI_SlaveTransferHandleIRQ:000000000000004c $d
     /tmp/ccsifHaE.s:2463   .text.SPI_SlaveTransferCreateHandle:0000000000000000 $t
     /tmp/ccsifHaE.s:2470   .text.SPI_SlaveTransferCreateHandle:0000000000000000 SPI_SlaveTransferCreateHandle
     /tmp/ccsifHaE.s:2494   .text.SPI_SlaveTransferCreateHandle:0000000000000010 $d
     /tmp/ccsifHaE.s:2500   .text.SPI0_DriverIRQHandler:0000000000000000 $t
     /tmp/ccsifHaE.s:2507   .text.SPI0_DriverIRQHandler:0000000000000000 SPI0_DriverIRQHandler
     /tmp/ccsifHaE.s:2528   .text.SPI0_DriverIRQHandler:000000000000000c $d
     /tmp/ccsifHaE.s:2533   .text.SPI1_DriverIRQHandler:0000000000000000 $t
     /tmp/ccsifHaE.s:2540   .text.SPI1_DriverIRQHandler:0000000000000000 SPI1_DriverIRQHandler
     /tmp/ccsifHaE.s:2561   .text.SPI1_DriverIRQHandler:000000000000000c $d
     /tmp/ccsifHaE.s:2571   .bss.s_dummyData:0000000000000000 s_dummyData
     /tmp/ccsifHaE.s:2567   .bss.s_dummyData:0000000000000000 $d
     /tmp/ccsifHaE.s:2574   .bss.s_spiHandle:0000000000000000 $d
     /tmp/ccsifHaE.s:2578   .bss.s_spiHandle:0000000000000000 s_spiHandle
     /tmp/ccsifHaE.s:2581   .bss.s_spiMasterIsr:0000000000000000 $d
     /tmp/ccsifHaE.s:2585   .bss.s_spiMasterIsr:0000000000000000 s_spiMasterIsr
     /tmp/ccsifHaE.s:2588   .bss.s_spiSlaveIsr:0000000000000000 $d
     /tmp/ccsifHaE.s:2592   .bss.s_spiSlaveIsr:0000000000000000 s_spiSlaveIsr
     /tmp/ccsifHaE.s:2595   .rodata.s_spiBases:0000000000000000 $d
     /tmp/ccsifHaE.s:2599   .rodata.s_spiBases:0000000000000000 s_spiBases
     /tmp/ccsifHaE.s:2603   .rodata.s_spiClock:0000000000000000 $d
     /tmp/ccsifHaE.s:2607   .rodata.s_spiClock:0000000000000000 s_spiClock
     /tmp/ccsifHaE.s:2611   .rodata.s_spiIRQ:0000000000000000 $d
     /tmp/ccsifHaE.s:2615   .rodata.s_spiIRQ:0000000000000000 s_spiIRQ

UNDEFINED SYMBOLS
__aeabi_uidiv
memset
