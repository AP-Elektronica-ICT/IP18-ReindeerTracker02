   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_uart_dma.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.UART_TransferSendDMACallback,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	UART_TransferSendDMACallback:
  23              	.LFB76:
  24              		.file 1 "../drivers/fsl_uart_dma.c"
   1:../drivers/fsl_uart_dma.c **** /*
   2:../drivers/fsl_uart_dma.c ****  * The Clear BSD License
   3:../drivers/fsl_uart_dma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_uart_dma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_uart_dma.c ****  * All rights reserved.
   6:../drivers/fsl_uart_dma.c ****  *
   7:../drivers/fsl_uart_dma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_uart_dma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_uart_dma.c ****  * that the following conditions are met:
  10:../drivers/fsl_uart_dma.c ****  *
  11:../drivers/fsl_uart_dma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_uart_dma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_uart_dma.c ****  *
  14:../drivers/fsl_uart_dma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_uart_dma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_uart_dma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_uart_dma.c ****  *
  18:../drivers/fsl_uart_dma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_uart_dma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_uart_dma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_uart_dma.c ****  *
  22:../drivers/fsl_uart_dma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_uart_dma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_uart_dma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_uart_dma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_uart_dma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_uart_dma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_uart_dma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_uart_dma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_uart_dma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_uart_dma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_uart_dma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_uart_dma.c ****  */
  34:../drivers/fsl_uart_dma.c **** 
  35:../drivers/fsl_uart_dma.c **** #include "fsl_uart_dma.h"
  36:../drivers/fsl_uart_dma.c **** 
  37:../drivers/fsl_uart_dma.c **** /*******************************************************************************
  38:../drivers/fsl_uart_dma.c ****  * Definitions
  39:../drivers/fsl_uart_dma.c ****  ******************************************************************************/
  40:../drivers/fsl_uart_dma.c **** 
  41:../drivers/fsl_uart_dma.c **** /* Array of UART handle. */
  42:../drivers/fsl_uart_dma.c **** #if (defined(UART5))
  43:../drivers/fsl_uart_dma.c **** #define UART_HANDLE_ARRAY_SIZE 6
  44:../drivers/fsl_uart_dma.c **** #else /* UART5 */
  45:../drivers/fsl_uart_dma.c **** #if (defined(UART4))
  46:../drivers/fsl_uart_dma.c **** #define UART_HANDLE_ARRAY_SIZE 5
  47:../drivers/fsl_uart_dma.c **** #else /* UART4 */
  48:../drivers/fsl_uart_dma.c **** #if (defined(UART3))
  49:../drivers/fsl_uart_dma.c **** #define UART_HANDLE_ARRAY_SIZE 4
  50:../drivers/fsl_uart_dma.c **** #else /* UART3 */
  51:../drivers/fsl_uart_dma.c **** #if (defined(UART2))
  52:../drivers/fsl_uart_dma.c **** #define UART_HANDLE_ARRAY_SIZE 3
  53:../drivers/fsl_uart_dma.c **** #else /* UART2 */
  54:../drivers/fsl_uart_dma.c **** #if (defined(UART1))
  55:../drivers/fsl_uart_dma.c **** #define UART_HANDLE_ARRAY_SIZE 2
  56:../drivers/fsl_uart_dma.c **** #else /* UART1 */
  57:../drivers/fsl_uart_dma.c **** #if (defined(UART0))
  58:../drivers/fsl_uart_dma.c **** #define UART_HANDLE_ARRAY_SIZE 1
  59:../drivers/fsl_uart_dma.c **** #else /* UART0 */
  60:../drivers/fsl_uart_dma.c **** #error No UART instance.
  61:../drivers/fsl_uart_dma.c **** #endif /* UART 0 */
  62:../drivers/fsl_uart_dma.c **** #endif /* UART 1 */
  63:../drivers/fsl_uart_dma.c **** #endif /* UART 2 */
  64:../drivers/fsl_uart_dma.c **** #endif /* UART 3 */
  65:../drivers/fsl_uart_dma.c **** #endif /* UART 4 */
  66:../drivers/fsl_uart_dma.c **** #endif /* UART 5 */
  67:../drivers/fsl_uart_dma.c **** 
  68:../drivers/fsl_uart_dma.c **** /*<! Structure definition for uart_dma_handle_t. The structure is private. */
  69:../drivers/fsl_uart_dma.c **** typedef struct _uart_dma_private_handle
  70:../drivers/fsl_uart_dma.c **** {
  71:../drivers/fsl_uart_dma.c ****     UART_Type *base;
  72:../drivers/fsl_uart_dma.c ****     uart_dma_handle_t *handle;
  73:../drivers/fsl_uart_dma.c **** } uart_dma_private_handle_t;
  74:../drivers/fsl_uart_dma.c **** 
  75:../drivers/fsl_uart_dma.c **** /* UART DMA transfer handle. */
  76:../drivers/fsl_uart_dma.c **** enum _uart_dma_tansfer_states
  77:../drivers/fsl_uart_dma.c **** {
  78:../drivers/fsl_uart_dma.c ****     kUART_TxIdle, /* TX idle. */
  79:../drivers/fsl_uart_dma.c ****     kUART_TxBusy, /* TX busy. */
  80:../drivers/fsl_uart_dma.c ****     kUART_RxIdle, /* RX idle. */
  81:../drivers/fsl_uart_dma.c ****     kUART_RxBusy  /* RX busy. */
  82:../drivers/fsl_uart_dma.c **** };
  83:../drivers/fsl_uart_dma.c **** 
  84:../drivers/fsl_uart_dma.c **** /*******************************************************************************
  85:../drivers/fsl_uart_dma.c ****  * Variables
  86:../drivers/fsl_uart_dma.c ****  ******************************************************************************/
  87:../drivers/fsl_uart_dma.c **** 
  88:../drivers/fsl_uart_dma.c **** /*<! Private handle only used for internally. */
  89:../drivers/fsl_uart_dma.c **** static uart_dma_private_handle_t s_dmaPrivateHandle[UART_HANDLE_ARRAY_SIZE];
  90:../drivers/fsl_uart_dma.c **** 
  91:../drivers/fsl_uart_dma.c **** /*******************************************************************************
  92:../drivers/fsl_uart_dma.c ****  * Prototypes
  93:../drivers/fsl_uart_dma.c ****  ******************************************************************************/
  94:../drivers/fsl_uart_dma.c **** 
  95:../drivers/fsl_uart_dma.c **** /*!
  96:../drivers/fsl_uart_dma.c ****  * @brief UART DMA send finished callback function.
  97:../drivers/fsl_uart_dma.c ****  *
  98:../drivers/fsl_uart_dma.c ****  * This function is called when UART DMA send finished. It disables the UART
  99:../drivers/fsl_uart_dma.c ****  * TX DMA request and sends @ref kStatus_UART_TxIdle to UART callback.
 100:../drivers/fsl_uart_dma.c ****  *
 101:../drivers/fsl_uart_dma.c ****  * @param handle The DMA handle.
 102:../drivers/fsl_uart_dma.c ****  * @param param Callback function parameter.
 103:../drivers/fsl_uart_dma.c ****  */
 104:../drivers/fsl_uart_dma.c **** static void UART_TransferSendDMACallback(dma_handle_t *handle, void *param);
 105:../drivers/fsl_uart_dma.c **** 
 106:../drivers/fsl_uart_dma.c **** /*!
 107:../drivers/fsl_uart_dma.c ****  * @brief UART DMA receive finished callback function.
 108:../drivers/fsl_uart_dma.c ****  *
 109:../drivers/fsl_uart_dma.c ****  * This function is called when UART DMA receive finished. It disables the UART
 110:../drivers/fsl_uart_dma.c ****  * RX DMA request and sends @ref kStatus_UART_RxIdle to UART callback.
 111:../drivers/fsl_uart_dma.c ****  *
 112:../drivers/fsl_uart_dma.c ****  * @param handle The DMA handle.
 113:../drivers/fsl_uart_dma.c ****  * @param param Callback function parameter.
 114:../drivers/fsl_uart_dma.c ****  */
 115:../drivers/fsl_uart_dma.c **** static void UART_TransferReceiveDMACallback(dma_handle_t *handle, void *param);
 116:../drivers/fsl_uart_dma.c **** 
 117:../drivers/fsl_uart_dma.c **** /*!
 118:../drivers/fsl_uart_dma.c ****  * @brief Get the UART instance from peripheral base address.
 119:../drivers/fsl_uart_dma.c ****  *
 120:../drivers/fsl_uart_dma.c ****  * @param base UART peripheral base address.
 121:../drivers/fsl_uart_dma.c ****  * @return UART instance.
 122:../drivers/fsl_uart_dma.c ****  */
 123:../drivers/fsl_uart_dma.c **** extern uint32_t UART_GetInstance(UART_Type *base);
 124:../drivers/fsl_uart_dma.c **** 
 125:../drivers/fsl_uart_dma.c **** /*******************************************************************************
 126:../drivers/fsl_uart_dma.c ****  * Code
 127:../drivers/fsl_uart_dma.c ****  ******************************************************************************/
 128:../drivers/fsl_uart_dma.c **** 
 129:../drivers/fsl_uart_dma.c **** static void UART_TransferSendDMACallback(dma_handle_t *handle, void *param)
 130:../drivers/fsl_uart_dma.c **** {
  25              		.loc 1 130 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 70B5     		push	{r4, r5, r6, lr}
  31              		.cfi_def_cfa_offset 16
  32              		.cfi_offset 4, -16
  33              		.cfi_offset 5, -12
  34              		.cfi_offset 6, -8
  35              		.cfi_offset 14, -4
  36              	.LVL1:
 131:../drivers/fsl_uart_dma.c ****     assert(handle);
 132:../drivers/fsl_uart_dma.c ****     assert(param);
 133:../drivers/fsl_uart_dma.c **** 
 134:../drivers/fsl_uart_dma.c ****     uart_dma_private_handle_t *uartPrivateHandle = (uart_dma_private_handle_t *)param;
 135:../drivers/fsl_uart_dma.c **** 
 136:../drivers/fsl_uart_dma.c ****     /* Disable UART TX DMA. */
 137:../drivers/fsl_uart_dma.c ****     UART_EnableTxDMA(uartPrivateHandle->base, false);
  37              		.loc 1 137 0
  38 0002 0B68     		ldr	r3, [r1]
  39              	.LVL2:
  40              	.LBB34:
  41              	.LBB35:
  42              		.file 2 "../drivers/fsl_uart.h"
   1:../drivers/fsl_uart.h **** /*
   2:../drivers/fsl_uart.h ****  * The Clear BSD License
   3:../drivers/fsl_uart.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_uart.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_uart.h ****  * All rights reserved.
   6:../drivers/fsl_uart.h ****  *
   7:../drivers/fsl_uart.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_uart.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_uart.h ****  * that the following conditions are met:
  10:../drivers/fsl_uart.h ****  *
  11:../drivers/fsl_uart.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_uart.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_uart.h ****  *
  14:../drivers/fsl_uart.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_uart.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_uart.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_uart.h ****  *
  18:../drivers/fsl_uart.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_uart.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_uart.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_uart.h ****  *
  22:../drivers/fsl_uart.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_uart.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_uart.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_uart.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_uart.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_uart.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_uart.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_uart.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_uart.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_uart.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_uart.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_uart.h ****  */
  34:../drivers/fsl_uart.h **** #ifndef _FSL_UART_H_
  35:../drivers/fsl_uart.h **** #define _FSL_UART_H_
  36:../drivers/fsl_uart.h **** 
  37:../drivers/fsl_uart.h **** #include "fsl_common.h"
  38:../drivers/fsl_uart.h **** 
  39:../drivers/fsl_uart.h **** /*!
  40:../drivers/fsl_uart.h ****  * @addtogroup uart_driver
  41:../drivers/fsl_uart.h ****  * @{
  42:../drivers/fsl_uart.h ****  */
  43:../drivers/fsl_uart.h **** 
  44:../drivers/fsl_uart.h **** /*******************************************************************************
  45:../drivers/fsl_uart.h ****  * Definitions
  46:../drivers/fsl_uart.h ****  ******************************************************************************/
  47:../drivers/fsl_uart.h **** 
  48:../drivers/fsl_uart.h **** /*! @name Driver version */
  49:../drivers/fsl_uart.h **** /*@{*/
  50:../drivers/fsl_uart.h **** /*! @brief UART driver version 2.1.5. */
  51:../drivers/fsl_uart.h **** #define FSL_UART_DRIVER_VERSION (MAKE_VERSION(2, 1, 5))
  52:../drivers/fsl_uart.h **** /*@}*/
  53:../drivers/fsl_uart.h **** 
  54:../drivers/fsl_uart.h **** /*! @brief Error codes for the UART driver. */
  55:../drivers/fsl_uart.h **** enum _uart_status
  56:../drivers/fsl_uart.h **** {
  57:../drivers/fsl_uart.h ****     kStatus_UART_TxBusy = MAKE_STATUS(kStatusGroup_UART, 0),              /*!< Transmitter is busy.
  58:../drivers/fsl_uart.h ****     kStatus_UART_RxBusy = MAKE_STATUS(kStatusGroup_UART, 1),              /*!< Receiver is busy. */
  59:../drivers/fsl_uart.h ****     kStatus_UART_TxIdle = MAKE_STATUS(kStatusGroup_UART, 2),              /*!< UART transmitter is 
  60:../drivers/fsl_uart.h ****     kStatus_UART_RxIdle = MAKE_STATUS(kStatusGroup_UART, 3),              /*!< UART receiver is idl
  61:../drivers/fsl_uart.h ****     kStatus_UART_TxWatermarkTooLarge = MAKE_STATUS(kStatusGroup_UART, 4), /*!< TX FIFO watermark to
  62:../drivers/fsl_uart.h ****     kStatus_UART_RxWatermarkTooLarge = MAKE_STATUS(kStatusGroup_UART, 5), /*!< RX FIFO watermark to
  63:../drivers/fsl_uart.h ****     kStatus_UART_FlagCannotClearManually =
  64:../drivers/fsl_uart.h ****         MAKE_STATUS(kStatusGroup_UART, 6),                                /*!< UART flag can't be m
  65:../drivers/fsl_uart.h ****     kStatus_UART_Error = MAKE_STATUS(kStatusGroup_UART, 7),               /*!< Error happens on UAR
  66:../drivers/fsl_uart.h ****     kStatus_UART_RxRingBufferOverrun = MAKE_STATUS(kStatusGroup_UART, 8), /*!< UART RX software rin
  67:../drivers/fsl_uart.h ****     kStatus_UART_RxHardwareOverrun = MAKE_STATUS(kStatusGroup_UART, 9),   /*!< UART RX receiver ove
  68:../drivers/fsl_uart.h ****     kStatus_UART_NoiseError = MAKE_STATUS(kStatusGroup_UART, 10),         /*!< UART noise error. */
  69:../drivers/fsl_uart.h ****     kStatus_UART_FramingError = MAKE_STATUS(kStatusGroup_UART, 11),       /*!< UART framing error. 
  70:../drivers/fsl_uart.h ****     kStatus_UART_ParityError = MAKE_STATUS(kStatusGroup_UART, 12),        /*!< UART parity error. *
  71:../drivers/fsl_uart.h ****     kStatus_UART_BaudrateNotSupport =
  72:../drivers/fsl_uart.h ****         MAKE_STATUS(kStatusGroup_UART, 13), /*!< Baudrate is not support in current clock source */
  73:../drivers/fsl_uart.h ****     kStatus_UART_IdleLineDetected = MAKE_STATUS(kStatusGroup_UART, 14), /*!< UART IDLE line detecte
  74:../drivers/fsl_uart.h **** };
  75:../drivers/fsl_uart.h **** 
  76:../drivers/fsl_uart.h **** /*! @brief UART parity mode. */
  77:../drivers/fsl_uart.h **** typedef enum _uart_parity_mode
  78:../drivers/fsl_uart.h **** {
  79:../drivers/fsl_uart.h ****     kUART_ParityDisabled = 0x0U, /*!< Parity disabled */
  80:../drivers/fsl_uart.h ****     kUART_ParityEven = 0x2U,     /*!< Parity enabled, type even, bit setting: PE|PT = 10 */
  81:../drivers/fsl_uart.h ****     kUART_ParityOdd = 0x3U,      /*!< Parity enabled, type odd,  bit setting: PE|PT = 11 */
  82:../drivers/fsl_uart.h **** } uart_parity_mode_t;
  83:../drivers/fsl_uart.h **** 
  84:../drivers/fsl_uart.h **** /*! @brief UART stop bit count. */
  85:../drivers/fsl_uart.h **** typedef enum _uart_stop_bit_count
  86:../drivers/fsl_uart.h **** {
  87:../drivers/fsl_uart.h ****     kUART_OneStopBit = 0U, /*!< One stop bit */
  88:../drivers/fsl_uart.h ****     kUART_TwoStopBit = 1U, /*!< Two stop bits */
  89:../drivers/fsl_uart.h **** } uart_stop_bit_count_t;
  90:../drivers/fsl_uart.h **** 
  91:../drivers/fsl_uart.h **** /*! @brief UART idle type select. */
  92:../drivers/fsl_uart.h **** typedef enum _uart_idle_type_select
  93:../drivers/fsl_uart.h **** {
  94:../drivers/fsl_uart.h ****     kUART_IdleTypeStartBit = 0U, /*!< Start counting after a valid start bit. */
  95:../drivers/fsl_uart.h ****     kUART_IdleTypeStopBit = 1U,  /*!< Start conuting after a stop bit. */
  96:../drivers/fsl_uart.h **** } uart_idle_type_select_t;
  97:../drivers/fsl_uart.h **** 
  98:../drivers/fsl_uart.h **** /*!
  99:../drivers/fsl_uart.h ****  * @brief UART interrupt configuration structure, default settings all disabled.
 100:../drivers/fsl_uart.h ****  *
 101:../drivers/fsl_uart.h ****  * This structure contains the settings for all of the UART interrupt configurations.
 102:../drivers/fsl_uart.h ****  */
 103:../drivers/fsl_uart.h **** enum _uart_interrupt_enable
 104:../drivers/fsl_uart.h **** {
 105:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
 106:../drivers/fsl_uart.h ****     kUART_LinBreakInterruptEnable = (UART_BDH_LBKDIE_MASK), /*!< LIN break detect interrupt. */
 107:../drivers/fsl_uart.h **** #endif
 108:../drivers/fsl_uart.h ****     kUART_RxActiveEdgeInterruptEnable = (UART_BDH_RXEDGIE_MASK),   /*!< RX active edge interrupt. *
 109:../drivers/fsl_uart.h ****     kUART_TxDataRegEmptyInterruptEnable = (UART_C2_TIE_MASK << 8), /*!< Transmit data register empt
 110:../drivers/fsl_uart.h ****     kUART_TransmissionCompleteInterruptEnable = (UART_C2_TCIE_MASK << 8), /*!< Transmission complet
 111:../drivers/fsl_uart.h ****     kUART_RxDataRegFullInterruptEnable = (UART_C2_RIE_MASK << 8),         /*!< Receiver data regist
 112:../drivers/fsl_uart.h ****     kUART_IdleLineInterruptEnable = (UART_C2_ILIE_MASK << 8),             /*!< Idle line interrupt.
 113:../drivers/fsl_uart.h ****     kUART_RxOverrunInterruptEnable = (UART_C3_ORIE_MASK << 16),           /*!< Receiver overrun int
 114:../drivers/fsl_uart.h ****     kUART_NoiseErrorInterruptEnable = (UART_C3_NEIE_MASK << 16),          /*!< Noise error flag int
 115:../drivers/fsl_uart.h ****     kUART_FramingErrorInterruptEnable = (UART_C3_FEIE_MASK << 16),        /*!< Framing error flag i
 116:../drivers/fsl_uart.h ****     kUART_ParityErrorInterruptEnable = (UART_C3_PEIE_MASK << 16),         /*!< Parity error flag in
 117:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 118:../drivers/fsl_uart.h ****     kUART_RxFifoOverflowInterruptEnable = (UART_CFIFO_RXOFE_MASK << 24),  /*!< RX FIFO overflow int
 119:../drivers/fsl_uart.h ****     kUART_TxFifoOverflowInterruptEnable = (UART_CFIFO_TXOFE_MASK << 24),  /*!< TX FIFO overflow int
 120:../drivers/fsl_uart.h ****     kUART_RxFifoUnderflowInterruptEnable = (UART_CFIFO_RXUFE_MASK << 24), /*!< RX FIFO underflow in
 121:../drivers/fsl_uart.h **** #endif
 122:../drivers/fsl_uart.h ****     kUART_AllInterruptsEnable =
 123:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
 124:../drivers/fsl_uart.h ****         kUART_LinBreakInterruptEnable |
 125:../drivers/fsl_uart.h **** #endif
 126:../drivers/fsl_uart.h ****         kUART_RxActiveEdgeInterruptEnable | kUART_TxDataRegEmptyInterruptEnable |
 127:../drivers/fsl_uart.h ****         kUART_TransmissionCompleteInterruptEnable | kUART_RxDataRegFullInterruptEnable | kUART_Idle
 128:../drivers/fsl_uart.h ****         kUART_RxOverrunInterruptEnable | kUART_NoiseErrorInterruptEnable | kUART_FramingErrorInterr
 129:../drivers/fsl_uart.h ****         kUART_ParityErrorInterruptEnable
 130:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 131:../drivers/fsl_uart.h ****         |
 132:../drivers/fsl_uart.h ****         kUART_RxFifoOverflowInterruptEnable | kUART_TxFifoOverflowInterruptEnable | kUART_RxFifoUnd
 133:../drivers/fsl_uart.h **** #endif
 134:../drivers/fsl_uart.h ****     ,
 135:../drivers/fsl_uart.h **** };
 136:../drivers/fsl_uart.h **** 
 137:../drivers/fsl_uart.h **** /*!
 138:../drivers/fsl_uart.h ****  * @brief UART status flags.
 139:../drivers/fsl_uart.h ****  *
 140:../drivers/fsl_uart.h ****  * This provides constants for the UART status flags for use in the UART functions.
 141:../drivers/fsl_uart.h ****  */
 142:../drivers/fsl_uart.h **** enum _uart_flags
 143:../drivers/fsl_uart.h **** {
 144:../drivers/fsl_uart.h ****     kUART_TxDataRegEmptyFlag = (UART_S1_TDRE_MASK),     /*!< TX data register empty flag. */
 145:../drivers/fsl_uart.h ****     kUART_TransmissionCompleteFlag = (UART_S1_TC_MASK), /*!< Transmission complete flag. */
 146:../drivers/fsl_uart.h ****     kUART_RxDataRegFullFlag = (UART_S1_RDRF_MASK),      /*!< RX data register full flag. */
 147:../drivers/fsl_uart.h ****     kUART_IdleLineFlag = (UART_S1_IDLE_MASK),           /*!< Idle line detect flag. */
 148:../drivers/fsl_uart.h ****     kUART_RxOverrunFlag = (UART_S1_OR_MASK),            /*!< RX overrun flag. */
 149:../drivers/fsl_uart.h ****     kUART_NoiseErrorFlag = (UART_S1_NF_MASK),           /*!< RX takes 3 samples of each received bi
 150:../drivers/fsl_uart.h ****                                                              If any of these samples differ, noise 
 151:../drivers/fsl_uart.h ****     kUART_FramingErrorFlag = (UART_S1_FE_MASK),         /*!< Frame error flag, sets if logic 0 was 
 152:../drivers/fsl_uart.h ****                                                              where stop bit expected */
 153:../drivers/fsl_uart.h ****     kUART_ParityErrorFlag = (UART_S1_PF_MASK),          /*!< If parity enabled, sets upon parity er
 154:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
 155:../drivers/fsl_uart.h ****     kUART_LinBreakFlag =
 156:../drivers/fsl_uart.h ****         (UART_S2_LBKDIF_MASK
 157:../drivers/fsl_uart.h ****          << 8), /*!< LIN break detect interrupt flag, sets when LIN break char detected and LIN cir
 158:../drivers/fsl_uart.h **** #endif
 159:../drivers/fsl_uart.h ****     kUART_RxActiveEdgeFlag =
 160:../drivers/fsl_uart.h ****         (UART_S2_RXEDGIF_MASK << 8), /*!< RX pin active edge interrupt flag,sets when active edge d
 161:../drivers/fsl_uart.h ****     kUART_RxActiveFlag =
 162:../drivers/fsl_uart.h ****         (UART_S2_RAF_MASK << 8), /*!< Receiver Active Flag (RAF), sets at beginning of valid start 
 163:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DAT
 164:../drivers/fsl_uart.h ****     kUART_NoiseErrorInRxDataRegFlag = (UART_ED_NOISY_MASK << 16),    /*!< Noisy bit, sets if noise 
 165:../drivers/fsl_uart.h ****     kUART_ParityErrorInRxDataRegFlag = (UART_ED_PARITYE_MASK << 16), /*!< Paritye bit, sets if pari
 166:../drivers/fsl_uart.h **** #endif
 167:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 168:../drivers/fsl_uart.h ****     kUART_TxFifoEmptyFlag = (UART_SFIFO_TXEMPT_MASK << 24),   /*!< TXEMPT bit, sets if TX buffer is
 169:../drivers/fsl_uart.h ****     kUART_RxFifoEmptyFlag = (UART_SFIFO_RXEMPT_MASK << 24),   /*!< RXEMPT bit, sets if RX buffer is
 170:../drivers/fsl_uart.h ****     kUART_TxFifoOverflowFlag = (UART_SFIFO_TXOF_MASK << 24),  /*!< TXOF bit, sets if TX buffer over
 171:../drivers/fsl_uart.h ****     kUART_RxFifoOverflowFlag = (UART_SFIFO_RXOF_MASK << 24),  /*!< RXOF bit, sets if receive buffer
 172:../drivers/fsl_uart.h ****     kUART_RxFifoUnderflowFlag = (UART_SFIFO_RXUF_MASK << 24), /*!< RXUF bit, sets if receive buffer
 173:../drivers/fsl_uart.h **** #endif
 174:../drivers/fsl_uart.h **** };
 175:../drivers/fsl_uart.h **** 
 176:../drivers/fsl_uart.h **** /*! @brief UART configuration structure. */
 177:../drivers/fsl_uart.h **** typedef struct _uart_config
 178:../drivers/fsl_uart.h **** {
 179:../drivers/fsl_uart.h ****     uint32_t baudRate_Bps;         /*!< UART baud rate  */
 180:../drivers/fsl_uart.h ****     uart_parity_mode_t parityMode; /*!< Parity mode, disabled (default), even, odd */
 181:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_S
 182:../drivers/fsl_uart.h ****     uart_stop_bit_count_t stopBitCount; /*!< Number of stop bits, 1 stop bit (default) or 2 stop bi
 183:../drivers/fsl_uart.h **** #endif
 184:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 185:../drivers/fsl_uart.h ****     uint8_t txFifoWatermark; /*!< TX FIFO watermark */
 186:../drivers/fsl_uart.h ****     uint8_t rxFifoWatermark; /*!< RX FIFO watermark */
 187:../drivers/fsl_uart.h **** #endif
 188:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_MODEM_SUPPORT) && FSL_FEATURE_UART_HAS_MODEM_SUPPORT
 189:../drivers/fsl_uart.h ****     bool enableRxRTS; /*!< RX RTS enable */
 190:../drivers/fsl_uart.h ****     bool enableTxCTS; /*!< TX CTS enable */
 191:../drivers/fsl_uart.h **** #endif
 192:../drivers/fsl_uart.h ****     uart_idle_type_select_t idleType; /*!< IDLE type select. */
 193:../drivers/fsl_uart.h ****     bool enableTx;                    /*!< Enable TX */
 194:../drivers/fsl_uart.h ****     bool enableRx;                    /*!< Enable RX */
 195:../drivers/fsl_uart.h **** } uart_config_t;
 196:../drivers/fsl_uart.h **** 
 197:../drivers/fsl_uart.h **** /*! @brief UART transfer structure. */
 198:../drivers/fsl_uart.h **** typedef struct _uart_transfer
 199:../drivers/fsl_uart.h **** {
 200:../drivers/fsl_uart.h ****     uint8_t *data;   /*!< The buffer of data to be transfer.*/
 201:../drivers/fsl_uart.h ****     size_t dataSize; /*!< The byte count to be transfer. */
 202:../drivers/fsl_uart.h **** } uart_transfer_t;
 203:../drivers/fsl_uart.h **** 
 204:../drivers/fsl_uart.h **** /* Forward declaration of the handle typedef. */
 205:../drivers/fsl_uart.h **** typedef struct _uart_handle uart_handle_t;
 206:../drivers/fsl_uart.h **** 
 207:../drivers/fsl_uart.h **** /*! @brief UART transfer callback function. */
 208:../drivers/fsl_uart.h **** typedef void (*uart_transfer_callback_t)(UART_Type *base, uart_handle_t *handle, status_t status, v
 209:../drivers/fsl_uart.h **** 
 210:../drivers/fsl_uart.h **** /*! @brief UART handle structure. */
 211:../drivers/fsl_uart.h **** struct _uart_handle
 212:../drivers/fsl_uart.h **** {
 213:../drivers/fsl_uart.h ****     uint8_t *volatile txData;   /*!< Address of remaining data to send. */
 214:../drivers/fsl_uart.h ****     volatile size_t txDataSize; /*!< Size of the remaining data to send. */
 215:../drivers/fsl_uart.h ****     size_t txDataSizeAll;       /*!< Size of the data to send out. */
 216:../drivers/fsl_uart.h ****     uint8_t *volatile rxData;   /*!< Address of remaining data to receive. */
 217:../drivers/fsl_uart.h ****     volatile size_t rxDataSize; /*!< Size of the remaining data to receive. */
 218:../drivers/fsl_uart.h ****     size_t rxDataSizeAll;       /*!< Size of the data to receive. */
 219:../drivers/fsl_uart.h **** 
 220:../drivers/fsl_uart.h ****     uint8_t *rxRingBuffer;              /*!< Start address of the receiver ring buffer. */
 221:../drivers/fsl_uart.h ****     size_t rxRingBufferSize;            /*!< Size of the ring buffer. */
 222:../drivers/fsl_uart.h ****     volatile uint16_t rxRingBufferHead; /*!< Index for the driver to store received data into ring 
 223:../drivers/fsl_uart.h ****     volatile uint16_t rxRingBufferTail; /*!< Index for the user to get data from the ring buffer. *
 224:../drivers/fsl_uart.h **** 
 225:../drivers/fsl_uart.h ****     uart_transfer_callback_t callback; /*!< Callback function. */
 226:../drivers/fsl_uart.h ****     void *userData;                    /*!< UART callback function parameter.*/
 227:../drivers/fsl_uart.h **** 
 228:../drivers/fsl_uart.h ****     volatile uint8_t txState; /*!< TX transfer state. */
 229:../drivers/fsl_uart.h ****     volatile uint8_t rxState; /*!< RX transfer state */
 230:../drivers/fsl_uart.h **** };
 231:../drivers/fsl_uart.h **** 
 232:../drivers/fsl_uart.h **** /*******************************************************************************
 233:../drivers/fsl_uart.h ****  * API
 234:../drivers/fsl_uart.h ****  ******************************************************************************/
 235:../drivers/fsl_uart.h **** 
 236:../drivers/fsl_uart.h **** #if defined(__cplusplus)
 237:../drivers/fsl_uart.h **** extern "C" {
 238:../drivers/fsl_uart.h **** #endif /* _cplusplus */
 239:../drivers/fsl_uart.h **** 
 240:../drivers/fsl_uart.h **** /*!
 241:../drivers/fsl_uart.h ****  * @name Initialization and deinitialization
 242:../drivers/fsl_uart.h ****  * @{
 243:../drivers/fsl_uart.h ****  */
 244:../drivers/fsl_uart.h **** 
 245:../drivers/fsl_uart.h **** /*!
 246:../drivers/fsl_uart.h ****  * @brief Initializes a UART instance with a user configuration structure and peripheral clock.
 247:../drivers/fsl_uart.h ****  *
 248:../drivers/fsl_uart.h ****  * This function configures the UART module with the user-defined settings. The user can configure 
 249:../drivers/fsl_uart.h ****  * structure and also get the default configuration by using the UART_GetDefaultConfig() function.
 250:../drivers/fsl_uart.h ****  * The example below shows how to use this API to configure UART.
 251:../drivers/fsl_uart.h ****  * @code
 252:../drivers/fsl_uart.h ****  *  uart_config_t uartConfig;
 253:../drivers/fsl_uart.h ****  *  uartConfig.baudRate_Bps = 115200U;
 254:../drivers/fsl_uart.h ****  *  uartConfig.parityMode = kUART_ParityDisabled;
 255:../drivers/fsl_uart.h ****  *  uartConfig.stopBitCount = kUART_OneStopBit;
 256:../drivers/fsl_uart.h ****  *  uartConfig.txFifoWatermark = 0;
 257:../drivers/fsl_uart.h ****  *  uartConfig.rxFifoWatermark = 1;
 258:../drivers/fsl_uart.h ****  *  UART_Init(UART1, &uartConfig, 20000000U);
 259:../drivers/fsl_uart.h ****  * @endcode
 260:../drivers/fsl_uart.h ****  *
 261:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 262:../drivers/fsl_uart.h ****  * @param config Pointer to the user-defined configuration structure.
 263:../drivers/fsl_uart.h ****  * @param srcClock_Hz UART clock source frequency in HZ.
 264:../drivers/fsl_uart.h ****  * @retval kStatus_UART_BaudrateNotSupport Baudrate is not support in current clock source.
 265:../drivers/fsl_uart.h ****  * @retval kStatus_Success Status UART initialize succeed
 266:../drivers/fsl_uart.h ****  */
 267:../drivers/fsl_uart.h **** status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz);
 268:../drivers/fsl_uart.h **** 
 269:../drivers/fsl_uart.h **** /*!
 270:../drivers/fsl_uart.h ****  * @brief Deinitializes a UART instance.
 271:../drivers/fsl_uart.h ****  *
 272:../drivers/fsl_uart.h ****  * This function waits for TX complete, disables TX and RX, and disables the UART clock.
 273:../drivers/fsl_uart.h ****  *
 274:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 275:../drivers/fsl_uart.h ****  */
 276:../drivers/fsl_uart.h **** void UART_Deinit(UART_Type *base);
 277:../drivers/fsl_uart.h **** 
 278:../drivers/fsl_uart.h **** /*!
 279:../drivers/fsl_uart.h ****  * @brief Gets the default configuration structure.
 280:../drivers/fsl_uart.h ****  *
 281:../drivers/fsl_uart.h ****  * This function initializes the UART configuration structure to a default value. The default
 282:../drivers/fsl_uart.h ****  * values are as follows.
 283:../drivers/fsl_uart.h ****  *   uartConfig->baudRate_Bps = 115200U;
 284:../drivers/fsl_uart.h ****  *   uartConfig->bitCountPerChar = kUART_8BitsPerChar;
 285:../drivers/fsl_uart.h ****  *   uartConfig->parityMode = kUART_ParityDisabled;
 286:../drivers/fsl_uart.h ****  *   uartConfig->stopBitCount = kUART_OneStopBit;
 287:../drivers/fsl_uart.h ****  *   uartConfig->txFifoWatermark = 0;
 288:../drivers/fsl_uart.h ****  *   uartConfig->rxFifoWatermark = 1;
 289:../drivers/fsl_uart.h ****  *   uartConfig->idleType = kUART_IdleTypeStartBit;
 290:../drivers/fsl_uart.h ****  *   uartConfig->enableTx = false;
 291:../drivers/fsl_uart.h ****  *   uartConfig->enableRx = false;
 292:../drivers/fsl_uart.h ****  *
 293:../drivers/fsl_uart.h ****  * @param config Pointer to configuration structure.
 294:../drivers/fsl_uart.h ****  */
 295:../drivers/fsl_uart.h **** void UART_GetDefaultConfig(uart_config_t *config);
 296:../drivers/fsl_uart.h **** 
 297:../drivers/fsl_uart.h **** /*!
 298:../drivers/fsl_uart.h ****  * @brief Sets the UART instance baud rate.
 299:../drivers/fsl_uart.h ****  *
 300:../drivers/fsl_uart.h ****  * This function configures the UART module baud rate. This function is used to update
 301:../drivers/fsl_uart.h ****  * the UART module baud rate after the UART module is initialized by the UART_Init.
 302:../drivers/fsl_uart.h ****  * @code
 303:../drivers/fsl_uart.h ****  *  UART_SetBaudRate(UART1, 115200U, 20000000U);
 304:../drivers/fsl_uart.h ****  * @endcode
 305:../drivers/fsl_uart.h ****  *
 306:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 307:../drivers/fsl_uart.h ****  * @param baudRate_Bps UART baudrate to be set.
 308:../drivers/fsl_uart.h ****  * @param srcClock_Hz UART clock source freqency in Hz.
 309:../drivers/fsl_uart.h ****  * @retval kStatus_UART_BaudrateNotSupport Baudrate is not support in the current clock source.
 310:../drivers/fsl_uart.h ****  * @retval kStatus_Success Set baudrate succeeded.
 311:../drivers/fsl_uart.h ****  */
 312:../drivers/fsl_uart.h **** status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz);
 313:../drivers/fsl_uart.h **** 
 314:../drivers/fsl_uart.h **** /* @} */
 315:../drivers/fsl_uart.h **** 
 316:../drivers/fsl_uart.h **** /*!
 317:../drivers/fsl_uart.h ****  * @name Status
 318:../drivers/fsl_uart.h ****  * @{
 319:../drivers/fsl_uart.h ****  */
 320:../drivers/fsl_uart.h **** 
 321:../drivers/fsl_uart.h **** /*!
 322:../drivers/fsl_uart.h ****  * @brief Gets UART status flags.
 323:../drivers/fsl_uart.h ****  *
 324:../drivers/fsl_uart.h ****  * This function gets all UART status flags. The flags are returned as the logical
 325:../drivers/fsl_uart.h ****  * OR value of the enumerators @ref _uart_flags. To check a specific status,
 326:../drivers/fsl_uart.h ****  * compare the return value with enumerators in @ref _uart_flags.
 327:../drivers/fsl_uart.h ****  * For example, to check whether the TX is empty, do the following.
 328:../drivers/fsl_uart.h ****  * @code
 329:../drivers/fsl_uart.h ****  *     if (kUART_TxDataRegEmptyFlag & UART_GetStatusFlags(UART1))
 330:../drivers/fsl_uart.h ****  *     {
 331:../drivers/fsl_uart.h ****  *         ...
 332:../drivers/fsl_uart.h ****  *     }
 333:../drivers/fsl_uart.h ****  * @endcode
 334:../drivers/fsl_uart.h ****  *
 335:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 336:../drivers/fsl_uart.h ****  * @return UART status flags which are ORed by the enumerators in the _uart_flags.
 337:../drivers/fsl_uart.h ****  */
 338:../drivers/fsl_uart.h **** uint32_t UART_GetStatusFlags(UART_Type *base);
 339:../drivers/fsl_uart.h **** 
 340:../drivers/fsl_uart.h **** /*!
 341:../drivers/fsl_uart.h ****  * @brief Clears status flags with the provided mask.
 342:../drivers/fsl_uart.h ****  *
 343:../drivers/fsl_uart.h ****  * This function clears UART status flags with a provided mask. An automatically cleared flag
 344:../drivers/fsl_uart.h ****  * can't be cleared by this function.
 345:../drivers/fsl_uart.h ****  * These flags can only be cleared or set by hardware.
 346:../drivers/fsl_uart.h ****  *    kUART_TxDataRegEmptyFlag, kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag,
 347:../drivers/fsl_uart.h ****  *    kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag, kUART_ParityErrorInRxDataRegFlag,
 348:../drivers/fsl_uart.h ****  *    kUART_TxFifoEmptyFlag,kUART_RxFifoEmptyFlag
 349:../drivers/fsl_uart.h ****  * Note that this API should be called when the Tx/Rx is idle. Otherwise it has no effect.
 350:../drivers/fsl_uart.h ****  *
 351:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 352:../drivers/fsl_uart.h ****  * @param mask The status flags to be cleared; it is logical OR value of @ref _uart_flags.
 353:../drivers/fsl_uart.h ****  * @retval kStatus_UART_FlagCannotClearManually The flag can't be cleared by this function but
 354:../drivers/fsl_uart.h ****  *         it is cleared automatically by hardware.
 355:../drivers/fsl_uart.h ****  * @retval kStatus_Success Status in the mask is cleared.
 356:../drivers/fsl_uart.h ****  */
 357:../drivers/fsl_uart.h **** status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask);
 358:../drivers/fsl_uart.h **** 
 359:../drivers/fsl_uart.h **** /* @} */
 360:../drivers/fsl_uart.h **** 
 361:../drivers/fsl_uart.h **** /*!
 362:../drivers/fsl_uart.h ****  * @name Interrupts
 363:../drivers/fsl_uart.h ****  * @{
 364:../drivers/fsl_uart.h ****  */
 365:../drivers/fsl_uart.h **** 
 366:../drivers/fsl_uart.h **** /*!
 367:../drivers/fsl_uart.h ****  * @brief Enables UART interrupts according to the provided mask.
 368:../drivers/fsl_uart.h ****  *
 369:../drivers/fsl_uart.h ****  * This function enables the UART interrupts according to the provided mask. The mask
 370:../drivers/fsl_uart.h ****  * is a logical OR of enumeration members. See @ref _uart_interrupt_enable.
 371:../drivers/fsl_uart.h ****  * For example, to enable TX empty interrupt and RX full interrupt, do the following.
 372:../drivers/fsl_uart.h ****  * @code
 373:../drivers/fsl_uart.h ****  *     UART_EnableInterrupts(UART1,kUART_TxDataRegEmptyInterruptEnable | kUART_RxDataRegFullInterru
 374:../drivers/fsl_uart.h ****  * @endcode
 375:../drivers/fsl_uart.h ****  *
 376:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 377:../drivers/fsl_uart.h ****  * @param mask The interrupts to enable. Logical OR of @ref _uart_interrupt_enable.
 378:../drivers/fsl_uart.h ****  */
 379:../drivers/fsl_uart.h **** void UART_EnableInterrupts(UART_Type *base, uint32_t mask);
 380:../drivers/fsl_uart.h **** 
 381:../drivers/fsl_uart.h **** /*!
 382:../drivers/fsl_uart.h ****  * @brief Disables the UART interrupts according to the provided mask.
 383:../drivers/fsl_uart.h ****  *
 384:../drivers/fsl_uart.h ****  * This function disables the UART interrupts according to the provided mask. The mask
 385:../drivers/fsl_uart.h ****  * is a logical OR of enumeration members. See @ref _uart_interrupt_enable.
 386:../drivers/fsl_uart.h ****  * For example, to disable TX empty interrupt and RX full interrupt do the following.
 387:../drivers/fsl_uart.h ****  * @code
 388:../drivers/fsl_uart.h ****  *     UART_DisableInterrupts(UART1,kUART_TxDataRegEmptyInterruptEnable | kUART_RxDataRegFullInterr
 389:../drivers/fsl_uart.h ****  * @endcode
 390:../drivers/fsl_uart.h ****  *
 391:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 392:../drivers/fsl_uart.h ****  * @param mask The interrupts to disable. Logical OR of @ref _uart_interrupt_enable.
 393:../drivers/fsl_uart.h ****  */
 394:../drivers/fsl_uart.h **** void UART_DisableInterrupts(UART_Type *base, uint32_t mask);
 395:../drivers/fsl_uart.h **** 
 396:../drivers/fsl_uart.h **** /*!
 397:../drivers/fsl_uart.h ****  * @brief Gets the enabled UART interrupts.
 398:../drivers/fsl_uart.h ****  *
 399:../drivers/fsl_uart.h ****  * This function gets the enabled UART interrupts. The enabled interrupts are returned
 400:../drivers/fsl_uart.h ****  * as the logical OR value of the enumerators @ref _uart_interrupt_enable. To check
 401:../drivers/fsl_uart.h ****  * a specific interrupts enable status, compare the return value with enumerators
 402:../drivers/fsl_uart.h ****  * in @ref _uart_interrupt_enable.
 403:../drivers/fsl_uart.h ****  * For example, to check whether TX empty interrupt is enabled, do the following.
 404:../drivers/fsl_uart.h ****  * @code
 405:../drivers/fsl_uart.h ****  *     uint32_t enabledInterrupts = UART_GetEnabledInterrupts(UART1);
 406:../drivers/fsl_uart.h ****  *
 407:../drivers/fsl_uart.h ****  *     if (kUART_TxDataRegEmptyInterruptEnable & enabledInterrupts)
 408:../drivers/fsl_uart.h ****  *     {
 409:../drivers/fsl_uart.h ****  *         ...
 410:../drivers/fsl_uart.h ****  *     }
 411:../drivers/fsl_uart.h ****  * @endcode
 412:../drivers/fsl_uart.h ****  *
 413:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 414:../drivers/fsl_uart.h ****  * @return UART interrupt flags which are logical OR of the enumerators in @ref _uart_interrupt_ena
 415:../drivers/fsl_uart.h ****  */
 416:../drivers/fsl_uart.h **** uint32_t UART_GetEnabledInterrupts(UART_Type *base);
 417:../drivers/fsl_uart.h **** 
 418:../drivers/fsl_uart.h **** /* @} */
 419:../drivers/fsl_uart.h **** 
 420:../drivers/fsl_uart.h **** #if defined(FSL_FEATURE_UART_HAS_DMA_SELECT) && FSL_FEATURE_UART_HAS_DMA_SELECT
 421:../drivers/fsl_uart.h **** /*!
 422:../drivers/fsl_uart.h ****  * @name DMA Control
 423:../drivers/fsl_uart.h ****  * @{
 424:../drivers/fsl_uart.h ****  */
 425:../drivers/fsl_uart.h **** 
 426:../drivers/fsl_uart.h **** /*!
 427:../drivers/fsl_uart.h ****  * @brief Gets the UART data register address.
 428:../drivers/fsl_uart.h ****  *
 429:../drivers/fsl_uart.h ****  * This function returns the UART data register address, which is mainly used by DMA/eDMA.
 430:../drivers/fsl_uart.h ****  *
 431:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 432:../drivers/fsl_uart.h ****  * @return UART data register addresses which are used both by the transmitter and the receiver.
 433:../drivers/fsl_uart.h ****  */
 434:../drivers/fsl_uart.h **** static inline uint32_t UART_GetDataRegisterAddress(UART_Type *base)
 435:../drivers/fsl_uart.h **** {
 436:../drivers/fsl_uart.h ****     return (uint32_t) & (base->D);
 437:../drivers/fsl_uart.h **** }
 438:../drivers/fsl_uart.h **** 
 439:../drivers/fsl_uart.h **** /*!
 440:../drivers/fsl_uart.h ****  * @brief Enables or disables the UART transmitter DMA request.
 441:../drivers/fsl_uart.h ****  *
 442:../drivers/fsl_uart.h ****  * This function enables or disables the transmit data register empty flag, S1[TDRE], to generate t
 443:../drivers/fsl_uart.h ****  *
 444:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 445:../drivers/fsl_uart.h ****  * @param enable True to enable, false to disable.
 446:../drivers/fsl_uart.h ****  */
 447:../drivers/fsl_uart.h **** static inline void UART_EnableTxDMA(UART_Type *base, bool enable)
 448:../drivers/fsl_uart.h **** {
 449:../drivers/fsl_uart.h ****     if (enable)
 450:../drivers/fsl_uart.h ****     {
 451:../drivers/fsl_uart.h **** #if (defined(FSL_FEATURE_UART_IS_SCI) && FSL_FEATURE_UART_IS_SCI)
 452:../drivers/fsl_uart.h ****         base->C4 |= UART_C4_TDMAS_MASK;
 453:../drivers/fsl_uart.h **** #else
 454:../drivers/fsl_uart.h ****         base->C5 |= UART_C5_TDMAS_MASK;
 455:../drivers/fsl_uart.h **** #endif
 456:../drivers/fsl_uart.h ****         base->C2 |= UART_C2_TIE_MASK;
 457:../drivers/fsl_uart.h ****     }
 458:../drivers/fsl_uart.h ****     else
 459:../drivers/fsl_uart.h ****     {
 460:../drivers/fsl_uart.h **** #if (defined(FSL_FEATURE_UART_IS_SCI) && FSL_FEATURE_UART_IS_SCI)
 461:../drivers/fsl_uart.h ****         base->C4 &= ~UART_C4_TDMAS_MASK;
 462:../drivers/fsl_uart.h **** #else
 463:../drivers/fsl_uart.h ****         base->C5 &= ~UART_C5_TDMAS_MASK;
  43              		.loc 2 463 0
  44 0004 DC7A     		ldrb	r4, [r3, #11]
  45 0006 7F25     		movs	r5, #127
  46 0008 2C40     		ands	r4, r5
  47 000a DC72     		strb	r4, [r3, #11]
 464:../drivers/fsl_uart.h **** #endif
 465:../drivers/fsl_uart.h ****         base->C2 &= ~UART_C2_TIE_MASK;
  48              		.loc 2 465 0
  49 000c DA78     		ldrb	r2, [r3, #3]
  50 000e 2A40     		ands	r2, r5
  51 0010 DA70     		strb	r2, [r3, #3]
  52              	.LVL3:
  53              	.LBE35:
  54              	.LBE34:
 138:../drivers/fsl_uart_dma.c **** 
 139:../drivers/fsl_uart_dma.c ****     /* Disable interrupt. */
 140:../drivers/fsl_uart_dma.c ****     DMA_DisableInterrupts(handle->base, handle->channel);
  55              		.loc 1 140 0
  56 0012 0368     		ldr	r3, [r0]
  57 0014 0279     		ldrb	r2, [r0, #4]
  58              	.LVL4:
  59              	.LBB36:
  60              	.LBB37:
  61              		.file 3 "../drivers/fsl_dma.h"
   1:../drivers/fsl_dma.h **** /*
   2:../drivers/fsl_dma.h ****  * The Clear BSD License
   3:../drivers/fsl_dma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dma.h ****  * All rights reserved.
   6:../drivers/fsl_dma.h ****  *
   7:../drivers/fsl_dma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dma.h ****  * that the following conditions are met:
  10:../drivers/fsl_dma.h ****  *
  11:../drivers/fsl_dma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dma.h ****  *
  14:../drivers/fsl_dma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dma.h ****  *
  18:../drivers/fsl_dma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dma.h ****  *
  22:../drivers/fsl_dma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dma.h ****  */
  34:../drivers/fsl_dma.h **** 
  35:../drivers/fsl_dma.h **** #ifndef _FSL_DMA_H_
  36:../drivers/fsl_dma.h **** #define _FSL_DMA_H_
  37:../drivers/fsl_dma.h **** 
  38:../drivers/fsl_dma.h **** #include "fsl_common.h"
  39:../drivers/fsl_dma.h **** 
  40:../drivers/fsl_dma.h **** /*!
  41:../drivers/fsl_dma.h ****  * @addtogroup dma
  42:../drivers/fsl_dma.h ****  * @{
  43:../drivers/fsl_dma.h ****  */
  44:../drivers/fsl_dma.h **** 
  45:../drivers/fsl_dma.h **** 
  46:../drivers/fsl_dma.h **** /*******************************************************************************
  47:../drivers/fsl_dma.h ****  * Definitions
  48:../drivers/fsl_dma.h ****  ******************************************************************************/
  49:../drivers/fsl_dma.h **** 
  50:../drivers/fsl_dma.h **** /*! @name Driver version */
  51:../drivers/fsl_dma.h **** /*@{*/
  52:../drivers/fsl_dma.h **** /*! @brief DMA driver version 2.0.1. */
  53:../drivers/fsl_dma.h **** #define FSL_DMA_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  54:../drivers/fsl_dma.h **** /*@}*/
  55:../drivers/fsl_dma.h **** 
  56:../drivers/fsl_dma.h **** /*! @brief status flag for the DMA driver. */
  57:../drivers/fsl_dma.h **** enum _dma_channel_status_flags
  58:../drivers/fsl_dma.h **** {
  59:../drivers/fsl_dma.h ****     kDMA_TransactionsBCRFlag = DMA_DSR_BCR_BCR_MASK,       /*!< Contains the number of bytes yet to
  60:../drivers/fsl_dma.h ****                                                                 transferred for a given block */
  61:../drivers/fsl_dma.h ****     kDMA_TransactionsDoneFlag = DMA_DSR_BCR_DONE_MASK,     /*!< Transactions Done */
  62:../drivers/fsl_dma.h ****     kDMA_TransactionsBusyFlag = DMA_DSR_BCR_BSY_MASK,      /*!< Transactions Busy */
  63:../drivers/fsl_dma.h ****     kDMA_TransactionsRequestFlag = DMA_DSR_BCR_REQ_MASK,   /*!< Transactions Request */
  64:../drivers/fsl_dma.h ****     kDMA_BusErrorOnDestinationFlag = DMA_DSR_BCR_BED_MASK, /*!< Bus Error on Destination */
  65:../drivers/fsl_dma.h ****     kDMA_BusErrorOnSourceFlag = DMA_DSR_BCR_BES_MASK,      /*!< Bus Error on Source */
  66:../drivers/fsl_dma.h ****     kDMA_ConfigurationErrorFlag = DMA_DSR_BCR_CE_MASK,     /*!< Configuration Error */
  67:../drivers/fsl_dma.h **** };
  68:../drivers/fsl_dma.h **** 
  69:../drivers/fsl_dma.h **** /*! @brief DMA transfer size type*/
  70:../drivers/fsl_dma.h **** typedef enum _dma_transfer_size
  71:../drivers/fsl_dma.h **** {
  72:../drivers/fsl_dma.h ****     kDMA_Transfersize32bits = 0x0U, /*!< 32 bits are transferred for every read/write */
  73:../drivers/fsl_dma.h ****     kDMA_Transfersize8bits,         /*!< 8 bits are transferred for every read/write */
  74:../drivers/fsl_dma.h ****     kDMA_Transfersize16bits,        /*!< 16b its are transferred for every read/write */
  75:../drivers/fsl_dma.h **** } dma_transfer_size_t;
  76:../drivers/fsl_dma.h **** 
  77:../drivers/fsl_dma.h **** /*! @brief Configuration type for the DMA modulo */
  78:../drivers/fsl_dma.h **** typedef enum _dma_modulo
  79:../drivers/fsl_dma.h **** {
  80:../drivers/fsl_dma.h ****     kDMA_ModuloDisable = 0x0U, /*!< Buffer disabled */
  81:../drivers/fsl_dma.h ****     kDMA_Modulo16Bytes,        /*!< Circular buffer size is 16 bytes. */
  82:../drivers/fsl_dma.h ****     kDMA_Modulo32Bytes,        /*!< Circular buffer size is 32 bytes. */
  83:../drivers/fsl_dma.h ****     kDMA_Modulo64Bytes,        /*!< Circular buffer size is 64 bytes. */
  84:../drivers/fsl_dma.h ****     kDMA_Modulo128Bytes,       /*!< Circular buffer size is 128 bytes. */
  85:../drivers/fsl_dma.h ****     kDMA_Modulo256Bytes,       /*!< Circular buffer size is 256 bytes. */
  86:../drivers/fsl_dma.h ****     kDMA_Modulo512Bytes,       /*!< Circular buffer size is 512 bytes. */
  87:../drivers/fsl_dma.h ****     kDMA_Modulo1KBytes,        /*!< Circular buffer size is 1 KB. */
  88:../drivers/fsl_dma.h ****     kDMA_Modulo2KBytes,        /*!< Circular buffer size is 2 KB. */
  89:../drivers/fsl_dma.h ****     kDMA_Modulo4KBytes,        /*!< Circular buffer size is 4 KB. */
  90:../drivers/fsl_dma.h ****     kDMA_Modulo8KBytes,        /*!< Circular buffer size is 8 KB. */
  91:../drivers/fsl_dma.h ****     kDMA_Modulo16KBytes,       /*!< Circular buffer size is 16 KB. */
  92:../drivers/fsl_dma.h ****     kDMA_Modulo32KBytes,       /*!< Circular buffer size is 32 KB. */
  93:../drivers/fsl_dma.h ****     kDMA_Modulo64KBytes,       /*!< Circular buffer size is 64 KB. */
  94:../drivers/fsl_dma.h ****     kDMA_Modulo128KBytes,      /*!< Circular buffer size is 128 KB. */
  95:../drivers/fsl_dma.h ****     kDMA_Modulo256KBytes,      /*!< Circular buffer size is 256 KB. */
  96:../drivers/fsl_dma.h **** } dma_modulo_t;
  97:../drivers/fsl_dma.h **** 
  98:../drivers/fsl_dma.h **** /*! @brief DMA channel link type */
  99:../drivers/fsl_dma.h **** typedef enum _dma_channel_link_type
 100:../drivers/fsl_dma.h **** {
 101:../drivers/fsl_dma.h ****     kDMA_ChannelLinkDisable = 0x0U,      /*!< No channel link. */
 102:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AndChannel2, /*!< Perform a link to channel LCH1 after each cycle-steal
 103:../drivers/fsl_dma.h ****                                               followed by a link to LCH2 after the BCR decrements t
 104:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1,            /*!< Perform a link to LCH1 after each cycle-steal transfe
 105:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AfterBCR0,   /*!< Perform a link to LCH1 after the BCR decrements. */
 106:../drivers/fsl_dma.h **** } dma_channel_link_type_t;
 107:../drivers/fsl_dma.h **** 
 108:../drivers/fsl_dma.h **** /*! @brief DMA transfer type */
 109:../drivers/fsl_dma.h **** typedef enum _dma_transfer_type
 110:../drivers/fsl_dma.h **** {
 111:../drivers/fsl_dma.h ****     kDMA_MemoryToMemory = 0x0U, /*!< Memory to Memory transfer. */
 112:../drivers/fsl_dma.h ****     kDMA_PeripheralToMemory,    /*!< Peripheral to Memory transfer. */
 113:../drivers/fsl_dma.h ****     kDMA_MemoryToPeripheral,    /*!< Memory to Peripheral transfer. */
 114:../drivers/fsl_dma.h **** } dma_transfer_type_t;
 115:../drivers/fsl_dma.h **** 
 116:../drivers/fsl_dma.h **** /*! @brief DMA transfer options */
 117:../drivers/fsl_dma.h **** typedef enum _dma_transfer_options
 118:../drivers/fsl_dma.h **** {
 119:../drivers/fsl_dma.h ****     kDMA_NoOptions = 0x0U, /*!< Transfer without options. */
 120:../drivers/fsl_dma.h ****     kDMA_EnableInterrupt,  /*!< Enable interrupt while transfer complete. */
 121:../drivers/fsl_dma.h **** } dma_transfer_options_t;
 122:../drivers/fsl_dma.h **** 
 123:../drivers/fsl_dma.h **** /*! @brief DMA transfer status */
 124:../drivers/fsl_dma.h **** enum _dma_transfer_status
 125:../drivers/fsl_dma.h **** {
 126:../drivers/fsl_dma.h ****     kStatus_DMA_Busy = MAKE_STATUS(kStatusGroup_DMA, 0),
 127:../drivers/fsl_dma.h **** };
 128:../drivers/fsl_dma.h **** 
 129:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 130:../drivers/fsl_dma.h **** typedef struct _dma_transfer_config
 131:../drivers/fsl_dma.h **** {
 132:../drivers/fsl_dma.h ****     uint32_t srcAddr;             /*!< DMA transfer source address. */
 133:../drivers/fsl_dma.h ****     uint32_t destAddr;            /*!< DMA destination address.*/
 134:../drivers/fsl_dma.h ****     bool enableSrcIncrement;      /*!< Source address increase after each transfer. */
 135:../drivers/fsl_dma.h ****     dma_transfer_size_t srcSize;  /*!< Source transfer size unit. */
 136:../drivers/fsl_dma.h ****     bool enableDestIncrement;     /*!< Destination address increase after each transfer. */
 137:../drivers/fsl_dma.h ****     dma_transfer_size_t destSize; /*!< Destination transfer unit.*/
 138:../drivers/fsl_dma.h ****     uint32_t transferSize;        /*!< The number of bytes to be transferred. */
 139:../drivers/fsl_dma.h **** } dma_transfer_config_t;
 140:../drivers/fsl_dma.h **** 
 141:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 142:../drivers/fsl_dma.h **** typedef struct _dma_channel_link_config
 143:../drivers/fsl_dma.h **** {
 144:../drivers/fsl_dma.h ****     dma_channel_link_type_t linkType; /*!< Channel link type. */
 145:../drivers/fsl_dma.h ****     uint32_t channel1;                /*!< The index of channel 1. */
 146:../drivers/fsl_dma.h ****     uint32_t channel2;                /*!< The index of channel 2. */
 147:../drivers/fsl_dma.h **** } dma_channel_link_config_t;
 148:../drivers/fsl_dma.h **** 
 149:../drivers/fsl_dma.h **** struct _dma_handle;
 150:../drivers/fsl_dma.h **** /*! @brief Callback function prototype for the DMA driver. */
 151:../drivers/fsl_dma.h **** typedef void (*dma_callback)(struct _dma_handle *handle, void *userData);
 152:../drivers/fsl_dma.h **** 
 153:../drivers/fsl_dma.h **** /*! @brief DMA DMA handle structure */
 154:../drivers/fsl_dma.h **** typedef struct _dma_handle
 155:../drivers/fsl_dma.h **** {
 156:../drivers/fsl_dma.h ****     DMA_Type *base;        /*!< DMA peripheral address. */
 157:../drivers/fsl_dma.h ****     uint8_t channel;       /*!< DMA channel used. */
 158:../drivers/fsl_dma.h ****     dma_callback callback; /*!< DMA callback function.*/
 159:../drivers/fsl_dma.h ****     void *userData;        /*!< Callback parameter. */
 160:../drivers/fsl_dma.h **** } dma_handle_t;
 161:../drivers/fsl_dma.h **** 
 162:../drivers/fsl_dma.h **** /*******************************************************************************
 163:../drivers/fsl_dma.h ****  * API
 164:../drivers/fsl_dma.h ****  ******************************************************************************/
 165:../drivers/fsl_dma.h **** #if defined(__cplusplus)
 166:../drivers/fsl_dma.h **** extern "C" {
 167:../drivers/fsl_dma.h **** #endif /* __cplusplus */
 168:../drivers/fsl_dma.h **** 
 169:../drivers/fsl_dma.h **** /*!
 170:../drivers/fsl_dma.h ****  * @name DMA Initialization and De-initialization
 171:../drivers/fsl_dma.h ****  * @{
 172:../drivers/fsl_dma.h ****  */
 173:../drivers/fsl_dma.h **** 
 174:../drivers/fsl_dma.h **** /*!
 175:../drivers/fsl_dma.h ****  * @brief Initializes the DMA peripheral.
 176:../drivers/fsl_dma.h ****  *
 177:../drivers/fsl_dma.h ****  * This function ungates the DMA clock.
 178:../drivers/fsl_dma.h ****  *
 179:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 180:../drivers/fsl_dma.h ****  */
 181:../drivers/fsl_dma.h **** void DMA_Init(DMA_Type *base);
 182:../drivers/fsl_dma.h **** 
 183:../drivers/fsl_dma.h **** /*!
 184:../drivers/fsl_dma.h ****  * @brief Deinitializes the DMA peripheral.
 185:../drivers/fsl_dma.h ****  *
 186:../drivers/fsl_dma.h ****  * This function gates the DMA clock.
 187:../drivers/fsl_dma.h ****  *
 188:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 189:../drivers/fsl_dma.h ****  */
 190:../drivers/fsl_dma.h **** void DMA_Deinit(DMA_Type *base);
 191:../drivers/fsl_dma.h **** 
 192:../drivers/fsl_dma.h **** /* @} */
 193:../drivers/fsl_dma.h **** /*!
 194:../drivers/fsl_dma.h ****  * @name DMA Channel Operation
 195:../drivers/fsl_dma.h ****  * @{
 196:../drivers/fsl_dma.h ****  */
 197:../drivers/fsl_dma.h **** 
 198:../drivers/fsl_dma.h **** /*!
 199:../drivers/fsl_dma.h ****  * @brief Resets the DMA channel.
 200:../drivers/fsl_dma.h ****  *
 201:../drivers/fsl_dma.h ****  * Sets all register values to reset values and enables
 202:../drivers/fsl_dma.h ****  * the cycle steal and auto stop channel request features.
 203:../drivers/fsl_dma.h ****  *
 204:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 205:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 206:../drivers/fsl_dma.h ****  */
 207:../drivers/fsl_dma.h **** void DMA_ResetChannel(DMA_Type *base, uint32_t channel);
 208:../drivers/fsl_dma.h **** 
 209:../drivers/fsl_dma.h **** /*!
 210:../drivers/fsl_dma.h ****  * @brief Configures the DMA transfer attribute.
 211:../drivers/fsl_dma.h ****  *
 212:../drivers/fsl_dma.h ****  * This function configures the transfer attribute including the source address,
 213:../drivers/fsl_dma.h ****  * destination address, transfer size, and so on.
 214:../drivers/fsl_dma.h ****  * This example shows how to set up the the dma_transfer_config_t
 215:../drivers/fsl_dma.h ****  * parameters and how to call the DMA_ConfigBasicTransfer function.
 216:../drivers/fsl_dma.h ****  * @code
 217:../drivers/fsl_dma.h ****  *   dma_transfer_config_t transferConfig;
 218:../drivers/fsl_dma.h ****  *   memset(&transferConfig, 0, sizeof(transferConfig));
 219:../drivers/fsl_dma.h ****  *   transferConfig.srcAddr = (uint32_t)srcAddr;
 220:../drivers/fsl_dma.h ****  *   transferConfig.destAddr = (uint32_t)destAddr;
 221:../drivers/fsl_dma.h ****  *   transferConfig.enbaleSrcIncrement = true;
 222:../drivers/fsl_dma.h ****  *   transferConfig.enableDestIncrement = true;
 223:../drivers/fsl_dma.h ****  *   transferConfig.srcSize = kDMA_Transfersize32bits;
 224:../drivers/fsl_dma.h ****  *   transferConfig.destSize = kDMA_Transfersize32bits;
 225:../drivers/fsl_dma.h ****  *   transferConfig.transferSize = sizeof(uint32_t) * BUFF_LENGTH;
 226:../drivers/fsl_dma.h ****  *   DMA_SetTransferConfig(DMA0, 0, &transferConfig);
 227:../drivers/fsl_dma.h ****  * @endcode
 228:../drivers/fsl_dma.h ****  *
 229:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 230:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 231:../drivers/fsl_dma.h ****  * @param config Pointer to the DMA transfer configuration structure.
 232:../drivers/fsl_dma.h ****  */
 233:../drivers/fsl_dma.h **** void DMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const dma_transfer_config_t *config);
 234:../drivers/fsl_dma.h **** 
 235:../drivers/fsl_dma.h **** /*!
 236:../drivers/fsl_dma.h ****  * @brief Configures the DMA channel link feature.
 237:../drivers/fsl_dma.h ****  *
 238:../drivers/fsl_dma.h ****  * This function allows DMA channels to have their transfers linked. The current DMA channel
 239:../drivers/fsl_dma.h ****  * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the channel link
 240:../drivers/fsl_dma.h ****  * type.
 241:../drivers/fsl_dma.h ****  * Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2
 242:../drivers/fsl_dma.h ****  * after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1AndChannel2.
 243:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after each cycle-steal transfer if the type is kDMA_ChannelLinkChannel1.
 244:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1Afte
 245:../drivers/fsl_dma.h ****  *
 246:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 247:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 248:../drivers/fsl_dma.h ****  * @param config Pointer to the channel link configuration structure.
 249:../drivers/fsl_dma.h ****  */
 250:../drivers/fsl_dma.h **** void DMA_SetChannelLinkConfig(DMA_Type *base, uint32_t channel, const dma_channel_link_config_t *co
 251:../drivers/fsl_dma.h **** 
 252:../drivers/fsl_dma.h **** /*!
 253:../drivers/fsl_dma.h ****  * @brief Sets the DMA source address for the DMA transfer.
 254:../drivers/fsl_dma.h ****  *
 255:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 256:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 257:../drivers/fsl_dma.h ****  * @param srcAddr DMA source address.
 258:../drivers/fsl_dma.h ****  */
 259:../drivers/fsl_dma.h **** static inline void DMA_SetSourceAddress(DMA_Type *base, uint32_t channel, uint32_t srcAddr)
 260:../drivers/fsl_dma.h **** {
 261:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 262:../drivers/fsl_dma.h **** 
 263:../drivers/fsl_dma.h ****     base->DMA[channel].SAR = srcAddr;
 264:../drivers/fsl_dma.h **** }
 265:../drivers/fsl_dma.h **** 
 266:../drivers/fsl_dma.h **** /*!
 267:../drivers/fsl_dma.h ****  * @brief Sets the DMA destination address for the DMA transfer.
 268:../drivers/fsl_dma.h ****  *
 269:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 270:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 271:../drivers/fsl_dma.h ****  * @param destAddr DMA destination address.
 272:../drivers/fsl_dma.h ****  */
 273:../drivers/fsl_dma.h **** static inline void DMA_SetDestinationAddress(DMA_Type *base, uint32_t channel, uint32_t destAddr)
 274:../drivers/fsl_dma.h **** {
 275:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 276:../drivers/fsl_dma.h **** 
 277:../drivers/fsl_dma.h ****     base->DMA[channel].DAR = destAddr;
 278:../drivers/fsl_dma.h **** }
 279:../drivers/fsl_dma.h **** 
 280:../drivers/fsl_dma.h **** /*!
 281:../drivers/fsl_dma.h ****  * @brief Sets the DMA transfer size for the DMA transfer.
 282:../drivers/fsl_dma.h ****  *
 283:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 284:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 285:../drivers/fsl_dma.h ****  * @param size The number of bytes to be transferred.
 286:../drivers/fsl_dma.h ****  */
 287:../drivers/fsl_dma.h **** static inline void DMA_SetTransferSize(DMA_Type *base, uint32_t channel, uint32_t size)
 288:../drivers/fsl_dma.h **** {
 289:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 290:../drivers/fsl_dma.h **** 
 291:../drivers/fsl_dma.h ****     base->DMA[channel].DSR_BCR = DMA_DSR_BCR_BCR(size);
 292:../drivers/fsl_dma.h **** }
 293:../drivers/fsl_dma.h **** 
 294:../drivers/fsl_dma.h **** /*!
 295:../drivers/fsl_dma.h ****  * @brief Sets the DMA modulo for the DMA transfer.
 296:../drivers/fsl_dma.h ****  *
 297:../drivers/fsl_dma.h ****  * This function defines a specific address range specified to be the value after (SAR + SSIZE)/(DA
 298:../drivers/fsl_dma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 299:../drivers/fsl_dma.h ****  * data queue easily.
 300:../drivers/fsl_dma.h ****  *
 301:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 302:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 303:../drivers/fsl_dma.h ****  * @param srcModulo source address modulo.
 304:../drivers/fsl_dma.h ****  * @param destModulo destination address modulo.
 305:../drivers/fsl_dma.h ****  */
 306:../drivers/fsl_dma.h **** void DMA_SetModulo(DMA_Type *base, uint32_t channel, dma_modulo_t srcModulo, dma_modulo_t destModul
 307:../drivers/fsl_dma.h **** 
 308:../drivers/fsl_dma.h **** /*!
 309:../drivers/fsl_dma.h ****  * @brief Enables the DMA cycle steal for the DMA transfer.
 310:../drivers/fsl_dma.h ****  *
 311:../drivers/fsl_dma.h ****  * If the cycle steal feature is enabled (true), the DMA controller forces a single read/write tran
 312:../drivers/fsl_dma.h ****  *  or it continuously makes read/write transfers until the BCR decrements to 0.
 313:../drivers/fsl_dma.h ****  *
 314:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 315:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 316:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 317:../drivers/fsl_dma.h ****  */
 318:../drivers/fsl_dma.h **** static inline void DMA_EnableCycleSteal(DMA_Type *base, uint32_t channel, bool enable)
 319:../drivers/fsl_dma.h **** {
 320:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 321:../drivers/fsl_dma.h **** 
 322:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_CS_MASK)) | DMA_DCR_CS(enable);
 323:../drivers/fsl_dma.h **** }
 324:../drivers/fsl_dma.h **** 
 325:../drivers/fsl_dma.h **** /*!
 326:../drivers/fsl_dma.h ****  * @brief Enables the DMA auto align for the DMA transfer.
 327:../drivers/fsl_dma.h ****  *
 328:../drivers/fsl_dma.h ****  * If the auto align feature is enabled (true), the appropriate address register increments
 329:../drivers/fsl_dma.h ****  * regardless of DINC or SINC.
 330:../drivers/fsl_dma.h ****  *
 331:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 332:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 333:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 334:../drivers/fsl_dma.h ****  */
 335:../drivers/fsl_dma.h **** static inline void DMA_EnableAutoAlign(DMA_Type *base, uint32_t channel, bool enable)
 336:../drivers/fsl_dma.h **** {
 337:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 338:../drivers/fsl_dma.h **** 
 339:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_AA_MASK)) | DMA_DCR_AA(enable);
 340:../drivers/fsl_dma.h **** }
 341:../drivers/fsl_dma.h **** 
 342:../drivers/fsl_dma.h **** /*!
 343:../drivers/fsl_dma.h ****  * @brief Enables the DMA async request for the DMA transfer.
 344:../drivers/fsl_dma.h ****  *
 345:../drivers/fsl_dma.h ****  * If the async request feature is enabled (true), the DMA supports asynchronous DREQs
 346:../drivers/fsl_dma.h ****  * while the MCU is in stop mode.
 347:../drivers/fsl_dma.h ****  *
 348:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 349:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 350:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 351:../drivers/fsl_dma.h ****  */
 352:../drivers/fsl_dma.h **** static inline void DMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 353:../drivers/fsl_dma.h **** {
 354:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 355:../drivers/fsl_dma.h **** 
 356:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_EADREQ_MASK)) | DMA_DCR_EADREQ(ena
 357:../drivers/fsl_dma.h **** }
 358:../drivers/fsl_dma.h **** 
 359:../drivers/fsl_dma.h **** /*!
 360:../drivers/fsl_dma.h ****  * @brief Enables an interrupt for the DMA transfer.
 361:../drivers/fsl_dma.h ****  *
 362:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 363:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 364:../drivers/fsl_dma.h ****  */
 365:../drivers/fsl_dma.h **** static inline void DMA_EnableInterrupts(DMA_Type *base, uint32_t channel)
 366:../drivers/fsl_dma.h **** {
 367:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 368:../drivers/fsl_dma.h **** 
 369:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_EINT(true);
 370:../drivers/fsl_dma.h **** }
 371:../drivers/fsl_dma.h **** 
 372:../drivers/fsl_dma.h **** /*!
 373:../drivers/fsl_dma.h ****  * @brief Disables an interrupt for the DMA transfer.
 374:../drivers/fsl_dma.h ****  *
 375:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 376:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 377:../drivers/fsl_dma.h ****  */
 378:../drivers/fsl_dma.h **** static inline void DMA_DisableInterrupts(DMA_Type *base, uint32_t channel)
 379:../drivers/fsl_dma.h **** {
 380:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 381:../drivers/fsl_dma.h **** 
 382:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_EINT_MASK;
  62              		.loc 3 382 0
  63 0016 1201     		lsls	r2, r2, #4
  64              	.LVL5:
  65 0018 9B18     		adds	r3, r3, r2
  66              	.LVL6:
  67 001a 0D33     		adds	r3, r3, #13
  68 001c FF33     		adds	r3, r3, #255
  69 001e 1A68     		ldr	r2, [r3]
  70 0020 5200     		lsls	r2, r2, #1
  71 0022 5208     		lsrs	r2, r2, #1
  72 0024 1A60     		str	r2, [r3]
  73              	.LVL7:
  74              	.LBE37:
  75              	.LBE36:
 141:../drivers/fsl_uart_dma.c **** 
 142:../drivers/fsl_uart_dma.c ****     uartPrivateHandle->handle->txState = kUART_TxIdle;
  76              		.loc 1 142 0
  77 0026 0023     		movs	r3, #0
  78 0028 4A68     		ldr	r2, [r1, #4]
  79 002a 1377     		strb	r3, [r2, #28]
 143:../drivers/fsl_uart_dma.c **** 
 144:../drivers/fsl_uart_dma.c ****     if (uartPrivateHandle->handle->callback)
  80              		.loc 1 144 0
  81 002c 4C68     		ldr	r4, [r1, #4]
  82 002e 6568     		ldr	r5, [r4, #4]
  83 0030 002D     		cmp	r5, #0
  84 0032 04D0     		beq	.L1
 145:../drivers/fsl_uart_dma.c ****     {
 146:../drivers/fsl_uart_dma.c ****         uartPrivateHandle->handle->callback(uartPrivateHandle->base, uartPrivateHandle->handle, kSt
  85              		.loc 1 146 0
  86 0034 0868     		ldr	r0, [r1]
  87              	.LVL8:
  88 0036 A368     		ldr	r3, [r4, #8]
  89 0038 014A     		ldr	r2, .L3
  90 003a 2100     		movs	r1, r4
  91              	.LVL9:
  92 003c A847     		blx	r5
  93              	.LVL10:
  94              	.L1:
 147:../drivers/fsl_uart_dma.c ****                                             uartPrivateHandle->handle->userData);
 148:../drivers/fsl_uart_dma.c ****     }
 149:../drivers/fsl_uart_dma.c **** }
  95              		.loc 1 149 0
  96              		@ sp needed
  97 003e 70BD     		pop	{r4, r5, r6, pc}
  98              	.L4:
  99              		.align	2
 100              	.L3:
 101 0040 EA030000 		.word	1002
 102              		.cfi_endproc
 103              	.LFE76:
 105              		.section	.text.UART_TransferReceiveDMACallback,"ax",%progbits
 106              		.align	1
 107              		.syntax unified
 108              		.code	16
 109              		.thumb_func
 110              		.fpu softvfp
 112              	UART_TransferReceiveDMACallback:
 113              	.LFB77:
 150:../drivers/fsl_uart_dma.c **** 
 151:../drivers/fsl_uart_dma.c **** static void UART_TransferReceiveDMACallback(dma_handle_t *handle, void *param)
 152:../drivers/fsl_uart_dma.c **** {
 114              		.loc 1 152 0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 0
 117              		@ frame_needed = 0, uses_anonymous_args = 0
 118              	.LVL11:
 119 0000 70B5     		push	{r4, r5, r6, lr}
 120              		.cfi_def_cfa_offset 16
 121              		.cfi_offset 4, -16
 122              		.cfi_offset 5, -12
 123              		.cfi_offset 6, -8
 124              		.cfi_offset 14, -4
 125              	.LVL12:
 153:../drivers/fsl_uart_dma.c ****     assert(handle);
 154:../drivers/fsl_uart_dma.c ****     assert(param);
 155:../drivers/fsl_uart_dma.c **** 
 156:../drivers/fsl_uart_dma.c ****     uart_dma_private_handle_t *uartPrivateHandle = (uart_dma_private_handle_t *)param;
 157:../drivers/fsl_uart_dma.c **** 
 158:../drivers/fsl_uart_dma.c ****     /* Disable UART RX DMA. */
 159:../drivers/fsl_uart_dma.c ****     UART_EnableRxDMA(uartPrivateHandle->base, false);
 126              		.loc 1 159 0
 127 0002 0B68     		ldr	r3, [r1]
 128              	.LVL13:
 129              	.LBB38:
 130              	.LBB39:
 466:../drivers/fsl_uart.h ****     }
 467:../drivers/fsl_uart.h **** }
 468:../drivers/fsl_uart.h **** 
 469:../drivers/fsl_uart.h **** /*!
 470:../drivers/fsl_uart.h ****  * @brief Enables or disables the UART receiver DMA.
 471:../drivers/fsl_uart.h ****  *
 472:../drivers/fsl_uart.h ****  * This function enables or disables the receiver data register full flag, S1[RDRF], to generate DM
 473:../drivers/fsl_uart.h ****  *
 474:../drivers/fsl_uart.h ****  * @param base UART peripheral base address.
 475:../drivers/fsl_uart.h ****  * @param enable True to enable, false to disable.
 476:../drivers/fsl_uart.h ****  */
 477:../drivers/fsl_uart.h **** static inline void UART_EnableRxDMA(UART_Type *base, bool enable)
 478:../drivers/fsl_uart.h **** {
 479:../drivers/fsl_uart.h ****     if (enable)
 480:../drivers/fsl_uart.h ****     {
 481:../drivers/fsl_uart.h **** #if (defined(FSL_FEATURE_UART_IS_SCI) && FSL_FEATURE_UART_IS_SCI)
 482:../drivers/fsl_uart.h ****         base->C4 |= UART_C4_RDMAS_MASK;
 483:../drivers/fsl_uart.h **** #else
 484:../drivers/fsl_uart.h ****         base->C5 |= UART_C5_RDMAS_MASK;
 485:../drivers/fsl_uart.h **** #endif
 486:../drivers/fsl_uart.h ****         base->C2 |= UART_C2_RIE_MASK;
 487:../drivers/fsl_uart.h ****     }
 488:../drivers/fsl_uart.h ****     else
 489:../drivers/fsl_uart.h ****     {
 490:../drivers/fsl_uart.h **** #if (defined(FSL_FEATURE_UART_IS_SCI) && FSL_FEATURE_UART_IS_SCI)
 491:../drivers/fsl_uart.h ****         base->C4 &= ~UART_C4_RDMAS_MASK;
 492:../drivers/fsl_uart.h **** #else
 493:../drivers/fsl_uart.h ****         base->C5 &= ~UART_C5_RDMAS_MASK;
 131              		.loc 2 493 0
 132 0004 DA7A     		ldrb	r2, [r3, #11]
 133 0006 2024     		movs	r4, #32
 134 0008 A243     		bics	r2, r4
 135 000a DA72     		strb	r2, [r3, #11]
 494:../drivers/fsl_uart.h **** #endif
 495:../drivers/fsl_uart.h ****         base->C2 &= ~UART_C2_RIE_MASK;
 136              		.loc 2 495 0
 137 000c DA78     		ldrb	r2, [r3, #3]
 138 000e A243     		bics	r2, r4
 139 0010 DA70     		strb	r2, [r3, #3]
 140              	.LVL14:
 141              	.LBE39:
 142              	.LBE38:
 160:../drivers/fsl_uart_dma.c **** 
 161:../drivers/fsl_uart_dma.c ****     /* Disable interrupt. */
 162:../drivers/fsl_uart_dma.c ****     DMA_DisableInterrupts(handle->base, handle->channel);
 143              		.loc 1 162 0
 144 0012 0368     		ldr	r3, [r0]
 145 0014 0279     		ldrb	r2, [r0, #4]
 146              	.LVL15:
 147              	.LBB40:
 148              	.LBB41:
 149              		.loc 3 382 0
 150 0016 1201     		lsls	r2, r2, #4
 151              	.LVL16:
 152 0018 9B18     		adds	r3, r3, r2
 153              	.LVL17:
 154 001a 0D33     		adds	r3, r3, #13
 155 001c FF33     		adds	r3, r3, #255
 156 001e 1A68     		ldr	r2, [r3]
 157 0020 5200     		lsls	r2, r2, #1
 158 0022 5208     		lsrs	r2, r2, #1
 159 0024 1A60     		str	r2, [r3]
 160              	.LVL18:
 161              	.LBE41:
 162              	.LBE40:
 163:../drivers/fsl_uart_dma.c **** 
 164:../drivers/fsl_uart_dma.c ****     uartPrivateHandle->handle->rxState = kUART_RxIdle;
 163              		.loc 1 164 0
 164 0026 0223     		movs	r3, #2
 165 0028 4A68     		ldr	r2, [r1, #4]
 166 002a 5377     		strb	r3, [r2, #29]
 165:../drivers/fsl_uart_dma.c **** 
 166:../drivers/fsl_uart_dma.c ****     if (uartPrivateHandle->handle->callback)
 167              		.loc 1 166 0
 168 002c 4C68     		ldr	r4, [r1, #4]
 169 002e 6568     		ldr	r5, [r4, #4]
 170 0030 002D     		cmp	r5, #0
 171 0032 04D0     		beq	.L5
 167:../drivers/fsl_uart_dma.c ****     {
 168:../drivers/fsl_uart_dma.c ****         uartPrivateHandle->handle->callback(uartPrivateHandle->base, uartPrivateHandle->handle, kSt
 172              		.loc 1 168 0
 173 0034 0868     		ldr	r0, [r1]
 174              	.LVL19:
 175 0036 A368     		ldr	r3, [r4, #8]
 176 0038 014A     		ldr	r2, .L7
 177 003a 2100     		movs	r1, r4
 178              	.LVL20:
 179 003c A847     		blx	r5
 180              	.LVL21:
 181              	.L5:
 169:../drivers/fsl_uart_dma.c ****                                             uartPrivateHandle->handle->userData);
 170:../drivers/fsl_uart_dma.c ****     }
 171:../drivers/fsl_uart_dma.c **** }
 182              		.loc 1 171 0
 183              		@ sp needed
 184 003e 70BD     		pop	{r4, r5, r6, pc}
 185              	.L8:
 186              		.align	2
 187              	.L7:
 188 0040 EB030000 		.word	1003
 189              		.cfi_endproc
 190              	.LFE77:
 192              		.section	.text.UART_TransferCreateHandleDMA,"ax",%progbits
 193              		.align	1
 194              		.global	UART_TransferCreateHandleDMA
 195              		.syntax unified
 196              		.code	16
 197              		.thumb_func
 198              		.fpu softvfp
 200              	UART_TransferCreateHandleDMA:
 201              	.LFB78:
 172:../drivers/fsl_uart_dma.c **** 
 173:../drivers/fsl_uart_dma.c **** void UART_TransferCreateHandleDMA(UART_Type *base,
 174:../drivers/fsl_uart_dma.c ****                                   uart_dma_handle_t *handle,
 175:../drivers/fsl_uart_dma.c ****                                   uart_dma_transfer_callback_t callback,
 176:../drivers/fsl_uart_dma.c ****                                   void *userData,
 177:../drivers/fsl_uart_dma.c ****                                   dma_handle_t *txDmaHandle,
 178:../drivers/fsl_uart_dma.c ****                                   dma_handle_t *rxDmaHandle)
 179:../drivers/fsl_uart_dma.c **** {
 202              		.loc 1 179 0
 203              		.cfi_startproc
 204              		@ args = 8, pretend = 0, frame = 0
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              	.LVL22:
 207 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 208              		.cfi_def_cfa_offset 20
 209              		.cfi_offset 4, -20
 210              		.cfi_offset 5, -16
 211              		.cfi_offset 6, -12
 212              		.cfi_offset 7, -8
 213              		.cfi_offset 14, -4
 214 0002 D646     		mov	lr, r10
 215 0004 00B5     		push	{lr}
 216              		.cfi_def_cfa_offset 24
 217              		.cfi_offset 10, -24
 218 0006 0700     		movs	r7, r0
 219 0008 0C00     		movs	r4, r1
 220 000a 9246     		mov	r10, r2
 221 000c 1D00     		movs	r5, r3
 180:../drivers/fsl_uart_dma.c ****     assert(handle);
 181:../drivers/fsl_uart_dma.c **** 
 182:../drivers/fsl_uart_dma.c ****     uint32_t instance = UART_GetInstance(base);
 222              		.loc 1 182 0
 223 000e FFF7FEFF 		bl	UART_GetInstance
 224              	.LVL23:
 225 0012 0600     		movs	r6, r0
 226              	.LVL24:
 183:../drivers/fsl_uart_dma.c **** 
 184:../drivers/fsl_uart_dma.c ****     memset(handle, 0, sizeof(*handle));
 227              		.loc 1 184 0
 228 0014 2022     		movs	r2, #32
 229 0016 0021     		movs	r1, #0
 230 0018 2000     		movs	r0, r4
 231              	.LVL25:
 232 001a FFF7FEFF 		bl	memset
 233              	.LVL26:
 185:../drivers/fsl_uart_dma.c **** 
 186:../drivers/fsl_uart_dma.c ****     s_dmaPrivateHandle[instance].base = base;
 234              		.loc 1 186 0
 235 001e 134B     		ldr	r3, .L12
 236 0020 F200     		lsls	r2, r6, #3
 237 0022 D750     		str	r7, [r2, r3]
 187:../drivers/fsl_uart_dma.c ****     s_dmaPrivateHandle[instance].handle = handle;
 238              		.loc 1 187 0
 239 0024 9B18     		adds	r3, r3, r2
 240 0026 5C60     		str	r4, [r3, #4]
 188:../drivers/fsl_uart_dma.c **** 
 189:../drivers/fsl_uart_dma.c ****     handle->rxState = kUART_RxIdle;
 241              		.loc 1 189 0
 242 0028 0223     		movs	r3, #2
 243 002a 6377     		strb	r3, [r4, #29]
 190:../drivers/fsl_uart_dma.c ****     handle->txState = kUART_TxIdle;
 244              		.loc 1 190 0
 245 002c 0023     		movs	r3, #0
 246 002e 2377     		strb	r3, [r4, #28]
 191:../drivers/fsl_uart_dma.c **** 
 192:../drivers/fsl_uart_dma.c ****     handle->callback = callback;
 247              		.loc 1 192 0
 248 0030 5346     		mov	r3, r10
 249 0032 6360     		str	r3, [r4, #4]
 193:../drivers/fsl_uart_dma.c ****     handle->userData = userData;
 250              		.loc 1 193 0
 251 0034 A560     		str	r5, [r4, #8]
 194:../drivers/fsl_uart_dma.c **** 
 195:../drivers/fsl_uart_dma.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 196:../drivers/fsl_uart_dma.c ****     /* Note:
 197:../drivers/fsl_uart_dma.c ****        Take care of the RX FIFO, DMA request only assert when received bytes
 198:../drivers/fsl_uart_dma.c ****        equal or more than RX water mark, there is potential issue if RX water
 199:../drivers/fsl_uart_dma.c ****        mark larger than 1.
 200:../drivers/fsl_uart_dma.c ****        For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
 201:../drivers/fsl_uart_dma.c ****        5 bytes are received. the last byte will be saved in FIFO but not trigger
 202:../drivers/fsl_uart_dma.c ****        DMA transfer because the water mark is 2.
 203:../drivers/fsl_uart_dma.c ****      */
 204:../drivers/fsl_uart_dma.c ****     if (rxDmaHandle)
 205:../drivers/fsl_uart_dma.c ****     {
 206:../drivers/fsl_uart_dma.c ****         base->RWFIFO = 1U;
 207:../drivers/fsl_uart_dma.c ****     }
 208:../drivers/fsl_uart_dma.c **** #endif
 209:../drivers/fsl_uart_dma.c **** 
 210:../drivers/fsl_uart_dma.c ****     handle->rxDmaHandle = rxDmaHandle;
 252              		.loc 1 210 0
 253 0036 079B     		ldr	r3, [sp, #28]
 254 0038 A361     		str	r3, [r4, #24]
 211:../drivers/fsl_uart_dma.c ****     handle->txDmaHandle = txDmaHandle;
 255              		.loc 1 211 0
 256 003a 069B     		ldr	r3, [sp, #24]
 257 003c 6361     		str	r3, [r4, #20]
 212:../drivers/fsl_uart_dma.c **** 
 213:../drivers/fsl_uart_dma.c ****     /* Configure TX. */
 214:../drivers/fsl_uart_dma.c ****     if (txDmaHandle)
 258              		.loc 1 214 0
 259 003e 002B     		cmp	r3, #0
 260 0040 06D0     		beq	.L10
 215:../drivers/fsl_uart_dma.c ****     {
 216:../drivers/fsl_uart_dma.c ****         DMA_SetCallback(txDmaHandle, UART_TransferSendDMACallback, &s_dmaPrivateHandle[instance]);
 261              		.loc 1 216 0
 262 0042 1300     		movs	r3, r2
 263 0044 094A     		ldr	r2, .L12
 264 0046 D218     		adds	r2, r2, r3
 265 0048 0949     		ldr	r1, .L12+4
 266 004a 0698     		ldr	r0, [sp, #24]
 267 004c FFF7FEFF 		bl	DMA_SetCallback
 268              	.LVL27:
 269              	.L10:
 217:../drivers/fsl_uart_dma.c ****     }
 218:../drivers/fsl_uart_dma.c **** 
 219:../drivers/fsl_uart_dma.c ****     /* Configure RX. */
 220:../drivers/fsl_uart_dma.c ****     if (rxDmaHandle)
 270              		.loc 1 220 0
 271 0050 079B     		ldr	r3, [sp, #28]
 272 0052 002B     		cmp	r3, #0
 273 0054 06D0     		beq	.L9
 221:../drivers/fsl_uart_dma.c ****     {
 222:../drivers/fsl_uart_dma.c ****         DMA_SetCallback(rxDmaHandle, UART_TransferReceiveDMACallback, &s_dmaPrivateHandle[instance]
 274              		.loc 1 222 0
 275 0056 F200     		lsls	r2, r6, #3
 276 0058 044B     		ldr	r3, .L12
 277 005a 9A18     		adds	r2, r3, r2
 278 005c 0549     		ldr	r1, .L12+8
 279 005e 0798     		ldr	r0, [sp, #28]
 280 0060 FFF7FEFF 		bl	DMA_SetCallback
 281              	.LVL28:
 282              	.L9:
 223:../drivers/fsl_uart_dma.c ****     }
 224:../drivers/fsl_uart_dma.c **** }
 283              		.loc 1 224 0
 284              		@ sp needed
 285              	.LVL29:
 286              	.LVL30:
 287              	.LVL31:
 288              	.LVL32:
 289              	.LVL33:
 290 0064 04BC     		pop	{r2}
 291 0066 9246     		mov	r10, r2
 292 0068 F0BD     		pop	{r4, r5, r6, r7, pc}
 293              	.L13:
 294 006a C046     		.align	2
 295              	.L12:
 296 006c 00000000 		.word	.LANCHOR0
 297 0070 00000000 		.word	UART_TransferSendDMACallback
 298 0074 00000000 		.word	UART_TransferReceiveDMACallback
 299              		.cfi_endproc
 300              	.LFE78:
 302              		.section	.text.UART_TransferSendDMA,"ax",%progbits
 303              		.align	1
 304              		.global	UART_TransferSendDMA
 305              		.syntax unified
 306              		.code	16
 307              		.thumb_func
 308              		.fpu softvfp
 310              	UART_TransferSendDMA:
 311              	.LFB79:
 225:../drivers/fsl_uart_dma.c **** 
 226:../drivers/fsl_uart_dma.c **** status_t UART_TransferSendDMA(UART_Type *base, uart_dma_handle_t *handle, uart_transfer_t *xfer)
 227:../drivers/fsl_uart_dma.c **** {
 312              		.loc 1 227 0
 313              		.cfi_startproc
 314              		@ args = 0, pretend = 0, frame = 16
 315              		@ frame_needed = 0, uses_anonymous_args = 0
 316              	.LVL34:
 317 0000 30B5     		push	{r4, r5, lr}
 318              		.cfi_def_cfa_offset 12
 319              		.cfi_offset 4, -12
 320              		.cfi_offset 5, -8
 321              		.cfi_offset 14, -4
 322 0002 89B0     		sub	sp, sp, #36
 323              		.cfi_def_cfa_offset 48
 324 0004 0500     		movs	r5, r0
 325 0006 0C00     		movs	r4, r1
 228:../drivers/fsl_uart_dma.c ****     assert(handle);
 229:../drivers/fsl_uart_dma.c ****     assert(handle->txDmaHandle);
 230:../drivers/fsl_uart_dma.c ****     assert(xfer);
 231:../drivers/fsl_uart_dma.c ****     assert(xfer->data);
 232:../drivers/fsl_uart_dma.c ****     assert(xfer->dataSize);
 233:../drivers/fsl_uart_dma.c **** 
 234:../drivers/fsl_uart_dma.c ****     dma_transfer_config_t xferConfig;
 235:../drivers/fsl_uart_dma.c ****     status_t status;
 236:../drivers/fsl_uart_dma.c **** 
 237:../drivers/fsl_uart_dma.c ****     /* If previous TX not finished. */
 238:../drivers/fsl_uart_dma.c ****     if (kUART_TxBusy == handle->txState)
 326              		.loc 1 238 0
 327 0008 0B7F     		ldrb	r3, [r1, #28]
 328 000a 012B     		cmp	r3, #1
 329 000c 2CD0     		beq	.L16
 239:../drivers/fsl_uart_dma.c ****     {
 240:../drivers/fsl_uart_dma.c ****         status = kStatus_UART_TxBusy;
 241:../drivers/fsl_uart_dma.c ****     }
 242:../drivers/fsl_uart_dma.c ****     else
 243:../drivers/fsl_uart_dma.c ****     {
 244:../drivers/fsl_uart_dma.c ****         handle->txState = kUART_TxBusy;
 330              		.loc 1 244 0
 331 000e 0120     		movs	r0, #1
 332              	.LVL35:
 333 0010 0877     		strb	r0, [r1, #28]
 245:../drivers/fsl_uart_dma.c ****         handle->txDataSizeAll = xfer->dataSize;
 334              		.loc 1 245 0
 335 0012 5368     		ldr	r3, [r2, #4]
 336 0014 0B61     		str	r3, [r1, #16]
 246:../drivers/fsl_uart_dma.c **** 
 247:../drivers/fsl_uart_dma.c ****         /* Prepare transfer. */
 248:../drivers/fsl_uart_dma.c ****         DMA_PrepareTransfer(&xferConfig, xfer->data, sizeof(uint8_t), (void *)UART_GetDataRegisterA
 337              		.loc 1 248 0
 338 0016 1168     		ldr	r1, [r2]
 339              	.LVL36:
 340              	.LBB42:
 341              	.LBB43:
 436:../drivers/fsl_uart.h **** }
 342              		.loc 2 436 0
 343 0018 EB1D     		adds	r3, r5, #7
 344              	.LVL37:
 345              	.LBE43:
 346              	.LBE42:
 249:../drivers/fsl_uart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_MemoryToPeripheral);
 347              		.loc 1 249 0
 348 001a 5268     		ldr	r2, [r2, #4]
 349              	.LVL38:
 350 001c 0192     		str	r2, [sp, #4]
 248:../drivers/fsl_uart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_MemoryToPeripheral);
 351              		.loc 1 248 0
 352 001e 0222     		movs	r2, #2
 353 0020 0292     		str	r2, [sp, #8]
 354 0022 0090     		str	r0, [sp]
 355 0024 013A     		subs	r2, r2, #1
 356 0026 04A8     		add	r0, sp, #16
 357 0028 FFF7FEFF 		bl	DMA_PrepareTransfer
 358              	.LVL39:
 250:../drivers/fsl_uart_dma.c **** 
 251:../drivers/fsl_uart_dma.c ****         /* Submit transfer. */
 252:../drivers/fsl_uart_dma.c ****         DMA_SubmitTransfer(handle->txDmaHandle, &xferConfig, kDMA_EnableInterrupt);
 359              		.loc 1 252 0
 360 002c 0122     		movs	r2, #1
 361 002e 04A9     		add	r1, sp, #16
 362 0030 6069     		ldr	r0, [r4, #20]
 363 0032 FFF7FEFF 		bl	DMA_SubmitTransfer
 364              	.LVL40:
 253:../drivers/fsl_uart_dma.c ****         DMA_StartTransfer(handle->txDmaHandle);
 365              		.loc 1 253 0
 366 0036 6269     		ldr	r2, [r4, #20]
 367              	.LVL41:
 368              	.LBB44:
 369              	.LBB45:
 383:../drivers/fsl_dma.h **** }
 384:../drivers/fsl_dma.h **** 
 385:../drivers/fsl_dma.h **** /* @} */
 386:../drivers/fsl_dma.h **** /*!
 387:../drivers/fsl_dma.h ****  * @name DMA Channel Transfer Operation
 388:../drivers/fsl_dma.h ****  * @{
 389:../drivers/fsl_dma.h ****  */
 390:../drivers/fsl_dma.h **** 
 391:../drivers/fsl_dma.h **** /*!
 392:../drivers/fsl_dma.h ****  * @brief Enables the DMA hardware channel request.
 393:../drivers/fsl_dma.h ****  *
 394:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 395:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 396:../drivers/fsl_dma.h ****  */
 397:../drivers/fsl_dma.h **** static inline void DMA_EnableChannelRequest(DMA_Type *base, uint32_t channel)
 398:../drivers/fsl_dma.h **** {
 399:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 400:../drivers/fsl_dma.h **** 
 401:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_ERQ_MASK;
 402:../drivers/fsl_dma.h **** }
 403:../drivers/fsl_dma.h **** 
 404:../drivers/fsl_dma.h **** /*!
 405:../drivers/fsl_dma.h ****  * @brief Disables the DMA hardware channel request.
 406:../drivers/fsl_dma.h ****  *
 407:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 408:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 409:../drivers/fsl_dma.h ****  */
 410:../drivers/fsl_dma.h **** static inline void DMA_DisableChannelRequest(DMA_Type *base, uint32_t channel)
 411:../drivers/fsl_dma.h **** {
 412:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 413:../drivers/fsl_dma.h **** 
 414:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_ERQ_MASK;
 415:../drivers/fsl_dma.h **** }
 416:../drivers/fsl_dma.h **** 
 417:../drivers/fsl_dma.h **** /*!
 418:../drivers/fsl_dma.h ****  * @brief Starts the DMA transfer with a software trigger.
 419:../drivers/fsl_dma.h ****  *
 420:../drivers/fsl_dma.h ****  * This function starts only one read/write iteration.
 421:../drivers/fsl_dma.h ****  *
 422:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 423:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 424:../drivers/fsl_dma.h ****  */
 425:../drivers/fsl_dma.h **** static inline void DMA_TriggerChannelStart(DMA_Type *base, uint32_t channel)
 426:../drivers/fsl_dma.h **** {
 427:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 428:../drivers/fsl_dma.h **** 
 429:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_START_MASK;
 430:../drivers/fsl_dma.h **** }
 431:../drivers/fsl_dma.h **** 
 432:../drivers/fsl_dma.h **** /* @} */
 433:../drivers/fsl_dma.h **** /*!
 434:../drivers/fsl_dma.h ****  * @name DMA Channel Status Operation
 435:../drivers/fsl_dma.h ****  * @{
 436:../drivers/fsl_dma.h ****  */
 437:../drivers/fsl_dma.h **** 
 438:../drivers/fsl_dma.h **** /*!
 439:../drivers/fsl_dma.h ****  * @brief Gets the remaining bytes of the current DMA transfer.
 440:../drivers/fsl_dma.h ****  *
 441:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 442:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 443:../drivers/fsl_dma.h ****  * @return The number of bytes which have not been transferred yet.
 444:../drivers/fsl_dma.h ****  */
 445:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetRemainingBytes(DMA_Type *base, uint32_t channel)
 446:../drivers/fsl_dma.h **** {
 447:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 448:../drivers/fsl_dma.h **** 
 449:../drivers/fsl_dma.h ****     return (base->DMA[channel].DSR_BCR & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT;
 450:../drivers/fsl_dma.h **** }
 451:../drivers/fsl_dma.h **** 
 452:../drivers/fsl_dma.h **** /*!
 453:../drivers/fsl_dma.h ****  * @brief Gets the DMA channel status flags.
 454:../drivers/fsl_dma.h ****  *
 455:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 456:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 457:../drivers/fsl_dma.h ****  * @return The mask of the channel status. Use the _dma_channel_status_flags
 458:../drivers/fsl_dma.h ****  *         type to decode the return 32 bit variables.
 459:../drivers/fsl_dma.h ****  */
 460:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetChannelStatusFlags(DMA_Type *base, uint32_t channel)
 461:../drivers/fsl_dma.h **** {
 462:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 463:../drivers/fsl_dma.h **** 
 464:../drivers/fsl_dma.h ****     return base->DMA[channel].DSR_BCR;
 465:../drivers/fsl_dma.h **** }
 466:../drivers/fsl_dma.h **** 
 467:../drivers/fsl_dma.h **** /*!
 468:../drivers/fsl_dma.h ****  * @brief Clears the DMA channel status flags.
 469:../drivers/fsl_dma.h ****  *
 470:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 471:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 472:../drivers/fsl_dma.h ****  * @param mask The mask of the channel status to be cleared. Use
 473:../drivers/fsl_dma.h ****  *             the defined _dma_channel_status_flags type.
 474:../drivers/fsl_dma.h ****  */
 475:../drivers/fsl_dma.h **** static inline void DMA_ClearChannelStatusFlags(DMA_Type *base, uint32_t channel, uint32_t mask)
 476:../drivers/fsl_dma.h **** {
 477:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 478:../drivers/fsl_dma.h **** 
 479:../drivers/fsl_dma.h ****     if (mask != 0U)
 480:../drivers/fsl_dma.h ****     {
 481:../drivers/fsl_dma.h ****         base->DMA[channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 482:../drivers/fsl_dma.h ****     }
 483:../drivers/fsl_dma.h **** }
 484:../drivers/fsl_dma.h **** 
 485:../drivers/fsl_dma.h **** /* @} */
 486:../drivers/fsl_dma.h **** /*!
 487:../drivers/fsl_dma.h ****  * @name DMA Channel Transactional Operation
 488:../drivers/fsl_dma.h ****  * @{
 489:../drivers/fsl_dma.h ****  */
 490:../drivers/fsl_dma.h **** 
 491:../drivers/fsl_dma.h **** /*!
 492:../drivers/fsl_dma.h ****  * @brief Creates the DMA handle.
 493:../drivers/fsl_dma.h ****  *
 494:../drivers/fsl_dma.h ****  * This function is called first if using the transactional API for the DMA. This function
 495:../drivers/fsl_dma.h ****  * initializes the internal state of the DMA handle.
 496:../drivers/fsl_dma.h ****  *
 497:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer. The DMA handle stores callback function and
 498:../drivers/fsl_dma.h ****  *               parameters.
 499:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 500:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 501:../drivers/fsl_dma.h ****  */
 502:../drivers/fsl_dma.h **** void DMA_CreateHandle(dma_handle_t *handle, DMA_Type *base, uint32_t channel);
 503:../drivers/fsl_dma.h **** 
 504:../drivers/fsl_dma.h **** /*!
 505:../drivers/fsl_dma.h ****  * @brief Sets the DMA callback function.
 506:../drivers/fsl_dma.h ****  *
 507:../drivers/fsl_dma.h ****  * This callback is called in the DMA IRQ handler. Use the callback to do something
 508:../drivers/fsl_dma.h ****  * after the current transfer complete.
 509:../drivers/fsl_dma.h ****  *
 510:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 511:../drivers/fsl_dma.h ****  * @param callback DMA callback function pointer.
 512:../drivers/fsl_dma.h ****  * @param userData Parameter for callback function. If it is not needed, just set to NULL.
 513:../drivers/fsl_dma.h ****  */
 514:../drivers/fsl_dma.h **** void DMA_SetCallback(dma_handle_t *handle, dma_callback callback, void *userData);
 515:../drivers/fsl_dma.h **** 
 516:../drivers/fsl_dma.h **** /*!
 517:../drivers/fsl_dma.h ****  * @brief Prepares the DMA transfer configuration structure.
 518:../drivers/fsl_dma.h ****  *
 519:../drivers/fsl_dma.h ****  * This function prepares the transfer configuration structure according to the user input.
 520:../drivers/fsl_dma.h ****  *
 521:../drivers/fsl_dma.h ****  * @param config Pointer to the user configuration structure of type dma_transfer_config_t.
 522:../drivers/fsl_dma.h ****  * @param srcAddr DMA transfer source address.
 523:../drivers/fsl_dma.h ****  * @param srcWidth DMA transfer source address width (byte).
 524:../drivers/fsl_dma.h ****  * @param destAddr DMA transfer destination address.
 525:../drivers/fsl_dma.h ****  * @param destWidth DMA transfer destination address width (byte).
 526:../drivers/fsl_dma.h ****  * @param transferBytes DMA transfer bytes to be transferred.
 527:../drivers/fsl_dma.h ****  * @param type DMA transfer type.
 528:../drivers/fsl_dma.h ****  */
 529:../drivers/fsl_dma.h **** void DMA_PrepareTransfer(dma_transfer_config_t *config,
 530:../drivers/fsl_dma.h ****                          void *srcAddr,
 531:../drivers/fsl_dma.h ****                          uint32_t srcWidth,
 532:../drivers/fsl_dma.h ****                          void *destAddr,
 533:../drivers/fsl_dma.h ****                          uint32_t destWidth,
 534:../drivers/fsl_dma.h ****                          uint32_t transferBytes,
 535:../drivers/fsl_dma.h ****                          dma_transfer_type_t type);
 536:../drivers/fsl_dma.h **** 
 537:../drivers/fsl_dma.h **** /*!
 538:../drivers/fsl_dma.h ****  * @brief Submits the DMA transfer request.
 539:../drivers/fsl_dma.h ****  *
 540:../drivers/fsl_dma.h ****  * This function submits the DMA transfer request according to the transfer configuration structure
 541:../drivers/fsl_dma.h ****  *
 542:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 543:../drivers/fsl_dma.h ****  * @param config Pointer to DMA transfer configuration structure.
 544:../drivers/fsl_dma.h ****  * @param options Additional configurations for transfer. Use
 545:../drivers/fsl_dma.h ****  *                the defined dma_transfer_options_t type.
 546:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA submit transfer request succeeded.
 547:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA is busy. Submit transfer request is not allow
 548:../drivers/fsl_dma.h ****  * @note This function can't process multi transfer request.
 549:../drivers/fsl_dma.h ****  */
 550:../drivers/fsl_dma.h **** status_t DMA_SubmitTransfer(dma_handle_t *handle, const dma_transfer_config_t *config, uint32_t opt
 551:../drivers/fsl_dma.h **** 
 552:../drivers/fsl_dma.h **** /*!
 553:../drivers/fsl_dma.h ****  * @brief DMA starts a transfer.
 554:../drivers/fsl_dma.h ****  *
 555:../drivers/fsl_dma.h ****  * This function enables the channel request. Call this function
 556:../drivers/fsl_dma.h ****  * after submitting a transfer request.
 557:../drivers/fsl_dma.h ****  *
 558:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 559:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA start transfer succeed.
 560:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA has started a transfer.
 561:../drivers/fsl_dma.h ****  */
 562:../drivers/fsl_dma.h **** static inline void DMA_StartTransfer(dma_handle_t *handle)
 563:../drivers/fsl_dma.h **** {
 564:../drivers/fsl_dma.h ****     assert(handle != NULL);
 565:../drivers/fsl_dma.h **** 
 566:../drivers/fsl_dma.h ****     handle->base->DMA[handle->channel].DCR |= DMA_DCR_ERQ_MASK;
 370              		.loc 3 566 0
 371 0038 1368     		ldr	r3, [r2]
 372 003a 1279     		ldrb	r2, [r2, #4]
 373              	.LVL42:
 374 003c 1201     		lsls	r2, r2, #4
 375 003e 9B18     		adds	r3, r3, r2
 376 0040 0D33     		adds	r3, r3, #13
 377 0042 FF33     		adds	r3, r3, #255
 378 0044 1968     		ldr	r1, [r3]
 379 0046 8022     		movs	r2, #128
 380 0048 D205     		lsls	r2, r2, #23
 381 004a 0A43     		orrs	r2, r1
 382 004c 1A60     		str	r2, [r3]
 383              	.LVL43:
 384              	.LBE45:
 385              	.LBE44:
 386              	.LBB46:
 387              	.LBB47:
 454:../drivers/fsl_uart.h **** #endif
 388              		.loc 2 454 0
 389 004e EA7A     		ldrb	r2, [r5, #11]
 390 0050 8021     		movs	r1, #128
 391 0052 4942     		rsbs	r1, r1, #0
 392 0054 0A43     		orrs	r2, r1
 393 0056 D2B2     		uxtb	r2, r2
 394 0058 EA72     		strb	r2, [r5, #11]
 456:../drivers/fsl_uart.h ****     }
 395              		.loc 2 456 0
 396 005a EB78     		ldrb	r3, [r5, #3]
 397 005c 0B43     		orrs	r3, r1
 398 005e DBB2     		uxtb	r3, r3
 399 0060 EB70     		strb	r3, [r5, #3]
 400              	.LVL44:
 401              	.LBE47:
 402              	.LBE46:
 254:../drivers/fsl_uart_dma.c **** 
 255:../drivers/fsl_uart_dma.c ****         /* Enable UART TX DMA. */
 256:../drivers/fsl_uart_dma.c ****         UART_EnableTxDMA(base, true);
 257:../drivers/fsl_uart_dma.c **** 
 258:../drivers/fsl_uart_dma.c ****         status = kStatus_Success;
 403              		.loc 1 258 0
 404 0062 0020     		movs	r0, #0
 405              	.LVL45:
 406              	.L14:
 259:../drivers/fsl_uart_dma.c ****     }
 260:../drivers/fsl_uart_dma.c **** 
 261:../drivers/fsl_uart_dma.c ****     return status;
 262:../drivers/fsl_uart_dma.c **** }
 407              		.loc 1 262 0
 408 0064 09B0     		add	sp, sp, #36
 409              		@ sp needed
 410              	.LVL46:
 411              	.LVL47:
 412 0066 30BD     		pop	{r4, r5, pc}
 413              	.LVL48:
 414              	.L16:
 240:../drivers/fsl_uart_dma.c ****     }
 415              		.loc 1 240 0
 416 0068 FA20     		movs	r0, #250
 417              	.LVL49:
 418 006a 8000     		lsls	r0, r0, #2
 419              	.LVL50:
 261:../drivers/fsl_uart_dma.c **** }
 420              		.loc 1 261 0
 421 006c FAE7     		b	.L14
 422              		.cfi_endproc
 423              	.LFE79:
 425              		.section	.text.UART_TransferReceiveDMA,"ax",%progbits
 426              		.align	1
 427              		.global	UART_TransferReceiveDMA
 428              		.syntax unified
 429              		.code	16
 430              		.thumb_func
 431              		.fpu softvfp
 433              	UART_TransferReceiveDMA:
 434              	.LFB80:
 263:../drivers/fsl_uart_dma.c **** 
 264:../drivers/fsl_uart_dma.c **** status_t UART_TransferReceiveDMA(UART_Type *base, uart_dma_handle_t *handle, uart_transfer_t *xfer)
 265:../drivers/fsl_uart_dma.c **** {
 435              		.loc 1 265 0
 436              		.cfi_startproc
 437              		@ args = 0, pretend = 0, frame = 16
 438              		@ frame_needed = 0, uses_anonymous_args = 0
 439              	.LVL51:
 440 0000 30B5     		push	{r4, r5, lr}
 441              		.cfi_def_cfa_offset 12
 442              		.cfi_offset 4, -12
 443              		.cfi_offset 5, -8
 444              		.cfi_offset 14, -4
 445 0002 89B0     		sub	sp, sp, #36
 446              		.cfi_def_cfa_offset 48
 447 0004 0500     		movs	r5, r0
 448 0006 0C00     		movs	r4, r1
 266:../drivers/fsl_uart_dma.c ****     assert(handle);
 267:../drivers/fsl_uart_dma.c ****     assert(handle->rxDmaHandle);
 268:../drivers/fsl_uart_dma.c ****     assert(xfer);
 269:../drivers/fsl_uart_dma.c ****     assert(xfer->data);
 270:../drivers/fsl_uart_dma.c ****     assert(xfer->dataSize);
 271:../drivers/fsl_uart_dma.c **** 
 272:../drivers/fsl_uart_dma.c ****     dma_transfer_config_t xferConfig;
 273:../drivers/fsl_uart_dma.c ****     status_t status;
 274:../drivers/fsl_uart_dma.c **** 
 275:../drivers/fsl_uart_dma.c ****     /* If previous RX not finished. */
 276:../drivers/fsl_uart_dma.c ****     if (kUART_RxBusy == handle->rxState)
 449              		.loc 1 276 0
 450 0008 4B7F     		ldrb	r3, [r1, #29]
 451 000a 032B     		cmp	r3, #3
 452 000c 28D0     		beq	.L19
 277:../drivers/fsl_uart_dma.c ****     {
 278:../drivers/fsl_uart_dma.c ****         status = kStatus_UART_RxBusy;
 279:../drivers/fsl_uart_dma.c ****     }
 280:../drivers/fsl_uart_dma.c ****     else
 281:../drivers/fsl_uart_dma.c ****     {
 282:../drivers/fsl_uart_dma.c ****         handle->rxState = kUART_RxBusy;
 453              		.loc 1 282 0
 454 000e 0323     		movs	r3, #3
 455 0010 4B77     		strb	r3, [r1, #29]
 283:../drivers/fsl_uart_dma.c ****         handle->rxDataSizeAll = xfer->dataSize;
 456              		.loc 1 283 0
 457 0012 5368     		ldr	r3, [r2, #4]
 458 0014 CB60     		str	r3, [r1, #12]
 459              	.LVL52:
 460              	.LBB48:
 461              	.LBB49:
 436:../drivers/fsl_uart.h **** }
 462              		.loc 2 436 0
 463 0016 C11D     		adds	r1, r0, #7
 464              	.LVL53:
 465              	.LBE49:
 466              	.LBE48:
 284:../drivers/fsl_uart_dma.c **** 
 285:../drivers/fsl_uart_dma.c ****         /* Prepare transfer. */
 286:../drivers/fsl_uart_dma.c ****         DMA_PrepareTransfer(&xferConfig, (void *)UART_GetDataRegisterAddress(base), sizeof(uint8_t)
 467              		.loc 1 286 0
 468 0018 1368     		ldr	r3, [r2]
 287:../drivers/fsl_uart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_PeripheralToMemory);
 469              		.loc 1 287 0
 470 001a 5268     		ldr	r2, [r2, #4]
 471              	.LVL54:
 472 001c 0192     		str	r2, [sp, #4]
 286:../drivers/fsl_uart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_PeripheralToMemory);
 473              		.loc 1 286 0
 474 001e 0122     		movs	r2, #1
 475 0020 0292     		str	r2, [sp, #8]
 476 0022 0092     		str	r2, [sp]
 477 0024 04A8     		add	r0, sp, #16
 478              	.LVL55:
 479 0026 FFF7FEFF 		bl	DMA_PrepareTransfer
 480              	.LVL56:
 288:../drivers/fsl_uart_dma.c **** 
 289:../drivers/fsl_uart_dma.c ****         /* Submit transfer. */
 290:../drivers/fsl_uart_dma.c ****         DMA_SubmitTransfer(handle->rxDmaHandle, &xferConfig, kDMA_EnableInterrupt);
 481              		.loc 1 290 0
 482 002a 0122     		movs	r2, #1
 483 002c 04A9     		add	r1, sp, #16
 484 002e A069     		ldr	r0, [r4, #24]
 485 0030 FFF7FEFF 		bl	DMA_SubmitTransfer
 486              	.LVL57:
 291:../drivers/fsl_uart_dma.c ****         DMA_StartTransfer(handle->rxDmaHandle);
 487              		.loc 1 291 0
 488 0034 A269     		ldr	r2, [r4, #24]
 489              	.LVL58:
 490              	.LBB50:
 491              	.LBB51:
 492              		.loc 3 566 0
 493 0036 1368     		ldr	r3, [r2]
 494 0038 1279     		ldrb	r2, [r2, #4]
 495              	.LVL59:
 496 003a 1201     		lsls	r2, r2, #4
 497 003c 9B18     		adds	r3, r3, r2
 498 003e 0D33     		adds	r3, r3, #13
 499 0040 FF33     		adds	r3, r3, #255
 500 0042 1968     		ldr	r1, [r3]
 501 0044 8022     		movs	r2, #128
 502 0046 D205     		lsls	r2, r2, #23
 503 0048 0A43     		orrs	r2, r1
 504 004a 1A60     		str	r2, [r3]
 505              	.LVL60:
 506              	.LBE51:
 507              	.LBE50:
 508              	.LBB52:
 509              	.LBB53:
 484:../drivers/fsl_uart.h **** #endif
 510              		.loc 2 484 0
 511 004c EA7A     		ldrb	r2, [r5, #11]
 512 004e 2021     		movs	r1, #32
 513 0050 0A43     		orrs	r2, r1
 514 0052 EA72     		strb	r2, [r5, #11]
 486:../drivers/fsl_uart.h ****     }
 515              		.loc 2 486 0
 516 0054 EB78     		ldrb	r3, [r5, #3]
 517 0056 0B43     		orrs	r3, r1
 518 0058 EB70     		strb	r3, [r5, #3]
 519              	.LVL61:
 520              	.LBE53:
 521              	.LBE52:
 292:../drivers/fsl_uart_dma.c **** 
 293:../drivers/fsl_uart_dma.c ****         /* Enable UART RX DMA. */
 294:../drivers/fsl_uart_dma.c ****         UART_EnableRxDMA(base, true);
 295:../drivers/fsl_uart_dma.c **** 
 296:../drivers/fsl_uart_dma.c ****         status = kStatus_Success;
 522              		.loc 1 296 0
 523 005a 0020     		movs	r0, #0
 524              	.LVL62:
 525              	.L17:
 297:../drivers/fsl_uart_dma.c ****     }
 298:../drivers/fsl_uart_dma.c **** 
 299:../drivers/fsl_uart_dma.c ****     return status;
 300:../drivers/fsl_uart_dma.c **** }
 526              		.loc 1 300 0
 527 005c 09B0     		add	sp, sp, #36
 528              		@ sp needed
 529              	.LVL63:
 530              	.LVL64:
 531 005e 30BD     		pop	{r4, r5, pc}
 532              	.LVL65:
 533              	.L19:
 278:../drivers/fsl_uart_dma.c ****     }
 534              		.loc 1 278 0
 535 0060 0048     		ldr	r0, .L20
 536              	.LVL66:
 299:../drivers/fsl_uart_dma.c **** }
 537              		.loc 1 299 0
 538 0062 FBE7     		b	.L17
 539              	.L21:
 540              		.align	2
 541              	.L20:
 542 0064 E9030000 		.word	1001
 543              		.cfi_endproc
 544              	.LFE80:
 546              		.section	.text.UART_TransferAbortSendDMA,"ax",%progbits
 547              		.align	1
 548              		.global	UART_TransferAbortSendDMA
 549              		.syntax unified
 550              		.code	16
 551              		.thumb_func
 552              		.fpu softvfp
 554              	UART_TransferAbortSendDMA:
 555              	.LFB81:
 301:../drivers/fsl_uart_dma.c **** 
 302:../drivers/fsl_uart_dma.c **** void UART_TransferAbortSendDMA(UART_Type *base, uart_dma_handle_t *handle)
 303:../drivers/fsl_uart_dma.c **** {
 556              		.loc 1 303 0
 557              		.cfi_startproc
 558              		@ args = 0, pretend = 0, frame = 0
 559              		@ frame_needed = 0, uses_anonymous_args = 0
 560              	.LVL67:
 561 0000 10B5     		push	{r4, lr}
 562              		.cfi_def_cfa_offset 8
 563              		.cfi_offset 4, -8
 564              		.cfi_offset 14, -4
 565 0002 0C00     		movs	r4, r1
 566              	.LVL68:
 567              	.LBB54:
 568              	.LBB55:
 463:../drivers/fsl_uart.h **** #endif
 569              		.loc 2 463 0
 570 0004 C27A     		ldrb	r2, [r0, #11]
 571 0006 7F21     		movs	r1, #127
 572              	.LVL69:
 573 0008 0A40     		ands	r2, r1
 574 000a C272     		strb	r2, [r0, #11]
 465:../drivers/fsl_uart.h ****     }
 575              		.loc 2 465 0
 576 000c C378     		ldrb	r3, [r0, #3]
 577 000e 0B40     		ands	r3, r1
 578 0010 C370     		strb	r3, [r0, #3]
 579              	.LVL70:
 580              	.LBE55:
 581              	.LBE54:
 304:../drivers/fsl_uart_dma.c ****     assert(handle);
 305:../drivers/fsl_uart_dma.c ****     assert(handle->txDmaHandle);
 306:../drivers/fsl_uart_dma.c **** 
 307:../drivers/fsl_uart_dma.c ****     /* Disable UART TX DMA. */
 308:../drivers/fsl_uart_dma.c ****     UART_EnableTxDMA(base, false);
 309:../drivers/fsl_uart_dma.c **** 
 310:../drivers/fsl_uart_dma.c ****     /* Stop transfer. */
 311:../drivers/fsl_uart_dma.c ****     DMA_AbortTransfer(handle->txDmaHandle);
 582              		.loc 1 311 0
 583 0012 6069     		ldr	r0, [r4, #20]
 584              	.LVL71:
 585 0014 FFF7FEFF 		bl	DMA_AbortTransfer
 586              	.LVL72:
 312:../drivers/fsl_uart_dma.c **** 
 313:../drivers/fsl_uart_dma.c ****     /* Write DMA->DSR[DONE] to abort transfer and clear status. */
 314:../drivers/fsl_uart_dma.c ****     DMA_ClearChannelStatusFlags(handle->txDmaHandle->base, handle->txDmaHandle->channel, kDMA_Trans
 587              		.loc 1 314 0
 588 0018 6269     		ldr	r2, [r4, #20]
 589 001a 1368     		ldr	r3, [r2]
 590 001c 1279     		ldrb	r2, [r2, #4]
 591              	.LVL73:
 592              	.LBB56:
 593              	.LBB57:
 481:../drivers/fsl_dma.h ****     }
 594              		.loc 3 481 0
 595 001e 1201     		lsls	r2, r2, #4
 596              	.LVL74:
 597 0020 9B18     		adds	r3, r3, r2
 598              	.LVL75:
 599 0022 0933     		adds	r3, r3, #9
 600 0024 FF33     		adds	r3, r3, #255
 601 0026 1968     		ldr	r1, [r3]
 602 0028 8022     		movs	r2, #128
 603 002a 5204     		lsls	r2, r2, #17
 604 002c 0A43     		orrs	r2, r1
 605 002e 1A60     		str	r2, [r3]
 606              	.LVL76:
 607              	.LBE57:
 608              	.LBE56:
 315:../drivers/fsl_uart_dma.c **** 
 316:../drivers/fsl_uart_dma.c ****     handle->txState = kUART_TxIdle;
 609              		.loc 1 316 0
 610 0030 0023     		movs	r3, #0
 611 0032 2377     		strb	r3, [r4, #28]
 317:../drivers/fsl_uart_dma.c **** }
 612              		.loc 1 317 0
 613              		@ sp needed
 614              	.LVL77:
 615 0034 10BD     		pop	{r4, pc}
 616              		.cfi_endproc
 617              	.LFE81:
 619              		.section	.text.UART_TransferAbortReceiveDMA,"ax",%progbits
 620              		.align	1
 621              		.global	UART_TransferAbortReceiveDMA
 622              		.syntax unified
 623              		.code	16
 624              		.thumb_func
 625              		.fpu softvfp
 627              	UART_TransferAbortReceiveDMA:
 628              	.LFB82:
 318:../drivers/fsl_uart_dma.c **** 
 319:../drivers/fsl_uart_dma.c **** void UART_TransferAbortReceiveDMA(UART_Type *base, uart_dma_handle_t *handle)
 320:../drivers/fsl_uart_dma.c **** {
 629              		.loc 1 320 0
 630              		.cfi_startproc
 631              		@ args = 0, pretend = 0, frame = 0
 632              		@ frame_needed = 0, uses_anonymous_args = 0
 633              	.LVL78:
 634 0000 10B5     		push	{r4, lr}
 635              		.cfi_def_cfa_offset 8
 636              		.cfi_offset 4, -8
 637              		.cfi_offset 14, -4
 638 0002 0C00     		movs	r4, r1
 639              	.LVL79:
 640              	.LBB58:
 641              	.LBB59:
 493:../drivers/fsl_uart.h **** #endif
 642              		.loc 2 493 0
 643 0004 C37A     		ldrb	r3, [r0, #11]
 644 0006 2022     		movs	r2, #32
 645 0008 9343     		bics	r3, r2
 646 000a C372     		strb	r3, [r0, #11]
 647              		.loc 2 495 0
 648 000c C378     		ldrb	r3, [r0, #3]
 649 000e 9343     		bics	r3, r2
 650 0010 C370     		strb	r3, [r0, #3]
 651              	.LVL80:
 652              	.LBE59:
 653              	.LBE58:
 321:../drivers/fsl_uart_dma.c ****     assert(handle);
 322:../drivers/fsl_uart_dma.c ****     assert(handle->rxDmaHandle);
 323:../drivers/fsl_uart_dma.c **** 
 324:../drivers/fsl_uart_dma.c ****     /* Disable UART RX DMA. */
 325:../drivers/fsl_uart_dma.c ****     UART_EnableRxDMA(base, false);
 326:../drivers/fsl_uart_dma.c **** 
 327:../drivers/fsl_uart_dma.c ****     /* Stop transfer. */
 328:../drivers/fsl_uart_dma.c ****     DMA_AbortTransfer(handle->rxDmaHandle);
 654              		.loc 1 328 0
 655 0012 8869     		ldr	r0, [r1, #24]
 656              	.LVL81:
 657 0014 FFF7FEFF 		bl	DMA_AbortTransfer
 658              	.LVL82:
 329:../drivers/fsl_uart_dma.c **** 
 330:../drivers/fsl_uart_dma.c ****     /* Write DMA->DSR[DONE] to abort transfer and clear status. */
 331:../drivers/fsl_uart_dma.c ****     DMA_ClearChannelStatusFlags(handle->rxDmaHandle->base, handle->rxDmaHandle->channel, kDMA_Trans
 659              		.loc 1 331 0
 660 0018 A269     		ldr	r2, [r4, #24]
 661 001a 1368     		ldr	r3, [r2]
 662 001c 1279     		ldrb	r2, [r2, #4]
 663              	.LVL83:
 664              	.LBB60:
 665              	.LBB61:
 481:../drivers/fsl_dma.h ****     }
 666              		.loc 3 481 0
 667 001e 1201     		lsls	r2, r2, #4
 668              	.LVL84:
 669 0020 9B18     		adds	r3, r3, r2
 670              	.LVL85:
 671 0022 0933     		adds	r3, r3, #9
 672 0024 FF33     		adds	r3, r3, #255
 673 0026 1968     		ldr	r1, [r3]
 674 0028 8022     		movs	r2, #128
 675 002a 5204     		lsls	r2, r2, #17
 676 002c 0A43     		orrs	r2, r1
 677 002e 1A60     		str	r2, [r3]
 678              	.LVL86:
 679              	.LBE61:
 680              	.LBE60:
 332:../drivers/fsl_uart_dma.c **** 
 333:../drivers/fsl_uart_dma.c ****     handle->rxState = kUART_RxIdle;
 681              		.loc 1 333 0
 682 0030 0223     		movs	r3, #2
 683 0032 6377     		strb	r3, [r4, #29]
 334:../drivers/fsl_uart_dma.c **** }
 684              		.loc 1 334 0
 685              		@ sp needed
 686              	.LVL87:
 687 0034 10BD     		pop	{r4, pc}
 688              		.cfi_endproc
 689              	.LFE82:
 691              		.section	.text.UART_TransferGetSendCountDMA,"ax",%progbits
 692              		.align	1
 693              		.global	UART_TransferGetSendCountDMA
 694              		.syntax unified
 695              		.code	16
 696              		.thumb_func
 697              		.fpu softvfp
 699              	UART_TransferGetSendCountDMA:
 700              	.LFB83:
 335:../drivers/fsl_uart_dma.c **** 
 336:../drivers/fsl_uart_dma.c **** status_t UART_TransferGetSendCountDMA(UART_Type *base, uart_dma_handle_t *handle, uint32_t *count)
 337:../drivers/fsl_uart_dma.c **** {
 701              		.loc 1 337 0
 702              		.cfi_startproc
 703              		@ args = 0, pretend = 0, frame = 0
 704              		@ frame_needed = 0, uses_anonymous_args = 0
 705              		@ link register save eliminated.
 706              	.LVL88:
 338:../drivers/fsl_uart_dma.c ****     assert(handle);
 339:../drivers/fsl_uart_dma.c ****     assert(handle->txDmaHandle);
 340:../drivers/fsl_uart_dma.c ****     assert(count);
 341:../drivers/fsl_uart_dma.c **** 
 342:../drivers/fsl_uart_dma.c ****     if (kUART_TxIdle == handle->txState)
 707              		.loc 1 342 0
 708 0000 0B7F     		ldrb	r3, [r1, #28]
 709 0002 002B     		cmp	r3, #0
 710 0004 0ED0     		beq	.L26
 343:../drivers/fsl_uart_dma.c ****     {
 344:../drivers/fsl_uart_dma.c ****         return kStatus_NoTransferInProgress;
 345:../drivers/fsl_uart_dma.c ****     }
 346:../drivers/fsl_uart_dma.c **** 
 347:../drivers/fsl_uart_dma.c ****     *count = handle->txDataSizeAll - DMA_GetRemainingBytes(handle->txDmaHandle->base, handle->txDma
 711              		.loc 1 347 0
 712 0006 0869     		ldr	r0, [r1, #16]
 713              	.LVL89:
 714 0008 4B69     		ldr	r3, [r1, #20]
 715 000a 1968     		ldr	r1, [r3]
 716              	.LVL90:
 717 000c 1B79     		ldrb	r3, [r3, #4]
 718              	.LVL91:
 719              	.LBB62:
 720              	.LBB63:
 449:../drivers/fsl_dma.h **** }
 721              		.loc 3 449 0
 722 000e 1B01     		lsls	r3, r3, #4
 723              	.LVL92:
 724 0010 C918     		adds	r1, r1, r3
 725              	.LVL93:
 726 0012 0931     		adds	r1, r1, #9
 727 0014 FF31     		adds	r1, r1, #255
 728 0016 0B68     		ldr	r3, [r1]
 729 0018 1B02     		lsls	r3, r3, #8
 730 001a 1B0A     		lsrs	r3, r3, #8
 731              	.LVL94:
 732              	.LBE63:
 733              	.LBE62:
 734              		.loc 1 347 0
 735 001c C31A     		subs	r3, r0, r3
 736 001e 1360     		str	r3, [r2]
 348:../drivers/fsl_uart_dma.c **** 
 349:../drivers/fsl_uart_dma.c ****     return kStatus_Success;
 737              		.loc 1 349 0
 738 0020 0020     		movs	r0, #0
 739              	.L24:
 350:../drivers/fsl_uart_dma.c **** }
 740              		.loc 1 350 0
 741              		@ sp needed
 742 0022 7047     		bx	lr
 743              	.LVL95:
 744              	.L26:
 344:../drivers/fsl_uart_dma.c ****     }
 745              		.loc 1 344 0
 746 0024 0620     		movs	r0, #6
 747              	.LVL96:
 748 0026 FCE7     		b	.L24
 749              		.cfi_endproc
 750              	.LFE83:
 752              		.section	.text.UART_TransferGetReceiveCountDMA,"ax",%progbits
 753              		.align	1
 754              		.global	UART_TransferGetReceiveCountDMA
 755              		.syntax unified
 756              		.code	16
 757              		.thumb_func
 758              		.fpu softvfp
 760              	UART_TransferGetReceiveCountDMA:
 761              	.LFB84:
 351:../drivers/fsl_uart_dma.c **** 
 352:../drivers/fsl_uart_dma.c **** status_t UART_TransferGetReceiveCountDMA(UART_Type *base, uart_dma_handle_t *handle, uint32_t *coun
 353:../drivers/fsl_uart_dma.c **** {
 762              		.loc 1 353 0
 763              		.cfi_startproc
 764              		@ args = 0, pretend = 0, frame = 0
 765              		@ frame_needed = 0, uses_anonymous_args = 0
 766              		@ link register save eliminated.
 767              	.LVL97:
 354:../drivers/fsl_uart_dma.c ****     assert(handle);
 355:../drivers/fsl_uart_dma.c ****     assert(handle->rxDmaHandle);
 356:../drivers/fsl_uart_dma.c ****     assert(count);
 357:../drivers/fsl_uart_dma.c **** 
 358:../drivers/fsl_uart_dma.c ****     if (kUART_RxIdle == handle->rxState)
 768              		.loc 1 358 0
 769 0000 4B7F     		ldrb	r3, [r1, #29]
 770 0002 022B     		cmp	r3, #2
 771 0004 0ED0     		beq	.L29
 359:../drivers/fsl_uart_dma.c ****     {
 360:../drivers/fsl_uart_dma.c ****         return kStatus_NoTransferInProgress;
 361:../drivers/fsl_uart_dma.c ****     }
 362:../drivers/fsl_uart_dma.c **** 
 363:../drivers/fsl_uart_dma.c ****     *count = handle->rxDataSizeAll - DMA_GetRemainingBytes(handle->rxDmaHandle->base, handle->rxDma
 772              		.loc 1 363 0
 773 0006 C868     		ldr	r0, [r1, #12]
 774              	.LVL98:
 775 0008 8B69     		ldr	r3, [r1, #24]
 776 000a 1968     		ldr	r1, [r3]
 777              	.LVL99:
 778 000c 1B79     		ldrb	r3, [r3, #4]
 779              	.LVL100:
 780              	.LBB64:
 781              	.LBB65:
 449:../drivers/fsl_dma.h **** }
 782              		.loc 3 449 0
 783 000e 1B01     		lsls	r3, r3, #4
 784              	.LVL101:
 785 0010 C918     		adds	r1, r1, r3
 786              	.LVL102:
 787 0012 0931     		adds	r1, r1, #9
 788 0014 FF31     		adds	r1, r1, #255
 789 0016 0B68     		ldr	r3, [r1]
 790 0018 1B02     		lsls	r3, r3, #8
 791 001a 1B0A     		lsrs	r3, r3, #8
 792              	.LVL103:
 793              	.LBE65:
 794              	.LBE64:
 795              		.loc 1 363 0
 796 001c C31A     		subs	r3, r0, r3
 797 001e 1360     		str	r3, [r2]
 364:../drivers/fsl_uart_dma.c **** 
 365:../drivers/fsl_uart_dma.c ****     return kStatus_Success;
 798              		.loc 1 365 0
 799 0020 0020     		movs	r0, #0
 800              	.L27:
 366:../drivers/fsl_uart_dma.c **** }
 801              		.loc 1 366 0
 802              		@ sp needed
 803 0022 7047     		bx	lr
 804              	.LVL104:
 805              	.L29:
 360:../drivers/fsl_uart_dma.c ****     }
 806              		.loc 1 360 0
 807 0024 0620     		movs	r0, #6
 808              	.LVL105:
 809 0026 FCE7     		b	.L27
 810              		.cfi_endproc
 811              	.LFE84:
 813              		.section	.bss.s_dmaPrivateHandle,"aw",%nobits
 814              		.align	2
 815              		.set	.LANCHOR0,. + 0
 818              	s_dmaPrivateHandle:
 819 0000 00000000 		.space	24
 819      00000000 
 819      00000000 
 819      00000000 
 819      00000000 
 820              		.text
 821              	.Letext0:
 822              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 823              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 824              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 825              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 826              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 827              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 828              		.file 10 "../CMSIS/system_MKL17Z4.h"
 829              		.file 11 "../CMSIS/MKL17Z4.h"
 830              		.file 12 "../drivers/fsl_common.h"
 831              		.file 13 "../drivers/fsl_clock.h"
 832              		.file 14 "../drivers/fsl_uart_dma.h"
 833              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_uart_dma.c
     /tmp/ccAsaaj4.s:16     .text.UART_TransferSendDMACallback:0000000000000000 $t
     /tmp/ccAsaaj4.s:22     .text.UART_TransferSendDMACallback:0000000000000000 UART_TransferSendDMACallback
     /tmp/ccAsaaj4.s:101    .text.UART_TransferSendDMACallback:0000000000000040 $d
     /tmp/ccAsaaj4.s:106    .text.UART_TransferReceiveDMACallback:0000000000000000 $t
     /tmp/ccAsaaj4.s:112    .text.UART_TransferReceiveDMACallback:0000000000000000 UART_TransferReceiveDMACallback
     /tmp/ccAsaaj4.s:188    .text.UART_TransferReceiveDMACallback:0000000000000040 $d
     /tmp/ccAsaaj4.s:193    .text.UART_TransferCreateHandleDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:200    .text.UART_TransferCreateHandleDMA:0000000000000000 UART_TransferCreateHandleDMA
     /tmp/ccAsaaj4.s:296    .text.UART_TransferCreateHandleDMA:000000000000006c $d
     /tmp/ccAsaaj4.s:303    .text.UART_TransferSendDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:310    .text.UART_TransferSendDMA:0000000000000000 UART_TransferSendDMA
     /tmp/ccAsaaj4.s:426    .text.UART_TransferReceiveDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:433    .text.UART_TransferReceiveDMA:0000000000000000 UART_TransferReceiveDMA
     /tmp/ccAsaaj4.s:542    .text.UART_TransferReceiveDMA:0000000000000064 $d
     /tmp/ccAsaaj4.s:547    .text.UART_TransferAbortSendDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:554    .text.UART_TransferAbortSendDMA:0000000000000000 UART_TransferAbortSendDMA
     /tmp/ccAsaaj4.s:620    .text.UART_TransferAbortReceiveDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:627    .text.UART_TransferAbortReceiveDMA:0000000000000000 UART_TransferAbortReceiveDMA
     /tmp/ccAsaaj4.s:692    .text.UART_TransferGetSendCountDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:699    .text.UART_TransferGetSendCountDMA:0000000000000000 UART_TransferGetSendCountDMA
     /tmp/ccAsaaj4.s:753    .text.UART_TransferGetReceiveCountDMA:0000000000000000 $t
     /tmp/ccAsaaj4.s:760    .text.UART_TransferGetReceiveCountDMA:0000000000000000 UART_TransferGetReceiveCountDMA
     /tmp/ccAsaaj4.s:814    .bss.s_dmaPrivateHandle:0000000000000000 $d
     /tmp/ccAsaaj4.s:818    .bss.s_dmaPrivateHandle:0000000000000000 s_dmaPrivateHandle

UNDEFINED SYMBOLS
UART_GetInstance
memset
DMA_SetCallback
DMA_PrepareTransfer
DMA_SubmitTransfer
DMA_AbortTransfer
