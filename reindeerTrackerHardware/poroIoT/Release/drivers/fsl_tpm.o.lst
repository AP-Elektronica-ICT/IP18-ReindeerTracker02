   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_tpm.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.TPM_GetInstance,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	TPM_GetInstance:
  23              	.LFB59:
  24              		.file 1 "../drivers/fsl_tpm.c"
   1:../drivers/fsl_tpm.c **** /*
   2:../drivers/fsl_tpm.c ****  * The Clear BSD License
   3:../drivers/fsl_tpm.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_tpm.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_tpm.c ****  * All rights reserved.
   6:../drivers/fsl_tpm.c ****  *
   7:../drivers/fsl_tpm.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_tpm.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_tpm.c ****  * that the following conditions are met:
  10:../drivers/fsl_tpm.c ****  *
  11:../drivers/fsl_tpm.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_tpm.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_tpm.c ****  *
  14:../drivers/fsl_tpm.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_tpm.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_tpm.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_tpm.c ****  *
  18:../drivers/fsl_tpm.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_tpm.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_tpm.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_tpm.c ****  *
  22:../drivers/fsl_tpm.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_tpm.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_tpm.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_tpm.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_tpm.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_tpm.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_tpm.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_tpm.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_tpm.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_tpm.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_tpm.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_tpm.c ****  */
  34:../drivers/fsl_tpm.c **** 
  35:../drivers/fsl_tpm.c **** #include "fsl_tpm.h"
  36:../drivers/fsl_tpm.c **** 
  37:../drivers/fsl_tpm.c **** /*******************************************************************************
  38:../drivers/fsl_tpm.c ****  * Definitions
  39:../drivers/fsl_tpm.c ****  ******************************************************************************/
  40:../drivers/fsl_tpm.c **** #define TPM_COMBINE_SHIFT (8U)
  41:../drivers/fsl_tpm.c **** 
  42:../drivers/fsl_tpm.c **** /*******************************************************************************
  43:../drivers/fsl_tpm.c ****  * Prototypes
  44:../drivers/fsl_tpm.c ****  ******************************************************************************/
  45:../drivers/fsl_tpm.c **** /*!
  46:../drivers/fsl_tpm.c ****  * @brief Gets the instance from the base address
  47:../drivers/fsl_tpm.c ****  *
  48:../drivers/fsl_tpm.c ****  * @param base TPM peripheral base address
  49:../drivers/fsl_tpm.c ****  *
  50:../drivers/fsl_tpm.c ****  * @return The TPM instance
  51:../drivers/fsl_tpm.c ****  */
  52:../drivers/fsl_tpm.c **** static uint32_t TPM_GetInstance(TPM_Type *base);
  53:../drivers/fsl_tpm.c **** 
  54:../drivers/fsl_tpm.c **** /*******************************************************************************
  55:../drivers/fsl_tpm.c ****  * Variables
  56:../drivers/fsl_tpm.c ****  ******************************************************************************/
  57:../drivers/fsl_tpm.c **** /*! @brief Pointers to TPM bases for each instance. */
  58:../drivers/fsl_tpm.c **** static TPM_Type *const s_tpmBases[] = TPM_BASE_PTRS;
  59:../drivers/fsl_tpm.c **** 
  60:../drivers/fsl_tpm.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  61:../drivers/fsl_tpm.c **** /*! @brief Pointers to TPM clocks for each instance. */
  62:../drivers/fsl_tpm.c **** static const clock_ip_name_t s_tpmClocks[] = TPM_CLOCKS;
  63:../drivers/fsl_tpm.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  64:../drivers/fsl_tpm.c **** 
  65:../drivers/fsl_tpm.c **** /*******************************************************************************
  66:../drivers/fsl_tpm.c ****  * Code
  67:../drivers/fsl_tpm.c ****  ******************************************************************************/
  68:../drivers/fsl_tpm.c **** static uint32_t TPM_GetInstance(TPM_Type *base)
  69:../drivers/fsl_tpm.c **** {
  25              		.loc 1 69 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
  70:../drivers/fsl_tpm.c ****     uint32_t instance;
  71:../drivers/fsl_tpm.c ****     uint32_t tpmArrayCount = (sizeof(s_tpmBases) / sizeof(s_tpmBases[0]));
  72:../drivers/fsl_tpm.c **** 
  73:../drivers/fsl_tpm.c ****     /* Find the instance index from base address mappings. */
  74:../drivers/fsl_tpm.c ****     for (instance = 0; instance < tpmArrayCount; instance++)
  31              		.loc 1 74 0
  32 0000 0023     		movs	r3, #0
  33              	.LVL1:
  34              	.L2:
  35              		.loc 1 74 0 is_stmt 0 discriminator 1
  36 0002 022B     		cmp	r3, #2
  37 0004 06D8     		bhi	.L1
  75:../drivers/fsl_tpm.c ****     {
  76:../drivers/fsl_tpm.c ****         if (s_tpmBases[instance] == base)
  38              		.loc 1 76 0 is_stmt 1
  39 0006 9A00     		lsls	r2, r3, #2
  40 0008 0349     		ldr	r1, .L5
  41 000a 5258     		ldr	r2, [r2, r1]
  42 000c 8242     		cmp	r2, r0
  43 000e 01D0     		beq	.L1
  74:../drivers/fsl_tpm.c ****     {
  44              		.loc 1 74 0 discriminator 2
  45 0010 0133     		adds	r3, r3, #1
  46              	.LVL2:
  47 0012 F6E7     		b	.L2
  48              	.L1:
  77:../drivers/fsl_tpm.c ****         {
  78:../drivers/fsl_tpm.c ****             break;
  79:../drivers/fsl_tpm.c ****         }
  80:../drivers/fsl_tpm.c ****     }
  81:../drivers/fsl_tpm.c **** 
  82:../drivers/fsl_tpm.c ****     assert(instance < tpmArrayCount);
  83:../drivers/fsl_tpm.c **** 
  84:../drivers/fsl_tpm.c ****     return instance;
  85:../drivers/fsl_tpm.c **** }
  49              		.loc 1 85 0
  50 0014 1800     		movs	r0, r3
  51              	.LVL3:
  52              		@ sp needed
  53 0016 7047     		bx	lr
  54              	.L6:
  55              		.align	2
  56              	.L5:
  57 0018 00000000 		.word	.LANCHOR0
  58              		.cfi_endproc
  59              	.LFE59:
  61              		.section	.text.TPM_Init,"ax",%progbits
  62              		.align	1
  63              		.global	TPM_Init
  64              		.syntax unified
  65              		.code	16
  66              		.thumb_func
  67              		.fpu softvfp
  69              	TPM_Init:
  70              	.LFB60:
  86:../drivers/fsl_tpm.c **** 
  87:../drivers/fsl_tpm.c **** void TPM_Init(TPM_Type *base, const tpm_config_t *config)
  88:../drivers/fsl_tpm.c **** {
  71              		.loc 1 88 0
  72              		.cfi_startproc
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              	.LVL4:
  76 0000 70B5     		push	{r4, r5, r6, lr}
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82 0002 0500     		movs	r5, r0
  83 0004 0C00     		movs	r4, r1
  89:../drivers/fsl_tpm.c ****     assert(config);
  90:../drivers/fsl_tpm.c **** 
  91:../drivers/fsl_tpm.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  92:../drivers/fsl_tpm.c ****     /* Enable the module clock */
  93:../drivers/fsl_tpm.c ****     CLOCK_EnableClock(s_tpmClocks[TPM_GetInstance(base)]);
  84              		.loc 1 93 0
  85 0006 FFF7FEFF 		bl	TPM_GetInstance
  86              	.LVL5:
  87 000a 8000     		lsls	r0, r0, #2
  88 000c 274B     		ldr	r3, .L11
  89 000e C358     		ldr	r3, [r0, r3]
  90              	.LVL6:
  91              	.LBB6:
  92              	.LBB7:
  93              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  94              		.loc 2 449 0
  95 0010 1A0C     		lsrs	r2, r3, #16
  96 0012 2749     		ldr	r1, .L11+4
  97 0014 8C46     		mov	ip, r1
  98 0016 6244     		add	r2, r2, ip
  99              	.LVL7:
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 100              		.loc 2 450 0
 101 0018 1168     		ldr	r1, [r2]
 102 001a 1B04     		lsls	r3, r3, #16
 103              	.LVL8:
 104 001c 1B0C     		lsrs	r3, r3, #16
 105 001e 0120     		movs	r0, #1
 106              	.LVL9:
 107 0020 9840     		lsls	r0, r0, r3
 108 0022 0300     		movs	r3, r0
 109 0024 0B43     		orrs	r3, r1
 110 0026 1360     		str	r3, [r2]
 111              	.LVL10:
 112              	.LBE7:
 113              	.LBE6:
  94:../drivers/fsl_tpm.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  95:../drivers/fsl_tpm.c **** 
  96:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_GLOBAL) && FSL_FEATURE_TPM_HAS_GLOBAL
  97:../drivers/fsl_tpm.c ****     /* TPM reset is available on certain SoC's */
  98:../drivers/fsl_tpm.c ****     TPM_Reset(base);
  99:../drivers/fsl_tpm.c **** #endif
 100:../drivers/fsl_tpm.c **** 
 101:../drivers/fsl_tpm.c ****     /* Set the clock prescale factor */
 102:../drivers/fsl_tpm.c ****     base->SC = TPM_SC_PS(config->prescale);
 114              		.loc 1 102 0
 115 0028 2278     		ldrb	r2, [r4]
 116 002a 0723     		movs	r3, #7
 117 002c 1340     		ands	r3, r2
 118 002e 2B60     		str	r3, [r5]
 103:../drivers/fsl_tpm.c **** #if !(defined(FSL_FEATURE_TPM_HAS_NO_CONF) && FSL_FEATURE_TPM_HAS_NO_CONF)
 104:../drivers/fsl_tpm.c ****     /* Setup the counter operation */
 105:../drivers/fsl_tpm.c ****     base->CONF = TPM_CONF_DOZEEN(config->enableDoze) | TPM_CONF_GTBEEN(config->useGlobalTimeBase) |
 119              		.loc 1 105 0
 120 0030 2279     		ldrb	r2, [r4, #4]
 121 0032 5201     		lsls	r2, r2, #5
 122 0034 2023     		movs	r3, #32
 123 0036 1340     		ands	r3, r2
 124 0038 6278     		ldrb	r2, [r4, #1]
 125 003a 5202     		lsls	r2, r2, #9
 126 003c 8021     		movs	r1, #128
 127 003e 8900     		lsls	r1, r1, #2
 128 0040 0A40     		ands	r2, r1
 129 0042 1343     		orrs	r3, r2
 106:../drivers/fsl_tpm.c ****                  TPM_CONF_CROT(config->enableReloadOnTrigger) | TPM_CONF_CSOT(config->enableStartOn
 130              		.loc 1 106 0
 131 0044 A279     		ldrb	r2, [r4, #6]
 132 0046 9204     		lsls	r2, r2, #18
 133 0048 8021     		movs	r1, #128
 134 004a C902     		lsls	r1, r1, #11
 135 004c 0A40     		ands	r2, r1
 105:../drivers/fsl_tpm.c ****                  TPM_CONF_CROT(config->enableReloadOnTrigger) | TPM_CONF_CSOT(config->enableStartOn
 136              		.loc 1 105 0
 137 004e 1343     		orrs	r3, r2
 138              		.loc 1 106 0
 139 0050 227A     		ldrb	r2, [r4, #8]
 140 0052 1204     		lsls	r2, r2, #16
 141 0054 8021     		movs	r1, #128
 142 0056 4902     		lsls	r1, r1, #9
 143 0058 0A40     		ands	r2, r1
 144 005a 1343     		orrs	r3, r2
 107:../drivers/fsl_tpm.c ****                  TPM_CONF_CSOO(config->enableStopOnOverflow) |
 145              		.loc 1 107 0
 146 005c E279     		ldrb	r2, [r4, #7]
 147 005e 5204     		lsls	r2, r2, #17
 148 0060 8021     		movs	r1, #128
 149 0062 8902     		lsls	r1, r1, #10
 150 0064 0A40     		ands	r2, r1
 106:../drivers/fsl_tpm.c ****                  TPM_CONF_CROT(config->enableReloadOnTrigger) | TPM_CONF_CSOT(config->enableStartOn
 151              		.loc 1 106 0
 152 0066 1343     		orrs	r3, r2
 108:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_PAUSE_COUNTER_ON_TRIGGER) && FSL_FEATURE_TPM_HAS_PAUSE_COUNTER_ON_T
 109:../drivers/fsl_tpm.c ****                  TPM_CONF_CPOT(config->enablePauseOnTrigger) |
 153              		.loc 1 109 0
 154 0068 627A     		ldrb	r2, [r4, #9]
 155 006a D204     		lsls	r2, r2, #19
 156 006c 8021     		movs	r1, #128
 157 006e 0903     		lsls	r1, r1, #12
 158 0070 0A40     		ands	r2, r1
 107:../drivers/fsl_tpm.c ****                  TPM_CONF_CSOO(config->enableStopOnOverflow) |
 159              		.loc 1 107 0
 160 0072 1343     		orrs	r3, r2
 110:../drivers/fsl_tpm.c **** #endif
 111:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_EXTERNAL_TRIGGER_SELECTION) && FSL_FEATURE_TPM_HAS_EXTERNAL_TRIGGER
 112:../drivers/fsl_tpm.c ****                  TPM_CONF_TRGSRC(config->triggerSource) |
 161              		.loc 1 112 0
 162 0074 E278     		ldrb	r2, [r4, #3]
 163 0076 D205     		lsls	r2, r2, #23
 164 0078 8021     		movs	r1, #128
 165 007a 0904     		lsls	r1, r1, #16
 166 007c 0A40     		ands	r2, r1
 109:../drivers/fsl_tpm.c **** #endif
 167              		.loc 1 109 0
 168 007e 1343     		orrs	r3, r2
 113:../drivers/fsl_tpm.c **** #endif
 114:../drivers/fsl_tpm.c ****                  TPM_CONF_TRGSEL(config->triggerSelect);
 169              		.loc 1 114 0
 170 0080 A278     		ldrb	r2, [r4, #2]
 171 0082 1206     		lsls	r2, r2, #24
 172 0084 F021     		movs	r1, #240
 173 0086 0905     		lsls	r1, r1, #20
 174 0088 0A40     		ands	r2, r1
 112:../drivers/fsl_tpm.c **** #endif
 175              		.loc 1 112 0
 176 008a 1343     		orrs	r3, r2
 105:../drivers/fsl_tpm.c ****                  TPM_CONF_CROT(config->enableReloadOnTrigger) | TPM_CONF_CSOT(config->enableStartOn
 177              		.loc 1 105 0
 178 008c 8422     		movs	r2, #132
 179 008e AB50     		str	r3, [r5, r2]
 115:../drivers/fsl_tpm.c ****     if (config->enableDebugMode)
 180              		.loc 1 115 0
 181 0090 6379     		ldrb	r3, [r4, #5]
 182 0092 002B     		cmp	r3, #0
 183 0094 05D1     		bne	.L10
 116:../drivers/fsl_tpm.c ****     {
 117:../drivers/fsl_tpm.c ****         base->CONF |= TPM_CONF_DBGMODE_MASK;
 118:../drivers/fsl_tpm.c ****     }
 119:../drivers/fsl_tpm.c ****     else
 120:../drivers/fsl_tpm.c ****     {
 121:../drivers/fsl_tpm.c ****         base->CONF &= ~TPM_CONF_DBGMODE_MASK;
 184              		.loc 1 121 0
 185 0096 8422     		movs	r2, #132
 186 0098 AB58     		ldr	r3, [r5, r2]
 187 009a C021     		movs	r1, #192
 188 009c 8B43     		bics	r3, r1
 189 009e AB50     		str	r3, [r5, r2]
 190              	.L7:
 122:../drivers/fsl_tpm.c ****     }
 123:../drivers/fsl_tpm.c **** #endif
 124:../drivers/fsl_tpm.c **** }
 191              		.loc 1 124 0
 192              		@ sp needed
 193              	.LVL11:
 194              	.LVL12:
 195 00a0 70BD     		pop	{r4, r5, r6, pc}
 196              	.LVL13:
 197              	.L10:
 117:../drivers/fsl_tpm.c ****     }
 198              		.loc 1 117 0
 199 00a2 AB58     		ldr	r3, [r5, r2]
 200 00a4 C021     		movs	r1, #192
 201 00a6 0B43     		orrs	r3, r1
 202 00a8 AB50     		str	r3, [r5, r2]
 203 00aa F9E7     		b	.L7
 204              	.L12:
 205              		.align	2
 206              	.L11:
 207 00ac 00000000 		.word	.LANCHOR1
 208 00b0 00700440 		.word	1074032640
 209              		.cfi_endproc
 210              	.LFE60:
 212              		.section	.text.TPM_Deinit,"ax",%progbits
 213              		.align	1
 214              		.global	TPM_Deinit
 215              		.syntax unified
 216              		.code	16
 217              		.thumb_func
 218              		.fpu softvfp
 220              	TPM_Deinit:
 221              	.LFB61:
 125:../drivers/fsl_tpm.c **** 
 126:../drivers/fsl_tpm.c **** void TPM_Deinit(TPM_Type *base)
 127:../drivers/fsl_tpm.c **** {
 222              		.loc 1 127 0
 223              		.cfi_startproc
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              	.LVL14:
 227 0000 10B5     		push	{r4, lr}
 228              		.cfi_def_cfa_offset 8
 229              		.cfi_offset 4, -8
 230              		.cfi_offset 14, -4
 128:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_SC_CLKS) && FSL_FEATURE_TPM_HAS_SC_CLKS
 129:../drivers/fsl_tpm.c ****     /* Stop the counter */
 130:../drivers/fsl_tpm.c ****     base->SC &= ~TPM_SC_CLKS_MASK;
 131:../drivers/fsl_tpm.c **** #else
 132:../drivers/fsl_tpm.c ****     /* Stop the counter */
 133:../drivers/fsl_tpm.c ****     base->SC &= ~TPM_SC_CMOD_MASK;
 231              		.loc 1 133 0
 232 0002 0368     		ldr	r3, [r0]
 233 0004 1822     		movs	r2, #24
 234 0006 9343     		bics	r3, r2
 235 0008 0360     		str	r3, [r0]
 134:../drivers/fsl_tpm.c **** #endif 
 135:../drivers/fsl_tpm.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 136:../drivers/fsl_tpm.c ****     /* Gate the TPM clock */
 137:../drivers/fsl_tpm.c ****     CLOCK_DisableClock(s_tpmClocks[TPM_GetInstance(base)]);
 236              		.loc 1 137 0
 237 000a FFF7FEFF 		bl	TPM_GetInstance
 238              	.LVL15:
 239 000e 8000     		lsls	r0, r0, #2
 240 0010 064B     		ldr	r3, .L14
 241 0012 C358     		ldr	r3, [r0, r3]
 242              	.LVL16:
 243              	.LBB8:
 244              	.LBB9:
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 245              		.loc 2 460 0
 246 0014 1A0C     		lsrs	r2, r3, #16
 247 0016 0649     		ldr	r1, .L14+4
 248 0018 8C46     		mov	ip, r1
 249 001a 6244     		add	r2, r2, ip
 250              	.LVL17:
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 251              		.loc 2 461 0
 252 001c 1168     		ldr	r1, [r2]
 253 001e 1B04     		lsls	r3, r3, #16
 254              	.LVL18:
 255 0020 1B0C     		lsrs	r3, r3, #16
 256 0022 0120     		movs	r0, #1
 257              	.LVL19:
 258 0024 9840     		lsls	r0, r0, r3
 259 0026 8143     		bics	r1, r0
 260 0028 1160     		str	r1, [r2]
 261              	.LVL20:
 262              	.LBE9:
 263              	.LBE8:
 138:../drivers/fsl_tpm.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 139:../drivers/fsl_tpm.c **** }
 264              		.loc 1 139 0
 265              		@ sp needed
 266 002a 10BD     		pop	{r4, pc}
 267              	.L15:
 268              		.align	2
 269              	.L14:
 270 002c 00000000 		.word	.LANCHOR1
 271 0030 00700440 		.word	1074032640
 272              		.cfi_endproc
 273              	.LFE61:
 275              		.section	.text.TPM_GetDefaultConfig,"ax",%progbits
 276              		.align	1
 277              		.global	TPM_GetDefaultConfig
 278              		.syntax unified
 279              		.code	16
 280              		.thumb_func
 281              		.fpu softvfp
 283              	TPM_GetDefaultConfig:
 284              	.LFB62:
 140:../drivers/fsl_tpm.c **** 
 141:../drivers/fsl_tpm.c **** void TPM_GetDefaultConfig(tpm_config_t *config)
 142:../drivers/fsl_tpm.c **** {
 285              		.loc 1 142 0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 0
 288              		@ frame_needed = 0, uses_anonymous_args = 0
 289              		@ link register save eliminated.
 290              	.LVL21:
 143:../drivers/fsl_tpm.c ****     assert(config);
 144:../drivers/fsl_tpm.c **** 
 145:../drivers/fsl_tpm.c ****     /* TPM clock divide by 1 */
 146:../drivers/fsl_tpm.c ****     config->prescale = kTPM_Prescale_Divide_1;
 291              		.loc 1 146 0
 292 0000 0023     		movs	r3, #0
 293 0002 0370     		strb	r3, [r0]
 147:../drivers/fsl_tpm.c **** #if !(defined(FSL_FEATURE_TPM_HAS_NO_CONF) && FSL_FEATURE_TPM_HAS_NO_CONF)
 148:../drivers/fsl_tpm.c ****     /* Use internal TPM counter as timebase */
 149:../drivers/fsl_tpm.c ****     config->useGlobalTimeBase = false;
 294              		.loc 1 149 0
 295 0004 4370     		strb	r3, [r0, #1]
 150:../drivers/fsl_tpm.c ****     /* TPM counter continues in doze mode */
 151:../drivers/fsl_tpm.c ****     config->enableDoze = false;
 296              		.loc 1 151 0
 297 0006 0371     		strb	r3, [r0, #4]
 152:../drivers/fsl_tpm.c ****     /* TPM counter pauses when in debug mode */
 153:../drivers/fsl_tpm.c ****     config->enableDebugMode = false;
 298              		.loc 1 153 0
 299 0008 4371     		strb	r3, [r0, #5]
 154:../drivers/fsl_tpm.c ****     /* TPM counter will not be reloaded on input trigger */
 155:../drivers/fsl_tpm.c ****     config->enableReloadOnTrigger = false;
 300              		.loc 1 155 0
 301 000a 8371     		strb	r3, [r0, #6]
 156:../drivers/fsl_tpm.c ****     /* TPM counter continues running after overflow */
 157:../drivers/fsl_tpm.c ****     config->enableStopOnOverflow = false;
 302              		.loc 1 157 0
 303 000c C371     		strb	r3, [r0, #7]
 158:../drivers/fsl_tpm.c ****     /* TPM counter starts immediately once it is enabled */
 159:../drivers/fsl_tpm.c ****     config->enableStartOnTrigger = false;
 304              		.loc 1 159 0
 305 000e 0372     		strb	r3, [r0, #8]
 160:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_PAUSE_COUNTER_ON_TRIGGER) && FSL_FEATURE_TPM_HAS_PAUSE_COUNTER_ON_T
 161:../drivers/fsl_tpm.c ****     config->enablePauseOnTrigger = false;
 306              		.loc 1 161 0
 307 0010 4372     		strb	r3, [r0, #9]
 162:../drivers/fsl_tpm.c **** #endif
 163:../drivers/fsl_tpm.c ****     /* Choose trigger select 0 as input trigger for controlling counter operation */
 164:../drivers/fsl_tpm.c ****     config->triggerSelect = kTPM_Trigger_Select_0;
 308              		.loc 1 164 0
 309 0012 8370     		strb	r3, [r0, #2]
 165:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_EXTERNAL_TRIGGER_SELECTION) && FSL_FEATURE_TPM_HAS_EXTERNAL_TRIGGER
 166:../drivers/fsl_tpm.c ****     /* Choose external trigger source to control counter operation */
 167:../drivers/fsl_tpm.c ****     config->triggerSource = kTPM_TriggerSource_External;
 310              		.loc 1 167 0
 311 0014 C370     		strb	r3, [r0, #3]
 168:../drivers/fsl_tpm.c **** #endif
 169:../drivers/fsl_tpm.c **** #endif
 170:../drivers/fsl_tpm.c **** }
 312              		.loc 1 170 0
 313              		@ sp needed
 314 0016 7047     		bx	lr
 315              		.cfi_endproc
 316              	.LFE62:
 318              		.global	__aeabi_uidiv
 319              		.section	.text.TPM_SetupPwm,"ax",%progbits
 320              		.align	1
 321              		.global	TPM_SetupPwm
 322              		.syntax unified
 323              		.code	16
 324              		.thumb_func
 325              		.fpu softvfp
 327              	TPM_SetupPwm:
 328              	.LFB63:
 171:../drivers/fsl_tpm.c **** 
 172:../drivers/fsl_tpm.c **** status_t TPM_SetupPwm(TPM_Type *base,
 173:../drivers/fsl_tpm.c ****                       const tpm_chnl_pwm_signal_param_t *chnlParams,
 174:../drivers/fsl_tpm.c ****                       uint8_t numOfChnls,
 175:../drivers/fsl_tpm.c ****                       tpm_pwm_mode_t mode,
 176:../drivers/fsl_tpm.c ****                       uint32_t pwmFreq_Hz,
 177:../drivers/fsl_tpm.c ****                       uint32_t srcClock_Hz)
 178:../drivers/fsl_tpm.c **** {
 329              		.loc 1 178 0
 330              		.cfi_startproc
 331              		@ args = 8, pretend = 0, frame = 0
 332              		@ frame_needed = 0, uses_anonymous_args = 0
 333              	.LVL22:
 334 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 335              		.cfi_def_cfa_offset 20
 336              		.cfi_offset 4, -20
 337              		.cfi_offset 5, -16
 338              		.cfi_offset 6, -12
 339              		.cfi_offset 7, -8
 340              		.cfi_offset 14, -4
 341 0002 C646     		mov	lr, r8
 342 0004 00B5     		push	{lr}
 343              		.cfi_def_cfa_offset 24
 344              		.cfi_offset 8, -24
 345 0006 0500     		movs	r5, r0
 346 0008 0C00     		movs	r4, r1
 347 000a 9046     		mov	r8, r2
 179:../drivers/fsl_tpm.c ****     assert(chnlParams);
 180:../drivers/fsl_tpm.c ****     assert(pwmFreq_Hz);
 181:../drivers/fsl_tpm.c ****     assert(numOfChnls);
 182:../drivers/fsl_tpm.c ****     assert(srcClock_Hz);
 183:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 184:../drivers/fsl_tpm.c ****     if(mode == kTPM_CombinedPwm)
 185:../drivers/fsl_tpm.c ****     {
 186:../drivers/fsl_tpm.c ****         assert(FSL_FEATURE_TPM_COMBINE_HAS_EFFECTn(base));
 187:../drivers/fsl_tpm.c ****     }
 188:../drivers/fsl_tpm.c **** #endif
 189:../drivers/fsl_tpm.c **** 
 190:../drivers/fsl_tpm.c ****     uint32_t mod;
 191:../drivers/fsl_tpm.c ****     uint32_t tpmClock = (srcClock_Hz / (1U << (base->SC & TPM_SC_PS_MASK)));
 348              		.loc 1 191 0
 349 000c 0168     		ldr	r1, [r0]
 350              	.LVL23:
 351 000e 0722     		movs	r2, #7
 352              	.LVL24:
 353 0010 0A40     		ands	r2, r1
 354 0012 0798     		ldr	r0, [sp, #28]
 355              	.LVL25:
 356 0014 D040     		lsrs	r0, r0, r2
 357              	.LVL26:
 192:../drivers/fsl_tpm.c ****     uint16_t cnv;
 193:../drivers/fsl_tpm.c ****     uint8_t i;
 194:../drivers/fsl_tpm.c **** 
 195:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_QDCTRL) && FSL_FEATURE_TPM_HAS_QDCTRL
 196:../drivers/fsl_tpm.c ****     /* The TPM's QDCTRL register required to be effective */
 197:../drivers/fsl_tpm.c ****     if( FSL_FEATURE_TPM_QDCTRL_HAS_EFFECTn(base) )
 198:../drivers/fsl_tpm.c ****     {
 199:../drivers/fsl_tpm.c ****         /* Clear quadrature Decoder mode because in quadrature Decoder mode PWM doesn't operate*/
 200:../drivers/fsl_tpm.c ****         base->QDCTRL &= ~TPM_QDCTRL_QUADEN_MASK;
 201:../drivers/fsl_tpm.c ****     }
 202:../drivers/fsl_tpm.c **** #endif
 203:../drivers/fsl_tpm.c **** 
 204:../drivers/fsl_tpm.c ****     switch (mode)
 358              		.loc 1 204 0
 359 0016 002B     		cmp	r3, #0
 360 0018 05D0     		beq	.L19
 361 001a 012B     		cmp	r3, #1
 362 001c 11D0     		beq	.L20
 205:../drivers/fsl_tpm.c ****     {
 206:../drivers/fsl_tpm.c ****         case kTPM_EdgeAlignedPwm:
 207:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 208:../drivers/fsl_tpm.c ****         case kTPM_CombinedPwm:
 209:../drivers/fsl_tpm.c **** #endif
 210:../drivers/fsl_tpm.c ****             base->SC &= ~TPM_SC_CPWMS_MASK;
 211:../drivers/fsl_tpm.c ****             mod = (tpmClock / pwmFreq_Hz) - 1;
 212:../drivers/fsl_tpm.c ****             break;
 213:../drivers/fsl_tpm.c ****         case kTPM_CenterAlignedPwm:
 214:../drivers/fsl_tpm.c ****             base->SC |= TPM_SC_CPWMS_MASK;
 215:../drivers/fsl_tpm.c ****             mod = tpmClock / (pwmFreq_Hz * 2);
 216:../drivers/fsl_tpm.c ****             break;
 217:../drivers/fsl_tpm.c ****         default:
 218:../drivers/fsl_tpm.c ****             return kStatus_Fail;
 363              		.loc 1 218 0
 364 001e 0120     		movs	r0, #1
 365              	.LVL27:
 366              	.L17:
 219:../drivers/fsl_tpm.c ****     }
 220:../drivers/fsl_tpm.c **** 
 221:../drivers/fsl_tpm.c ****     /* Return an error in case we overflow the registers, probably would require changing
 222:../drivers/fsl_tpm.c ****      * clock source to get the desired frequency */
 223:../drivers/fsl_tpm.c ****     if (mod > 65535U)
 224:../drivers/fsl_tpm.c ****     {
 225:../drivers/fsl_tpm.c ****         return kStatus_Fail;
 226:../drivers/fsl_tpm.c ****     }
 227:../drivers/fsl_tpm.c ****     /* Set the PWM period */
 228:../drivers/fsl_tpm.c ****     base->MOD = mod;
 229:../drivers/fsl_tpm.c **** 
 230:../drivers/fsl_tpm.c ****     /* Setup each TPM channel */
 231:../drivers/fsl_tpm.c ****     for (i = 0; i < numOfChnls; i++)
 232:../drivers/fsl_tpm.c ****     {
 233:../drivers/fsl_tpm.c ****         /* Return error if requested dutycycle is greater than the max allowed */
 234:../drivers/fsl_tpm.c ****         if (chnlParams->dutyCyclePercent > 100)
 235:../drivers/fsl_tpm.c ****         {
 236:../drivers/fsl_tpm.c ****             return kStatus_Fail;
 237:../drivers/fsl_tpm.c ****         }
 238:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 239:../drivers/fsl_tpm.c ****         if (mode == kTPM_CombinedPwm)
 240:../drivers/fsl_tpm.c ****         {
 241:../drivers/fsl_tpm.c ****             uint16_t cnvFirstEdge;
 242:../drivers/fsl_tpm.c **** 
 243:../drivers/fsl_tpm.c ****             /* This check is added for combined mode as the channel number should be the pair numbe
 244:../drivers/fsl_tpm.c ****             if (chnlParams->chnlNumber >= (FSL_FEATURE_TPM_CHANNEL_COUNTn(base) / 2))
 245:../drivers/fsl_tpm.c ****             {
 246:../drivers/fsl_tpm.c ****                 return kStatus_Fail;
 247:../drivers/fsl_tpm.c ****             }
 248:../drivers/fsl_tpm.c **** 
 249:../drivers/fsl_tpm.c ****             /* Return error if requested value is greater than the max allowed */
 250:../drivers/fsl_tpm.c ****             if (chnlParams->firstEdgeDelayPercent > 100)
 251:../drivers/fsl_tpm.c ****             {
 252:../drivers/fsl_tpm.c ****                 return kStatus_Fail;
 253:../drivers/fsl_tpm.c ****             }
 254:../drivers/fsl_tpm.c ****             /* Configure delay of the first edge */
 255:../drivers/fsl_tpm.c ****             if (chnlParams->firstEdgeDelayPercent == 0)
 256:../drivers/fsl_tpm.c ****             {
 257:../drivers/fsl_tpm.c ****                 /* No delay for the first edge */
 258:../drivers/fsl_tpm.c ****                 cnvFirstEdge = 0;
 259:../drivers/fsl_tpm.c ****             }
 260:../drivers/fsl_tpm.c ****             else
 261:../drivers/fsl_tpm.c ****             {
 262:../drivers/fsl_tpm.c ****                 cnvFirstEdge = (mod * chnlParams->firstEdgeDelayPercent) / 100;
 263:../drivers/fsl_tpm.c ****             }
 264:../drivers/fsl_tpm.c ****             /* Configure dutycycle */
 265:../drivers/fsl_tpm.c ****             if (chnlParams->dutyCyclePercent == 0)
 266:../drivers/fsl_tpm.c ****             {
 267:../drivers/fsl_tpm.c ****                 /* Signal stays low */
 268:../drivers/fsl_tpm.c ****                 cnv = 0;
 269:../drivers/fsl_tpm.c ****                 cnvFirstEdge = 0;
 270:../drivers/fsl_tpm.c ****             }
 271:../drivers/fsl_tpm.c ****             else
 272:../drivers/fsl_tpm.c ****             {
 273:../drivers/fsl_tpm.c ****                 cnv = (mod * chnlParams->dutyCyclePercent) / 100;
 274:../drivers/fsl_tpm.c ****                 /* For 100% duty cycle */
 275:../drivers/fsl_tpm.c ****                 if (cnv >= mod)
 276:../drivers/fsl_tpm.c ****                 {
 277:../drivers/fsl_tpm.c ****                     cnv = mod + 1;
 278:../drivers/fsl_tpm.c ****                 }
 279:../drivers/fsl_tpm.c ****             }
 280:../drivers/fsl_tpm.c **** 
 281:../drivers/fsl_tpm.c ****             /* Set the combine bit for the channel pair */
 282:../drivers/fsl_tpm.c ****             base->COMBINE |= (1U << (TPM_COMBINE_COMBINE0_SHIFT + (TPM_COMBINE_SHIFT * chnlParams->
 283:../drivers/fsl_tpm.c **** 
 284:../drivers/fsl_tpm.c ****             /* When switching mode, disable channel n first */
 285:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlParams->chnlNumber * 2].CnSC &=
 286:../drivers/fsl_tpm.c ****                 ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 287:../drivers/fsl_tpm.c **** 
 288:../drivers/fsl_tpm.c ****             /* Wait till mode change to disable channel is acknowledged */
 289:../drivers/fsl_tpm.c ****             while ((base->CONTROLS[chnlParams->chnlNumber * 2].CnSC &
 290:../drivers/fsl_tpm.c ****                     (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MAS
 291:../drivers/fsl_tpm.c ****             {
 292:../drivers/fsl_tpm.c ****             }
 293:../drivers/fsl_tpm.c **** 
 294:../drivers/fsl_tpm.c ****             /* Set the requested PWM mode for channel n, PWM output requires mode select to be set 
 295:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlParams->chnlNumber * 2].CnSC |=
 296:../drivers/fsl_tpm.c ****                 ((chnlParams->level << TPM_CnSC_ELSA_SHIFT) | (2U << TPM_CnSC_MSA_SHIFT));
 297:../drivers/fsl_tpm.c **** 
 298:../drivers/fsl_tpm.c ****             /* Wait till mode change is acknowledged */
 299:../drivers/fsl_tpm.c ****             while (!(base->CONTROLS[chnlParams->chnlNumber * 2].CnSC &
 300:../drivers/fsl_tpm.c ****                      (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MA
 301:../drivers/fsl_tpm.c ****             {
 302:../drivers/fsl_tpm.c ****             }
 303:../drivers/fsl_tpm.c ****             /* Set the channel pair values */
 304:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlParams->chnlNumber * 2].CnV = cnvFirstEdge;
 305:../drivers/fsl_tpm.c **** 
 306:../drivers/fsl_tpm.c ****             /* When switching mode, disable channel n + 1 first */
 307:../drivers/fsl_tpm.c ****             base->CONTROLS[(chnlParams->chnlNumber * 2) + 1].CnSC &=
 308:../drivers/fsl_tpm.c ****                 ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 309:../drivers/fsl_tpm.c **** 
 310:../drivers/fsl_tpm.c ****             /* Wait till mode change to disable channel is acknowledged */
 311:../drivers/fsl_tpm.c ****             while ((base->CONTROLS[(chnlParams->chnlNumber * 2) + 1].CnSC &
 312:../drivers/fsl_tpm.c ****                     (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MAS
 313:../drivers/fsl_tpm.c ****             {
 314:../drivers/fsl_tpm.c ****             }
 315:../drivers/fsl_tpm.c **** 
 316:../drivers/fsl_tpm.c ****             /* Set the requested PWM mode for channel n + 1, PWM output requires mode select to be 
 317:../drivers/fsl_tpm.c ****             base->CONTROLS[(chnlParams->chnlNumber * 2) + 1].CnSC |=
 318:../drivers/fsl_tpm.c ****                 ((chnlParams->level << TPM_CnSC_ELSA_SHIFT) | (2U << TPM_CnSC_MSA_SHIFT));
 319:../drivers/fsl_tpm.c **** 
 320:../drivers/fsl_tpm.c ****             /* Wait till mode change is acknowledged */
 321:../drivers/fsl_tpm.c ****             while (!(base->CONTROLS[(chnlParams->chnlNumber * 2) + 1].CnSC &
 322:../drivers/fsl_tpm.c ****                      (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MA
 323:../drivers/fsl_tpm.c ****             {
 324:../drivers/fsl_tpm.c ****             }
 325:../drivers/fsl_tpm.c ****             /* Set the channel pair values */
 326:../drivers/fsl_tpm.c ****             base->CONTROLS[(chnlParams->chnlNumber * 2) + 1].CnV = cnvFirstEdge + cnv;
 327:../drivers/fsl_tpm.c ****         }
 328:../drivers/fsl_tpm.c ****         else
 329:../drivers/fsl_tpm.c ****         {
 330:../drivers/fsl_tpm.c **** #endif
 331:../drivers/fsl_tpm.c ****             if (chnlParams->dutyCyclePercent == 0)
 332:../drivers/fsl_tpm.c ****             {
 333:../drivers/fsl_tpm.c ****                 /* Signal stays low */
 334:../drivers/fsl_tpm.c ****                 cnv = 0;
 335:../drivers/fsl_tpm.c ****             }
 336:../drivers/fsl_tpm.c ****             else
 337:../drivers/fsl_tpm.c ****             {
 338:../drivers/fsl_tpm.c ****                 cnv = (mod * chnlParams->dutyCyclePercent) / 100;
 339:../drivers/fsl_tpm.c ****                 /* For 100% duty cycle */
 340:../drivers/fsl_tpm.c ****                 if (cnv >= mod)
 341:../drivers/fsl_tpm.c ****                 {
 342:../drivers/fsl_tpm.c ****                     cnv = mod + 1;
 343:../drivers/fsl_tpm.c ****                 }
 344:../drivers/fsl_tpm.c ****             }
 345:../drivers/fsl_tpm.c **** 
 346:../drivers/fsl_tpm.c ****             /* When switching mode, disable channel first */
 347:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlParams->chnlNumber].CnSC &=
 348:../drivers/fsl_tpm.c ****                 ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 349:../drivers/fsl_tpm.c **** 
 350:../drivers/fsl_tpm.c ****             /* Wait till mode change to disable channel is acknowledged */
 351:../drivers/fsl_tpm.c ****             while ((base->CONTROLS[chnlParams->chnlNumber].CnSC &
 352:../drivers/fsl_tpm.c ****                     (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MAS
 353:../drivers/fsl_tpm.c ****             {
 354:../drivers/fsl_tpm.c ****             }
 355:../drivers/fsl_tpm.c **** 
 356:../drivers/fsl_tpm.c ****             /* Set the requested PWM mode, PWM output requires mode select to be set to 2 */
 357:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlParams->chnlNumber].CnSC |=
 358:../drivers/fsl_tpm.c ****                 ((chnlParams->level << TPM_CnSC_ELSA_SHIFT) | (2U << TPM_CnSC_MSA_SHIFT));
 359:../drivers/fsl_tpm.c **** 
 360:../drivers/fsl_tpm.c ****             /* Wait till mode change is acknowledged */
 361:../drivers/fsl_tpm.c ****             while (!(base->CONTROLS[chnlParams->chnlNumber].CnSC &
 362:../drivers/fsl_tpm.c ****                      (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MA
 363:../drivers/fsl_tpm.c ****             {
 364:../drivers/fsl_tpm.c ****             }
 365:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlParams->chnlNumber].CnV = cnv;
 366:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 367:../drivers/fsl_tpm.c ****         }
 368:../drivers/fsl_tpm.c **** #endif
 369:../drivers/fsl_tpm.c **** 
 370:../drivers/fsl_tpm.c ****         chnlParams++;
 371:../drivers/fsl_tpm.c ****     }
 372:../drivers/fsl_tpm.c **** 
 373:../drivers/fsl_tpm.c ****     return kStatus_Success;
 374:../drivers/fsl_tpm.c **** }
 367              		.loc 1 374 0
 368              		@ sp needed
 369              	.LVL28:
 370              	.LVL29:
 371 0020 04BC     		pop	{r2}
 372 0022 9046     		mov	r8, r2
 373 0024 F0BD     		pop	{r4, r5, r6, r7, pc}
 374              	.LVL30:
 375              	.L19:
 210:../drivers/fsl_tpm.c ****             mod = (tpmClock / pwmFreq_Hz) - 1;
 376              		.loc 1 210 0
 377 0026 2B68     		ldr	r3, [r5]
 378              	.LVL31:
 379 0028 2022     		movs	r2, #32
 380 002a 9343     		bics	r3, r2
 381 002c 2B60     		str	r3, [r5]
 211:../drivers/fsl_tpm.c ****             break;
 382              		.loc 1 211 0
 383 002e 0699     		ldr	r1, [sp, #24]
 384 0030 FFF7FEFF 		bl	__aeabi_uidiv
 385              	.LVL32:
 386 0034 471E     		subs	r7, r0, #1
 387              	.LVL33:
 388              	.L21:
 223:../drivers/fsl_tpm.c ****     {
 389              		.loc 1 223 0
 390 0036 2A4B     		ldr	r3, .L33
 391 0038 9F42     		cmp	r7, r3
 392 003a 4CD8     		bhi	.L28
 228:../drivers/fsl_tpm.c **** 
 393              		.loc 1 228 0
 394 003c AF60     		str	r7, [r5, #8]
 395              	.LVL34:
 231:../drivers/fsl_tpm.c ****     {
 396              		.loc 1 231 0
 397 003e 0026     		movs	r6, #0
 398 0040 33E0     		b	.L22
 399              	.LVL35:
 400              	.L20:
 214:../drivers/fsl_tpm.c ****             mod = tpmClock / (pwmFreq_Hz * 2);
 401              		.loc 1 214 0
 402 0042 2B68     		ldr	r3, [r5]
 403              	.LVL36:
 404 0044 2022     		movs	r2, #32
 405 0046 1343     		orrs	r3, r2
 406 0048 2B60     		str	r3, [r5]
 215:../drivers/fsl_tpm.c ****             break;
 407              		.loc 1 215 0
 408 004a 069B     		ldr	r3, [sp, #24]
 409 004c 5900     		lsls	r1, r3, #1
 410 004e FFF7FEFF 		bl	__aeabi_uidiv
 411              	.LVL37:
 412 0052 0700     		movs	r7, r0
 413              	.LVL38:
 216:../drivers/fsl_tpm.c ****         default:
 414              		.loc 1 216 0
 415 0054 EFE7     		b	.L21
 416              	.LVL39:
 417              	.L30:
 334:../drivers/fsl_tpm.c ****             }
 418              		.loc 1 334 0
 419 0056 0021     		movs	r1, #0
 420              	.L23:
 421              	.LVL40:
 347:../drivers/fsl_tpm.c ****                 ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 422              		.loc 1 347 0
 423 0058 2378     		ldrb	r3, [r4]
 424 005a 0133     		adds	r3, r3, #1
 425 005c DB00     		lsls	r3, r3, #3
 426 005e EB18     		adds	r3, r5, r3
 427 0060 5A68     		ldr	r2, [r3, #4]
 428 0062 3C20     		movs	r0, #60
 429 0064 8243     		bics	r2, r0
 430 0066 5A60     		str	r2, [r3, #4]
 431              	.L24:
 351:../drivers/fsl_tpm.c ****                     (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MAS
 432              		.loc 1 351 0 discriminator 1
 433 0068 2278     		ldrb	r2, [r4]
 434 006a 531C     		adds	r3, r2, #1
 435 006c DB00     		lsls	r3, r3, #3
 436 006e EB18     		adds	r3, r5, r3
 437 0070 5B68     		ldr	r3, [r3, #4]
 438 0072 3C20     		movs	r0, #60
 439 0074 1842     		tst	r0, r3
 440 0076 F7D1     		bne	.L24
 357:../drivers/fsl_tpm.c ****                 ((chnlParams->level << TPM_CnSC_ELSA_SHIFT) | (2U << TPM_CnSC_MSA_SHIFT));
 441              		.loc 1 357 0
 442 0078 0132     		adds	r2, r2, #1
 443 007a D200     		lsls	r2, r2, #3
 444 007c AA18     		adds	r2, r5, r2
 445 007e 5068     		ldr	r0, [r2, #4]
 358:../drivers/fsl_tpm.c **** 
 446              		.loc 1 358 0
 447 0080 6378     		ldrb	r3, [r4, #1]
 448 0082 9B00     		lsls	r3, r3, #2
 357:../drivers/fsl_tpm.c ****                 ((chnlParams->level << TPM_CnSC_ELSA_SHIFT) | (2U << TPM_CnSC_MSA_SHIFT));
 449              		.loc 1 357 0
 450 0084 0343     		orrs	r3, r0
 451 0086 2020     		movs	r0, #32
 452 0088 0343     		orrs	r3, r0
 453 008a 5360     		str	r3, [r2, #4]
 454              	.L25:
 361:../drivers/fsl_tpm.c ****                      (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MA
 455              		.loc 1 361 0 discriminator 1
 456 008c 2278     		ldrb	r2, [r4]
 457 008e 531C     		adds	r3, r2, #1
 458 0090 DB00     		lsls	r3, r3, #3
 459 0092 EB18     		adds	r3, r5, r3
 460 0094 5B68     		ldr	r3, [r3, #4]
 461 0096 3C20     		movs	r0, #60
 462 0098 1842     		tst	r0, r3
 463 009a F7D0     		beq	.L25
 365:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 464              		.loc 1 365 0 discriminator 2
 465 009c 0132     		adds	r2, r2, #1
 466 009e D200     		lsls	r2, r2, #3
 467 00a0 AA18     		adds	r2, r5, r2
 468 00a2 9160     		str	r1, [r2, #8]
 370:../drivers/fsl_tpm.c ****     }
 469              		.loc 1 370 0 discriminator 2
 470 00a4 0334     		adds	r4, r4, #3
 471              	.LVL41:
 231:../drivers/fsl_tpm.c ****     {
 472              		.loc 1 231 0 discriminator 2
 473 00a6 0136     		adds	r6, r6, #1
 474              	.LVL42:
 475 00a8 F6B2     		uxtb	r6, r6
 476              	.LVL43:
 477              	.L22:
 231:../drivers/fsl_tpm.c ****     {
 478              		.loc 1 231 0 is_stmt 0 discriminator 1
 479 00aa 4645     		cmp	r6, r8
 480 00ac 11D2     		bcs	.L32
 234:../drivers/fsl_tpm.c ****         {
 481              		.loc 1 234 0 is_stmt 1
 482 00ae A078     		ldrb	r0, [r4, #2]
 483 00b0 6428     		cmp	r0, #100
 484 00b2 12D8     		bhi	.L29
 331:../drivers/fsl_tpm.c ****             {
 485              		.loc 1 331 0
 486 00b4 0028     		cmp	r0, #0
 487 00b6 CED0     		beq	.L30
 338:../drivers/fsl_tpm.c ****                 /* For 100% duty cycle */
 488              		.loc 1 338 0
 489 00b8 7843     		muls	r0, r7
 490 00ba 6421     		movs	r1, #100
 491 00bc FFF7FEFF 		bl	__aeabi_uidiv
 492              	.LVL44:
 493 00c0 81B2     		uxth	r1, r0
 494              	.LVL45:
 340:../drivers/fsl_tpm.c ****                 {
 495              		.loc 1 340 0
 496 00c2 0004     		lsls	r0, r0, #16
 497 00c4 000C     		lsrs	r0, r0, #16
 498 00c6 8742     		cmp	r7, r0
 499 00c8 C6D8     		bhi	.L23
 342:../drivers/fsl_tpm.c ****                 }
 500              		.loc 1 342 0
 501 00ca B9B2     		uxth	r1, r7
 502              	.LVL46:
 503 00cc 0131     		adds	r1, r1, #1
 504 00ce 89B2     		uxth	r1, r1
 505              	.LVL47:
 506 00d0 C2E7     		b	.L23
 507              	.LVL48:
 508              	.L32:
 373:../drivers/fsl_tpm.c **** }
 509              		.loc 1 373 0
 510 00d2 0020     		movs	r0, #0
 511 00d4 A4E7     		b	.L17
 512              	.LVL49:
 513              	.L28:
 225:../drivers/fsl_tpm.c ****     }
 514              		.loc 1 225 0
 515 00d6 0120     		movs	r0, #1
 516 00d8 A2E7     		b	.L17
 517              	.LVL50:
 518              	.L29:
 236:../drivers/fsl_tpm.c ****         }
 519              		.loc 1 236 0
 520 00da 0120     		movs	r0, #1
 521 00dc A0E7     		b	.L17
 522              	.L34:
 523 00de C046     		.align	2
 524              	.L33:
 525 00e0 FFFF0000 		.word	65535
 526              		.cfi_endproc
 527              	.LFE63:
 529              		.global	__aeabi_idiv
 530              		.section	.text.TPM_UpdatePwmDutycycle,"ax",%progbits
 531              		.align	1
 532              		.global	TPM_UpdatePwmDutycycle
 533              		.syntax unified
 534              		.code	16
 535              		.thumb_func
 536              		.fpu softvfp
 538              	TPM_UpdatePwmDutycycle:
 539              	.LFB64:
 375:../drivers/fsl_tpm.c **** 
 376:../drivers/fsl_tpm.c **** void TPM_UpdatePwmDutycycle(TPM_Type *base,
 377:../drivers/fsl_tpm.c ****                             tpm_chnl_t chnlNumber,
 378:../drivers/fsl_tpm.c ****                             tpm_pwm_mode_t currentPwmMode,
 379:../drivers/fsl_tpm.c ****                             uint8_t dutyCyclePercent)
 380:../drivers/fsl_tpm.c **** {
 540              		.loc 1 380 0
 541              		.cfi_startproc
 542              		@ args = 0, pretend = 0, frame = 0
 543              		@ frame_needed = 0, uses_anonymous_args = 0
 544              	.LVL51:
 545 0000 70B5     		push	{r4, r5, r6, lr}
 546              		.cfi_def_cfa_offset 16
 547              		.cfi_offset 4, -16
 548              		.cfi_offset 5, -12
 549              		.cfi_offset 6, -8
 550              		.cfi_offset 14, -4
 551 0002 0500     		movs	r5, r0
 552 0004 0C00     		movs	r4, r1
 381:../drivers/fsl_tpm.c ****     assert(chnlNumber < FSL_FEATURE_TPM_CHANNEL_COUNTn(base));
 382:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 383:../drivers/fsl_tpm.c ****     if(currentPwmMode == kTPM_CombinedPwm)
 384:../drivers/fsl_tpm.c ****     {
 385:../drivers/fsl_tpm.c ****         assert(FSL_FEATURE_TPM_COMBINE_HAS_EFFECTn(base));
 386:../drivers/fsl_tpm.c ****     }
 387:../drivers/fsl_tpm.c **** #endif
 388:../drivers/fsl_tpm.c **** 
 389:../drivers/fsl_tpm.c ****     uint16_t cnv, mod;
 390:../drivers/fsl_tpm.c **** 
 391:../drivers/fsl_tpm.c ****     mod = base->MOD;
 553              		.loc 1 391 0
 554 0006 8268     		ldr	r2, [r0, #8]
 555              	.LVL52:
 556 0008 96B2     		uxth	r6, r2
 557              	.LVL53:
 392:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 393:../drivers/fsl_tpm.c ****     if (currentPwmMode == kTPM_CombinedPwm)
 394:../drivers/fsl_tpm.c ****     {
 395:../drivers/fsl_tpm.c ****         uint16_t cnvFirstEdge;
 396:../drivers/fsl_tpm.c **** 
 397:../drivers/fsl_tpm.c ****         /* This check is added for combined mode as the channel number should be the pair number */
 398:../drivers/fsl_tpm.c ****         if (chnlNumber >= (FSL_FEATURE_TPM_CHANNEL_COUNTn(base) / 2))
 399:../drivers/fsl_tpm.c ****         {
 400:../drivers/fsl_tpm.c ****             return;
 401:../drivers/fsl_tpm.c ****         }
 402:../drivers/fsl_tpm.c ****         cnv = (mod * dutyCyclePercent) / 100;
 403:../drivers/fsl_tpm.c ****         cnvFirstEdge = base->CONTROLS[chnlNumber * 2].CnV;
 404:../drivers/fsl_tpm.c ****         /* For 100% duty cycle */
 405:../drivers/fsl_tpm.c ****         if (cnv >= mod)
 406:../drivers/fsl_tpm.c ****         {
 407:../drivers/fsl_tpm.c ****             cnv = mod + 1;
 408:../drivers/fsl_tpm.c ****         }
 409:../drivers/fsl_tpm.c ****         base->CONTROLS[(chnlNumber * 2) + 1].CnV = cnvFirstEdge + cnv;
 410:../drivers/fsl_tpm.c ****     }
 411:../drivers/fsl_tpm.c ****     else
 412:../drivers/fsl_tpm.c ****     {
 413:../drivers/fsl_tpm.c **** #endif
 414:../drivers/fsl_tpm.c ****         cnv = (mod * dutyCyclePercent) / 100;
 558              		.loc 1 414 0
 559 000a 1204     		lsls	r2, r2, #16
 560 000c 120C     		lsrs	r2, r2, #16
 561 000e 5343     		muls	r3, r2
 562              	.LVL54:
 563 0010 1800     		movs	r0, r3
 564              	.LVL55:
 565 0012 6421     		movs	r1, #100
 566              	.LVL56:
 567 0014 FFF7FEFF 		bl	__aeabi_idiv
 568              	.LVL57:
 569 0018 80B2     		uxth	r0, r0
 570              	.LVL58:
 415:../drivers/fsl_tpm.c ****         /* For 100% duty cycle */
 416:../drivers/fsl_tpm.c ****         if (cnv >= mod)
 571              		.loc 1 416 0
 572 001a 8642     		cmp	r6, r0
 573 001c 01D8     		bhi	.L36
 417:../drivers/fsl_tpm.c ****         {
 418:../drivers/fsl_tpm.c ****             cnv = mod + 1;
 574              		.loc 1 418 0
 575 001e 0136     		adds	r6, r6, #1
 576              	.LVL59:
 577 0020 B0B2     		uxth	r0, r6
 578              	.LVL60:
 579              	.L36:
 419:../drivers/fsl_tpm.c ****         }
 420:../drivers/fsl_tpm.c ****         base->CONTROLS[chnlNumber].CnV = cnv;
 580              		.loc 1 420 0
 581 0022 0134     		adds	r4, r4, #1
 582 0024 E400     		lsls	r4, r4, #3
 583 0026 2C19     		adds	r4, r5, r4
 584 0028 A060     		str	r0, [r4, #8]
 421:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_WAIT_CnV_REGISTER_UPDATE) && FSL_FEATURE_TPM_WAIT_CnV_REGISTER_UPDATE
 422:../drivers/fsl_tpm.c ****         while(!(cnv == base->CONTROLS[chnlNumber].CnV))
 423:../drivers/fsl_tpm.c ****         {
 424:../drivers/fsl_tpm.c ****         }
 425:../drivers/fsl_tpm.c **** #endif 
 426:../drivers/fsl_tpm.c ****         
 427:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 428:../drivers/fsl_tpm.c ****     }
 429:../drivers/fsl_tpm.c **** #endif
 430:../drivers/fsl_tpm.c **** }
 585              		.loc 1 430 0
 586              		@ sp needed
 587              	.LVL61:
 588 002a 70BD     		pop	{r4, r5, r6, pc}
 589              		.cfi_endproc
 590              	.LFE64:
 592              		.section	.text.TPM_UpdateChnlEdgeLevelSelect,"ax",%progbits
 593              		.align	1
 594              		.global	TPM_UpdateChnlEdgeLevelSelect
 595              		.syntax unified
 596              		.code	16
 597              		.thumb_func
 598              		.fpu softvfp
 600              	TPM_UpdateChnlEdgeLevelSelect:
 601              	.LFB65:
 431:../drivers/fsl_tpm.c **** 
 432:../drivers/fsl_tpm.c **** void TPM_UpdateChnlEdgeLevelSelect(TPM_Type *base, tpm_chnl_t chnlNumber, uint8_t level)
 433:../drivers/fsl_tpm.c **** {
 602              		.loc 1 433 0
 603              		.cfi_startproc
 604              		@ args = 0, pretend = 0, frame = 0
 605              		@ frame_needed = 0, uses_anonymous_args = 0
 606              	.LVL62:
 607 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 608              		.cfi_def_cfa_offset 20
 609              		.cfi_offset 4, -20
 610              		.cfi_offset 5, -16
 611              		.cfi_offset 6, -12
 612              		.cfi_offset 7, -8
 613              		.cfi_offset 14, -4
 434:../drivers/fsl_tpm.c ****     assert(chnlNumber < FSL_FEATURE_TPM_CHANNEL_COUNTn(base));
 435:../drivers/fsl_tpm.c **** 
 436:../drivers/fsl_tpm.c ****     uint32_t reg = base->CONTROLS[chnlNumber].CnSC
 614              		.loc 1 436 0
 615 0002 0C00     		movs	r4, r1
 616 0004 4B1C     		adds	r3, r1, #1
 617 0006 DB00     		lsls	r3, r3, #3
 618 0008 C318     		adds	r3, r0, r3
 619 000a 5E68     		ldr	r6, [r3, #4]
 620              	.LVL63:
 437:../drivers/fsl_tpm.c **** #if !(defined(FSL_FEATURE_TPM_CnSC_CHF_WRITE_0_CLEAR) && FSL_FEATURE_TPM_CnSC_CHF_WRITE_0_CLEAR)   
 438:../drivers/fsl_tpm.c ****     & ~(TPM_CnSC_CHF_MASK)
 439:../drivers/fsl_tpm.c **** #endif
 440:../drivers/fsl_tpm.c ****     ;
 441:../drivers/fsl_tpm.c **** 
 442:../drivers/fsl_tpm.c ****     /* When switching mode, disable channel first  */
 443:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnSC &=
 621              		.loc 1 443 0
 622 000c 5D68     		ldr	r5, [r3, #4]
 623 000e 3C27     		movs	r7, #60
 624 0010 BD43     		bics	r5, r7
 625 0012 5D60     		str	r5, [r3, #4]
 626              	.L38:
 444:../drivers/fsl_tpm.c ****         ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 445:../drivers/fsl_tpm.c **** 
 446:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 447:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[chnlNumber].CnSC &
 627              		.loc 1 447 0 discriminator 1
 628 0014 631C     		adds	r3, r4, #1
 629 0016 DB00     		lsls	r3, r3, #3
 630 0018 C318     		adds	r3, r0, r3
 631 001a 5B68     		ldr	r3, [r3, #4]
 632 001c 3C25     		movs	r5, #60
 633 001e 1D42     		tst	r5, r3
 634 0020 F8D1     		bne	.L38
 448:../drivers/fsl_tpm.c ****             (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 449:../drivers/fsl_tpm.c ****     {
 450:../drivers/fsl_tpm.c ****     }
 451:../drivers/fsl_tpm.c **** 
 452:../drivers/fsl_tpm.c ****     /* Clear the field and write the new level value */
 453:../drivers/fsl_tpm.c ****     reg &= ~(TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 635              		.loc 1 453 0
 636 0022 8C23     		movs	r3, #140
 637 0024 9E43     		bics	r6, r3
 638              	.LVL64:
 454:../drivers/fsl_tpm.c ****     reg |= ((uint32_t)level << TPM_CnSC_ELSA_SHIFT) & (TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 639              		.loc 1 454 0
 640 0026 9500     		lsls	r5, r2, #2
 641 0028 0C22     		movs	r2, #12
 642              	.LVL65:
 643 002a 2A40     		ands	r2, r5
 644 002c 3243     		orrs	r2, r6
 645              	.LVL66:
 455:../drivers/fsl_tpm.c ****     
 456:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnSC = reg;
 646              		.loc 1 456 0
 647 002e 0131     		adds	r1, r1, #1
 648              	.LVL67:
 649 0030 C900     		lsls	r1, r1, #3
 650 0032 4118     		adds	r1, r0, r1
 651 0034 4A60     		str	r2, [r1, #4]
 457:../drivers/fsl_tpm.c **** 
 458:../drivers/fsl_tpm.c ****     /* Wait till mode change is acknowledged */
 459:../drivers/fsl_tpm.c ****     reg &= (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 652              		.loc 1 459 0
 653 0036 3C21     		movs	r1, #60
 654 0038 1140     		ands	r1, r2
 655              	.LVL68:
 656              	.L39:
 460:../drivers/fsl_tpm.c ****     while (reg != (base->CONTROLS[chnlNumber].CnSC &
 657              		.loc 1 460 0 discriminator 1
 658 003a 631C     		adds	r3, r4, #1
 659 003c DB00     		lsls	r3, r3, #3
 660 003e C318     		adds	r3, r0, r3
 661 0040 5A68     		ldr	r2, [r3, #4]
 662 0042 3C23     		movs	r3, #60
 663 0044 1340     		ands	r3, r2
 664 0046 8B42     		cmp	r3, r1
 665 0048 F7D1     		bne	.L39
 461:../drivers/fsl_tpm.c ****                    (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK
 462:../drivers/fsl_tpm.c ****     {
 463:../drivers/fsl_tpm.c ****     }
 464:../drivers/fsl_tpm.c **** }
 666              		.loc 1 464 0
 667              		@ sp needed
 668 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 669              		.cfi_endproc
 670              	.LFE65:
 672              		.section	.text.TPM_SetupInputCapture,"ax",%progbits
 673              		.align	1
 674              		.global	TPM_SetupInputCapture
 675              		.syntax unified
 676              		.code	16
 677              		.thumb_func
 678              		.fpu softvfp
 680              	TPM_SetupInputCapture:
 681              	.LFB66:
 465:../drivers/fsl_tpm.c **** 
 466:../drivers/fsl_tpm.c **** void TPM_SetupInputCapture(TPM_Type *base, tpm_chnl_t chnlNumber, tpm_input_capture_edge_t captureM
 467:../drivers/fsl_tpm.c **** {
 682              		.loc 1 467 0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 0
 685              		@ frame_needed = 0, uses_anonymous_args = 0
 686              	.LVL69:
 687 0000 70B5     		push	{r4, r5, r6, lr}
 688              		.cfi_def_cfa_offset 16
 689              		.cfi_offset 4, -16
 690              		.cfi_offset 5, -12
 691              		.cfi_offset 6, -8
 692              		.cfi_offset 14, -4
 468:../drivers/fsl_tpm.c ****     assert(chnlNumber < FSL_FEATURE_TPM_CHANNEL_COUNTn(base));
 469:../drivers/fsl_tpm.c **** 
 470:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_QDCTRL) && FSL_FEATURE_TPM_HAS_QDCTRL
 471:../drivers/fsl_tpm.c ****     /* The TPM's QDCTRL register required to be effective */
 472:../drivers/fsl_tpm.c ****     if( FSL_FEATURE_TPM_QDCTRL_HAS_EFFECTn(base) )
 473:../drivers/fsl_tpm.c ****     {
 474:../drivers/fsl_tpm.c ****         /* Clear quadrature Decoder mode for channel 0 or 1*/
 475:../drivers/fsl_tpm.c ****         if ((chnlNumber == 0) || (chnlNumber == 1))
 476:../drivers/fsl_tpm.c ****         {
 477:../drivers/fsl_tpm.c ****             base->QDCTRL &= ~TPM_QDCTRL_QUADEN_MASK;
 478:../drivers/fsl_tpm.c ****         }
 479:../drivers/fsl_tpm.c ****     }
 480:../drivers/fsl_tpm.c **** #endif
 481:../drivers/fsl_tpm.c **** 
 482:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 483:../drivers/fsl_tpm.c ****         /* The TPM's COMBINE register required to be effective */
 484:../drivers/fsl_tpm.c ****     if( FSL_FEATURE_TPM_COMBINE_HAS_EFFECTn(base) )
 485:../drivers/fsl_tpm.c ****     {
 486:../drivers/fsl_tpm.c ****         /* Clear the combine bit for chnlNumber */
 487:../drivers/fsl_tpm.c ****         base->COMBINE &= ~(1U << TPM_COMBINE_SHIFT * (chnlNumber / 2));
 488:../drivers/fsl_tpm.c ****     }
 489:../drivers/fsl_tpm.c **** #endif
 490:../drivers/fsl_tpm.c **** 
 491:../drivers/fsl_tpm.c ****     /* When switching mode, disable channel first  */
 492:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnSC &=
 693              		.loc 1 492 0
 694 0002 0C00     		movs	r4, r1
 695 0004 4B1C     		adds	r3, r1, #1
 696 0006 DB00     		lsls	r3, r3, #3
 697 0008 C318     		adds	r3, r0, r3
 698 000a 5D68     		ldr	r5, [r3, #4]
 699 000c 3C26     		movs	r6, #60
 700 000e B543     		bics	r5, r6
 701 0010 5D60     		str	r5, [r3, #4]
 702              	.L41:
 493:../drivers/fsl_tpm.c ****         ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 494:../drivers/fsl_tpm.c **** 
 495:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 496:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[chnlNumber].CnSC &
 703              		.loc 1 496 0 discriminator 1
 704 0012 631C     		adds	r3, r4, #1
 705 0014 DB00     		lsls	r3, r3, #3
 706 0016 C318     		adds	r3, r0, r3
 707 0018 5B68     		ldr	r3, [r3, #4]
 708 001a 3C25     		movs	r5, #60
 709 001c 1D42     		tst	r5, r3
 710 001e F8D1     		bne	.L41
 497:../drivers/fsl_tpm.c ****             (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 498:../drivers/fsl_tpm.c ****     {
 499:../drivers/fsl_tpm.c ****     }
 500:../drivers/fsl_tpm.c **** 
 501:../drivers/fsl_tpm.c ****     /* Set the requested input capture mode */
 502:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnSC |= captureMode;
 711              		.loc 1 502 0
 712 0020 0131     		adds	r1, r1, #1
 713              	.LVL70:
 714 0022 C900     		lsls	r1, r1, #3
 715 0024 4118     		adds	r1, r0, r1
 716 0026 4B68     		ldr	r3, [r1, #4]
 717 0028 1A43     		orrs	r2, r3
 718              	.LVL71:
 719 002a 4A60     		str	r2, [r1, #4]
 720              	.L42:
 503:../drivers/fsl_tpm.c **** 
 504:../drivers/fsl_tpm.c ****     /* Wait till mode change is acknowledged */
 505:../drivers/fsl_tpm.c ****     while (!(base->CONTROLS[chnlNumber].CnSC &
 721              		.loc 1 505 0 discriminator 1
 722 002c 631C     		adds	r3, r4, #1
 723 002e DB00     		lsls	r3, r3, #3
 724 0030 C318     		adds	r3, r0, r3
 725 0032 5B68     		ldr	r3, [r3, #4]
 726 0034 3C22     		movs	r2, #60
 727 0036 1A42     		tst	r2, r3
 728 0038 F8D0     		beq	.L42
 506:../drivers/fsl_tpm.c ****              (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 507:../drivers/fsl_tpm.c ****     {
 508:../drivers/fsl_tpm.c ****     }
 509:../drivers/fsl_tpm.c **** }
 729              		.loc 1 509 0
 730              		@ sp needed
 731 003a 70BD     		pop	{r4, r5, r6, pc}
 732              		.cfi_endproc
 733              	.LFE66:
 735              		.section	.text.TPM_SetupOutputCompare,"ax",%progbits
 736              		.align	1
 737              		.global	TPM_SetupOutputCompare
 738              		.syntax unified
 739              		.code	16
 740              		.thumb_func
 741              		.fpu softvfp
 743              	TPM_SetupOutputCompare:
 744              	.LFB67:
 510:../drivers/fsl_tpm.c **** 
 511:../drivers/fsl_tpm.c **** void TPM_SetupOutputCompare(TPM_Type *base,
 512:../drivers/fsl_tpm.c ****                             tpm_chnl_t chnlNumber,
 513:../drivers/fsl_tpm.c ****                             tpm_output_compare_mode_t compareMode,
 514:../drivers/fsl_tpm.c ****                             uint32_t compareValue)
 515:../drivers/fsl_tpm.c **** {
 745              		.loc 1 515 0
 746              		.cfi_startproc
 747              		@ args = 0, pretend = 0, frame = 0
 748              		@ frame_needed = 0, uses_anonymous_args = 0
 749              	.LVL72:
 750 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 751              		.cfi_def_cfa_offset 20
 752              		.cfi_offset 4, -20
 753              		.cfi_offset 5, -16
 754              		.cfi_offset 6, -12
 755              		.cfi_offset 7, -8
 756              		.cfi_offset 14, -4
 516:../drivers/fsl_tpm.c ****     assert(chnlNumber < FSL_FEATURE_TPM_CHANNEL_COUNTn(base));
 517:../drivers/fsl_tpm.c **** 
 518:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_QDCTRL) && FSL_FEATURE_TPM_HAS_QDCTRL
 519:../drivers/fsl_tpm.c ****     /* The TPM's QDCTRL register required to be effective */
 520:../drivers/fsl_tpm.c ****     if( FSL_FEATURE_TPM_QDCTRL_HAS_EFFECTn(base) )
 521:../drivers/fsl_tpm.c ****     {
 522:../drivers/fsl_tpm.c ****         /* Clear quadrature Decoder mode for channel 0 or 1 */
 523:../drivers/fsl_tpm.c ****         if ((chnlNumber == 0) || (chnlNumber == 1))
 524:../drivers/fsl_tpm.c ****         {
 525:../drivers/fsl_tpm.c ****             base->QDCTRL &= ~TPM_QDCTRL_QUADEN_MASK;
 526:../drivers/fsl_tpm.c ****         }
 527:../drivers/fsl_tpm.c ****     }
 528:../drivers/fsl_tpm.c **** #endif
 529:../drivers/fsl_tpm.c **** 
 530:../drivers/fsl_tpm.c ****     /* When switching mode, disable channel first  */
 531:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnSC &=
 757              		.loc 1 531 0
 758 0002 0D00     		movs	r5, r1
 759 0004 4C1C     		adds	r4, r1, #1
 760 0006 E400     		lsls	r4, r4, #3
 761 0008 0419     		adds	r4, r0, r4
 762 000a 6668     		ldr	r6, [r4, #4]
 763 000c 3C27     		movs	r7, #60
 764 000e BE43     		bics	r6, r7
 765 0010 6660     		str	r6, [r4, #4]
 766              	.L44:
 532:../drivers/fsl_tpm.c ****         ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 533:../drivers/fsl_tpm.c **** 
 534:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 535:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[chnlNumber].CnSC &
 767              		.loc 1 535 0 discriminator 1
 768 0012 6C1C     		adds	r4, r5, #1
 769 0014 E400     		lsls	r4, r4, #3
 770 0016 0419     		adds	r4, r0, r4
 771 0018 6468     		ldr	r4, [r4, #4]
 772 001a 3C26     		movs	r6, #60
 773 001c 2642     		tst	r6, r4
 774 001e F8D1     		bne	.L44
 536:../drivers/fsl_tpm.c ****             (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 537:../drivers/fsl_tpm.c ****     {
 538:../drivers/fsl_tpm.c ****     }
 539:../drivers/fsl_tpm.c **** 
 540:../drivers/fsl_tpm.c ****     /* Setup the channel output behaviour when a match occurs with the compare value */
 541:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnSC |= compareMode;
 775              		.loc 1 541 0
 776 0020 0131     		adds	r1, r1, #1
 777              	.LVL73:
 778 0022 C900     		lsls	r1, r1, #3
 779 0024 4118     		adds	r1, r0, r1
 780 0026 4C68     		ldr	r4, [r1, #4]
 781 0028 2243     		orrs	r2, r4
 782              	.LVL74:
 783 002a 4A60     		str	r2, [r1, #4]
 542:../drivers/fsl_tpm.c **** 
 543:../drivers/fsl_tpm.c ****     /* Setup the compare value */
 544:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlNumber].CnV = compareValue;
 784              		.loc 1 544 0
 785 002c 8B60     		str	r3, [r1, #8]
 786              	.LVL75:
 787              	.L45:
 545:../drivers/fsl_tpm.c **** 
 546:../drivers/fsl_tpm.c ****     /* Wait till mode change is acknowledged */
 547:../drivers/fsl_tpm.c ****     while (!(base->CONTROLS[chnlNumber].CnSC &
 788              		.loc 1 547 0 discriminator 1
 789 002e 6B1C     		adds	r3, r5, #1
 790 0030 DB00     		lsls	r3, r3, #3
 791 0032 C318     		adds	r3, r0, r3
 792 0034 5B68     		ldr	r3, [r3, #4]
 793 0036 3C22     		movs	r2, #60
 794 0038 1A42     		tst	r2, r3
 795 003a F8D0     		beq	.L45
 548:../drivers/fsl_tpm.c ****              (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 549:../drivers/fsl_tpm.c ****     {
 550:../drivers/fsl_tpm.c ****     }
 551:../drivers/fsl_tpm.c **** }
 796              		.loc 1 551 0
 797              		@ sp needed
 798 003c F0BD     		pop	{r4, r5, r6, r7, pc}
 799              		.cfi_endproc
 800              	.LFE67:
 802              		.section	.text.TPM_EnableInterrupts,"ax",%progbits
 803              		.align	1
 804              		.global	TPM_EnableInterrupts
 805              		.syntax unified
 806              		.code	16
 807              		.thumb_func
 808              		.fpu softvfp
 810              	TPM_EnableInterrupts:
 811              	.LFB68:
 552:../drivers/fsl_tpm.c **** 
 553:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE
 554:../drivers/fsl_tpm.c **** void TPM_SetupDualEdgeCapture(TPM_Type *base,
 555:../drivers/fsl_tpm.c ****                               tpm_chnl_t chnlPairNumber,
 556:../drivers/fsl_tpm.c ****                               const tpm_dual_edge_capture_param_t *edgeParam,
 557:../drivers/fsl_tpm.c ****                               uint32_t filterValue)
 558:../drivers/fsl_tpm.c **** {
 559:../drivers/fsl_tpm.c ****     assert(edgeParam);
 560:../drivers/fsl_tpm.c ****     assert(chnlPairNumber < FSL_FEATURE_TPM_CHANNEL_COUNTn(base) / 2);
 561:../drivers/fsl_tpm.c ****     assert(FSL_FEATURE_TPM_COMBINE_HAS_EFFECTn(base));
 562:../drivers/fsl_tpm.c **** 
 563:../drivers/fsl_tpm.c ****     uint32_t reg;
 564:../drivers/fsl_tpm.c **** 
 565:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_QDCTRL) && FSL_FEATURE_TPM_HAS_QDCTRL
 566:../drivers/fsl_tpm.c ****     /* The TPM's QDCTRL register required to be effective */
 567:../drivers/fsl_tpm.c ****     if( FSL_FEATURE_TPM_QDCTRL_HAS_EFFECTn(base) )
 568:../drivers/fsl_tpm.c ****     {
 569:../drivers/fsl_tpm.c ****         /* Clear quadrature Decoder mode for channel 0 or 1*/
 570:../drivers/fsl_tpm.c ****         if (chnlPairNumber == 0)
 571:../drivers/fsl_tpm.c ****         {
 572:../drivers/fsl_tpm.c ****             base->QDCTRL &= ~TPM_QDCTRL_QUADEN_MASK;
 573:../drivers/fsl_tpm.c ****         }
 574:../drivers/fsl_tpm.c ****     }
 575:../drivers/fsl_tpm.c **** #endif
 576:../drivers/fsl_tpm.c **** 
 577:../drivers/fsl_tpm.c ****     /* Unlock: When switching mode, disable channel first */
 578:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlPairNumber * 2].CnSC &=
 579:../drivers/fsl_tpm.c ****         ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 580:../drivers/fsl_tpm.c **** 
 581:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 582:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[chnlPairNumber * 2].CnSC &
 583:../drivers/fsl_tpm.c ****             (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 584:../drivers/fsl_tpm.c ****     {
 585:../drivers/fsl_tpm.c ****     }
 586:../drivers/fsl_tpm.c **** 
 587:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlPairNumber * 2 + 1].CnSC &=
 588:../drivers/fsl_tpm.c ****         ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK);
 589:../drivers/fsl_tpm.c **** 
 590:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 591:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[chnlPairNumber * 2 + 1].CnSC &
 592:../drivers/fsl_tpm.c ****             (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 593:../drivers/fsl_tpm.c ****     {
 594:../drivers/fsl_tpm.c ****     }
 595:../drivers/fsl_tpm.c **** 
 596:../drivers/fsl_tpm.c ****     /* Now, the registers for input mode can be operated. */
 597:../drivers/fsl_tpm.c ****     if (edgeParam->enableSwap)
 598:../drivers/fsl_tpm.c ****     {
 599:../drivers/fsl_tpm.c ****         /* Set the combine and swap bits for the channel pair */
 600:../drivers/fsl_tpm.c ****         base->COMBINE |= (TPM_COMBINE_COMBINE0_MASK | TPM_COMBINE_COMSWAP0_MASK)
 601:../drivers/fsl_tpm.c ****                          << (TPM_COMBINE_SHIFT * chnlPairNumber);
 602:../drivers/fsl_tpm.c **** 
 603:../drivers/fsl_tpm.c ****         /* Input filter setup for channel n+1 input */
 604:../drivers/fsl_tpm.c ****         reg = base->FILTER;
 605:../drivers/fsl_tpm.c ****         reg &= ~(TPM_FILTER_CH0FVAL_MASK << (TPM_FILTER_CH1FVAL_SHIFT * (chnlPairNumber + 1)));
 606:../drivers/fsl_tpm.c ****         reg |= (filterValue << (TPM_FILTER_CH1FVAL_SHIFT * (chnlPairNumber + 1)));
 607:../drivers/fsl_tpm.c ****         base->FILTER = reg;
 608:../drivers/fsl_tpm.c ****     }
 609:../drivers/fsl_tpm.c ****     else
 610:../drivers/fsl_tpm.c ****     {
 611:../drivers/fsl_tpm.c ****         reg = base->COMBINE;
 612:../drivers/fsl_tpm.c ****         /* Clear the swap bit for the channel pair */
 613:../drivers/fsl_tpm.c ****         reg &= ~(TPM_COMBINE_COMSWAP0_MASK << (TPM_COMBINE_COMSWAP0_SHIFT * chnlPairNumber));
 614:../drivers/fsl_tpm.c **** 
 615:../drivers/fsl_tpm.c ****         /* Set the combine bit for the channel pair */
 616:../drivers/fsl_tpm.c ****         reg |= TPM_COMBINE_COMBINE0_MASK << (TPM_COMBINE_SHIFT * chnlPairNumber);
 617:../drivers/fsl_tpm.c ****         base->COMBINE = reg;
 618:../drivers/fsl_tpm.c **** 
 619:../drivers/fsl_tpm.c ****         /* Input filter setup for channel n input */
 620:../drivers/fsl_tpm.c ****         reg = base->FILTER;
 621:../drivers/fsl_tpm.c ****         reg &= ~(TPM_FILTER_CH0FVAL_MASK << (TPM_FILTER_CH1FVAL_SHIFT * chnlPairNumber));
 622:../drivers/fsl_tpm.c ****         reg |= (filterValue << (TPM_FILTER_CH1FVAL_SHIFT * chnlPairNumber));
 623:../drivers/fsl_tpm.c ****         base->FILTER = reg;
 624:../drivers/fsl_tpm.c ****     }
 625:../drivers/fsl_tpm.c **** 
 626:../drivers/fsl_tpm.c ****     /* Setup the edge detection from channel n */
 627:../drivers/fsl_tpm.c ****     base->CONTROLS[chnlPairNumber * 2].CnSC |= edgeParam->currChanEdgeMode;
 628:../drivers/fsl_tpm.c **** 
 629:../drivers/fsl_tpm.c ****     /* Wait till mode change is acknowledged */
 630:../drivers/fsl_tpm.c ****     while (!(base->CONTROLS[chnlPairNumber * 2].CnSC &
 631:../drivers/fsl_tpm.c ****              (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 632:../drivers/fsl_tpm.c ****     {
 633:../drivers/fsl_tpm.c ****     }
 634:../drivers/fsl_tpm.c **** 
 635:../drivers/fsl_tpm.c ****     /* Setup the edge detection from channel n+1 */
 636:../drivers/fsl_tpm.c ****     base->CONTROLS[(chnlPairNumber * 2) + 1].CnSC |= edgeParam->nextChanEdgeMode;
 637:../drivers/fsl_tpm.c **** 
 638:../drivers/fsl_tpm.c ****     /* Wait till mode change is acknowledged */
 639:../drivers/fsl_tpm.c ****     while (!(base->CONTROLS[(chnlPairNumber * 2) + 1].CnSC &
 640:../drivers/fsl_tpm.c ****              (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_CnSC_ELSB_MASK)))
 641:../drivers/fsl_tpm.c ****     {
 642:../drivers/fsl_tpm.c ****     }
 643:../drivers/fsl_tpm.c **** }
 644:../drivers/fsl_tpm.c **** #endif
 645:../drivers/fsl_tpm.c **** 
 646:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_QDCTRL) && FSL_FEATURE_TPM_HAS_QDCTRL
 647:../drivers/fsl_tpm.c **** void TPM_SetupQuadDecode(TPM_Type *base,
 648:../drivers/fsl_tpm.c ****                          const tpm_phase_params_t *phaseAParams,
 649:../drivers/fsl_tpm.c ****                          const tpm_phase_params_t *phaseBParams,
 650:../drivers/fsl_tpm.c ****                          tpm_quad_decode_mode_t quadMode)
 651:../drivers/fsl_tpm.c **** {
 652:../drivers/fsl_tpm.c ****     assert(phaseAParams);
 653:../drivers/fsl_tpm.c ****     assert(phaseBParams);
 654:../drivers/fsl_tpm.c ****     assert(FSL_FEATURE_TPM_QDCTRL_HAS_EFFECTn(base));
 655:../drivers/fsl_tpm.c **** 
 656:../drivers/fsl_tpm.c ****     base->CONTROLS[0].CnSC &= ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_Cn
 657:../drivers/fsl_tpm.c **** 
 658:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 659:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[0].CnSC & (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | 
 660:../drivers/fsl_tpm.c ****     {
 661:../drivers/fsl_tpm.c ****     }
 662:../drivers/fsl_tpm.c ****     uint32_t reg;
 663:../drivers/fsl_tpm.c **** 
 664:../drivers/fsl_tpm.c ****     /* Set Phase A filter value */
 665:../drivers/fsl_tpm.c ****     reg = base->FILTER;
 666:../drivers/fsl_tpm.c ****     reg &= ~(TPM_FILTER_CH0FVAL_MASK);
 667:../drivers/fsl_tpm.c ****     reg |= TPM_FILTER_CH0FVAL(phaseAParams->phaseFilterVal);
 668:../drivers/fsl_tpm.c ****     base->FILTER = reg;
 669:../drivers/fsl_tpm.c **** 
 670:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_POL) && FSL_FEATURE_TPM_HAS_POL
 671:../drivers/fsl_tpm.c ****     /* Set Phase A polarity */
 672:../drivers/fsl_tpm.c ****     if (phaseAParams->phasePolarity)
 673:../drivers/fsl_tpm.c ****     {
 674:../drivers/fsl_tpm.c ****         base->POL |= TPM_POL_POL0_MASK;
 675:../drivers/fsl_tpm.c ****     }
 676:../drivers/fsl_tpm.c ****     else
 677:../drivers/fsl_tpm.c ****     {
 678:../drivers/fsl_tpm.c ****         base->POL &= ~TPM_POL_POL0_MASK;
 679:../drivers/fsl_tpm.c ****     }
 680:../drivers/fsl_tpm.c **** #endif
 681:../drivers/fsl_tpm.c **** 
 682:../drivers/fsl_tpm.c ****     base->CONTROLS[1].CnSC &= ~(TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | TPM_Cn
 683:../drivers/fsl_tpm.c **** 
 684:../drivers/fsl_tpm.c ****     /* Wait till mode change to disable channel is acknowledged */
 685:../drivers/fsl_tpm.c ****     while ((base->CONTROLS[1].CnSC & (TPM_CnSC_MSA_MASK | TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK | 
 686:../drivers/fsl_tpm.c ****     {
 687:../drivers/fsl_tpm.c ****     }
 688:../drivers/fsl_tpm.c ****     /* Set Phase B filter value */
 689:../drivers/fsl_tpm.c ****     reg = base->FILTER;
 690:../drivers/fsl_tpm.c ****     reg &= ~(TPM_FILTER_CH1FVAL_MASK);
 691:../drivers/fsl_tpm.c ****     reg |= TPM_FILTER_CH1FVAL(phaseBParams->phaseFilterVal);
 692:../drivers/fsl_tpm.c ****     base->FILTER = reg;
 693:../drivers/fsl_tpm.c **** #if defined(FSL_FEATURE_TPM_HAS_POL) && FSL_FEATURE_TPM_HAS_POL
 694:../drivers/fsl_tpm.c ****     /* Set Phase B polarity */
 695:../drivers/fsl_tpm.c ****     if (phaseBParams->phasePolarity)
 696:../drivers/fsl_tpm.c ****     {
 697:../drivers/fsl_tpm.c ****         base->POL |= TPM_POL_POL1_MASK;
 698:../drivers/fsl_tpm.c ****     }
 699:../drivers/fsl_tpm.c ****     else
 700:../drivers/fsl_tpm.c ****     {
 701:../drivers/fsl_tpm.c ****         base->POL &= ~TPM_POL_POL1_MASK;
 702:../drivers/fsl_tpm.c ****     }
 703:../drivers/fsl_tpm.c **** #endif
 704:../drivers/fsl_tpm.c **** 
 705:../drivers/fsl_tpm.c ****     /* Set Quadrature mode */
 706:../drivers/fsl_tpm.c ****     reg = base->QDCTRL;
 707:../drivers/fsl_tpm.c ****     reg &= ~(TPM_QDCTRL_QUADMODE_MASK);
 708:../drivers/fsl_tpm.c ****     reg |= TPM_QDCTRL_QUADMODE(quadMode);
 709:../drivers/fsl_tpm.c ****     base->QDCTRL = reg;
 710:../drivers/fsl_tpm.c **** 
 711:../drivers/fsl_tpm.c ****     /* Enable Quad decode */
 712:../drivers/fsl_tpm.c ****     base->QDCTRL |= TPM_QDCTRL_QUADEN_MASK;
 713:../drivers/fsl_tpm.c **** }
 714:../drivers/fsl_tpm.c **** 
 715:../drivers/fsl_tpm.c **** #endif
 716:../drivers/fsl_tpm.c **** 
 717:../drivers/fsl_tpm.c **** void TPM_EnableInterrupts(TPM_Type *base, uint32_t mask)
 718:../drivers/fsl_tpm.c **** {
 812              		.loc 1 718 0
 813              		.cfi_startproc
 814              		@ args = 0, pretend = 0, frame = 0
 815              		@ frame_needed = 0, uses_anonymous_args = 0
 816              	.LVL76:
 817 0000 30B5     		push	{r4, r5, lr}
 818              		.cfi_def_cfa_offset 12
 819              		.cfi_offset 4, -12
 820              		.cfi_offset 5, -8
 821              		.cfi_offset 14, -4
 719:../drivers/fsl_tpm.c ****     uint32_t chnlInterrupts = (mask & 0xFF);
 822              		.loc 1 719 0
 823 0002 FF23     		movs	r3, #255
 824 0004 0B40     		ands	r3, r1
 825              	.LVL77:
 720:../drivers/fsl_tpm.c ****     uint8_t chnlNumber = 0;
 721:../drivers/fsl_tpm.c **** 
 722:../drivers/fsl_tpm.c ****     /* Enable the timer overflow interrupt */
 723:../drivers/fsl_tpm.c ****     if (mask & kTPM_TimeOverflowInterruptEnable)
 826              		.loc 1 723 0
 827 0006 CA05     		lsls	r2, r1, #23
 828 0008 03D5     		bpl	.L47
 724:../drivers/fsl_tpm.c ****     {
 725:../drivers/fsl_tpm.c ****         base->SC |= TPM_SC_TOIE_MASK;
 829              		.loc 1 725 0
 830 000a 0268     		ldr	r2, [r0]
 831 000c 4021     		movs	r1, #64
 832              	.LVL78:
 833 000e 0A43     		orrs	r2, r1
 834 0010 0260     		str	r2, [r0]
 835              	.L47:
 718:../drivers/fsl_tpm.c ****     uint32_t chnlInterrupts = (mask & 0xFF);
 836              		.loc 1 718 0
 837 0012 0022     		movs	r2, #0
 838 0014 02E0     		b	.L48
 839              	.LVL79:
 840              	.L49:
 726:../drivers/fsl_tpm.c ****     }
 727:../drivers/fsl_tpm.c **** 
 728:../drivers/fsl_tpm.c ****     /* Enable the channel interrupts */
 729:../drivers/fsl_tpm.c ****     while (chnlInterrupts)
 730:../drivers/fsl_tpm.c ****     {
 731:../drivers/fsl_tpm.c ****         if (chnlInterrupts & 0x1)
 732:../drivers/fsl_tpm.c ****         {
 733:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlNumber].CnSC |= TPM_CnSC_CHIE_MASK;
 734:../drivers/fsl_tpm.c ****         }
 735:../drivers/fsl_tpm.c ****         chnlNumber++;
 841              		.loc 1 735 0
 842 0016 0132     		adds	r2, r2, #1
 843              	.LVL80:
 844 0018 D2B2     		uxtb	r2, r2
 845              	.LVL81:
 736:../drivers/fsl_tpm.c ****         chnlInterrupts = chnlInterrupts >> 1U;
 846              		.loc 1 736 0
 847 001a 5B08     		lsrs	r3, r3, #1
 848              	.LVL82:
 849              	.L48:
 729:../drivers/fsl_tpm.c ****     {
 850              		.loc 1 729 0
 851 001c 002B     		cmp	r3, #0
 852 001e 09D0     		beq	.L51
 731:../drivers/fsl_tpm.c ****         {
 853              		.loc 1 731 0
 854 0020 D907     		lsls	r1, r3, #31
 855 0022 F8D5     		bpl	.L49
 733:../drivers/fsl_tpm.c ****         }
 856              		.loc 1 733 0
 857 0024 511C     		adds	r1, r2, #1
 858 0026 C900     		lsls	r1, r1, #3
 859 0028 4118     		adds	r1, r0, r1
 860 002a 4C68     		ldr	r4, [r1, #4]
 861 002c 4025     		movs	r5, #64
 862 002e 2C43     		orrs	r4, r5
 863 0030 4C60     		str	r4, [r1, #4]
 864 0032 F0E7     		b	.L49
 865              	.L51:
 737:../drivers/fsl_tpm.c ****     }
 738:../drivers/fsl_tpm.c **** }
 866              		.loc 1 738 0
 867              		@ sp needed
 868 0034 30BD     		pop	{r4, r5, pc}
 869              		.cfi_endproc
 870              	.LFE68:
 872              		.section	.text.TPM_DisableInterrupts,"ax",%progbits
 873              		.align	1
 874              		.global	TPM_DisableInterrupts
 875              		.syntax unified
 876              		.code	16
 877              		.thumb_func
 878              		.fpu softvfp
 880              	TPM_DisableInterrupts:
 881              	.LFB69:
 739:../drivers/fsl_tpm.c **** 
 740:../drivers/fsl_tpm.c **** void TPM_DisableInterrupts(TPM_Type *base, uint32_t mask)
 741:../drivers/fsl_tpm.c **** {
 882              		.loc 1 741 0
 883              		.cfi_startproc
 884              		@ args = 0, pretend = 0, frame = 0
 885              		@ frame_needed = 0, uses_anonymous_args = 0
 886              	.LVL83:
 887 0000 30B5     		push	{r4, r5, lr}
 888              		.cfi_def_cfa_offset 12
 889              		.cfi_offset 4, -12
 890              		.cfi_offset 5, -8
 891              		.cfi_offset 14, -4
 742:../drivers/fsl_tpm.c ****     uint32_t chnlInterrupts = (mask & 0xFF);
 892              		.loc 1 742 0
 893 0002 FF23     		movs	r3, #255
 894 0004 0B40     		ands	r3, r1
 895              	.LVL84:
 743:../drivers/fsl_tpm.c ****     uint8_t chnlNumber = 0;
 744:../drivers/fsl_tpm.c **** 
 745:../drivers/fsl_tpm.c ****     /* Disable the timer overflow interrupt */
 746:../drivers/fsl_tpm.c ****     if (mask & kTPM_TimeOverflowInterruptEnable)
 896              		.loc 1 746 0
 897 0006 CA05     		lsls	r2, r1, #23
 898 0008 03D5     		bpl	.L53
 747:../drivers/fsl_tpm.c ****     {
 748:../drivers/fsl_tpm.c ****         base->SC &= ~TPM_SC_TOIE_MASK;
 899              		.loc 1 748 0
 900 000a 0268     		ldr	r2, [r0]
 901 000c 4021     		movs	r1, #64
 902              	.LVL85:
 903 000e 8A43     		bics	r2, r1
 904 0010 0260     		str	r2, [r0]
 905              	.L53:
 741:../drivers/fsl_tpm.c ****     uint32_t chnlInterrupts = (mask & 0xFF);
 906              		.loc 1 741 0
 907 0012 0022     		movs	r2, #0
 908 0014 02E0     		b	.L54
 909              	.LVL86:
 910              	.L55:
 749:../drivers/fsl_tpm.c ****     }
 750:../drivers/fsl_tpm.c **** 
 751:../drivers/fsl_tpm.c ****     /* Disable the channel interrupts */
 752:../drivers/fsl_tpm.c ****     while (chnlInterrupts)
 753:../drivers/fsl_tpm.c ****     {
 754:../drivers/fsl_tpm.c ****         if (chnlInterrupts & 0x1)
 755:../drivers/fsl_tpm.c ****         {
 756:../drivers/fsl_tpm.c ****             base->CONTROLS[chnlNumber].CnSC &= ~TPM_CnSC_CHIE_MASK;
 757:../drivers/fsl_tpm.c ****         }
 758:../drivers/fsl_tpm.c ****         chnlNumber++;
 911              		.loc 1 758 0
 912 0016 0132     		adds	r2, r2, #1
 913              	.LVL87:
 914 0018 D2B2     		uxtb	r2, r2
 915              	.LVL88:
 759:../drivers/fsl_tpm.c ****         chnlInterrupts = chnlInterrupts >> 1U;
 916              		.loc 1 759 0
 917 001a 5B08     		lsrs	r3, r3, #1
 918              	.LVL89:
 919              	.L54:
 752:../drivers/fsl_tpm.c ****     {
 920              		.loc 1 752 0
 921 001c 002B     		cmp	r3, #0
 922 001e 09D0     		beq	.L57
 754:../drivers/fsl_tpm.c ****         {
 923              		.loc 1 754 0
 924 0020 D907     		lsls	r1, r3, #31
 925 0022 F8D5     		bpl	.L55
 756:../drivers/fsl_tpm.c ****         }
 926              		.loc 1 756 0
 927 0024 511C     		adds	r1, r2, #1
 928 0026 C900     		lsls	r1, r1, #3
 929 0028 4118     		adds	r1, r0, r1
 930 002a 4C68     		ldr	r4, [r1, #4]
 931 002c 4025     		movs	r5, #64
 932 002e AC43     		bics	r4, r5
 933 0030 4C60     		str	r4, [r1, #4]
 934 0032 F0E7     		b	.L55
 935              	.L57:
 760:../drivers/fsl_tpm.c ****     }
 761:../drivers/fsl_tpm.c **** }
 936              		.loc 1 761 0
 937              		@ sp needed
 938 0034 30BD     		pop	{r4, r5, pc}
 939              		.cfi_endproc
 940              	.LFE69:
 942              		.section	.text.TPM_GetEnabledInterrupts,"ax",%progbits
 943              		.align	1
 944              		.global	TPM_GetEnabledInterrupts
 945              		.syntax unified
 946              		.code	16
 947              		.thumb_func
 948              		.fpu softvfp
 950              	TPM_GetEnabledInterrupts:
 951              	.LFB70:
 762:../drivers/fsl_tpm.c **** 
 763:../drivers/fsl_tpm.c **** uint32_t TPM_GetEnabledInterrupts(TPM_Type *base)
 764:../drivers/fsl_tpm.c **** {
 952              		.loc 1 764 0
 953              		.cfi_startproc
 954              		@ args = 0, pretend = 0, frame = 0
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956              		@ link register save eliminated.
 957              	.LVL90:
 958 0000 0100     		movs	r1, r0
 959              	.LVL91:
 765:../drivers/fsl_tpm.c ****     uint32_t enabledInterrupts = 0;
 766:../drivers/fsl_tpm.c ****     int8_t chnlCount = FSL_FEATURE_TPM_CHANNEL_COUNTn(base);
 960              		.loc 1 766 0
 961 0002 134B     		ldr	r3, .L70
 962 0004 9842     		cmp	r0, r3
 963 0006 1BD0     		beq	.L64
 964              		.loc 1 766 0 is_stmt 0 discriminator 1
 965 0008 124B     		ldr	r3, .L70+4
 966 000a 9842     		cmp	r0, r3
 967 000c 1AD0     		beq	.L65
 968              		.loc 1 766 0 discriminator 3
 969 000e 124B     		ldr	r3, .L70+8
 970 0010 9842     		cmp	r0, r3
 971 0012 13D0     		beq	.L68
 972              		.loc 1 766 0
 973 0014 0123     		movs	r3, #1
 974 0016 5B42     		rsbs	r3, r3, #0
 975              	.L59:
 976              	.LVL92:
 767:../drivers/fsl_tpm.c **** 
 768:../drivers/fsl_tpm.c ****     /* The CHANNEL_COUNT macro returns -1 if it cannot match the TPM instance */
 769:../drivers/fsl_tpm.c ****     assert(chnlCount != -1);
 770:../drivers/fsl_tpm.c **** 
 771:../drivers/fsl_tpm.c ****     /* Check if timer overflow interrupt is enabled */
 772:../drivers/fsl_tpm.c ****     if (base->SC & TPM_SC_TOIE_MASK)
 977              		.loc 1 772 0 is_stmt 1 discriminator 12
 978 0018 0A68     		ldr	r2, [r1]
 979 001a 5206     		lsls	r2, r2, #25
 980 001c 14D4     		bmi	.L67
 765:../drivers/fsl_tpm.c ****     uint32_t enabledInterrupts = 0;
 981              		.loc 1 765 0
 982 001e 0020     		movs	r0, #0
 983              	.LVL93:
 984              	.L61:
 773:../drivers/fsl_tpm.c ****     {
 774:../drivers/fsl_tpm.c ****         enabledInterrupts |= kTPM_TimeOverflowInterruptEnable;
 775:../drivers/fsl_tpm.c ****     }
 776:../drivers/fsl_tpm.c **** 
 777:../drivers/fsl_tpm.c ****     /* Check if the channel interrupts are enabled */
 778:../drivers/fsl_tpm.c ****     while (chnlCount > 0)
 985              		.loc 1 778 0
 986 0020 002B     		cmp	r3, #0
 987 0022 14DD     		ble	.L69
 779:../drivers/fsl_tpm.c ****     {
 780:../drivers/fsl_tpm.c ****         chnlCount--;
 988              		.loc 1 780 0
 989 0024 013B     		subs	r3, r3, #1
 990              	.LVL94:
 991 0026 5BB2     		sxtb	r3, r3
 992              	.LVL95:
 781:../drivers/fsl_tpm.c ****         if (base->CONTROLS[chnlCount].CnSC & TPM_CnSC_CHIE_MASK)
 993              		.loc 1 781 0
 994 0028 5A1C     		adds	r2, r3, #1
 995 002a D200     		lsls	r2, r2, #3
 996 002c 8A18     		adds	r2, r1, r2
 997 002e 5268     		ldr	r2, [r2, #4]
 998 0030 5206     		lsls	r2, r2, #25
 999 0032 F5D5     		bpl	.L61
 782:../drivers/fsl_tpm.c ****         {
 783:../drivers/fsl_tpm.c ****             enabledInterrupts |= (1U << chnlCount);
 1000              		.loc 1 783 0
 1001 0034 0122     		movs	r2, #1
 1002 0036 9A40     		lsls	r2, r2, r3
 1003 0038 1043     		orrs	r0, r2
 1004              	.LVL96:
 1005 003a F1E7     		b	.L61
 1006              	.LVL97:
 1007              	.L68:
 766:../drivers/fsl_tpm.c **** 
 1008              		.loc 1 766 0
 1009 003c 0223     		movs	r3, #2
 1010 003e EBE7     		b	.L59
 1011              	.L64:
 1012 0040 0623     		movs	r3, #6
 1013 0042 E9E7     		b	.L59
 1014              	.L65:
 1015 0044 0223     		movs	r3, #2
 1016 0046 E7E7     		b	.L59
 1017              	.LVL98:
 1018              	.L67:
 774:../drivers/fsl_tpm.c ****     }
 1019              		.loc 1 774 0
 1020 0048 8020     		movs	r0, #128
 1021              	.LVL99:
 1022 004a 4000     		lsls	r0, r0, #1
 1023 004c E8E7     		b	.L61
 1024              	.LVL100:
 1025              	.L69:
 784:../drivers/fsl_tpm.c ****         }
 785:../drivers/fsl_tpm.c ****     }
 786:../drivers/fsl_tpm.c **** 
 787:../drivers/fsl_tpm.c ****     return enabledInterrupts;
 788:../drivers/fsl_tpm.c **** }
 1026              		.loc 1 788 0
 1027              		@ sp needed
 1028 004e 7047     		bx	lr
 1029              	.L71:
 1030              		.align	2
 1031              	.L70:
 1032 0050 00800340 		.word	1073971200
 1033 0054 00900340 		.word	1073975296
 1034 0058 00A00340 		.word	1073979392
 1035              		.cfi_endproc
 1036              	.LFE70:
 1038              		.section	.rodata.s_tpmBases,"a",%progbits
 1039              		.align	2
 1040              		.set	.LANCHOR0,. + 0
 1043              	s_tpmBases:
 1044 0000 00800340 		.word	1073971200
 1045 0004 00900340 		.word	1073975296
 1046 0008 00A00340 		.word	1073979392
 1047              		.section	.rodata.s_tpmClocks,"a",%progbits
 1048              		.align	2
 1049              		.set	.LANCHOR1,. + 0
 1052              	s_tpmClocks:
 1053 0000 18003C10 		.word	272367640
 1054 0004 19003C10 		.word	272367641
 1055 0008 1A003C10 		.word	272367642
 1056              		.text
 1057              	.Letext0:
 1058              		.file 3 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1059              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1060              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1061              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1062              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1063              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1064              		.file 9 "../CMSIS/system_MKL17Z4.h"
 1065              		.file 10 "../CMSIS/MKL17Z4.h"
 1066              		.file 11 "../drivers/fsl_common.h"
 1067              		.file 12 "../drivers/fsl_tpm.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_tpm.c
     /tmp/ccuuiFXJ.s:16     .text.TPM_GetInstance:0000000000000000 $t
     /tmp/ccuuiFXJ.s:22     .text.TPM_GetInstance:0000000000000000 TPM_GetInstance
     /tmp/ccuuiFXJ.s:57     .text.TPM_GetInstance:0000000000000018 $d
     /tmp/ccuuiFXJ.s:62     .text.TPM_Init:0000000000000000 $t
     /tmp/ccuuiFXJ.s:69     .text.TPM_Init:0000000000000000 TPM_Init
     /tmp/ccuuiFXJ.s:207    .text.TPM_Init:00000000000000ac $d
     /tmp/ccuuiFXJ.s:213    .text.TPM_Deinit:0000000000000000 $t
     /tmp/ccuuiFXJ.s:220    .text.TPM_Deinit:0000000000000000 TPM_Deinit
     /tmp/ccuuiFXJ.s:270    .text.TPM_Deinit:000000000000002c $d
     /tmp/ccuuiFXJ.s:276    .text.TPM_GetDefaultConfig:0000000000000000 $t
     /tmp/ccuuiFXJ.s:283    .text.TPM_GetDefaultConfig:0000000000000000 TPM_GetDefaultConfig
     /tmp/ccuuiFXJ.s:320    .text.TPM_SetupPwm:0000000000000000 $t
     /tmp/ccuuiFXJ.s:327    .text.TPM_SetupPwm:0000000000000000 TPM_SetupPwm
     /tmp/ccuuiFXJ.s:525    .text.TPM_SetupPwm:00000000000000e0 $d
     /tmp/ccuuiFXJ.s:531    .text.TPM_UpdatePwmDutycycle:0000000000000000 $t
     /tmp/ccuuiFXJ.s:538    .text.TPM_UpdatePwmDutycycle:0000000000000000 TPM_UpdatePwmDutycycle
     /tmp/ccuuiFXJ.s:593    .text.TPM_UpdateChnlEdgeLevelSelect:0000000000000000 $t
     /tmp/ccuuiFXJ.s:600    .text.TPM_UpdateChnlEdgeLevelSelect:0000000000000000 TPM_UpdateChnlEdgeLevelSelect
     /tmp/ccuuiFXJ.s:673    .text.TPM_SetupInputCapture:0000000000000000 $t
     /tmp/ccuuiFXJ.s:680    .text.TPM_SetupInputCapture:0000000000000000 TPM_SetupInputCapture
     /tmp/ccuuiFXJ.s:736    .text.TPM_SetupOutputCompare:0000000000000000 $t
     /tmp/ccuuiFXJ.s:743    .text.TPM_SetupOutputCompare:0000000000000000 TPM_SetupOutputCompare
     /tmp/ccuuiFXJ.s:803    .text.TPM_EnableInterrupts:0000000000000000 $t
     /tmp/ccuuiFXJ.s:810    .text.TPM_EnableInterrupts:0000000000000000 TPM_EnableInterrupts
     /tmp/ccuuiFXJ.s:873    .text.TPM_DisableInterrupts:0000000000000000 $t
     /tmp/ccuuiFXJ.s:880    .text.TPM_DisableInterrupts:0000000000000000 TPM_DisableInterrupts
     /tmp/ccuuiFXJ.s:943    .text.TPM_GetEnabledInterrupts:0000000000000000 $t
     /tmp/ccuuiFXJ.s:950    .text.TPM_GetEnabledInterrupts:0000000000000000 TPM_GetEnabledInterrupts
     /tmp/ccuuiFXJ.s:1032   .text.TPM_GetEnabledInterrupts:0000000000000050 $d
     /tmp/ccuuiFXJ.s:1039   .rodata.s_tpmBases:0000000000000000 $d
     /tmp/ccuuiFXJ.s:1043   .rodata.s_tpmBases:0000000000000000 s_tpmBases
     /tmp/ccuuiFXJ.s:1048   .rodata.s_tpmClocks:0000000000000000 $d
     /tmp/ccuuiFXJ.s:1052   .rodata.s_tpmClocks:0000000000000000 s_tpmClocks

UNDEFINED SYMBOLS
__aeabi_uidiv
__aeabi_idiv
