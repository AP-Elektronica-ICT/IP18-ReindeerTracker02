   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_flexio_uart.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.FLEXIO_UART_TransferGetRxRingBufferLength,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	FLEXIO_UART_TransferGetRxRingBufferLength:
  23              	.LFB75:
  24              		.file 1 "../drivers/fsl_flexio_uart.c"
   1:../drivers/fsl_flexio_uart.c **** /*
   2:../drivers/fsl_flexio_uart.c ****  * The Clear BSD License
   3:../drivers/fsl_flexio_uart.c ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_flexio_uart.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_flexio_uart.c ****  * All rights reserved.
   6:../drivers/fsl_flexio_uart.c ****  *
   7:../drivers/fsl_flexio_uart.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_flexio_uart.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_flexio_uart.c ****  * that the following conditions are met:
  10:../drivers/fsl_flexio_uart.c ****  *
  11:../drivers/fsl_flexio_uart.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_flexio_uart.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_flexio_uart.c ****  *
  14:../drivers/fsl_flexio_uart.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_flexio_uart.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_flexio_uart.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_flexio_uart.c ****  *
  18:../drivers/fsl_flexio_uart.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_flexio_uart.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_flexio_uart.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_flexio_uart.c ****  *
  22:../drivers/fsl_flexio_uart.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_flexio_uart.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_flexio_uart.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_flexio_uart.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_flexio_uart.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_flexio_uart.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_flexio_uart.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_flexio_uart.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_flexio_uart.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_flexio_uart.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_flexio_uart.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_flexio_uart.c ****  */
  34:../drivers/fsl_flexio_uart.c **** 
  35:../drivers/fsl_flexio_uart.c **** #include "fsl_flexio_uart.h"
  36:../drivers/fsl_flexio_uart.c **** 
  37:../drivers/fsl_flexio_uart.c **** /*******************************************************************************
  38:../drivers/fsl_flexio_uart.c ****  * Definitions
  39:../drivers/fsl_flexio_uart.c ****  ******************************************************************************/
  40:../drivers/fsl_flexio_uart.c **** 
  41:../drivers/fsl_flexio_uart.c **** /*<! @brief uart transfer state. */
  42:../drivers/fsl_flexio_uart.c **** enum _flexio_uart_transfer_states
  43:../drivers/fsl_flexio_uart.c **** {
  44:../drivers/fsl_flexio_uart.c ****     kFLEXIO_UART_TxIdle, /* TX idle. */
  45:../drivers/fsl_flexio_uart.c ****     kFLEXIO_UART_TxBusy, /* TX busy. */
  46:../drivers/fsl_flexio_uart.c ****     kFLEXIO_UART_RxIdle, /* RX idle. */
  47:../drivers/fsl_flexio_uart.c ****     kFLEXIO_UART_RxBusy  /* RX busy. */
  48:../drivers/fsl_flexio_uart.c **** };
  49:../drivers/fsl_flexio_uart.c **** 
  50:../drivers/fsl_flexio_uart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
  51:../drivers/fsl_flexio_uart.c **** extern const clock_ip_name_t s_flexioClocks[];
  52:../drivers/fsl_flexio_uart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
  53:../drivers/fsl_flexio_uart.c **** 
  54:../drivers/fsl_flexio_uart.c **** extern FLEXIO_Type *const s_flexioBases[];
  55:../drivers/fsl_flexio_uart.c **** 
  56:../drivers/fsl_flexio_uart.c **** /*******************************************************************************
  57:../drivers/fsl_flexio_uart.c ****  * Prototypes
  58:../drivers/fsl_flexio_uart.c ****  ******************************************************************************/
  59:../drivers/fsl_flexio_uart.c **** 
  60:../drivers/fsl_flexio_uart.c **** extern uint32_t FLEXIO_GetInstance(FLEXIO_Type *base);
  61:../drivers/fsl_flexio_uart.c **** 
  62:../drivers/fsl_flexio_uart.c **** /*!
  63:../drivers/fsl_flexio_uart.c ****  * @brief Get the length of received data in RX ring buffer.
  64:../drivers/fsl_flexio_uart.c ****  *
  65:../drivers/fsl_flexio_uart.c ****  * @param handle FLEXIO UART handle pointer.
  66:../drivers/fsl_flexio_uart.c ****  * @return Length of received data in RX ring buffer.
  67:../drivers/fsl_flexio_uart.c ****  */
  68:../drivers/fsl_flexio_uart.c **** static size_t FLEXIO_UART_TransferGetRxRingBufferLength(flexio_uart_handle_t *handle);
  69:../drivers/fsl_flexio_uart.c **** 
  70:../drivers/fsl_flexio_uart.c **** /*!
  71:../drivers/fsl_flexio_uart.c ****  * @brief Check whether the RX ring buffer is full.
  72:../drivers/fsl_flexio_uart.c ****  *
  73:../drivers/fsl_flexio_uart.c ****  * @param handle FLEXIO UART handle pointer.
  74:../drivers/fsl_flexio_uart.c ****  * @retval true  RX ring buffer is full.
  75:../drivers/fsl_flexio_uart.c ****  * @retval false RX ring buffer is not full.
  76:../drivers/fsl_flexio_uart.c ****  */
  77:../drivers/fsl_flexio_uart.c **** static bool FLEXIO_UART_TransferIsRxRingBufferFull(flexio_uart_handle_t *handle);
  78:../drivers/fsl_flexio_uart.c **** 
  79:../drivers/fsl_flexio_uart.c **** /*******************************************************************************
  80:../drivers/fsl_flexio_uart.c ****  * Codes
  81:../drivers/fsl_flexio_uart.c ****  ******************************************************************************/
  82:../drivers/fsl_flexio_uart.c **** 
  83:../drivers/fsl_flexio_uart.c **** uint32_t FLEXIO_UART_GetInstance(FLEXIO_UART_Type *base)
  84:../drivers/fsl_flexio_uart.c **** {
  85:../drivers/fsl_flexio_uart.c ****     return FLEXIO_GetInstance(base->flexioBase);
  86:../drivers/fsl_flexio_uart.c **** }
  87:../drivers/fsl_flexio_uart.c **** 
  88:../drivers/fsl_flexio_uart.c **** static size_t FLEXIO_UART_TransferGetRxRingBufferLength(flexio_uart_handle_t *handle)
  89:../drivers/fsl_flexio_uart.c **** {
  25              		.loc 1 89 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
  90:../drivers/fsl_flexio_uart.c ****     size_t size;
  91:../drivers/fsl_flexio_uart.c **** 
  92:../drivers/fsl_flexio_uart.c ****     if (handle->rxRingBufferTail > handle->rxRingBufferHead)
  31              		.loc 1 92 0
  32 0000 428C     		ldrh	r2, [r0, #34]
  33 0002 92B2     		uxth	r2, r2
  34 0004 038C     		ldrh	r3, [r0, #32]
  35 0006 9BB2     		uxth	r3, r3
  36 0008 9A42     		cmp	r2, r3
  37 000a 03D8     		bhi	.L4
  93:../drivers/fsl_flexio_uart.c ****     {
  94:../drivers/fsl_flexio_uart.c ****         size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferT
  95:../drivers/fsl_flexio_uart.c ****     }
  96:../drivers/fsl_flexio_uart.c ****     else
  97:../drivers/fsl_flexio_uart.c ****     {
  98:../drivers/fsl_flexio_uart.c ****         size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
  38              		.loc 1 98 0
  39 000c 038C     		ldrh	r3, [r0, #32]
  40 000e 408C     		ldrh	r0, [r0, #34]
  41              	.LVL1:
  42 0010 181A     		subs	r0, r3, r0
  43              	.LVL2:
  44              	.L1:
  99:../drivers/fsl_flexio_uart.c ****     }
 100:../drivers/fsl_flexio_uart.c **** 
 101:../drivers/fsl_flexio_uart.c ****     return size;
 102:../drivers/fsl_flexio_uart.c **** }
  45              		.loc 1 102 0
  46              		@ sp needed
  47 0012 7047     		bx	lr
  48              	.LVL3:
  49              	.L4:
  94:../drivers/fsl_flexio_uart.c ****     }
  50              		.loc 1 94 0
  51 0014 038C     		ldrh	r3, [r0, #32]
  52 0016 C269     		ldr	r2, [r0, #28]
  53 0018 9446     		mov	ip, r2
  54 001a 6344     		add	r3, r3, ip
  55 001c 408C     		ldrh	r0, [r0, #34]
  56              	.LVL4:
  57 001e 181A     		subs	r0, r3, r0
  58              	.LVL5:
  59 0020 F7E7     		b	.L1
  60              		.cfi_endproc
  61              	.LFE75:
  63              		.section	.text.FLEXIO_UART_TransferIsRxRingBufferFull,"ax",%progbits
  64              		.align	1
  65              		.syntax unified
  66              		.code	16
  67              		.thumb_func
  68              		.fpu softvfp
  70              	FLEXIO_UART_TransferIsRxRingBufferFull:
  71              	.LFB76:
 103:../drivers/fsl_flexio_uart.c **** 
 104:../drivers/fsl_flexio_uart.c **** static bool FLEXIO_UART_TransferIsRxRingBufferFull(flexio_uart_handle_t *handle)
 105:../drivers/fsl_flexio_uart.c **** {
  72              		.loc 1 105 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76              	.LVL6:
  77 0000 10B5     		push	{r4, lr}
  78              		.cfi_def_cfa_offset 8
  79              		.cfi_offset 4, -8
  80              		.cfi_offset 14, -4
  81 0002 0400     		movs	r4, r0
 106:../drivers/fsl_flexio_uart.c ****     bool full;
 107:../drivers/fsl_flexio_uart.c **** 
 108:../drivers/fsl_flexio_uart.c ****     if (FLEXIO_UART_TransferGetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
  82              		.loc 1 108 0
  83 0004 FFF7FEFF 		bl	FLEXIO_UART_TransferGetRxRingBufferLength
  84              	.LVL7:
  85 0008 E369     		ldr	r3, [r4, #28]
  86 000a 013B     		subs	r3, r3, #1
  87 000c 9842     		cmp	r0, r3
  88 000e 01D0     		beq	.L8
 109:../drivers/fsl_flexio_uart.c ****     {
 110:../drivers/fsl_flexio_uart.c ****         full = true;
 111:../drivers/fsl_flexio_uart.c ****     }
 112:../drivers/fsl_flexio_uart.c ****     else
 113:../drivers/fsl_flexio_uart.c ****     {
 114:../drivers/fsl_flexio_uart.c ****         full = false;
  89              		.loc 1 114 0
  90 0010 0020     		movs	r0, #0
  91              	.L6:
  92              	.LVL8:
 115:../drivers/fsl_flexio_uart.c ****     }
 116:../drivers/fsl_flexio_uart.c **** 
 117:../drivers/fsl_flexio_uart.c ****     return full;
 118:../drivers/fsl_flexio_uart.c **** }
  93              		.loc 1 118 0
  94              		@ sp needed
  95              	.LVL9:
  96 0012 10BD     		pop	{r4, pc}
  97              	.LVL10:
  98              	.L8:
 110:../drivers/fsl_flexio_uart.c ****     }
  99              		.loc 1 110 0
 100 0014 0120     		movs	r0, #1
 101 0016 FCE7     		b	.L6
 102              		.cfi_endproc
 103              	.LFE76:
 105              		.section	.text.FLEXIO_UART_GetInstance,"ax",%progbits
 106              		.align	1
 107              		.global	FLEXIO_UART_GetInstance
 108              		.syntax unified
 109              		.code	16
 110              		.thumb_func
 111              		.fpu softvfp
 113              	FLEXIO_UART_GetInstance:
 114              	.LFB74:
  84:../drivers/fsl_flexio_uart.c ****     return FLEXIO_GetInstance(base->flexioBase);
 115              		.loc 1 84 0
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              	.LVL11:
 120 0000 10B5     		push	{r4, lr}
 121              		.cfi_def_cfa_offset 8
 122              		.cfi_offset 4, -8
 123              		.cfi_offset 14, -4
  85:../drivers/fsl_flexio_uart.c **** }
 124              		.loc 1 85 0
 125 0002 0068     		ldr	r0, [r0]
 126              	.LVL12:
 127 0004 FFF7FEFF 		bl	FLEXIO_GetInstance
 128              	.LVL13:
  86:../drivers/fsl_flexio_uart.c **** 
 129              		.loc 1 86 0
 130              		@ sp needed
 131 0008 10BD     		pop	{r4, pc}
 132              		.cfi_endproc
 133              	.LFE74:
 135              		.global	__aeabi_uidiv
 136              		.section	.text.FLEXIO_UART_Init,"ax",%progbits
 137              		.align	1
 138              		.global	FLEXIO_UART_Init
 139              		.syntax unified
 140              		.code	16
 141              		.thumb_func
 142              		.fpu softvfp
 144              	FLEXIO_UART_Init:
 145              	.LFB77:
 119:../drivers/fsl_flexio_uart.c **** 
 120:../drivers/fsl_flexio_uart.c **** status_t FLEXIO_UART_Init(FLEXIO_UART_Type *base, const flexio_uart_config_t *userConfig, uint32_t 
 121:../drivers/fsl_flexio_uart.c **** {
 146              		.loc 1 121 0
 147              		.cfi_startproc
 148              		@ args = 0, pretend = 0, frame = 56
 149              		@ frame_needed = 0, uses_anonymous_args = 0
 150              	.LVL14:
 151 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 152              		.cfi_def_cfa_offset 20
 153              		.cfi_offset 4, -20
 154              		.cfi_offset 5, -16
 155              		.cfi_offset 6, -12
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 CE46     		mov	lr, r9
 159 0004 00B5     		push	{lr}
 160              		.cfi_def_cfa_offset 24
 161              		.cfi_offset 9, -24
 162 0006 8EB0     		sub	sp, sp, #56
 163              		.cfi_def_cfa_offset 80
 164 0008 0400     		movs	r4, r0
 165 000a 0E00     		movs	r6, r1
 166 000c 0192     		str	r2, [sp, #4]
 167              	.LVL15:
 122:../drivers/fsl_flexio_uart.c ****     assert(base && userConfig);
 123:../drivers/fsl_flexio_uart.c **** 
 124:../drivers/fsl_flexio_uart.c ****     flexio_shifter_config_t shifterConfig;
 125:../drivers/fsl_flexio_uart.c ****     flexio_timer_config_t timerConfig;
 126:../drivers/fsl_flexio_uart.c ****     uint32_t ctrlReg = 0;
 127:../drivers/fsl_flexio_uart.c ****     uint16_t timerDiv = 0;
 128:../drivers/fsl_flexio_uart.c ****     uint16_t timerCmp = 0;
 129:../drivers/fsl_flexio_uart.c ****     status_t result = kStatus_Success;
 130:../drivers/fsl_flexio_uart.c **** 
 131:../drivers/fsl_flexio_uart.c ****     /* Clear the shifterConfig & timerConfig struct. */
 132:../drivers/fsl_flexio_uart.c ****     memset(&shifterConfig, 0, sizeof(shifterConfig));
 168              		.loc 1 132 0
 169 000e 1422     		movs	r2, #20
 170              	.LVL16:
 171 0010 0021     		movs	r1, #0
 172              	.LVL17:
 173 0012 09A8     		add	r0, sp, #36
 174              	.LVL18:
 175 0014 FFF7FEFF 		bl	memset
 176              	.LVL19:
 133:../drivers/fsl_flexio_uart.c ****     memset(&timerConfig, 0, sizeof(timerConfig));
 177              		.loc 1 133 0
 178 0018 1C22     		movs	r2, #28
 179 001a 0021     		movs	r1, #0
 180 001c 02A8     		add	r0, sp, #8
 181 001e FFF7FEFF 		bl	memset
 182              	.LVL20:
 134:../drivers/fsl_flexio_uart.c **** 
 135:../drivers/fsl_flexio_uart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 136:../drivers/fsl_flexio_uart.c ****     /* Ungate flexio clock. */
 137:../drivers/fsl_flexio_uart.c ****     CLOCK_EnableClock(s_flexioClocks[FLEXIO_UART_GetInstance(base)]);
 183              		.loc 1 137 0
 184 0022 2000     		movs	r0, r4
 185 0024 FFF7FEFF 		bl	FLEXIO_UART_GetInstance
 186              	.LVL21:
 187 0028 8000     		lsls	r0, r0, #2
 188 002a 504B     		ldr	r3, .L14
 189 002c C358     		ldr	r3, [r0, r3]
 190              	.LVL22:
 191              	.LBB36:
 192              	.LBB37:
 193              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 194              		.loc 2 449 0
 195 002e 1A0C     		lsrs	r2, r3, #16
 196 0030 4F49     		ldr	r1, .L14+4
 197 0032 8C46     		mov	ip, r1
 198 0034 6244     		add	r2, r2, ip
 199              	.LVL23:
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 200              		.loc 2 450 0
 201 0036 1168     		ldr	r1, [r2]
 202 0038 1B04     		lsls	r3, r3, #16
 203              	.LVL24:
 204 003a 1B0C     		lsrs	r3, r3, #16
 205 003c 0120     		movs	r0, #1
 206              	.LVL25:
 207 003e 9840     		lsls	r0, r0, r3
 208 0040 0300     		movs	r3, r0
 209 0042 0B43     		orrs	r3, r1
 210 0044 1360     		str	r3, [r2]
 211              	.LVL26:
 212              	.LBE37:
 213              	.LBE36:
 138:../drivers/fsl_flexio_uart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 139:../drivers/fsl_flexio_uart.c **** 
 140:../drivers/fsl_flexio_uart.c ****     /* Configure FLEXIO UART */
 141:../drivers/fsl_flexio_uart.c ****     ctrlReg = base->flexioBase->CTRL;
 214              		.loc 1 141 0
 215 0046 2068     		ldr	r0, [r4]
 216 0048 8268     		ldr	r2, [r0, #8]
 217              	.LVL27:
 142:../drivers/fsl_flexio_uart.c ****     ctrlReg &= ~(FLEXIO_CTRL_DOZEN_MASK | FLEXIO_CTRL_DBGE_MASK | FLEXIO_CTRL_FASTACC_MASK | FLEXIO
 218              		.loc 1 142 0
 219 004a 4A4B     		ldr	r3, .L14+8
 220 004c 1A40     		ands	r2, r3
 221              	.LVL28:
 143:../drivers/fsl_flexio_uart.c ****     ctrlReg |= (FLEXIO_CTRL_DBGE(userConfig->enableInDebug) | FLEXIO_CTRL_FASTACC(userConfig->enabl
 222              		.loc 1 143 0
 223 004e B378     		ldrb	r3, [r6, #2]
 224 0050 9B07     		lsls	r3, r3, #30
 225 0052 8021     		movs	r1, #128
 226 0054 C905     		lsls	r1, r1, #23
 227 0056 0B40     		ands	r3, r1
 228 0058 F778     		ldrb	r7, [r6, #3]
 229 005a BF00     		lsls	r7, r7, #2
 230 005c 0421     		movs	r1, #4
 231 005e 3940     		ands	r1, r7
 232 0060 0B43     		orrs	r3, r1
 144:../drivers/fsl_flexio_uart.c ****                 FLEXIO_CTRL_FLEXEN(userConfig->enableUart));
 233              		.loc 1 144 0
 234 0062 3178     		ldrb	r1, [r6]
 143:../drivers/fsl_flexio_uart.c ****     ctrlReg |= (FLEXIO_CTRL_DBGE(userConfig->enableInDebug) | FLEXIO_CTRL_FASTACC(userConfig->enabl
 235              		.loc 1 143 0
 236 0064 0B43     		orrs	r3, r1
 237 0066 1343     		orrs	r3, r2
 238              	.LVL29:
 145:../drivers/fsl_flexio_uart.c ****     if (!userConfig->enableInDoze)
 239              		.loc 1 145 0
 240 0068 7278     		ldrb	r2, [r6, #1]
 241 006a 002A     		cmp	r2, #0
 242 006c 02D1     		bne	.L11
 146:../drivers/fsl_flexio_uart.c ****     {
 147:../drivers/fsl_flexio_uart.c ****         ctrlReg |= FLEXIO_CTRL_DOZEN_MASK;
 243              		.loc 1 147 0
 244 006e 8022     		movs	r2, #128
 245 0070 1206     		lsls	r2, r2, #24
 246 0072 1343     		orrs	r3, r2
 247              	.LVL30:
 248              	.L11:
 148:../drivers/fsl_flexio_uart.c ****     }
 149:../drivers/fsl_flexio_uart.c **** 
 150:../drivers/fsl_flexio_uart.c ****     base->flexioBase->CTRL = ctrlReg;
 249              		.loc 1 150 0
 250 0074 8360     		str	r3, [r0, #8]
 151:../drivers/fsl_flexio_uart.c **** 
 152:../drivers/fsl_flexio_uart.c ****     /* Do hardware configuration. */
 153:../drivers/fsl_flexio_uart.c ****     /* 1. Configure the shifter 0 for tx. */
 154:../drivers/fsl_flexio_uart.c ****     shifterConfig.timerSelect = base->timerIndex[0];
 251              		.loc 1 154 0
 252 0076 237A     		ldrb	r3, [r4, #8]
 253              	.LVL31:
 254 0078 09AA     		add	r2, sp, #36
 255 007a 0993     		str	r3, [sp, #36]
 155:../drivers/fsl_flexio_uart.c ****     shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive;
 256              		.loc 1 155 0
 257 007c 0027     		movs	r7, #0
 258 007e 1771     		strb	r7, [r2, #4]
 156:../drivers/fsl_flexio_uart.c ****     shifterConfig.pinConfig = kFLEXIO_PinConfigOutput;
 259              		.loc 1 156 0
 260 0080 0323     		movs	r3, #3
 261 0082 5371     		strb	r3, [r2, #5]
 157:../drivers/fsl_flexio_uart.c ****     shifterConfig.pinSelect = base->TxPinIndex;
 262              		.loc 1 157 0
 263 0084 2179     		ldrb	r1, [r4, #4]
 264 0086 9160     		str	r1, [r2, #8]
 265              	.LVL32:
 158:../drivers/fsl_flexio_uart.c ****     shifterConfig.pinPolarity = kFLEXIO_PinActiveHigh;
 266              		.loc 1 158 0
 267 0088 1773     		strb	r7, [r2, #12]
 159:../drivers/fsl_flexio_uart.c ****     shifterConfig.shifterMode = kFLEXIO_ShifterModeTransmit;
 268              		.loc 1 159 0
 269 008a 0225     		movs	r5, #2
 270 008c 5573     		strb	r5, [r2, #13]
 160:../drivers/fsl_flexio_uart.c ****     shifterConfig.inputSource = kFLEXIO_ShifterInputFromPin;
 271              		.loc 1 160 0
 272 008e 9773     		strb	r7, [r2, #14]
 161:../drivers/fsl_flexio_uart.c ****     shifterConfig.shifterStop = kFLEXIO_ShifterStopBitHigh;
 273              		.loc 1 161 0
 274 0090 D373     		strb	r3, [r2, #15]
 162:../drivers/fsl_flexio_uart.c ****     shifterConfig.shifterStart = kFLEXIO_ShifterStartBitLow;
 275              		.loc 1 162 0
 276 0092 1574     		strb	r5, [r2, #16]
 163:../drivers/fsl_flexio_uart.c **** 
 164:../drivers/fsl_flexio_uart.c ****     FLEXIO_SetShifterConfig(base->flexioBase, base->shifterIndex[0], &shifterConfig);
 277              		.loc 1 164 0
 278 0094 A179     		ldrb	r1, [r4, #6]
 279 0096 2068     		ldr	r0, [r4]
 280 0098 FFF7FEFF 		bl	FLEXIO_SetShifterConfig
 281              	.LVL33:
 165:../drivers/fsl_flexio_uart.c **** 
 166:../drivers/fsl_flexio_uart.c ****     /*2. Configure the timer 0 for tx. */
 167:../drivers/fsl_flexio_uart.c ****     timerConfig.triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(base->shifterIndex[0]);
 282              		.loc 1 167 0
 283 009c A279     		ldrb	r2, [r4, #6]
 284 009e 9200     		lsls	r2, r2, #2
 285 00a0 0123     		movs	r3, #1
 286 00a2 1A43     		orrs	r2, r3
 287 00a4 0292     		str	r2, [sp, #8]
 168:../drivers/fsl_flexio_uart.c ****     timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveLow;
 288              		.loc 1 168 0
 289 00a6 02AA     		add	r2, sp, #8
 290 00a8 1371     		strb	r3, [r2, #4]
 169:../drivers/fsl_flexio_uart.c ****     timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceInternal;
 291              		.loc 1 169 0
 292 00aa 5371     		strb	r3, [r2, #5]
 170:../drivers/fsl_flexio_uart.c ****     timerConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 293              		.loc 1 170 0
 294 00ac 9771     		strb	r7, [r2, #6]
 171:../drivers/fsl_flexio_uart.c ****     timerConfig.pinSelect = base->TxPinIndex;
 295              		.loc 1 171 0
 296 00ae 2279     		ldrb	r2, [r4, #4]
 297 00b0 0492     		str	r2, [sp, #16]
 172:../drivers/fsl_flexio_uart.c ****     timerConfig.pinPolarity = kFLEXIO_PinActiveHigh;
 298              		.loc 1 172 0
 299 00b2 02AA     		add	r2, sp, #8
 300 00b4 1773     		strb	r7, [r2, #12]
 173:../drivers/fsl_flexio_uart.c ****     timerConfig.timerMode = kFLEXIO_TimerModeDual8BitBaudBit;
 301              		.loc 1 173 0
 302 00b6 5373     		strb	r3, [r2, #13]
 174:../drivers/fsl_flexio_uart.c ****     timerConfig.timerOutput = kFLEXIO_TimerOutputOneNotAffectedByReset;
 303              		.loc 1 174 0
 304 00b8 9773     		strb	r7, [r2, #14]
 175:../drivers/fsl_flexio_uart.c ****     timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput;
 305              		.loc 1 175 0
 306 00ba D773     		strb	r7, [r2, #15]
 176:../drivers/fsl_flexio_uart.c ****     timerConfig.timerReset = kFLEXIO_TimerResetNever;
 307              		.loc 1 176 0
 308 00bc 1774     		strb	r7, [r2, #16]
 177:../drivers/fsl_flexio_uart.c ****     timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompare;
 309              		.loc 1 177 0
 310 00be 5574     		strb	r5, [r2, #17]
 178:../drivers/fsl_flexio_uart.c ****     timerConfig.timerEnable = kFLEXIO_TimerEnableOnTriggerHigh;
 311              		.loc 1 178 0
 312 00c0 9574     		strb	r5, [r2, #18]
 179:../drivers/fsl_flexio_uart.c ****     timerConfig.timerStop = kFLEXIO_TimerStopBitEnableOnTimerDisable;
 313              		.loc 1 179 0
 314 00c2 D574     		strb	r5, [r2, #19]
 180:../drivers/fsl_flexio_uart.c ****     timerConfig.timerStart = kFLEXIO_TimerStartBitEnabled;
 315              		.loc 1 180 0
 316 00c4 1375     		strb	r3, [r2, #20]
 181:../drivers/fsl_flexio_uart.c **** 
 182:../drivers/fsl_flexio_uart.c ****     timerDiv = srcClock_Hz / userConfig->baudRate_Bps;
 317              		.loc 1 182 0
 318 00c6 7168     		ldr	r1, [r6, #4]
 319 00c8 0198     		ldr	r0, [sp, #4]
 320 00ca FFF7FEFF 		bl	__aeabi_uidiv
 321              	.LVL34:
 322 00ce 85B2     		uxth	r5, r0
 323              	.LVL35:
 183:../drivers/fsl_flexio_uart.c ****     timerDiv = timerDiv / 2 - 1;
 324              		.loc 1 183 0
 325 00d0 6D08     		lsrs	r5, r5, #1
 326              	.LVL36:
 327 00d2 013D     		subs	r5, r5, #1
 328 00d4 ADB2     		uxth	r5, r5
 329              	.LVL37:
 184:../drivers/fsl_flexio_uart.c **** 
 185:../drivers/fsl_flexio_uart.c ****     if (timerDiv > 0xFFU)
 330              		.loc 1 185 0
 331 00d6 FF2D     		cmp	r5, #255
 332 00d8 45D8     		bhi	.L13
 129:../drivers/fsl_flexio_uart.c **** 
 333              		.loc 1 129 0
 334 00da 0023     		movs	r3, #0
 335 00dc 0193     		str	r3, [sp, #4]
 336              	.LVL38:
 337              	.L12:
 186:../drivers/fsl_flexio_uart.c ****     {
 187:../drivers/fsl_flexio_uart.c ****         result = kStatus_InvalidArgument;
 188:../drivers/fsl_flexio_uart.c ****     }
 189:../drivers/fsl_flexio_uart.c **** 
 190:../drivers/fsl_flexio_uart.c ****     timerCmp = ((uint32_t)(userConfig->bitCountPerChar * 2 - 1)) << 8U;
 338              		.loc 1 190 0
 339 00de 337A     		ldrb	r3, [r6, #8]
 340 00e0 5B00     		lsls	r3, r3, #1
 341 00e2 013B     		subs	r3, r3, #1
 342 00e4 9BB2     		uxth	r3, r3
 343 00e6 1B02     		lsls	r3, r3, #8
 344 00e8 9BB2     		uxth	r3, r3
 345              	.LVL39:
 191:../drivers/fsl_flexio_uart.c ****     timerCmp |= timerDiv;
 346              		.loc 1 191 0
 347 00ea 1D43     		orrs	r5, r3
 348              	.LVL40:
 192:../drivers/fsl_flexio_uart.c **** 
 193:../drivers/fsl_flexio_uart.c ****     timerConfig.timerCompare = timerCmp;
 349              		.loc 1 193 0
 350 00ec 0895     		str	r5, [sp, #32]
 194:../drivers/fsl_flexio_uart.c **** 
 195:../drivers/fsl_flexio_uart.c ****     FLEXIO_SetTimerConfig(base->flexioBase, base->timerIndex[0], &timerConfig);
 351              		.loc 1 195 0
 352 00ee 217A     		ldrb	r1, [r4, #8]
 353 00f0 02AA     		add	r2, sp, #8
 354 00f2 2068     		ldr	r0, [r4]
 355              	.LVL41:
 356 00f4 FFF7FEFF 		bl	FLEXIO_SetTimerConfig
 357              	.LVL42:
 196:../drivers/fsl_flexio_uart.c **** 
 197:../drivers/fsl_flexio_uart.c ****     /* 3. Configure the shifter 1 for rx. */
 198:../drivers/fsl_flexio_uart.c ****     shifterConfig.timerSelect = base->timerIndex[1];
 358              		.loc 1 198 0
 359 00f8 637A     		ldrb	r3, [r4, #9]
 360 00fa 09AA     		add	r2, sp, #36
 361 00fc 0993     		str	r3, [sp, #36]
 199:../drivers/fsl_flexio_uart.c ****     shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnNegitive;
 362              		.loc 1 199 0
 363 00fe 0127     		movs	r7, #1
 364 0100 1771     		strb	r7, [r2, #4]
 200:../drivers/fsl_flexio_uart.c ****     shifterConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 365              		.loc 1 200 0
 366 0102 0026     		movs	r6, #0
 367              	.LVL43:
 368 0104 5671     		strb	r6, [r2, #5]
 201:../drivers/fsl_flexio_uart.c ****     shifterConfig.pinSelect = base->RxPinIndex;
 369              		.loc 1 201 0
 370 0106 6379     		ldrb	r3, [r4, #5]
 371 0108 9360     		str	r3, [r2, #8]
 202:../drivers/fsl_flexio_uart.c ****     shifterConfig.pinPolarity = kFLEXIO_PinActiveHigh;
 372              		.loc 1 202 0
 373 010a 1673     		strb	r6, [r2, #12]
 203:../drivers/fsl_flexio_uart.c ****     shifterConfig.shifterMode = kFLEXIO_ShifterModeReceive;
 374              		.loc 1 203 0
 375 010c 5773     		strb	r7, [r2, #13]
 204:../drivers/fsl_flexio_uart.c ****     shifterConfig.inputSource = kFLEXIO_ShifterInputFromPin;
 376              		.loc 1 204 0
 377 010e 9673     		strb	r6, [r2, #14]
 205:../drivers/fsl_flexio_uart.c ****     shifterConfig.shifterStop = kFLEXIO_ShifterStopBitHigh;
 378              		.loc 1 205 0
 379 0110 0323     		movs	r3, #3
 380 0112 D373     		strb	r3, [r2, #15]
 206:../drivers/fsl_flexio_uart.c ****     shifterConfig.shifterStart = kFLEXIO_ShifterStartBitLow;
 381              		.loc 1 206 0
 382 0114 013B     		subs	r3, r3, #1
 383 0116 9946     		mov	r9, r3
 384 0118 1374     		strb	r3, [r2, #16]
 207:../drivers/fsl_flexio_uart.c **** 
 208:../drivers/fsl_flexio_uart.c ****     FLEXIO_SetShifterConfig(base->flexioBase, base->shifterIndex[1], &shifterConfig);
 385              		.loc 1 208 0
 386 011a E179     		ldrb	r1, [r4, #7]
 387 011c 2068     		ldr	r0, [r4]
 388 011e FFF7FEFF 		bl	FLEXIO_SetShifterConfig
 389              	.LVL44:
 209:../drivers/fsl_flexio_uart.c **** 
 210:../drivers/fsl_flexio_uart.c ****     /* 4. Configure the timer 1 for rx. */
 211:../drivers/fsl_flexio_uart.c ****     timerConfig.triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_PININPUT(base->RxPinIndex);
 390              		.loc 1 211 0
 391 0122 6379     		ldrb	r3, [r4, #5]
 392 0124 5A00     		lsls	r2, r3, #1
 393 0126 0292     		str	r2, [sp, #8]
 212:../drivers/fsl_flexio_uart.c ****     timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
 394              		.loc 1 212 0
 395 0128 02AA     		add	r2, sp, #8
 396 012a 1671     		strb	r6, [r2, #4]
 213:../drivers/fsl_flexio_uart.c ****     timerConfig.triggerSource = kFLEXIO_TimerTriggerSourceExternal;
 397              		.loc 1 213 0
 398 012c 5671     		strb	r6, [r2, #5]
 214:../drivers/fsl_flexio_uart.c ****     timerConfig.pinConfig = kFLEXIO_PinConfigOutputDisabled;
 399              		.loc 1 214 0
 400 012e 9671     		strb	r6, [r2, #6]
 215:../drivers/fsl_flexio_uart.c ****     timerConfig.pinSelect = base->RxPinIndex;
 401              		.loc 1 215 0
 402 0130 0493     		str	r3, [sp, #16]
 216:../drivers/fsl_flexio_uart.c ****     timerConfig.pinPolarity = kFLEXIO_PinActiveLow;
 403              		.loc 1 216 0
 404 0132 1300     		movs	r3, r2
 405 0134 1773     		strb	r7, [r2, #12]
 217:../drivers/fsl_flexio_uart.c ****     timerConfig.timerMode = kFLEXIO_TimerModeDual8BitBaudBit;
 406              		.loc 1 217 0
 407 0136 5773     		strb	r7, [r2, #13]
 218:../drivers/fsl_flexio_uart.c ****     timerConfig.timerOutput = kFLEXIO_TimerOutputOneAffectedByReset;
 408              		.loc 1 218 0
 409 0138 4A46     		mov	r2, r9
 410 013a 9A73     		strb	r2, [r3, #14]
 219:../drivers/fsl_flexio_uart.c ****     timerConfig.timerDecrement = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput;
 411              		.loc 1 219 0
 412 013c DE73     		strb	r6, [r3, #15]
 220:../drivers/fsl_flexio_uart.c ****     timerConfig.timerReset = kFLEXIO_TimerResetOnTimerPinRisingEdge;
 413              		.loc 1 220 0
 414 013e 0423     		movs	r3, #4
 415 0140 02AA     		add	r2, sp, #8
 416 0142 1374     		strb	r3, [r2, #16]
 221:../drivers/fsl_flexio_uart.c ****     timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompare;
 417              		.loc 1 221 0
 418 0144 4946     		mov	r1, r9
 419 0146 5174     		strb	r1, [r2, #17]
 222:../drivers/fsl_flexio_uart.c ****     timerConfig.timerEnable = kFLEXIO_TimerEnableOnPinRisingEdge;
 420              		.loc 1 222 0
 421 0148 9374     		strb	r3, [r2, #18]
 223:../drivers/fsl_flexio_uart.c ****     timerConfig.timerStop = kFLEXIO_TimerStopBitEnableOnTimerDisable;
 422              		.loc 1 223 0
 423 014a 1300     		movs	r3, r2
 424 014c D974     		strb	r1, [r3, #19]
 224:../drivers/fsl_flexio_uart.c ****     timerConfig.timerStart = kFLEXIO_TimerStartBitEnabled;
 425              		.loc 1 224 0
 426 014e 1F75     		strb	r7, [r3, #20]
 225:../drivers/fsl_flexio_uart.c **** 
 226:../drivers/fsl_flexio_uart.c ****     timerConfig.timerCompare = timerCmp;
 427              		.loc 1 226 0
 428 0150 0895     		str	r5, [sp, #32]
 227:../drivers/fsl_flexio_uart.c **** 
 228:../drivers/fsl_flexio_uart.c ****     FLEXIO_SetTimerConfig(base->flexioBase, base->timerIndex[1], &timerConfig);
 429              		.loc 1 228 0
 430 0152 617A     		ldrb	r1, [r4, #9]
 431 0154 2068     		ldr	r0, [r4]
 432 0156 1A00     		movs	r2, r3
 433 0158 FFF7FEFF 		bl	FLEXIO_SetTimerConfig
 434              	.LVL45:
 229:../drivers/fsl_flexio_uart.c **** 
 230:../drivers/fsl_flexio_uart.c ****     return result;
 231:../drivers/fsl_flexio_uart.c **** }
 435              		.loc 1 231 0
 436 015c 0198     		ldr	r0, [sp, #4]
 437 015e 0EB0     		add	sp, sp, #56
 438              		@ sp needed
 439              	.LVL46:
 440              	.LVL47:
 441 0160 04BC     		pop	{r2}
 442 0162 9146     		mov	r9, r2
 443 0164 F0BD     		pop	{r4, r5, r6, r7, pc}
 444              	.LVL48:
 445              	.L13:
 187:../drivers/fsl_flexio_uart.c ****     }
 446              		.loc 1 187 0
 447 0166 0423     		movs	r3, #4
 448 0168 0193     		str	r3, [sp, #4]
 449              	.LVL49:
 450 016a B8E7     		b	.L12
 451              	.L15:
 452              		.align	2
 453              	.L14:
 454 016c 00000000 		.word	s_flexioClocks
 455 0170 00700440 		.word	1074032640
 456 0174 FAFFFF3F 		.word	1073741818
 457              		.cfi_endproc
 458              	.LFE77:
 460              		.section	.text.FLEXIO_UART_Deinit,"ax",%progbits
 461              		.align	1
 462              		.global	FLEXIO_UART_Deinit
 463              		.syntax unified
 464              		.code	16
 465              		.thumb_func
 466              		.fpu softvfp
 468              	FLEXIO_UART_Deinit:
 469              	.LFB78:
 232:../drivers/fsl_flexio_uart.c **** 
 233:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_Deinit(FLEXIO_UART_Type *base)
 234:../drivers/fsl_flexio_uart.c **** {
 470              		.loc 1 234 0
 471              		.cfi_startproc
 472              		@ args = 0, pretend = 0, frame = 0
 473              		@ frame_needed = 0, uses_anonymous_args = 0
 474              	.LVL50:
 475 0000 10B5     		push	{r4, lr}
 476              		.cfi_def_cfa_offset 8
 477              		.cfi_offset 4, -8
 478              		.cfi_offset 14, -4
 235:../drivers/fsl_flexio_uart.c ****     base->flexioBase->SHIFTCFG[base->shifterIndex[0]] = 0;
 479              		.loc 1 235 0
 480 0002 8279     		ldrb	r2, [r0, #6]
 481 0004 4032     		adds	r2, r2, #64
 482 0006 9200     		lsls	r2, r2, #2
 483 0008 0023     		movs	r3, #0
 484 000a 0168     		ldr	r1, [r0]
 485 000c 5350     		str	r3, [r2, r1]
 236:../drivers/fsl_flexio_uart.c ****     base->flexioBase->SHIFTCTL[base->shifterIndex[0]] = 0;
 486              		.loc 1 236 0
 487 000e 8279     		ldrb	r2, [r0, #6]
 488 0010 2032     		adds	r2, r2, #32
 489 0012 9200     		lsls	r2, r2, #2
 490 0014 0168     		ldr	r1, [r0]
 491 0016 5350     		str	r3, [r2, r1]
 237:../drivers/fsl_flexio_uart.c ****     base->flexioBase->SHIFTCFG[base->shifterIndex[1]] = 0;
 492              		.loc 1 237 0
 493 0018 C279     		ldrb	r2, [r0, #7]
 494 001a 4032     		adds	r2, r2, #64
 495 001c 9200     		lsls	r2, r2, #2
 496 001e 0168     		ldr	r1, [r0]
 497 0020 5350     		str	r3, [r2, r1]
 238:../drivers/fsl_flexio_uart.c ****     base->flexioBase->SHIFTCTL[base->shifterIndex[1]] = 0;
 498              		.loc 1 238 0
 499 0022 C279     		ldrb	r2, [r0, #7]
 500 0024 2032     		adds	r2, r2, #32
 501 0026 9200     		lsls	r2, r2, #2
 502 0028 0168     		ldr	r1, [r0]
 503 002a 5350     		str	r3, [r2, r1]
 239:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMCFG[base->timerIndex[0]] = 0;
 504              		.loc 1 239 0
 505 002c 027A     		ldrb	r2, [r0, #8]
 506 002e 2132     		adds	r2, r2, #33
 507 0030 FF32     		adds	r2, r2, #255
 508 0032 9200     		lsls	r2, r2, #2
 509 0034 0168     		ldr	r1, [r0]
 510 0036 5350     		str	r3, [r2, r1]
 240:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMCMP[base->timerIndex[0]] = 0;
 511              		.loc 1 240 0
 512 0038 027A     		ldrb	r2, [r0, #8]
 513 003a 4132     		adds	r2, r2, #65
 514 003c FF32     		adds	r2, r2, #255
 515 003e 9200     		lsls	r2, r2, #2
 516 0040 0168     		ldr	r1, [r0]
 517 0042 5350     		str	r3, [r2, r1]
 241:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMCTL[base->timerIndex[0]] = 0;
 518              		.loc 1 241 0
 519 0044 027A     		ldrb	r2, [r0, #8]
 520 0046 0132     		adds	r2, r2, #1
 521 0048 FF32     		adds	r2, r2, #255
 522 004a 9200     		lsls	r2, r2, #2
 523 004c 0168     		ldr	r1, [r0]
 524 004e 5350     		str	r3, [r2, r1]
 242:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMCFG[base->timerIndex[1]] = 0;
 525              		.loc 1 242 0
 526 0050 427A     		ldrb	r2, [r0, #9]
 527 0052 2132     		adds	r2, r2, #33
 528 0054 FF32     		adds	r2, r2, #255
 529 0056 9200     		lsls	r2, r2, #2
 530 0058 0168     		ldr	r1, [r0]
 531 005a 5350     		str	r3, [r2, r1]
 243:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMCMP[base->timerIndex[1]] = 0;
 532              		.loc 1 243 0
 533 005c 427A     		ldrb	r2, [r0, #9]
 534 005e 4132     		adds	r2, r2, #65
 535 0060 FF32     		adds	r2, r2, #255
 536 0062 9200     		lsls	r2, r2, #2
 537 0064 0168     		ldr	r1, [r0]
 538 0066 5350     		str	r3, [r2, r1]
 244:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMCTL[base->timerIndex[1]] = 0;
 539              		.loc 1 244 0
 540 0068 427A     		ldrb	r2, [r0, #9]
 541 006a 0132     		adds	r2, r2, #1
 542 006c FF32     		adds	r2, r2, #255
 543 006e 9200     		lsls	r2, r2, #2
 544 0070 0168     		ldr	r1, [r0]
 545 0072 5350     		str	r3, [r2, r1]
 245:../drivers/fsl_flexio_uart.c ****     /* Clear the shifter flag. */
 246:../drivers/fsl_flexio_uart.c ****     base->flexioBase->SHIFTSTAT = (1U << base->shifterIndex[0]);
 546              		.loc 1 246 0
 547 0074 8179     		ldrb	r1, [r0, #6]
 548 0076 0268     		ldr	r2, [r0]
 549 0078 0133     		adds	r3, r3, #1
 550 007a 1C00     		movs	r4, r3
 551 007c 8C40     		lsls	r4, r4, r1
 552 007e 1461     		str	r4, [r2, #16]
 247:../drivers/fsl_flexio_uart.c ****     base->flexioBase->SHIFTSTAT = (1U << base->shifterIndex[1]);
 553              		.loc 1 247 0
 554 0080 C179     		ldrb	r1, [r0, #7]
 555 0082 0268     		ldr	r2, [r0]
 556 0084 1C00     		movs	r4, r3
 557 0086 8C40     		lsls	r4, r4, r1
 558 0088 1461     		str	r4, [r2, #16]
 248:../drivers/fsl_flexio_uart.c ****     /* Clear the timer flag. */
 249:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMSTAT = (1U << base->timerIndex[0]);
 559              		.loc 1 249 0
 560 008a 017A     		ldrb	r1, [r0, #8]
 561 008c 0268     		ldr	r2, [r0]
 562 008e 1C00     		movs	r4, r3
 563 0090 8C40     		lsls	r4, r4, r1
 564 0092 9461     		str	r4, [r2, #24]
 250:../drivers/fsl_flexio_uart.c ****     base->flexioBase->TIMSTAT = (1U << base->timerIndex[1]);
 565              		.loc 1 250 0
 566 0094 417A     		ldrb	r1, [r0, #9]
 567 0096 0268     		ldr	r2, [r0]
 568 0098 8B40     		lsls	r3, r3, r1
 569 009a 9361     		str	r3, [r2, #24]
 251:../drivers/fsl_flexio_uart.c **** }
 570              		.loc 1 251 0
 571              		@ sp needed
 572 009c 10BD     		pop	{r4, pc}
 573              		.cfi_endproc
 574              	.LFE78:
 576              		.section	.text.FLEXIO_UART_GetDefaultConfig,"ax",%progbits
 577              		.align	1
 578              		.global	FLEXIO_UART_GetDefaultConfig
 579              		.syntax unified
 580              		.code	16
 581              		.thumb_func
 582              		.fpu softvfp
 584              	FLEXIO_UART_GetDefaultConfig:
 585              	.LFB79:
 252:../drivers/fsl_flexio_uart.c **** 
 253:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_GetDefaultConfig(flexio_uart_config_t *userConfig)
 254:../drivers/fsl_flexio_uart.c **** {
 586              		.loc 1 254 0
 587              		.cfi_startproc
 588              		@ args = 0, pretend = 0, frame = 0
 589              		@ frame_needed = 0, uses_anonymous_args = 0
 590              		@ link register save eliminated.
 591              	.LVL51:
 255:../drivers/fsl_flexio_uart.c ****     assert(userConfig);
 256:../drivers/fsl_flexio_uart.c **** 
 257:../drivers/fsl_flexio_uart.c ****     userConfig->enableUart = true;
 592              		.loc 1 257 0
 593 0000 0122     		movs	r2, #1
 594 0002 0270     		strb	r2, [r0]
 258:../drivers/fsl_flexio_uart.c ****     userConfig->enableInDoze = false;
 595              		.loc 1 258 0
 596 0004 0023     		movs	r3, #0
 597 0006 4370     		strb	r3, [r0, #1]
 259:../drivers/fsl_flexio_uart.c ****     userConfig->enableInDebug = true;
 598              		.loc 1 259 0
 599 0008 8270     		strb	r2, [r0, #2]
 260:../drivers/fsl_flexio_uart.c ****     userConfig->enableFastAccess = false;
 600              		.loc 1 260 0
 601 000a C370     		strb	r3, [r0, #3]
 261:../drivers/fsl_flexio_uart.c ****     /* Default baud rate 115200. */
 262:../drivers/fsl_flexio_uart.c ****     userConfig->baudRate_Bps = 115200U;
 602              		.loc 1 262 0
 603 000c E123     		movs	r3, #225
 604 000e 5B02     		lsls	r3, r3, #9
 605 0010 4360     		str	r3, [r0, #4]
 263:../drivers/fsl_flexio_uart.c ****     /* Default bit count at 8. */
 264:../drivers/fsl_flexio_uart.c ****     userConfig->bitCountPerChar = kFLEXIO_UART_8BitsPerChar;
 606              		.loc 1 264 0
 607 0012 0823     		movs	r3, #8
 608 0014 0372     		strb	r3, [r0, #8]
 265:../drivers/fsl_flexio_uart.c **** }
 609              		.loc 1 265 0
 610              		@ sp needed
 611 0016 7047     		bx	lr
 612              		.cfi_endproc
 613              	.LFE79:
 615              		.section	.text.FLEXIO_UART_EnableInterrupts,"ax",%progbits
 616              		.align	1
 617              		.global	FLEXIO_UART_EnableInterrupts
 618              		.syntax unified
 619              		.code	16
 620              		.thumb_func
 621              		.fpu softvfp
 623              	FLEXIO_UART_EnableInterrupts:
 624              	.LFB80:
 266:../drivers/fsl_flexio_uart.c **** 
 267:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_EnableInterrupts(FLEXIO_UART_Type *base, uint32_t mask)
 268:../drivers/fsl_flexio_uart.c **** {
 625              		.loc 1 268 0
 626              		.cfi_startproc
 627              		@ args = 0, pretend = 0, frame = 0
 628              		@ frame_needed = 0, uses_anonymous_args = 0
 629              	.LVL52:
 630 0000 10B5     		push	{r4, lr}
 631              		.cfi_def_cfa_offset 8
 632              		.cfi_offset 4, -8
 633              		.cfi_offset 14, -4
 269:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_TxDataRegEmptyInterruptEnable)
 634              		.loc 1 269 0
 635 0002 CB07     		lsls	r3, r1, #31
 636 0004 06D5     		bpl	.L19
 270:../drivers/fsl_flexio_uart.c ****     {
 271:../drivers/fsl_flexio_uart.c ****         FLEXIO_EnableShifterStatusInterrupts(base->flexioBase, 1U << base->shifterIndex[0]);
 637              		.loc 1 271 0
 638 0006 0268     		ldr	r2, [r0]
 639 0008 8479     		ldrb	r4, [r0, #6]
 640 000a 0123     		movs	r3, #1
 641 000c A340     		lsls	r3, r3, r4
 642              	.LVL53:
 643              	.LBB38:
 644              	.LBB39:
 645              		.file 3 "../drivers/fsl_flexio.h"
   1:../drivers/fsl_flexio.h **** /*
   2:../drivers/fsl_flexio.h ****  * The Clear BSD License
   3:../drivers/fsl_flexio.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_flexio.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_flexio.h ****  * All rights reserved.
   6:../drivers/fsl_flexio.h ****  *
   7:../drivers/fsl_flexio.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_flexio.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_flexio.h ****  * that the following conditions are met:
  10:../drivers/fsl_flexio.h ****  *
  11:../drivers/fsl_flexio.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_flexio.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_flexio.h ****  *
  14:../drivers/fsl_flexio.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_flexio.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_flexio.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_flexio.h ****  *
  18:../drivers/fsl_flexio.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_flexio.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_flexio.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_flexio.h ****  *
  22:../drivers/fsl_flexio.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_flexio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_flexio.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_flexio.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_flexio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_flexio.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_flexio.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_flexio.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_flexio.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_flexio.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_flexio.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_flexio.h ****  */
  34:../drivers/fsl_flexio.h **** #ifndef _FSL_FLEXIO_H_
  35:../drivers/fsl_flexio.h **** #define _FSL_FLEXIO_H_
  36:../drivers/fsl_flexio.h **** 
  37:../drivers/fsl_flexio.h **** #include "fsl_common.h"
  38:../drivers/fsl_flexio.h **** 
  39:../drivers/fsl_flexio.h **** /*!
  40:../drivers/fsl_flexio.h ****  * @addtogroup flexio_driver
  41:../drivers/fsl_flexio.h ****  * @{
  42:../drivers/fsl_flexio.h ****  */
  43:../drivers/fsl_flexio.h **** 
  44:../drivers/fsl_flexio.h **** /*******************************************************************************
  45:../drivers/fsl_flexio.h ****  * Definitions
  46:../drivers/fsl_flexio.h ****  ******************************************************************************/
  47:../drivers/fsl_flexio.h **** 
  48:../drivers/fsl_flexio.h **** /*! @name Driver version */
  49:../drivers/fsl_flexio.h **** /*@{*/
  50:../drivers/fsl_flexio.h **** /*! @brief FlexIO driver version 2.0.2. */
  51:../drivers/fsl_flexio.h **** #define FSL_FLEXIO_DRIVER_VERSION (MAKE_VERSION(2, 0, 2))
  52:../drivers/fsl_flexio.h **** /*@}*/
  53:../drivers/fsl_flexio.h **** 
  54:../drivers/fsl_flexio.h **** /*! @brief Calculate FlexIO timer trigger.*/
  55:../drivers/fsl_flexio.h **** #define FLEXIO_TIMER_TRIGGER_SEL_PININPUT(x) ((uint32_t)(x) << 1U)
  56:../drivers/fsl_flexio.h **** #define FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(x) (((uint32_t)(x) << 2U) | 0x1U)
  57:../drivers/fsl_flexio.h **** #define FLEXIO_TIMER_TRIGGER_SEL_TIMn(x) (((uint32_t)(x) << 2U) | 0x3U)
  58:../drivers/fsl_flexio.h **** 
  59:../drivers/fsl_flexio.h **** /*! @brief Define time of timer trigger polarity.*/
  60:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_trigger_polarity
  61:../drivers/fsl_flexio.h **** {
  62:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerPolarityActiveHigh = 0x0U, /*!< Active high. */
  63:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerPolarityActiveLow = 0x1U,  /*!< Active low. */
  64:../drivers/fsl_flexio.h **** } flexio_timer_trigger_polarity_t;
  65:../drivers/fsl_flexio.h **** 
  66:../drivers/fsl_flexio.h **** /*! @brief Define type of timer trigger source.*/
  67:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_trigger_source
  68:../drivers/fsl_flexio.h **** {
  69:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerSourceExternal = 0x0U, /*!< External trigger selected. */
  70:../drivers/fsl_flexio.h ****     kFLEXIO_TimerTriggerSourceInternal = 0x1U, /*!< Internal trigger selected. */
  71:../drivers/fsl_flexio.h **** } flexio_timer_trigger_source_t;
  72:../drivers/fsl_flexio.h **** 
  73:../drivers/fsl_flexio.h **** /*! @brief Define type of timer/shifter pin configuration.*/
  74:../drivers/fsl_flexio.h **** typedef enum _flexio_pin_config
  75:../drivers/fsl_flexio.h **** {
  76:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigOutputDisabled = 0x0U,         /*!< Pin output disabled. */
  77:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigOpenDrainOrBidirection = 0x1U, /*!< Pin open drain or bidirectional output ena
  78:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigBidirectionOutputData = 0x2U,  /*!< Pin bidirectional output data. */
  79:../drivers/fsl_flexio.h ****     kFLEXIO_PinConfigOutput = 0x3U,                 /*!< Pin output. */
  80:../drivers/fsl_flexio.h **** } flexio_pin_config_t;
  81:../drivers/fsl_flexio.h **** 
  82:../drivers/fsl_flexio.h **** /*! @brief Definition of pin polarity.*/
  83:../drivers/fsl_flexio.h **** typedef enum _flexio_pin_polarity
  84:../drivers/fsl_flexio.h **** {
  85:../drivers/fsl_flexio.h ****     kFLEXIO_PinActiveHigh = 0x0U, /*!< Active high. */
  86:../drivers/fsl_flexio.h ****     kFLEXIO_PinActiveLow = 0x1U,  /*!< Active low. */
  87:../drivers/fsl_flexio.h **** } flexio_pin_polarity_t;
  88:../drivers/fsl_flexio.h **** 
  89:../drivers/fsl_flexio.h **** /*! @brief Define type of timer work mode.*/
  90:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_mode
  91:../drivers/fsl_flexio.h **** {
  92:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeDisabled = 0x0U,        /*!< Timer Disabled. */
  93:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeDual8BitBaudBit = 0x1U, /*!< Dual 8-bit counters baud/bit mode. */
  94:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeDual8BitPWM = 0x2U,     /*!< Dual 8-bit counters PWM mode. */
  95:../drivers/fsl_flexio.h ****     kFLEXIO_TimerModeSingle16Bit = 0x3U,     /*!< Single 16-bit counter mode. */
  96:../drivers/fsl_flexio.h **** } flexio_timer_mode_t;
  97:../drivers/fsl_flexio.h **** 
  98:../drivers/fsl_flexio.h **** /*! @brief Define type of timer initial output or timer reset condition.*/
  99:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_output
 100:../drivers/fsl_flexio.h **** {
 101:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputOneNotAffectedByReset = 0x0U,  /*!< Logic one when enabled and is not affect
 102:../drivers/fsl_flexio.h ****                                                        reset. */
 103:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputZeroNotAffectedByReset = 0x1U, /*!< Logic zero when enabled and is not affec
 104:../drivers/fsl_flexio.h ****                                                        reset. */
 105:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputOneAffectedByReset = 0x2U,     /*!< Logic one when enabled and on timer rese
 106:../drivers/fsl_flexio.h ****     kFLEXIO_TimerOutputZeroAffectedByReset = 0x3U,    /*!< Logic zero when enabled and on timer res
 107:../drivers/fsl_flexio.h **** } flexio_timer_output_t;
 108:../drivers/fsl_flexio.h **** 
 109:../drivers/fsl_flexio.h **** /*! @brief Define type of timer decrement.*/
 110:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_decrement_source
 111:../drivers/fsl_flexio.h **** {
 112:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput = 0x0U,   /*!< Decrement counter on FlexIO clo
 113:../drivers/fsl_flexio.h ****                                                                 equals Timer output. */
 114:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnTriggerInputShiftTimerOutput = 0x1U,  /*!< Decrement counter on Trigger in
 115:../drivers/fsl_flexio.h ****                                                                 Shift clock equals Timer output. */
 116:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnPinInputShiftPinInput = 0x2U,         /*!< Decrement counter on Pin input 
 117:../drivers/fsl_flexio.h ****                                                                 Shift clock equals Pin input. */
 118:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDecSrcOnTriggerInputShiftTriggerInput = 0x3U, /*!< Decrement counter on Trigger in
 119:../drivers/fsl_flexio.h ****                                                                 Shift clock equals Trigger input. *
 120:../drivers/fsl_flexio.h **** } flexio_timer_decrement_source_t;
 121:../drivers/fsl_flexio.h **** 
 122:../drivers/fsl_flexio.h **** /*! @brief Define type of timer reset condition.*/
 123:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_reset_condition
 124:../drivers/fsl_flexio.h **** {
 125:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetNever = 0x0U,                            /*!< Timer never reset. */
 126:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerPinEqualToTimerOutput = 0x2U,     /*!< Timer reset on Timer Pin equal 
 127:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerTriggerEqualToTimerOutput = 0x3U, /*!< Timer reset on Timer Trigger eq
 128:../drivers/fsl_flexio.h ****                                                                 Timer Output. */
 129:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerPinRisingEdge = 0x4U,             /*!< Timer reset on Timer Pin rising
 130:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerTriggerRisingEdge = 0x6U,         /*!< Timer reset on Trigger rising e
 131:../drivers/fsl_flexio.h ****     kFLEXIO_TimerResetOnTimerTriggerBothEdge = 0x7U,           /*!< Timer reset on Trigger rising o
 132:../drivers/fsl_flexio.h **** } flexio_timer_reset_condition_t;
 133:../drivers/fsl_flexio.h **** 
 134:../drivers/fsl_flexio.h **** /*! @brief Define type of timer disable condition.*/
 135:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_disable_condition
 136:../drivers/fsl_flexio.h **** {
 137:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableNever = 0x0U,                    /*!< Timer never disabled. */
 138:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnPreTimerDisable = 0x1U,        /*!< Timer disabled on Timer N-1 disable. 
 139:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnTimerCompare = 0x2U,           /*!< Timer disabled on Timer compare. */
 140:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnTimerCompareTriggerLow = 0x3U, /*!< Timer disabled on Timer compare and T
 141:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnPinBothEdge = 0x4U,            /*!< Timer disabled on Pin rising or falli
 142:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnPinBothEdgeTriggerHigh = 0x5U, /*!< Timer disabled on Pin rising or falli
 143:../drivers/fsl_flexio.h ****                                                           Trigger is high. */
 144:../drivers/fsl_flexio.h ****     kFLEXIO_TimerDisableOnTriggerFallingEdge = 0x6U,     /*!< Timer disabled on Trigger falling edg
 145:../drivers/fsl_flexio.h **** } flexio_timer_disable_condition_t;
 146:../drivers/fsl_flexio.h **** 
 147:../drivers/fsl_flexio.h **** /*! @brief Define type of timer enable condition.*/
 148:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_enable_condition
 149:../drivers/fsl_flexio.h **** {
 150:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnabledAlways = 0x0U,                    /*!< Timer always enabled. */
 151:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnPrevTimerEnable = 0x1U,          /*!< Timer enabled on Timer N-1 enable. *
 152:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerHigh = 0x2U,              /*!< Timer enabled on Trigger high. */
 153:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerHighPinHigh = 0x3U,       /*!< Timer enabled on Trigger high and Pi
 154:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnPinRisingEdge = 0x4U,            /*!< Timer enabled on Pin rising edge. */
 155:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnPinRisingEdgeTriggerHigh = 0x5U, /*!< Timer enabled on Pin rising edge and
 156:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerRisingEdge = 0x6U,        /*!< Timer enabled on Trigger rising edge
 157:../drivers/fsl_flexio.h ****     kFLEXIO_TimerEnableOnTriggerBothEdge = 0x7U,          /*!< Timer enabled on Trigger rising or f
 158:../drivers/fsl_flexio.h **** } flexio_timer_enable_condition_t;
 159:../drivers/fsl_flexio.h **** 
 160:../drivers/fsl_flexio.h **** /*! @brief Define type of timer stop bit generate condition.*/
 161:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_stop_bit_condition
 162:../drivers/fsl_flexio.h **** {
 163:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitDisabled = 0x0U,                    /*!< Stop bit disabled. */
 164:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitEnableOnTimerCompare = 0x1U,        /*!< Stop bit is enabled on timer compa
 165:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitEnableOnTimerDisable = 0x2U,        /*!< Stop bit is enabled on timer disab
 166:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStopBitEnableOnTimerCompareDisable = 0x3U, /*!< Stop bit is enabled on timer compa
 167:../drivers/fsl_flexio.h ****                                                              disable. */
 168:../drivers/fsl_flexio.h **** } flexio_timer_stop_bit_condition_t;
 169:../drivers/fsl_flexio.h **** 
 170:../drivers/fsl_flexio.h **** /*! @brief Define type of timer start bit generate condition.*/
 171:../drivers/fsl_flexio.h **** typedef enum _flexio_timer_start_bit_condition
 172:../drivers/fsl_flexio.h **** {
 173:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStartBitDisabled = 0x0U, /*!< Start bit disabled. */
 174:../drivers/fsl_flexio.h ****     kFLEXIO_TimerStartBitEnabled = 0x1U,  /*!< Start bit enabled. */
 175:../drivers/fsl_flexio.h **** } flexio_timer_start_bit_condition_t;
 176:../drivers/fsl_flexio.h **** 
 177:../drivers/fsl_flexio.h **** /*! @brief Define type of timer polarity for shifter control. */
 178:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_timer_polarity
 179:../drivers/fsl_flexio.h **** {
 180:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterTimerPolarityOnPositive = 0x0U, /* Shift on positive edge of shift clock. */
 181:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterTimerPolarityOnNegitive = 0x1U, /* Shift on negative edge of shift clock. */
 182:../drivers/fsl_flexio.h **** } flexio_shifter_timer_polarity_t;
 183:../drivers/fsl_flexio.h **** 
 184:../drivers/fsl_flexio.h **** /*! @brief Define type of shifter working mode.*/
 185:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_mode
 186:../drivers/fsl_flexio.h **** {
 187:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterDisabled = 0x0U,            /*!< Shifter is disabled. */
 188:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeReceive = 0x1U,         /*!< Receive mode. */
 189:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeTransmit = 0x2U,        /*!< Transmit mode. */
 190:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeMatchStore = 0x4U,      /*!< Match store mode. */
 191:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeMatchContinuous = 0x5U, /*!< Match continuous mode. */
 192:../drivers/fsl_flexio.h **** #if FSL_FEATURE_FLEXIO_HAS_STATE_MODE
 193:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeState = 0x6U, /*!< SHIFTBUF contents are used for storing
 194:../drivers/fsl_flexio.h ****                                       programmable state attributes. */
 195:../drivers/fsl_flexio.h **** #endif                               /* FSL_FEATURE_FLEXIO_HAS_STATE_MODE */
 196:../drivers/fsl_flexio.h **** #if FSL_FEATURE_FLEXIO_HAS_LOGIC_MODE
 197:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterModeLogic = 0x7U, /*!< SHIFTBUF contents are used for implementing
 198:../drivers/fsl_flexio.h ****                                      programmable logic look up table. */
 199:../drivers/fsl_flexio.h **** #endif                               /* FSL_FEATURE_FLEXIO_HAS_LOGIC_MODE */
 200:../drivers/fsl_flexio.h **** } flexio_shifter_mode_t;
 201:../drivers/fsl_flexio.h **** 
 202:../drivers/fsl_flexio.h **** /*! @brief Define type of shifter input source.*/
 203:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_input_source
 204:../drivers/fsl_flexio.h **** {
 205:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterInputFromPin = 0x0U,               /*!< Shifter input from pin. */
 206:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterInputFromNextShifterOutput = 0x1U, /*!< Shifter input from Shifter N+1. */
 207:../drivers/fsl_flexio.h **** } flexio_shifter_input_source_t;
 208:../drivers/fsl_flexio.h **** 
 209:../drivers/fsl_flexio.h **** /*! @brief Define of STOP bit configuration.*/
 210:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_stop_bit
 211:../drivers/fsl_flexio.h **** {
 212:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStopBitDisable = 0x0U, /*!< Disable shifter stop bit. */
 213:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStopBitLow = 0x2U,     /*!< Set shifter stop bit to logic low level. */
 214:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStopBitHigh = 0x3U,    /*!< Set shifter stop bit to logic high level. */
 215:../drivers/fsl_flexio.h **** } flexio_shifter_stop_bit_t;
 216:../drivers/fsl_flexio.h **** 
 217:../drivers/fsl_flexio.h **** /*! @brief Define type of START bit configuration.*/
 218:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_start_bit
 219:../drivers/fsl_flexio.h **** {
 220:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable = 0x0U, /*!< Disable shifter start bit, transmi
 221:../drivers/fsl_flexio.h ****                                                              data on enable. */
 222:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitDisabledLoadDataOnShift = 0x1U,  /*!< Disable shifter start bit, transmi
 223:../drivers/fsl_flexio.h ****                                                              data on first shift. */
 224:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitLow = 0x2U,                      /*!< Set shifter start bit to logic low
 225:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterStartBitHigh = 0x3U,                     /*!< Set shifter start bit to logic hig
 226:../drivers/fsl_flexio.h **** } flexio_shifter_start_bit_t;
 227:../drivers/fsl_flexio.h **** 
 228:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO shifter buffer type*/
 229:../drivers/fsl_flexio.h **** typedef enum _flexio_shifter_buffer_type
 230:../drivers/fsl_flexio.h **** {
 231:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBuffer = 0x0U,               /*!< Shifter Buffer N Register. */
 232:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferBitSwapped = 0x1U,     /*!< Shifter Buffer N Bit Byte Swapped Register. */
 233:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferByteSwapped = 0x2U,    /*!< Shifter Buffer N Byte Swapped Register. */
 234:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferBitByteSwapped = 0x3U, /*!< Shifter Buffer N Bit Swapped Register. */
 235:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_NIBBLE_BYTE_SWAP) && FSL_FEATURE_FLEXIO_HAS_SHFT_BUF
 236:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferNibbleByteSwapped = 0x4U, /*!< Shifter Buffer N Nibble Byte Swapped Regist
 237:../drivers/fsl_flexio.h **** #endif                                             /*FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_NIBBLE_BYTE
 238:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_HALF_WORD_SWAP) && FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFE
 239:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferHalfWordSwapped = 0x5U, /*!< Shifter Buffer N Half Word Swapped Register. 
 240:../drivers/fsl_flexio.h **** #endif
 241:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_NIBBLE_SWAP) && FSL_FEATURE_FLEXIO_HAS_SHFT_BUFFER_N
 242:../drivers/fsl_flexio.h ****     kFLEXIO_ShifterBufferNibbleSwapped = 0x6U, /*!< Shifter Buffer N Nibble Swapped Register. */
 243:../drivers/fsl_flexio.h **** #endif
 244:../drivers/fsl_flexio.h **** } flexio_shifter_buffer_type_t;
 245:../drivers/fsl_flexio.h **** 
 246:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO user configuration structure. */
 247:../drivers/fsl_flexio.h **** typedef struct _flexio_config_
 248:../drivers/fsl_flexio.h **** {
 249:../drivers/fsl_flexio.h ****     bool enableFlexio;     /*!< Enable/disable FlexIO module */
 250:../drivers/fsl_flexio.h ****     bool enableInDoze;     /*!< Enable/disable FlexIO operation in doze mode */
 251:../drivers/fsl_flexio.h ****     bool enableInDebug;    /*!< Enable/disable FlexIO operation in debug mode */
 252:../drivers/fsl_flexio.h ****     bool enableFastAccess; /*!< Enable/disable fast access to FlexIO registers, fast access require
 253:../drivers/fsl_flexio.h ****                            the FlexIO clock to be at least twice the frequency of the bus clock. */
 254:../drivers/fsl_flexio.h **** } flexio_config_t;
 255:../drivers/fsl_flexio.h **** 
 256:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO timer configuration structure. */
 257:../drivers/fsl_flexio.h **** typedef struct _flexio_timer_config
 258:../drivers/fsl_flexio.h **** {
 259:../drivers/fsl_flexio.h ****     /* Trigger. */
 260:../drivers/fsl_flexio.h ****     uint32_t triggerSelect;                          /*!< The internal trigger selection number usi
 261:../drivers/fsl_flexio.h ****     flexio_timer_trigger_polarity_t triggerPolarity; /*!< Trigger Polarity. */
 262:../drivers/fsl_flexio.h ****     flexio_timer_trigger_source_t triggerSource;     /*!< Trigger Source, internal (see 'trgsel') o
 263:../drivers/fsl_flexio.h ****     /* Pin. */
 264:../drivers/fsl_flexio.h ****     flexio_pin_config_t pinConfig;     /*!< Timer Pin Configuration. */
 265:../drivers/fsl_flexio.h ****     uint32_t pinSelect;                /*!< Timer Pin number Select. */
 266:../drivers/fsl_flexio.h ****     flexio_pin_polarity_t pinPolarity; /*!< Timer Pin Polarity. */
 267:../drivers/fsl_flexio.h ****     /* Timer. */
 268:../drivers/fsl_flexio.h ****     flexio_timer_mode_t timerMode;                  /*!< Timer work Mode. */
 269:../drivers/fsl_flexio.h ****     flexio_timer_output_t timerOutput;              /*!< Configures the initial state of the Timer 
 270:../drivers/fsl_flexio.h ****                                                     whether it is affected by the Timer reset. */
 271:../drivers/fsl_flexio.h ****     flexio_timer_decrement_source_t timerDecrement; /*!< Configures the source of the Timer decreme
 272:../drivers/fsl_flexio.h ****                                                     source of the Shift clock. */
 273:../drivers/fsl_flexio.h ****     flexio_timer_reset_condition_t timerReset;      /*!< Configures the condition that causes the t
 274:../drivers/fsl_flexio.h ****                                                     (and optionally the timer output) to be reset. 
 275:../drivers/fsl_flexio.h ****     flexio_timer_disable_condition_t timerDisable;  /*!< Configures the condition that causes the T
 276:../drivers/fsl_flexio.h ****                                                     disabled and stop decrementing. */
 277:../drivers/fsl_flexio.h ****     flexio_timer_enable_condition_t timerEnable;    /*!< Configures the condition that causes the T
 278:../drivers/fsl_flexio.h ****                                                     enabled and start decrementing. */
 279:../drivers/fsl_flexio.h ****     flexio_timer_stop_bit_condition_t timerStop;    /*!< Timer STOP Bit generation. */
 280:../drivers/fsl_flexio.h ****     flexio_timer_start_bit_condition_t timerStart;  /*!< Timer STRAT Bit generation. */
 281:../drivers/fsl_flexio.h ****     uint32_t timerCompare;                          /*!< Value for Timer Compare N Register. */
 282:../drivers/fsl_flexio.h **** } flexio_timer_config_t;
 283:../drivers/fsl_flexio.h **** 
 284:../drivers/fsl_flexio.h **** /*! @brief Define FlexIO shifter configuration structure. */
 285:../drivers/fsl_flexio.h **** typedef struct _flexio_shifter_config
 286:../drivers/fsl_flexio.h **** {
 287:../drivers/fsl_flexio.h ****     /* Timer. */
 288:../drivers/fsl_flexio.h ****     uint32_t timerSelect;                          /*!< Selects which Timer is used for controlling
 289:../drivers/fsl_flexio.h ****                                                     logic/shift register and generating the Shift c
 290:../drivers/fsl_flexio.h ****     flexio_shifter_timer_polarity_t timerPolarity; /*!< Timer Polarity. */
 291:../drivers/fsl_flexio.h ****     /* Pin. */
 292:../drivers/fsl_flexio.h ****     flexio_pin_config_t pinConfig;     /*!< Shifter Pin Configuration. */
 293:../drivers/fsl_flexio.h ****     uint32_t pinSelect;                /*!< Shifter Pin number Select. */
 294:../drivers/fsl_flexio.h ****     flexio_pin_polarity_t pinPolarity; /*!< Shifter Pin Polarity. */
 295:../drivers/fsl_flexio.h ****     /* Shifter. */
 296:../drivers/fsl_flexio.h ****     flexio_shifter_mode_t shifterMode; /*!< Configures the mode of the Shifter. */
 297:../drivers/fsl_flexio.h **** #if FSL_FEATURE_FLEXIO_HAS_PARALLEL_WIDTH
 298:../drivers/fsl_flexio.h ****     uint32_t parallelWidth;                    /*!< Configures the parallel width when using parall
 299:../drivers/fsl_flexio.h **** #endif                                         /* FSL_FEATURE_FLEXIO_HAS_PARALLEL_WIDTH */
 300:../drivers/fsl_flexio.h ****     flexio_shifter_input_source_t inputSource; /*!< Selects the input source for the shifter. */
 301:../drivers/fsl_flexio.h ****     flexio_shifter_stop_bit_t shifterStop;     /*!< Shifter STOP bit. */
 302:../drivers/fsl_flexio.h ****     flexio_shifter_start_bit_t shifterStart;   /*!< Shifter START bit. */
 303:../drivers/fsl_flexio.h **** } flexio_shifter_config_t;
 304:../drivers/fsl_flexio.h **** 
 305:../drivers/fsl_flexio.h **** /*! @brief typedef for FlexIO simulated driver interrupt handler.*/
 306:../drivers/fsl_flexio.h **** typedef void (*flexio_isr_t)(void *base, void *handle);
 307:../drivers/fsl_flexio.h **** 
 308:../drivers/fsl_flexio.h **** /*******************************************************************************
 309:../drivers/fsl_flexio.h ****  * API
 310:../drivers/fsl_flexio.h ****  ******************************************************************************/
 311:../drivers/fsl_flexio.h **** 
 312:../drivers/fsl_flexio.h **** #if defined(__cplusplus)
 313:../drivers/fsl_flexio.h **** extern "C" {
 314:../drivers/fsl_flexio.h **** #endif /*_cplusplus*/
 315:../drivers/fsl_flexio.h **** 
 316:../drivers/fsl_flexio.h **** /*!
 317:../drivers/fsl_flexio.h ****  * @name FlexIO Initialization and De-initialization
 318:../drivers/fsl_flexio.h ****  * @{
 319:../drivers/fsl_flexio.h ****  */
 320:../drivers/fsl_flexio.h **** 
 321:../drivers/fsl_flexio.h **** /*!
 322:../drivers/fsl_flexio.h ****  * @brief Gets the default configuration to configure the FlexIO module. The configuration
 323:../drivers/fsl_flexio.h ****  * can used directly to call the FLEXIO_Configure().
 324:../drivers/fsl_flexio.h ****  *
 325:../drivers/fsl_flexio.h ****  * Example:
 326:../drivers/fsl_flexio.h ****    @code
 327:../drivers/fsl_flexio.h ****    flexio_config_t config;
 328:../drivers/fsl_flexio.h ****    FLEXIO_GetDefaultConfig(&config);
 329:../drivers/fsl_flexio.h ****    @endcode
 330:../drivers/fsl_flexio.h ****  *
 331:../drivers/fsl_flexio.h ****  * @param userConfig pointer to flexio_config_t structure
 332:../drivers/fsl_flexio.h **** */
 333:../drivers/fsl_flexio.h **** void FLEXIO_GetDefaultConfig(flexio_config_t *userConfig);
 334:../drivers/fsl_flexio.h **** 
 335:../drivers/fsl_flexio.h **** /*!
 336:../drivers/fsl_flexio.h ****  * @brief Configures the FlexIO with a FlexIO configuration. The configuration structure
 337:../drivers/fsl_flexio.h ****  * can be filled by the user or be set with default values by FLEXIO_GetDefaultConfig().
 338:../drivers/fsl_flexio.h ****  *
 339:../drivers/fsl_flexio.h ****  * Example
 340:../drivers/fsl_flexio.h ****    @code
 341:../drivers/fsl_flexio.h ****    flexio_config_t config = {
 342:../drivers/fsl_flexio.h ****    .enableFlexio = true,
 343:../drivers/fsl_flexio.h ****    .enableInDoze = false,
 344:../drivers/fsl_flexio.h ****    .enableInDebug = true,
 345:../drivers/fsl_flexio.h ****    .enableFastAccess = false
 346:../drivers/fsl_flexio.h ****    };
 347:../drivers/fsl_flexio.h ****    FLEXIO_Configure(base, &config);
 348:../drivers/fsl_flexio.h ****    @endcode
 349:../drivers/fsl_flexio.h ****  *
 350:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 351:../drivers/fsl_flexio.h ****  * @param userConfig pointer to flexio_config_t structure
 352:../drivers/fsl_flexio.h **** */
 353:../drivers/fsl_flexio.h **** void FLEXIO_Init(FLEXIO_Type *base, const flexio_config_t *userConfig);
 354:../drivers/fsl_flexio.h **** 
 355:../drivers/fsl_flexio.h **** /*!
 356:../drivers/fsl_flexio.h ****  * @brief Gates the FlexIO clock. Call this API to stop the FlexIO clock.
 357:../drivers/fsl_flexio.h ****  *
 358:../drivers/fsl_flexio.h ****  * @note After calling this API, call the FLEXO_Init to use the FlexIO module.
 359:../drivers/fsl_flexio.h ****  *
 360:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 361:../drivers/fsl_flexio.h **** */
 362:../drivers/fsl_flexio.h **** void FLEXIO_Deinit(FLEXIO_Type *base);
 363:../drivers/fsl_flexio.h **** 
 364:../drivers/fsl_flexio.h **** /* @} */
 365:../drivers/fsl_flexio.h **** 
 366:../drivers/fsl_flexio.h **** /*!
 367:../drivers/fsl_flexio.h ****  * @name FlexIO Basic Operation
 368:../drivers/fsl_flexio.h ****  * @{
 369:../drivers/fsl_flexio.h ****  */
 370:../drivers/fsl_flexio.h **** 
 371:../drivers/fsl_flexio.h **** /*!
 372:../drivers/fsl_flexio.h ****  * @brief Resets the FlexIO module.
 373:../drivers/fsl_flexio.h ****  *
 374:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 375:../drivers/fsl_flexio.h **** */
 376:../drivers/fsl_flexio.h **** void FLEXIO_Reset(FLEXIO_Type *base);
 377:../drivers/fsl_flexio.h **** 
 378:../drivers/fsl_flexio.h **** /*!
 379:../drivers/fsl_flexio.h ****  * @brief Enables the FlexIO module operation.
 380:../drivers/fsl_flexio.h ****  *
 381:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 382:../drivers/fsl_flexio.h ****  * @param enable true to enable, false to disable.
 383:../drivers/fsl_flexio.h **** */
 384:../drivers/fsl_flexio.h **** static inline void FLEXIO_Enable(FLEXIO_Type *base, bool enable)
 385:../drivers/fsl_flexio.h **** {
 386:../drivers/fsl_flexio.h ****     if (enable)
 387:../drivers/fsl_flexio.h ****     {
 388:../drivers/fsl_flexio.h ****         base->CTRL |= FLEXIO_CTRL_FLEXEN_MASK;
 389:../drivers/fsl_flexio.h ****     }
 390:../drivers/fsl_flexio.h ****     else
 391:../drivers/fsl_flexio.h ****     {
 392:../drivers/fsl_flexio.h ****         base->CTRL &= ~FLEXIO_CTRL_FLEXEN_MASK;
 393:../drivers/fsl_flexio.h ****     }
 394:../drivers/fsl_flexio.h **** }
 395:../drivers/fsl_flexio.h **** 
 396:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_PIN_STATUS) && FSL_FEATURE_FLEXIO_HAS_PIN_STATUS
 397:../drivers/fsl_flexio.h **** /*!
 398:../drivers/fsl_flexio.h ****  * @brief Reads the input data on each of the FlexIO pins.
 399:../drivers/fsl_flexio.h ****  *
 400:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 401:../drivers/fsl_flexio.h ****  * @return FlexIO pin input data
 402:../drivers/fsl_flexio.h **** */
 403:../drivers/fsl_flexio.h **** static inline uint32_t FLEXIO_ReadPinInput(FLEXIO_Type *base)
 404:../drivers/fsl_flexio.h **** {
 405:../drivers/fsl_flexio.h ****     return base->PIN;
 406:../drivers/fsl_flexio.h **** }
 407:../drivers/fsl_flexio.h **** #endif /*FSL_FEATURE_FLEXIO_HAS_PIN_STATUS*/
 408:../drivers/fsl_flexio.h **** 
 409:../drivers/fsl_flexio.h **** #if defined(FSL_FEATURE_FLEXIO_HAS_STATE_MODE) && FSL_FEATURE_FLEXIO_HAS_STATE_MODE
 410:../drivers/fsl_flexio.h **** /*!
 411:../drivers/fsl_flexio.h ****  * @brief Gets the current state pointer for state mode use.
 412:../drivers/fsl_flexio.h ****  *
 413:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 414:../drivers/fsl_flexio.h ****  * @return current State pointer
 415:../drivers/fsl_flexio.h **** */
 416:../drivers/fsl_flexio.h **** static inline uint8_t FLEXIO_GetShifterState(FLEXIO_Type *base)
 417:../drivers/fsl_flexio.h **** {
 418:../drivers/fsl_flexio.h ****     return ((base->SHIFTSTATE) & FLEXIO_SHIFTSTATE_STATE_MASK);
 419:../drivers/fsl_flexio.h **** }
 420:../drivers/fsl_flexio.h **** #endif /*FSL_FEATURE_FLEXIO_HAS_STATE_MODE*/
 421:../drivers/fsl_flexio.h **** 
 422:../drivers/fsl_flexio.h **** /*!
 423:../drivers/fsl_flexio.h ****  * @brief Configures the shifter with the shifter configuration. The configuration structure
 424:../drivers/fsl_flexio.h ****  * covers both the SHIFTCTL and SHIFTCFG registers. To configure the shifter to the proper
 425:../drivers/fsl_flexio.h ****  * mode, select which timer controls the shifter to shift, whether to generate start bit/stop
 426:../drivers/fsl_flexio.h ****  *  bit, and the polarity of start bit and stop bit.
 427:../drivers/fsl_flexio.h ****  *
 428:../drivers/fsl_flexio.h ****  * Example
 429:../drivers/fsl_flexio.h ****    @code
 430:../drivers/fsl_flexio.h ****    flexio_shifter_config_t config = {
 431:../drivers/fsl_flexio.h ****    .timerSelect = 0,
 432:../drivers/fsl_flexio.h ****    .timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive,
 433:../drivers/fsl_flexio.h ****    .pinConfig = kFLEXIO_PinConfigOpenDrainOrBidirection,
 434:../drivers/fsl_flexio.h ****    .pinPolarity = kFLEXIO_PinActiveLow,
 435:../drivers/fsl_flexio.h ****    .shifterMode = kFLEXIO_ShifterModeTransmit,
 436:../drivers/fsl_flexio.h ****    .inputSource = kFLEXIO_ShifterInputFromPin,
 437:../drivers/fsl_flexio.h ****    .shifterStop = kFLEXIO_ShifterStopBitHigh,
 438:../drivers/fsl_flexio.h ****    .shifterStart = kFLEXIO_ShifterStartBitLow
 439:../drivers/fsl_flexio.h ****    };
 440:../drivers/fsl_flexio.h ****    FLEXIO_SetShifterConfig(base, &config);
 441:../drivers/fsl_flexio.h ****    @endcode
 442:../drivers/fsl_flexio.h ****  *
 443:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 444:../drivers/fsl_flexio.h ****  * @param index Shifter index
 445:../drivers/fsl_flexio.h ****  * @param shifterConfig Pointer to flexio_shifter_config_t structure
 446:../drivers/fsl_flexio.h **** */
 447:../drivers/fsl_flexio.h **** void FLEXIO_SetShifterConfig(FLEXIO_Type *base, uint8_t index, const flexio_shifter_config_t *shift
 448:../drivers/fsl_flexio.h **** /*!
 449:../drivers/fsl_flexio.h ****  * @brief Configures the timer with the timer configuration. The configuration structure
 450:../drivers/fsl_flexio.h ****  * covers both the TIMCTL and TIMCFG registers. To configure the timer to the proper
 451:../drivers/fsl_flexio.h ****  * mode, select trigger source for timer and the timer pin output and the timing for timer.
 452:../drivers/fsl_flexio.h ****  *
 453:../drivers/fsl_flexio.h ****  * Example
 454:../drivers/fsl_flexio.h ****    @code
 455:../drivers/fsl_flexio.h ****    flexio_timer_config_t config = {
 456:../drivers/fsl_flexio.h ****    .triggerSelect = FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(0),
 457:../drivers/fsl_flexio.h ****    .triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveLow,
 458:../drivers/fsl_flexio.h ****    .triggerSource = kFLEXIO_TimerTriggerSourceInternal,
 459:../drivers/fsl_flexio.h ****    .pinConfig = kFLEXIO_PinConfigOpenDrainOrBidirection,
 460:../drivers/fsl_flexio.h ****    .pinSelect = 0,
 461:../drivers/fsl_flexio.h ****    .pinPolarity = kFLEXIO_PinActiveHigh,
 462:../drivers/fsl_flexio.h ****    .timerMode = kFLEXIO_TimerModeDual8BitBaudBit,
 463:../drivers/fsl_flexio.h ****    .timerOutput = kFLEXIO_TimerOutputZeroNotAffectedByReset,
 464:../drivers/fsl_flexio.h ****    .timerDecrement = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput,
 465:../drivers/fsl_flexio.h ****    .timerReset = kFLEXIO_TimerResetOnTimerPinEqualToTimerOutput,
 466:../drivers/fsl_flexio.h ****    .timerDisable = kFLEXIO_TimerDisableOnTimerCompare,
 467:../drivers/fsl_flexio.h ****    .timerEnable = kFLEXIO_TimerEnableOnTriggerHigh,
 468:../drivers/fsl_flexio.h ****    .timerStop = kFLEXIO_TimerStopBitEnableOnTimerDisable,
 469:../drivers/fsl_flexio.h ****    .timerStart = kFLEXIO_TimerStartBitEnabled
 470:../drivers/fsl_flexio.h ****    };
 471:../drivers/fsl_flexio.h ****    FLEXIO_SetTimerConfig(base, &config);
 472:../drivers/fsl_flexio.h ****    @endcode
 473:../drivers/fsl_flexio.h ****  *
 474:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 475:../drivers/fsl_flexio.h ****  * @param index Timer index
 476:../drivers/fsl_flexio.h ****  * @param timerConfig Pointer to the flexio_timer_config_t structure
 477:../drivers/fsl_flexio.h **** */
 478:../drivers/fsl_flexio.h **** void FLEXIO_SetTimerConfig(FLEXIO_Type *base, uint8_t index, const flexio_timer_config_t *timerConf
 479:../drivers/fsl_flexio.h **** 
 480:../drivers/fsl_flexio.h **** /* @} */
 481:../drivers/fsl_flexio.h **** 
 482:../drivers/fsl_flexio.h **** /*!
 483:../drivers/fsl_flexio.h ****  * @name FlexIO Interrupt Operation
 484:../drivers/fsl_flexio.h ****  * @{
 485:../drivers/fsl_flexio.h ****  */
 486:../drivers/fsl_flexio.h **** 
 487:../drivers/fsl_flexio.h **** /*!
 488:../drivers/fsl_flexio.h ****  * @brief Enables the shifter status interrupt. The interrupt generates when the corresponding SSF 
 489:../drivers/fsl_flexio.h ****  *
 490:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 491:../drivers/fsl_flexio.h ****  * @param mask The shifter status mask which can be calculated by (1 << shifter index)
 492:../drivers/fsl_flexio.h ****  * @note For multiple shifter status interrupt enable, for example, two shifter status enable, can 
 493:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 494:../drivers/fsl_flexio.h **** */
 495:../drivers/fsl_flexio.h **** static inline void FLEXIO_EnableShifterStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 496:../drivers/fsl_flexio.h **** {
 497:../drivers/fsl_flexio.h ****     base->SHIFTSIEN |= mask;
 646              		.loc 3 497 0
 647 000e 146A     		ldr	r4, [r2, #32]
 648 0010 2343     		orrs	r3, r4
 649              	.LVL54:
 650 0012 1362     		str	r3, [r2, #32]
 651              	.LVL55:
 652              	.L19:
 653              	.LBE39:
 654              	.LBE38:
 272:../drivers/fsl_flexio_uart.c ****     }
 273:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_RxDataRegFullInterruptEnable)
 655              		.loc 1 273 0
 656 0014 8B07     		lsls	r3, r1, #30
 657 0016 06D5     		bpl	.L18
 274:../drivers/fsl_flexio_uart.c ****     {
 275:../drivers/fsl_flexio_uart.c ****         FLEXIO_EnableShifterStatusInterrupts(base->flexioBase, 1U << base->shifterIndex[1]);
 658              		.loc 1 275 0
 659 0018 0268     		ldr	r2, [r0]
 660 001a C179     		ldrb	r1, [r0, #7]
 661              	.LVL56:
 662 001c 0123     		movs	r3, #1
 663 001e 8B40     		lsls	r3, r3, r1
 664              	.LVL57:
 665              	.LBB40:
 666              	.LBB41:
 667              		.loc 3 497 0
 668 0020 116A     		ldr	r1, [r2, #32]
 669 0022 0B43     		orrs	r3, r1
 670              	.LVL58:
 671 0024 1362     		str	r3, [r2, #32]
 672              	.LVL59:
 673              	.L18:
 674              	.LBE41:
 675              	.LBE40:
 276:../drivers/fsl_flexio_uart.c ****     }
 277:../drivers/fsl_flexio_uart.c **** }
 676              		.loc 1 277 0
 677              		@ sp needed
 678 0026 10BD     		pop	{r4, pc}
 679              		.cfi_endproc
 680              	.LFE80:
 682              		.section	.text.FLEXIO_UART_DisableInterrupts,"ax",%progbits
 683              		.align	1
 684              		.global	FLEXIO_UART_DisableInterrupts
 685              		.syntax unified
 686              		.code	16
 687              		.thumb_func
 688              		.fpu softvfp
 690              	FLEXIO_UART_DisableInterrupts:
 691              	.LFB81:
 278:../drivers/fsl_flexio_uart.c **** 
 279:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_DisableInterrupts(FLEXIO_UART_Type *base, uint32_t mask)
 280:../drivers/fsl_flexio_uart.c **** {
 692              		.loc 1 280 0
 693              		.cfi_startproc
 694              		@ args = 0, pretend = 0, frame = 0
 695              		@ frame_needed = 0, uses_anonymous_args = 0
 696              	.LVL60:
 697 0000 10B5     		push	{r4, lr}
 698              		.cfi_def_cfa_offset 8
 699              		.cfi_offset 4, -8
 700              		.cfi_offset 14, -4
 281:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_TxDataRegEmptyInterruptEnable)
 701              		.loc 1 281 0
 702 0002 CB07     		lsls	r3, r1, #31
 703 0004 06D5     		bpl	.L22
 282:../drivers/fsl_flexio_uart.c ****     {
 283:../drivers/fsl_flexio_uart.c ****         FLEXIO_DisableShifterStatusInterrupts(base->flexioBase, 1U << base->shifterIndex[0]);
 704              		.loc 1 283 0
 705 0006 0468     		ldr	r4, [r0]
 706 0008 8379     		ldrb	r3, [r0, #6]
 707 000a 0122     		movs	r2, #1
 708 000c 9A40     		lsls	r2, r2, r3
 709              	.LVL61:
 710              	.LBB42:
 711              	.LBB43:
 498:../drivers/fsl_flexio.h **** }
 499:../drivers/fsl_flexio.h **** 
 500:../drivers/fsl_flexio.h **** /*!
 501:../drivers/fsl_flexio.h ****  * @brief Disables the shifter status interrupt. The interrupt won't generate when the correspondin
 502:../drivers/fsl_flexio.h ****  *
 503:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 504:../drivers/fsl_flexio.h ****  * @param mask The shifter status mask which can be calculated by (1 << shifter index)
 505:../drivers/fsl_flexio.h ****  * @note For multiple shifter status interrupt enable, for example, two shifter status enable, can 
 506:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 507:../drivers/fsl_flexio.h **** */
 508:../drivers/fsl_flexio.h **** static inline void FLEXIO_DisableShifterStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 509:../drivers/fsl_flexio.h **** {
 510:../drivers/fsl_flexio.h ****     base->SHIFTSIEN &= ~mask;
 712              		.loc 3 510 0
 713 000e 236A     		ldr	r3, [r4, #32]
 714 0010 9343     		bics	r3, r2
 715 0012 2362     		str	r3, [r4, #32]
 716              	.LVL62:
 717              	.L22:
 718              	.LBE43:
 719              	.LBE42:
 284:../drivers/fsl_flexio_uart.c ****     }
 285:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_RxDataRegFullInterruptEnable)
 720              		.loc 1 285 0
 721 0014 8B07     		lsls	r3, r1, #30
 722 0016 06D5     		bpl	.L21
 286:../drivers/fsl_flexio_uart.c ****     {
 287:../drivers/fsl_flexio_uart.c ****         FLEXIO_DisableShifterStatusInterrupts(base->flexioBase, 1U << base->shifterIndex[1]);
 723              		.loc 1 287 0
 724 0018 0168     		ldr	r1, [r0]
 725              	.LVL63:
 726 001a C379     		ldrb	r3, [r0, #7]
 727 001c 0122     		movs	r2, #1
 728 001e 9A40     		lsls	r2, r2, r3
 729              	.LVL64:
 730              	.LBB44:
 731              	.LBB45:
 732              		.loc 3 510 0
 733 0020 0B6A     		ldr	r3, [r1, #32]
 734 0022 9343     		bics	r3, r2
 735 0024 0B62     		str	r3, [r1, #32]
 736              	.LVL65:
 737              	.L21:
 738              	.LBE45:
 739              	.LBE44:
 288:../drivers/fsl_flexio_uart.c ****     }
 289:../drivers/fsl_flexio_uart.c **** }
 740              		.loc 1 289 0
 741              		@ sp needed
 742 0026 10BD     		pop	{r4, pc}
 743              		.cfi_endproc
 744              	.LFE81:
 746              		.section	.text.FLEXIO_UART_GetStatusFlags,"ax",%progbits
 747              		.align	1
 748              		.global	FLEXIO_UART_GetStatusFlags
 749              		.syntax unified
 750              		.code	16
 751              		.thumb_func
 752              		.fpu softvfp
 754              	FLEXIO_UART_GetStatusFlags:
 755              	.LFB82:
 290:../drivers/fsl_flexio_uart.c **** 
 291:../drivers/fsl_flexio_uart.c **** uint32_t FLEXIO_UART_GetStatusFlags(FLEXIO_UART_Type *base)
 292:../drivers/fsl_flexio_uart.c **** {
 756              		.loc 1 292 0
 757              		.cfi_startproc
 758              		@ args = 0, pretend = 0, frame = 0
 759              		@ frame_needed = 0, uses_anonymous_args = 0
 760              	.LVL66:
 761 0000 70B5     		push	{r4, r5, r6, lr}
 762              		.cfi_def_cfa_offset 16
 763              		.cfi_offset 4, -16
 764              		.cfi_offset 5, -12
 765              		.cfi_offset 6, -8
 766              		.cfi_offset 14, -4
 767 0002 0500     		movs	r5, r0
 768              	.LVL67:
 293:../drivers/fsl_flexio_uart.c ****     uint32_t status = 0;
 294:../drivers/fsl_flexio_uart.c ****     status =
 295:../drivers/fsl_flexio_uart.c ****         ((FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->shifterIndex[0])) >> base->
 769              		.loc 1 295 0
 770 0004 0468     		ldr	r4, [r0]
 771              	.LVL68:
 772              	.LBB46:
 773              	.LBB47:
 511:../drivers/fsl_flexio.h **** }
 512:../drivers/fsl_flexio.h **** 
 513:../drivers/fsl_flexio.h **** /*!
 514:../drivers/fsl_flexio.h ****  * @brief Enables the shifter error interrupt. The interrupt generates when the corresponding SEF i
 515:../drivers/fsl_flexio.h ****  *
 516:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 517:../drivers/fsl_flexio.h ****  * @param mask The shifter error mask which can be calculated by (1 << shifter index)
 518:../drivers/fsl_flexio.h ****  * @note For multiple shifter error interrupt enable, for example, two shifter error enable, can ca
 519:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 520:../drivers/fsl_flexio.h **** */
 521:../drivers/fsl_flexio.h **** static inline void FLEXIO_EnableShifterErrorInterrupts(FLEXIO_Type *base, uint32_t mask)
 522:../drivers/fsl_flexio.h **** {
 523:../drivers/fsl_flexio.h ****     base->SHIFTEIEN |= mask;
 524:../drivers/fsl_flexio.h **** }
 525:../drivers/fsl_flexio.h **** 
 526:../drivers/fsl_flexio.h **** /*!
 527:../drivers/fsl_flexio.h ****  * @brief Disables the shifter error interrupt. The interrupt won't generate when the corresponding
 528:../drivers/fsl_flexio.h ****  *
 529:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 530:../drivers/fsl_flexio.h ****  * @param mask The shifter error mask which can be calculated by (1 << shifter index)
 531:../drivers/fsl_flexio.h ****  * @note For multiple shifter error interrupt enable, for example, two shifter error enable, can ca
 532:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 533:../drivers/fsl_flexio.h **** */
 534:../drivers/fsl_flexio.h **** static inline void FLEXIO_DisableShifterErrorInterrupts(FLEXIO_Type *base, uint32_t mask)
 535:../drivers/fsl_flexio.h **** {
 536:../drivers/fsl_flexio.h ****     base->SHIFTEIEN &= ~mask;
 537:../drivers/fsl_flexio.h **** }
 538:../drivers/fsl_flexio.h **** 
 539:../drivers/fsl_flexio.h **** /*!
 540:../drivers/fsl_flexio.h ****  * @brief Enables the timer status interrupt. The interrupt generates when the corresponding SSF is
 541:../drivers/fsl_flexio.h ****  *
 542:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 543:../drivers/fsl_flexio.h ****  * @param mask The timer status mask which can be calculated by (1 << timer index)
 544:../drivers/fsl_flexio.h ****  * @note For multiple timer status interrupt enable, for example, two timer status enable, can calc
 545:../drivers/fsl_flexio.h ****  * the mask by using ((1 << timer index0) | (1 << timer index1))
 546:../drivers/fsl_flexio.h **** */
 547:../drivers/fsl_flexio.h **** static inline void FLEXIO_EnableTimerStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 548:../drivers/fsl_flexio.h **** {
 549:../drivers/fsl_flexio.h ****     base->TIMIEN |= mask;
 550:../drivers/fsl_flexio.h **** }
 551:../drivers/fsl_flexio.h **** 
 552:../drivers/fsl_flexio.h **** /*!
 553:../drivers/fsl_flexio.h ****  * @brief Disables the timer status interrupt. The interrupt won't generate when the corresponding 
 554:../drivers/fsl_flexio.h ****  *
 555:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 556:../drivers/fsl_flexio.h ****  * @param mask The timer status mask which can be calculated by (1 << timer index)
 557:../drivers/fsl_flexio.h ****  * @note For multiple timer status interrupt enable, for example, two timer status enable, can calc
 558:../drivers/fsl_flexio.h ****  * the mask by using ((1 << timer index0) | (1 << timer index1))
 559:../drivers/fsl_flexio.h **** */
 560:../drivers/fsl_flexio.h **** static inline void FLEXIO_DisableTimerStatusInterrupts(FLEXIO_Type *base, uint32_t mask)
 561:../drivers/fsl_flexio.h **** {
 562:../drivers/fsl_flexio.h ****     base->TIMIEN &= ~mask;
 563:../drivers/fsl_flexio.h **** }
 564:../drivers/fsl_flexio.h **** 
 565:../drivers/fsl_flexio.h **** /* @} */
 566:../drivers/fsl_flexio.h **** 
 567:../drivers/fsl_flexio.h **** /*!
 568:../drivers/fsl_flexio.h ****  * @name FlexIO Status Operation
 569:../drivers/fsl_flexio.h ****  * @{
 570:../drivers/fsl_flexio.h ****  */
 571:../drivers/fsl_flexio.h **** 
 572:../drivers/fsl_flexio.h **** /*!
 573:../drivers/fsl_flexio.h ****  * @brief Gets the shifter status flags.
 574:../drivers/fsl_flexio.h ****  *
 575:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 576:../drivers/fsl_flexio.h ****  * @return Shifter status flags
 577:../drivers/fsl_flexio.h **** */
 578:../drivers/fsl_flexio.h **** static inline uint32_t FLEXIO_GetShifterStatusFlags(FLEXIO_Type *base)
 579:../drivers/fsl_flexio.h **** {
 580:../drivers/fsl_flexio.h ****     return ((base->SHIFTSTAT) & FLEXIO_SHIFTSTAT_SSF_MASK);
 774              		.loc 3 580 0
 775 0006 2369     		ldr	r3, [r4, #16]
 776 0008 0F22     		movs	r2, #15
 777 000a 1340     		ands	r3, r2
 778              	.LVL69:
 779              	.LBE47:
 780              	.LBE46:
 781              		.loc 1 295 0
 782 000c 8679     		ldrb	r6, [r0, #6]
 783 000e 0121     		movs	r1, #1
 784 0010 0800     		movs	r0, r1
 785              	.LVL70:
 786 0012 B040     		lsls	r0, r0, r6
 787 0014 0340     		ands	r3, r0
 294:../drivers/fsl_flexio_uart.c ****         ((FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->shifterIndex[0])) >> base->
 788              		.loc 1 294 0
 789 0016 F340     		lsrs	r3, r3, r6
 790              	.LVL71:
 791              	.LBB48:
 792              	.LBB49:
 793              		.loc 3 580 0
 794 0018 2069     		ldr	r0, [r4, #16]
 795 001a 1040     		ands	r0, r2
 796              	.LVL72:
 797              	.LBE49:
 798              	.LBE48:
 296:../drivers/fsl_flexio_uart.c ****     status |=
 297:../drivers/fsl_flexio_uart.c ****         (((FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->shifterIndex[1])) >> (base
 799              		.loc 1 297 0
 800 001c ED79     		ldrb	r5, [r5, #7]
 801              	.LVL73:
 802 001e A940     		lsls	r1, r1, r5
 803 0020 0840     		ands	r0, r1
 804 0022 E840     		lsrs	r0, r0, r5
 298:../drivers/fsl_flexio_uart.c ****          << 1U);
 805              		.loc 1 298 0
 806 0024 4000     		lsls	r0, r0, #1
 296:../drivers/fsl_flexio_uart.c ****     status |=
 807              		.loc 1 296 0
 808 0026 1843     		orrs	r0, r3
 809              	.LVL74:
 810              	.LBB50:
 811              	.LBB51:
 581:../drivers/fsl_flexio.h **** }
 582:../drivers/fsl_flexio.h **** 
 583:../drivers/fsl_flexio.h **** /*!
 584:../drivers/fsl_flexio.h ****  * @brief Clears the shifter status flags.
 585:../drivers/fsl_flexio.h ****  *
 586:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 587:../drivers/fsl_flexio.h ****  * @param mask The shifter status mask which can be calculated by (1 << shifter index)
 588:../drivers/fsl_flexio.h ****  * @note For clearing multiple shifter status flags, for example, two shifter status flags, can cal
 589:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 590:../drivers/fsl_flexio.h **** */
 591:../drivers/fsl_flexio.h **** static inline void FLEXIO_ClearShifterStatusFlags(FLEXIO_Type *base, uint32_t mask)
 592:../drivers/fsl_flexio.h **** {
 593:../drivers/fsl_flexio.h ****     base->SHIFTSTAT = mask;
 594:../drivers/fsl_flexio.h **** }
 595:../drivers/fsl_flexio.h **** 
 596:../drivers/fsl_flexio.h **** /*!
 597:../drivers/fsl_flexio.h ****  * @brief Gets the shifter error flags.
 598:../drivers/fsl_flexio.h ****  *
 599:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 600:../drivers/fsl_flexio.h ****  * @return Shifter error flags
 601:../drivers/fsl_flexio.h **** */
 602:../drivers/fsl_flexio.h **** static inline uint32_t FLEXIO_GetShifterErrorFlags(FLEXIO_Type *base)
 603:../drivers/fsl_flexio.h **** {
 604:../drivers/fsl_flexio.h ****     return ((base->SHIFTERR) & FLEXIO_SHIFTERR_SEF_MASK);
 812              		.loc 3 604 0
 813 0028 6369     		ldr	r3, [r4, #20]
 814 002a 1A40     		ands	r2, r3
 815              	.LVL75:
 816              	.LBE51:
 817              	.LBE50:
 299:../drivers/fsl_flexio_uart.c ****     status |=
 300:../drivers/fsl_flexio_uart.c ****         (((FLEXIO_GetShifterErrorFlags(base->flexioBase) & (1U << base->shifterIndex[1])) >> (base-
 818              		.loc 1 300 0
 819 002c 0A40     		ands	r2, r1
 820 002e EA40     		lsrs	r2, r2, r5
 301:../drivers/fsl_flexio_uart.c ****          << 2U);
 821              		.loc 1 301 0
 822 0030 9200     		lsls	r2, r2, #2
 299:../drivers/fsl_flexio_uart.c ****     status |=
 823              		.loc 1 299 0
 824 0032 1043     		orrs	r0, r2
 825              	.LVL76:
 302:../drivers/fsl_flexio_uart.c ****     return status;
 303:../drivers/fsl_flexio_uart.c **** }
 826              		.loc 1 303 0
 827              		@ sp needed
 828 0034 70BD     		pop	{r4, r5, r6, pc}
 829              		.cfi_endproc
 830              	.LFE82:
 832              		.section	.text.FLEXIO_UART_ClearStatusFlags,"ax",%progbits
 833              		.align	1
 834              		.global	FLEXIO_UART_ClearStatusFlags
 835              		.syntax unified
 836              		.code	16
 837              		.thumb_func
 838              		.fpu softvfp
 840              	FLEXIO_UART_ClearStatusFlags:
 841              	.LFB83:
 304:../drivers/fsl_flexio_uart.c **** 
 305:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_ClearStatusFlags(FLEXIO_UART_Type *base, uint32_t mask)
 306:../drivers/fsl_flexio_uart.c **** {
 842              		.loc 1 306 0
 843              		.cfi_startproc
 844              		@ args = 0, pretend = 0, frame = 0
 845              		@ frame_needed = 0, uses_anonymous_args = 0
 846              	.LVL77:
 847 0000 10B5     		push	{r4, lr}
 848              		.cfi_def_cfa_offset 8
 849              		.cfi_offset 4, -8
 850              		.cfi_offset 14, -4
 307:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_TxDataRegEmptyFlag)
 851              		.loc 1 307 0
 852 0002 CB07     		lsls	r3, r1, #31
 853 0004 04D5     		bpl	.L26
 308:../drivers/fsl_flexio_uart.c ****     {
 309:../drivers/fsl_flexio_uart.c ****         FLEXIO_ClearShifterStatusFlags(base->flexioBase, 1U << base->shifterIndex[0]);
 854              		.loc 1 309 0
 855 0006 0268     		ldr	r2, [r0]
 856 0008 8479     		ldrb	r4, [r0, #6]
 857 000a 0123     		movs	r3, #1
 858 000c A340     		lsls	r3, r3, r4
 859              	.LVL78:
 860              	.LBB52:
 861              	.LBB53:
 593:../drivers/fsl_flexio.h **** }
 862              		.loc 3 593 0
 863 000e 1361     		str	r3, [r2, #16]
 864              	.LVL79:
 865              	.L26:
 866              	.LBE53:
 867              	.LBE52:
 310:../drivers/fsl_flexio_uart.c ****     }
 311:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_RxDataRegFullFlag)
 868              		.loc 1 311 0
 869 0010 8B07     		lsls	r3, r1, #30
 870 0012 04D5     		bpl	.L27
 312:../drivers/fsl_flexio_uart.c ****     {
 313:../drivers/fsl_flexio_uart.c ****         FLEXIO_ClearShifterStatusFlags(base->flexioBase, 1U << base->shifterIndex[1]);
 871              		.loc 1 313 0
 872 0014 0268     		ldr	r2, [r0]
 873 0016 C479     		ldrb	r4, [r0, #7]
 874 0018 0123     		movs	r3, #1
 875 001a A340     		lsls	r3, r3, r4
 876              	.LVL80:
 877              	.LBB54:
 878              	.LBB55:
 593:../drivers/fsl_flexio.h **** }
 879              		.loc 3 593 0
 880 001c 1361     		str	r3, [r2, #16]
 881              	.LVL81:
 882              	.L27:
 883              	.LBE55:
 884              	.LBE54:
 314:../drivers/fsl_flexio_uart.c ****     }
 315:../drivers/fsl_flexio_uart.c ****     if (mask & kFLEXIO_UART_RxOverRunFlag)
 885              		.loc 1 315 0
 886 001e 4B07     		lsls	r3, r1, #29
 887 0020 04D5     		bpl	.L25
 316:../drivers/fsl_flexio_uart.c ****     {
 317:../drivers/fsl_flexio_uart.c ****         FLEXIO_ClearShifterErrorFlags(base->flexioBase, 1U << base->shifterIndex[1]);
 888              		.loc 1 317 0
 889 0022 0268     		ldr	r2, [r0]
 890 0024 C179     		ldrb	r1, [r0, #7]
 891              	.LVL82:
 892 0026 0123     		movs	r3, #1
 893 0028 8B40     		lsls	r3, r3, r1
 894              	.LVL83:
 895              	.LBB56:
 896              	.LBB57:
 605:../drivers/fsl_flexio.h **** }
 606:../drivers/fsl_flexio.h **** 
 607:../drivers/fsl_flexio.h **** /*!
 608:../drivers/fsl_flexio.h ****  * @brief Clears the shifter error flags.
 609:../drivers/fsl_flexio.h ****  *
 610:../drivers/fsl_flexio.h ****  * @param base FlexIO peripheral base address
 611:../drivers/fsl_flexio.h ****  * @param mask The shifter error mask which can be calculated by (1 << shifter index)
 612:../drivers/fsl_flexio.h ****  * @note For clearing multiple shifter error flags, for example, two shifter error flags, can calcu
 613:../drivers/fsl_flexio.h ****  * the mask by using ((1 << shifter index0) | (1 << shifter index1))
 614:../drivers/fsl_flexio.h **** */
 615:../drivers/fsl_flexio.h **** static inline void FLEXIO_ClearShifterErrorFlags(FLEXIO_Type *base, uint32_t mask)
 616:../drivers/fsl_flexio.h **** {
 617:../drivers/fsl_flexio.h ****     base->SHIFTERR = mask;
 897              		.loc 3 617 0
 898 002a 5361     		str	r3, [r2, #20]
 899              	.LVL84:
 900              	.L25:
 901              	.LBE57:
 902              	.LBE56:
 318:../drivers/fsl_flexio_uart.c ****     }
 319:../drivers/fsl_flexio_uart.c **** }
 903              		.loc 1 319 0
 904              		@ sp needed
 905 002c 10BD     		pop	{r4, pc}
 906              		.cfi_endproc
 907              	.LFE83:
 909              		.section	.text.FLEXIO_UART_TransferHandleIRQ,"ax",%progbits
 910              		.align	1
 911              		.global	FLEXIO_UART_TransferHandleIRQ
 912              		.syntax unified
 913              		.code	16
 914              		.thumb_func
 915              		.fpu softvfp
 917              	FLEXIO_UART_TransferHandleIRQ:
 918              	.LFB95:
 320:../drivers/fsl_flexio_uart.c **** 
 321:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_WriteBlocking(FLEXIO_UART_Type *base, const uint8_t *txData, size_t txSize)
 322:../drivers/fsl_flexio_uart.c **** {
 323:../drivers/fsl_flexio_uart.c ****     assert(txData);
 324:../drivers/fsl_flexio_uart.c ****     assert(txSize);
 325:../drivers/fsl_flexio_uart.c **** 
 326:../drivers/fsl_flexio_uart.c ****     while (txSize--)
 327:../drivers/fsl_flexio_uart.c ****     {
 328:../drivers/fsl_flexio_uart.c ****         /* Wait until data transfer complete. */
 329:../drivers/fsl_flexio_uart.c ****         while (!(FLEXIO_GetShifterStatusFlags(base->flexioBase) & (1U << base->shifterIndex[0])))
 330:../drivers/fsl_flexio_uart.c ****         {
 331:../drivers/fsl_flexio_uart.c ****         }
 332:../drivers/fsl_flexio_uart.c **** 
 333:../drivers/fsl_flexio_uart.c ****         base->flexioBase->SHIFTBUF[base->shifterIndex[0]] = *txData++;
 334:../drivers/fsl_flexio_uart.c ****     }
 335:../drivers/fsl_flexio_uart.c **** }
 336:../drivers/fsl_flexio_uart.c **** 
 337:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_ReadBlocking(FLEXIO_UART_Type *base, uint8_t *rxData, size_t rxSize)
 338:../drivers/fsl_flexio_uart.c **** {
 339:../drivers/fsl_flexio_uart.c ****     assert(rxData);
 340:../drivers/fsl_flexio_uart.c ****     assert(rxSize);
 341:../drivers/fsl_flexio_uart.c **** 
 342:../drivers/fsl_flexio_uart.c ****     while (rxSize--)
 343:../drivers/fsl_flexio_uart.c ****     {
 344:../drivers/fsl_flexio_uart.c ****         /* Wait until data transfer complete. */
 345:../drivers/fsl_flexio_uart.c ****         while (!(FLEXIO_UART_GetStatusFlags(base) & kFLEXIO_UART_RxDataRegFullFlag))
 346:../drivers/fsl_flexio_uart.c ****         {
 347:../drivers/fsl_flexio_uart.c ****         }
 348:../drivers/fsl_flexio_uart.c **** 
 349:../drivers/fsl_flexio_uart.c ****         *rxData++ = base->flexioBase->SHIFTBUFBYS[base->shifterIndex[1]];
 350:../drivers/fsl_flexio_uart.c ****     }
 351:../drivers/fsl_flexio_uart.c **** }
 352:../drivers/fsl_flexio_uart.c **** 
 353:../drivers/fsl_flexio_uart.c **** status_t FLEXIO_UART_TransferCreateHandle(FLEXIO_UART_Type *base,
 354:../drivers/fsl_flexio_uart.c ****                                           flexio_uart_handle_t *handle,
 355:../drivers/fsl_flexio_uart.c ****                                           flexio_uart_transfer_callback_t callback,
 356:../drivers/fsl_flexio_uart.c ****                                           void *userData)
 357:../drivers/fsl_flexio_uart.c **** {
 358:../drivers/fsl_flexio_uart.c ****     assert(handle);
 359:../drivers/fsl_flexio_uart.c **** 
 360:../drivers/fsl_flexio_uart.c ****     IRQn_Type flexio_irqs[] = FLEXIO_IRQS;
 361:../drivers/fsl_flexio_uart.c **** 
 362:../drivers/fsl_flexio_uart.c ****     /* Zero the handle. */
 363:../drivers/fsl_flexio_uart.c ****     memset(handle, 0, sizeof(*handle));
 364:../drivers/fsl_flexio_uart.c **** 
 365:../drivers/fsl_flexio_uart.c ****     /* Set the TX/RX state. */
 366:../drivers/fsl_flexio_uart.c ****     handle->rxState = kFLEXIO_UART_RxIdle;
 367:../drivers/fsl_flexio_uart.c ****     handle->txState = kFLEXIO_UART_TxIdle;
 368:../drivers/fsl_flexio_uart.c **** 
 369:../drivers/fsl_flexio_uart.c ****     /* Set the callback and user data. */
 370:../drivers/fsl_flexio_uart.c ****     handle->callback = callback;
 371:../drivers/fsl_flexio_uart.c ****     handle->userData = userData;
 372:../drivers/fsl_flexio_uart.c **** 
 373:../drivers/fsl_flexio_uart.c ****     /* Enable interrupt in NVIC. */
 374:../drivers/fsl_flexio_uart.c ****     EnableIRQ(flexio_irqs[FLEXIO_UART_GetInstance(base)]);
 375:../drivers/fsl_flexio_uart.c **** 
 376:../drivers/fsl_flexio_uart.c ****     /* Save the context in global variables to support the double weak mechanism. */
 377:../drivers/fsl_flexio_uart.c ****     return FLEXIO_RegisterHandleIRQ(base, handle, FLEXIO_UART_TransferHandleIRQ);
 378:../drivers/fsl_flexio_uart.c **** }
 379:../drivers/fsl_flexio_uart.c **** 
 380:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_TransferStartRingBuffer(FLEXIO_UART_Type *base,
 381:../drivers/fsl_flexio_uart.c ****                                          flexio_uart_handle_t *handle,
 382:../drivers/fsl_flexio_uart.c ****                                          uint8_t *ringBuffer,
 383:../drivers/fsl_flexio_uart.c ****                                          size_t ringBufferSize)
 384:../drivers/fsl_flexio_uart.c **** {
 385:../drivers/fsl_flexio_uart.c ****     assert(handle);
 386:../drivers/fsl_flexio_uart.c **** 
 387:../drivers/fsl_flexio_uart.c ****     /* Setup the ringbuffer address */
 388:../drivers/fsl_flexio_uart.c ****     if (ringBuffer)
 389:../drivers/fsl_flexio_uart.c ****     {
 390:../drivers/fsl_flexio_uart.c ****         handle->rxRingBuffer = ringBuffer;
 391:../drivers/fsl_flexio_uart.c ****         handle->rxRingBufferSize = ringBufferSize;
 392:../drivers/fsl_flexio_uart.c ****         handle->rxRingBufferHead = 0U;
 393:../drivers/fsl_flexio_uart.c ****         handle->rxRingBufferTail = 0U;
 394:../drivers/fsl_flexio_uart.c **** 
 395:../drivers/fsl_flexio_uart.c ****         /* Enable the interrupt to accept the data when user need the ring buffer. */
 396:../drivers/fsl_flexio_uart.c ****         FLEXIO_UART_EnableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 397:../drivers/fsl_flexio_uart.c ****     }
 398:../drivers/fsl_flexio_uart.c **** }
 399:../drivers/fsl_flexio_uart.c **** 
 400:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_TransferStopRingBuffer(FLEXIO_UART_Type *base, flexio_uart_handle_t *handle)
 401:../drivers/fsl_flexio_uart.c **** {
 402:../drivers/fsl_flexio_uart.c ****     assert(handle);
 403:../drivers/fsl_flexio_uart.c **** 
 404:../drivers/fsl_flexio_uart.c ****     if (handle->rxState == kFLEXIO_UART_RxIdle)
 405:../drivers/fsl_flexio_uart.c ****     {
 406:../drivers/fsl_flexio_uart.c ****         FLEXIO_UART_DisableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 407:../drivers/fsl_flexio_uart.c ****     }
 408:../drivers/fsl_flexio_uart.c **** 
 409:../drivers/fsl_flexio_uart.c ****     handle->rxRingBuffer = NULL;
 410:../drivers/fsl_flexio_uart.c ****     handle->rxRingBufferSize = 0U;
 411:../drivers/fsl_flexio_uart.c ****     handle->rxRingBufferHead = 0U;
 412:../drivers/fsl_flexio_uart.c ****     handle->rxRingBufferTail = 0U;
 413:../drivers/fsl_flexio_uart.c **** }
 414:../drivers/fsl_flexio_uart.c **** 
 415:../drivers/fsl_flexio_uart.c **** status_t FLEXIO_UART_TransferSendNonBlocking(FLEXIO_UART_Type *base,
 416:../drivers/fsl_flexio_uart.c ****                                              flexio_uart_handle_t *handle,
 417:../drivers/fsl_flexio_uart.c ****                                              flexio_uart_transfer_t *xfer)
 418:../drivers/fsl_flexio_uart.c **** {
 419:../drivers/fsl_flexio_uart.c ****     status_t status;
 420:../drivers/fsl_flexio_uart.c **** 
 421:../drivers/fsl_flexio_uart.c ****     /* Return error if xfer invalid. */
 422:../drivers/fsl_flexio_uart.c ****     if ((0U == xfer->dataSize) || (NULL == xfer->data))
 423:../drivers/fsl_flexio_uart.c ****     {
 424:../drivers/fsl_flexio_uart.c ****         return kStatus_InvalidArgument;
 425:../drivers/fsl_flexio_uart.c ****     }
 426:../drivers/fsl_flexio_uart.c **** 
 427:../drivers/fsl_flexio_uart.c ****     /* Return error if current TX busy. */
 428:../drivers/fsl_flexio_uart.c ****     if (kFLEXIO_UART_TxBusy == handle->txState)
 429:../drivers/fsl_flexio_uart.c ****     {
 430:../drivers/fsl_flexio_uart.c ****         status = kStatus_FLEXIO_UART_TxBusy;
 431:../drivers/fsl_flexio_uart.c ****     }
 432:../drivers/fsl_flexio_uart.c ****     else
 433:../drivers/fsl_flexio_uart.c ****     {
 434:../drivers/fsl_flexio_uart.c ****         handle->txData = xfer->data;
 435:../drivers/fsl_flexio_uart.c ****         handle->txDataSize = xfer->dataSize;
 436:../drivers/fsl_flexio_uart.c ****         handle->txDataSizeAll = xfer->dataSize;
 437:../drivers/fsl_flexio_uart.c ****         handle->txState = kFLEXIO_UART_TxBusy;
 438:../drivers/fsl_flexio_uart.c **** 
 439:../drivers/fsl_flexio_uart.c ****         /* Enable transmiter interrupt. */
 440:../drivers/fsl_flexio_uart.c ****         FLEXIO_UART_EnableInterrupts(base, kFLEXIO_UART_TxDataRegEmptyInterruptEnable);
 441:../drivers/fsl_flexio_uart.c **** 
 442:../drivers/fsl_flexio_uart.c ****         status = kStatus_Success;
 443:../drivers/fsl_flexio_uart.c ****     }
 444:../drivers/fsl_flexio_uart.c **** 
 445:../drivers/fsl_flexio_uart.c ****     return status;
 446:../drivers/fsl_flexio_uart.c **** }
 447:../drivers/fsl_flexio_uart.c **** 
 448:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_TransferAbortSend(FLEXIO_UART_Type *base, flexio_uart_handle_t *handle)
 449:../drivers/fsl_flexio_uart.c **** {
 450:../drivers/fsl_flexio_uart.c ****     /* Disable the transmitter and disable the interrupt. */
 451:../drivers/fsl_flexio_uart.c ****     FLEXIO_UART_DisableInterrupts(base, kFLEXIO_UART_TxDataRegEmptyInterruptEnable);
 452:../drivers/fsl_flexio_uart.c **** 
 453:../drivers/fsl_flexio_uart.c ****     handle->txDataSize = 0;
 454:../drivers/fsl_flexio_uart.c ****     handle->txState = kFLEXIO_UART_TxIdle;
 455:../drivers/fsl_flexio_uart.c **** }
 456:../drivers/fsl_flexio_uart.c **** 
 457:../drivers/fsl_flexio_uart.c **** status_t FLEXIO_UART_TransferGetSendCount(FLEXIO_UART_Type *base, flexio_uart_handle_t *handle, siz
 458:../drivers/fsl_flexio_uart.c **** {
 459:../drivers/fsl_flexio_uart.c ****     assert(handle);
 460:../drivers/fsl_flexio_uart.c ****     assert(count);
 461:../drivers/fsl_flexio_uart.c **** 
 462:../drivers/fsl_flexio_uart.c ****     if (kFLEXIO_UART_TxIdle == handle->txState)
 463:../drivers/fsl_flexio_uart.c ****     {
 464:../drivers/fsl_flexio_uart.c ****         return kStatus_NoTransferInProgress;
 465:../drivers/fsl_flexio_uart.c ****     }
 466:../drivers/fsl_flexio_uart.c **** 
 467:../drivers/fsl_flexio_uart.c ****     *count = handle->txDataSizeAll - handle->txDataSize;
 468:../drivers/fsl_flexio_uart.c **** 
 469:../drivers/fsl_flexio_uart.c ****     return kStatus_Success;
 470:../drivers/fsl_flexio_uart.c **** }
 471:../drivers/fsl_flexio_uart.c **** 
 472:../drivers/fsl_flexio_uart.c **** status_t FLEXIO_UART_TransferReceiveNonBlocking(FLEXIO_UART_Type *base,
 473:../drivers/fsl_flexio_uart.c ****                                                 flexio_uart_handle_t *handle,
 474:../drivers/fsl_flexio_uart.c ****                                                 flexio_uart_transfer_t *xfer,
 475:../drivers/fsl_flexio_uart.c ****                                                 size_t *receivedBytes)
 476:../drivers/fsl_flexio_uart.c **** {
 477:../drivers/fsl_flexio_uart.c ****     uint32_t i;
 478:../drivers/fsl_flexio_uart.c ****     status_t status;
 479:../drivers/fsl_flexio_uart.c ****     /* How many bytes to copy from ring buffer to user memory. */
 480:../drivers/fsl_flexio_uart.c ****     size_t bytesToCopy = 0U;
 481:../drivers/fsl_flexio_uart.c ****     /* How many bytes to receive. */
 482:../drivers/fsl_flexio_uart.c ****     size_t bytesToReceive;
 483:../drivers/fsl_flexio_uart.c ****     /* How many bytes currently have received. */
 484:../drivers/fsl_flexio_uart.c ****     size_t bytesCurrentReceived;
 485:../drivers/fsl_flexio_uart.c **** 
 486:../drivers/fsl_flexio_uart.c ****     /* Return error if xfer invalid. */
 487:../drivers/fsl_flexio_uart.c ****     if ((0U == xfer->dataSize) || (NULL == xfer->data))
 488:../drivers/fsl_flexio_uart.c ****     {
 489:../drivers/fsl_flexio_uart.c ****         return kStatus_InvalidArgument;
 490:../drivers/fsl_flexio_uart.c ****     }
 491:../drivers/fsl_flexio_uart.c **** 
 492:../drivers/fsl_flexio_uart.c ****     /* How to get data:
 493:../drivers/fsl_flexio_uart.c ****        1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
 494:../drivers/fsl_flexio_uart.c ****           to uart handle, enable interrupt to store received data to xfer->data. When
 495:../drivers/fsl_flexio_uart.c ****           all data received, trigger callback.
 496:../drivers/fsl_flexio_uart.c ****        2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
 497:../drivers/fsl_flexio_uart.c ****           If there are enough data in ring buffer, copy them to xfer->data and return.
 498:../drivers/fsl_flexio_uart.c ****           If there are not enough data in ring buffer, copy all of them to xfer->data,
 499:../drivers/fsl_flexio_uart.c ****           save the xfer->data remained empty space to uart handle, receive data
 500:../drivers/fsl_flexio_uart.c ****           to this empty space and trigger callback when finished. */
 501:../drivers/fsl_flexio_uart.c **** 
 502:../drivers/fsl_flexio_uart.c ****     if (kFLEXIO_UART_RxBusy == handle->rxState)
 503:../drivers/fsl_flexio_uart.c ****     {
 504:../drivers/fsl_flexio_uart.c ****         status = kStatus_FLEXIO_UART_RxBusy;
 505:../drivers/fsl_flexio_uart.c ****     }
 506:../drivers/fsl_flexio_uart.c ****     else
 507:../drivers/fsl_flexio_uart.c ****     {
 508:../drivers/fsl_flexio_uart.c ****         bytesToReceive = xfer->dataSize;
 509:../drivers/fsl_flexio_uart.c ****         bytesCurrentReceived = 0U;
 510:../drivers/fsl_flexio_uart.c **** 
 511:../drivers/fsl_flexio_uart.c ****         /* If RX ring buffer is used. */
 512:../drivers/fsl_flexio_uart.c ****         if (handle->rxRingBuffer)
 513:../drivers/fsl_flexio_uart.c ****         {
 514:../drivers/fsl_flexio_uart.c ****             /* Disable FLEXIO_UART RX IRQ, protect ring buffer. */
 515:../drivers/fsl_flexio_uart.c ****             FLEXIO_UART_DisableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 516:../drivers/fsl_flexio_uart.c **** 
 517:../drivers/fsl_flexio_uart.c ****             /* How many bytes in RX ring buffer currently. */
 518:../drivers/fsl_flexio_uart.c ****             bytesToCopy = FLEXIO_UART_TransferGetRxRingBufferLength(handle);
 519:../drivers/fsl_flexio_uart.c **** 
 520:../drivers/fsl_flexio_uart.c ****             if (bytesToCopy)
 521:../drivers/fsl_flexio_uart.c ****             {
 522:../drivers/fsl_flexio_uart.c ****                 bytesToCopy = MIN(bytesToReceive, bytesToCopy);
 523:../drivers/fsl_flexio_uart.c **** 
 524:../drivers/fsl_flexio_uart.c ****                 bytesToReceive -= bytesToCopy;
 525:../drivers/fsl_flexio_uart.c **** 
 526:../drivers/fsl_flexio_uart.c ****                 /* Copy data from ring buffer to user memory. */
 527:../drivers/fsl_flexio_uart.c ****                 for (i = 0U; i < bytesToCopy; i++)
 528:../drivers/fsl_flexio_uart.c ****                 {
 529:../drivers/fsl_flexio_uart.c ****                     xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferT
 530:../drivers/fsl_flexio_uart.c **** 
 531:../drivers/fsl_flexio_uart.c ****                     /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
 532:../drivers/fsl_flexio_uart.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 533:../drivers/fsl_flexio_uart.c ****                     {
 534:../drivers/fsl_flexio_uart.c ****                         handle->rxRingBufferTail = 0U;
 535:../drivers/fsl_flexio_uart.c ****                     }
 536:../drivers/fsl_flexio_uart.c ****                     else
 537:../drivers/fsl_flexio_uart.c ****                     {
 538:../drivers/fsl_flexio_uart.c ****                         handle->rxRingBufferTail++;
 539:../drivers/fsl_flexio_uart.c ****                     }
 540:../drivers/fsl_flexio_uart.c ****                 }
 541:../drivers/fsl_flexio_uart.c ****             }
 542:../drivers/fsl_flexio_uart.c **** 
 543:../drivers/fsl_flexio_uart.c ****             /* If ring buffer does not have enough data, still need to read more data. */
 544:../drivers/fsl_flexio_uart.c ****             if (bytesToReceive)
 545:../drivers/fsl_flexio_uart.c ****             {
 546:../drivers/fsl_flexio_uart.c ****                 /* No data in ring buffer, save the request to UART handle. */
 547:../drivers/fsl_flexio_uart.c ****                 handle->rxData = xfer->data + bytesCurrentReceived;
 548:../drivers/fsl_flexio_uart.c ****                 handle->rxDataSize = bytesToReceive;
 549:../drivers/fsl_flexio_uart.c ****                 handle->rxDataSizeAll = bytesToReceive;
 550:../drivers/fsl_flexio_uart.c ****                 handle->rxState = kFLEXIO_UART_RxBusy;
 551:../drivers/fsl_flexio_uart.c ****             }
 552:../drivers/fsl_flexio_uart.c **** 
 553:../drivers/fsl_flexio_uart.c ****             /* Enable FLEXIO_UART RX IRQ if previously enabled. */
 554:../drivers/fsl_flexio_uart.c ****             FLEXIO_UART_EnableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 555:../drivers/fsl_flexio_uart.c ****         }
 556:../drivers/fsl_flexio_uart.c ****         /* Ring buffer not used. */
 557:../drivers/fsl_flexio_uart.c ****         else
 558:../drivers/fsl_flexio_uart.c ****         {
 559:../drivers/fsl_flexio_uart.c ****             handle->rxData = xfer->data + bytesCurrentReceived;
 560:../drivers/fsl_flexio_uart.c ****             handle->rxDataSize = bytesToReceive;
 561:../drivers/fsl_flexio_uart.c ****             handle->rxDataSizeAll = bytesToReceive;
 562:../drivers/fsl_flexio_uart.c ****             handle->rxState = kFLEXIO_UART_RxBusy;
 563:../drivers/fsl_flexio_uart.c **** 
 564:../drivers/fsl_flexio_uart.c ****             /* Enable RX interrupt. */
 565:../drivers/fsl_flexio_uart.c ****             FLEXIO_UART_EnableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 566:../drivers/fsl_flexio_uart.c ****         }
 567:../drivers/fsl_flexio_uart.c **** 
 568:../drivers/fsl_flexio_uart.c ****         /* Return the how many bytes have read. */
 569:../drivers/fsl_flexio_uart.c ****         if (receivedBytes)
 570:../drivers/fsl_flexio_uart.c ****         {
 571:../drivers/fsl_flexio_uart.c ****             *receivedBytes = bytesCurrentReceived;
 572:../drivers/fsl_flexio_uart.c ****         }
 573:../drivers/fsl_flexio_uart.c **** 
 574:../drivers/fsl_flexio_uart.c ****         status = kStatus_Success;
 575:../drivers/fsl_flexio_uart.c ****     }
 576:../drivers/fsl_flexio_uart.c **** 
 577:../drivers/fsl_flexio_uart.c ****     return status;
 578:../drivers/fsl_flexio_uart.c **** }
 579:../drivers/fsl_flexio_uart.c **** 
 580:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_TransferAbortReceive(FLEXIO_UART_Type *base, flexio_uart_handle_t *handle)
 581:../drivers/fsl_flexio_uart.c **** {
 582:../drivers/fsl_flexio_uart.c ****     /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
 583:../drivers/fsl_flexio_uart.c ****     if (!handle->rxRingBuffer)
 584:../drivers/fsl_flexio_uart.c ****     {
 585:../drivers/fsl_flexio_uart.c ****         /* Disable RX interrupt. */
 586:../drivers/fsl_flexio_uart.c ****         FLEXIO_UART_DisableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 587:../drivers/fsl_flexio_uart.c ****     }
 588:../drivers/fsl_flexio_uart.c **** 
 589:../drivers/fsl_flexio_uart.c ****     handle->rxDataSize = 0U;
 590:../drivers/fsl_flexio_uart.c ****     handle->rxState = kFLEXIO_UART_RxIdle;
 591:../drivers/fsl_flexio_uart.c **** }
 592:../drivers/fsl_flexio_uart.c **** 
 593:../drivers/fsl_flexio_uart.c **** status_t FLEXIO_UART_TransferGetReceiveCount(FLEXIO_UART_Type *base, flexio_uart_handle_t *handle, 
 594:../drivers/fsl_flexio_uart.c **** {
 595:../drivers/fsl_flexio_uart.c ****     assert(handle);
 596:../drivers/fsl_flexio_uart.c ****     assert(count);
 597:../drivers/fsl_flexio_uart.c **** 
 598:../drivers/fsl_flexio_uart.c ****     if (kFLEXIO_UART_RxIdle == handle->rxState)
 599:../drivers/fsl_flexio_uart.c ****     {
 600:../drivers/fsl_flexio_uart.c ****         return kStatus_NoTransferInProgress;
 601:../drivers/fsl_flexio_uart.c ****     }
 602:../drivers/fsl_flexio_uart.c **** 
 603:../drivers/fsl_flexio_uart.c ****     *count = handle->rxDataSizeAll - handle->rxDataSize;
 604:../drivers/fsl_flexio_uart.c **** 
 605:../drivers/fsl_flexio_uart.c ****     return kStatus_Success;
 606:../drivers/fsl_flexio_uart.c **** }
 607:../drivers/fsl_flexio_uart.c **** 
 608:../drivers/fsl_flexio_uart.c **** void FLEXIO_UART_TransferHandleIRQ(void *uartType, void *uartHandle)
 609:../drivers/fsl_flexio_uart.c **** {
 919              		.loc 1 609 0
 920              		.cfi_startproc
 921              		@ args = 0, pretend = 0, frame = 0
 922              		@ frame_needed = 0, uses_anonymous_args = 0
 923              	.LVL85:
 924 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 925              		.cfi_def_cfa_offset 24
 926              		.cfi_offset 3, -24
 927              		.cfi_offset 4, -20
 928              		.cfi_offset 5, -16
 929              		.cfi_offset 6, -12
 930              		.cfi_offset 7, -8
 931              		.cfi_offset 14, -4
 932 0002 0600     		movs	r6, r0
 933 0004 0D00     		movs	r5, r1
 934              	.LVL86:
 610:../drivers/fsl_flexio_uart.c ****     uint8_t count = 1;
 611:../drivers/fsl_flexio_uart.c ****     FLEXIO_UART_Type *base = (FLEXIO_UART_Type *)uartType;
 612:../drivers/fsl_flexio_uart.c ****     flexio_uart_handle_t *handle = (flexio_uart_handle_t *)uartHandle;
 613:../drivers/fsl_flexio_uart.c **** 
 614:../drivers/fsl_flexio_uart.c ****     /* Read the status back. */
 615:../drivers/fsl_flexio_uart.c ****     uint8_t status = FLEXIO_UART_GetStatusFlags(base);
 935              		.loc 1 615 0
 936 0006 FFF7FEFF 		bl	FLEXIO_UART_GetStatusFlags
 937              	.LVL87:
 938 000a C4B2     		uxtb	r4, r0
 939              	.LVL88:
 616:../drivers/fsl_flexio_uart.c **** 
 617:../drivers/fsl_flexio_uart.c ****     /* If RX overrun. */
 618:../drivers/fsl_flexio_uart.c ****     if (kFLEXIO_UART_RxOverRunFlag & status)
 940              		.loc 1 618 0
 941 000c 6307     		lsls	r3, r4, #29
 942 000e 26D4     		bmi	.L42
 943              	.L30:
 619:../drivers/fsl_flexio_uart.c ****     {
 620:../drivers/fsl_flexio_uart.c ****         /* Clear Overrun flag. */
 621:../drivers/fsl_flexio_uart.c ****         FLEXIO_UART_ClearStatusFlags(base, kFLEXIO_UART_RxOverRunFlag);
 622:../drivers/fsl_flexio_uart.c **** 
 623:../drivers/fsl_flexio_uart.c ****         /* Trigger callback. */
 624:../drivers/fsl_flexio_uart.c ****         if (handle->callback)
 625:../drivers/fsl_flexio_uart.c ****         {
 626:../drivers/fsl_flexio_uart.c ****             handle->callback(base, handle, kStatus_FLEXIO_UART_RxHardwareOverrun, handle->userData)
 627:../drivers/fsl_flexio_uart.c ****         }
 628:../drivers/fsl_flexio_uart.c ****     }
 629:../drivers/fsl_flexio_uart.c **** 
 630:../drivers/fsl_flexio_uart.c ****     /* Receive data register full */
 631:../drivers/fsl_flexio_uart.c ****     if ((kFLEXIO_UART_RxDataRegFullFlag & status) && (base->flexioBase->SHIFTSIEN & (1U << base->sh
 944              		.loc 1 631 0
 945 0010 A307     		lsls	r3, r4, #30
 946 0012 37D5     		bpl	.L31
 947              		.loc 1 631 0 is_stmt 0 discriminator 1
 948 0014 3168     		ldr	r1, [r6]
 949 0016 086A     		ldr	r0, [r1, #32]
 950 0018 F279     		ldrb	r2, [r6, #7]
 951 001a 0123     		movs	r3, #1
 952 001c 9340     		lsls	r3, r3, r2
 953 001e 0342     		tst	r3, r0
 954 0020 30D0     		beq	.L31
 632:../drivers/fsl_flexio_uart.c ****     {
 633:../drivers/fsl_flexio_uart.c ****         /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
 634:../drivers/fsl_flexio_uart.c ****         if (handle->rxDataSize)
 955              		.loc 1 634 0 is_stmt 1
 956 0022 EB68     		ldr	r3, [r5, #12]
 957 0024 002B     		cmp	r3, #0
 958 0026 27D0     		beq	.L39
 635:../drivers/fsl_flexio_uart.c ****         {
 636:../drivers/fsl_flexio_uart.c ****             /* Using non block API to read the data from the registers. */
 637:../drivers/fsl_flexio_uart.c ****             FLEXIO_UART_ReadByte(base, handle->rxData);
 959              		.loc 1 637 0
 960 0028 AB68     		ldr	r3, [r5, #8]
 961              	.LVL89:
 962              	.LBB58:
 963              	.LBB59:
 964              		.file 4 "../drivers/fsl_flexio_uart.h"
   1:../drivers/fsl_flexio_uart.h **** /*
   2:../drivers/fsl_flexio_uart.h ****  * The Clear BSD License
   3:../drivers/fsl_flexio_uart.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_flexio_uart.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_flexio_uart.h ****  * All rights reserved.
   6:../drivers/fsl_flexio_uart.h ****  *
   7:../drivers/fsl_flexio_uart.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_flexio_uart.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_flexio_uart.h ****  * that the following conditions are met:
  10:../drivers/fsl_flexio_uart.h ****  *
  11:../drivers/fsl_flexio_uart.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_flexio_uart.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_flexio_uart.h ****  *
  14:../drivers/fsl_flexio_uart.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_flexio_uart.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_flexio_uart.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_flexio_uart.h ****  *
  18:../drivers/fsl_flexio_uart.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_flexio_uart.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_flexio_uart.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_flexio_uart.h ****  *
  22:../drivers/fsl_flexio_uart.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_flexio_uart.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_flexio_uart.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_flexio_uart.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_flexio_uart.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_flexio_uart.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_flexio_uart.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_flexio_uart.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_flexio_uart.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_flexio_uart.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_flexio_uart.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_flexio_uart.h ****  */
  34:../drivers/fsl_flexio_uart.h **** 
  35:../drivers/fsl_flexio_uart.h **** #ifndef _FSL_FLEXIO_UART_H_
  36:../drivers/fsl_flexio_uart.h **** #define _FSL_FLEXIO_UART_H_
  37:../drivers/fsl_flexio_uart.h **** 
  38:../drivers/fsl_flexio_uart.h **** #include "fsl_common.h"
  39:../drivers/fsl_flexio_uart.h **** #include "fsl_flexio.h"
  40:../drivers/fsl_flexio_uart.h **** 
  41:../drivers/fsl_flexio_uart.h **** /*!
  42:../drivers/fsl_flexio_uart.h ****  * @addtogroup flexio_uart
  43:../drivers/fsl_flexio_uart.h ****  * @{
  44:../drivers/fsl_flexio_uart.h ****  */
  45:../drivers/fsl_flexio_uart.h **** 
  46:../drivers/fsl_flexio_uart.h **** /*******************************************************************************
  47:../drivers/fsl_flexio_uart.h ****  * Definitions
  48:../drivers/fsl_flexio_uart.h ****  ******************************************************************************/
  49:../drivers/fsl_flexio_uart.h **** 
  50:../drivers/fsl_flexio_uart.h **** /*! @name Driver version */
  51:../drivers/fsl_flexio_uart.h **** /*@{*/
  52:../drivers/fsl_flexio_uart.h **** /*! @brief FlexIO UART driver version 2.1.3. */
  53:../drivers/fsl_flexio_uart.h **** #define FSL_FLEXIO_UART_DRIVER_VERSION (MAKE_VERSION(2, 1, 3))
  54:../drivers/fsl_flexio_uart.h **** /*@}*/
  55:../drivers/fsl_flexio_uart.h **** 
  56:../drivers/fsl_flexio_uart.h **** /*! @brief Error codes for the UART driver. */
  57:../drivers/fsl_flexio_uart.h **** enum _flexio_uart_status
  58:../drivers/fsl_flexio_uart.h **** {
  59:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_TxBusy = MAKE_STATUS(kStatusGroup_FLEXIO_UART, 0), /*!< Transmitter is busy
  60:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_RxBusy = MAKE_STATUS(kStatusGroup_FLEXIO_UART, 1), /*!< Receiver is busy. *
  61:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_TxIdle = MAKE_STATUS(kStatusGroup_FLEXIO_UART, 2), /*!< UART transmitter is
  62:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_RxIdle = MAKE_STATUS(kStatusGroup_FLEXIO_UART, 3), /*!< UART receiver is id
  63:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_ERROR = MAKE_STATUS(kStatusGroup_FLEXIO_UART, 4),  /*!< ERROR happens on UA
  64:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_RxRingBufferOverrun =
  65:../drivers/fsl_flexio_uart.h ****         MAKE_STATUS(kStatusGroup_FLEXIO_UART, 5), /*!< UART RX software ring buffer overrun. */
  66:../drivers/fsl_flexio_uart.h ****     kStatus_FLEXIO_UART_RxHardwareOverrun = MAKE_STATUS(kStatusGroup_FLEXIO_UART, 6) /*!< UART RX r
  67:../drivers/fsl_flexio_uart.h **** };
  68:../drivers/fsl_flexio_uart.h **** 
  69:../drivers/fsl_flexio_uart.h **** /*! @brief FlexIO UART bit count per char. */
  70:../drivers/fsl_flexio_uart.h **** typedef enum _flexio_uart_bit_count_per_char
  71:../drivers/fsl_flexio_uart.h **** {
  72:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_7BitsPerChar = 7U, /*!< 7-bit data characters */
  73:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_8BitsPerChar = 8U, /*!< 8-bit data characters */
  74:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_9BitsPerChar = 9U, /*!< 9-bit data characters */
  75:../drivers/fsl_flexio_uart.h **** } flexio_uart_bit_count_per_char_t;
  76:../drivers/fsl_flexio_uart.h **** 
  77:../drivers/fsl_flexio_uart.h **** /*! @brief Define FlexIO UART interrupt mask. */
  78:../drivers/fsl_flexio_uart.h **** enum _flexio_uart_interrupt_enable
  79:../drivers/fsl_flexio_uart.h **** {
  80:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_TxDataRegEmptyInterruptEnable = 0x1U, /*!< Transmit buffer empty interrupt enable.
  81:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_RxDataRegFullInterruptEnable = 0x2U,  /*!< Receive buffer full interrupt enable. *
  82:../drivers/fsl_flexio_uart.h **** };
  83:../drivers/fsl_flexio_uart.h **** 
  84:../drivers/fsl_flexio_uart.h **** /*! @brief Define FlexIO UART status mask. */
  85:../drivers/fsl_flexio_uart.h **** enum _flexio_uart_status_flags
  86:../drivers/fsl_flexio_uart.h **** {
  87:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_TxDataRegEmptyFlag = 0x1U, /*!< Transmit buffer empty flag. */
  88:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_RxDataRegFullFlag = 0x2U,  /*!< Receive buffer full flag. */
  89:../drivers/fsl_flexio_uart.h ****     kFLEXIO_UART_RxOverRunFlag = 0x4U,      /*!< Receive buffer over run flag. */
  90:../drivers/fsl_flexio_uart.h **** };
  91:../drivers/fsl_flexio_uart.h **** 
  92:../drivers/fsl_flexio_uart.h **** /*! @brief Define FlexIO UART access structure typedef. */
  93:../drivers/fsl_flexio_uart.h **** typedef struct _flexio_uart_type
  94:../drivers/fsl_flexio_uart.h **** {
  95:../drivers/fsl_flexio_uart.h ****     FLEXIO_Type *flexioBase; /*!< FlexIO base pointer. */
  96:../drivers/fsl_flexio_uart.h ****     uint8_t TxPinIndex;      /*!< Pin select for UART_Tx. */
  97:../drivers/fsl_flexio_uart.h ****     uint8_t RxPinIndex;      /*!< Pin select for UART_Rx. */
  98:../drivers/fsl_flexio_uart.h ****     uint8_t shifterIndex[2]; /*!< Shifter index used in FlexIO UART. */
  99:../drivers/fsl_flexio_uart.h ****     uint8_t timerIndex[2];   /*!< Timer index used in FlexIO UART. */
 100:../drivers/fsl_flexio_uart.h **** } FLEXIO_UART_Type;
 101:../drivers/fsl_flexio_uart.h **** 
 102:../drivers/fsl_flexio_uart.h **** /*! @brief Define FlexIO UART user configuration structure. */
 103:../drivers/fsl_flexio_uart.h **** typedef struct _flexio_uart_config
 104:../drivers/fsl_flexio_uart.h **** {
 105:../drivers/fsl_flexio_uart.h ****     bool enableUart;                                  /*!< Enable/disable FlexIO UART TX & RX. */
 106:../drivers/fsl_flexio_uart.h ****     bool enableInDoze;                                /*!< Enable/disable FlexIO operation in doze 
 107:../drivers/fsl_flexio_uart.h ****     bool enableInDebug;                               /*!< Enable/disable FlexIO operation in debug
 108:../drivers/fsl_flexio_uart.h ****     bool enableFastAccess;                            /*!< Enable/disable fast access to FlexIO reg
 109:../drivers/fsl_flexio_uart.h ****                                                        fast access requires the FlexIO clock to be 
 110:../drivers/fsl_flexio_uart.h ****                                                        twice the frequency of the bus clock. */
 111:../drivers/fsl_flexio_uart.h ****     uint32_t baudRate_Bps;                            /*!< Baud rate in Bps. */
 112:../drivers/fsl_flexio_uart.h ****     flexio_uart_bit_count_per_char_t bitCountPerChar; /*!< number of bits, 7/8/9 -bit */
 113:../drivers/fsl_flexio_uart.h **** } flexio_uart_config_t;
 114:../drivers/fsl_flexio_uart.h **** 
 115:../drivers/fsl_flexio_uart.h **** /*! @brief Define FlexIO UART transfer structure. */
 116:../drivers/fsl_flexio_uart.h **** typedef struct _flexio_uart_transfer
 117:../drivers/fsl_flexio_uart.h **** {
 118:../drivers/fsl_flexio_uart.h ****     uint8_t *data;   /*!< Transfer buffer*/
 119:../drivers/fsl_flexio_uart.h ****     size_t dataSize; /*!< Transfer size*/
 120:../drivers/fsl_flexio_uart.h **** } flexio_uart_transfer_t;
 121:../drivers/fsl_flexio_uart.h **** 
 122:../drivers/fsl_flexio_uart.h **** /* Forward declaration of the handle typedef. */
 123:../drivers/fsl_flexio_uart.h **** typedef struct _flexio_uart_handle flexio_uart_handle_t;
 124:../drivers/fsl_flexio_uart.h **** 
 125:../drivers/fsl_flexio_uart.h **** /*! @brief FlexIO UART transfer callback function. */
 126:../drivers/fsl_flexio_uart.h **** typedef void (*flexio_uart_transfer_callback_t)(FLEXIO_UART_Type *base,
 127:../drivers/fsl_flexio_uart.h ****                                                 flexio_uart_handle_t *handle,
 128:../drivers/fsl_flexio_uart.h ****                                                 status_t status,
 129:../drivers/fsl_flexio_uart.h ****                                                 void *userData);
 130:../drivers/fsl_flexio_uart.h **** 
 131:../drivers/fsl_flexio_uart.h **** /*! @brief Define FLEXIO UART handle structure*/
 132:../drivers/fsl_flexio_uart.h **** struct _flexio_uart_handle
 133:../drivers/fsl_flexio_uart.h **** {
 134:../drivers/fsl_flexio_uart.h ****     uint8_t *volatile txData;   /*!< Address of remaining data to send. */
 135:../drivers/fsl_flexio_uart.h ****     volatile size_t txDataSize; /*!< Size of the remaining data to send. */
 136:../drivers/fsl_flexio_uart.h ****     uint8_t *volatile rxData;   /*!< Address of remaining data to receive. */
 137:../drivers/fsl_flexio_uart.h ****     volatile size_t rxDataSize; /*!< Size of the remaining data to receive. */
 138:../drivers/fsl_flexio_uart.h ****     size_t txDataSizeAll;       /*!< Total bytes to be sent. */
 139:../drivers/fsl_flexio_uart.h ****     size_t rxDataSizeAll;       /*!< Total bytes to be received. */
 140:../drivers/fsl_flexio_uart.h **** 
 141:../drivers/fsl_flexio_uart.h ****     uint8_t *rxRingBuffer;              /*!< Start address of the receiver ring buffer. */
 142:../drivers/fsl_flexio_uart.h ****     size_t rxRingBufferSize;            /*!< Size of the ring buffer. */
 143:../drivers/fsl_flexio_uart.h ****     volatile uint16_t rxRingBufferHead; /*!< Index for the driver to store received data into ring 
 144:../drivers/fsl_flexio_uart.h ****     volatile uint16_t rxRingBufferTail; /*!< Index for the user to get data from the ring buffer. *
 145:../drivers/fsl_flexio_uart.h **** 
 146:../drivers/fsl_flexio_uart.h ****     flexio_uart_transfer_callback_t callback; /*!< Callback function. */
 147:../drivers/fsl_flexio_uart.h ****     void *userData;                           /*!< UART callback function parameter.*/
 148:../drivers/fsl_flexio_uart.h **** 
 149:../drivers/fsl_flexio_uart.h ****     volatile uint8_t txState; /*!< TX transfer state. */
 150:../drivers/fsl_flexio_uart.h ****     volatile uint8_t rxState; /*!< RX transfer state */
 151:../drivers/fsl_flexio_uart.h **** };
 152:../drivers/fsl_flexio_uart.h **** 
 153:../drivers/fsl_flexio_uart.h **** /*******************************************************************************
 154:../drivers/fsl_flexio_uart.h ****  * API
 155:../drivers/fsl_flexio_uart.h ****  ******************************************************************************/
 156:../drivers/fsl_flexio_uart.h **** 
 157:../drivers/fsl_flexio_uart.h **** #if defined(__cplusplus)
 158:../drivers/fsl_flexio_uart.h **** extern "C" {
 159:../drivers/fsl_flexio_uart.h **** #endif /*_cplusplus*/
 160:../drivers/fsl_flexio_uart.h **** 
 161:../drivers/fsl_flexio_uart.h **** /*!
 162:../drivers/fsl_flexio_uart.h ****  * @name Initialization and deinitialization
 163:../drivers/fsl_flexio_uart.h ****  * @{
 164:../drivers/fsl_flexio_uart.h ****  */
 165:../drivers/fsl_flexio_uart.h **** 
 166:../drivers/fsl_flexio_uart.h **** /*!
 167:../drivers/fsl_flexio_uart.h ****  * @brief Ungates the FlexIO clock, resets the FlexIO module, configures FlexIO UART
 168:../drivers/fsl_flexio_uart.h ****  * hardware, and configures the FlexIO UART with FlexIO UART configuration.
 169:../drivers/fsl_flexio_uart.h ****  * The configuration structure can be filled by the user or be set with
 170:../drivers/fsl_flexio_uart.h ****  * default values by FLEXIO_UART_GetDefaultConfig().
 171:../drivers/fsl_flexio_uart.h ****  *
 172:../drivers/fsl_flexio_uart.h ****  * Example
 173:../drivers/fsl_flexio_uart.h ****    @code
 174:../drivers/fsl_flexio_uart.h ****    FLEXIO_UART_Type base = {
 175:../drivers/fsl_flexio_uart.h ****    .flexioBase = FLEXIO,
 176:../drivers/fsl_flexio_uart.h ****    .TxPinIndex = 0,
 177:../drivers/fsl_flexio_uart.h ****    .RxPinIndex = 1,
 178:../drivers/fsl_flexio_uart.h ****    .shifterIndex = {0,1},
 179:../drivers/fsl_flexio_uart.h ****    .timerIndex = {0,1}
 180:../drivers/fsl_flexio_uart.h ****    };
 181:../drivers/fsl_flexio_uart.h ****    flexio_uart_config_t config = {
 182:../drivers/fsl_flexio_uart.h ****    .enableInDoze = false,
 183:../drivers/fsl_flexio_uart.h ****    .enableInDebug = true,
 184:../drivers/fsl_flexio_uart.h ****    .enableFastAccess = false,
 185:../drivers/fsl_flexio_uart.h ****    .baudRate_Bps = 115200U,
 186:../drivers/fsl_flexio_uart.h ****    .bitCountPerChar = 8
 187:../drivers/fsl_flexio_uart.h ****    };
 188:../drivers/fsl_flexio_uart.h ****    FLEXIO_UART_Init(base, &config, srcClock_Hz);
 189:../drivers/fsl_flexio_uart.h ****    @endcode
 190:../drivers/fsl_flexio_uart.h ****  *
 191:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 192:../drivers/fsl_flexio_uart.h ****  * @param userConfig Pointer to the flexio_uart_config_t structure.
 193:../drivers/fsl_flexio_uart.h ****  * @param srcClock_Hz FlexIO source clock in Hz.
 194:../drivers/fsl_flexio_uart.h ****  * @retval kStatus_Success Configuration success
 195:../drivers/fsl_flexio_uart.h ****  * @retval kStatus_InvalidArgument Buadrate configuration out of range
 196:../drivers/fsl_flexio_uart.h **** */
 197:../drivers/fsl_flexio_uart.h **** status_t FLEXIO_UART_Init(FLEXIO_UART_Type *base, const flexio_uart_config_t *userConfig, uint32_t 
 198:../drivers/fsl_flexio_uart.h **** 
 199:../drivers/fsl_flexio_uart.h **** /*!
 200:../drivers/fsl_flexio_uart.h ****  * @brief Resets the FlexIO UART shifter and timer config.
 201:../drivers/fsl_flexio_uart.h ****  *
 202:../drivers/fsl_flexio_uart.h ****  * @note After calling this API, call the FLEXO_UART_Init to use the FlexIO UART module.
 203:../drivers/fsl_flexio_uart.h ****  *
 204:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to FLEXIO_UART_Type structure
 205:../drivers/fsl_flexio_uart.h **** */
 206:../drivers/fsl_flexio_uart.h **** void FLEXIO_UART_Deinit(FLEXIO_UART_Type *base);
 207:../drivers/fsl_flexio_uart.h **** 
 208:../drivers/fsl_flexio_uart.h **** /*!
 209:../drivers/fsl_flexio_uart.h ****  * @brief Gets the default configuration to configure the FlexIO UART. The configuration
 210:../drivers/fsl_flexio_uart.h ****  * can be used directly for calling the FLEXIO_UART_Init().
 211:../drivers/fsl_flexio_uart.h ****  * Example:
 212:../drivers/fsl_flexio_uart.h ****    @code
 213:../drivers/fsl_flexio_uart.h ****    flexio_uart_config_t config;
 214:../drivers/fsl_flexio_uart.h ****    FLEXIO_UART_GetDefaultConfig(&userConfig);
 215:../drivers/fsl_flexio_uart.h ****    @endcode
 216:../drivers/fsl_flexio_uart.h ****  * @param userConfig Pointer to the flexio_uart_config_t structure.
 217:../drivers/fsl_flexio_uart.h **** */
 218:../drivers/fsl_flexio_uart.h **** void FLEXIO_UART_GetDefaultConfig(flexio_uart_config_t *userConfig);
 219:../drivers/fsl_flexio_uart.h **** 
 220:../drivers/fsl_flexio_uart.h **** /* @} */
 221:../drivers/fsl_flexio_uart.h **** 
 222:../drivers/fsl_flexio_uart.h **** /*!
 223:../drivers/fsl_flexio_uart.h ****  * @name Status
 224:../drivers/fsl_flexio_uart.h ****  * @{
 225:../drivers/fsl_flexio_uart.h ****  */
 226:../drivers/fsl_flexio_uart.h **** 
 227:../drivers/fsl_flexio_uart.h **** /*!
 228:../drivers/fsl_flexio_uart.h ****  * @brief Gets the FlexIO UART status flags.
 229:../drivers/fsl_flexio_uart.h ****  *
 230:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 231:../drivers/fsl_flexio_uart.h ****  * @return FlexIO UART status flags.
 232:../drivers/fsl_flexio_uart.h **** */
 233:../drivers/fsl_flexio_uart.h **** 
 234:../drivers/fsl_flexio_uart.h **** uint32_t FLEXIO_UART_GetStatusFlags(FLEXIO_UART_Type *base);
 235:../drivers/fsl_flexio_uart.h **** 
 236:../drivers/fsl_flexio_uart.h **** /*!
 237:../drivers/fsl_flexio_uart.h ****  * @brief Gets the FlexIO UART status flags.
 238:../drivers/fsl_flexio_uart.h ****  *
 239:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 240:../drivers/fsl_flexio_uart.h ****  * @param mask Status flag.
 241:../drivers/fsl_flexio_uart.h ****  *      The parameter can be any combination of the following values:
 242:../drivers/fsl_flexio_uart.h ****  *          @arg kFLEXIO_UART_TxDataRegEmptyFlag
 243:../drivers/fsl_flexio_uart.h ****  *          @arg kFLEXIO_UART_RxEmptyFlag
 244:../drivers/fsl_flexio_uart.h ****  *          @arg kFLEXIO_UART_RxOverRunFlag
 245:../drivers/fsl_flexio_uart.h **** */
 246:../drivers/fsl_flexio_uart.h **** 
 247:../drivers/fsl_flexio_uart.h **** void FLEXIO_UART_ClearStatusFlags(FLEXIO_UART_Type *base, uint32_t mask);
 248:../drivers/fsl_flexio_uart.h **** 
 249:../drivers/fsl_flexio_uart.h **** /* @} */
 250:../drivers/fsl_flexio_uart.h **** 
 251:../drivers/fsl_flexio_uart.h **** /*!
 252:../drivers/fsl_flexio_uart.h ****  * @name Interrupts
 253:../drivers/fsl_flexio_uart.h ****  * @{
 254:../drivers/fsl_flexio_uart.h ****  */
 255:../drivers/fsl_flexio_uart.h **** 
 256:../drivers/fsl_flexio_uart.h **** /*!
 257:../drivers/fsl_flexio_uart.h ****  * @brief Enables the FlexIO UART interrupt.
 258:../drivers/fsl_flexio_uart.h ****  *
 259:../drivers/fsl_flexio_uart.h ****  * This function enables the FlexIO UART interrupt.
 260:../drivers/fsl_flexio_uart.h ****  *
 261:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 262:../drivers/fsl_flexio_uart.h ****  * @param mask Interrupt source.
 263:../drivers/fsl_flexio_uart.h ****  */
 264:../drivers/fsl_flexio_uart.h **** void FLEXIO_UART_EnableInterrupts(FLEXIO_UART_Type *base, uint32_t mask);
 265:../drivers/fsl_flexio_uart.h **** 
 266:../drivers/fsl_flexio_uart.h **** /*!
 267:../drivers/fsl_flexio_uart.h ****  * @brief Disables the FlexIO UART interrupt.
 268:../drivers/fsl_flexio_uart.h ****  *
 269:../drivers/fsl_flexio_uart.h ****  * This function disables the FlexIO UART interrupt.
 270:../drivers/fsl_flexio_uart.h ****  *
 271:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 272:../drivers/fsl_flexio_uart.h ****  * @param mask Interrupt source.
 273:../drivers/fsl_flexio_uart.h ****  */
 274:../drivers/fsl_flexio_uart.h **** void FLEXIO_UART_DisableInterrupts(FLEXIO_UART_Type *base, uint32_t mask);
 275:../drivers/fsl_flexio_uart.h **** 
 276:../drivers/fsl_flexio_uart.h **** /* @} */
 277:../drivers/fsl_flexio_uart.h **** 
 278:../drivers/fsl_flexio_uart.h **** /*!
 279:../drivers/fsl_flexio_uart.h ****  * @name DMA Control
 280:../drivers/fsl_flexio_uart.h ****  * @{
 281:../drivers/fsl_flexio_uart.h ****  */
 282:../drivers/fsl_flexio_uart.h **** 
 283:../drivers/fsl_flexio_uart.h **** /*!
 284:../drivers/fsl_flexio_uart.h ****  * @brief Gets the FlexIO UARt transmit data register address.
 285:../drivers/fsl_flexio_uart.h ****  *
 286:../drivers/fsl_flexio_uart.h ****  * This function returns the UART data register address, which is mainly used by DMA/eDMA.
 287:../drivers/fsl_flexio_uart.h ****  *
 288:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 289:../drivers/fsl_flexio_uart.h ****  * @return FlexIO UART transmit data register address.
 290:../drivers/fsl_flexio_uart.h ****  */
 291:../drivers/fsl_flexio_uart.h **** static inline uint32_t FLEXIO_UART_GetTxDataRegisterAddress(FLEXIO_UART_Type *base)
 292:../drivers/fsl_flexio_uart.h **** {
 293:../drivers/fsl_flexio_uart.h ****     return FLEXIO_GetShifterBufferAddress(base->flexioBase, kFLEXIO_ShifterBuffer, base->shifterInd
 294:../drivers/fsl_flexio_uart.h **** }
 295:../drivers/fsl_flexio_uart.h **** 
 296:../drivers/fsl_flexio_uart.h **** /*!
 297:../drivers/fsl_flexio_uart.h ****  * @brief Gets the FlexIO UART receive data register address.
 298:../drivers/fsl_flexio_uart.h ****  *
 299:../drivers/fsl_flexio_uart.h ****  * This function returns the UART data register address, which is mainly used by DMA/eDMA.
 300:../drivers/fsl_flexio_uart.h ****  *
 301:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 302:../drivers/fsl_flexio_uart.h ****  * @return FlexIO UART receive data register address.
 303:../drivers/fsl_flexio_uart.h ****  */
 304:../drivers/fsl_flexio_uart.h **** static inline uint32_t FLEXIO_UART_GetRxDataRegisterAddress(FLEXIO_UART_Type *base)
 305:../drivers/fsl_flexio_uart.h **** {
 306:../drivers/fsl_flexio_uart.h ****     return FLEXIO_GetShifterBufferAddress(base->flexioBase, kFLEXIO_ShifterBufferByteSwapped, base-
 307:../drivers/fsl_flexio_uart.h **** }
 308:../drivers/fsl_flexio_uart.h **** 
 309:../drivers/fsl_flexio_uart.h **** /*!
 310:../drivers/fsl_flexio_uart.h ****  * @brief Enables/disables the FlexIO UART transmit DMA.
 311:../drivers/fsl_flexio_uart.h ****  * This function enables/disables the FlexIO UART Tx DMA,
 312:../drivers/fsl_flexio_uart.h ****  * which means asserting the kFLEXIO_UART_TxDataRegEmptyFlag does/doesn't trigger the DMA request.
 313:../drivers/fsl_flexio_uart.h ****  *
 314:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 315:../drivers/fsl_flexio_uart.h ****  * @param enable True to enable, false to disable.
 316:../drivers/fsl_flexio_uart.h ****  */
 317:../drivers/fsl_flexio_uart.h **** static inline void FLEXIO_UART_EnableTxDMA(FLEXIO_UART_Type *base, bool enable)
 318:../drivers/fsl_flexio_uart.h **** {
 319:../drivers/fsl_flexio_uart.h ****     FLEXIO_EnableShifterStatusDMA(base->flexioBase, 1 << base->shifterIndex[0], enable);
 320:../drivers/fsl_flexio_uart.h **** }
 321:../drivers/fsl_flexio_uart.h **** 
 322:../drivers/fsl_flexio_uart.h **** /*!
 323:../drivers/fsl_flexio_uart.h ****  * @brief Enables/disables the FlexIO UART receive DMA.
 324:../drivers/fsl_flexio_uart.h ****  * This function enables/disables the FlexIO UART Rx DMA,
 325:../drivers/fsl_flexio_uart.h ****  * which means asserting kFLEXIO_UART_RxDataRegFullFlag does/doesn't trigger the DMA request.
 326:../drivers/fsl_flexio_uart.h ****  *
 327:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 328:../drivers/fsl_flexio_uart.h ****  * @param enable True to enable, false to disable.
 329:../drivers/fsl_flexio_uart.h ****  */
 330:../drivers/fsl_flexio_uart.h **** static inline void FLEXIO_UART_EnableRxDMA(FLEXIO_UART_Type *base, bool enable)
 331:../drivers/fsl_flexio_uart.h **** {
 332:../drivers/fsl_flexio_uart.h ****     FLEXIO_EnableShifterStatusDMA(base->flexioBase, 1 << base->shifterIndex[1], enable);
 333:../drivers/fsl_flexio_uart.h **** }
 334:../drivers/fsl_flexio_uart.h **** 
 335:../drivers/fsl_flexio_uart.h **** /* @} */
 336:../drivers/fsl_flexio_uart.h **** 
 337:../drivers/fsl_flexio_uart.h **** /*!
 338:../drivers/fsl_flexio_uart.h ****  * @name Bus Operations
 339:../drivers/fsl_flexio_uart.h ****  * @{
 340:../drivers/fsl_flexio_uart.h ****  */
 341:../drivers/fsl_flexio_uart.h **** 
 342:../drivers/fsl_flexio_uart.h **** /*!
 343:../drivers/fsl_flexio_uart.h ****  * @brief Enables/disables the FlexIO UART module operation.
 344:../drivers/fsl_flexio_uart.h ****  *
 345:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type.
 346:../drivers/fsl_flexio_uart.h ****  * @param enable True to enable, false does not have any effect.
 347:../drivers/fsl_flexio_uart.h **** */
 348:../drivers/fsl_flexio_uart.h **** static inline void FLEXIO_UART_Enable(FLEXIO_UART_Type *base, bool enable)
 349:../drivers/fsl_flexio_uart.h **** {
 350:../drivers/fsl_flexio_uart.h ****     if (enable)
 351:../drivers/fsl_flexio_uart.h ****     {
 352:../drivers/fsl_flexio_uart.h ****         base->flexioBase->CTRL |= FLEXIO_CTRL_FLEXEN_MASK;
 353:../drivers/fsl_flexio_uart.h ****     }
 354:../drivers/fsl_flexio_uart.h **** }
 355:../drivers/fsl_flexio_uart.h **** 
 356:../drivers/fsl_flexio_uart.h **** /*!
 357:../drivers/fsl_flexio_uart.h ****  * @brief Writes one byte of data.
 358:../drivers/fsl_flexio_uart.h ****  *
 359:../drivers/fsl_flexio_uart.h ****  * @note This is a non-blocking API, which returns directly after the data is put into the
 360:../drivers/fsl_flexio_uart.h ****  * data register. Ensure that the TxEmptyFlag is asserted before calling
 361:../drivers/fsl_flexio_uart.h ****  * this API.
 362:../drivers/fsl_flexio_uart.h ****  *
 363:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 364:../drivers/fsl_flexio_uart.h ****  * @param buffer The data bytes to send.
 365:../drivers/fsl_flexio_uart.h ****  */
 366:../drivers/fsl_flexio_uart.h **** static inline void FLEXIO_UART_WriteByte(FLEXIO_UART_Type *base, const uint8_t *buffer)
 367:../drivers/fsl_flexio_uart.h **** {
 368:../drivers/fsl_flexio_uart.h ****     base->flexioBase->SHIFTBUF[base->shifterIndex[0]] = *buffer;
 369:../drivers/fsl_flexio_uart.h **** }
 370:../drivers/fsl_flexio_uart.h **** 
 371:../drivers/fsl_flexio_uart.h **** /*!
 372:../drivers/fsl_flexio_uart.h ****  * @brief Reads one byte of data.
 373:../drivers/fsl_flexio_uart.h ****  *
 374:../drivers/fsl_flexio_uart.h ****  * @note This is a non-blocking API, which returns directly after the data is read from the
 375:../drivers/fsl_flexio_uart.h ****  * data register. Ensure that the RxFullFlag is asserted before calling this API.
 376:../drivers/fsl_flexio_uart.h ****  *
 377:../drivers/fsl_flexio_uart.h ****  * @param base Pointer to the FLEXIO_UART_Type structure.
 378:../drivers/fsl_flexio_uart.h ****  * @param buffer The buffer to store the received bytes.
 379:../drivers/fsl_flexio_uart.h ****  */
 380:../drivers/fsl_flexio_uart.h **** static inline void FLEXIO_UART_ReadByte(FLEXIO_UART_Type *base, uint8_t *buffer)
 381:../drivers/fsl_flexio_uart.h **** {
 382:../drivers/fsl_flexio_uart.h ****     *buffer = base->flexioBase->SHIFTBUFBYS[base->shifterIndex[1]];
 965              		.loc 4 382 0
 966 002a C032     		adds	r2, r2, #192
 967 002c 9200     		lsls	r2, r2, #2
 968 002e 5258     		ldr	r2, [r2, r1]
 969 0030 1A70     		strb	r2, [r3]
 970              	.LVL90:
 971              	.LBE59:
 972              	.LBE58:
 638:../drivers/fsl_flexio_uart.c ****             handle->rxDataSize--;
 973              		.loc 1 638 0
 974 0032 EB68     		ldr	r3, [r5, #12]
 975 0034 013B     		subs	r3, r3, #1
 976 0036 EB60     		str	r3, [r5, #12]
 639:../drivers/fsl_flexio_uart.c ****             handle->rxData++;
 977              		.loc 1 639 0
 978 0038 AB68     		ldr	r3, [r5, #8]
 979 003a 0133     		adds	r3, r3, #1
 980 003c AB60     		str	r3, [r5, #8]
 981              	.LVL91:
 640:../drivers/fsl_flexio_uart.c ****             count--;
 641:../drivers/fsl_flexio_uart.c **** 
 642:../drivers/fsl_flexio_uart.c ****             /* If all the data required for upper layer is ready, trigger callback. */
 643:../drivers/fsl_flexio_uart.c ****             if (!handle->rxDataSize)
 982              		.loc 1 643 0
 983 003e EB68     		ldr	r3, [r5, #12]
 984 0040 002B     		cmp	r3, #0
 985 0042 3AD1     		bne	.L40
 644:../drivers/fsl_flexio_uart.c ****             {
 645:../drivers/fsl_flexio_uart.c ****                 handle->rxState = kFLEXIO_UART_RxIdle;
 986              		.loc 1 645 0
 987 0044 2D33     		adds	r3, r3, #45
 988 0046 0222     		movs	r2, #2
 989 0048 EA54     		strb	r2, [r5, r3]
 646:../drivers/fsl_flexio_uart.c **** 
 647:../drivers/fsl_flexio_uart.c ****                 if (handle->callback)
 990              		.loc 1 647 0
 991 004a 6F6A     		ldr	r7, [r5, #36]
 992 004c 002F     		cmp	r7, #0
 993 004e 36D0     		beq	.L41
 648:../drivers/fsl_flexio_uart.c ****                 {
 649:../drivers/fsl_flexio_uart.c ****                     handle->callback(base, handle, kStatus_FLEXIO_UART_RxIdle, handle->userData);
 994              		.loc 1 649 0
 995 0050 AB6A     		ldr	r3, [r5, #40]
 996 0052 414A     		ldr	r2, .L47
 997 0054 2900     		movs	r1, r5
 998 0056 3000     		movs	r0, r6
 999 0058 B847     		blx	r7
 1000              	.LVL92:
 640:../drivers/fsl_flexio_uart.c **** 
 1001              		.loc 1 640 0
 1002 005a 0023     		movs	r3, #0
 1003 005c 0DE0     		b	.L32
 1004              	.LVL93:
 1005              	.L42:
 621:../drivers/fsl_flexio_uart.c **** 
 1006              		.loc 1 621 0
 1007 005e 0421     		movs	r1, #4
 1008 0060 3000     		movs	r0, r6
 1009 0062 FFF7FEFF 		bl	FLEXIO_UART_ClearStatusFlags
 1010              	.LVL94:
 624:../drivers/fsl_flexio_uart.c ****         {
 1011              		.loc 1 624 0
 1012 0066 6F6A     		ldr	r7, [r5, #36]
 1013 0068 002F     		cmp	r7, #0
 1014 006a D1D0     		beq	.L30
 626:../drivers/fsl_flexio_uart.c ****         }
 1015              		.loc 1 626 0
 1016 006c AB6A     		ldr	r3, [r5, #40]
 1017 006e 3B4A     		ldr	r2, .L47+4
 1018 0070 2900     		movs	r1, r5
 1019 0072 3000     		movs	r0, r6
 1020 0074 B847     		blx	r7
 1021              	.LVL95:
 1022 0076 CBE7     		b	.L30
 1023              	.L39:
 610:../drivers/fsl_flexio_uart.c ****     FLEXIO_UART_Type *base = (FLEXIO_UART_Type *)uartType;
 1024              		.loc 1 610 0
 1025 0078 0123     		movs	r3, #1
 1026              	.LVL96:
 1027              	.L32:
 650:../drivers/fsl_flexio_uart.c ****                 }
 651:../drivers/fsl_flexio_uart.c ****             }
 652:../drivers/fsl_flexio_uart.c ****         }
 653:../drivers/fsl_flexio_uart.c **** 
 654:../drivers/fsl_flexio_uart.c ****         if (handle->rxRingBuffer)
 1028              		.loc 1 654 0
 1029 007a AA69     		ldr	r2, [r5, #24]
 1030 007c 002A     		cmp	r2, #0
 1031 007e 53D0     		beq	.L33
 655:../drivers/fsl_flexio_uart.c ****         {
 656:../drivers/fsl_flexio_uart.c ****             if (count)
 1032              		.loc 1 656 0
 1033 0080 002B     		cmp	r3, #0
 1034 0082 1ED1     		bne	.L43
 1035              	.LVL97:
 1036              	.L31:
 657:../drivers/fsl_flexio_uart.c ****             {
 658:../drivers/fsl_flexio_uart.c ****                 /* If RX ring buffer is full, trigger callback to notify over run. */
 659:../drivers/fsl_flexio_uart.c ****                 if (FLEXIO_UART_TransferIsRxRingBufferFull(handle))
 660:../drivers/fsl_flexio_uart.c ****                 {
 661:../drivers/fsl_flexio_uart.c ****                     if (handle->callback)
 662:../drivers/fsl_flexio_uart.c ****                     {
 663:../drivers/fsl_flexio_uart.c ****                         handle->callback(base, handle, kStatus_FLEXIO_UART_RxRingBufferOverrun, han
 664:../drivers/fsl_flexio_uart.c ****                     }
 665:../drivers/fsl_flexio_uart.c ****                 }
 666:../drivers/fsl_flexio_uart.c **** 
 667:../drivers/fsl_flexio_uart.c ****                 /* If ring buffer is still full after callback function, the oldest data is overrid
 668:../drivers/fsl_flexio_uart.c ****                 if (FLEXIO_UART_TransferIsRxRingBufferFull(handle))
 669:../drivers/fsl_flexio_uart.c ****                 {
 670:../drivers/fsl_flexio_uart.c ****                     /* Increase handle->rxRingBufferTail to make room for new data. */
 671:../drivers/fsl_flexio_uart.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 672:../drivers/fsl_flexio_uart.c ****                     {
 673:../drivers/fsl_flexio_uart.c ****                         handle->rxRingBufferTail = 0U;
 674:../drivers/fsl_flexio_uart.c ****                     }
 675:../drivers/fsl_flexio_uart.c ****                     else
 676:../drivers/fsl_flexio_uart.c ****                     {
 677:../drivers/fsl_flexio_uart.c ****                         handle->rxRingBufferTail++;
 678:../drivers/fsl_flexio_uart.c ****                     }
 679:../drivers/fsl_flexio_uart.c ****                 }
 680:../drivers/fsl_flexio_uart.c **** 
 681:../drivers/fsl_flexio_uart.c ****                 /* Read data. */
 682:../drivers/fsl_flexio_uart.c ****                 handle->rxRingBuffer[handle->rxRingBufferHead] = base->flexioBase->SHIFTBUFBYS[base
 683:../drivers/fsl_flexio_uart.c **** 
 684:../drivers/fsl_flexio_uart.c ****                 /* Increase handle->rxRingBufferHead. */
 685:../drivers/fsl_flexio_uart.c ****                 if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
 686:../drivers/fsl_flexio_uart.c ****                 {
 687:../drivers/fsl_flexio_uart.c ****                     handle->rxRingBufferHead = 0U;
 688:../drivers/fsl_flexio_uart.c ****                 }
 689:../drivers/fsl_flexio_uart.c ****                 else
 690:../drivers/fsl_flexio_uart.c ****                 {
 691:../drivers/fsl_flexio_uart.c ****                     handle->rxRingBufferHead++;
 692:../drivers/fsl_flexio_uart.c ****                 }
 693:../drivers/fsl_flexio_uart.c ****             }
 694:../drivers/fsl_flexio_uart.c ****         }
 695:../drivers/fsl_flexio_uart.c ****         /* If no receive requst pending, stop RX interrupt. */
 696:../drivers/fsl_flexio_uart.c ****         else if (!handle->rxDataSize)
 697:../drivers/fsl_flexio_uart.c ****         {
 698:../drivers/fsl_flexio_uart.c ****             FLEXIO_UART_DisableInterrupts(base, kFLEXIO_UART_RxDataRegFullInterruptEnable);
 699:../drivers/fsl_flexio_uart.c ****         }
 700:../drivers/fsl_flexio_uart.c ****         else
 701:../drivers/fsl_flexio_uart.c ****         {
 702:../drivers/fsl_flexio_uart.c ****         }
 703:../drivers/fsl_flexio_uart.c ****     }
 704:../drivers/fsl_flexio_uart.c **** 
 705:../drivers/fsl_flexio_uart.c ****     /* Send data register empty and the interrupt is enabled. */
 706:../drivers/fsl_flexio_uart.c ****     if ((kFLEXIO_UART_TxDataRegEmptyFlag & status) && (base->flexioBase->SHIFTSIEN & (1U << base->s
 1037              		.loc 1 706 0
 1038 0084 E307     		lsls	r3, r4, #31
 1039 0086 17D5     		bpl	.L29
 1040              		.loc 1 706 0 is_stmt 0 discriminator 1
 1041 0088 3168     		ldr	r1, [r6]
 1042 008a 086A     		ldr	r0, [r1, #32]
 1043 008c B279     		ldrb	r2, [r6, #6]
 1044 008e 0123     		movs	r3, #1
 1045 0090 9340     		lsls	r3, r3, r2
 1046 0092 0342     		tst	r3, r0
 1047 0094 10D0     		beq	.L29
 707:../drivers/fsl_flexio_uart.c ****     {
 708:../drivers/fsl_flexio_uart.c ****         if (handle->txDataSize)
 1048              		.loc 1 708 0 is_stmt 1
 1049 0096 6B68     		ldr	r3, [r5, #4]
 1050 0098 002B     		cmp	r3, #0
 1051 009a 0DD0     		beq	.L29
 709:../drivers/fsl_flexio_uart.c ****         {
 710:../drivers/fsl_flexio_uart.c ****             /* Using non block API to write the data to the registers. */
 711:../drivers/fsl_flexio_uart.c ****             FLEXIO_UART_WriteByte(base, handle->txData);
 1052              		.loc 1 711 0
 1053 009c 2B68     		ldr	r3, [r5]
 1054              	.LVL98:
 1055              	.LBB60:
 1056              	.LBB61:
 368:../drivers/fsl_flexio_uart.h **** }
 1057              		.loc 4 368 0
 1058 009e 1B78     		ldrb	r3, [r3]
 1059              	.LVL99:
 1060 00a0 8032     		adds	r2, r2, #128
 1061 00a2 9200     		lsls	r2, r2, #2
 1062 00a4 5350     		str	r3, [r2, r1]
 1063              	.LVL100:
 1064              	.LBE61:
 1065              	.LBE60:
 712:../drivers/fsl_flexio_uart.c ****             handle->txData++;
 1066              		.loc 1 712 0
 1067 00a6 2B68     		ldr	r3, [r5]
 1068 00a8 0133     		adds	r3, r3, #1
 1069 00aa 2B60     		str	r3, [r5]
 713:../drivers/fsl_flexio_uart.c ****             handle->txDataSize--;
 1070              		.loc 1 713 0
 1071 00ac 6B68     		ldr	r3, [r5, #4]
 1072 00ae 013B     		subs	r3, r3, #1
 1073 00b0 6B60     		str	r3, [r5, #4]
 714:../drivers/fsl_flexio_uart.c ****             count--;
 715:../drivers/fsl_flexio_uart.c **** 
 716:../drivers/fsl_flexio_uart.c ****             /* If all the data are written to data register, TX finished. */
 717:../drivers/fsl_flexio_uart.c ****             if (!handle->txDataSize)
 1074              		.loc 1 717 0
 1075 00b2 6B68     		ldr	r3, [r5, #4]
 1076 00b4 002B     		cmp	r3, #0
 1077 00b6 3FD0     		beq	.L44
 1078              	.LVL101:
 1079              	.L29:
 718:../drivers/fsl_flexio_uart.c ****             {
 719:../drivers/fsl_flexio_uart.c ****                 handle->txState = kFLEXIO_UART_TxIdle;
 720:../drivers/fsl_flexio_uart.c **** 
 721:../drivers/fsl_flexio_uart.c ****                 /* Disable TX register empty interrupt. */
 722:../drivers/fsl_flexio_uart.c ****                 FLEXIO_UART_DisableInterrupts(base, kFLEXIO_UART_TxDataRegEmptyInterruptEnable);
 723:../drivers/fsl_flexio_uart.c **** 
 724:../drivers/fsl_flexio_uart.c ****                 /* Trigger callback. */
 725:../drivers/fsl_flexio_uart.c ****                 if (handle->callback)
 726:../drivers/fsl_flexio_uart.c ****                 {
 727:../drivers/fsl_flexio_uart.c ****                     handle->callback(base, handle, kStatus_FLEXIO_UART_TxIdle, handle->userData);
 728:../drivers/fsl_flexio_uart.c ****                 }
 729:../drivers/fsl_flexio_uart.c ****             }
 730:../drivers/fsl_flexio_uart.c ****         }
 731:../drivers/fsl_flexio_uart.c ****     }
 732:../drivers/fsl_flexio_uart.c **** }
 1080              		.loc 1 732 0
 1081              		@ sp needed
 1082              	.LVL102:
 1083              	.LVL103:
 1084 00b8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1085              	.LVL104:
 1086              	.L40:
 640:../drivers/fsl_flexio_uart.c **** 
 1087              		.loc 1 640 0
 1088 00ba 0023     		movs	r3, #0
 1089 00bc DDE7     		b	.L32
 1090              	.L41:
 1091 00be 0023     		movs	r3, #0
 1092 00c0 DBE7     		b	.L32
 1093              	.LVL105:
 1094              	.L43:
 659:../drivers/fsl_flexio_uart.c ****                 {
 1095              		.loc 1 659 0
 1096 00c2 2800     		movs	r0, r5
 1097 00c4 FFF7FEFF 		bl	FLEXIO_UART_TransferIsRxRingBufferFull
 1098              	.LVL106:
 1099 00c8 0028     		cmp	r0, #0
 1100 00ca 07D0     		beq	.L34
 661:../drivers/fsl_flexio_uart.c ****                     {
 1101              		.loc 1 661 0
 1102 00cc 6F6A     		ldr	r7, [r5, #36]
 1103 00ce 002F     		cmp	r7, #0
 1104 00d0 04D0     		beq	.L34
 663:../drivers/fsl_flexio_uart.c ****                     }
 1105              		.loc 1 663 0
 1106 00d2 AB6A     		ldr	r3, [r5, #40]
 1107 00d4 224A     		ldr	r2, .L47+8
 1108 00d6 2900     		movs	r1, r5
 1109 00d8 3000     		movs	r0, r6
 1110 00da B847     		blx	r7
 1111              	.LVL107:
 1112              	.L34:
 668:../drivers/fsl_flexio_uart.c ****                 {
 1113              		.loc 1 668 0
 1114 00dc 2800     		movs	r0, r5
 1115 00de FFF7FEFF 		bl	FLEXIO_UART_TransferIsRxRingBufferFull
 1116              	.LVL108:
 1117 00e2 0028     		cmp	r0, #0
 1118 00e4 08D0     		beq	.L35
 671:../drivers/fsl_flexio_uart.c ****                     {
 1119              		.loc 1 671 0
 1120 00e6 6B8C     		ldrh	r3, [r5, #34]
 1121 00e8 0133     		adds	r3, r3, #1
 1122 00ea EA69     		ldr	r2, [r5, #28]
 1123 00ec 9342     		cmp	r3, r2
 1124 00ee 15D0     		beq	.L45
 677:../drivers/fsl_flexio_uart.c ****                     }
 1125              		.loc 1 677 0
 1126 00f0 6B8C     		ldrh	r3, [r5, #34]
 1127 00f2 0133     		adds	r3, r3, #1
 1128 00f4 9BB2     		uxth	r3, r3
 1129 00f6 6B84     		strh	r3, [r5, #34]
 1130              	.L35:
 682:../drivers/fsl_flexio_uart.c **** 
 1131              		.loc 1 682 0
 1132 00f8 F379     		ldrb	r3, [r6, #7]
 1133 00fa C033     		adds	r3, r3, #192
 1134 00fc 9B00     		lsls	r3, r3, #2
 1135 00fe 3268     		ldr	r2, [r6]
 1136 0100 9A58     		ldr	r2, [r3, r2]
 1137 0102 2B8C     		ldrh	r3, [r5, #32]
 1138 0104 A969     		ldr	r1, [r5, #24]
 1139 0106 CA54     		strb	r2, [r1, r3]
 685:../drivers/fsl_flexio_uart.c ****                 {
 1140              		.loc 1 685 0
 1141 0108 2B8C     		ldrh	r3, [r5, #32]
 1142 010a 0133     		adds	r3, r3, #1
 1143 010c EA69     		ldr	r2, [r5, #28]
 1144 010e 9342     		cmp	r3, r2
 1145 0110 07D0     		beq	.L46
 691:../drivers/fsl_flexio_uart.c ****                 }
 1146              		.loc 1 691 0
 1147 0112 2B8C     		ldrh	r3, [r5, #32]
 1148 0114 0133     		adds	r3, r3, #1
 1149 0116 9BB2     		uxth	r3, r3
 1150 0118 2B84     		strh	r3, [r5, #32]
 1151 011a B3E7     		b	.L31
 1152              	.L45:
 673:../drivers/fsl_flexio_uart.c ****                     }
 1153              		.loc 1 673 0
 1154 011c 0023     		movs	r3, #0
 1155 011e 6B84     		strh	r3, [r5, #34]
 1156 0120 EAE7     		b	.L35
 1157              	.L46:
 687:../drivers/fsl_flexio_uart.c ****                 }
 1158              		.loc 1 687 0
 1159 0122 0023     		movs	r3, #0
 1160 0124 2B84     		strh	r3, [r5, #32]
 1161 0126 ADE7     		b	.L31
 1162              	.LVL109:
 1163              	.L33:
 696:../drivers/fsl_flexio_uart.c ****         {
 1164              		.loc 1 696 0
 1165 0128 EB68     		ldr	r3, [r5, #12]
 1166              	.LVL110:
 1167 012a 002B     		cmp	r3, #0
 1168 012c AAD1     		bne	.L31
 698:../drivers/fsl_flexio_uart.c ****         }
 1169              		.loc 1 698 0
 1170 012e 0221     		movs	r1, #2
 1171 0130 3000     		movs	r0, r6
 1172 0132 FFF7FEFF 		bl	FLEXIO_UART_DisableInterrupts
 1173              	.LVL111:
 1174 0136 A5E7     		b	.L31
 1175              	.L44:
 719:../drivers/fsl_flexio_uart.c **** 
 1176              		.loc 1 719 0
 1177 0138 2C33     		adds	r3, r3, #44
 1178 013a 0022     		movs	r2, #0
 1179 013c EA54     		strb	r2, [r5, r3]
 722:../drivers/fsl_flexio_uart.c **** 
 1180              		.loc 1 722 0
 1181 013e 0121     		movs	r1, #1
 1182 0140 3000     		movs	r0, r6
 1183 0142 FFF7FEFF 		bl	FLEXIO_UART_DisableInterrupts
 1184              	.LVL112:
 725:../drivers/fsl_flexio_uart.c ****                 {
 1185              		.loc 1 725 0
 1186 0146 6C6A     		ldr	r4, [r5, #36]
 1187              	.LVL113:
 1188 0148 002C     		cmp	r4, #0
 1189 014a B5D0     		beq	.L29
 727:../drivers/fsl_flexio_uart.c ****                 }
 1190              		.loc 1 727 0
 1191 014c AB6A     		ldr	r3, [r5, #40]
 1192 014e 054A     		ldr	r2, .L47+12
 1193 0150 2900     		movs	r1, r5
 1194 0152 3000     		movs	r0, r6
 1195 0154 A047     		blx	r4
 1196              	.LVL114:
 1197              		.loc 1 732 0
 1198 0156 AFE7     		b	.L29
 1199              	.L48:
 1200              		.align	2
 1201              	.L47:
 1202 0158 BF020000 		.word	703
 1203 015c C2020000 		.word	706
 1204 0160 C1020000 		.word	705
 1205 0164 BE020000 		.word	702
 1206              		.cfi_endproc
 1207              	.LFE95:
 1209              		.section	.text.FLEXIO_UART_WriteBlocking,"ax",%progbits
 1210              		.align	1
 1211              		.global	FLEXIO_UART_WriteBlocking
 1212              		.syntax unified
 1213              		.code	16
 1214              		.thumb_func
 1215              		.fpu softvfp
 1217              	FLEXIO_UART_WriteBlocking:
 1218              	.LFB84:
 322:../drivers/fsl_flexio_uart.c ****     assert(txData);
 1219              		.loc 1 322 0
 1220              		.cfi_startproc
 1221              		@ args = 0, pretend = 0, frame = 0
 1222              		@ frame_needed = 0, uses_anonymous_args = 0
 1223              	.LVL115:
 1224 0000 70B5     		push	{r4, r5, r6, lr}
 1225              		.cfi_def_cfa_offset 16
 1226              		.cfi_offset 4, -16
 1227              		.cfi_offset 5, -12
 1228              		.cfi_offset 6, -8
 1229              		.cfi_offset 14, -4
 326:../drivers/fsl_flexio_uart.c ****     {
 1230              		.loc 1 326 0
 1231 0002 0EE0     		b	.L50
 1232              	.LVL116:
 1233              	.L51:
 329:../drivers/fsl_flexio_uart.c ****         {
 1234              		.loc 1 329 0 discriminator 1
 1235 0004 0568     		ldr	r5, [r0]
 1236              	.LVL117:
 1237              	.LBB62:
 1238              	.LBB63:
 580:../drivers/fsl_flexio.h **** }
 1239              		.loc 3 580 0 discriminator 1
 1240 0006 2B69     		ldr	r3, [r5, #16]
 1241 0008 0F22     		movs	r2, #15
 1242 000a 1A40     		ands	r2, r3
 1243              	.LVL118:
 1244              	.LBE63:
 1245              	.LBE62:
 329:../drivers/fsl_flexio_uart.c ****         {
 1246              		.loc 1 329 0 discriminator 1
 1247 000c 8479     		ldrb	r4, [r0, #6]
 1248 000e 0123     		movs	r3, #1
 1249 0010 A340     		lsls	r3, r3, r4
 1250 0012 1A42     		tst	r2, r3
 1251 0014 F6D0     		beq	.L51
 1252              	.LVL119:
 333:../drivers/fsl_flexio_uart.c ****     }
 1253              		.loc 1 333 0
 1254 0016 0B78     		ldrb	r3, [r1]
 1255 0018 8034     		adds	r4, r4, #128
 1256 001a A400     		lsls	r4, r4, #2
 1257 001c 6351     		str	r3, [r4, r5]
 326:../drivers/fsl_flexio_uart.c ****     {
 1258              		.loc 1 326 0
 1259 001e 3200     		movs	r2, r6
 333:../drivers/fsl_flexio_uart.c ****     }
 1260              		.loc 1 333 0
 1261 0020 0131     		adds	r1, r1, #1
 1262              	.LVL120:
 1263              	.L50:
 326:../drivers/fsl_flexio_uart.c ****     {
 1264              		.loc 1 326 0
 1265 0022 561E     		subs	r6, r2, #1
 1266              	.LVL121:
 1267 0024 002A     		cmp	r2, #0
 1268 0026 EDD1     		bne	.L51
 335:../drivers/fsl_flexio_uart.c **** 
 1269              		.loc 1 335 0
 1270              		@ sp needed
 1271              	.LVL122:
 1272 0028 70BD     		pop	{r4, r5, r6, pc}
 1273              		.cfi_endproc
 1274              	.LFE84:
 1276              		.section	.text.FLEXIO_UART_ReadBlocking,"ax",%progbits
 1277              		.align	1
 1278              		.global	FLEXIO_UART_ReadBlocking
 1279              		.syntax unified
 1280              		.code	16
 1281              		.thumb_func
 1282              		.fpu softvfp
 1284              	FLEXIO_UART_ReadBlocking:
 1285              	.LFB85:
 338:../drivers/fsl_flexio_uart.c ****     assert(rxData);
 1286              		.loc 1 338 0
 1287              		.cfi_startproc
 1288              		@ args = 0, pretend = 0, frame = 0
 1289              		@ frame_needed = 0, uses_anonymous_args = 0
 1290              	.LVL123:
 1291 0000 70B5     		push	{r4, r5, r6, lr}
 1292              		.cfi_def_cfa_offset 16
 1293              		.cfi_offset 4, -16
 1294              		.cfi_offset 5, -12
 1295              		.cfi_offset 6, -8
 1296              		.cfi_offset 14, -4
 1297 0002 0400     		movs	r4, r0
 1298 0004 0D00     		movs	r5, r1
 342:../drivers/fsl_flexio_uart.c ****     {
 1299              		.loc 1 342 0
 1300 0006 0CE0     		b	.L53
 1301              	.LVL124:
 1302              	.L54:
 345:../drivers/fsl_flexio_uart.c ****         {
 1303              		.loc 1 345 0 discriminator 1
 1304 0008 2000     		movs	r0, r4
 1305 000a FFF7FEFF 		bl	FLEXIO_UART_GetStatusFlags
 1306              	.LVL125:
 1307 000e 8307     		lsls	r3, r0, #30
 1308 0010 FAD5     		bpl	.L54
 349:../drivers/fsl_flexio_uart.c ****     }
 1309              		.loc 1 349 0
 1310 0012 E379     		ldrb	r3, [r4, #7]
 1311 0014 C033     		adds	r3, r3, #192
 1312 0016 9B00     		lsls	r3, r3, #2
 1313 0018 2268     		ldr	r2, [r4]
 1314 001a 9B58     		ldr	r3, [r3, r2]
 1315              	.LVL126:
 1316 001c 2B70     		strb	r3, [r5]
 342:../drivers/fsl_flexio_uart.c ****     {
 1317              		.loc 1 342 0
 1318 001e 3200     		movs	r2, r6
 349:../drivers/fsl_flexio_uart.c ****     }
 1319              		.loc 1 349 0
 1320 0020 0135     		adds	r5, r5, #1
 1321              	.LVL127:
 1322              	.L53:
 342:../drivers/fsl_flexio_uart.c ****     {
 1323              		.loc 1 342 0
 1324 0022 561E     		subs	r6, r2, #1
 1325              	.LVL128:
 1326 0024 002A     		cmp	r2, #0
 1327 0026 EFD1     		bne	.L54
 351:../drivers/fsl_flexio_uart.c **** 
 1328              		.loc 1 351 0
 1329              		@ sp needed
 1330              	.LVL129:
 1331              	.LVL130:
 1332              	.LVL131:
 1333 0028 70BD     		pop	{r4, r5, r6, pc}
 1334              		.cfi_endproc
 1335              	.LFE85:
 1337              		.section	.text.FLEXIO_UART_TransferCreateHandle,"ax",%progbits
 1338              		.align	1
 1339              		.global	FLEXIO_UART_TransferCreateHandle
 1340              		.syntax unified
 1341              		.code	16
 1342              		.thumb_func
 1343              		.fpu softvfp
 1345              	FLEXIO_UART_TransferCreateHandle:
 1346              	.LFB86:
 357:../drivers/fsl_flexio_uart.c ****     assert(handle);
 1347              		.loc 1 357 0
 1348              		.cfi_startproc
 1349              		@ args = 0, pretend = 0, frame = 0
 1350              		@ frame_needed = 0, uses_anonymous_args = 0
 1351              	.LVL132:
 1352 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1353              		.cfi_def_cfa_offset 24
 1354              		.cfi_offset 3, -24
 1355              		.cfi_offset 4, -20
 1356              		.cfi_offset 5, -16
 1357              		.cfi_offset 6, -12
 1358              		.cfi_offset 7, -8
 1359              		.cfi_offset 14, -4
 1360 0002 0500     		movs	r5, r0
 1361 0004 0C00     		movs	r4, r1
 1362 0006 1700     		movs	r7, r2
 1363 0008 1E00     		movs	r6, r3
 363:../drivers/fsl_flexio_uart.c **** 
 1364              		.loc 1 363 0
 1365 000a 3022     		movs	r2, #48
 1366              	.LVL133:
 1367 000c 0021     		movs	r1, #0
 1368              	.LVL134:
 1369 000e 2000     		movs	r0, r4
 1370              	.LVL135:
 1371 0010 FFF7FEFF 		bl	memset
 1372              	.LVL136:
 366:../drivers/fsl_flexio_uart.c ****     handle->txState = kFLEXIO_UART_TxIdle;
 1373              		.loc 1 366 0
 1374 0014 2D23     		movs	r3, #45
 1375 0016 0222     		movs	r2, #2
 1376 0018 E254     		strb	r2, [r4, r3]
 367:../drivers/fsl_flexio_uart.c **** 
 1377              		.loc 1 367 0
 1378 001a 013B     		subs	r3, r3, #1
 1379 001c 0022     		movs	r2, #0
 1380 001e E254     		strb	r2, [r4, r3]
 370:../drivers/fsl_flexio_uart.c ****     handle->userData = userData;
 1381              		.loc 1 370 0
 1382 0020 6762     		str	r7, [r4, #36]
 371:../drivers/fsl_flexio_uart.c **** 
 1383              		.loc 1 371 0
 1384 0022 A662     		str	r6, [r4, #40]
 374:../drivers/fsl_flexio_uart.c **** 
 1385              		.loc 1 374 0
 1386 0024 2800     		movs	r0, r5
 1387 0026 FFF7FEFF 		bl	FLEXIO_UART_GetInstance
 1388              	.LVL137:
 1389              	.LBB64:
 1390              	.LBB65:
 1391              	.LBB66:
 1392              		.file 5 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 1393              		.loc 5 735 0
 1394 002a 054B     		ldr	r3, .L56
 1395 002c 8022     		movs	r2, #128
 1396 002e D201     		lsls	r2, r2, #7
 1397 0030 1A60     		str	r2, [r3]
 1398              	.LVL138:
 1399              	.LBE66:
 1400              	.LBE65:
 1401              	.LBE64:
 377:../drivers/fsl_flexio_uart.c **** }
 1402              		.loc 1 377 0
 1403 0032 044A     		ldr	r2, .L56+4
 1404 0034 2100     		movs	r1, r4
 1405 0036 2800     		movs	r0, r5
 1406 0038 FFF7FEFF 		bl	FLEXIO_RegisterHandleIRQ
 1407              	.LVL139:
 378:../drivers/fsl_flexio_uart.c **** 
 1408              		.loc 1 378 0
 1409              		@ sp needed
 1410              	.LVL140:
 1411              	.LVL141:
 1412              	.LVL142:
 1413              	.LVL143:
 1414 003c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1415              	.L57:
 1416 003e C046     		.align	2
 1417              	.L56:
 1418 0040 00E100E0 		.word	-536813312
 1419 0044 00000000 		.word	FLEXIO_UART_TransferHandleIRQ
 1420              		.cfi_endproc
 1421              	.LFE86:
 1423              		.section	.text.FLEXIO_UART_TransferStartRingBuffer,"ax",%progbits
 1424              		.align	1
 1425              		.global	FLEXIO_UART_TransferStartRingBuffer
 1426              		.syntax unified
 1427              		.code	16
 1428              		.thumb_func
 1429              		.fpu softvfp
 1431              	FLEXIO_UART_TransferStartRingBuffer:
 1432              	.LFB87:
 384:../drivers/fsl_flexio_uart.c ****     assert(handle);
 1433              		.loc 1 384 0
 1434              		.cfi_startproc
 1435              		@ args = 0, pretend = 0, frame = 0
 1436              		@ frame_needed = 0, uses_anonymous_args = 0
 1437              	.LVL144:
 1438 0000 10B5     		push	{r4, lr}
 1439              		.cfi_def_cfa_offset 8
 1440              		.cfi_offset 4, -8
 1441              		.cfi_offset 14, -4
 388:../drivers/fsl_flexio_uart.c ****     {
 1442              		.loc 1 388 0
 1443 0002 002A     		cmp	r2, #0
 1444 0004 07D0     		beq	.L58
 390:../drivers/fsl_flexio_uart.c ****         handle->rxRingBufferSize = ringBufferSize;
 1445              		.loc 1 390 0
 1446 0006 8A61     		str	r2, [r1, #24]
 391:../drivers/fsl_flexio_uart.c ****         handle->rxRingBufferHead = 0U;
 1447              		.loc 1 391 0
 1448 0008 CB61     		str	r3, [r1, #28]
 392:../drivers/fsl_flexio_uart.c ****         handle->rxRingBufferTail = 0U;
 1449              		.loc 1 392 0
 1450 000a 0023     		movs	r3, #0
 1451              	.LVL145:
 1452 000c 0B84     		strh	r3, [r1, #32]
 393:../drivers/fsl_flexio_uart.c **** 
 1453              		.loc 1 393 0
 1454 000e 4B84     		strh	r3, [r1, #34]
 396:../drivers/fsl_flexio_uart.c ****     }
 1455              		.loc 1 396 0
 1456 0010 0221     		movs	r1, #2
 1457              	.LVL146:
 1458 0012 FFF7FEFF 		bl	FLEXIO_UART_EnableInterrupts
 1459              	.LVL147:
 1460              	.L58:
 398:../drivers/fsl_flexio_uart.c **** 
 1461              		.loc 1 398 0
 1462              		@ sp needed
 1463 0016 10BD     		pop	{r4, pc}
 1464              		.cfi_endproc
 1465              	.LFE87:
 1467              		.section	.text.FLEXIO_UART_TransferStopRingBuffer,"ax",%progbits
 1468              		.align	1
 1469              		.global	FLEXIO_UART_TransferStopRingBuffer
 1470              		.syntax unified
 1471              		.code	16
 1472              		.thumb_func
 1473              		.fpu softvfp
 1475              	FLEXIO_UART_TransferStopRingBuffer:
 1476              	.LFB88:
 401:../drivers/fsl_flexio_uart.c ****     assert(handle);
 1477              		.loc 1 401 0
 1478              		.cfi_startproc
 1479              		@ args = 0, pretend = 0, frame = 0
 1480              		@ frame_needed = 0, uses_anonymous_args = 0
 1481              	.LVL148:
 1482 0000 10B5     		push	{r4, lr}
 1483              		.cfi_def_cfa_offset 8
 1484              		.cfi_offset 4, -8
 1485              		.cfi_offset 14, -4
 1486 0002 0C00     		movs	r4, r1
 404:../drivers/fsl_flexio_uart.c ****     {
 1487              		.loc 1 404 0
 1488 0004 2D23     		movs	r3, #45
 1489 0006 CB5C     		ldrb	r3, [r1, r3]
 1490 0008 022B     		cmp	r3, #2
 1491 000a 05D0     		beq	.L62
 1492              	.LVL149:
 1493              	.L61:
 409:../drivers/fsl_flexio_uart.c ****     handle->rxRingBufferSize = 0U;
 1494              		.loc 1 409 0
 1495 000c 0023     		movs	r3, #0
 1496 000e A361     		str	r3, [r4, #24]
 410:../drivers/fsl_flexio_uart.c ****     handle->rxRingBufferHead = 0U;
 1497              		.loc 1 410 0
 1498 0010 E361     		str	r3, [r4, #28]
 411:../drivers/fsl_flexio_uart.c ****     handle->rxRingBufferTail = 0U;
 1499              		.loc 1 411 0
 1500 0012 2384     		strh	r3, [r4, #32]
 412:../drivers/fsl_flexio_uart.c **** }
 1501              		.loc 1 412 0
 1502 0014 6384     		strh	r3, [r4, #34]
 413:../drivers/fsl_flexio_uart.c **** 
 1503              		.loc 1 413 0
 1504              		@ sp needed
 1505              	.LVL150:
 1506 0016 10BD     		pop	{r4, pc}
 1507              	.LVL151:
 1508              	.L62:
 406:../drivers/fsl_flexio_uart.c ****     }
 1509              		.loc 1 406 0
 1510 0018 0221     		movs	r1, #2
 1511              	.LVL152:
 1512 001a FFF7FEFF 		bl	FLEXIO_UART_DisableInterrupts
 1513              	.LVL153:
 1514 001e F5E7     		b	.L61
 1515              		.cfi_endproc
 1516              	.LFE88:
 1518              		.section	.text.FLEXIO_UART_TransferSendNonBlocking,"ax",%progbits
 1519              		.align	1
 1520              		.global	FLEXIO_UART_TransferSendNonBlocking
 1521              		.syntax unified
 1522              		.code	16
 1523              		.thumb_func
 1524              		.fpu softvfp
 1526              	FLEXIO_UART_TransferSendNonBlocking:
 1527              	.LFB89:
 418:../drivers/fsl_flexio_uart.c ****     status_t status;
 1528              		.loc 1 418 0
 1529              		.cfi_startproc
 1530              		@ args = 0, pretend = 0, frame = 0
 1531              		@ frame_needed = 0, uses_anonymous_args = 0
 1532              	.LVL154:
 1533 0000 10B5     		push	{r4, lr}
 1534              		.cfi_def_cfa_offset 8
 1535              		.cfi_offset 4, -8
 1536              		.cfi_offset 14, -4
 422:../drivers/fsl_flexio_uart.c ****     {
 1537              		.loc 1 422 0
 1538 0002 5368     		ldr	r3, [r2, #4]
 1539 0004 002B     		cmp	r3, #0
 1540 0006 13D0     		beq	.L65
 422:../drivers/fsl_flexio_uart.c ****     {
 1541              		.loc 1 422 0 is_stmt 0 discriminator 1
 1542 0008 1368     		ldr	r3, [r2]
 1543 000a 002B     		cmp	r3, #0
 1544 000c 12D0     		beq	.L66
 428:../drivers/fsl_flexio_uart.c ****     {
 1545              		.loc 1 428 0 is_stmt 1
 1546 000e 2C24     		movs	r4, #44
 1547 0010 0C5D     		ldrb	r4, [r1, r4]
 1548 0012 012C     		cmp	r4, #1
 1549 0014 10D0     		beq	.L67
 434:../drivers/fsl_flexio_uart.c ****         handle->txDataSize = xfer->dataSize;
 1550              		.loc 1 434 0
 1551 0016 0B60     		str	r3, [r1]
 435:../drivers/fsl_flexio_uart.c ****         handle->txDataSizeAll = xfer->dataSize;
 1552              		.loc 1 435 0
 1553 0018 5368     		ldr	r3, [r2, #4]
 1554 001a 4B60     		str	r3, [r1, #4]
 436:../drivers/fsl_flexio_uart.c ****         handle->txState = kFLEXIO_UART_TxBusy;
 1555              		.loc 1 436 0
 1556 001c 5368     		ldr	r3, [r2, #4]
 1557 001e 0B61     		str	r3, [r1, #16]
 437:../drivers/fsl_flexio_uart.c **** 
 1558              		.loc 1 437 0
 1559 0020 2C23     		movs	r3, #44
 1560 0022 0122     		movs	r2, #1
 1561              	.LVL155:
 1562 0024 CA54     		strb	r2, [r1, r3]
 440:../drivers/fsl_flexio_uart.c **** 
 1563              		.loc 1 440 0
 1564 0026 0121     		movs	r1, #1
 1565              	.LVL156:
 1566 0028 FFF7FEFF 		bl	FLEXIO_UART_EnableInterrupts
 1567              	.LVL157:
 442:../drivers/fsl_flexio_uart.c ****     }
 1568              		.loc 1 442 0
 1569 002c 0020     		movs	r0, #0
 1570              	.LVL158:
 1571              	.L63:
 446:../drivers/fsl_flexio_uart.c **** 
 1572              		.loc 1 446 0
 1573              		@ sp needed
 1574 002e 10BD     		pop	{r4, pc}
 1575              	.LVL159:
 1576              	.L65:
 424:../drivers/fsl_flexio_uart.c ****     }
 1577              		.loc 1 424 0
 1578 0030 0420     		movs	r0, #4
 1579              	.LVL160:
 1580 0032 FCE7     		b	.L63
 1581              	.LVL161:
 1582              	.L66:
 1583 0034 0420     		movs	r0, #4
 1584              	.LVL162:
 1585 0036 FAE7     		b	.L63
 1586              	.LVL163:
 1587              	.L67:
 430:../drivers/fsl_flexio_uart.c ****     }
 1588              		.loc 1 430 0
 1589 0038 AF20     		movs	r0, #175
 1590              	.LVL164:
 1591 003a 8000     		lsls	r0, r0, #2
 1592 003c F7E7     		b	.L63
 1593              		.cfi_endproc
 1594              	.LFE89:
 1596              		.section	.text.FLEXIO_UART_TransferAbortSend,"ax",%progbits
 1597              		.align	1
 1598              		.global	FLEXIO_UART_TransferAbortSend
 1599              		.syntax unified
 1600              		.code	16
 1601              		.thumb_func
 1602              		.fpu softvfp
 1604              	FLEXIO_UART_TransferAbortSend:
 1605              	.LFB90:
 449:../drivers/fsl_flexio_uart.c ****     /* Disable the transmitter and disable the interrupt. */
 1606              		.loc 1 449 0
 1607              		.cfi_startproc
 1608              		@ args = 0, pretend = 0, frame = 0
 1609              		@ frame_needed = 0, uses_anonymous_args = 0
 1610              	.LVL165:
 1611 0000 10B5     		push	{r4, lr}
 1612              		.cfi_def_cfa_offset 8
 1613              		.cfi_offset 4, -8
 1614              		.cfi_offset 14, -4
 1615 0002 0C00     		movs	r4, r1
 451:../drivers/fsl_flexio_uart.c **** 
 1616              		.loc 1 451 0
 1617 0004 0121     		movs	r1, #1
 1618              	.LVL166:
 1619 0006 FFF7FEFF 		bl	FLEXIO_UART_DisableInterrupts
 1620              	.LVL167:
 453:../drivers/fsl_flexio_uart.c ****     handle->txState = kFLEXIO_UART_TxIdle;
 1621              		.loc 1 453 0
 1622 000a 0023     		movs	r3, #0
 1623 000c 6360     		str	r3, [r4, #4]
 454:../drivers/fsl_flexio_uart.c **** }
 1624              		.loc 1 454 0
 1625 000e 2C22     		movs	r2, #44
 1626 0010 A354     		strb	r3, [r4, r2]
 455:../drivers/fsl_flexio_uart.c **** 
 1627              		.loc 1 455 0
 1628              		@ sp needed
 1629              	.LVL168:
 1630 0012 10BD     		pop	{r4, pc}
 1631              		.cfi_endproc
 1632              	.LFE90:
 1634              		.section	.text.FLEXIO_UART_TransferGetSendCount,"ax",%progbits
 1635              		.align	1
 1636              		.global	FLEXIO_UART_TransferGetSendCount
 1637              		.syntax unified
 1638              		.code	16
 1639              		.thumb_func
 1640              		.fpu softvfp
 1642              	FLEXIO_UART_TransferGetSendCount:
 1643              	.LFB91:
 458:../drivers/fsl_flexio_uart.c ****     assert(handle);
 1644              		.loc 1 458 0
 1645              		.cfi_startproc
 1646              		@ args = 0, pretend = 0, frame = 0
 1647              		@ frame_needed = 0, uses_anonymous_args = 0
 1648              		@ link register save eliminated.
 1649              	.LVL169:
 462:../drivers/fsl_flexio_uart.c ****     {
 1650              		.loc 1 462 0
 1651 0000 2C23     		movs	r3, #44
 1652 0002 CB5C     		ldrb	r3, [r1, r3]
 1653 0004 002B     		cmp	r3, #0
 1654 0006 05D0     		beq	.L71
 467:../drivers/fsl_flexio_uart.c **** 
 1655              		.loc 1 467 0
 1656 0008 0B69     		ldr	r3, [r1, #16]
 1657 000a 4968     		ldr	r1, [r1, #4]
 1658              	.LVL170:
 1659 000c 5B1A     		subs	r3, r3, r1
 1660 000e 1360     		str	r3, [r2]
 469:../drivers/fsl_flexio_uart.c **** }
 1661              		.loc 1 469 0
 1662 0010 0020     		movs	r0, #0
 1663              	.LVL171:
 1664              	.L69:
 470:../drivers/fsl_flexio_uart.c **** 
 1665              		.loc 1 470 0
 1666              		@ sp needed
 1667 0012 7047     		bx	lr
 1668              	.LVL172:
 1669              	.L71:
 464:../drivers/fsl_flexio_uart.c ****     }
 1670              		.loc 1 464 0
 1671 0014 0620     		movs	r0, #6
 1672              	.LVL173:
 1673 0016 FCE7     		b	.L69
 1674              		.cfi_endproc
 1675              	.LFE91:
 1677              		.section	.text.FLEXIO_UART_TransferReceiveNonBlocking,"ax",%progbits
 1678              		.align	1
 1679              		.global	FLEXIO_UART_TransferReceiveNonBlocking
 1680              		.syntax unified
 1681              		.code	16
 1682              		.thumb_func
 1683              		.fpu softvfp
 1685              	FLEXIO_UART_TransferReceiveNonBlocking:
 1686              	.LFB92:
 476:../drivers/fsl_flexio_uart.c ****     uint32_t i;
 1687              		.loc 1 476 0
 1688              		.cfi_startproc
 1689              		@ args = 0, pretend = 0, frame = 8
 1690              		@ frame_needed = 0, uses_anonymous_args = 0
 1691              	.LVL174:
 1692 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1693              		.cfi_def_cfa_offset 20
 1694              		.cfi_offset 4, -20
 1695              		.cfi_offset 5, -16
 1696              		.cfi_offset 6, -12
 1697              		.cfi_offset 7, -8
 1698              		.cfi_offset 14, -4
 1699 0002 C646     		mov	lr, r8
 1700 0004 00B5     		push	{lr}
 1701              		.cfi_def_cfa_offset 24
 1702              		.cfi_offset 8, -24
 1703 0006 82B0     		sub	sp, sp, #8
 1704              		.cfi_def_cfa_offset 32
 1705 0008 0190     		str	r0, [sp, #4]
 1706 000a 0C00     		movs	r4, r1
 1707 000c 1600     		movs	r6, r2
 1708 000e 9846     		mov	r8, r3
 1709              	.LVL175:
 487:../drivers/fsl_flexio_uart.c ****     {
 1710              		.loc 1 487 0
 1711 0010 5768     		ldr	r7, [r2, #4]
 1712 0012 002F     		cmp	r7, #0
 1713 0014 52D0     		beq	.L83
 487:../drivers/fsl_flexio_uart.c ****     {
 1714              		.loc 1 487 0 is_stmt 0 discriminator 1
 1715 0016 1368     		ldr	r3, [r2]
 1716              	.LVL176:
 1717 0018 002B     		cmp	r3, #0
 1718 001a 51D0     		beq	.L84
 502:../drivers/fsl_flexio_uart.c ****     {
 1719              		.loc 1 502 0 is_stmt 1
 1720 001c 2D22     		movs	r2, #45
 1721              	.LVL177:
 1722 001e 8A5C     		ldrb	r2, [r1, r2]
 1723 0020 032A     		cmp	r2, #3
 1724 0022 4FD0     		beq	.L85
 1725              	.LVL178:
 512:../drivers/fsl_flexio_uart.c ****         {
 1726              		.loc 1 512 0
 1727 0024 8A69     		ldr	r2, [r1, #24]
 1728 0026 002A     		cmp	r2, #0
 1729 0028 3CD0     		beq	.L74
 515:../drivers/fsl_flexio_uart.c **** 
 1730              		.loc 1 515 0
 1731 002a 0221     		movs	r1, #2
 1732              	.LVL179:
 1733 002c FFF7FEFF 		bl	FLEXIO_UART_DisableInterrupts
 1734              	.LVL180:
 518:../drivers/fsl_flexio_uart.c **** 
 1735              		.loc 1 518 0
 1736 0030 2000     		movs	r0, r4
 1737 0032 FFF7FEFF 		bl	FLEXIO_UART_TransferGetRxRingBufferLength
 1738              	.LVL181:
 520:../drivers/fsl_flexio_uart.c ****             {
 1739              		.loc 1 520 0
 1740 0036 0028     		cmp	r0, #0
 1741 0038 1CD0     		beq	.L86
 522:../drivers/fsl_flexio_uart.c **** 
 1742              		.loc 1 522 0
 1743 003a 3A00     		movs	r2, r7
 1744 003c 8742     		cmp	r7, r0
 1745 003e 00D9     		bls	.L76
 1746 0040 0200     		movs	r2, r0
 1747              	.L76:
 1748              	.LVL182:
 524:../drivers/fsl_flexio_uart.c **** 
 1749              		.loc 1 524 0
 1750 0042 BF1A     		subs	r7, r7, r2
 1751              	.LVL183:
 527:../drivers/fsl_flexio_uart.c ****                 {
 1752              		.loc 1 527 0
 1753 0044 0025     		movs	r5, #0
 1754 0046 02E0     		b	.L77
 1755              	.LVL184:
 1756              	.L88:
 534:../drivers/fsl_flexio_uart.c ****                     }
 1757              		.loc 1 534 0
 1758 0048 0023     		movs	r3, #0
 1759 004a 6384     		strh	r3, [r4, #34]
 1760              	.L79:
 476:../drivers/fsl_flexio_uart.c ****     uint32_t i;
 1761              		.loc 1 476 0 discriminator 1
 1762 004c 0D00     		movs	r5, r1
 1763              	.LVL185:
 1764              	.L77:
 527:../drivers/fsl_flexio_uart.c ****                 {
 1765              		.loc 1 527 0 discriminator 1
 1766 004e 9542     		cmp	r5, r2
 1767 0050 11D2     		bcs	.L75
 529:../drivers/fsl_flexio_uart.c **** 
 1768              		.loc 1 529 0
 1769 0052 638C     		ldrh	r3, [r4, #34]
 1770 0054 9BB2     		uxth	r3, r3
 1771 0056 691C     		adds	r1, r5, #1
 1772              	.LVL186:
 1773 0058 A069     		ldr	r0, [r4, #24]
 1774 005a C35C     		ldrb	r3, [r0, r3]
 1775 005c 3068     		ldr	r0, [r6]
 1776 005e 4355     		strb	r3, [r0, r5]
 532:../drivers/fsl_flexio_uart.c ****                     {
 1777              		.loc 1 532 0
 1778 0060 638C     		ldrh	r3, [r4, #34]
 1779 0062 0133     		adds	r3, r3, #1
 1780 0064 E069     		ldr	r0, [r4, #28]
 1781 0066 8342     		cmp	r3, r0
 1782 0068 EED0     		beq	.L88
 538:../drivers/fsl_flexio_uart.c ****                     }
 1783              		.loc 1 538 0
 1784 006a 638C     		ldrh	r3, [r4, #34]
 1785 006c 0133     		adds	r3, r3, #1
 1786 006e 9BB2     		uxth	r3, r3
 1787 0070 6384     		strh	r3, [r4, #34]
 1788 0072 EBE7     		b	.L79
 1789              	.LVL187:
 1790              	.L86:
 509:../drivers/fsl_flexio_uart.c **** 
 1791              		.loc 1 509 0
 1792 0074 0025     		movs	r5, #0
 1793              	.LVL188:
 1794              	.L75:
 544:../drivers/fsl_flexio_uart.c ****             {
 1795              		.loc 1 544 0
 1796 0076 002F     		cmp	r7, #0
 1797 0078 07D0     		beq	.L81
 547:../drivers/fsl_flexio_uart.c ****                 handle->rxDataSize = bytesToReceive;
 1798              		.loc 1 547 0
 1799 007a 3368     		ldr	r3, [r6]
 1800 007c 5B19     		adds	r3, r3, r5
 1801 007e A360     		str	r3, [r4, #8]
 548:../drivers/fsl_flexio_uart.c ****                 handle->rxDataSizeAll = bytesToReceive;
 1802              		.loc 1 548 0
 1803 0080 E760     		str	r7, [r4, #12]
 549:../drivers/fsl_flexio_uart.c ****                 handle->rxState = kFLEXIO_UART_RxBusy;
 1804              		.loc 1 549 0
 1805 0082 6761     		str	r7, [r4, #20]
 550:../drivers/fsl_flexio_uart.c ****             }
 1806              		.loc 1 550 0
 1807 0084 2D23     		movs	r3, #45
 1808 0086 0322     		movs	r2, #3
 1809 0088 E254     		strb	r2, [r4, r3]
 1810              	.L81:
 554:../drivers/fsl_flexio_uart.c ****         }
 1811              		.loc 1 554 0
 1812 008a 0221     		movs	r1, #2
 1813 008c 0198     		ldr	r0, [sp, #4]
 1814 008e FFF7FEFF 		bl	FLEXIO_UART_EnableInterrupts
 1815              	.LVL189:
 1816              	.L82:
 569:../drivers/fsl_flexio_uart.c ****         {
 1817              		.loc 1 569 0
 1818 0092 4346     		mov	r3, r8
 1819 0094 002B     		cmp	r3, #0
 1820 0096 17D0     		beq	.L87
 1821              	.LVL190:
 571:../drivers/fsl_flexio_uart.c ****         }
 1822              		.loc 1 571 0
 1823 0098 1D60     		str	r5, [r3]
 574:../drivers/fsl_flexio_uart.c ****     }
 1824              		.loc 1 574 0
 1825 009a 0020     		movs	r0, #0
 1826              	.LVL191:
 1827              	.L72:
 578:../drivers/fsl_flexio_uart.c **** 
 1828              		.loc 1 578 0
 1829 009c 02B0     		add	sp, sp, #8
 1830              		@ sp needed
 1831              	.LVL192:
 1832              	.LVL193:
 1833              	.LVL194:
 1834 009e 04BC     		pop	{r2}
 1835 00a0 9046     		mov	r8, r2
 1836 00a2 F0BD     		pop	{r4, r5, r6, r7, pc}
 1837              	.LVL195:
 1838              	.L74:
 559:../drivers/fsl_flexio_uart.c ****             handle->rxDataSize = bytesToReceive;
 1839              		.loc 1 559 0
 1840 00a4 8B60     		str	r3, [r1, #8]
 560:../drivers/fsl_flexio_uart.c ****             handle->rxDataSizeAll = bytesToReceive;
 1841              		.loc 1 560 0
 1842 00a6 CF60     		str	r7, [r1, #12]
 561:../drivers/fsl_flexio_uart.c ****             handle->rxState = kFLEXIO_UART_RxBusy;
 1843              		.loc 1 561 0
 1844 00a8 4F61     		str	r7, [r1, #20]
 562:../drivers/fsl_flexio_uart.c **** 
 1845              		.loc 1 562 0
 1846 00aa 2D23     		movs	r3, #45
 1847 00ac 0322     		movs	r2, #3
 1848 00ae CA54     		strb	r2, [r1, r3]
 565:../drivers/fsl_flexio_uart.c ****         }
 1849              		.loc 1 565 0
 1850 00b0 0221     		movs	r1, #2
 1851              	.LVL196:
 1852 00b2 0198     		ldr	r0, [sp, #4]
 1853              	.LVL197:
 1854 00b4 FFF7FEFF 		bl	FLEXIO_UART_EnableInterrupts
 1855              	.LVL198:
 509:../drivers/fsl_flexio_uart.c **** 
 1856              		.loc 1 509 0
 1857 00b8 0025     		movs	r5, #0
 1858 00ba EAE7     		b	.L82
 1859              	.LVL199:
 1860              	.L83:
 489:../drivers/fsl_flexio_uart.c ****     }
 1861              		.loc 1 489 0
 1862 00bc 0420     		movs	r0, #4
 1863              	.LVL200:
 1864 00be EDE7     		b	.L72
 1865              	.LVL201:
 1866              	.L84:
 1867 00c0 0420     		movs	r0, #4
 1868              	.LVL202:
 1869 00c2 EBE7     		b	.L72
 1870              	.LVL203:
 1871              	.L85:
 504:../drivers/fsl_flexio_uart.c ****     }
 1872              		.loc 1 504 0
 1873 00c4 0148     		ldr	r0, .L89
 1874              	.LVL204:
 1875 00c6 E9E7     		b	.L72
 1876              	.LVL205:
 1877              	.L87:
 574:../drivers/fsl_flexio_uart.c ****     }
 1878              		.loc 1 574 0
 1879 00c8 0020     		movs	r0, #0
 1880 00ca E7E7     		b	.L72
 1881              	.L90:
 1882              		.align	2
 1883              	.L89:
 1884 00cc BD020000 		.word	701
 1885              		.cfi_endproc
 1886              	.LFE92:
 1888              		.section	.text.FLEXIO_UART_TransferAbortReceive,"ax",%progbits
 1889              		.align	1
 1890              		.global	FLEXIO_UART_TransferAbortReceive
 1891              		.syntax unified
 1892              		.code	16
 1893              		.thumb_func
 1894              		.fpu softvfp
 1896              	FLEXIO_UART_TransferAbortReceive:
 1897              	.LFB93:
 581:../drivers/fsl_flexio_uart.c ****     /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
 1898              		.loc 1 581 0
 1899              		.cfi_startproc
 1900              		@ args = 0, pretend = 0, frame = 0
 1901              		@ frame_needed = 0, uses_anonymous_args = 0
 1902              	.LVL206:
 1903 0000 10B5     		push	{r4, lr}
 1904              		.cfi_def_cfa_offset 8
 1905              		.cfi_offset 4, -8
 1906              		.cfi_offset 14, -4
 1907 0002 0C00     		movs	r4, r1
 583:../drivers/fsl_flexio_uart.c ****     {
 1908              		.loc 1 583 0
 1909 0004 8B69     		ldr	r3, [r1, #24]
 1910 0006 002B     		cmp	r3, #0
 1911 0008 05D0     		beq	.L93
 1912              	.LVL207:
 1913              	.L92:
 589:../drivers/fsl_flexio_uart.c ****     handle->rxState = kFLEXIO_UART_RxIdle;
 1914              		.loc 1 589 0
 1915 000a 0023     		movs	r3, #0
 1916 000c E360     		str	r3, [r4, #12]
 590:../drivers/fsl_flexio_uart.c **** }
 1917              		.loc 1 590 0
 1918 000e 2D33     		adds	r3, r3, #45
 1919 0010 0222     		movs	r2, #2
 1920 0012 E254     		strb	r2, [r4, r3]
 591:../drivers/fsl_flexio_uart.c **** 
 1921              		.loc 1 591 0
 1922              		@ sp needed
 1923              	.LVL208:
 1924 0014 10BD     		pop	{r4, pc}
 1925              	.LVL209:
 1926              	.L93:
 586:../drivers/fsl_flexio_uart.c ****     }
 1927              		.loc 1 586 0
 1928 0016 0221     		movs	r1, #2
 1929              	.LVL210:
 1930 0018 FFF7FEFF 		bl	FLEXIO_UART_DisableInterrupts
 1931              	.LVL211:
 1932 001c F5E7     		b	.L92
 1933              		.cfi_endproc
 1934              	.LFE93:
 1936              		.section	.text.FLEXIO_UART_TransferGetReceiveCount,"ax",%progbits
 1937              		.align	1
 1938              		.global	FLEXIO_UART_TransferGetReceiveCount
 1939              		.syntax unified
 1940              		.code	16
 1941              		.thumb_func
 1942              		.fpu softvfp
 1944              	FLEXIO_UART_TransferGetReceiveCount:
 1945              	.LFB94:
 594:../drivers/fsl_flexio_uart.c ****     assert(handle);
 1946              		.loc 1 594 0
 1947              		.cfi_startproc
 1948              		@ args = 0, pretend = 0, frame = 0
 1949              		@ frame_needed = 0, uses_anonymous_args = 0
 1950              		@ link register save eliminated.
 1951              	.LVL212:
 598:../drivers/fsl_flexio_uart.c ****     {
 1952              		.loc 1 598 0
 1953 0000 2D23     		movs	r3, #45
 1954 0002 CB5C     		ldrb	r3, [r1, r3]
 1955 0004 022B     		cmp	r3, #2
 1956 0006 05D0     		beq	.L96
 603:../drivers/fsl_flexio_uart.c **** 
 1957              		.loc 1 603 0
 1958 0008 4B69     		ldr	r3, [r1, #20]
 1959 000a C968     		ldr	r1, [r1, #12]
 1960              	.LVL213:
 1961 000c 5B1A     		subs	r3, r3, r1
 1962 000e 1360     		str	r3, [r2]
 605:../drivers/fsl_flexio_uart.c **** }
 1963              		.loc 1 605 0
 1964 0010 0020     		movs	r0, #0
 1965              	.LVL214:
 1966              	.L94:
 606:../drivers/fsl_flexio_uart.c **** 
 1967              		.loc 1 606 0
 1968              		@ sp needed
 1969 0012 7047     		bx	lr
 1970              	.LVL215:
 1971              	.L96:
 600:../drivers/fsl_flexio_uart.c ****     }
 1972              		.loc 1 600 0
 1973 0014 0620     		movs	r0, #6
 1974              	.LVL216:
 1975 0016 FCE7     		b	.L94
 1976              		.cfi_endproc
 1977              	.LFE94:
 1979              		.text
 1980              	.Letext0:
 1981              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1982              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1983              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1984              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1985              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1986              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1987              		.file 12 "../CMSIS/MKL17Z4.h"
 1988              		.file 13 "../CMSIS/system_MKL17Z4.h"
 1989              		.file 14 "../drivers/fsl_common.h"
 1990              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_flexio_uart.c
     /tmp/ccug5SQr.s:16     .text.FLEXIO_UART_TransferGetRxRingBufferLength:0000000000000000 $t
     /tmp/ccug5SQr.s:22     .text.FLEXIO_UART_TransferGetRxRingBufferLength:0000000000000000 FLEXIO_UART_TransferGetRxRingBufferLength
     /tmp/ccug5SQr.s:64     .text.FLEXIO_UART_TransferIsRxRingBufferFull:0000000000000000 $t
     /tmp/ccug5SQr.s:70     .text.FLEXIO_UART_TransferIsRxRingBufferFull:0000000000000000 FLEXIO_UART_TransferIsRxRingBufferFull
     /tmp/ccug5SQr.s:106    .text.FLEXIO_UART_GetInstance:0000000000000000 $t
     /tmp/ccug5SQr.s:113    .text.FLEXIO_UART_GetInstance:0000000000000000 FLEXIO_UART_GetInstance
     /tmp/ccug5SQr.s:137    .text.FLEXIO_UART_Init:0000000000000000 $t
     /tmp/ccug5SQr.s:144    .text.FLEXIO_UART_Init:0000000000000000 FLEXIO_UART_Init
     /tmp/ccug5SQr.s:454    .text.FLEXIO_UART_Init:000000000000016c $d
     /tmp/ccug5SQr.s:461    .text.FLEXIO_UART_Deinit:0000000000000000 $t
     /tmp/ccug5SQr.s:468    .text.FLEXIO_UART_Deinit:0000000000000000 FLEXIO_UART_Deinit
     /tmp/ccug5SQr.s:577    .text.FLEXIO_UART_GetDefaultConfig:0000000000000000 $t
     /tmp/ccug5SQr.s:584    .text.FLEXIO_UART_GetDefaultConfig:0000000000000000 FLEXIO_UART_GetDefaultConfig
     /tmp/ccug5SQr.s:616    .text.FLEXIO_UART_EnableInterrupts:0000000000000000 $t
     /tmp/ccug5SQr.s:623    .text.FLEXIO_UART_EnableInterrupts:0000000000000000 FLEXIO_UART_EnableInterrupts
     /tmp/ccug5SQr.s:683    .text.FLEXIO_UART_DisableInterrupts:0000000000000000 $t
     /tmp/ccug5SQr.s:690    .text.FLEXIO_UART_DisableInterrupts:0000000000000000 FLEXIO_UART_DisableInterrupts
     /tmp/ccug5SQr.s:747    .text.FLEXIO_UART_GetStatusFlags:0000000000000000 $t
     /tmp/ccug5SQr.s:754    .text.FLEXIO_UART_GetStatusFlags:0000000000000000 FLEXIO_UART_GetStatusFlags
     /tmp/ccug5SQr.s:833    .text.FLEXIO_UART_ClearStatusFlags:0000000000000000 $t
     /tmp/ccug5SQr.s:840    .text.FLEXIO_UART_ClearStatusFlags:0000000000000000 FLEXIO_UART_ClearStatusFlags
     /tmp/ccug5SQr.s:910    .text.FLEXIO_UART_TransferHandleIRQ:0000000000000000 $t
     /tmp/ccug5SQr.s:917    .text.FLEXIO_UART_TransferHandleIRQ:0000000000000000 FLEXIO_UART_TransferHandleIRQ
     /tmp/ccug5SQr.s:1202   .text.FLEXIO_UART_TransferHandleIRQ:0000000000000158 $d
     /tmp/ccug5SQr.s:1210   .text.FLEXIO_UART_WriteBlocking:0000000000000000 $t
     /tmp/ccug5SQr.s:1217   .text.FLEXIO_UART_WriteBlocking:0000000000000000 FLEXIO_UART_WriteBlocking
     /tmp/ccug5SQr.s:1277   .text.FLEXIO_UART_ReadBlocking:0000000000000000 $t
     /tmp/ccug5SQr.s:1284   .text.FLEXIO_UART_ReadBlocking:0000000000000000 FLEXIO_UART_ReadBlocking
     /tmp/ccug5SQr.s:1338   .text.FLEXIO_UART_TransferCreateHandle:0000000000000000 $t
     /tmp/ccug5SQr.s:1345   .text.FLEXIO_UART_TransferCreateHandle:0000000000000000 FLEXIO_UART_TransferCreateHandle
     /tmp/ccug5SQr.s:1418   .text.FLEXIO_UART_TransferCreateHandle:0000000000000040 $d
     /tmp/ccug5SQr.s:1424   .text.FLEXIO_UART_TransferStartRingBuffer:0000000000000000 $t
     /tmp/ccug5SQr.s:1431   .text.FLEXIO_UART_TransferStartRingBuffer:0000000000000000 FLEXIO_UART_TransferStartRingBuffer
     /tmp/ccug5SQr.s:1468   .text.FLEXIO_UART_TransferStopRingBuffer:0000000000000000 $t
     /tmp/ccug5SQr.s:1475   .text.FLEXIO_UART_TransferStopRingBuffer:0000000000000000 FLEXIO_UART_TransferStopRingBuffer
     /tmp/ccug5SQr.s:1519   .text.FLEXIO_UART_TransferSendNonBlocking:0000000000000000 $t
     /tmp/ccug5SQr.s:1526   .text.FLEXIO_UART_TransferSendNonBlocking:0000000000000000 FLEXIO_UART_TransferSendNonBlocking
     /tmp/ccug5SQr.s:1597   .text.FLEXIO_UART_TransferAbortSend:0000000000000000 $t
     /tmp/ccug5SQr.s:1604   .text.FLEXIO_UART_TransferAbortSend:0000000000000000 FLEXIO_UART_TransferAbortSend
     /tmp/ccug5SQr.s:1635   .text.FLEXIO_UART_TransferGetSendCount:0000000000000000 $t
     /tmp/ccug5SQr.s:1642   .text.FLEXIO_UART_TransferGetSendCount:0000000000000000 FLEXIO_UART_TransferGetSendCount
     /tmp/ccug5SQr.s:1678   .text.FLEXIO_UART_TransferReceiveNonBlocking:0000000000000000 $t
     /tmp/ccug5SQr.s:1685   .text.FLEXIO_UART_TransferReceiveNonBlocking:0000000000000000 FLEXIO_UART_TransferReceiveNonBlocking
     /tmp/ccug5SQr.s:1884   .text.FLEXIO_UART_TransferReceiveNonBlocking:00000000000000cc $d
     /tmp/ccug5SQr.s:1889   .text.FLEXIO_UART_TransferAbortReceive:0000000000000000 $t
     /tmp/ccug5SQr.s:1896   .text.FLEXIO_UART_TransferAbortReceive:0000000000000000 FLEXIO_UART_TransferAbortReceive
     /tmp/ccug5SQr.s:1937   .text.FLEXIO_UART_TransferGetReceiveCount:0000000000000000 $t
     /tmp/ccug5SQr.s:1944   .text.FLEXIO_UART_TransferGetReceiveCount:0000000000000000 FLEXIO_UART_TransferGetReceiveCount

UNDEFINED SYMBOLS
FLEXIO_GetInstance
__aeabi_uidiv
memset
FLEXIO_SetShifterConfig
FLEXIO_SetTimerConfig
s_flexioClocks
FLEXIO_RegisterHandleIRQ
