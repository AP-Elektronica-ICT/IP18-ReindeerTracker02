   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_lpuart_dma.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.LPUART_TransferSendDMACallback,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	LPUART_TransferSendDMACallback:
  23              	.LFB76:
  24              		.file 1 "../drivers/fsl_lpuart_dma.c"
   1:../drivers/fsl_lpuart_dma.c **** /*
   2:../drivers/fsl_lpuart_dma.c ****  * The Clear BSD License
   3:../drivers/fsl_lpuart_dma.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_lpuart_dma.c ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_lpuart_dma.c ****  * All rights reserved.
   6:../drivers/fsl_lpuart_dma.c ****  *
   7:../drivers/fsl_lpuart_dma.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_lpuart_dma.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_lpuart_dma.c ****  * that the following conditions are met:
  10:../drivers/fsl_lpuart_dma.c ****  *
  11:../drivers/fsl_lpuart_dma.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_lpuart_dma.c ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_lpuart_dma.c ****  *
  14:../drivers/fsl_lpuart_dma.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_lpuart_dma.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_lpuart_dma.c ****  *   other materials provided with the distribution.
  17:../drivers/fsl_lpuart_dma.c ****  *
  18:../drivers/fsl_lpuart_dma.c ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_lpuart_dma.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_lpuart_dma.c ****  *   software without specific prior written permission.
  21:../drivers/fsl_lpuart_dma.c ****  *
  22:../drivers/fsl_lpuart_dma.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_lpuart_dma.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_lpuart_dma.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_lpuart_dma.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_lpuart_dma.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_lpuart_dma.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_lpuart_dma.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_lpuart_dma.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_lpuart_dma.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_lpuart_dma.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_lpuart_dma.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_lpuart_dma.c ****  */
  34:../drivers/fsl_lpuart_dma.c **** #include "fsl_lpuart_dma.h"
  35:../drivers/fsl_lpuart_dma.c **** 
  36:../drivers/fsl_lpuart_dma.c **** /*******************************************************************************
  37:../drivers/fsl_lpuart_dma.c ****  * Definitions
  38:../drivers/fsl_lpuart_dma.c ****  ******************************************************************************/
  39:../drivers/fsl_lpuart_dma.c **** 
  40:../drivers/fsl_lpuart_dma.c **** /*<! Structure definition for lpuart_dma_handle_t. The structure is private. */
  41:../drivers/fsl_lpuart_dma.c **** typedef struct _lpuart_dma_private_handle
  42:../drivers/fsl_lpuart_dma.c **** {
  43:../drivers/fsl_lpuart_dma.c ****     LPUART_Type *base;
  44:../drivers/fsl_lpuart_dma.c ****     lpuart_dma_handle_t *handle;
  45:../drivers/fsl_lpuart_dma.c **** } lpuart_dma_private_handle_t;
  46:../drivers/fsl_lpuart_dma.c **** 
  47:../drivers/fsl_lpuart_dma.c **** /* LPUART DMA transfer handle. */
  48:../drivers/fsl_lpuart_dma.c **** enum _uart_dma_tansfer_states
  49:../drivers/fsl_lpuart_dma.c **** {
  50:../drivers/fsl_lpuart_dma.c ****     kLPUART_TxIdle, /* TX idle. */
  51:../drivers/fsl_lpuart_dma.c ****     kLPUART_TxBusy, /* TX busy. */
  52:../drivers/fsl_lpuart_dma.c ****     kLPUART_RxIdle, /* RX idle. */
  53:../drivers/fsl_lpuart_dma.c ****     kLPUART_RxBusy  /* RX busy. */
  54:../drivers/fsl_lpuart_dma.c **** };
  55:../drivers/fsl_lpuart_dma.c **** 
  56:../drivers/fsl_lpuart_dma.c **** /*******************************************************************************
  57:../drivers/fsl_lpuart_dma.c ****  * Variables
  58:../drivers/fsl_lpuart_dma.c ****  ******************************************************************************/
  59:../drivers/fsl_lpuart_dma.c **** 
  60:../drivers/fsl_lpuart_dma.c **** /* Array of LPUART handle. */
  61:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART8))
  62:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 9
  63:../drivers/fsl_lpuart_dma.c **** #else /* LPUART8 */
  64:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART7))
  65:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 8
  66:../drivers/fsl_lpuart_dma.c **** #else /* LPUART7 */
  67:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART6))
  68:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 7
  69:../drivers/fsl_lpuart_dma.c **** #else /* LPUART6 */
  70:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART5))
  71:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 6
  72:../drivers/fsl_lpuart_dma.c **** #else /* LPUART5 */
  73:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART4))
  74:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 5
  75:../drivers/fsl_lpuart_dma.c **** #else /* LPUART4 */
  76:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART3))
  77:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 4
  78:../drivers/fsl_lpuart_dma.c **** #else /* LPUART3 */
  79:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART2))
  80:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 3
  81:../drivers/fsl_lpuart_dma.c **** #else /* LPUART2 */
  82:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART1))
  83:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 2
  84:../drivers/fsl_lpuart_dma.c **** #else /* LPUART1 */
  85:../drivers/fsl_lpuart_dma.c **** #if (defined(LPUART0))
  86:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE 1
  87:../drivers/fsl_lpuart_dma.c **** #else /* LPUART0 */
  88:../drivers/fsl_lpuart_dma.c **** #define LPUART_HANDLE_ARRAY_SIZE FSL_FEATURE_SOC_LPUART_COUNT
  89:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 0 */
  90:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 1 */
  91:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 2 */
  92:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 3 */
  93:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 4 */
  94:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 5 */
  95:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 6 */
  96:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 7 */
  97:../drivers/fsl_lpuart_dma.c **** #endif /* LPUART 8 */
  98:../drivers/fsl_lpuart_dma.c **** 
  99:../drivers/fsl_lpuart_dma.c **** /*<! Private handle only used for internally. */
 100:../drivers/fsl_lpuart_dma.c **** static lpuart_dma_private_handle_t s_dmaPrivateHandle[LPUART_HANDLE_ARRAY_SIZE];
 101:../drivers/fsl_lpuart_dma.c **** 
 102:../drivers/fsl_lpuart_dma.c **** /*******************************************************************************
 103:../drivers/fsl_lpuart_dma.c ****  * Prototypes
 104:../drivers/fsl_lpuart_dma.c ****  ******************************************************************************/
 105:../drivers/fsl_lpuart_dma.c **** 
 106:../drivers/fsl_lpuart_dma.c **** /*!
 107:../drivers/fsl_lpuart_dma.c ****  * @brief LPUART DMA send finished callback function.
 108:../drivers/fsl_lpuart_dma.c ****  *
 109:../drivers/fsl_lpuart_dma.c ****  * This function is called when LPUART DMA send finished. It disables the LPUART
 110:../drivers/fsl_lpuart_dma.c ****  * TX DMA request and sends @ref kStatus_LPUART_TxIdle to LPUART callback.
 111:../drivers/fsl_lpuart_dma.c ****  *
 112:../drivers/fsl_lpuart_dma.c ****  * @param handle The DMA handle.
 113:../drivers/fsl_lpuart_dma.c ****  * @param param Callback function parameter.
 114:../drivers/fsl_lpuart_dma.c ****  */
 115:../drivers/fsl_lpuart_dma.c **** static void LPUART_TransferSendDMACallback(dma_handle_t *handle, void *param);
 116:../drivers/fsl_lpuart_dma.c **** 
 117:../drivers/fsl_lpuart_dma.c **** /*!
 118:../drivers/fsl_lpuart_dma.c ****  * @brief LPUART DMA receive finished callback function.
 119:../drivers/fsl_lpuart_dma.c ****  *
 120:../drivers/fsl_lpuart_dma.c ****  * This function is called when LPUART DMA receive finished. It disables the LPUART
 121:../drivers/fsl_lpuart_dma.c ****  * RX DMA request and sends @ref kStatus_LPUART_RxIdle to LPUART callback.
 122:../drivers/fsl_lpuart_dma.c ****  *
 123:../drivers/fsl_lpuart_dma.c ****  * @param handle The DMA handle.
 124:../drivers/fsl_lpuart_dma.c ****  * @param param Callback function parameter.
 125:../drivers/fsl_lpuart_dma.c ****  */
 126:../drivers/fsl_lpuart_dma.c **** static void LPUART_TransferReceiveDMACallback(dma_handle_t *handle, void *param);
 127:../drivers/fsl_lpuart_dma.c **** 
 128:../drivers/fsl_lpuart_dma.c **** /*!
 129:../drivers/fsl_lpuart_dma.c ****  * @brief Get the LPUART instance from peripheral base address.
 130:../drivers/fsl_lpuart_dma.c ****  *
 131:../drivers/fsl_lpuart_dma.c ****  * @param base LPUART peripheral base address.
 132:../drivers/fsl_lpuart_dma.c ****  * @return LPUART instance.
 133:../drivers/fsl_lpuart_dma.c ****  */
 134:../drivers/fsl_lpuart_dma.c **** extern uint32_t LPUART_GetInstance(LPUART_Type *base);
 135:../drivers/fsl_lpuart_dma.c **** 
 136:../drivers/fsl_lpuart_dma.c **** /*******************************************************************************
 137:../drivers/fsl_lpuart_dma.c ****  * Code
 138:../drivers/fsl_lpuart_dma.c ****  ******************************************************************************/
 139:../drivers/fsl_lpuart_dma.c **** 
 140:../drivers/fsl_lpuart_dma.c **** static void LPUART_TransferSendDMACallback(dma_handle_t *handle, void *param)
 141:../drivers/fsl_lpuart_dma.c **** {
  25              		.loc 1 141 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 70B5     		push	{r4, r5, r6, lr}
  31              		.cfi_def_cfa_offset 16
  32              		.cfi_offset 4, -16
  33              		.cfi_offset 5, -12
  34              		.cfi_offset 6, -8
  35              		.cfi_offset 14, -4
  36              	.LVL1:
 142:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 143:../drivers/fsl_lpuart_dma.c ****     assert(param);
 144:../drivers/fsl_lpuart_dma.c **** 
 145:../drivers/fsl_lpuart_dma.c ****     lpuart_dma_private_handle_t *lpuartPrivateHandle = (lpuart_dma_private_handle_t *)param;
 146:../drivers/fsl_lpuart_dma.c **** 
 147:../drivers/fsl_lpuart_dma.c ****     /* Disable LPUART TX DMA. */
 148:../drivers/fsl_lpuart_dma.c ****     LPUART_EnableTxDMA(lpuartPrivateHandle->base, false);
  37              		.loc 1 148 0
  38 0002 0B68     		ldr	r3, [r1]
  39              	.LVL2:
  40              	.LBB34:
  41              	.LBB35:
  42              		.file 2 "../drivers/fsl_lpuart.h"
   1:../drivers/fsl_lpuart.h **** /*
   2:../drivers/fsl_lpuart.h ****  * The Clear BSD License
   3:../drivers/fsl_lpuart.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_lpuart.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_lpuart.h ****  * All rights reserved.
   6:../drivers/fsl_lpuart.h ****  *
   7:../drivers/fsl_lpuart.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_lpuart.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_lpuart.h ****  * that the following conditions are met:
  10:../drivers/fsl_lpuart.h ****  *
  11:../drivers/fsl_lpuart.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_lpuart.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_lpuart.h ****  *
  14:../drivers/fsl_lpuart.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_lpuart.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_lpuart.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_lpuart.h ****  *
  18:../drivers/fsl_lpuart.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_lpuart.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_lpuart.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_lpuart.h ****  *
  22:../drivers/fsl_lpuart.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_lpuart.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_lpuart.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_lpuart.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_lpuart.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_lpuart.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_lpuart.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_lpuart.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_lpuart.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_lpuart.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_lpuart.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_lpuart.h ****  */
  34:../drivers/fsl_lpuart.h **** #ifndef _FSL_LPUART_H_
  35:../drivers/fsl_lpuart.h **** #define _FSL_LPUART_H_
  36:../drivers/fsl_lpuart.h **** 
  37:../drivers/fsl_lpuart.h **** #include "fsl_common.h"
  38:../drivers/fsl_lpuart.h **** 
  39:../drivers/fsl_lpuart.h **** /*!
  40:../drivers/fsl_lpuart.h ****  * @addtogroup lpuart_driver
  41:../drivers/fsl_lpuart.h ****  * @{
  42:../drivers/fsl_lpuart.h ****  */
  43:../drivers/fsl_lpuart.h **** 
  44:../drivers/fsl_lpuart.h **** /*******************************************************************************
  45:../drivers/fsl_lpuart.h ****  * Definitions
  46:../drivers/fsl_lpuart.h ****  ******************************************************************************/
  47:../drivers/fsl_lpuart.h **** 
  48:../drivers/fsl_lpuart.h **** /*! @name Driver version */
  49:../drivers/fsl_lpuart.h **** /*@{*/
  50:../drivers/fsl_lpuart.h **** /*! @brief LPUART driver version 2.2.4. */
  51:../drivers/fsl_lpuart.h **** #define FSL_LPUART_DRIVER_VERSION (MAKE_VERSION(2, 2, 4))
  52:../drivers/fsl_lpuart.h **** /*@}*/
  53:../drivers/fsl_lpuart.h **** 
  54:../drivers/fsl_lpuart.h **** /*! @brief Error codes for the LPUART driver. */
  55:../drivers/fsl_lpuart.h **** enum _lpuart_status
  56:../drivers/fsl_lpuart.h **** {
  57:../drivers/fsl_lpuart.h ****     kStatus_LPUART_TxBusy = MAKE_STATUS(kStatusGroup_LPUART, 0),                  /*!< TX busy */
  58:../drivers/fsl_lpuart.h ****     kStatus_LPUART_RxBusy = MAKE_STATUS(kStatusGroup_LPUART, 1),                  /*!< RX busy */
  59:../drivers/fsl_lpuart.h ****     kStatus_LPUART_TxIdle = MAKE_STATUS(kStatusGroup_LPUART, 2),                  /*!< LPUART trans
  60:../drivers/fsl_lpuart.h ****     kStatus_LPUART_RxIdle = MAKE_STATUS(kStatusGroup_LPUART, 3),                  /*!< LPUART recei
  61:../drivers/fsl_lpuart.h ****     kStatus_LPUART_TxWatermarkTooLarge = MAKE_STATUS(kStatusGroup_LPUART, 4),     /*!< TX FIFO wate
  62:../drivers/fsl_lpuart.h ****     kStatus_LPUART_RxWatermarkTooLarge = MAKE_STATUS(kStatusGroup_LPUART, 5),     /*!< RX FIFO wate
  63:../drivers/fsl_lpuart.h ****     kStatus_LPUART_FlagCannotClearManually = MAKE_STATUS(kStatusGroup_LPUART, 6), /*!< Some flag ca
  64:../drivers/fsl_lpuart.h ****     kStatus_LPUART_Error = MAKE_STATUS(kStatusGroup_LPUART, 7),                   /*!< Error happen
  65:../drivers/fsl_lpuart.h ****     kStatus_LPUART_RxRingBufferOverrun =
  66:../drivers/fsl_lpuart.h ****         MAKE_STATUS(kStatusGroup_LPUART, 8), /*!< LPUART RX software ring buffer overrun. */
  67:../drivers/fsl_lpuart.h ****     kStatus_LPUART_RxHardwareOverrun = MAKE_STATUS(kStatusGroup_LPUART, 9), /*!< LPUART RX receiver
  68:../drivers/fsl_lpuart.h ****     kStatus_LPUART_NoiseError = MAKE_STATUS(kStatusGroup_LPUART, 10),       /*!< LPUART noise error
  69:../drivers/fsl_lpuart.h ****     kStatus_LPUART_FramingError = MAKE_STATUS(kStatusGroup_LPUART, 11),     /*!< LPUART framing err
  70:../drivers/fsl_lpuart.h ****     kStatus_LPUART_ParityError = MAKE_STATUS(kStatusGroup_LPUART, 12),      /*!< LPUART parity erro
  71:../drivers/fsl_lpuart.h ****     kStatus_LPUART_BaudrateNotSupport =
  72:../drivers/fsl_lpuart.h ****         MAKE_STATUS(kStatusGroup_LPUART, 13), /*!< Baudrate is not support in current clock source 
  73:../drivers/fsl_lpuart.h ****     kStatus_LPUART_IdleLineDetected = MAKE_STATUS(kStatusGroup_LPUART, 14), /*!< IDLE flag. */
  74:../drivers/fsl_lpuart.h **** };
  75:../drivers/fsl_lpuart.h **** 
  76:../drivers/fsl_lpuart.h **** /*! @brief LPUART parity mode. */
  77:../drivers/fsl_lpuart.h **** typedef enum _lpuart_parity_mode
  78:../drivers/fsl_lpuart.h **** {
  79:../drivers/fsl_lpuart.h ****     kLPUART_ParityDisabled = 0x0U, /*!< Parity disabled */
  80:../drivers/fsl_lpuart.h ****     kLPUART_ParityEven = 0x2U,     /*!< Parity enabled, type even, bit setting: PE|PT = 10 */
  81:../drivers/fsl_lpuart.h ****     kLPUART_ParityOdd = 0x3U,      /*!< Parity enabled, type odd,  bit setting: PE|PT = 11 */
  82:../drivers/fsl_lpuart.h **** } lpuart_parity_mode_t;
  83:../drivers/fsl_lpuart.h **** 
  84:../drivers/fsl_lpuart.h **** /*! @brief LPUART data bits count. */
  85:../drivers/fsl_lpuart.h **** typedef enum _lpuart_data_bits
  86:../drivers/fsl_lpuart.h **** {
  87:../drivers/fsl_lpuart.h ****     kLPUART_EightDataBits = 0x0U, /*!< Eight data bit */
  88:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
  89:../drivers/fsl_lpuart.h ****     kLPUART_SevenDataBits = 0x1U, /*!< Seven data bit */
  90:../drivers/fsl_lpuart.h **** #endif
  91:../drivers/fsl_lpuart.h **** } lpuart_data_bits_t;
  92:../drivers/fsl_lpuart.h **** 
  93:../drivers/fsl_lpuart.h **** /*! @brief LPUART stop bit count. */
  94:../drivers/fsl_lpuart.h **** typedef enum _lpuart_stop_bit_count
  95:../drivers/fsl_lpuart.h **** {
  96:../drivers/fsl_lpuart.h ****     kLPUART_OneStopBit = 0U, /*!< One stop bit */
  97:../drivers/fsl_lpuart.h ****     kLPUART_TwoStopBit = 1U, /*!< Two stop bits */
  98:../drivers/fsl_lpuart.h **** } lpuart_stop_bit_count_t;
  99:../drivers/fsl_lpuart.h **** 
 100:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
 101:../drivers/fsl_lpuart.h **** /*! @brief LPUART transmit CTS source. */
 102:../drivers/fsl_lpuart.h **** typedef enum _lpuart_transmit_cts_source
 103:../drivers/fsl_lpuart.h **** {
 104:../drivers/fsl_lpuart.h ****     kLPUART_CtsSourcePin = 0U,         /*!< CTS resource is the LPUART_CTS pin. */
 105:../drivers/fsl_lpuart.h ****     kLPUART_CtsSourceMatchResult = 1U, /*!< CTS resource is the match result. */
 106:../drivers/fsl_lpuart.h **** } lpuart_transmit_cts_source_t;
 107:../drivers/fsl_lpuart.h **** 
 108:../drivers/fsl_lpuart.h **** /*! @brief LPUART transmit CTS configure. */
 109:../drivers/fsl_lpuart.h **** typedef enum _lpuart_transmit_cts_config
 110:../drivers/fsl_lpuart.h **** {
 111:../drivers/fsl_lpuart.h ****     kLPUART_CtsSampleAtStart = 0U, /*!< CTS input is sampled at the start of each character. */
 112:../drivers/fsl_lpuart.h ****     kLPUART_CtsSampleAtIdle = 1U,  /*!< CTS input is sampled when the transmitter is idle */
 113:../drivers/fsl_lpuart.h **** } lpuart_transmit_cts_config_t;
 114:../drivers/fsl_lpuart.h **** #endif
 115:../drivers/fsl_lpuart.h **** 
 116:../drivers/fsl_lpuart.h **** /*! @brief LPUART idle flag type defines when the receiver starts counting. */
 117:../drivers/fsl_lpuart.h **** typedef enum _lpuart_idle_type_select
 118:../drivers/fsl_lpuart.h **** {
 119:../drivers/fsl_lpuart.h ****     kLPUART_IdleTypeStartBit = 0U, /*!< Start counting after a valid start bit. */
 120:../drivers/fsl_lpuart.h ****     kLPUART_IdleTypeStopBit = 1U,  /*!< Start conuting after a stop bit. */
 121:../drivers/fsl_lpuart.h **** } lpuart_idle_type_select_t;
 122:../drivers/fsl_lpuart.h **** 
 123:../drivers/fsl_lpuart.h **** /*! @brief LPUART idle detected configuration.
 124:../drivers/fsl_lpuart.h ****  *  This structure defines the number of idle characters that must be received before
 125:../drivers/fsl_lpuart.h ****  *  the IDLE flag is set.
 126:../drivers/fsl_lpuart.h ****  */
 127:../drivers/fsl_lpuart.h **** typedef enum _lpuart_idle_config
 128:../drivers/fsl_lpuart.h **** {
 129:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter1 = 0U,   /*!< the number of idle characters. */
 130:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter2 = 1U,   /*!< the number of idle characters. */
 131:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter4 = 2U,   /*!< the number of idle characters. */
 132:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter8 = 3U,   /*!< the number of idle characters. */
 133:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter16 = 4U,  /*!< the number of idle characters. */
 134:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter32 = 5U,  /*!< the number of idle characters. */
 135:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter64 = 6U,  /*!< the number of idle characters. */
 136:../drivers/fsl_lpuart.h ****     kLPUART_IdleCharacter128 = 7U, /*!< the number of idle characters. */
 137:../drivers/fsl_lpuart.h **** } lpuart_idle_config_t;
 138:../drivers/fsl_lpuart.h **** 
 139:../drivers/fsl_lpuart.h **** /*!
 140:../drivers/fsl_lpuart.h ****  * @brief LPUART interrupt configuration structure, default settings all disabled.
 141:../drivers/fsl_lpuart.h ****  *
 142:../drivers/fsl_lpuart.h ****  * This structure contains the settings for all LPUART interrupt configurations.
 143:../drivers/fsl_lpuart.h ****  */
 144:../drivers/fsl_lpuart.h **** enum _lpuart_interrupt_enable
 145:../drivers/fsl_lpuart.h **** {
 146:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
 147:../drivers/fsl_lpuart.h ****     kLPUART_LinBreakInterruptEnable = (LPUART_BAUD_LBKDIE_MASK >> 8), /*!< LIN break detect. */
 148:../drivers/fsl_lpuart.h **** #endif
 149:../drivers/fsl_lpuart.h ****     kLPUART_RxActiveEdgeInterruptEnable = (LPUART_BAUD_RXEDGIE_MASK >> 8), /*!< Receive Active Edge
 150:../drivers/fsl_lpuart.h ****     kLPUART_TxDataRegEmptyInterruptEnable = (LPUART_CTRL_TIE_MASK),        /*!< Transmit data regis
 151:../drivers/fsl_lpuart.h ****     kLPUART_TransmissionCompleteInterruptEnable = (LPUART_CTRL_TCIE_MASK), /*!< Transmission comple
 152:../drivers/fsl_lpuart.h ****     kLPUART_RxDataRegFullInterruptEnable = (LPUART_CTRL_RIE_MASK),         /*!< Receiver data regis
 153:../drivers/fsl_lpuart.h ****     kLPUART_IdleLineInterruptEnable = (LPUART_CTRL_ILIE_MASK),             /*!< Idle line. */
 154:../drivers/fsl_lpuart.h ****     kLPUART_RxOverrunInterruptEnable = (LPUART_CTRL_ORIE_MASK),            /*!< Receiver Overrun. *
 155:../drivers/fsl_lpuart.h ****     kLPUART_NoiseErrorInterruptEnable = (LPUART_CTRL_NEIE_MASK),           /*!< Noise error flag. *
 156:../drivers/fsl_lpuart.h ****     kLPUART_FramingErrorInterruptEnable = (LPUART_CTRL_FEIE_MASK),         /*!< Framing error flag.
 157:../drivers/fsl_lpuart.h ****     kLPUART_ParityErrorInterruptEnable = (LPUART_CTRL_PEIE_MASK),          /*!< Parity error flag. 
 158:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 159:../drivers/fsl_lpuart.h ****     kLPUART_TxFifoOverflowInterruptEnable = (LPUART_FIFO_TXOFE_MASK >> 8),  /*!< Transmit FIFO Over
 160:../drivers/fsl_lpuart.h ****     kLPUART_RxFifoUnderflowInterruptEnable = (LPUART_FIFO_RXUFE_MASK >> 8), /*!< Receive FIFO Under
 161:../drivers/fsl_lpuart.h **** #endif
 162:../drivers/fsl_lpuart.h **** };
 163:../drivers/fsl_lpuart.h **** 
 164:../drivers/fsl_lpuart.h **** /*!
 165:../drivers/fsl_lpuart.h ****  * @brief LPUART status flags.
 166:../drivers/fsl_lpuart.h ****  *
 167:../drivers/fsl_lpuart.h ****  * This provides constants for the LPUART status flags for use in the LPUART functions.
 168:../drivers/fsl_lpuart.h ****  */
 169:../drivers/fsl_lpuart.h **** enum _lpuart_flags
 170:../drivers/fsl_lpuart.h **** {
 171:../drivers/fsl_lpuart.h ****     kLPUART_TxDataRegEmptyFlag =
 172:../drivers/fsl_lpuart.h ****         (LPUART_STAT_TDRE_MASK), /*!< Transmit data register empty flag, sets when transmit buffer 
 173:../drivers/fsl_lpuart.h ****     kLPUART_TransmissionCompleteFlag =
 174:../drivers/fsl_lpuart.h ****         (LPUART_STAT_TC_MASK), /*!< Transmission complete flag, sets when transmission activity com
 175:../drivers/fsl_lpuart.h ****     kLPUART_RxDataRegFullFlag =
 176:../drivers/fsl_lpuart.h ****         (LPUART_STAT_RDRF_MASK), /*!< Receive data register full flag, sets when the receive data b
 177:../drivers/fsl_lpuart.h ****     kLPUART_IdleLineFlag = (LPUART_STAT_IDLE_MASK), /*!< Idle line detect flag, sets when idle line
 178:../drivers/fsl_lpuart.h ****     kLPUART_RxOverrunFlag = (LPUART_STAT_OR_MASK),  /*!< Receive Overrun, sets when new data is rec
 179:../drivers/fsl_lpuart.h ****                                                        read from receive register */
 180:../drivers/fsl_lpuart.h ****     kLPUART_NoiseErrorFlag = (LPUART_STAT_NF_MASK), /*!< Receive takes 3 samples of each received b
 181:../drivers/fsl_lpuart.h ****                                                        samples differ, noise flag sets */
 182:../drivers/fsl_lpuart.h ****     kLPUART_FramingErrorFlag =
 183:../drivers/fsl_lpuart.h ****         (LPUART_STAT_FE_MASK), /*!< Frame error flag, sets if logic 0 was detected where stop bit e
 184:../drivers/fsl_lpuart.h ****     kLPUART_ParityErrorFlag = (LPUART_STAT_PF_MASK), /*!< If parity enabled, sets upon parity error
 185:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
 186:../drivers/fsl_lpuart.h ****     kLPUART_LinBreakFlag = (LPUART_STAT_LBKDIF_MASK), /*!< LIN break detect interrupt flag, sets wh
 187:../drivers/fsl_lpuart.h ****                                                          detected and LIN circuit enabled */
 188:../drivers/fsl_lpuart.h **** #endif
 189:../drivers/fsl_lpuart.h ****     kLPUART_RxActiveEdgeFlag =
 190:../drivers/fsl_lpuart.h ****         (LPUART_STAT_RXEDGIF_MASK), /*!< Receive pin active edge interrupt flag, sets when active e
 191:../drivers/fsl_lpuart.h ****     kLPUART_RxActiveFlag =
 192:../drivers/fsl_lpuart.h ****         (LPUART_STAT_RAF_MASK), /*!< Receiver Active Flag (RAF), sets at beginning of valid start b
 193:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
 194:../drivers/fsl_lpuart.h ****     kLPUART_DataMatch1Flag = LPUART_STAT_MA1F_MASK, /*!< The next character to be read from LPUART_
 195:../drivers/fsl_lpuart.h ****     kLPUART_DataMatch2Flag = LPUART_STAT_MA2F_MASK, /*!< The next character to be read from LPUART_
 196:../drivers/fsl_lpuart.h **** #endif
 197:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_LPUART_HAS_EXTENDED
 198:../drivers/fsl_lpuart.h ****     kLPUART_NoiseErrorInRxDataRegFlag =
 199:../drivers/fsl_lpuart.h ****         (LPUART_DATA_NOISY_MASK >> 10), /*!< NOISY bit, sets if noise detected in current data word
 200:../drivers/fsl_lpuart.h ****     kLPUART_ParityErrorInRxDataRegFlag =
 201:../drivers/fsl_lpuart.h ****         (LPUART_DATA_PARITYE_MASK >> 10), /*!< PARITYE bit, sets if noise detected in current data 
 202:../drivers/fsl_lpuart.h **** #endif
 203:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 204:../drivers/fsl_lpuart.h ****     kLPUART_TxFifoEmptyFlag = (LPUART_FIFO_TXEMPT_MASK >> 16), /*!< TXEMPT bit, sets if transmit bu
 205:../drivers/fsl_lpuart.h ****     kLPUART_RxFifoEmptyFlag = (LPUART_FIFO_RXEMPT_MASK >> 16), /*!< RXEMPT bit, sets if receive buf
 206:../drivers/fsl_lpuart.h ****     kLPUART_TxFifoOverflowFlag =
 207:../drivers/fsl_lpuart.h ****         (LPUART_FIFO_TXOF_MASK >> 16), /*!< TXOF bit, sets if transmit buffer overflow occurred */
 208:../drivers/fsl_lpuart.h ****     kLPUART_RxFifoUnderflowFlag =
 209:../drivers/fsl_lpuart.h ****         (LPUART_FIFO_RXUF_MASK >> 16), /*!< RXUF bit, sets if receive buffer underflow occurred */
 210:../drivers/fsl_lpuart.h **** #endif
 211:../drivers/fsl_lpuart.h **** };
 212:../drivers/fsl_lpuart.h **** 
 213:../drivers/fsl_lpuart.h **** /*! @brief LPUART configuration structure. */
 214:../drivers/fsl_lpuart.h **** typedef struct _lpuart_config
 215:../drivers/fsl_lpuart.h **** {
 216:../drivers/fsl_lpuart.h ****     uint32_t baudRate_Bps;            /*!< LPUART baud rate  */
 217:../drivers/fsl_lpuart.h ****     lpuart_parity_mode_t parityMode;  /*!< Parity mode, disabled (default), even, odd */
 218:../drivers/fsl_lpuart.h ****     lpuart_data_bits_t dataBitsCount; /*!< Data bits count, eight (default), seven */
 219:../drivers/fsl_lpuart.h ****     bool isMsb;                       /*!< Data bits order, LSB (default), MSB */
 220:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONF
 221:../drivers/fsl_lpuart.h ****     lpuart_stop_bit_count_t stopBitCount; /*!< Number of stop bits, 1 stop bit (default) or 2 stop 
 222:../drivers/fsl_lpuart.h **** #endif
 223:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 224:../drivers/fsl_lpuart.h ****     uint8_t txFifoWatermark; /*!< TX FIFO watermark */
 225:../drivers/fsl_lpuart.h ****     uint8_t rxFifoWatermark; /*!< RX FIFO watermark */
 226:../drivers/fsl_lpuart.h **** #endif
 227:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
 228:../drivers/fsl_lpuart.h ****     bool enableRxRTS;                         /*!< RX RTS enable */
 229:../drivers/fsl_lpuart.h ****     bool enableTxCTS;                         /*!< TX CTS enable */
 230:../drivers/fsl_lpuart.h ****     lpuart_transmit_cts_source_t txCtsSource; /*!< TX CTS source */
 231:../drivers/fsl_lpuart.h ****     lpuart_transmit_cts_config_t txCtsConfig; /*!< TX CTS configure */
 232:../drivers/fsl_lpuart.h **** #endif
 233:../drivers/fsl_lpuart.h ****     lpuart_idle_type_select_t rxIdleType; /*!< RX IDLE type. */
 234:../drivers/fsl_lpuart.h ****     lpuart_idle_config_t rxIdleConfig;    /*!< RX IDLE configuration. */
 235:../drivers/fsl_lpuart.h ****     bool enableTx;                        /*!< Enable TX */
 236:../drivers/fsl_lpuart.h ****     bool enableRx;                        /*!< Enable RX */
 237:../drivers/fsl_lpuart.h **** } lpuart_config_t;
 238:../drivers/fsl_lpuart.h **** 
 239:../drivers/fsl_lpuart.h **** /*! @brief LPUART transfer structure. */
 240:../drivers/fsl_lpuart.h **** typedef struct _lpuart_transfer
 241:../drivers/fsl_lpuart.h **** {
 242:../drivers/fsl_lpuart.h ****     uint8_t *data;   /*!< The buffer of data to be transfer.*/
 243:../drivers/fsl_lpuart.h ****     size_t dataSize; /*!< The byte count to be transfer. */
 244:../drivers/fsl_lpuart.h **** } lpuart_transfer_t;
 245:../drivers/fsl_lpuart.h **** 
 246:../drivers/fsl_lpuart.h **** /* Forward declaration of the handle typedef. */
 247:../drivers/fsl_lpuart.h **** typedef struct _lpuart_handle lpuart_handle_t;
 248:../drivers/fsl_lpuart.h **** 
 249:../drivers/fsl_lpuart.h **** /*! @brief LPUART transfer callback function. */
 250:../drivers/fsl_lpuart.h **** typedef void (*lpuart_transfer_callback_t)(LPUART_Type *base, lpuart_handle_t *handle, status_t sta
 251:../drivers/fsl_lpuart.h **** 
 252:../drivers/fsl_lpuart.h **** /*! @brief LPUART handle structure. */
 253:../drivers/fsl_lpuart.h **** struct _lpuart_handle
 254:../drivers/fsl_lpuart.h **** {
 255:../drivers/fsl_lpuart.h ****     uint8_t *volatile txData;   /*!< Address of remaining data to send. */
 256:../drivers/fsl_lpuart.h ****     volatile size_t txDataSize; /*!< Size of the remaining data to send. */
 257:../drivers/fsl_lpuart.h ****     size_t txDataSizeAll;       /*!< Size of the data to send out. */
 258:../drivers/fsl_lpuart.h ****     uint8_t *volatile rxData;   /*!< Address of remaining data to receive. */
 259:../drivers/fsl_lpuart.h ****     volatile size_t rxDataSize; /*!< Size of the remaining data to receive. */
 260:../drivers/fsl_lpuart.h ****     size_t rxDataSizeAll;       /*!< Size of the data to receive. */
 261:../drivers/fsl_lpuart.h **** 
 262:../drivers/fsl_lpuart.h ****     uint8_t *rxRingBuffer;              /*!< Start address of the receiver ring buffer. */
 263:../drivers/fsl_lpuart.h ****     size_t rxRingBufferSize;            /*!< Size of the ring buffer. */
 264:../drivers/fsl_lpuart.h ****     volatile uint16_t rxRingBufferHead; /*!< Index for the driver to store received data into ring 
 265:../drivers/fsl_lpuart.h ****     volatile uint16_t rxRingBufferTail; /*!< Index for the user to get data from the ring buffer. *
 266:../drivers/fsl_lpuart.h **** 
 267:../drivers/fsl_lpuart.h ****     lpuart_transfer_callback_t callback; /*!< Callback function. */
 268:../drivers/fsl_lpuart.h ****     void *userData;                      /*!< LPUART callback function parameter.*/
 269:../drivers/fsl_lpuart.h **** 
 270:../drivers/fsl_lpuart.h ****     volatile uint8_t txState; /*!< TX transfer state. */
 271:../drivers/fsl_lpuart.h ****     volatile uint8_t rxState; /*!< RX transfer state. */
 272:../drivers/fsl_lpuart.h **** 
 273:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
 274:../drivers/fsl_lpuart.h ****     bool isSevenDataBits; /*!< Seven data bits flag. */
 275:../drivers/fsl_lpuart.h **** #endif
 276:../drivers/fsl_lpuart.h **** };
 277:../drivers/fsl_lpuart.h **** 
 278:../drivers/fsl_lpuart.h **** /*******************************************************************************
 279:../drivers/fsl_lpuart.h ****  * API
 280:../drivers/fsl_lpuart.h ****  ******************************************************************************/
 281:../drivers/fsl_lpuart.h **** 
 282:../drivers/fsl_lpuart.h **** #if defined(__cplusplus)
 283:../drivers/fsl_lpuart.h **** extern "C" {
 284:../drivers/fsl_lpuart.h **** #endif /* _cplusplus */
 285:../drivers/fsl_lpuart.h **** 
 286:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_GLOBAL) && FSL_FEATURE_LPUART_HAS_GLOBAL
 287:../drivers/fsl_lpuart.h **** 
 288:../drivers/fsl_lpuart.h **** /*!
 289:../drivers/fsl_lpuart.h ****  * @name Software Reset
 290:../drivers/fsl_lpuart.h ****  * @{
 291:../drivers/fsl_lpuart.h ****  */
 292:../drivers/fsl_lpuart.h **** 
 293:../drivers/fsl_lpuart.h **** /*!
 294:../drivers/fsl_lpuart.h ****  * @brief Resets the LPUART using software.
 295:../drivers/fsl_lpuart.h ****  *
 296:../drivers/fsl_lpuart.h ****  * This function resets all internal logic and registers except the Global Register.
 297:../drivers/fsl_lpuart.h ****  * Remains set until cleared by software.
 298:../drivers/fsl_lpuart.h ****  *
 299:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 300:../drivers/fsl_lpuart.h ****  */
 301:../drivers/fsl_lpuart.h **** static inline void LPUART_SoftwareReset(LPUART_Type *base)
 302:../drivers/fsl_lpuart.h **** {
 303:../drivers/fsl_lpuart.h ****     base->GLOBAL |= LPUART_GLOBAL_RST_MASK;
 304:../drivers/fsl_lpuart.h ****     base->GLOBAL &= ~LPUART_GLOBAL_RST_MASK;
 305:../drivers/fsl_lpuart.h **** }
 306:../drivers/fsl_lpuart.h **** /* @} */
 307:../drivers/fsl_lpuart.h **** #endif /*FSL_FEATURE_LPUART_HAS_GLOBAL*/
 308:../drivers/fsl_lpuart.h **** 
 309:../drivers/fsl_lpuart.h **** /*!
 310:../drivers/fsl_lpuart.h ****  * @name Initialization and deinitialization
 311:../drivers/fsl_lpuart.h ****  * @{
 312:../drivers/fsl_lpuart.h ****  */
 313:../drivers/fsl_lpuart.h **** 
 314:../drivers/fsl_lpuart.h **** /*!
 315:../drivers/fsl_lpuart.h ****  * @brief Initializes an LPUART instance with the user configuration structure and the peripheral c
 316:../drivers/fsl_lpuart.h ****  *
 317:../drivers/fsl_lpuart.h ****  * This function configures the LPUART module with user-defined settings. Call the LPUART_GetDefaul
 318:../drivers/fsl_lpuart.h ****  * to configure the configuration structure and get the default configuration.
 319:../drivers/fsl_lpuart.h ****  * The example below shows how to use this API to configure the LPUART.
 320:../drivers/fsl_lpuart.h ****  * @code
 321:../drivers/fsl_lpuart.h ****  *  lpuart_config_t lpuartConfig;
 322:../drivers/fsl_lpuart.h ****  *  lpuartConfig.baudRate_Bps = 115200U;
 323:../drivers/fsl_lpuart.h ****  *  lpuartConfig.parityMode = kLPUART_ParityDisabled;
 324:../drivers/fsl_lpuart.h ****  *  lpuartConfig.dataBitsCount = kLPUART_EightDataBits;
 325:../drivers/fsl_lpuart.h ****  *  lpuartConfig.isMsb = false;
 326:../drivers/fsl_lpuart.h ****  *  lpuartConfig.stopBitCount = kLPUART_OneStopBit;
 327:../drivers/fsl_lpuart.h ****  *  lpuartConfig.txFifoWatermark = 0;
 328:../drivers/fsl_lpuart.h ****  *  lpuartConfig.rxFifoWatermark = 1;
 329:../drivers/fsl_lpuart.h ****  *  LPUART_Init(LPUART1, &lpuartConfig, 20000000U);
 330:../drivers/fsl_lpuart.h ****  * @endcode
 331:../drivers/fsl_lpuart.h ****  *
 332:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 333:../drivers/fsl_lpuart.h ****  * @param config Pointer to a user-defined configuration structure.
 334:../drivers/fsl_lpuart.h ****  * @param srcClock_Hz LPUART clock source frequency in HZ.
 335:../drivers/fsl_lpuart.h ****  * @retval kStatus_LPUART_BaudrateNotSupport Baudrate is not support in current clock source.
 336:../drivers/fsl_lpuart.h ****  * @retval kStatus_Success LPUART initialize succeed
 337:../drivers/fsl_lpuart.h ****  */
 338:../drivers/fsl_lpuart.h **** status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz);
 339:../drivers/fsl_lpuart.h **** 
 340:../drivers/fsl_lpuart.h **** /*!
 341:../drivers/fsl_lpuart.h ****  * @brief Deinitializes a LPUART instance.
 342:../drivers/fsl_lpuart.h ****  *
 343:../drivers/fsl_lpuart.h ****  * This function waits for transmit to complete, disables TX and RX, and disables the LPUART clock.
 344:../drivers/fsl_lpuart.h ****  *
 345:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 346:../drivers/fsl_lpuart.h ****  */
 347:../drivers/fsl_lpuart.h **** void LPUART_Deinit(LPUART_Type *base);
 348:../drivers/fsl_lpuart.h **** 
 349:../drivers/fsl_lpuart.h **** /*!
 350:../drivers/fsl_lpuart.h ****  * @brief Gets the default configuration structure.
 351:../drivers/fsl_lpuart.h ****  *
 352:../drivers/fsl_lpuart.h ****  * This function initializes the LPUART configuration structure to a default value. The default
 353:../drivers/fsl_lpuart.h ****  * values are:
 354:../drivers/fsl_lpuart.h ****  *   lpuartConfig->baudRate_Bps = 115200U;
 355:../drivers/fsl_lpuart.h ****  *   lpuartConfig->parityMode = kLPUART_ParityDisabled;
 356:../drivers/fsl_lpuart.h ****  *   lpuartConfig->dataBitsCount = kLPUART_EightDataBits;
 357:../drivers/fsl_lpuart.h ****  *   lpuartConfig->isMsb = false;
 358:../drivers/fsl_lpuart.h ****  *   lpuartConfig->stopBitCount = kLPUART_OneStopBit;
 359:../drivers/fsl_lpuart.h ****  *   lpuartConfig->txFifoWatermark = 0;
 360:../drivers/fsl_lpuart.h ****  *   lpuartConfig->rxFifoWatermark = 1;
 361:../drivers/fsl_lpuart.h ****  *   lpuartConfig->rxIdleType = kLPUART_IdleTypeStartBit;
 362:../drivers/fsl_lpuart.h ****  *   lpuartConfig->rxIdleConfig = kLPUART_IdleCharacter1;
 363:../drivers/fsl_lpuart.h ****  *   lpuartConfig->enableTx = false;
 364:../drivers/fsl_lpuart.h ****  *   lpuartConfig->enableRx = false;
 365:../drivers/fsl_lpuart.h ****  *
 366:../drivers/fsl_lpuart.h ****  * @param config Pointer to a configuration structure.
 367:../drivers/fsl_lpuart.h ****  */
 368:../drivers/fsl_lpuart.h **** void LPUART_GetDefaultConfig(lpuart_config_t *config);
 369:../drivers/fsl_lpuart.h **** 
 370:../drivers/fsl_lpuart.h **** /*!
 371:../drivers/fsl_lpuart.h ****  * @brief Sets the LPUART instance baudrate.
 372:../drivers/fsl_lpuart.h ****  *
 373:../drivers/fsl_lpuart.h ****  * This function configures the LPUART module baudrate. This function is used to update
 374:../drivers/fsl_lpuart.h ****  * the LPUART module baudrate after the LPUART module is initialized by the LPUART_Init.
 375:../drivers/fsl_lpuart.h ****  * @code
 376:../drivers/fsl_lpuart.h ****  *  LPUART_SetBaudRate(LPUART1, 115200U, 20000000U);
 377:../drivers/fsl_lpuart.h ****  * @endcode
 378:../drivers/fsl_lpuart.h ****  *
 379:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 380:../drivers/fsl_lpuart.h ****  * @param baudRate_Bps LPUART baudrate to be set.
 381:../drivers/fsl_lpuart.h ****  * @param srcClock_Hz LPUART clock source frequency in HZ.
 382:../drivers/fsl_lpuart.h ****  * @retval kStatus_LPUART_BaudrateNotSupport Baudrate is not supported in the current clock source.
 383:../drivers/fsl_lpuart.h ****  * @retval kStatus_Success Set baudrate succeeded.
 384:../drivers/fsl_lpuart.h ****  */
 385:../drivers/fsl_lpuart.h **** status_t LPUART_SetBaudRate(LPUART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz);
 386:../drivers/fsl_lpuart.h **** 
 387:../drivers/fsl_lpuart.h **** /* @} */
 388:../drivers/fsl_lpuart.h **** 
 389:../drivers/fsl_lpuart.h **** /*!
 390:../drivers/fsl_lpuart.h ****  * @name Status
 391:../drivers/fsl_lpuart.h ****  * @{
 392:../drivers/fsl_lpuart.h ****  */
 393:../drivers/fsl_lpuart.h **** 
 394:../drivers/fsl_lpuart.h **** /*!
 395:../drivers/fsl_lpuart.h ****  * @brief Gets LPUART status flags.
 396:../drivers/fsl_lpuart.h ****  *
 397:../drivers/fsl_lpuart.h ****  * This function gets all LPUART status flags. The flags are returned as the logical
 398:../drivers/fsl_lpuart.h ****  * OR value of the enumerators @ref _lpuart_flags. To check for a specific status,
 399:../drivers/fsl_lpuart.h ****  * compare the return value with enumerators in the @ref _lpuart_flags.
 400:../drivers/fsl_lpuart.h ****  * For example, to check whether the TX is empty:
 401:../drivers/fsl_lpuart.h ****  * @code
 402:../drivers/fsl_lpuart.h ****  *     if (kLPUART_TxDataRegEmptyFlag & LPUART_GetStatusFlags(LPUART1))
 403:../drivers/fsl_lpuart.h ****  *     {
 404:../drivers/fsl_lpuart.h ****  *         ...
 405:../drivers/fsl_lpuart.h ****  *     }
 406:../drivers/fsl_lpuart.h ****  * @endcode
 407:../drivers/fsl_lpuart.h ****  *
 408:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 409:../drivers/fsl_lpuart.h ****  * @return LPUART status flags which are ORed by the enumerators in the _lpuart_flags.
 410:../drivers/fsl_lpuart.h ****  */
 411:../drivers/fsl_lpuart.h **** uint32_t LPUART_GetStatusFlags(LPUART_Type *base);
 412:../drivers/fsl_lpuart.h **** 
 413:../drivers/fsl_lpuart.h **** /*!
 414:../drivers/fsl_lpuart.h ****  * @brief Clears status flags with a provided mask.
 415:../drivers/fsl_lpuart.h ****  *
 416:../drivers/fsl_lpuart.h ****  * This function clears LPUART status flags with a provided mask. Automatically cleared flags
 417:../drivers/fsl_lpuart.h ****  * can't be cleared by this function.
 418:../drivers/fsl_lpuart.h ****  * Flags that can only cleared or set by hardware are:
 419:../drivers/fsl_lpuart.h ****  *    kLPUART_TxDataRegEmptyFlag, kLPUART_TransmissionCompleteFlag, kLPUART_RxDataRegFullFlag,
 420:../drivers/fsl_lpuart.h ****  *    kLPUART_RxActiveFlag, kLPUART_NoiseErrorInRxDataRegFlag, kLPUART_ParityErrorInRxDataRegFlag,
 421:../drivers/fsl_lpuart.h ****  *    kLPUART_TxFifoEmptyFlag,kLPUART_RxFifoEmptyFlag
 422:../drivers/fsl_lpuart.h ****  * Note: This API should be called when the Tx/Rx is idle, otherwise it takes no effects.
 423:../drivers/fsl_lpuart.h ****  *
 424:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 425:../drivers/fsl_lpuart.h ****  * @param mask the status flags to be cleared. The user can use the enumerators in the
 426:../drivers/fsl_lpuart.h ****  *  _lpuart_status_flag_t to do the OR operation and get the mask.
 427:../drivers/fsl_lpuart.h ****  * @return 0 succeed, others failed.
 428:../drivers/fsl_lpuart.h ****  * @retval kStatus_LPUART_FlagCannotClearManually The flag can't be cleared by this function but
 429:../drivers/fsl_lpuart.h ****  *         it is cleared automatically by hardware.
 430:../drivers/fsl_lpuart.h ****  * @retval kStatus_Success Status in the mask are cleared.
 431:../drivers/fsl_lpuart.h ****  */
 432:../drivers/fsl_lpuart.h **** status_t LPUART_ClearStatusFlags(LPUART_Type *base, uint32_t mask);
 433:../drivers/fsl_lpuart.h **** 
 434:../drivers/fsl_lpuart.h **** /* @} */
 435:../drivers/fsl_lpuart.h **** 
 436:../drivers/fsl_lpuart.h **** /*!
 437:../drivers/fsl_lpuart.h ****  * @name Interrupts
 438:../drivers/fsl_lpuart.h ****  * @{
 439:../drivers/fsl_lpuart.h ****  */
 440:../drivers/fsl_lpuart.h **** 
 441:../drivers/fsl_lpuart.h **** /*!
 442:../drivers/fsl_lpuart.h ****  * @brief Enables LPUART interrupts according to a provided mask.
 443:../drivers/fsl_lpuart.h ****  *
 444:../drivers/fsl_lpuart.h ****  * This function enables the LPUART interrupts according to a provided mask. The mask
 445:../drivers/fsl_lpuart.h ****  * is a logical OR of enumeration members. See the @ref _lpuart_interrupt_enable.
 446:../drivers/fsl_lpuart.h ****  * This examples shows how to enable TX empty interrupt and RX full interrupt:
 447:../drivers/fsl_lpuart.h ****  * @code
 448:../drivers/fsl_lpuart.h ****  *     LPUART_EnableInterrupts(LPUART1,kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_RxDataRegFul
 449:../drivers/fsl_lpuart.h ****  * @endcode
 450:../drivers/fsl_lpuart.h ****  *
 451:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 452:../drivers/fsl_lpuart.h ****  * @param mask The interrupts to enable. Logical OR of @ref _uart_interrupt_enable.
 453:../drivers/fsl_lpuart.h ****  */
 454:../drivers/fsl_lpuart.h **** void LPUART_EnableInterrupts(LPUART_Type *base, uint32_t mask);
 455:../drivers/fsl_lpuart.h **** 
 456:../drivers/fsl_lpuart.h **** /*!
 457:../drivers/fsl_lpuart.h ****  * @brief Disables  LPUART interrupts according to a provided mask.
 458:../drivers/fsl_lpuart.h ****  *
 459:../drivers/fsl_lpuart.h ****  * This function disables the LPUART interrupts according to a provided mask. The mask
 460:../drivers/fsl_lpuart.h ****  * is a logical OR of enumeration members. See @ref _lpuart_interrupt_enable.
 461:../drivers/fsl_lpuart.h ****  * This example shows how to disable the TX empty interrupt and RX full interrupt:
 462:../drivers/fsl_lpuart.h ****  * @code
 463:../drivers/fsl_lpuart.h ****  *     LPUART_DisableInterrupts(LPUART1,kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_RxDataRegFu
 464:../drivers/fsl_lpuart.h ****  * @endcode
 465:../drivers/fsl_lpuart.h ****  *
 466:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 467:../drivers/fsl_lpuart.h ****  * @param mask The interrupts to disable. Logical OR of @ref _lpuart_interrupt_enable.
 468:../drivers/fsl_lpuart.h ****  */
 469:../drivers/fsl_lpuart.h **** void LPUART_DisableInterrupts(LPUART_Type *base, uint32_t mask);
 470:../drivers/fsl_lpuart.h **** 
 471:../drivers/fsl_lpuart.h **** /*!
 472:../drivers/fsl_lpuart.h ****  * @brief Gets enabled LPUART interrupts.
 473:../drivers/fsl_lpuart.h ****  *
 474:../drivers/fsl_lpuart.h ****  * This function gets the enabled LPUART interrupts. The enabled interrupts are returned
 475:../drivers/fsl_lpuart.h ****  * as the logical OR value of the enumerators @ref _lpuart_interrupt_enable. To check
 476:../drivers/fsl_lpuart.h ****  * a specific interrupt enable status, compare the return value with enumerators
 477:../drivers/fsl_lpuart.h ****  * in @ref _lpuart_interrupt_enable.
 478:../drivers/fsl_lpuart.h ****  * For example, to check whether the TX empty interrupt is enabled:
 479:../drivers/fsl_lpuart.h ****  * @code
 480:../drivers/fsl_lpuart.h ****  *     uint32_t enabledInterrupts = LPUART_GetEnabledInterrupts(LPUART1);
 481:../drivers/fsl_lpuart.h ****  *
 482:../drivers/fsl_lpuart.h ****  *     if (kLPUART_TxDataRegEmptyInterruptEnable & enabledInterrupts)
 483:../drivers/fsl_lpuart.h ****  *     {
 484:../drivers/fsl_lpuart.h ****  *         ...
 485:../drivers/fsl_lpuart.h ****  *     }
 486:../drivers/fsl_lpuart.h ****  * @endcode
 487:../drivers/fsl_lpuart.h ****  *
 488:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 489:../drivers/fsl_lpuart.h ****  * @return LPUART interrupt flags which are logical OR of the enumerators in @ref _lpuart_interrupt
 490:../drivers/fsl_lpuart.h ****  */
 491:../drivers/fsl_lpuart.h **** uint32_t LPUART_GetEnabledInterrupts(LPUART_Type *base);
 492:../drivers/fsl_lpuart.h **** 
 493:../drivers/fsl_lpuart.h **** #if defined(FSL_FEATURE_LPUART_HAS_DMA_ENABLE) && FSL_FEATURE_LPUART_HAS_DMA_ENABLE
 494:../drivers/fsl_lpuart.h **** /*!
 495:../drivers/fsl_lpuart.h ****  * @brief Gets the LPUART data register address.
 496:../drivers/fsl_lpuart.h ****  *
 497:../drivers/fsl_lpuart.h ****  * This function returns the LPUART data register address, which is mainly used by the DMA/eDMA.
 498:../drivers/fsl_lpuart.h ****  *
 499:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 500:../drivers/fsl_lpuart.h ****  * @return LPUART data register addresses which are used both by the transmitter and receiver.
 501:../drivers/fsl_lpuart.h ****  */
 502:../drivers/fsl_lpuart.h **** static inline uint32_t LPUART_GetDataRegisterAddress(LPUART_Type *base)
 503:../drivers/fsl_lpuart.h **** {
 504:../drivers/fsl_lpuart.h ****     return (uint32_t) & (base->DATA);
 505:../drivers/fsl_lpuart.h **** }
 506:../drivers/fsl_lpuart.h **** 
 507:../drivers/fsl_lpuart.h **** /*!
 508:../drivers/fsl_lpuart.h ****  * @brief Enables or disables the LPUART transmitter DMA request.
 509:../drivers/fsl_lpuart.h ****  *
 510:../drivers/fsl_lpuart.h ****  * This function enables or disables the transmit data register empty flag, STAT[TDRE], to generate
 511:../drivers/fsl_lpuart.h ****  *
 512:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 513:../drivers/fsl_lpuart.h ****  * @param enable True to enable, false to disable.
 514:../drivers/fsl_lpuart.h ****  */
 515:../drivers/fsl_lpuart.h **** static inline void LPUART_EnableTxDMA(LPUART_Type *base, bool enable)
 516:../drivers/fsl_lpuart.h **** {
 517:../drivers/fsl_lpuart.h ****     if (enable)
 518:../drivers/fsl_lpuart.h ****     {
 519:../drivers/fsl_lpuart.h ****         base->BAUD |= LPUART_BAUD_TDMAE_MASK;
 520:../drivers/fsl_lpuart.h ****         base->CTRL |= LPUART_CTRL_TIE_MASK;
 521:../drivers/fsl_lpuart.h ****     }
 522:../drivers/fsl_lpuart.h ****     else
 523:../drivers/fsl_lpuart.h ****     {
 524:../drivers/fsl_lpuart.h ****         base->BAUD &= ~LPUART_BAUD_TDMAE_MASK;
  43              		.loc 2 524 0
  44 0004 1868     		ldr	r0, [r3]
  45              	.LVL3:
  46 0006 0F4C     		ldr	r4, .L3
  47 0008 2040     		ands	r0, r4
  48 000a 1860     		str	r0, [r3]
 525:../drivers/fsl_lpuart.h ****         base->CTRL &= ~LPUART_CTRL_TIE_MASK;
  49              		.loc 2 525 0
  50 000c 9A68     		ldr	r2, [r3, #8]
  51 000e 2240     		ands	r2, r4
  52 0010 9A60     		str	r2, [r3, #8]
  53              	.LVL4:
  54              	.LBE35:
  55              	.LBE34:
 149:../drivers/fsl_lpuart_dma.c **** 
 150:../drivers/fsl_lpuart_dma.c ****     /* Disable interrupt. */
 151:../drivers/fsl_lpuart_dma.c ****     DMA_DisableInterrupts(lpuartPrivateHandle->handle->txDmaHandle->base,
  56              		.loc 1 151 0
  57 0012 4B68     		ldr	r3, [r1, #4]
  58 0014 1A69     		ldr	r2, [r3, #16]
  59 0016 1368     		ldr	r3, [r2]
 152:../drivers/fsl_lpuart_dma.c ****                           lpuartPrivateHandle->handle->txDmaHandle->channel);
  60              		.loc 1 152 0
  61 0018 1279     		ldrb	r2, [r2, #4]
  62              	.LVL5:
  63              	.LBB36:
  64              	.LBB37:
  65              		.file 3 "../drivers/fsl_dma.h"
   1:../drivers/fsl_dma.h **** /*
   2:../drivers/fsl_dma.h ****  * The Clear BSD License
   3:../drivers/fsl_dma.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_dma.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_dma.h ****  * All rights reserved.
   6:../drivers/fsl_dma.h ****  *
   7:../drivers/fsl_dma.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_dma.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_dma.h ****  * that the following conditions are met:
  10:../drivers/fsl_dma.h ****  *
  11:../drivers/fsl_dma.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_dma.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_dma.h ****  *
  14:../drivers/fsl_dma.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_dma.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_dma.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_dma.h ****  *
  18:../drivers/fsl_dma.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_dma.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_dma.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_dma.h ****  *
  22:../drivers/fsl_dma.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_dma.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_dma.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_dma.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_dma.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_dma.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_dma.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_dma.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_dma.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_dma.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_dma.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_dma.h ****  */
  34:../drivers/fsl_dma.h **** 
  35:../drivers/fsl_dma.h **** #ifndef _FSL_DMA_H_
  36:../drivers/fsl_dma.h **** #define _FSL_DMA_H_
  37:../drivers/fsl_dma.h **** 
  38:../drivers/fsl_dma.h **** #include "fsl_common.h"
  39:../drivers/fsl_dma.h **** 
  40:../drivers/fsl_dma.h **** /*!
  41:../drivers/fsl_dma.h ****  * @addtogroup dma
  42:../drivers/fsl_dma.h ****  * @{
  43:../drivers/fsl_dma.h ****  */
  44:../drivers/fsl_dma.h **** 
  45:../drivers/fsl_dma.h **** 
  46:../drivers/fsl_dma.h **** /*******************************************************************************
  47:../drivers/fsl_dma.h ****  * Definitions
  48:../drivers/fsl_dma.h ****  ******************************************************************************/
  49:../drivers/fsl_dma.h **** 
  50:../drivers/fsl_dma.h **** /*! @name Driver version */
  51:../drivers/fsl_dma.h **** /*@{*/
  52:../drivers/fsl_dma.h **** /*! @brief DMA driver version 2.0.1. */
  53:../drivers/fsl_dma.h **** #define FSL_DMA_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  54:../drivers/fsl_dma.h **** /*@}*/
  55:../drivers/fsl_dma.h **** 
  56:../drivers/fsl_dma.h **** /*! @brief status flag for the DMA driver. */
  57:../drivers/fsl_dma.h **** enum _dma_channel_status_flags
  58:../drivers/fsl_dma.h **** {
  59:../drivers/fsl_dma.h ****     kDMA_TransactionsBCRFlag = DMA_DSR_BCR_BCR_MASK,       /*!< Contains the number of bytes yet to
  60:../drivers/fsl_dma.h ****                                                                 transferred for a given block */
  61:../drivers/fsl_dma.h ****     kDMA_TransactionsDoneFlag = DMA_DSR_BCR_DONE_MASK,     /*!< Transactions Done */
  62:../drivers/fsl_dma.h ****     kDMA_TransactionsBusyFlag = DMA_DSR_BCR_BSY_MASK,      /*!< Transactions Busy */
  63:../drivers/fsl_dma.h ****     kDMA_TransactionsRequestFlag = DMA_DSR_BCR_REQ_MASK,   /*!< Transactions Request */
  64:../drivers/fsl_dma.h ****     kDMA_BusErrorOnDestinationFlag = DMA_DSR_BCR_BED_MASK, /*!< Bus Error on Destination */
  65:../drivers/fsl_dma.h ****     kDMA_BusErrorOnSourceFlag = DMA_DSR_BCR_BES_MASK,      /*!< Bus Error on Source */
  66:../drivers/fsl_dma.h ****     kDMA_ConfigurationErrorFlag = DMA_DSR_BCR_CE_MASK,     /*!< Configuration Error */
  67:../drivers/fsl_dma.h **** };
  68:../drivers/fsl_dma.h **** 
  69:../drivers/fsl_dma.h **** /*! @brief DMA transfer size type*/
  70:../drivers/fsl_dma.h **** typedef enum _dma_transfer_size
  71:../drivers/fsl_dma.h **** {
  72:../drivers/fsl_dma.h ****     kDMA_Transfersize32bits = 0x0U, /*!< 32 bits are transferred for every read/write */
  73:../drivers/fsl_dma.h ****     kDMA_Transfersize8bits,         /*!< 8 bits are transferred for every read/write */
  74:../drivers/fsl_dma.h ****     kDMA_Transfersize16bits,        /*!< 16b its are transferred for every read/write */
  75:../drivers/fsl_dma.h **** } dma_transfer_size_t;
  76:../drivers/fsl_dma.h **** 
  77:../drivers/fsl_dma.h **** /*! @brief Configuration type for the DMA modulo */
  78:../drivers/fsl_dma.h **** typedef enum _dma_modulo
  79:../drivers/fsl_dma.h **** {
  80:../drivers/fsl_dma.h ****     kDMA_ModuloDisable = 0x0U, /*!< Buffer disabled */
  81:../drivers/fsl_dma.h ****     kDMA_Modulo16Bytes,        /*!< Circular buffer size is 16 bytes. */
  82:../drivers/fsl_dma.h ****     kDMA_Modulo32Bytes,        /*!< Circular buffer size is 32 bytes. */
  83:../drivers/fsl_dma.h ****     kDMA_Modulo64Bytes,        /*!< Circular buffer size is 64 bytes. */
  84:../drivers/fsl_dma.h ****     kDMA_Modulo128Bytes,       /*!< Circular buffer size is 128 bytes. */
  85:../drivers/fsl_dma.h ****     kDMA_Modulo256Bytes,       /*!< Circular buffer size is 256 bytes. */
  86:../drivers/fsl_dma.h ****     kDMA_Modulo512Bytes,       /*!< Circular buffer size is 512 bytes. */
  87:../drivers/fsl_dma.h ****     kDMA_Modulo1KBytes,        /*!< Circular buffer size is 1 KB. */
  88:../drivers/fsl_dma.h ****     kDMA_Modulo2KBytes,        /*!< Circular buffer size is 2 KB. */
  89:../drivers/fsl_dma.h ****     kDMA_Modulo4KBytes,        /*!< Circular buffer size is 4 KB. */
  90:../drivers/fsl_dma.h ****     kDMA_Modulo8KBytes,        /*!< Circular buffer size is 8 KB. */
  91:../drivers/fsl_dma.h ****     kDMA_Modulo16KBytes,       /*!< Circular buffer size is 16 KB. */
  92:../drivers/fsl_dma.h ****     kDMA_Modulo32KBytes,       /*!< Circular buffer size is 32 KB. */
  93:../drivers/fsl_dma.h ****     kDMA_Modulo64KBytes,       /*!< Circular buffer size is 64 KB. */
  94:../drivers/fsl_dma.h ****     kDMA_Modulo128KBytes,      /*!< Circular buffer size is 128 KB. */
  95:../drivers/fsl_dma.h ****     kDMA_Modulo256KBytes,      /*!< Circular buffer size is 256 KB. */
  96:../drivers/fsl_dma.h **** } dma_modulo_t;
  97:../drivers/fsl_dma.h **** 
  98:../drivers/fsl_dma.h **** /*! @brief DMA channel link type */
  99:../drivers/fsl_dma.h **** typedef enum _dma_channel_link_type
 100:../drivers/fsl_dma.h **** {
 101:../drivers/fsl_dma.h ****     kDMA_ChannelLinkDisable = 0x0U,      /*!< No channel link. */
 102:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AndChannel2, /*!< Perform a link to channel LCH1 after each cycle-steal
 103:../drivers/fsl_dma.h ****                                               followed by a link to LCH2 after the BCR decrements t
 104:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1,            /*!< Perform a link to LCH1 after each cycle-steal transfe
 105:../drivers/fsl_dma.h ****     kDMA_ChannelLinkChannel1AfterBCR0,   /*!< Perform a link to LCH1 after the BCR decrements. */
 106:../drivers/fsl_dma.h **** } dma_channel_link_type_t;
 107:../drivers/fsl_dma.h **** 
 108:../drivers/fsl_dma.h **** /*! @brief DMA transfer type */
 109:../drivers/fsl_dma.h **** typedef enum _dma_transfer_type
 110:../drivers/fsl_dma.h **** {
 111:../drivers/fsl_dma.h ****     kDMA_MemoryToMemory = 0x0U, /*!< Memory to Memory transfer. */
 112:../drivers/fsl_dma.h ****     kDMA_PeripheralToMemory,    /*!< Peripheral to Memory transfer. */
 113:../drivers/fsl_dma.h ****     kDMA_MemoryToPeripheral,    /*!< Memory to Peripheral transfer. */
 114:../drivers/fsl_dma.h **** } dma_transfer_type_t;
 115:../drivers/fsl_dma.h **** 
 116:../drivers/fsl_dma.h **** /*! @brief DMA transfer options */
 117:../drivers/fsl_dma.h **** typedef enum _dma_transfer_options
 118:../drivers/fsl_dma.h **** {
 119:../drivers/fsl_dma.h ****     kDMA_NoOptions = 0x0U, /*!< Transfer without options. */
 120:../drivers/fsl_dma.h ****     kDMA_EnableInterrupt,  /*!< Enable interrupt while transfer complete. */
 121:../drivers/fsl_dma.h **** } dma_transfer_options_t;
 122:../drivers/fsl_dma.h **** 
 123:../drivers/fsl_dma.h **** /*! @brief DMA transfer status */
 124:../drivers/fsl_dma.h **** enum _dma_transfer_status
 125:../drivers/fsl_dma.h **** {
 126:../drivers/fsl_dma.h ****     kStatus_DMA_Busy = MAKE_STATUS(kStatusGroup_DMA, 0),
 127:../drivers/fsl_dma.h **** };
 128:../drivers/fsl_dma.h **** 
 129:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 130:../drivers/fsl_dma.h **** typedef struct _dma_transfer_config
 131:../drivers/fsl_dma.h **** {
 132:../drivers/fsl_dma.h ****     uint32_t srcAddr;             /*!< DMA transfer source address. */
 133:../drivers/fsl_dma.h ****     uint32_t destAddr;            /*!< DMA destination address.*/
 134:../drivers/fsl_dma.h ****     bool enableSrcIncrement;      /*!< Source address increase after each transfer. */
 135:../drivers/fsl_dma.h ****     dma_transfer_size_t srcSize;  /*!< Source transfer size unit. */
 136:../drivers/fsl_dma.h ****     bool enableDestIncrement;     /*!< Destination address increase after each transfer. */
 137:../drivers/fsl_dma.h ****     dma_transfer_size_t destSize; /*!< Destination transfer unit.*/
 138:../drivers/fsl_dma.h ****     uint32_t transferSize;        /*!< The number of bytes to be transferred. */
 139:../drivers/fsl_dma.h **** } dma_transfer_config_t;
 140:../drivers/fsl_dma.h **** 
 141:../drivers/fsl_dma.h **** /*! @brief DMA transfer configuration structure */
 142:../drivers/fsl_dma.h **** typedef struct _dma_channel_link_config
 143:../drivers/fsl_dma.h **** {
 144:../drivers/fsl_dma.h ****     dma_channel_link_type_t linkType; /*!< Channel link type. */
 145:../drivers/fsl_dma.h ****     uint32_t channel1;                /*!< The index of channel 1. */
 146:../drivers/fsl_dma.h ****     uint32_t channel2;                /*!< The index of channel 2. */
 147:../drivers/fsl_dma.h **** } dma_channel_link_config_t;
 148:../drivers/fsl_dma.h **** 
 149:../drivers/fsl_dma.h **** struct _dma_handle;
 150:../drivers/fsl_dma.h **** /*! @brief Callback function prototype for the DMA driver. */
 151:../drivers/fsl_dma.h **** typedef void (*dma_callback)(struct _dma_handle *handle, void *userData);
 152:../drivers/fsl_dma.h **** 
 153:../drivers/fsl_dma.h **** /*! @brief DMA DMA handle structure */
 154:../drivers/fsl_dma.h **** typedef struct _dma_handle
 155:../drivers/fsl_dma.h **** {
 156:../drivers/fsl_dma.h ****     DMA_Type *base;        /*!< DMA peripheral address. */
 157:../drivers/fsl_dma.h ****     uint8_t channel;       /*!< DMA channel used. */
 158:../drivers/fsl_dma.h ****     dma_callback callback; /*!< DMA callback function.*/
 159:../drivers/fsl_dma.h ****     void *userData;        /*!< Callback parameter. */
 160:../drivers/fsl_dma.h **** } dma_handle_t;
 161:../drivers/fsl_dma.h **** 
 162:../drivers/fsl_dma.h **** /*******************************************************************************
 163:../drivers/fsl_dma.h ****  * API
 164:../drivers/fsl_dma.h ****  ******************************************************************************/
 165:../drivers/fsl_dma.h **** #if defined(__cplusplus)
 166:../drivers/fsl_dma.h **** extern "C" {
 167:../drivers/fsl_dma.h **** #endif /* __cplusplus */
 168:../drivers/fsl_dma.h **** 
 169:../drivers/fsl_dma.h **** /*!
 170:../drivers/fsl_dma.h ****  * @name DMA Initialization and De-initialization
 171:../drivers/fsl_dma.h ****  * @{
 172:../drivers/fsl_dma.h ****  */
 173:../drivers/fsl_dma.h **** 
 174:../drivers/fsl_dma.h **** /*!
 175:../drivers/fsl_dma.h ****  * @brief Initializes the DMA peripheral.
 176:../drivers/fsl_dma.h ****  *
 177:../drivers/fsl_dma.h ****  * This function ungates the DMA clock.
 178:../drivers/fsl_dma.h ****  *
 179:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 180:../drivers/fsl_dma.h ****  */
 181:../drivers/fsl_dma.h **** void DMA_Init(DMA_Type *base);
 182:../drivers/fsl_dma.h **** 
 183:../drivers/fsl_dma.h **** /*!
 184:../drivers/fsl_dma.h ****  * @brief Deinitializes the DMA peripheral.
 185:../drivers/fsl_dma.h ****  *
 186:../drivers/fsl_dma.h ****  * This function gates the DMA clock.
 187:../drivers/fsl_dma.h ****  *
 188:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 189:../drivers/fsl_dma.h ****  */
 190:../drivers/fsl_dma.h **** void DMA_Deinit(DMA_Type *base);
 191:../drivers/fsl_dma.h **** 
 192:../drivers/fsl_dma.h **** /* @} */
 193:../drivers/fsl_dma.h **** /*!
 194:../drivers/fsl_dma.h ****  * @name DMA Channel Operation
 195:../drivers/fsl_dma.h ****  * @{
 196:../drivers/fsl_dma.h ****  */
 197:../drivers/fsl_dma.h **** 
 198:../drivers/fsl_dma.h **** /*!
 199:../drivers/fsl_dma.h ****  * @brief Resets the DMA channel.
 200:../drivers/fsl_dma.h ****  *
 201:../drivers/fsl_dma.h ****  * Sets all register values to reset values and enables
 202:../drivers/fsl_dma.h ****  * the cycle steal and auto stop channel request features.
 203:../drivers/fsl_dma.h ****  *
 204:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 205:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 206:../drivers/fsl_dma.h ****  */
 207:../drivers/fsl_dma.h **** void DMA_ResetChannel(DMA_Type *base, uint32_t channel);
 208:../drivers/fsl_dma.h **** 
 209:../drivers/fsl_dma.h **** /*!
 210:../drivers/fsl_dma.h ****  * @brief Configures the DMA transfer attribute.
 211:../drivers/fsl_dma.h ****  *
 212:../drivers/fsl_dma.h ****  * This function configures the transfer attribute including the source address,
 213:../drivers/fsl_dma.h ****  * destination address, transfer size, and so on.
 214:../drivers/fsl_dma.h ****  * This example shows how to set up the the dma_transfer_config_t
 215:../drivers/fsl_dma.h ****  * parameters and how to call the DMA_ConfigBasicTransfer function.
 216:../drivers/fsl_dma.h ****  * @code
 217:../drivers/fsl_dma.h ****  *   dma_transfer_config_t transferConfig;
 218:../drivers/fsl_dma.h ****  *   memset(&transferConfig, 0, sizeof(transferConfig));
 219:../drivers/fsl_dma.h ****  *   transferConfig.srcAddr = (uint32_t)srcAddr;
 220:../drivers/fsl_dma.h ****  *   transferConfig.destAddr = (uint32_t)destAddr;
 221:../drivers/fsl_dma.h ****  *   transferConfig.enbaleSrcIncrement = true;
 222:../drivers/fsl_dma.h ****  *   transferConfig.enableDestIncrement = true;
 223:../drivers/fsl_dma.h ****  *   transferConfig.srcSize = kDMA_Transfersize32bits;
 224:../drivers/fsl_dma.h ****  *   transferConfig.destSize = kDMA_Transfersize32bits;
 225:../drivers/fsl_dma.h ****  *   transferConfig.transferSize = sizeof(uint32_t) * BUFF_LENGTH;
 226:../drivers/fsl_dma.h ****  *   DMA_SetTransferConfig(DMA0, 0, &transferConfig);
 227:../drivers/fsl_dma.h ****  * @endcode
 228:../drivers/fsl_dma.h ****  *
 229:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 230:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 231:../drivers/fsl_dma.h ****  * @param config Pointer to the DMA transfer configuration structure.
 232:../drivers/fsl_dma.h ****  */
 233:../drivers/fsl_dma.h **** void DMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const dma_transfer_config_t *config);
 234:../drivers/fsl_dma.h **** 
 235:../drivers/fsl_dma.h **** /*!
 236:../drivers/fsl_dma.h ****  * @brief Configures the DMA channel link feature.
 237:../drivers/fsl_dma.h ****  *
 238:../drivers/fsl_dma.h ****  * This function allows DMA channels to have their transfers linked. The current DMA channel
 239:../drivers/fsl_dma.h ****  * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the channel link
 240:../drivers/fsl_dma.h ****  * type.
 241:../drivers/fsl_dma.h ****  * Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2
 242:../drivers/fsl_dma.h ****  * after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1AndChannel2.
 243:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after each cycle-steal transfer if the type is kDMA_ChannelLinkChannel1.
 244:../drivers/fsl_dma.h ****  * Perform a link to LCH1 after the BCR decrements to 0 if the type is kDMA_ChannelLinkChannel1Afte
 245:../drivers/fsl_dma.h ****  *
 246:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 247:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 248:../drivers/fsl_dma.h ****  * @param config Pointer to the channel link configuration structure.
 249:../drivers/fsl_dma.h ****  */
 250:../drivers/fsl_dma.h **** void DMA_SetChannelLinkConfig(DMA_Type *base, uint32_t channel, const dma_channel_link_config_t *co
 251:../drivers/fsl_dma.h **** 
 252:../drivers/fsl_dma.h **** /*!
 253:../drivers/fsl_dma.h ****  * @brief Sets the DMA source address for the DMA transfer.
 254:../drivers/fsl_dma.h ****  *
 255:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 256:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 257:../drivers/fsl_dma.h ****  * @param srcAddr DMA source address.
 258:../drivers/fsl_dma.h ****  */
 259:../drivers/fsl_dma.h **** static inline void DMA_SetSourceAddress(DMA_Type *base, uint32_t channel, uint32_t srcAddr)
 260:../drivers/fsl_dma.h **** {
 261:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 262:../drivers/fsl_dma.h **** 
 263:../drivers/fsl_dma.h ****     base->DMA[channel].SAR = srcAddr;
 264:../drivers/fsl_dma.h **** }
 265:../drivers/fsl_dma.h **** 
 266:../drivers/fsl_dma.h **** /*!
 267:../drivers/fsl_dma.h ****  * @brief Sets the DMA destination address for the DMA transfer.
 268:../drivers/fsl_dma.h ****  *
 269:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 270:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 271:../drivers/fsl_dma.h ****  * @param destAddr DMA destination address.
 272:../drivers/fsl_dma.h ****  */
 273:../drivers/fsl_dma.h **** static inline void DMA_SetDestinationAddress(DMA_Type *base, uint32_t channel, uint32_t destAddr)
 274:../drivers/fsl_dma.h **** {
 275:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 276:../drivers/fsl_dma.h **** 
 277:../drivers/fsl_dma.h ****     base->DMA[channel].DAR = destAddr;
 278:../drivers/fsl_dma.h **** }
 279:../drivers/fsl_dma.h **** 
 280:../drivers/fsl_dma.h **** /*!
 281:../drivers/fsl_dma.h ****  * @brief Sets the DMA transfer size for the DMA transfer.
 282:../drivers/fsl_dma.h ****  *
 283:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 284:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 285:../drivers/fsl_dma.h ****  * @param size The number of bytes to be transferred.
 286:../drivers/fsl_dma.h ****  */
 287:../drivers/fsl_dma.h **** static inline void DMA_SetTransferSize(DMA_Type *base, uint32_t channel, uint32_t size)
 288:../drivers/fsl_dma.h **** {
 289:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 290:../drivers/fsl_dma.h **** 
 291:../drivers/fsl_dma.h ****     base->DMA[channel].DSR_BCR = DMA_DSR_BCR_BCR(size);
 292:../drivers/fsl_dma.h **** }
 293:../drivers/fsl_dma.h **** 
 294:../drivers/fsl_dma.h **** /*!
 295:../drivers/fsl_dma.h ****  * @brief Sets the DMA modulo for the DMA transfer.
 296:../drivers/fsl_dma.h ****  *
 297:../drivers/fsl_dma.h ****  * This function defines a specific address range specified to be the value after (SAR + SSIZE)/(DA
 298:../drivers/fsl_dma.h ****  * calculation is performed or the original register value. It provides the ability to implement a 
 299:../drivers/fsl_dma.h ****  * data queue easily.
 300:../drivers/fsl_dma.h ****  *
 301:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 302:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 303:../drivers/fsl_dma.h ****  * @param srcModulo source address modulo.
 304:../drivers/fsl_dma.h ****  * @param destModulo destination address modulo.
 305:../drivers/fsl_dma.h ****  */
 306:../drivers/fsl_dma.h **** void DMA_SetModulo(DMA_Type *base, uint32_t channel, dma_modulo_t srcModulo, dma_modulo_t destModul
 307:../drivers/fsl_dma.h **** 
 308:../drivers/fsl_dma.h **** /*!
 309:../drivers/fsl_dma.h ****  * @brief Enables the DMA cycle steal for the DMA transfer.
 310:../drivers/fsl_dma.h ****  *
 311:../drivers/fsl_dma.h ****  * If the cycle steal feature is enabled (true), the DMA controller forces a single read/write tran
 312:../drivers/fsl_dma.h ****  *  or it continuously makes read/write transfers until the BCR decrements to 0.
 313:../drivers/fsl_dma.h ****  *
 314:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 315:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 316:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 317:../drivers/fsl_dma.h ****  */
 318:../drivers/fsl_dma.h **** static inline void DMA_EnableCycleSteal(DMA_Type *base, uint32_t channel, bool enable)
 319:../drivers/fsl_dma.h **** {
 320:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 321:../drivers/fsl_dma.h **** 
 322:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_CS_MASK)) | DMA_DCR_CS(enable);
 323:../drivers/fsl_dma.h **** }
 324:../drivers/fsl_dma.h **** 
 325:../drivers/fsl_dma.h **** /*!
 326:../drivers/fsl_dma.h ****  * @brief Enables the DMA auto align for the DMA transfer.
 327:../drivers/fsl_dma.h ****  *
 328:../drivers/fsl_dma.h ****  * If the auto align feature is enabled (true), the appropriate address register increments
 329:../drivers/fsl_dma.h ****  * regardless of DINC or SINC.
 330:../drivers/fsl_dma.h ****  *
 331:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 332:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 333:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 334:../drivers/fsl_dma.h ****  */
 335:../drivers/fsl_dma.h **** static inline void DMA_EnableAutoAlign(DMA_Type *base, uint32_t channel, bool enable)
 336:../drivers/fsl_dma.h **** {
 337:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 338:../drivers/fsl_dma.h **** 
 339:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_AA_MASK)) | DMA_DCR_AA(enable);
 340:../drivers/fsl_dma.h **** }
 341:../drivers/fsl_dma.h **** 
 342:../drivers/fsl_dma.h **** /*!
 343:../drivers/fsl_dma.h ****  * @brief Enables the DMA async request for the DMA transfer.
 344:../drivers/fsl_dma.h ****  *
 345:../drivers/fsl_dma.h ****  * If the async request feature is enabled (true), the DMA supports asynchronous DREQs
 346:../drivers/fsl_dma.h ****  * while the MCU is in stop mode.
 347:../drivers/fsl_dma.h ****  *
 348:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 349:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 350:../drivers/fsl_dma.h ****  * @param enable The command for enable (true) or disable (false).
 351:../drivers/fsl_dma.h ****  */
 352:../drivers/fsl_dma.h **** static inline void DMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
 353:../drivers/fsl_dma.h **** {
 354:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 355:../drivers/fsl_dma.h **** 
 356:../drivers/fsl_dma.h ****     base->DMA[channel].DCR = (base->DMA[channel].DCR & (~DMA_DCR_EADREQ_MASK)) | DMA_DCR_EADREQ(ena
 357:../drivers/fsl_dma.h **** }
 358:../drivers/fsl_dma.h **** 
 359:../drivers/fsl_dma.h **** /*!
 360:../drivers/fsl_dma.h ****  * @brief Enables an interrupt for the DMA transfer.
 361:../drivers/fsl_dma.h ****  *
 362:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 363:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 364:../drivers/fsl_dma.h ****  */
 365:../drivers/fsl_dma.h **** static inline void DMA_EnableInterrupts(DMA_Type *base, uint32_t channel)
 366:../drivers/fsl_dma.h **** {
 367:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 368:../drivers/fsl_dma.h **** 
 369:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_EINT(true);
 370:../drivers/fsl_dma.h **** }
 371:../drivers/fsl_dma.h **** 
 372:../drivers/fsl_dma.h **** /*!
 373:../drivers/fsl_dma.h ****  * @brief Disables an interrupt for the DMA transfer.
 374:../drivers/fsl_dma.h ****  *
 375:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 376:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 377:../drivers/fsl_dma.h ****  */
 378:../drivers/fsl_dma.h **** static inline void DMA_DisableInterrupts(DMA_Type *base, uint32_t channel)
 379:../drivers/fsl_dma.h **** {
 380:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 381:../drivers/fsl_dma.h **** 
 382:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_EINT_MASK;
  66              		.loc 3 382 0
  67 001a 1201     		lsls	r2, r2, #4
  68              	.LVL6:
  69 001c 9B18     		adds	r3, r3, r2
  70              	.LVL7:
  71 001e 0D33     		adds	r3, r3, #13
  72 0020 FF33     		adds	r3, r3, #255
  73 0022 1A68     		ldr	r2, [r3]
  74 0024 5200     		lsls	r2, r2, #1
  75 0026 5208     		lsrs	r2, r2, #1
  76 0028 1A60     		str	r2, [r3]
  77              	.LVL8:
  78              	.LBE37:
  79              	.LBE36:
 153:../drivers/fsl_lpuart_dma.c **** 
 154:../drivers/fsl_lpuart_dma.c ****     lpuartPrivateHandle->handle->txState = kLPUART_TxIdle;
  80              		.loc 1 154 0
  81 002a 0023     		movs	r3, #0
  82 002c 4A68     		ldr	r2, [r1, #4]
  83 002e 1376     		strb	r3, [r2, #24]
 155:../drivers/fsl_lpuart_dma.c **** 
 156:../drivers/fsl_lpuart_dma.c ****     if (lpuartPrivateHandle->handle->callback)
  84              		.loc 1 156 0
  85 0030 4C68     		ldr	r4, [r1, #4]
  86 0032 2568     		ldr	r5, [r4]
  87 0034 002D     		cmp	r5, #0
  88 0036 04D0     		beq	.L1
 157:../drivers/fsl_lpuart_dma.c ****     {
 158:../drivers/fsl_lpuart_dma.c ****         lpuartPrivateHandle->handle->callback(lpuartPrivateHandle->base, lpuartPrivateHandle->handl
  89              		.loc 1 158 0
  90 0038 0868     		ldr	r0, [r1]
  91 003a 6368     		ldr	r3, [r4, #4]
  92 003c 024A     		ldr	r2, .L3+4
  93 003e 2100     		movs	r1, r4
  94              	.LVL9:
  95 0040 A847     		blx	r5
  96              	.LVL10:
  97              	.L1:
 159:../drivers/fsl_lpuart_dma.c ****                                               kStatus_LPUART_TxIdle, lpuartPrivateHandle->handle->u
 160:../drivers/fsl_lpuart_dma.c ****     }
 161:../drivers/fsl_lpuart_dma.c **** }
  98              		.loc 1 161 0
  99              		@ sp needed
 100 0042 70BD     		pop	{r4, r5, r6, pc}
 101              	.L4:
 102              		.align	2
 103              	.L3:
 104 0044 FFFF7FFF 		.word	-8388609
 105 0048 16050000 		.word	1302
 106              		.cfi_endproc
 107              	.LFE76:
 109              		.section	.text.LPUART_TransferReceiveDMACallback,"ax",%progbits
 110              		.align	1
 111              		.syntax unified
 112              		.code	16
 113              		.thumb_func
 114              		.fpu softvfp
 116              	LPUART_TransferReceiveDMACallback:
 117              	.LFB77:
 162:../drivers/fsl_lpuart_dma.c **** 
 163:../drivers/fsl_lpuart_dma.c **** static void LPUART_TransferReceiveDMACallback(dma_handle_t *handle, void *param)
 164:../drivers/fsl_lpuart_dma.c **** {
 118              		.loc 1 164 0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 0
 121              		@ frame_needed = 0, uses_anonymous_args = 0
 122              	.LVL11:
 123 0000 70B5     		push	{r4, r5, r6, lr}
 124              		.cfi_def_cfa_offset 16
 125              		.cfi_offset 4, -16
 126              		.cfi_offset 5, -12
 127              		.cfi_offset 6, -8
 128              		.cfi_offset 14, -4
 129              	.LVL12:
 165:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 166:../drivers/fsl_lpuart_dma.c ****     assert(param);
 167:../drivers/fsl_lpuart_dma.c **** 
 168:../drivers/fsl_lpuart_dma.c ****     lpuart_dma_private_handle_t *lpuartPrivateHandle = (lpuart_dma_private_handle_t *)param;
 169:../drivers/fsl_lpuart_dma.c **** 
 170:../drivers/fsl_lpuart_dma.c ****     /* Disable LPUART RX DMA. */
 171:../drivers/fsl_lpuart_dma.c ****     LPUART_EnableRxDMA(lpuartPrivateHandle->base, false);
 130              		.loc 1 171 0
 131 0002 0B68     		ldr	r3, [r1]
 132              	.LVL13:
 133              	.LBB38:
 134              	.LBB39:
 526:../drivers/fsl_lpuart.h ****     }
 527:../drivers/fsl_lpuart.h **** }
 528:../drivers/fsl_lpuart.h **** 
 529:../drivers/fsl_lpuart.h **** /*!
 530:../drivers/fsl_lpuart.h ****  * @brief Enables or disables the LPUART receiver DMA.
 531:../drivers/fsl_lpuart.h ****  *
 532:../drivers/fsl_lpuart.h ****  * This function enables or disables the receiver data register full flag, STAT[RDRF], to generate 
 533:../drivers/fsl_lpuart.h ****  *
 534:../drivers/fsl_lpuart.h ****  * @param base LPUART peripheral base address.
 535:../drivers/fsl_lpuart.h ****  * @param enable True to enable, false to disable.
 536:../drivers/fsl_lpuart.h ****  */
 537:../drivers/fsl_lpuart.h **** static inline void LPUART_EnableRxDMA(LPUART_Type *base, bool enable)
 538:../drivers/fsl_lpuart.h **** {
 539:../drivers/fsl_lpuart.h ****     if (enable)
 540:../drivers/fsl_lpuart.h ****     {
 541:../drivers/fsl_lpuart.h ****         base->BAUD |= LPUART_BAUD_RDMAE_MASK;
 542:../drivers/fsl_lpuart.h ****         base->CTRL |= LPUART_CTRL_RIE_MASK;
 543:../drivers/fsl_lpuart.h ****     }
 544:../drivers/fsl_lpuart.h ****     else
 545:../drivers/fsl_lpuart.h ****     {
 546:../drivers/fsl_lpuart.h ****         base->BAUD &= ~LPUART_BAUD_RDMAE_MASK;
 135              		.loc 2 546 0
 136 0004 1868     		ldr	r0, [r3]
 137              	.LVL14:
 138 0006 0F4C     		ldr	r4, .L7
 139 0008 2040     		ands	r0, r4
 140 000a 1860     		str	r0, [r3]
 547:../drivers/fsl_lpuart.h ****         base->CTRL &= ~LPUART_CTRL_RIE_MASK;
 141              		.loc 2 547 0
 142 000c 9A68     		ldr	r2, [r3, #8]
 143 000e 2240     		ands	r2, r4
 144 0010 9A60     		str	r2, [r3, #8]
 145              	.LVL15:
 146              	.LBE39:
 147              	.LBE38:
 172:../drivers/fsl_lpuart_dma.c **** 
 173:../drivers/fsl_lpuart_dma.c ****     /* Disable interrupt. */
 174:../drivers/fsl_lpuart_dma.c ****     DMA_DisableInterrupts(lpuartPrivateHandle->handle->rxDmaHandle->base,
 148              		.loc 1 174 0
 149 0012 4B68     		ldr	r3, [r1, #4]
 150 0014 5A69     		ldr	r2, [r3, #20]
 151 0016 1368     		ldr	r3, [r2]
 175:../drivers/fsl_lpuart_dma.c ****                           lpuartPrivateHandle->handle->rxDmaHandle->channel);
 152              		.loc 1 175 0
 153 0018 1279     		ldrb	r2, [r2, #4]
 154              	.LVL16:
 155              	.LBB40:
 156              	.LBB41:
 157              		.loc 3 382 0
 158 001a 1201     		lsls	r2, r2, #4
 159              	.LVL17:
 160 001c 9B18     		adds	r3, r3, r2
 161              	.LVL18:
 162 001e 0D33     		adds	r3, r3, #13
 163 0020 FF33     		adds	r3, r3, #255
 164 0022 1A68     		ldr	r2, [r3]
 165 0024 5200     		lsls	r2, r2, #1
 166 0026 5208     		lsrs	r2, r2, #1
 167 0028 1A60     		str	r2, [r3]
 168              	.LVL19:
 169              	.LBE41:
 170              	.LBE40:
 176:../drivers/fsl_lpuart_dma.c **** 
 177:../drivers/fsl_lpuart_dma.c ****     lpuartPrivateHandle->handle->rxState = kLPUART_RxIdle;
 171              		.loc 1 177 0
 172 002a 0223     		movs	r3, #2
 173 002c 4A68     		ldr	r2, [r1, #4]
 174 002e 5376     		strb	r3, [r2, #25]
 178:../drivers/fsl_lpuart_dma.c **** 
 179:../drivers/fsl_lpuart_dma.c ****     if (lpuartPrivateHandle->handle->callback)
 175              		.loc 1 179 0
 176 0030 4C68     		ldr	r4, [r1, #4]
 177 0032 2568     		ldr	r5, [r4]
 178 0034 002D     		cmp	r5, #0
 179 0036 04D0     		beq	.L5
 180:../drivers/fsl_lpuart_dma.c ****     {
 181:../drivers/fsl_lpuart_dma.c ****         lpuartPrivateHandle->handle->callback(lpuartPrivateHandle->base, lpuartPrivateHandle->handl
 180              		.loc 1 181 0
 181 0038 0868     		ldr	r0, [r1]
 182 003a 6368     		ldr	r3, [r4, #4]
 183 003c 024A     		ldr	r2, .L7+4
 184 003e 2100     		movs	r1, r4
 185              	.LVL20:
 186 0040 A847     		blx	r5
 187              	.LVL21:
 188              	.L5:
 182:../drivers/fsl_lpuart_dma.c ****                                               kStatus_LPUART_RxIdle, lpuartPrivateHandle->handle->u
 183:../drivers/fsl_lpuart_dma.c ****     }
 184:../drivers/fsl_lpuart_dma.c **** }
 189              		.loc 1 184 0
 190              		@ sp needed
 191 0042 70BD     		pop	{r4, r5, r6, pc}
 192              	.L8:
 193              		.align	2
 194              	.L7:
 195 0044 FFFFDFFF 		.word	-2097153
 196 0048 17050000 		.word	1303
 197              		.cfi_endproc
 198              	.LFE77:
 200              		.section	.text.LPUART_TransferCreateHandleDMA,"ax",%progbits
 201              		.align	1
 202              		.global	LPUART_TransferCreateHandleDMA
 203              		.syntax unified
 204              		.code	16
 205              		.thumb_func
 206              		.fpu softvfp
 208              	LPUART_TransferCreateHandleDMA:
 209              	.LFB78:
 185:../drivers/fsl_lpuart_dma.c **** 
 186:../drivers/fsl_lpuart_dma.c **** void LPUART_TransferCreateHandleDMA(LPUART_Type *base,
 187:../drivers/fsl_lpuart_dma.c ****                                     lpuart_dma_handle_t *handle,
 188:../drivers/fsl_lpuart_dma.c ****                                     lpuart_dma_transfer_callback_t callback,
 189:../drivers/fsl_lpuart_dma.c ****                                     void *userData,
 190:../drivers/fsl_lpuart_dma.c ****                                     dma_handle_t *txDmaHandle,
 191:../drivers/fsl_lpuart_dma.c ****                                     dma_handle_t *rxDmaHandle)
 192:../drivers/fsl_lpuart_dma.c **** {
 210              		.loc 1 192 0
 211              		.cfi_startproc
 212              		@ args = 8, pretend = 0, frame = 0
 213              		@ frame_needed = 0, uses_anonymous_args = 0
 214              	.LVL22:
 215 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 216              		.cfi_def_cfa_offset 20
 217              		.cfi_offset 4, -20
 218              		.cfi_offset 5, -16
 219              		.cfi_offset 6, -12
 220              		.cfi_offset 7, -8
 221              		.cfi_offset 14, -4
 222 0002 D646     		mov	lr, r10
 223 0004 00B5     		push	{lr}
 224              		.cfi_def_cfa_offset 24
 225              		.cfi_offset 10, -24
 226 0006 0700     		movs	r7, r0
 227 0008 0C00     		movs	r4, r1
 228 000a 9246     		mov	r10, r2
 229 000c 1D00     		movs	r5, r3
 193:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 194:../drivers/fsl_lpuart_dma.c **** 
 195:../drivers/fsl_lpuart_dma.c ****     uint32_t instance = LPUART_GetInstance(base);
 230              		.loc 1 195 0
 231 000e FFF7FEFF 		bl	LPUART_GetInstance
 232              	.LVL23:
 233 0012 0600     		movs	r6, r0
 234              	.LVL24:
 196:../drivers/fsl_lpuart_dma.c **** 
 197:../drivers/fsl_lpuart_dma.c ****     memset(handle, 0, sizeof(lpuart_dma_handle_t));
 235              		.loc 1 197 0
 236 0014 2000     		movs	r0, r4
 237              	.LVL25:
 238 0016 0830     		adds	r0, r0, #8
 239 0018 1422     		movs	r2, #20
 240 001a 0021     		movs	r1, #0
 241 001c FFF7FEFF 		bl	memset
 242              	.LVL26:
 198:../drivers/fsl_lpuart_dma.c **** 
 199:../drivers/fsl_lpuart_dma.c ****     s_dmaPrivateHandle[instance].base = base;
 243              		.loc 1 199 0
 244 0020 124B     		ldr	r3, .L12
 245 0022 F200     		lsls	r2, r6, #3
 246 0024 D750     		str	r7, [r2, r3]
 200:../drivers/fsl_lpuart_dma.c ****     s_dmaPrivateHandle[instance].handle = handle;
 247              		.loc 1 200 0
 248 0026 9B18     		adds	r3, r3, r2
 249 0028 5C60     		str	r4, [r3, #4]
 201:../drivers/fsl_lpuart_dma.c **** 
 202:../drivers/fsl_lpuart_dma.c ****     handle->rxState = kLPUART_RxIdle;
 250              		.loc 1 202 0
 251 002a 0223     		movs	r3, #2
 252 002c 6376     		strb	r3, [r4, #25]
 203:../drivers/fsl_lpuart_dma.c ****     handle->txState = kLPUART_TxIdle;
 253              		.loc 1 203 0
 254 002e 0023     		movs	r3, #0
 255 0030 2376     		strb	r3, [r4, #24]
 204:../drivers/fsl_lpuart_dma.c **** 
 205:../drivers/fsl_lpuart_dma.c ****     handle->callback = callback;
 256              		.loc 1 205 0
 257 0032 5346     		mov	r3, r10
 258 0034 2360     		str	r3, [r4]
 206:../drivers/fsl_lpuart_dma.c ****     handle->userData = userData;
 259              		.loc 1 206 0
 260 0036 6560     		str	r5, [r4, #4]
 207:../drivers/fsl_lpuart_dma.c **** 
 208:../drivers/fsl_lpuart_dma.c **** #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
 209:../drivers/fsl_lpuart_dma.c ****     /* Note:
 210:../drivers/fsl_lpuart_dma.c ****        Take care of the RX FIFO, DMA request only assert when received bytes
 211:../drivers/fsl_lpuart_dma.c ****        equal or more than RX water mark, there is potential issue if RX water
 212:../drivers/fsl_lpuart_dma.c ****        mark larger than 1.
 213:../drivers/fsl_lpuart_dma.c ****        For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
 214:../drivers/fsl_lpuart_dma.c ****        5 bytes are received. the last byte will be saved in FIFO but not trigger
 215:../drivers/fsl_lpuart_dma.c ****        DMA transfer because the water mark is 2.
 216:../drivers/fsl_lpuart_dma.c ****      */
 217:../drivers/fsl_lpuart_dma.c ****     if (rxDmaHandle)
 218:../drivers/fsl_lpuart_dma.c ****     {
 219:../drivers/fsl_lpuart_dma.c ****         base->WATER &= (~LPUART_WATER_RXWATER_MASK);
 220:../drivers/fsl_lpuart_dma.c ****     }
 221:../drivers/fsl_lpuart_dma.c **** #endif
 222:../drivers/fsl_lpuart_dma.c **** 
 223:../drivers/fsl_lpuart_dma.c ****     handle->rxDmaHandle = rxDmaHandle;
 261              		.loc 1 223 0
 262 0038 079B     		ldr	r3, [sp, #28]
 263 003a 6361     		str	r3, [r4, #20]
 224:../drivers/fsl_lpuart_dma.c ****     handle->txDmaHandle = txDmaHandle;
 264              		.loc 1 224 0
 265 003c 069B     		ldr	r3, [sp, #24]
 266 003e 2361     		str	r3, [r4, #16]
 225:../drivers/fsl_lpuart_dma.c **** 
 226:../drivers/fsl_lpuart_dma.c ****     /* Configure TX. */
 227:../drivers/fsl_lpuart_dma.c ****     if (txDmaHandle)
 267              		.loc 1 227 0
 268 0040 002B     		cmp	r3, #0
 269 0042 06D0     		beq	.L10
 228:../drivers/fsl_lpuart_dma.c ****     {
 229:../drivers/fsl_lpuart_dma.c ****         DMA_SetCallback(txDmaHandle, LPUART_TransferSendDMACallback, &s_dmaPrivateHandle[instance])
 270              		.loc 1 229 0
 271 0044 1300     		movs	r3, r2
 272 0046 094A     		ldr	r2, .L12
 273 0048 D218     		adds	r2, r2, r3
 274 004a 0949     		ldr	r1, .L12+4
 275 004c 0698     		ldr	r0, [sp, #24]
 276 004e FFF7FEFF 		bl	DMA_SetCallback
 277              	.LVL27:
 278              	.L10:
 230:../drivers/fsl_lpuart_dma.c ****     }
 231:../drivers/fsl_lpuart_dma.c **** 
 232:../drivers/fsl_lpuart_dma.c ****     /* Configure RX. */
 233:../drivers/fsl_lpuart_dma.c ****     if (rxDmaHandle)
 279              		.loc 1 233 0
 280 0052 079B     		ldr	r3, [sp, #28]
 281 0054 002B     		cmp	r3, #0
 282 0056 06D0     		beq	.L9
 234:../drivers/fsl_lpuart_dma.c ****     {
 235:../drivers/fsl_lpuart_dma.c ****         DMA_SetCallback(rxDmaHandle, LPUART_TransferReceiveDMACallback, &s_dmaPrivateHandle[instanc
 283              		.loc 1 235 0
 284 0058 F200     		lsls	r2, r6, #3
 285 005a 044B     		ldr	r3, .L12
 286 005c 9A18     		adds	r2, r3, r2
 287 005e 0549     		ldr	r1, .L12+8
 288 0060 0798     		ldr	r0, [sp, #28]
 289 0062 FFF7FEFF 		bl	DMA_SetCallback
 290              	.LVL28:
 291              	.L9:
 236:../drivers/fsl_lpuart_dma.c ****     }
 237:../drivers/fsl_lpuart_dma.c **** }
 292              		.loc 1 237 0
 293              		@ sp needed
 294              	.LVL29:
 295              	.LVL30:
 296              	.LVL31:
 297              	.LVL32:
 298              	.LVL33:
 299 0066 04BC     		pop	{r2}
 300 0068 9246     		mov	r10, r2
 301 006a F0BD     		pop	{r4, r5, r6, r7, pc}
 302              	.L13:
 303              		.align	2
 304              	.L12:
 305 006c 00000000 		.word	.LANCHOR0
 306 0070 00000000 		.word	LPUART_TransferSendDMACallback
 307 0074 00000000 		.word	LPUART_TransferReceiveDMACallback
 308              		.cfi_endproc
 309              	.LFE78:
 311              		.section	.text.LPUART_TransferSendDMA,"ax",%progbits
 312              		.align	1
 313              		.global	LPUART_TransferSendDMA
 314              		.syntax unified
 315              		.code	16
 316              		.thumb_func
 317              		.fpu softvfp
 319              	LPUART_TransferSendDMA:
 320              	.LFB79:
 238:../drivers/fsl_lpuart_dma.c **** 
 239:../drivers/fsl_lpuart_dma.c **** status_t LPUART_TransferSendDMA(LPUART_Type *base, lpuart_dma_handle_t *handle, lpuart_transfer_t *
 240:../drivers/fsl_lpuart_dma.c **** {
 321              		.loc 1 240 0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 16
 324              		@ frame_needed = 0, uses_anonymous_args = 0
 325              	.LVL34:
 326 0000 30B5     		push	{r4, r5, lr}
 327              		.cfi_def_cfa_offset 12
 328              		.cfi_offset 4, -12
 329              		.cfi_offset 5, -8
 330              		.cfi_offset 14, -4
 331 0002 89B0     		sub	sp, sp, #36
 332              		.cfi_def_cfa_offset 48
 333 0004 0500     		movs	r5, r0
 334 0006 0C00     		movs	r4, r1
 241:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 242:../drivers/fsl_lpuart_dma.c ****     assert(handle->txDmaHandle);
 243:../drivers/fsl_lpuart_dma.c ****     assert(xfer);
 244:../drivers/fsl_lpuart_dma.c ****     assert(xfer->data);
 245:../drivers/fsl_lpuart_dma.c ****     assert(xfer->dataSize);
 246:../drivers/fsl_lpuart_dma.c **** 
 247:../drivers/fsl_lpuart_dma.c ****     status_t status;
 248:../drivers/fsl_lpuart_dma.c ****     dma_transfer_config_t xferConfig;
 249:../drivers/fsl_lpuart_dma.c **** 
 250:../drivers/fsl_lpuart_dma.c ****     /* If previous TX not finished. */
 251:../drivers/fsl_lpuart_dma.c ****     if (kLPUART_TxBusy == handle->txState)
 335              		.loc 1 251 0
 336 0008 0B7E     		ldrb	r3, [r1, #24]
 337 000a 012B     		cmp	r3, #1
 338 000c 2BD0     		beq	.L16
 252:../drivers/fsl_lpuart_dma.c ****     {
 253:../drivers/fsl_lpuart_dma.c ****         status = kStatus_LPUART_TxBusy;
 254:../drivers/fsl_lpuart_dma.c ****     }
 255:../drivers/fsl_lpuart_dma.c ****     else
 256:../drivers/fsl_lpuart_dma.c ****     {
 257:../drivers/fsl_lpuart_dma.c ****         handle->txState = kLPUART_TxBusy;
 339              		.loc 1 257 0
 340 000e 0120     		movs	r0, #1
 341              	.LVL35:
 342 0010 0876     		strb	r0, [r1, #24]
 258:../drivers/fsl_lpuart_dma.c ****         handle->txDataSizeAll = xfer->dataSize;
 343              		.loc 1 258 0
 344 0012 5368     		ldr	r3, [r2, #4]
 345 0014 CB60     		str	r3, [r1, #12]
 259:../drivers/fsl_lpuart_dma.c **** 
 260:../drivers/fsl_lpuart_dma.c ****         /* Prepare transfer. */
 261:../drivers/fsl_lpuart_dma.c ****         DMA_PrepareTransfer(&xferConfig, xfer->data, sizeof(uint8_t), (void *)LPUART_GetDataRegiste
 346              		.loc 1 261 0
 347 0016 1168     		ldr	r1, [r2]
 348              	.LVL36:
 349              	.LBB42:
 350              	.LBB43:
 504:../drivers/fsl_lpuart.h **** }
 351              		.loc 2 504 0
 352 0018 2B00     		movs	r3, r5
 353 001a 0C33     		adds	r3, r3, #12
 354              	.LVL37:
 355              	.LBE43:
 356              	.LBE42:
 262:../drivers/fsl_lpuart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_MemoryToPeripheral);
 357              		.loc 1 262 0
 358 001c 5268     		ldr	r2, [r2, #4]
 359              	.LVL38:
 360 001e 0192     		str	r2, [sp, #4]
 261:../drivers/fsl_lpuart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_MemoryToPeripheral);
 361              		.loc 1 261 0
 362 0020 0222     		movs	r2, #2
 363 0022 0292     		str	r2, [sp, #8]
 364 0024 0090     		str	r0, [sp]
 365 0026 013A     		subs	r2, r2, #1
 366 0028 04A8     		add	r0, sp, #16
 367 002a FFF7FEFF 		bl	DMA_PrepareTransfer
 368              	.LVL39:
 263:../drivers/fsl_lpuart_dma.c **** 
 264:../drivers/fsl_lpuart_dma.c ****         /* Submit transfer. */
 265:../drivers/fsl_lpuart_dma.c ****         DMA_SubmitTransfer(handle->txDmaHandle, &xferConfig, kDMA_EnableInterrupt);
 369              		.loc 1 265 0
 370 002e 0122     		movs	r2, #1
 371 0030 04A9     		add	r1, sp, #16
 372 0032 2069     		ldr	r0, [r4, #16]
 373 0034 FFF7FEFF 		bl	DMA_SubmitTransfer
 374              	.LVL40:
 266:../drivers/fsl_lpuart_dma.c ****         DMA_StartTransfer(handle->txDmaHandle);
 375              		.loc 1 266 0
 376 0038 2269     		ldr	r2, [r4, #16]
 377              	.LVL41:
 378              	.LBB44:
 379              	.LBB45:
 383:../drivers/fsl_dma.h **** }
 384:../drivers/fsl_dma.h **** 
 385:../drivers/fsl_dma.h **** /* @} */
 386:../drivers/fsl_dma.h **** /*!
 387:../drivers/fsl_dma.h ****  * @name DMA Channel Transfer Operation
 388:../drivers/fsl_dma.h ****  * @{
 389:../drivers/fsl_dma.h ****  */
 390:../drivers/fsl_dma.h **** 
 391:../drivers/fsl_dma.h **** /*!
 392:../drivers/fsl_dma.h ****  * @brief Enables the DMA hardware channel request.
 393:../drivers/fsl_dma.h ****  *
 394:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 395:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 396:../drivers/fsl_dma.h ****  */
 397:../drivers/fsl_dma.h **** static inline void DMA_EnableChannelRequest(DMA_Type *base, uint32_t channel)
 398:../drivers/fsl_dma.h **** {
 399:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 400:../drivers/fsl_dma.h **** 
 401:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_ERQ_MASK;
 402:../drivers/fsl_dma.h **** }
 403:../drivers/fsl_dma.h **** 
 404:../drivers/fsl_dma.h **** /*!
 405:../drivers/fsl_dma.h ****  * @brief Disables the DMA hardware channel request.
 406:../drivers/fsl_dma.h ****  *
 407:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 408:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 409:../drivers/fsl_dma.h ****  */
 410:../drivers/fsl_dma.h **** static inline void DMA_DisableChannelRequest(DMA_Type *base, uint32_t channel)
 411:../drivers/fsl_dma.h **** {
 412:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 413:../drivers/fsl_dma.h **** 
 414:../drivers/fsl_dma.h ****     base->DMA[channel].DCR &= ~DMA_DCR_ERQ_MASK;
 415:../drivers/fsl_dma.h **** }
 416:../drivers/fsl_dma.h **** 
 417:../drivers/fsl_dma.h **** /*!
 418:../drivers/fsl_dma.h ****  * @brief Starts the DMA transfer with a software trigger.
 419:../drivers/fsl_dma.h ****  *
 420:../drivers/fsl_dma.h ****  * This function starts only one read/write iteration.
 421:../drivers/fsl_dma.h ****  *
 422:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 423:../drivers/fsl_dma.h ****  * @param channel The DMA channel number.
 424:../drivers/fsl_dma.h ****  */
 425:../drivers/fsl_dma.h **** static inline void DMA_TriggerChannelStart(DMA_Type *base, uint32_t channel)
 426:../drivers/fsl_dma.h **** {
 427:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 428:../drivers/fsl_dma.h **** 
 429:../drivers/fsl_dma.h ****     base->DMA[channel].DCR |= DMA_DCR_START_MASK;
 430:../drivers/fsl_dma.h **** }
 431:../drivers/fsl_dma.h **** 
 432:../drivers/fsl_dma.h **** /* @} */
 433:../drivers/fsl_dma.h **** /*!
 434:../drivers/fsl_dma.h ****  * @name DMA Channel Status Operation
 435:../drivers/fsl_dma.h ****  * @{
 436:../drivers/fsl_dma.h ****  */
 437:../drivers/fsl_dma.h **** 
 438:../drivers/fsl_dma.h **** /*!
 439:../drivers/fsl_dma.h ****  * @brief Gets the remaining bytes of the current DMA transfer.
 440:../drivers/fsl_dma.h ****  *
 441:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 442:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 443:../drivers/fsl_dma.h ****  * @return The number of bytes which have not been transferred yet.
 444:../drivers/fsl_dma.h ****  */
 445:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetRemainingBytes(DMA_Type *base, uint32_t channel)
 446:../drivers/fsl_dma.h **** {
 447:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 448:../drivers/fsl_dma.h **** 
 449:../drivers/fsl_dma.h ****     return (base->DMA[channel].DSR_BCR & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT;
 450:../drivers/fsl_dma.h **** }
 451:../drivers/fsl_dma.h **** 
 452:../drivers/fsl_dma.h **** /*!
 453:../drivers/fsl_dma.h ****  * @brief Gets the DMA channel status flags.
 454:../drivers/fsl_dma.h ****  *
 455:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 456:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 457:../drivers/fsl_dma.h ****  * @return The mask of the channel status. Use the _dma_channel_status_flags
 458:../drivers/fsl_dma.h ****  *         type to decode the return 32 bit variables.
 459:../drivers/fsl_dma.h ****  */
 460:../drivers/fsl_dma.h **** static inline uint32_t DMA_GetChannelStatusFlags(DMA_Type *base, uint32_t channel)
 461:../drivers/fsl_dma.h **** {
 462:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 463:../drivers/fsl_dma.h **** 
 464:../drivers/fsl_dma.h ****     return base->DMA[channel].DSR_BCR;
 465:../drivers/fsl_dma.h **** }
 466:../drivers/fsl_dma.h **** 
 467:../drivers/fsl_dma.h **** /*!
 468:../drivers/fsl_dma.h ****  * @brief Clears the DMA channel status flags.
 469:../drivers/fsl_dma.h ****  *
 470:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 471:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 472:../drivers/fsl_dma.h ****  * @param mask The mask of the channel status to be cleared. Use
 473:../drivers/fsl_dma.h ****  *             the defined _dma_channel_status_flags type.
 474:../drivers/fsl_dma.h ****  */
 475:../drivers/fsl_dma.h **** static inline void DMA_ClearChannelStatusFlags(DMA_Type *base, uint32_t channel, uint32_t mask)
 476:../drivers/fsl_dma.h **** {
 477:../drivers/fsl_dma.h ****     assert(channel < FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
 478:../drivers/fsl_dma.h **** 
 479:../drivers/fsl_dma.h ****     if (mask != 0U)
 480:../drivers/fsl_dma.h ****     {
 481:../drivers/fsl_dma.h ****         base->DMA[channel].DSR_BCR |= DMA_DSR_BCR_DONE(true);
 482:../drivers/fsl_dma.h ****     }
 483:../drivers/fsl_dma.h **** }
 484:../drivers/fsl_dma.h **** 
 485:../drivers/fsl_dma.h **** /* @} */
 486:../drivers/fsl_dma.h **** /*!
 487:../drivers/fsl_dma.h ****  * @name DMA Channel Transactional Operation
 488:../drivers/fsl_dma.h ****  * @{
 489:../drivers/fsl_dma.h ****  */
 490:../drivers/fsl_dma.h **** 
 491:../drivers/fsl_dma.h **** /*!
 492:../drivers/fsl_dma.h ****  * @brief Creates the DMA handle.
 493:../drivers/fsl_dma.h ****  *
 494:../drivers/fsl_dma.h ****  * This function is called first if using the transactional API for the DMA. This function
 495:../drivers/fsl_dma.h ****  * initializes the internal state of the DMA handle.
 496:../drivers/fsl_dma.h ****  *
 497:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer. The DMA handle stores callback function and
 498:../drivers/fsl_dma.h ****  *               parameters.
 499:../drivers/fsl_dma.h ****  * @param base DMA peripheral base address.
 500:../drivers/fsl_dma.h ****  * @param channel DMA channel number.
 501:../drivers/fsl_dma.h ****  */
 502:../drivers/fsl_dma.h **** void DMA_CreateHandle(dma_handle_t *handle, DMA_Type *base, uint32_t channel);
 503:../drivers/fsl_dma.h **** 
 504:../drivers/fsl_dma.h **** /*!
 505:../drivers/fsl_dma.h ****  * @brief Sets the DMA callback function.
 506:../drivers/fsl_dma.h ****  *
 507:../drivers/fsl_dma.h ****  * This callback is called in the DMA IRQ handler. Use the callback to do something
 508:../drivers/fsl_dma.h ****  * after the current transfer complete.
 509:../drivers/fsl_dma.h ****  *
 510:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 511:../drivers/fsl_dma.h ****  * @param callback DMA callback function pointer.
 512:../drivers/fsl_dma.h ****  * @param userData Parameter for callback function. If it is not needed, just set to NULL.
 513:../drivers/fsl_dma.h ****  */
 514:../drivers/fsl_dma.h **** void DMA_SetCallback(dma_handle_t *handle, dma_callback callback, void *userData);
 515:../drivers/fsl_dma.h **** 
 516:../drivers/fsl_dma.h **** /*!
 517:../drivers/fsl_dma.h ****  * @brief Prepares the DMA transfer configuration structure.
 518:../drivers/fsl_dma.h ****  *
 519:../drivers/fsl_dma.h ****  * This function prepares the transfer configuration structure according to the user input.
 520:../drivers/fsl_dma.h ****  *
 521:../drivers/fsl_dma.h ****  * @param config Pointer to the user configuration structure of type dma_transfer_config_t.
 522:../drivers/fsl_dma.h ****  * @param srcAddr DMA transfer source address.
 523:../drivers/fsl_dma.h ****  * @param srcWidth DMA transfer source address width (byte).
 524:../drivers/fsl_dma.h ****  * @param destAddr DMA transfer destination address.
 525:../drivers/fsl_dma.h ****  * @param destWidth DMA transfer destination address width (byte).
 526:../drivers/fsl_dma.h ****  * @param transferBytes DMA transfer bytes to be transferred.
 527:../drivers/fsl_dma.h ****  * @param type DMA transfer type.
 528:../drivers/fsl_dma.h ****  */
 529:../drivers/fsl_dma.h **** void DMA_PrepareTransfer(dma_transfer_config_t *config,
 530:../drivers/fsl_dma.h ****                          void *srcAddr,
 531:../drivers/fsl_dma.h ****                          uint32_t srcWidth,
 532:../drivers/fsl_dma.h ****                          void *destAddr,
 533:../drivers/fsl_dma.h ****                          uint32_t destWidth,
 534:../drivers/fsl_dma.h ****                          uint32_t transferBytes,
 535:../drivers/fsl_dma.h ****                          dma_transfer_type_t type);
 536:../drivers/fsl_dma.h **** 
 537:../drivers/fsl_dma.h **** /*!
 538:../drivers/fsl_dma.h ****  * @brief Submits the DMA transfer request.
 539:../drivers/fsl_dma.h ****  *
 540:../drivers/fsl_dma.h ****  * This function submits the DMA transfer request according to the transfer configuration structure
 541:../drivers/fsl_dma.h ****  *
 542:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 543:../drivers/fsl_dma.h ****  * @param config Pointer to DMA transfer configuration structure.
 544:../drivers/fsl_dma.h ****  * @param options Additional configurations for transfer. Use
 545:../drivers/fsl_dma.h ****  *                the defined dma_transfer_options_t type.
 546:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA submit transfer request succeeded.
 547:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA is busy. Submit transfer request is not allow
 548:../drivers/fsl_dma.h ****  * @note This function can't process multi transfer request.
 549:../drivers/fsl_dma.h ****  */
 550:../drivers/fsl_dma.h **** status_t DMA_SubmitTransfer(dma_handle_t *handle, const dma_transfer_config_t *config, uint32_t opt
 551:../drivers/fsl_dma.h **** 
 552:../drivers/fsl_dma.h **** /*!
 553:../drivers/fsl_dma.h ****  * @brief DMA starts a transfer.
 554:../drivers/fsl_dma.h ****  *
 555:../drivers/fsl_dma.h ****  * This function enables the channel request. Call this function
 556:../drivers/fsl_dma.h ****  * after submitting a transfer request.
 557:../drivers/fsl_dma.h ****  *
 558:../drivers/fsl_dma.h ****  * @param handle DMA handle pointer.
 559:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Success It indicates that the DMA start transfer succeed.
 560:../drivers/fsl_dma.h ****  * @retval kStatus_DMA_Busy It indicates that the DMA has started a transfer.
 561:../drivers/fsl_dma.h ****  */
 562:../drivers/fsl_dma.h **** static inline void DMA_StartTransfer(dma_handle_t *handle)
 563:../drivers/fsl_dma.h **** {
 564:../drivers/fsl_dma.h ****     assert(handle != NULL);
 565:../drivers/fsl_dma.h **** 
 566:../drivers/fsl_dma.h ****     handle->base->DMA[handle->channel].DCR |= DMA_DCR_ERQ_MASK;
 380              		.loc 3 566 0
 381 003a 1368     		ldr	r3, [r2]
 382 003c 1279     		ldrb	r2, [r2, #4]
 383              	.LVL42:
 384 003e 1201     		lsls	r2, r2, #4
 385 0040 9B18     		adds	r3, r3, r2
 386 0042 0D33     		adds	r3, r3, #13
 387 0044 FF33     		adds	r3, r3, #255
 388 0046 1968     		ldr	r1, [r3]
 389 0048 8022     		movs	r2, #128
 390 004a D205     		lsls	r2, r2, #23
 391 004c 0A43     		orrs	r2, r1
 392 004e 1A60     		str	r2, [r3]
 393              	.LVL43:
 394              	.LBE45:
 395              	.LBE44:
 396              	.LBB46:
 397              	.LBB47:
 519:../drivers/fsl_lpuart.h ****         base->CTRL |= LPUART_CTRL_TIE_MASK;
 398              		.loc 2 519 0
 399 0050 2A68     		ldr	r2, [r5]
 400 0052 8023     		movs	r3, #128
 401 0054 1B04     		lsls	r3, r3, #16
 402 0056 1A43     		orrs	r2, r3
 403 0058 2A60     		str	r2, [r5]
 520:../drivers/fsl_lpuart.h ****     }
 404              		.loc 2 520 0
 405 005a AA68     		ldr	r2, [r5, #8]
 406 005c 1343     		orrs	r3, r2
 407 005e AB60     		str	r3, [r5, #8]
 408              	.LVL44:
 409              	.LBE47:
 410              	.LBE46:
 267:../drivers/fsl_lpuart_dma.c **** 
 268:../drivers/fsl_lpuart_dma.c ****         /* Enable LPUART TX DMA. */
 269:../drivers/fsl_lpuart_dma.c ****         LPUART_EnableTxDMA(base, true);
 270:../drivers/fsl_lpuart_dma.c **** 
 271:../drivers/fsl_lpuart_dma.c ****         status = kStatus_Success;
 411              		.loc 1 271 0
 412 0060 0020     		movs	r0, #0
 413              	.LVL45:
 414              	.L14:
 272:../drivers/fsl_lpuart_dma.c ****     }
 273:../drivers/fsl_lpuart_dma.c **** 
 274:../drivers/fsl_lpuart_dma.c ****     return status;
 275:../drivers/fsl_lpuart_dma.c **** }
 415              		.loc 1 275 0
 416 0062 09B0     		add	sp, sp, #36
 417              		@ sp needed
 418              	.LVL46:
 419              	.LVL47:
 420 0064 30BD     		pop	{r4, r5, pc}
 421              	.LVL48:
 422              	.L16:
 253:../drivers/fsl_lpuart_dma.c ****     }
 423              		.loc 1 253 0
 424 0066 0148     		ldr	r0, .L17
 425              	.LVL49:
 274:../drivers/fsl_lpuart_dma.c **** }
 426              		.loc 1 274 0
 427 0068 FBE7     		b	.L14
 428              	.L18:
 429 006a C046     		.align	2
 430              	.L17:
 431 006c 14050000 		.word	1300
 432              		.cfi_endproc
 433              	.LFE79:
 435              		.section	.text.LPUART_TransferReceiveDMA,"ax",%progbits
 436              		.align	1
 437              		.global	LPUART_TransferReceiveDMA
 438              		.syntax unified
 439              		.code	16
 440              		.thumb_func
 441              		.fpu softvfp
 443              	LPUART_TransferReceiveDMA:
 444              	.LFB80:
 276:../drivers/fsl_lpuart_dma.c **** 
 277:../drivers/fsl_lpuart_dma.c **** status_t LPUART_TransferReceiveDMA(LPUART_Type *base, lpuart_dma_handle_t *handle, lpuart_transfer_
 278:../drivers/fsl_lpuart_dma.c **** {
 445              		.loc 1 278 0
 446              		.cfi_startproc
 447              		@ args = 0, pretend = 0, frame = 16
 448              		@ frame_needed = 0, uses_anonymous_args = 0
 449              	.LVL50:
 450 0000 30B5     		push	{r4, r5, lr}
 451              		.cfi_def_cfa_offset 12
 452              		.cfi_offset 4, -12
 453              		.cfi_offset 5, -8
 454              		.cfi_offset 14, -4
 455 0002 89B0     		sub	sp, sp, #36
 456              		.cfi_def_cfa_offset 48
 457 0004 0500     		movs	r5, r0
 458 0006 0C00     		movs	r4, r1
 279:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 280:../drivers/fsl_lpuart_dma.c ****     assert(handle->rxDmaHandle);
 281:../drivers/fsl_lpuart_dma.c ****     assert(xfer);
 282:../drivers/fsl_lpuart_dma.c ****     assert(xfer->data);
 283:../drivers/fsl_lpuart_dma.c ****     assert(xfer->dataSize);
 284:../drivers/fsl_lpuart_dma.c **** 
 285:../drivers/fsl_lpuart_dma.c ****     status_t status;
 286:../drivers/fsl_lpuart_dma.c ****     dma_transfer_config_t xferConfig;
 287:../drivers/fsl_lpuart_dma.c **** 
 288:../drivers/fsl_lpuart_dma.c ****     /* If previous RX not finished. */
 289:../drivers/fsl_lpuart_dma.c ****     if (kLPUART_RxBusy == handle->rxState)
 459              		.loc 1 289 0
 460 0008 4B7E     		ldrb	r3, [r1, #25]
 461 000a 032B     		cmp	r3, #3
 462 000c 2AD0     		beq	.L21
 290:../drivers/fsl_lpuart_dma.c ****     {
 291:../drivers/fsl_lpuart_dma.c ****         status = kStatus_LPUART_RxBusy;
 292:../drivers/fsl_lpuart_dma.c ****     }
 293:../drivers/fsl_lpuart_dma.c ****     else
 294:../drivers/fsl_lpuart_dma.c ****     {
 295:../drivers/fsl_lpuart_dma.c ****         handle->rxState = kLPUART_RxBusy;
 463              		.loc 1 295 0
 464 000e 0323     		movs	r3, #3
 465 0010 4B76     		strb	r3, [r1, #25]
 296:../drivers/fsl_lpuart_dma.c ****         handle->rxDataSizeAll = xfer->dataSize;
 466              		.loc 1 296 0
 467 0012 5368     		ldr	r3, [r2, #4]
 468 0014 8B60     		str	r3, [r1, #8]
 469              	.LVL51:
 470              	.LBB48:
 471              	.LBB49:
 504:../drivers/fsl_lpuart.h **** }
 472              		.loc 2 504 0
 473 0016 0100     		movs	r1, r0
 474              	.LVL52:
 475 0018 0C31     		adds	r1, r1, #12
 476              	.LVL53:
 477              	.LBE49:
 478              	.LBE48:
 297:../drivers/fsl_lpuart_dma.c **** 
 298:../drivers/fsl_lpuart_dma.c ****         /* Prepare transfer. */
 299:../drivers/fsl_lpuart_dma.c ****         DMA_PrepareTransfer(&xferConfig, (void *)LPUART_GetDataRegisterAddress(base), sizeof(uint8_
 479              		.loc 1 299 0
 480 001a 1368     		ldr	r3, [r2]
 300:../drivers/fsl_lpuart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_PeripheralToMemory);
 481              		.loc 1 300 0
 482 001c 5268     		ldr	r2, [r2, #4]
 483              	.LVL54:
 484 001e 0192     		str	r2, [sp, #4]
 299:../drivers/fsl_lpuart_dma.c ****                             sizeof(uint8_t), xfer->dataSize, kDMA_PeripheralToMemory);
 485              		.loc 1 299 0
 486 0020 0122     		movs	r2, #1
 487 0022 0292     		str	r2, [sp, #8]
 488 0024 0092     		str	r2, [sp]
 489 0026 04A8     		add	r0, sp, #16
 490              	.LVL55:
 491 0028 FFF7FEFF 		bl	DMA_PrepareTransfer
 492              	.LVL56:
 301:../drivers/fsl_lpuart_dma.c **** 
 302:../drivers/fsl_lpuart_dma.c ****         /* Submit transfer. */
 303:../drivers/fsl_lpuart_dma.c ****         DMA_SubmitTransfer(handle->rxDmaHandle, &xferConfig, kDMA_EnableInterrupt);
 493              		.loc 1 303 0
 494 002c 0122     		movs	r2, #1
 495 002e 04A9     		add	r1, sp, #16
 496 0030 6069     		ldr	r0, [r4, #20]
 497 0032 FFF7FEFF 		bl	DMA_SubmitTransfer
 498              	.LVL57:
 304:../drivers/fsl_lpuart_dma.c ****         DMA_StartTransfer(handle->rxDmaHandle);
 499              		.loc 1 304 0
 500 0036 6269     		ldr	r2, [r4, #20]
 501              	.LVL58:
 502              	.LBB50:
 503              	.LBB51:
 504              		.loc 3 566 0
 505 0038 1368     		ldr	r3, [r2]
 506 003a 1279     		ldrb	r2, [r2, #4]
 507              	.LVL59:
 508 003c 1201     		lsls	r2, r2, #4
 509 003e 9B18     		adds	r3, r3, r2
 510 0040 0D33     		adds	r3, r3, #13
 511 0042 FF33     		adds	r3, r3, #255
 512 0044 1968     		ldr	r1, [r3]
 513 0046 8022     		movs	r2, #128
 514 0048 D205     		lsls	r2, r2, #23
 515 004a 0A43     		orrs	r2, r1
 516 004c 1A60     		str	r2, [r3]
 517              	.LVL60:
 518              	.LBE51:
 519              	.LBE50:
 520              	.LBB52:
 521              	.LBB53:
 541:../drivers/fsl_lpuart.h ****         base->CTRL |= LPUART_CTRL_RIE_MASK;
 522              		.loc 2 541 0
 523 004e 2A68     		ldr	r2, [r5]
 524 0050 8023     		movs	r3, #128
 525 0052 9B03     		lsls	r3, r3, #14
 526 0054 1A43     		orrs	r2, r3
 527 0056 2A60     		str	r2, [r5]
 542:../drivers/fsl_lpuart.h ****     }
 528              		.loc 2 542 0
 529 0058 AA68     		ldr	r2, [r5, #8]
 530 005a 1343     		orrs	r3, r2
 531 005c AB60     		str	r3, [r5, #8]
 532              	.LVL61:
 533              	.LBE53:
 534              	.LBE52:
 305:../drivers/fsl_lpuart_dma.c **** 
 306:../drivers/fsl_lpuart_dma.c ****         /* Enable LPUART RX DMA. */
 307:../drivers/fsl_lpuart_dma.c ****         LPUART_EnableRxDMA(base, true);
 308:../drivers/fsl_lpuart_dma.c **** 
 309:../drivers/fsl_lpuart_dma.c ****         status = kStatus_Success;
 535              		.loc 1 309 0
 536 005e 0020     		movs	r0, #0
 537              	.LVL62:
 538              	.L19:
 310:../drivers/fsl_lpuart_dma.c ****     }
 311:../drivers/fsl_lpuart_dma.c **** 
 312:../drivers/fsl_lpuart_dma.c ****     return status;
 313:../drivers/fsl_lpuart_dma.c **** }
 539              		.loc 1 313 0
 540 0060 09B0     		add	sp, sp, #36
 541              		@ sp needed
 542              	.LVL63:
 543              	.LVL64:
 544 0062 30BD     		pop	{r4, r5, pc}
 545              	.LVL65:
 546              	.L21:
 291:../drivers/fsl_lpuart_dma.c ****     }
 547              		.loc 1 291 0
 548 0064 0048     		ldr	r0, .L22
 549              	.LVL66:
 312:../drivers/fsl_lpuart_dma.c **** }
 550              		.loc 1 312 0
 551 0066 FBE7     		b	.L19
 552              	.L23:
 553              		.align	2
 554              	.L22:
 555 0068 15050000 		.word	1301
 556              		.cfi_endproc
 557              	.LFE80:
 559              		.section	.text.LPUART_TransferAbortSendDMA,"ax",%progbits
 560              		.align	1
 561              		.global	LPUART_TransferAbortSendDMA
 562              		.syntax unified
 563              		.code	16
 564              		.thumb_func
 565              		.fpu softvfp
 567              	LPUART_TransferAbortSendDMA:
 568              	.LFB81:
 314:../drivers/fsl_lpuart_dma.c **** 
 315:../drivers/fsl_lpuart_dma.c **** void LPUART_TransferAbortSendDMA(LPUART_Type *base, lpuart_dma_handle_t *handle)
 316:../drivers/fsl_lpuart_dma.c **** {
 569              		.loc 1 316 0
 570              		.cfi_startproc
 571              		@ args = 0, pretend = 0, frame = 0
 572              		@ frame_needed = 0, uses_anonymous_args = 0
 573              	.LVL67:
 574 0000 10B5     		push	{r4, lr}
 575              		.cfi_def_cfa_offset 8
 576              		.cfi_offset 4, -8
 577              		.cfi_offset 14, -4
 578 0002 0C00     		movs	r4, r1
 579              	.LVL68:
 580              	.LBB54:
 581              	.LBB55:
 524:../drivers/fsl_lpuart.h ****         base->CTRL &= ~LPUART_CTRL_TIE_MASK;
 582              		.loc 2 524 0
 583 0004 0268     		ldr	r2, [r0]
 584 0006 0C49     		ldr	r1, .L25
 585              	.LVL69:
 586 0008 0A40     		ands	r2, r1
 587 000a 0260     		str	r2, [r0]
 525:../drivers/fsl_lpuart.h ****     }
 588              		.loc 2 525 0
 589 000c 8368     		ldr	r3, [r0, #8]
 590 000e 0B40     		ands	r3, r1
 591 0010 8360     		str	r3, [r0, #8]
 592              	.LVL70:
 593              	.LBE55:
 594              	.LBE54:
 317:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 318:../drivers/fsl_lpuart_dma.c ****     assert(handle->txDmaHandle);
 319:../drivers/fsl_lpuart_dma.c **** 
 320:../drivers/fsl_lpuart_dma.c ****     /* Disable LPUART TX DMA. */
 321:../drivers/fsl_lpuart_dma.c ****     LPUART_EnableTxDMA(base, false);
 322:../drivers/fsl_lpuart_dma.c **** 
 323:../drivers/fsl_lpuart_dma.c ****     /* Stop transfer. */
 324:../drivers/fsl_lpuart_dma.c ****     DMA_AbortTransfer(handle->txDmaHandle);
 595              		.loc 1 324 0
 596 0012 2069     		ldr	r0, [r4, #16]
 597              	.LVL71:
 598 0014 FFF7FEFF 		bl	DMA_AbortTransfer
 599              	.LVL72:
 325:../drivers/fsl_lpuart_dma.c **** 
 326:../drivers/fsl_lpuart_dma.c ****     /* Write DMA->DSR[DONE] to abort transfer and clear status. */
 327:../drivers/fsl_lpuart_dma.c ****     DMA_ClearChannelStatusFlags(handle->txDmaHandle->base, handle->txDmaHandle->channel, kDMA_Trans
 600              		.loc 1 327 0
 601 0018 2269     		ldr	r2, [r4, #16]
 602 001a 1368     		ldr	r3, [r2]
 603 001c 1279     		ldrb	r2, [r2, #4]
 604              	.LVL73:
 605              	.LBB56:
 606              	.LBB57:
 481:../drivers/fsl_dma.h ****     }
 607              		.loc 3 481 0
 608 001e 1201     		lsls	r2, r2, #4
 609              	.LVL74:
 610 0020 9B18     		adds	r3, r3, r2
 611              	.LVL75:
 612 0022 0933     		adds	r3, r3, #9
 613 0024 FF33     		adds	r3, r3, #255
 614 0026 1968     		ldr	r1, [r3]
 615 0028 8022     		movs	r2, #128
 616 002a 5204     		lsls	r2, r2, #17
 617 002c 0A43     		orrs	r2, r1
 618 002e 1A60     		str	r2, [r3]
 619              	.LVL76:
 620              	.LBE57:
 621              	.LBE56:
 328:../drivers/fsl_lpuart_dma.c **** 
 329:../drivers/fsl_lpuart_dma.c ****     handle->txState = kLPUART_TxIdle;
 622              		.loc 1 329 0
 623 0030 0023     		movs	r3, #0
 624 0032 2376     		strb	r3, [r4, #24]
 330:../drivers/fsl_lpuart_dma.c **** }
 625              		.loc 1 330 0
 626              		@ sp needed
 627              	.LVL77:
 628 0034 10BD     		pop	{r4, pc}
 629              	.L26:
 630 0036 C046     		.align	2
 631              	.L25:
 632 0038 FFFF7FFF 		.word	-8388609
 633              		.cfi_endproc
 634              	.LFE81:
 636              		.section	.text.LPUART_TransferAbortReceiveDMA,"ax",%progbits
 637              		.align	1
 638              		.global	LPUART_TransferAbortReceiveDMA
 639              		.syntax unified
 640              		.code	16
 641              		.thumb_func
 642              		.fpu softvfp
 644              	LPUART_TransferAbortReceiveDMA:
 645              	.LFB82:
 331:../drivers/fsl_lpuart_dma.c **** 
 332:../drivers/fsl_lpuart_dma.c **** void LPUART_TransferAbortReceiveDMA(LPUART_Type *base, lpuart_dma_handle_t *handle)
 333:../drivers/fsl_lpuart_dma.c **** {
 646              		.loc 1 333 0
 647              		.cfi_startproc
 648              		@ args = 0, pretend = 0, frame = 0
 649              		@ frame_needed = 0, uses_anonymous_args = 0
 650              	.LVL78:
 651 0000 10B5     		push	{r4, lr}
 652              		.cfi_def_cfa_offset 8
 653              		.cfi_offset 4, -8
 654              		.cfi_offset 14, -4
 655 0002 0C00     		movs	r4, r1
 656              	.LVL79:
 657              	.LBB58:
 658              	.LBB59:
 546:../drivers/fsl_lpuart.h ****         base->CTRL &= ~LPUART_CTRL_RIE_MASK;
 659              		.loc 2 546 0
 660 0004 0268     		ldr	r2, [r0]
 661 0006 0C49     		ldr	r1, .L28
 662              	.LVL80:
 663 0008 0A40     		ands	r2, r1
 664 000a 0260     		str	r2, [r0]
 665              		.loc 2 547 0
 666 000c 8368     		ldr	r3, [r0, #8]
 667 000e 0B40     		ands	r3, r1
 668 0010 8360     		str	r3, [r0, #8]
 669              	.LVL81:
 670              	.LBE59:
 671              	.LBE58:
 334:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 335:../drivers/fsl_lpuart_dma.c ****     assert(handle->rxDmaHandle);
 336:../drivers/fsl_lpuart_dma.c **** 
 337:../drivers/fsl_lpuart_dma.c ****     /* Disable LPUART RX DMA. */
 338:../drivers/fsl_lpuart_dma.c ****     LPUART_EnableRxDMA(base, false);
 339:../drivers/fsl_lpuart_dma.c **** 
 340:../drivers/fsl_lpuart_dma.c ****     /* Stop transfer. */
 341:../drivers/fsl_lpuart_dma.c ****     DMA_AbortTransfer(handle->rxDmaHandle);
 672              		.loc 1 341 0
 673 0012 6069     		ldr	r0, [r4, #20]
 674              	.LVL82:
 675 0014 FFF7FEFF 		bl	DMA_AbortTransfer
 676              	.LVL83:
 342:../drivers/fsl_lpuart_dma.c **** 
 343:../drivers/fsl_lpuart_dma.c ****     /* Write DMA->DSR[DONE] to abort transfer and clear status. */
 344:../drivers/fsl_lpuart_dma.c ****     DMA_ClearChannelStatusFlags(handle->rxDmaHandle->base, handle->rxDmaHandle->channel, kDMA_Trans
 677              		.loc 1 344 0
 678 0018 6269     		ldr	r2, [r4, #20]
 679 001a 1368     		ldr	r3, [r2]
 680 001c 1279     		ldrb	r2, [r2, #4]
 681              	.LVL84:
 682              	.LBB60:
 683              	.LBB61:
 481:../drivers/fsl_dma.h ****     }
 684              		.loc 3 481 0
 685 001e 1201     		lsls	r2, r2, #4
 686              	.LVL85:
 687 0020 9B18     		adds	r3, r3, r2
 688              	.LVL86:
 689 0022 0933     		adds	r3, r3, #9
 690 0024 FF33     		adds	r3, r3, #255
 691 0026 1968     		ldr	r1, [r3]
 692 0028 8022     		movs	r2, #128
 693 002a 5204     		lsls	r2, r2, #17
 694 002c 0A43     		orrs	r2, r1
 695 002e 1A60     		str	r2, [r3]
 696              	.LVL87:
 697              	.LBE61:
 698              	.LBE60:
 345:../drivers/fsl_lpuart_dma.c **** 
 346:../drivers/fsl_lpuart_dma.c ****     handle->rxState = kLPUART_RxIdle;
 699              		.loc 1 346 0
 700 0030 0223     		movs	r3, #2
 701 0032 6376     		strb	r3, [r4, #25]
 347:../drivers/fsl_lpuart_dma.c **** }
 702              		.loc 1 347 0
 703              		@ sp needed
 704              	.LVL88:
 705 0034 10BD     		pop	{r4, pc}
 706              	.L29:
 707 0036 C046     		.align	2
 708              	.L28:
 709 0038 FFFFDFFF 		.word	-2097153
 710              		.cfi_endproc
 711              	.LFE82:
 713              		.section	.text.LPUART_TransferGetSendCountDMA,"ax",%progbits
 714              		.align	1
 715              		.global	LPUART_TransferGetSendCountDMA
 716              		.syntax unified
 717              		.code	16
 718              		.thumb_func
 719              		.fpu softvfp
 721              	LPUART_TransferGetSendCountDMA:
 722              	.LFB83:
 348:../drivers/fsl_lpuart_dma.c **** 
 349:../drivers/fsl_lpuart_dma.c **** status_t LPUART_TransferGetSendCountDMA(LPUART_Type *base, lpuart_dma_handle_t *handle, uint32_t *c
 350:../drivers/fsl_lpuart_dma.c **** {
 723              		.loc 1 350 0
 724              		.cfi_startproc
 725              		@ args = 0, pretend = 0, frame = 0
 726              		@ frame_needed = 0, uses_anonymous_args = 0
 727              		@ link register save eliminated.
 728              	.LVL89:
 351:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 352:../drivers/fsl_lpuart_dma.c ****     assert(handle->txDmaHandle);
 353:../drivers/fsl_lpuart_dma.c ****     assert(count);
 354:../drivers/fsl_lpuart_dma.c **** 
 355:../drivers/fsl_lpuart_dma.c ****     if (kLPUART_TxIdle == handle->txState)
 729              		.loc 1 355 0
 730 0000 0B7E     		ldrb	r3, [r1, #24]
 731 0002 002B     		cmp	r3, #0
 732 0004 0ED0     		beq	.L32
 356:../drivers/fsl_lpuart_dma.c ****     {
 357:../drivers/fsl_lpuart_dma.c ****         return kStatus_NoTransferInProgress;
 358:../drivers/fsl_lpuart_dma.c ****     }
 359:../drivers/fsl_lpuart_dma.c **** 
 360:../drivers/fsl_lpuart_dma.c ****     *count = handle->txDataSizeAll - DMA_GetRemainingBytes(handle->txDmaHandle->base, handle->txDma
 733              		.loc 1 360 0
 734 0006 C868     		ldr	r0, [r1, #12]
 735              	.LVL90:
 736 0008 0B69     		ldr	r3, [r1, #16]
 737 000a 1968     		ldr	r1, [r3]
 738              	.LVL91:
 739 000c 1B79     		ldrb	r3, [r3, #4]
 740              	.LVL92:
 741              	.LBB62:
 742              	.LBB63:
 449:../drivers/fsl_dma.h **** }
 743              		.loc 3 449 0
 744 000e 1B01     		lsls	r3, r3, #4
 745              	.LVL93:
 746 0010 C918     		adds	r1, r1, r3
 747              	.LVL94:
 748 0012 0931     		adds	r1, r1, #9
 749 0014 FF31     		adds	r1, r1, #255
 750 0016 0B68     		ldr	r3, [r1]
 751 0018 1B02     		lsls	r3, r3, #8
 752 001a 1B0A     		lsrs	r3, r3, #8
 753              	.LVL95:
 754              	.LBE63:
 755              	.LBE62:
 756              		.loc 1 360 0
 757 001c C31A     		subs	r3, r0, r3
 758 001e 1360     		str	r3, [r2]
 361:../drivers/fsl_lpuart_dma.c **** 
 362:../drivers/fsl_lpuart_dma.c ****     return kStatus_Success;
 759              		.loc 1 362 0
 760 0020 0020     		movs	r0, #0
 761              	.L30:
 363:../drivers/fsl_lpuart_dma.c **** }
 762              		.loc 1 363 0
 763              		@ sp needed
 764 0022 7047     		bx	lr
 765              	.LVL96:
 766              	.L32:
 357:../drivers/fsl_lpuart_dma.c ****     }
 767              		.loc 1 357 0
 768 0024 0620     		movs	r0, #6
 769              	.LVL97:
 770 0026 FCE7     		b	.L30
 771              		.cfi_endproc
 772              	.LFE83:
 774              		.section	.text.LPUART_TransferGetReceiveCountDMA,"ax",%progbits
 775              		.align	1
 776              		.global	LPUART_TransferGetReceiveCountDMA
 777              		.syntax unified
 778              		.code	16
 779              		.thumb_func
 780              		.fpu softvfp
 782              	LPUART_TransferGetReceiveCountDMA:
 783              	.LFB84:
 364:../drivers/fsl_lpuart_dma.c **** 
 365:../drivers/fsl_lpuart_dma.c **** status_t LPUART_TransferGetReceiveCountDMA(LPUART_Type *base, lpuart_dma_handle_t *handle, uint32_t
 366:../drivers/fsl_lpuart_dma.c **** {
 784              		.loc 1 366 0
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 0
 787              		@ frame_needed = 0, uses_anonymous_args = 0
 788              		@ link register save eliminated.
 789              	.LVL98:
 367:../drivers/fsl_lpuart_dma.c ****     assert(handle);
 368:../drivers/fsl_lpuart_dma.c ****     assert(handle->rxDmaHandle);
 369:../drivers/fsl_lpuart_dma.c ****     assert(count);
 370:../drivers/fsl_lpuart_dma.c **** 
 371:../drivers/fsl_lpuart_dma.c ****     if (kLPUART_RxIdle == handle->rxState)
 790              		.loc 1 371 0
 791 0000 4B7E     		ldrb	r3, [r1, #25]
 792 0002 022B     		cmp	r3, #2
 793 0004 0ED0     		beq	.L35
 372:../drivers/fsl_lpuart_dma.c ****     {
 373:../drivers/fsl_lpuart_dma.c ****         return kStatus_NoTransferInProgress;
 374:../drivers/fsl_lpuart_dma.c ****     }
 375:../drivers/fsl_lpuart_dma.c **** 
 376:../drivers/fsl_lpuart_dma.c ****     *count = handle->rxDataSizeAll - DMA_GetRemainingBytes(handle->rxDmaHandle->base, handle->rxDma
 794              		.loc 1 376 0
 795 0006 8868     		ldr	r0, [r1, #8]
 796              	.LVL99:
 797 0008 4B69     		ldr	r3, [r1, #20]
 798 000a 1968     		ldr	r1, [r3]
 799              	.LVL100:
 800 000c 1B79     		ldrb	r3, [r3, #4]
 801              	.LVL101:
 802              	.LBB64:
 803              	.LBB65:
 449:../drivers/fsl_dma.h **** }
 804              		.loc 3 449 0
 805 000e 1B01     		lsls	r3, r3, #4
 806              	.LVL102:
 807 0010 C918     		adds	r1, r1, r3
 808              	.LVL103:
 809 0012 0931     		adds	r1, r1, #9
 810 0014 FF31     		adds	r1, r1, #255
 811 0016 0B68     		ldr	r3, [r1]
 812 0018 1B02     		lsls	r3, r3, #8
 813 001a 1B0A     		lsrs	r3, r3, #8
 814              	.LVL104:
 815              	.LBE65:
 816              	.LBE64:
 817              		.loc 1 376 0
 818 001c C31A     		subs	r3, r0, r3
 819 001e 1360     		str	r3, [r2]
 377:../drivers/fsl_lpuart_dma.c **** 
 378:../drivers/fsl_lpuart_dma.c ****     return kStatus_Success;
 820              		.loc 1 378 0
 821 0020 0020     		movs	r0, #0
 822              	.L33:
 379:../drivers/fsl_lpuart_dma.c **** }
 823              		.loc 1 379 0
 824              		@ sp needed
 825 0022 7047     		bx	lr
 826              	.LVL105:
 827              	.L35:
 373:../drivers/fsl_lpuart_dma.c ****     }
 828              		.loc 1 373 0
 829 0024 0620     		movs	r0, #6
 830              	.LVL106:
 831 0026 FCE7     		b	.L33
 832              		.cfi_endproc
 833              	.LFE84:
 835              		.section	.bss.s_dmaPrivateHandle,"aw",%nobits
 836              		.align	2
 837              		.set	.LANCHOR0,. + 0
 840              	s_dmaPrivateHandle:
 841 0000 00000000 		.space	16
 841      00000000 
 841      00000000 
 841      00000000 
 842              		.text
 843              	.Letext0:
 844              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 845              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 846              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 847              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 848              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 849              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 850              		.file 10 "../CMSIS/system_MKL17Z4.h"
 851              		.file 11 "../CMSIS/MKL17Z4.h"
 852              		.file 12 "../drivers/fsl_common.h"
 853              		.file 13 "../drivers/fsl_clock.h"
 854              		.file 14 "../drivers/fsl_lpuart_dma.h"
 855              		.file 15 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_lpuart_dma.c
     /tmp/cc2cIHQZ.s:16     .text.LPUART_TransferSendDMACallback:0000000000000000 $t
     /tmp/cc2cIHQZ.s:22     .text.LPUART_TransferSendDMACallback:0000000000000000 LPUART_TransferSendDMACallback
     /tmp/cc2cIHQZ.s:104    .text.LPUART_TransferSendDMACallback:0000000000000044 $d
     /tmp/cc2cIHQZ.s:110    .text.LPUART_TransferReceiveDMACallback:0000000000000000 $t
     /tmp/cc2cIHQZ.s:116    .text.LPUART_TransferReceiveDMACallback:0000000000000000 LPUART_TransferReceiveDMACallback
     /tmp/cc2cIHQZ.s:195    .text.LPUART_TransferReceiveDMACallback:0000000000000044 $d
     /tmp/cc2cIHQZ.s:201    .text.LPUART_TransferCreateHandleDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:208    .text.LPUART_TransferCreateHandleDMA:0000000000000000 LPUART_TransferCreateHandleDMA
     /tmp/cc2cIHQZ.s:305    .text.LPUART_TransferCreateHandleDMA:000000000000006c $d
     /tmp/cc2cIHQZ.s:312    .text.LPUART_TransferSendDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:319    .text.LPUART_TransferSendDMA:0000000000000000 LPUART_TransferSendDMA
     /tmp/cc2cIHQZ.s:431    .text.LPUART_TransferSendDMA:000000000000006c $d
     /tmp/cc2cIHQZ.s:436    .text.LPUART_TransferReceiveDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:443    .text.LPUART_TransferReceiveDMA:0000000000000000 LPUART_TransferReceiveDMA
     /tmp/cc2cIHQZ.s:555    .text.LPUART_TransferReceiveDMA:0000000000000068 $d
     /tmp/cc2cIHQZ.s:560    .text.LPUART_TransferAbortSendDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:567    .text.LPUART_TransferAbortSendDMA:0000000000000000 LPUART_TransferAbortSendDMA
     /tmp/cc2cIHQZ.s:632    .text.LPUART_TransferAbortSendDMA:0000000000000038 $d
     /tmp/cc2cIHQZ.s:637    .text.LPUART_TransferAbortReceiveDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:644    .text.LPUART_TransferAbortReceiveDMA:0000000000000000 LPUART_TransferAbortReceiveDMA
     /tmp/cc2cIHQZ.s:709    .text.LPUART_TransferAbortReceiveDMA:0000000000000038 $d
     /tmp/cc2cIHQZ.s:714    .text.LPUART_TransferGetSendCountDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:721    .text.LPUART_TransferGetSendCountDMA:0000000000000000 LPUART_TransferGetSendCountDMA
     /tmp/cc2cIHQZ.s:775    .text.LPUART_TransferGetReceiveCountDMA:0000000000000000 $t
     /tmp/cc2cIHQZ.s:782    .text.LPUART_TransferGetReceiveCountDMA:0000000000000000 LPUART_TransferGetReceiveCountDMA
     /tmp/cc2cIHQZ.s:836    .bss.s_dmaPrivateHandle:0000000000000000 $d
     /tmp/cc2cIHQZ.s:840    .bss.s_dmaPrivateHandle:0000000000000000 s_dmaPrivateHandle

UNDEFINED SYMBOLS
LPUART_GetInstance
memset
DMA_SetCallback
DMA_PrepareTransfer
DMA_SubmitTransfer
DMA_AbortTransfer
