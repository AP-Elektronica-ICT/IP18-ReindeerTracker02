   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.initTimer,"ax",%progbits
  16              		.align	1
  17              		.global	initTimer
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	initTimer:
  24              	.LFB125:
  25              		.file 1 "../source/main.c"
   1:../source/main.c **** /**
   2:../source/main.c ****  * This is template for main module created by New Kinetis SDK 2.x Project Wizard. Enjoy!
   3:../source/main.c ****  **/
   4:../source/main.c **** 
   5:../source/main.c **** #include "board.h"
   6:../source/main.c **** #include "pin_mux.h"
   7:../source/main.c **** #include "clock_config.h"
   8:../source/main.c **** 
   9:../source/main.c **** #include "fsl_gpio.h"
  10:../source/main.c **** #include "fsl_uart.h"
  11:../source/main.c **** #include "fsl_port.h"
  12:../source/main.c **** #include "fsl_common.h"
  13:../source/main.c **** #include "fsl_i2c.h"
  14:../source/main.c **** #include "fsl_smc.h"
  15:../source/main.c **** #include "fsl_lptmr.h"
  16:../source/main.c **** #include "at_func.h"
  17:../source/main.c **** #include "fsl_lpuart.h"
  18:../source/main.c **** 
  19:../source/main.c **** #include <stdio.h>
  20:../source/main.c **** #include <stdlib.h>
  21:../source/main.c **** 
  22:../source/main.c **** #include "acc_func.h"
  23:../source/main.c **** #include "i2c_func.h"
  24:../source/main.c **** #include "adc_func.h"
  25:../source/main.c **** #include "fsl_rtc.h"
  26:../source/main.c **** #include "gps_func.h"
  27:../source/main.c **** #include "ubx_func.h"
  28:../source/main.c **** #include "nbiot_func.h"
  29:../source/main.c **** #include "timing.h"
  30:../source/main.c **** 
  31:../source/main.c **** #define RESPONSE_TIMEOUT_NORMAL_VALUE 2000
  32:../source/main.c **** 
  33:../source/main.c **** lptmr_config_t lptmr_config;
  34:../source/main.c **** smc_power_mode_vlls_config_t smc_power_mode_vlls_config;
  35:../source/main.c **** uart_config_t uart_config;
  36:../source/main.c **** 
  37:../source/main.c **** 
  38:../source/main.c **** volatile uint8_t wake = 2;
  39:../source/main.c **** volatile uint8_t NB_strReady = 0;
  40:../source/main.c **** volatile uint16_t NB_bufPtr = 0;
  41:../source/main.c **** 
  42:../source/main.c **** char NB_recBuf[500]; 	//buffer for receiving NB IoT module data
  43:../source/main.c **** 
  44:../source/main.c **** static char PC_recBuf[500];	//buffer for receiving from PC terminal
  45:../source/main.c **** volatile uint16_t PC_bufPtr = 0;
  46:../source/main.c **** volatile uint8_t PC_strReady = 0;
  47:../source/main.c **** 
  48:../source/main.c **** char GPS_recBuf[600];	//buffer for receiving from PC terminal
  49:../source/main.c **** volatile uint16_t GPS_bufPtr = 0;
  50:../source/main.c **** volatile uint8_t GPS_strReady = 0;
  51:../source/main.c **** uint8_t streamGps = 0;
  52:../source/main.c **** 
  53:../source/main.c **** char parsedLat[15];
  54:../source/main.c **** char parsedLon[15];
  55:../source/main.c **** 
  56:../source/main.c **** volatile uint32_t moduleResponseTimeout = RESPONSE_TIMEOUT_NORMAL_VALUE; //timeout variable for wai
  57:../source/main.c **** 
  58:../source/main.c **** uint32_t ms_ticks; //millisecond ticks value for the delay_ms function
  59:../source/main.c **** /*
  60:../source/main.c ****  void delay_ms(uint32_t del)
  61:../source/main.c ****  {
  62:../source/main.c ****  for (; del > 0; del--)
  63:../source/main.c ****  {
  64:../source/main.c ****  for(uint32_t t = 0; t<ms_ticks;t++)
  65:../source/main.c ****  {
  66:../source/main.c ****  __asm("nop");
  67:../source/main.c ****  }
  68:../source/main.c ****  }
  69:../source/main.c ****  }
  70:../source/main.c ****  */
  71:../source/main.c **** 
  72:../source/main.c **** void initTimer() {
  26              		.loc 1 72 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 70B5     		push	{r4, r5, r6, lr}
  31              		.cfi_def_cfa_offset 16
  32              		.cfi_offset 4, -16
  33              		.cfi_offset 5, -12
  34              		.cfi_offset 6, -8
  35              		.cfi_offset 14, -4
  73:../source/main.c **** 
  74:../source/main.c **** 	/*
  75:../source/main.c **** 	 * Init dead reindeer timer. LPTIMER interrupt will wake up MCU after a certain time, IF accelerom
  76:../source/main.c **** 	 * has not waked it earlier (and reset the timer)
  77:../source/main.c **** 	 */
  78:../source/main.c **** 
  79:../source/main.c **** 	LPTMR_GetDefaultConfig(&lptmr_config);
  36              		.loc 1 79 0
  37 0002 0A4C     		ldr	r4, .L2
  80:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  81:../source/main.c **** 	lptmr_config.value = kLPTMR_Prescale_Glitch_0;
  82:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  83:../source/main.c **** 	EnableIRQ(LPTMR0_IRQn);
  84:../source/main.c **** 	LPTMR_Init(LPTMR0, &lptmr_config);
  38              		.loc 1 84 0
  39 0004 0A4D     		ldr	r5, .L2+4
  79:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  40              		.loc 1 79 0
  41 0006 2000     		movs	r0, r4
  42 0008 FFF7FEFF 		bl	LPTMR_GetDefaultConfig
  43              	.LVL0:
  81:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  44              		.loc 1 81 0
  45 000c 0022     		movs	r2, #0
  80:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  46              		.loc 1 80 0
  47 000e 0123     		movs	r3, #1
  81:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  48              		.loc 1 81 0
  49 0010 A271     		strb	r2, [r4, #6]
  50              	.LBB36:
  51              	.LBB37:
  52              	.LBB38:
  53              		.file 2 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  54              		.loc 2 735 0
  55 0012 8022     		movs	r2, #128
  56              	.LBE38:
  57              	.LBE37:
  58              	.LBE36:
  80:../source/main.c **** 	lptmr_config.value = kLPTMR_Prescale_Glitch_0;
  59              		.loc 1 80 0
  60 0014 2371     		strb	r3, [r4, #4]
  82:../source/main.c **** 	EnableIRQ(LPTMR0_IRQn);
  61              		.loc 1 82 0
  62 0016 6371     		strb	r3, [r4, #5]
  63              	.LVL1:
  64              	.LBB41:
  65              	.LBB40:
  66              	.LBB39:
  67              		.loc 2 735 0
  68 0018 064B     		ldr	r3, .L2+8
  69 001a 5205     		lsls	r2, r2, #21
  70 001c 1A60     		str	r2, [r3]
  71              	.LVL2:
  72              	.LBE39:
  73              	.LBE40:
  74              	.LBE41:
  75              		.loc 1 84 0
  76 001e 2800     		movs	r0, r5
  77 0020 2100     		movs	r1, r4
  78 0022 FFF7FEFF 		bl	LPTMR_Init
  79              	.LVL3:
  80              	.LBB42:
  81              	.LBB43:
  82              		.file 3 "../drivers/fsl_lptmr.h"
   1:../drivers/fsl_lptmr.h **** /*
   2:../drivers/fsl_lptmr.h ****  * The Clear BSD License
   3:../drivers/fsl_lptmr.h ****  * Copyright (c) 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_lptmr.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_lptmr.h ****  * All rights reserved.
   6:../drivers/fsl_lptmr.h ****  *
   7:../drivers/fsl_lptmr.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_lptmr.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_lptmr.h ****  * that the following conditions are met:
  10:../drivers/fsl_lptmr.h ****  *
  11:../drivers/fsl_lptmr.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_lptmr.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_lptmr.h ****  *
  14:../drivers/fsl_lptmr.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_lptmr.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_lptmr.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_lptmr.h ****  *
  18:../drivers/fsl_lptmr.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_lptmr.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_lptmr.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_lptmr.h ****  *
  22:../drivers/fsl_lptmr.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_lptmr.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_lptmr.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_lptmr.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_lptmr.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_lptmr.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_lptmr.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_lptmr.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_lptmr.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_lptmr.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_lptmr.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_lptmr.h ****  */
  34:../drivers/fsl_lptmr.h **** #ifndef _FSL_LPTMR_H_
  35:../drivers/fsl_lptmr.h **** #define _FSL_LPTMR_H_
  36:../drivers/fsl_lptmr.h **** 
  37:../drivers/fsl_lptmr.h **** #include "fsl_common.h"
  38:../drivers/fsl_lptmr.h **** 
  39:../drivers/fsl_lptmr.h **** /*!
  40:../drivers/fsl_lptmr.h ****  * @addtogroup lptmr
  41:../drivers/fsl_lptmr.h ****  * @{
  42:../drivers/fsl_lptmr.h ****  */
  43:../drivers/fsl_lptmr.h **** 
  44:../drivers/fsl_lptmr.h **** /*******************************************************************************
  45:../drivers/fsl_lptmr.h ****  * Definitions
  46:../drivers/fsl_lptmr.h ****  ******************************************************************************/
  47:../drivers/fsl_lptmr.h **** 
  48:../drivers/fsl_lptmr.h **** /*! @name Driver version */
  49:../drivers/fsl_lptmr.h **** /*@{*/
  50:../drivers/fsl_lptmr.h **** #define FSL_LPTMR_DRIVER_VERSION (MAKE_VERSION(2, 0, 1)) /*!< Version 2.0.1 */
  51:../drivers/fsl_lptmr.h **** /*@}*/
  52:../drivers/fsl_lptmr.h **** 
  53:../drivers/fsl_lptmr.h **** /*! @brief LPTMR pin selection used in pulse counter mode.*/
  54:../drivers/fsl_lptmr.h **** typedef enum _lptmr_pin_select
  55:../drivers/fsl_lptmr.h **** {
  56:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_0 = 0x0U, /*!< Pulse counter input 0 is selected */
  57:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_1 = 0x1U, /*!< Pulse counter input 1 is selected */
  58:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_2 = 0x2U, /*!< Pulse counter input 2 is selected */
  59:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_3 = 0x3U  /*!< Pulse counter input 3 is selected */
  60:../drivers/fsl_lptmr.h **** } lptmr_pin_select_t;
  61:../drivers/fsl_lptmr.h **** 
  62:../drivers/fsl_lptmr.h **** /*! @brief LPTMR pin polarity used in pulse counter mode.*/
  63:../drivers/fsl_lptmr.h **** typedef enum _lptmr_pin_polarity
  64:../drivers/fsl_lptmr.h **** {
  65:../drivers/fsl_lptmr.h ****     kLPTMR_PinPolarityActiveHigh = 0x0U, /*!< Pulse Counter input source is active-high */
  66:../drivers/fsl_lptmr.h ****     kLPTMR_PinPolarityActiveLow = 0x1U   /*!< Pulse Counter input source is active-low */
  67:../drivers/fsl_lptmr.h **** } lptmr_pin_polarity_t;
  68:../drivers/fsl_lptmr.h **** 
  69:../drivers/fsl_lptmr.h **** /*! @brief LPTMR timer mode selection.*/
  70:../drivers/fsl_lptmr.h **** typedef enum _lptmr_timer_mode
  71:../drivers/fsl_lptmr.h **** {
  72:../drivers/fsl_lptmr.h ****     kLPTMR_TimerModeTimeCounter = 0x0U, /*!< Time Counter mode */
  73:../drivers/fsl_lptmr.h ****     kLPTMR_TimerModePulseCounter = 0x1U /*!< Pulse Counter mode */
  74:../drivers/fsl_lptmr.h **** } lptmr_timer_mode_t;
  75:../drivers/fsl_lptmr.h **** 
  76:../drivers/fsl_lptmr.h **** /*! @brief LPTMR prescaler/glitch filter values*/
  77:../drivers/fsl_lptmr.h **** typedef enum _lptmr_prescaler_glitch_value
  78:../drivers/fsl_lptmr.h **** {
  79:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_0 = 0x0U,  /*!< Prescaler divide 2, glitch filter does not support this 
  80:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_1 = 0x1U,  /*!< Prescaler divide 4, glitch filter 2 */
  81:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_2 = 0x2U,  /*!< Prescaler divide 8, glitch filter 4 */
  82:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_3 = 0x3U,  /*!< Prescaler divide 16, glitch filter 8 */
  83:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_4 = 0x4U,  /*!< Prescaler divide 32, glitch filter 16 */
  84:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_5 = 0x5U,  /*!< Prescaler divide 64, glitch filter 32 */
  85:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_6 = 0x6U,  /*!< Prescaler divide 128, glitch filter 64 */
  86:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_7 = 0x7U,  /*!< Prescaler divide 256, glitch filter 128 */
  87:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_8 = 0x8U,  /*!< Prescaler divide 512, glitch filter 256 */
  88:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_9 = 0x9U,  /*!< Prescaler divide 1024, glitch filter 512*/
  89:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_10 = 0xAU, /*!< Prescaler divide 2048 glitch filter 1024 */
  90:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_11 = 0xBU, /*!< Prescaler divide 4096, glitch filter 2048 */
  91:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_12 = 0xCU, /*!< Prescaler divide 8192, glitch filter 4096 */
  92:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_13 = 0xDU, /*!< Prescaler divide 16384, glitch filter 8192 */
  93:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_14 = 0xEU, /*!< Prescaler divide 32768, glitch filter 16384 */
  94:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_15 = 0xFU  /*!< Prescaler divide 65536, glitch filter 32768 */
  95:../drivers/fsl_lptmr.h **** } lptmr_prescaler_glitch_value_t;
  96:../drivers/fsl_lptmr.h **** 
  97:../drivers/fsl_lptmr.h **** /*!
  98:../drivers/fsl_lptmr.h ****  * @brief LPTMR prescaler/glitch filter clock select.
  99:../drivers/fsl_lptmr.h ****  * @note Clock connections are SoC-specific
 100:../drivers/fsl_lptmr.h ****  */
 101:../drivers/fsl_lptmr.h **** typedef enum _lptmr_prescaler_clock_select
 102:../drivers/fsl_lptmr.h **** {
 103:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_0 = 0x0U, /*!< Prescaler/glitch filter clock 0 selected. */
 104:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_1 = 0x1U, /*!< Prescaler/glitch filter clock 1 selected. */
 105:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_2 = 0x2U, /*!< Prescaler/glitch filter clock 2 selected. */
 106:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_3 = 0x3U, /*!< Prescaler/glitch filter clock 3 selected. */
 107:../drivers/fsl_lptmr.h **** } lptmr_prescaler_clock_select_t;
 108:../drivers/fsl_lptmr.h **** 
 109:../drivers/fsl_lptmr.h **** /*! @brief List of the LPTMR interrupts */
 110:../drivers/fsl_lptmr.h **** typedef enum _lptmr_interrupt_enable
 111:../drivers/fsl_lptmr.h **** {
 112:../drivers/fsl_lptmr.h ****     kLPTMR_TimerInterruptEnable = LPTMR_CSR_TIE_MASK, /*!< Timer interrupt enable */
 113:../drivers/fsl_lptmr.h **** } lptmr_interrupt_enable_t;
 114:../drivers/fsl_lptmr.h **** 
 115:../drivers/fsl_lptmr.h **** /*! @brief List of the LPTMR status flags */
 116:../drivers/fsl_lptmr.h **** typedef enum _lptmr_status_flags
 117:../drivers/fsl_lptmr.h **** {
 118:../drivers/fsl_lptmr.h ****     kLPTMR_TimerCompareFlag = LPTMR_CSR_TCF_MASK, /*!< Timer compare flag */
 119:../drivers/fsl_lptmr.h **** } lptmr_status_flags_t;
 120:../drivers/fsl_lptmr.h **** 
 121:../drivers/fsl_lptmr.h **** /*!
 122:../drivers/fsl_lptmr.h ****  * @brief LPTMR config structure
 123:../drivers/fsl_lptmr.h ****  *
 124:../drivers/fsl_lptmr.h ****  * This structure holds the configuration settings for the LPTMR peripheral. To initialize this
 125:../drivers/fsl_lptmr.h ****  * structure to reasonable defaults, call the LPTMR_GetDefaultConfig() function and pass a
 126:../drivers/fsl_lptmr.h ****  * pointer to your configuration structure instance.
 127:../drivers/fsl_lptmr.h ****  *
 128:../drivers/fsl_lptmr.h ****  * The configuration struct can be made constant so it resides in flash.
 129:../drivers/fsl_lptmr.h ****  */
 130:../drivers/fsl_lptmr.h **** typedef struct _lptmr_config
 131:../drivers/fsl_lptmr.h **** {
 132:../drivers/fsl_lptmr.h ****     lptmr_timer_mode_t timerMode;     /*!< Time counter mode or pulse counter mode */
 133:../drivers/fsl_lptmr.h ****     lptmr_pin_select_t pinSelect;     /*!< LPTMR pulse input pin select; used only in pulse counter
 134:../drivers/fsl_lptmr.h ****     lptmr_pin_polarity_t pinPolarity; /*!< LPTMR pulse input pin polarity; used only in pulse count
 135:../drivers/fsl_lptmr.h ****     bool enableFreeRunning;           /*!< True: enable free running, counter is reset on overflow
 136:../drivers/fsl_lptmr.h ****                                            False: counter is reset when the compare flag is set */
 137:../drivers/fsl_lptmr.h ****     bool bypassPrescaler;             /*!< True: bypass prescaler; false: use clock from prescaler 
 138:../drivers/fsl_lptmr.h ****     lptmr_prescaler_clock_select_t prescalerClockSource; /*!< LPTMR clock source */
 139:../drivers/fsl_lptmr.h ****     lptmr_prescaler_glitch_value_t value;                /*!< Prescaler or glitch filter value */
 140:../drivers/fsl_lptmr.h **** } lptmr_config_t;
 141:../drivers/fsl_lptmr.h **** 
 142:../drivers/fsl_lptmr.h **** /*******************************************************************************
 143:../drivers/fsl_lptmr.h ****  * API
 144:../drivers/fsl_lptmr.h ****  ******************************************************************************/
 145:../drivers/fsl_lptmr.h **** 
 146:../drivers/fsl_lptmr.h **** #if defined(__cplusplus)
 147:../drivers/fsl_lptmr.h **** extern "C" {
 148:../drivers/fsl_lptmr.h **** #endif
 149:../drivers/fsl_lptmr.h **** 
 150:../drivers/fsl_lptmr.h **** /*!
 151:../drivers/fsl_lptmr.h ****  * @name Initialization and deinitialization
 152:../drivers/fsl_lptmr.h ****  * @{
 153:../drivers/fsl_lptmr.h ****  */
 154:../drivers/fsl_lptmr.h **** 
 155:../drivers/fsl_lptmr.h **** /*!
 156:../drivers/fsl_lptmr.h ****  * @brief Ungates the LPTMR clock and configures the peripheral for a basic operation.
 157:../drivers/fsl_lptmr.h ****  *
 158:../drivers/fsl_lptmr.h ****  * @note This API should be called at the beginning of the application using the LPTMR driver.
 159:../drivers/fsl_lptmr.h ****  *
 160:../drivers/fsl_lptmr.h ****  * @param base   LPTMR peripheral base address
 161:../drivers/fsl_lptmr.h ****  * @param config A pointer to the LPTMR configuration structure.
 162:../drivers/fsl_lptmr.h ****  */
 163:../drivers/fsl_lptmr.h **** void LPTMR_Init(LPTMR_Type *base, const lptmr_config_t *config);
 164:../drivers/fsl_lptmr.h **** 
 165:../drivers/fsl_lptmr.h **** /*!
 166:../drivers/fsl_lptmr.h ****  * @brief Gates the LPTMR clock.
 167:../drivers/fsl_lptmr.h ****  *
 168:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 169:../drivers/fsl_lptmr.h ****  */
 170:../drivers/fsl_lptmr.h **** void LPTMR_Deinit(LPTMR_Type *base);
 171:../drivers/fsl_lptmr.h **** 
 172:../drivers/fsl_lptmr.h **** /*!
 173:../drivers/fsl_lptmr.h ****  * @brief Fills in the LPTMR configuration structure with default settings.
 174:../drivers/fsl_lptmr.h ****  *
 175:../drivers/fsl_lptmr.h ****  * The default values are as follows.
 176:../drivers/fsl_lptmr.h ****  * @code
 177:../drivers/fsl_lptmr.h ****  *    config->timerMode = kLPTMR_TimerModeTimeCounter;
 178:../drivers/fsl_lptmr.h ****  *    config->pinSelect = kLPTMR_PinSelectInput_0;
 179:../drivers/fsl_lptmr.h ****  *    config->pinPolarity = kLPTMR_PinPolarityActiveHigh;
 180:../drivers/fsl_lptmr.h ****  *    config->enableFreeRunning = false;
 181:../drivers/fsl_lptmr.h ****  *    config->bypassPrescaler = true;
 182:../drivers/fsl_lptmr.h ****  *    config->prescalerClockSource = kLPTMR_PrescalerClock_1;
 183:../drivers/fsl_lptmr.h ****  *    config->value = kLPTMR_Prescale_Glitch_0;
 184:../drivers/fsl_lptmr.h ****  * @endcode
 185:../drivers/fsl_lptmr.h ****  * @param config A pointer to the LPTMR configuration structure.
 186:../drivers/fsl_lptmr.h ****  */
 187:../drivers/fsl_lptmr.h **** void LPTMR_GetDefaultConfig(lptmr_config_t *config);
 188:../drivers/fsl_lptmr.h **** 
 189:../drivers/fsl_lptmr.h **** /*! @}*/
 190:../drivers/fsl_lptmr.h **** 
 191:../drivers/fsl_lptmr.h **** /*!
 192:../drivers/fsl_lptmr.h ****  * @name Interrupt Interface
 193:../drivers/fsl_lptmr.h ****  * @{
 194:../drivers/fsl_lptmr.h ****  */
 195:../drivers/fsl_lptmr.h **** 
 196:../drivers/fsl_lptmr.h **** /*!
 197:../drivers/fsl_lptmr.h ****  * @brief Enables the selected LPTMR interrupts.
 198:../drivers/fsl_lptmr.h ****  *
 199:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 200:../drivers/fsl_lptmr.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 201:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_interrupt_enable_t
 202:../drivers/fsl_lptmr.h ****  */
 203:../drivers/fsl_lptmr.h **** static inline void LPTMR_EnableInterrupts(LPTMR_Type *base, uint32_t mask)
 204:../drivers/fsl_lptmr.h **** {
 205:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 206:../drivers/fsl_lptmr.h **** 
 207:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit so that we don't clear this w1c bit when writing back */
 208:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 209:../drivers/fsl_lptmr.h ****     reg |= mask;
 210:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 211:../drivers/fsl_lptmr.h **** }
 212:../drivers/fsl_lptmr.h **** 
 213:../drivers/fsl_lptmr.h **** /*!
 214:../drivers/fsl_lptmr.h ****  * @brief Disables the selected LPTMR interrupts.
 215:../drivers/fsl_lptmr.h ****  *
 216:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 217:../drivers/fsl_lptmr.h ****  * @param mask The interrupts to disable. This is a logical OR of members of the
 218:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_interrupt_enable_t.
 219:../drivers/fsl_lptmr.h ****  */
 220:../drivers/fsl_lptmr.h **** static inline void LPTMR_DisableInterrupts(LPTMR_Type *base, uint32_t mask)
 221:../drivers/fsl_lptmr.h **** {
 222:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 223:../drivers/fsl_lptmr.h **** 
 224:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit so that we don't clear this w1c bit when writing back */
 225:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 226:../drivers/fsl_lptmr.h ****     reg &= ~mask;
 227:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 228:../drivers/fsl_lptmr.h **** }
 229:../drivers/fsl_lptmr.h **** 
 230:../drivers/fsl_lptmr.h **** /*!
 231:../drivers/fsl_lptmr.h ****  * @brief Gets the enabled LPTMR interrupts.
 232:../drivers/fsl_lptmr.h ****  *
 233:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 234:../drivers/fsl_lptmr.h ****  *
 235:../drivers/fsl_lptmr.h ****  * @return The enabled interrupts. This is the logical OR of members of the
 236:../drivers/fsl_lptmr.h ****  *         enumeration ::lptmr_interrupt_enable_t
 237:../drivers/fsl_lptmr.h ****  */
 238:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetEnabledInterrupts(LPTMR_Type *base)
 239:../drivers/fsl_lptmr.h **** {
 240:../drivers/fsl_lptmr.h ****     return (base->CSR & LPTMR_CSR_TIE_MASK);
 241:../drivers/fsl_lptmr.h **** }
 242:../drivers/fsl_lptmr.h **** 
 243:../drivers/fsl_lptmr.h **** /*! @}*/
 244:../drivers/fsl_lptmr.h **** 
 245:../drivers/fsl_lptmr.h **** #if defined(FSL_FEATURE_LPTMR_HAS_CSR_TDRE) && (FSL_FEATURE_LPTMR_HAS_CSR_TDRE)
 246:../drivers/fsl_lptmr.h **** /*!
 247:../drivers/fsl_lptmr.h ****  * @brief Enable or disable timer DMA request
 248:../drivers/fsl_lptmr.h ****  *
 249:../drivers/fsl_lptmr.h ****  * @param base base LPTMR peripheral base address
 250:../drivers/fsl_lptmr.h ****  * @param enable Switcher of timer DMA feature. "true" means to enable, "false" means to disable.
 251:../drivers/fsl_lptmr.h ****  */
 252:../drivers/fsl_lptmr.h **** static inline void LPTMR_EnableTimerDMA(LPTMR_Type *base, bool enable)
 253:../drivers/fsl_lptmr.h **** {
 254:../drivers/fsl_lptmr.h ****     if(enable)
 255:../drivers/fsl_lptmr.h ****     {
 256:../drivers/fsl_lptmr.h ****         base->CSR |= LPTMR_CSR_TDRE_MASK;
 257:../drivers/fsl_lptmr.h ****     }
 258:../drivers/fsl_lptmr.h ****     else
 259:../drivers/fsl_lptmr.h ****     {
 260:../drivers/fsl_lptmr.h ****         base->CSR &= ~(LPTMR_CSR_TDRE_MASK);
 261:../drivers/fsl_lptmr.h ****     }
 262:../drivers/fsl_lptmr.h **** }
 263:../drivers/fsl_lptmr.h **** #endif /* FSL_FEATURE_LPTMR_HAS_CSR_TDRE */
 264:../drivers/fsl_lptmr.h **** 
 265:../drivers/fsl_lptmr.h **** /*!
 266:../drivers/fsl_lptmr.h ****  * @name Status Interface
 267:../drivers/fsl_lptmr.h ****  * @{
 268:../drivers/fsl_lptmr.h ****  */
 269:../drivers/fsl_lptmr.h **** 
 270:../drivers/fsl_lptmr.h **** /*!
 271:../drivers/fsl_lptmr.h ****  * @brief Gets the LPTMR status flags.
 272:../drivers/fsl_lptmr.h ****  *
 273:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 274:../drivers/fsl_lptmr.h ****  *
 275:../drivers/fsl_lptmr.h ****  * @return The status flags. This is the logical OR of members of the
 276:../drivers/fsl_lptmr.h ****  *         enumeration ::lptmr_status_flags_t
 277:../drivers/fsl_lptmr.h ****  */
 278:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetStatusFlags(LPTMR_Type *base)
 279:../drivers/fsl_lptmr.h **** {
 280:../drivers/fsl_lptmr.h ****     return (base->CSR & LPTMR_CSR_TCF_MASK);
 281:../drivers/fsl_lptmr.h **** }
 282:../drivers/fsl_lptmr.h **** 
 283:../drivers/fsl_lptmr.h **** /*!
 284:../drivers/fsl_lptmr.h ****  * @brief  Clears the LPTMR status flags.
 285:../drivers/fsl_lptmr.h ****  *
 286:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 287:../drivers/fsl_lptmr.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
 288:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_status_flags_t.
 289:../drivers/fsl_lptmr.h ****  */
 290:../drivers/fsl_lptmr.h **** static inline void LPTMR_ClearStatusFlags(LPTMR_Type *base, uint32_t mask)
 291:../drivers/fsl_lptmr.h **** {
 292:../drivers/fsl_lptmr.h ****     base->CSR |= mask;
 293:../drivers/fsl_lptmr.h **** }
 294:../drivers/fsl_lptmr.h **** 
 295:../drivers/fsl_lptmr.h **** /*! @}*/
 296:../drivers/fsl_lptmr.h **** 
 297:../drivers/fsl_lptmr.h **** /*!
 298:../drivers/fsl_lptmr.h ****  * @name Read and write the timer period
 299:../drivers/fsl_lptmr.h ****  * @{
 300:../drivers/fsl_lptmr.h ****  */
 301:../drivers/fsl_lptmr.h **** 
 302:../drivers/fsl_lptmr.h **** /*!
 303:../drivers/fsl_lptmr.h ****  * @brief Sets the timer period in units of count.
 304:../drivers/fsl_lptmr.h ****  *
 305:../drivers/fsl_lptmr.h ****  * Timers counts from 0 until it equals the count value set here. The count value is written to
 306:../drivers/fsl_lptmr.h ****  * the CMR register.
 307:../drivers/fsl_lptmr.h ****  *
 308:../drivers/fsl_lptmr.h ****  * @note
 309:../drivers/fsl_lptmr.h ****  * 1. The TCF flag is set with the CNR equals the count provided here and then increments.
 310:../drivers/fsl_lptmr.h ****  * 2. Call the utility macros provided in the fsl_common.h to convert to ticks.
 311:../drivers/fsl_lptmr.h ****  *
 312:../drivers/fsl_lptmr.h ****  * @param base  LPTMR peripheral base address
 313:../drivers/fsl_lptmr.h ****  * @param ticks A timer period in units of ticks, which should be equal or greater than 1.
 314:../drivers/fsl_lptmr.h ****  */
 315:../drivers/fsl_lptmr.h **** static inline void LPTMR_SetTimerPeriod(LPTMR_Type *base, uint32_t ticks)
 316:../drivers/fsl_lptmr.h **** {
 317:../drivers/fsl_lptmr.h ****     assert(ticks > 0);
 318:../drivers/fsl_lptmr.h ****     base->CMR = ticks - 1;
  83              		.loc 3 318 0
  84 0026 044B     		ldr	r3, .L2+12
  85              	.LBE43:
  86              	.LBE42:
  85:../source/main.c **** 	LPTMR_SetTimerPeriod(LPTMR0, 7000);  // 3000 for 20hz data rat
  86:../source/main.c **** }
  87              		.loc 1 86 0
  88              		@ sp needed
  89              	.LBB45:
  90              	.LBB44:
  91              		.loc 3 318 0
  92 0028 AB60     		str	r3, [r5, #8]
  93              	.LVL4:
  94              	.LBE44:
  95              	.LBE45:
  96              		.loc 1 86 0
  97 002a 70BD     		pop	{r4, r5, r6, pc}
  98              	.L3:
  99              		.align	2
 100              	.L2:
 101 002c 00000000 		.word	lptmr_config
 102 0030 00000440 		.word	1074003968
 103 0034 00E100E0 		.word	-536813312
 104 0038 571B0000 		.word	6999
 105              		.cfi_endproc
 106              	.LFE125:
 108              		.section	.text.initUART,"ax",%progbits
 109              		.align	1
 110              		.global	initUART
 111              		.syntax unified
 112              		.code	16
 113              		.thumb_func
 114              		.fpu softvfp
 116              	initUART:
 117              	.LFB126:
  87:../source/main.c **** 
  88:../source/main.c **** /*
  89:../source/main.c ****  *
  90:../source/main.c ****  * Init all needed UART buses. LPUART0 for NB-IoT, UART0 for PC, UART2 for GPS
  91:../source/main.c ****  */
  92:../source/main.c **** 
  93:../source/main.c **** void initUART() {
 118              		.loc 1 93 0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 16
 121              		@ frame_needed = 0, uses_anonymous_args = 0
 122 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 123              		.cfi_def_cfa_offset 20
 124              		.cfi_offset 4, -20
 125              		.cfi_offset 5, -16
 126              		.cfi_offset 6, -12
 127              		.cfi_offset 7, -8
 128              		.cfi_offset 14, -4
 129 0002 85B0     		sub	sp, sp, #20
 130              		.cfi_def_cfa_offset 40
  94:../source/main.c **** 
  95:../source/main.c **** 	lpuart_config_t lpuart_config;
  96:../source/main.c **** 	LPUART_GetDefaultConfig(&lpuart_config);
 131              		.loc 1 96 0
 132 0004 01AC     		add	r4, sp, #4
 133 0006 2000     		movs	r0, r4
 134 0008 FFF7FEFF 		bl	LPUART_GetDefaultConfig
 135              	.LVL5:
  97:../source/main.c **** 
  98:../source/main.c **** 	uint32_t uartClkSrcFreq = BOARD_DEBUG_UART_CLK_FREQ; //get MCU clock frequency for setting correct
 136              		.loc 1 98 0
 137 000c FFF7FEFF 		bl	CLOCK_GetCoreSysClkFreq
 138              	.LVL6:
  99:../source/main.c **** 
 100:../source/main.c **** 	UART_GetDefaultConfig(&uart_config);
 139              		.loc 1 100 0
 140 0010 224D     		ldr	r5, .L5
  98:../source/main.c **** 
 141              		.loc 1 98 0
 142 0012 0600     		movs	r6, r0
 143              	.LVL7:
 144              		.loc 1 100 0
 145 0014 2800     		movs	r0, r5
 146              	.LVL8:
 147 0016 FFF7FEFF 		bl	UART_GetDefaultConfig
 148              	.LVL9:
 101:../source/main.c **** 	uart_config.baudRate_Bps = 9600;
 149              		.loc 1 101 0
 150 001a 9623     		movs	r3, #150
 102:../source/main.c **** 	uart_config.enableTx = true;
 103:../source/main.c **** 	uart_config.enableRx = true;
 104:../source/main.c **** 	lpuart_config.baudRate_Bps = 57600;
 151              		.loc 1 104 0
 152 001c E122     		movs	r2, #225
 101:../source/main.c **** 	uart_config.baudRate_Bps = 9600;
 153              		.loc 1 101 0
 154 001e 9B01     		lsls	r3, r3, #6
 155 0020 2B60     		str	r3, [r5]
 102:../source/main.c **** 	uart_config.enableTx = true;
 156              		.loc 1 102 0
 157 0022 0123     		movs	r3, #1
 158              		.loc 1 104 0
 159 0024 1202     		lsls	r2, r2, #8
 160 0026 0192     		str	r2, [sp, #4]
 102:../source/main.c **** 	uart_config.enableTx = true;
 161              		.loc 1 102 0
 162 0028 AB71     		strb	r3, [r5, #6]
 103:../source/main.c **** 	lpuart_config.baudRate_Bps = 57600;
 163              		.loc 1 103 0
 164 002a EB71     		strb	r3, [r5, #7]
 105:../source/main.c **** 	lpuart_config.enableTx = true;
 165              		.loc 1 105 0
 166 002c A372     		strb	r3, [r4, #10]
 106:../source/main.c **** 	lpuart_config.enableRx = true;
 167              		.loc 1 106 0
 168 002e E372     		strb	r3, [r4, #11]
 169              	.LVL10:
 170              	.LBB54:
 171              	.LBB55:
 172              		.file 4 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 462:../drivers/fsl_clock.h **** }
 463:../drivers/fsl_clock.h **** 
 464:../drivers/fsl_clock.h **** /*!
 465:../drivers/fsl_clock.h ****  * @brief Set ERCLK32K source.
 466:../drivers/fsl_clock.h ****  *
 467:../drivers/fsl_clock.h ****  * @param src The value to set ERCLK32K clock source.
 468:../drivers/fsl_clock.h ****  */
 469:../drivers/fsl_clock.h **** static inline void CLOCK_SetEr32kClock(uint32_t src)
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
 472:../drivers/fsl_clock.h **** }
 473:../drivers/fsl_clock.h **** 
 474:../drivers/fsl_clock.h **** /*!
 475:../drivers/fsl_clock.h ****  * @brief Set LPUART0 clock source.
 476:../drivers/fsl_clock.h ****  *
 477:../drivers/fsl_clock.h ****  * @param src The value to set LPUART0 clock source.
 478:../drivers/fsl_clock.h ****  */
 479:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpuart0Clock(uint32_t src)
 480:../drivers/fsl_clock.h **** {
 481:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART0SRC_MASK) | SIM_SOPT2_LPUART0SRC(src));
 482:../drivers/fsl_clock.h **** }
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*!
 485:../drivers/fsl_clock.h ****  * @brief Set LPUART1 clock source.
 486:../drivers/fsl_clock.h ****  *
 487:../drivers/fsl_clock.h ****  * @param src The value to set LPUART1 clock source.
 488:../drivers/fsl_clock.h ****  */
 489:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpuart1Clock(uint32_t src)
 490:../drivers/fsl_clock.h **** {
 491:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART1SRC_MASK) | SIM_SOPT2_LPUART1SRC(src));
 173              		.loc 4 491 0
 174 0030 1B4A     		ldr	r2, .L5+4
 175 0032 1C4B     		ldr	r3, .L5+8
 176 0034 1C48     		ldr	r0, .L5+12
 177 0036 D158     		ldr	r1, [r2, r3]
 178              	.LBE55:
 179              	.LBE54:
 107:../source/main.c **** 
 108:../source/main.c **** 	CLOCK_SetLpuart1Clock(0x1U);
 109:../source/main.c **** 	CLOCK_SetLpuart0Clock(0x1U);
 110:../source/main.c **** 
 111:../source/main.c **** 	LPUART_Init(LPUART0, &lpuart_config, uartClkSrcFreq); //Init LPUART0 for NBiot
 180              		.loc 1 111 0
 181 0038 1C4F     		ldr	r7, .L5+16
 182              	.LBB57:
 183              	.LBB56:
 184              		.loc 4 491 0
 185 003a 0840     		ands	r0, r1
 186 003c 8021     		movs	r1, #128
 187 003e 4905     		lsls	r1, r1, #21
 188 0040 0143     		orrs	r1, r0
 189 0042 D150     		str	r1, [r2, r3]
 190              	.LVL11:
 191              	.LBE56:
 192              	.LBE57:
 193              	.LBB58:
 194              	.LBB59:
 481:../drivers/fsl_clock.h **** }
 195              		.loc 4 481 0
 196 0044 D158     		ldr	r1, [r2, r3]
 197 0046 1A48     		ldr	r0, .L5+20
 198 0048 0840     		ands	r0, r1
 199 004a 8021     		movs	r1, #128
 200 004c C904     		lsls	r1, r1, #19
 201 004e 0143     		orrs	r1, r0
 202 0050 D150     		str	r1, [r2, r3]
 203              	.LVL12:
 204              	.LBE59:
 205              	.LBE58:
 206              		.loc 1 111 0
 207 0052 3800     		movs	r0, r7
 208 0054 3200     		movs	r2, r6
 209 0056 2100     		movs	r1, r4
 210 0058 FFF7FEFF 		bl	LPUART_Init
 211              	.LVL13:
 112:../source/main.c **** 
 113:../source/main.c **** 	UART_Init(UART2, &uart_config, uartClkSrcFreq); //UART2 for GPS with same settings!
 212              		.loc 1 113 0
 213 005c 3200     		movs	r2, r6
 214 005e 2900     		movs	r1, r5
 215 0060 1448     		ldr	r0, .L5+24
 216 0062 FFF7FEFF 		bl	UART_Init
 217              	.LVL14:
 114:../source/main.c **** 
 115:../source/main.c **** 	lpuart_config.baudRate_Bps = 57600;
 218              		.loc 1 115 0
 219 0066 E122     		movs	r2, #225
 116:../source/main.c **** 
 117:../source/main.c **** 	LPUART_Init(LPUART1, &lpuart_config, uartClkSrcFreq); //Init LPUART0 for NBiot
 220              		.loc 1 117 0
 221 0068 2100     		movs	r1, r4
 118:../source/main.c **** 
 119:../source/main.c **** 	LPUART_EnableInterrupts(LPUART0, kUART_RxDataRegFullInterruptEnable); //enable LPUART0 receive int
 222              		.loc 1 119 0
 223 006a 8024     		movs	r4, #128
 117:../source/main.c **** 
 224              		.loc 1 117 0
 225 006c 124D     		ldr	r5, .L5+28
 115:../source/main.c **** 
 226              		.loc 1 115 0
 227 006e 1202     		lsls	r2, r2, #8
 228              		.loc 1 119 0
 229 0070 A401     		lsls	r4, r4, #6
 115:../source/main.c **** 
 230              		.loc 1 115 0
 231 0072 0192     		str	r2, [sp, #4]
 117:../source/main.c **** 
 232              		.loc 1 117 0
 233 0074 2800     		movs	r0, r5
 234 0076 3200     		movs	r2, r6
 235 0078 FFF7FEFF 		bl	LPUART_Init
 236              	.LVL15:
 237              		.loc 1 119 0
 238 007c 2100     		movs	r1, r4
 239 007e 3800     		movs	r0, r7
 240 0080 FFF7FEFF 		bl	LPUART_EnableInterrupts
 241              	.LVL16:
 120:../source/main.c **** 
 121:../source/main.c **** 	//EnableIRQ(LPUART0_IRQn);
 122:../source/main.c **** 
 123:../source/main.c **** 	UART_EnableInterrupts(UART2, kUART_RxDataRegFullInterruptEnable); //enable LPUART0 receive interru
 242              		.loc 1 123 0
 243 0084 2100     		movs	r1, r4
 244 0086 0B48     		ldr	r0, .L5+24
 245 0088 FFF7FEFF 		bl	UART_EnableInterrupts
 246              	.LVL17:
 124:../source/main.c **** 	//EnableIRQ(UART2_FLEXIO_IRQn);
 125:../source/main.c **** 
 126:../source/main.c **** 	LPUART_EnableInterrupts(LPUART1, kUART_RxDataRegFullInterruptEnable); //enable UART0 receive inter
 247              		.loc 1 126 0
 248 008c 2100     		movs	r1, r4
 249 008e 2800     		movs	r0, r5
 250 0090 FFF7FEFF 		bl	LPUART_EnableInterrupts
 251              	.LVL18:
 252              	.LBB60:
 253              	.LBB61:
 254              	.LBB62:
 255              		.loc 2 735 0
 256 0094 094B     		ldr	r3, .L5+32
 257 0096 1C60     		str	r4, [r3]
 258              	.LVL19:
 259              	.LBE62:
 260              	.LBE61:
 261              	.LBE60:
 127:../source/main.c **** 	EnableIRQ( LPUART1_IRQn );
 128:../source/main.c **** 
 129:../source/main.c **** }
 262              		.loc 1 129 0
 263 0098 05B0     		add	sp, sp, #20
 264              		@ sp needed
 265              	.LVL20:
 266 009a F0BD     		pop	{r4, r5, r6, r7, pc}
 267              	.L6:
 268              		.align	2
 269              	.L5:
 270 009c 00000000 		.word	uart_config
 271 00a0 00700440 		.word	1074032640
 272 00a4 04100000 		.word	4100
 273 00a8 FFFFFFCF 		.word	-805306369
 274 00ac 00400540 		.word	1074085888
 275 00b0 FFFFFFF3 		.word	-201326593
 276 00b4 00C00640 		.word	1074184192
 277 00b8 00500540 		.word	1074089984
 278 00bc 00E100E0 		.word	-536813312
 279              		.cfi_endproc
 280              	.LFE126:
 282              		.section	.text.NB_send,"ax",%progbits
 283              		.align	1
 284              		.global	NB_send
 285              		.syntax unified
 286              		.code	16
 287              		.thumb_func
 288              		.fpu softvfp
 290              	NB_send:
 291              	.LFB127:
 130:../source/main.c **** 
 131:../source/main.c **** /*
 132:../source/main.c ****  * Send data to NBiot with LPUART0
 133:../source/main.c ****  * String to be sent is pointed by *data
 134:../source/main.c ****  *
 135:../source/main.c ****  */
 136:../source/main.c **** 
 137:../source/main.c **** void NB_send(char *data) {
 292              		.loc 1 137 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 296              	.LVL21:
 138:../source/main.c **** 
 139:../source/main.c **** 	char c = *data++; //assign c a character from the string and post-increment string pointer
 297              		.loc 1 139 0
 298 0000 0023     		movs	r3, #0
 140:../source/main.c **** 
 141:../source/main.c **** 	while (c) { //loop until c is zero which means string has ended and no more chars has to be sent
 142:../source/main.c **** 
 143:../source/main.c **** 		while (!((LPUART0->STAT) & kLPUART_TxDataRegEmptyFlag)) {
 299              		.loc 1 143 0
 300 0002 8021     		movs	r1, #128
 137:../source/main.c **** 
 301              		.loc 1 137 0
 302 0004 10B5     		push	{r4, lr}
 303              		.cfi_def_cfa_offset 8
 304              		.cfi_offset 4, -8
 305              		.cfi_offset 14, -4
 306              		.loc 1 143 0
 307 0006 074A     		ldr	r2, .L13
 139:../source/main.c **** 
 308              		.loc 1 139 0
 309 0008 C356     		ldrsb	r3, [r0, r3]
 310              	.LVL22:
 311              		.loc 1 143 0
 312 000a 0904     		lsls	r1, r1, #16
 139:../source/main.c **** 
 313              		.loc 1 139 0
 314 000c 0130     		adds	r0, r0, #1
 315              	.LVL23:
 316              	.L8:
 141:../source/main.c **** 
 317              		.loc 1 141 0
 318 000e 002B     		cmp	r3, #0
 319 0010 00D1     		bne	.L9
 144:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 145:../source/main.c **** 		LPUART0->DATA = c; //write new character to transmit buffer
 146:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 147:../source/main.c **** 	}
 148:../source/main.c **** }
 320              		.loc 1 148 0
 321              		@ sp needed
 322 0012 10BD     		pop	{r4, pc}
 323              	.L9:
 143:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 324              		.loc 1 143 0 discriminator 1
 325 0014 5468     		ldr	r4, [r2, #4]
 326 0016 0C42     		tst	r4, r1
 327 0018 FCD0     		beq	.L9
 145:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 328              		.loc 1 145 0
 329 001a D360     		str	r3, [r2, #12]
 330              	.LVL24:
 146:../source/main.c **** 	}
 331              		.loc 1 146 0
 332 001c 0023     		movs	r3, #0
 333              	.LVL25:
 334 001e C356     		ldrsb	r3, [r0, r3]
 335              	.LVL26:
 336 0020 0130     		adds	r0, r0, #1
 337              	.LVL27:
 338 0022 F4E7     		b	.L8
 339              	.L14:
 340              		.align	2
 341              	.L13:
 342 0024 00400540 		.word	1074085888
 343              		.cfi_endproc
 344              	.LFE127:
 346              		.section	.text.GPS_send,"ax",%progbits
 347              		.align	1
 348              		.global	GPS_send
 349              		.syntax unified
 350              		.code	16
 351              		.thumb_func
 352              		.fpu softvfp
 354              	GPS_send:
 355              	.LFB128:
 149:../source/main.c **** 
 150:../source/main.c **** 
 151:../source/main.c **** 
 152:../source/main.c **** void GPS_send(char *data, uint8_t len) {
 356              		.loc 1 152 0
 357              		.cfi_startproc
 358              		@ args = 0, pretend = 0, frame = 0
 359              		@ frame_needed = 0, uses_anonymous_args = 0
 360              	.LVL28:
 153:../source/main.c **** 
 154:../source/main.c **** 	char c = *data++; //assign c a character from the string and post-increment string pointer
 361              		.loc 1 154 0
 362 0000 0023     		movs	r3, #0
 152:../source/main.c **** 
 363              		.loc 1 152 0
 364 0002 10B5     		push	{r4, lr}
 365              		.cfi_def_cfa_offset 8
 366              		.cfi_offset 4, -8
 367              		.cfi_offset 14, -4
 155:../source/main.c **** 
 156:../source/main.c **** 	for (; len > 0; len--) { //loop until c is zero which means string has ended and no more chars has
 157:../source/main.c **** 
 158:../source/main.c **** 		while (!((UART2->S1) & 0x80)) {
 368              		.loc 1 158 0
 369 0004 084C     		ldr	r4, .L20
 154:../source/main.c **** 
 370              		.loc 1 154 0
 371 0006 C356     		ldrsb	r3, [r0, r3]
 372              	.LVL29:
 373 0008 0130     		adds	r0, r0, #1
 374              	.LVL30:
 375              	.L16:
 156:../source/main.c **** 
 376              		.loc 1 156 0 discriminator 1
 377 000a 0029     		cmp	r1, #0
 378 000c 00D1     		bne	.L17
 159:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 160:../source/main.c **** 		UART2->D = c; //write new character to transmit buffer
 161:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 162:../source/main.c **** 	}
 163:../source/main.c **** }
 379              		.loc 1 163 0
 380              		@ sp needed
 381 000e 10BD     		pop	{r4, pc}
 382              	.L17:
 158:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 383              		.loc 1 158 0 discriminator 1
 384 0010 2279     		ldrb	r2, [r4, #4]
 385 0012 52B2     		sxtb	r2, r2
 386 0014 002A     		cmp	r2, #0
 387 0016 FBDA     		bge	.L17
 160:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 388              		.loc 1 160 0
 389 0018 DBB2     		uxtb	r3, r3
 390 001a E371     		strb	r3, [r4, #7]
 391              	.LVL31:
 161:../source/main.c **** 	}
 392              		.loc 1 161 0
 393 001c 0023     		movs	r3, #0
 394              	.LVL32:
 156:../source/main.c **** 
 395              		.loc 1 156 0
 396 001e 0139     		subs	r1, r1, #1
 397              	.LVL33:
 161:../source/main.c **** 	}
 398              		.loc 1 161 0
 399 0020 C356     		ldrsb	r3, [r0, r3]
 400              	.LVL34:
 156:../source/main.c **** 
 401              		.loc 1 156 0
 402 0022 C9B2     		uxtb	r1, r1
 403              	.LVL35:
 404 0024 0130     		adds	r0, r0, #1
 405              	.LVL36:
 406 0026 F0E7     		b	.L16
 407              	.L21:
 408              		.align	2
 409              	.L20:
 410 0028 00C00640 		.word	1074184192
 411              		.cfi_endproc
 412              	.LFE128:
 414              		.section	.text.PCprint,"ax",%progbits
 415              		.align	1
 416              		.global	PCprint
 417              		.syntax unified
 418              		.code	16
 419              		.thumb_func
 420              		.fpu softvfp
 422              	PCprint:
 423              	.LFB129:
 164:../source/main.c **** 
 165:../source/main.c **** uint8_t PCprint(char *data) {
 424              		.loc 1 165 0
 425              		.cfi_startproc
 426              		@ args = 0, pretend = 0, frame = 0
 427              		@ frame_needed = 0, uses_anonymous_args = 0
 428              	.LVL37:
 429 0000 30B5     		push	{r4, r5, lr}
 430              		.cfi_def_cfa_offset 12
 431              		.cfi_offset 4, -12
 432              		.cfi_offset 5, -8
 433              		.cfi_offset 14, -4
 166:../source/main.c **** 	char c;
 167:../source/main.c **** 	uint8_t len = 0;
 168:../source/main.c **** 	while ((c = *data++)) {
 169:../source/main.c **** 
 170:../source/main.c **** 		while (!(LPUART1->STAT & kLPUART_TxDataRegEmptyFlag)) {
 434              		.loc 1 170 0
 435 0002 8025     		movs	r5, #128
 165:../source/main.c **** 	char c;
 436              		.loc 1 165 0
 437 0004 0400     		movs	r4, r0
 168:../source/main.c **** 
 438              		.loc 1 168 0
 439 0006 0023     		movs	r3, #0
 440              		.loc 1 170 0
 441 0008 0649     		ldr	r1, .L28
 442 000a 2D04     		lsls	r5, r5, #16
 443              	.LVL38:
 444              	.L23:
 168:../source/main.c **** 
 445              		.loc 1 168 0
 446 000c E256     		ldrsb	r2, [r4, r3]
 447 000e D8B2     		uxtb	r0, r3
 448              	.LVL39:
 449 0010 002A     		cmp	r2, #0
 450 0012 00D1     		bne	.L24
 171:../source/main.c **** 		}
 172:../source/main.c **** 
 173:../source/main.c **** 		LPUART1->DATA = c;
 174:../source/main.c **** 		len++;
 175:../source/main.c **** 
 176:../source/main.c **** 	}
 177:../source/main.c **** 
 178:../source/main.c **** 
 179:../source/main.c **** 	return len;
 180:../source/main.c **** }
 451              		.loc 1 180 0
 452              		@ sp needed
 453              	.LVL40:
 454 0014 30BD     		pop	{r4, r5, pc}
 455              	.LVL41:
 456              	.L24:
 170:../source/main.c **** 		}
 457              		.loc 1 170 0 discriminator 1
 458 0016 4868     		ldr	r0, [r1, #4]
 459 0018 2842     		tst	r0, r5
 460 001a FCD0     		beq	.L24
 173:../source/main.c **** 		len++;
 461              		.loc 1 173 0
 462 001c CA60     		str	r2, [r1, #12]
 463              	.LVL42:
 464 001e 0133     		adds	r3, r3, #1
 465              	.LVL43:
 466 0020 F4E7     		b	.L23
 467              	.L29:
 468 0022 C046     		.align	2
 469              	.L28:
 470 0024 00500540 		.word	1074089984
 471              		.cfi_endproc
 472              	.LFE129:
 474              		.global	__aeabi_uidiv
 475              		.section	.text.startup.main,"ax",%progbits
 476              		.align	1
 477              		.global	main
 478              		.syntax unified
 479              		.code	16
 480              		.thumb_func
 481              		.fpu softvfp
 483              	main:
 484              	.LFB130:
 181:../source/main.c **** 
 182:../source/main.c **** int main(void) {
 485              		.loc 1 182 0
 486              		.cfi_startproc
 487              		@ args = 0, pretend = 0, frame = 528
 488              		@ frame_needed = 0, uses_anonymous_args = 0
 489 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 490              		.cfi_def_cfa_offset 20
 491              		.cfi_offset 4, -20
 492              		.cfi_offset 5, -16
 493              		.cfi_offset 6, -12
 494              		.cfi_offset 7, -8
 495              		.cfi_offset 14, -4
 496 0002 C24C     		ldr	r4, .L71
 497 0004 A544     		add	sp, sp, r4
 498              		.cfi_def_cfa_offset 552
 183:../source/main.c **** 
 184:../source/main.c **** 	//PMC->REGSC |= 0x08;	//acknowledge wake up to voltage regulator module, this is needed with LLWU 
 185:../source/main.c **** 	//EnableIRQ(LLWU_IRQn);//enable LLWU interrupts. if we wake up from VLLS mode, it means that next 
 186:../source/main.c **** 						 //will jump to the LLWU interrupt vector
 187:../source/main.c **** 
 188:../source/main.c **** 	struct reindeerData_t reindeerData; //create struct for our reindeer data that will be sent
 189:../source/main.c **** 	char mqttMessage[450];
 190:../source/main.c **** 
 191:../source/main.c **** 	BOARD_InitPins();	//init all physical pins
 499              		.loc 1 191 0
 500 0006 FFF7FEFF 		bl	BOARD_InitPins
 501              	.LVL44:
 192:../source/main.c **** 	BOARD_BootClockRUN();  //by uncommenting this we can use FRDM 50Mhz external clock, but will not w
 502              		.loc 1 192 0
 503 000a FFF7FEFF 		bl	BOARD_BootClockRUN
 504              	.LVL45:
 193:../source/main.c **** 	//BOARD_InitDebugConsole();
 194:../source/main.c **** 
 195:../source/main.c **** 	/*
 196:../source/main.c **** 	 * Calculate how many processor ticks are in 1 ms to make accurate delay_ms function
 197:../source/main.c **** 	 * first take MCU clock frequency, divide by 1000ms and divide by 7 because our delay_ms loop take
 198:../source/main.c **** 	 */
 199:../source/main.c **** 	ms_ticks = BOARD_DEBUG_UART_CLK_FREQ / 1000 / 7;
 505              		.loc 1 199 0
 506 000e FFF7FEFF 		bl	CLOCK_GetCoreSysClkFreq
 507              	.LVL46:
 508 0012 BF49     		ldr	r1, .L71+4
 509 0014 FFF7FEFF 		bl	__aeabi_uidiv
 510              	.LVL47:
 511 0018 BE4B     		ldr	r3, .L71+8
 512 001a 1860     		str	r0, [r3]
 200:../source/main.c **** 
 201:../source/main.c **** 	SysTick_Config(BOARD_DEBUG_UART_CLK_FREQ / 1000); //setup SysTick timer for 1ms interval for delay
 513              		.loc 1 201 0
 514 001c FFF7FEFF 		bl	CLOCK_GetCoreSysClkFreq
 515              	.LVL48:
 516 0020 FA21     		movs	r1, #250
 517 0022 8900     		lsls	r1, r1, #2
 518 0024 FFF7FEFF 		bl	__aeabi_uidiv
 519              	.LVL49:
 520              	.LBB77:
 521              	.LBB78:
 736:../CMSIS/core_cm0plus.h ****   }
 737:../CMSIS/core_cm0plus.h **** }
 738:../CMSIS/core_cm0plus.h **** 
 739:../CMSIS/core_cm0plus.h **** 
 740:../CMSIS/core_cm0plus.h **** /**
 741:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Enable status
 742:../CMSIS/core_cm0plus.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 743:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 744:../CMSIS/core_cm0plus.h ****   \return             0  Interrupt is not enabled.
 745:../CMSIS/core_cm0plus.h ****   \return             1  Interrupt is enabled.
 746:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 747:../CMSIS/core_cm0plus.h ****  */
 748:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 749:../CMSIS/core_cm0plus.h **** {
 750:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 751:../CMSIS/core_cm0plus.h ****   {
 752:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 753:../CMSIS/core_cm0plus.h ****   }
 754:../CMSIS/core_cm0plus.h ****   else
 755:../CMSIS/core_cm0plus.h ****   {
 756:../CMSIS/core_cm0plus.h ****     return(0U);
 757:../CMSIS/core_cm0plus.h ****   }
 758:../CMSIS/core_cm0plus.h **** }
 759:../CMSIS/core_cm0plus.h **** 
 760:../CMSIS/core_cm0plus.h **** 
 761:../CMSIS/core_cm0plus.h **** /**
 762:../CMSIS/core_cm0plus.h ****   \brief   Disable Interrupt
 763:../CMSIS/core_cm0plus.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 764:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 765:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 766:../CMSIS/core_cm0plus.h ****  */
 767:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 768:../CMSIS/core_cm0plus.h **** {
 769:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 770:../CMSIS/core_cm0plus.h ****   {
 771:../CMSIS/core_cm0plus.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 772:../CMSIS/core_cm0plus.h ****     __DSB();
 773:../CMSIS/core_cm0plus.h ****     __ISB();
 774:../CMSIS/core_cm0plus.h ****   }
 775:../CMSIS/core_cm0plus.h **** }
 776:../CMSIS/core_cm0plus.h **** 
 777:../CMSIS/core_cm0plus.h **** 
 778:../CMSIS/core_cm0plus.h **** /**
 779:../CMSIS/core_cm0plus.h ****   \brief   Get Pending Interrupt
 780:../CMSIS/core_cm0plus.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 781:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 782:../CMSIS/core_cm0plus.h ****   \return             0  Interrupt status is not pending.
 783:../CMSIS/core_cm0plus.h ****   \return             1  Interrupt status is pending.
 784:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 785:../CMSIS/core_cm0plus.h ****  */
 786:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 787:../CMSIS/core_cm0plus.h **** {
 788:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 789:../CMSIS/core_cm0plus.h ****   {
 790:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 791:../CMSIS/core_cm0plus.h ****   }
 792:../CMSIS/core_cm0plus.h ****   else
 793:../CMSIS/core_cm0plus.h ****   {
 794:../CMSIS/core_cm0plus.h ****     return(0U);
 795:../CMSIS/core_cm0plus.h ****   }
 796:../CMSIS/core_cm0plus.h **** }
 797:../CMSIS/core_cm0plus.h **** 
 798:../CMSIS/core_cm0plus.h **** 
 799:../CMSIS/core_cm0plus.h **** /**
 800:../CMSIS/core_cm0plus.h ****   \brief   Set Pending Interrupt
 801:../CMSIS/core_cm0plus.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 802:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 803:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 804:../CMSIS/core_cm0plus.h ****  */
 805:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 806:../CMSIS/core_cm0plus.h **** {
 807:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 808:../CMSIS/core_cm0plus.h ****   {
 809:../CMSIS/core_cm0plus.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 810:../CMSIS/core_cm0plus.h ****   }
 811:../CMSIS/core_cm0plus.h **** }
 812:../CMSIS/core_cm0plus.h **** 
 813:../CMSIS/core_cm0plus.h **** 
 814:../CMSIS/core_cm0plus.h **** /**
 815:../CMSIS/core_cm0plus.h ****   \brief   Clear Pending Interrupt
 816:../CMSIS/core_cm0plus.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 817:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 818:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 819:../CMSIS/core_cm0plus.h ****  */
 820:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 821:../CMSIS/core_cm0plus.h **** {
 822:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 823:../CMSIS/core_cm0plus.h ****   {
 824:../CMSIS/core_cm0plus.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 825:../CMSIS/core_cm0plus.h ****   }
 826:../CMSIS/core_cm0plus.h **** }
 827:../CMSIS/core_cm0plus.h **** 
 828:../CMSIS/core_cm0plus.h **** 
 829:../CMSIS/core_cm0plus.h **** /**
 830:../CMSIS/core_cm0plus.h ****   \brief   Set Interrupt Priority
 831:../CMSIS/core_cm0plus.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 832:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 833:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 834:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Interrupt number.
 835:../CMSIS/core_cm0plus.h ****   \param [in]  priority  Priority to set.
 836:../CMSIS/core_cm0plus.h ****   \note    The priority cannot be set for every processor exception.
 837:../CMSIS/core_cm0plus.h ****  */
 838:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 839:../CMSIS/core_cm0plus.h **** {
 840:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 841:../CMSIS/core_cm0plus.h ****   {
 842:../CMSIS/core_cm0plus.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 843:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 844:../CMSIS/core_cm0plus.h ****   }
 845:../CMSIS/core_cm0plus.h ****   else
 846:../CMSIS/core_cm0plus.h ****   {
 847:../CMSIS/core_cm0plus.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 848:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 849:../CMSIS/core_cm0plus.h ****   }
 850:../CMSIS/core_cm0plus.h **** }
 851:../CMSIS/core_cm0plus.h **** 
 852:../CMSIS/core_cm0plus.h **** 
 853:../CMSIS/core_cm0plus.h **** /**
 854:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Priority
 855:../CMSIS/core_cm0plus.h ****   \details Reads the priority of a device specific interrupt or a processor exception.
 856:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 857:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 858:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn  Interrupt number.
 859:../CMSIS/core_cm0plus.h ****   \return             Interrupt Priority.
 860:../CMSIS/core_cm0plus.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 861:../CMSIS/core_cm0plus.h ****  */
 862:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
 863:../CMSIS/core_cm0plus.h **** {
 864:../CMSIS/core_cm0plus.h **** 
 865:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 866:../CMSIS/core_cm0plus.h ****   {
 867:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 868:../CMSIS/core_cm0plus.h ****   }
 869:../CMSIS/core_cm0plus.h ****   else
 870:../CMSIS/core_cm0plus.h ****   {
 871:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 872:../CMSIS/core_cm0plus.h ****   }
 873:../CMSIS/core_cm0plus.h **** }
 874:../CMSIS/core_cm0plus.h **** 
 875:../CMSIS/core_cm0plus.h **** 
 876:../CMSIS/core_cm0plus.h **** /**
 877:../CMSIS/core_cm0plus.h ****   \brief   Set Interrupt Vector
 878:../CMSIS/core_cm0plus.h ****   \details Sets an interrupt vector in SRAM based interrupt vector table.
 879:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 880:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 881:../CMSIS/core_cm0plus.h ****            VTOR must been relocated to SRAM before.
 882:../CMSIS/core_cm0plus.h ****            If VTOR is not present address 0 must be mapped to SRAM.
 883:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn      Interrupt number
 884:../CMSIS/core_cm0plus.h ****   \param [in]   vector    Address of interrupt handler function
 885:../CMSIS/core_cm0plus.h ****  */
 886:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
 887:../CMSIS/core_cm0plus.h **** {
 888:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 889:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
 890:../CMSIS/core_cm0plus.h **** #else
 891:../CMSIS/core_cm0plus.h ****     uint32_t *vectors = (uint32_t *)0x0U;
 892:../CMSIS/core_cm0plus.h **** #endif
 893:../CMSIS/core_cm0plus.h ****   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
 894:../CMSIS/core_cm0plus.h **** }
 895:../CMSIS/core_cm0plus.h **** 
 896:../CMSIS/core_cm0plus.h **** 
 897:../CMSIS/core_cm0plus.h **** /**
 898:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Vector
 899:../CMSIS/core_cm0plus.h ****   \details Reads an interrupt vector from interrupt vector table.
 900:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 901:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 902:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn      Interrupt number.
 903:../CMSIS/core_cm0plus.h ****   \return                 Address of interrupt handler function
 904:../CMSIS/core_cm0plus.h ****  */
 905:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
 906:../CMSIS/core_cm0plus.h **** {
 907:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 908:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
 909:../CMSIS/core_cm0plus.h **** #else
 910:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)0x0U;
 911:../CMSIS/core_cm0plus.h **** #endif
 912:../CMSIS/core_cm0plus.h ****   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
 913:../CMSIS/core_cm0plus.h **** 
 914:../CMSIS/core_cm0plus.h **** }
 915:../CMSIS/core_cm0plus.h **** 
 916:../CMSIS/core_cm0plus.h **** 
 917:../CMSIS/core_cm0plus.h **** /**
 918:../CMSIS/core_cm0plus.h ****   \brief   System Reset
 919:../CMSIS/core_cm0plus.h ****   \details Initiates a system reset request to reset the MCU.
 920:../CMSIS/core_cm0plus.h ****  */
 921:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SystemReset(void)
 922:../CMSIS/core_cm0plus.h **** {
 923:../CMSIS/core_cm0plus.h ****   __DSB();                                                          /* Ensure all outstanding memor
 924:../CMSIS/core_cm0plus.h ****                                                                        buffered write are completed
 925:../CMSIS/core_cm0plus.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 926:../CMSIS/core_cm0plus.h ****                  SCB_AIRCR_SYSRESETREQ_Msk);
 927:../CMSIS/core_cm0plus.h ****   __DSB();                                                          /* Ensure completion of memory 
 928:../CMSIS/core_cm0plus.h **** 
 929:../CMSIS/core_cm0plus.h ****   for(;;)                                                           /* wait until reset */
 930:../CMSIS/core_cm0plus.h ****   {
 931:../CMSIS/core_cm0plus.h ****     __NOP();
 932:../CMSIS/core_cm0plus.h ****   }
 933:../CMSIS/core_cm0plus.h **** }
 934:../CMSIS/core_cm0plus.h **** 
 935:../CMSIS/core_cm0plus.h **** /*@} end of CMSIS_Core_NVICFunctions */
 936:../CMSIS/core_cm0plus.h **** 
 937:../CMSIS/core_cm0plus.h **** /* ##########################  MPU functions  #################################### */
 938:../CMSIS/core_cm0plus.h **** 
 939:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 940:../CMSIS/core_cm0plus.h **** 
 941:../CMSIS/core_cm0plus.h **** #include "mpu_armv7.h"
 942:../CMSIS/core_cm0plus.h **** 
 943:../CMSIS/core_cm0plus.h **** #endif
 944:../CMSIS/core_cm0plus.h **** 
 945:../CMSIS/core_cm0plus.h **** /* ##########################  FPU functions  #################################### */
 946:../CMSIS/core_cm0plus.h **** /**
 947:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 948:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FpuFunctions FPU Functions
 949:../CMSIS/core_cm0plus.h ****   \brief    Function that provides FPU type.
 950:../CMSIS/core_cm0plus.h ****   @{
 951:../CMSIS/core_cm0plus.h ****  */
 952:../CMSIS/core_cm0plus.h **** 
 953:../CMSIS/core_cm0plus.h **** /**
 954:../CMSIS/core_cm0plus.h ****   \brief   get FPU type
 955:../CMSIS/core_cm0plus.h ****   \details returns the FPU type
 956:../CMSIS/core_cm0plus.h ****   \returns
 957:../CMSIS/core_cm0plus.h ****    - \b  0: No FPU
 958:../CMSIS/core_cm0plus.h ****    - \b  1: Single precision FPU
 959:../CMSIS/core_cm0plus.h ****    - \b  2: Double + Single precision FPU
 960:../CMSIS/core_cm0plus.h ****  */
 961:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t SCB_GetFPUType(void)
 962:../CMSIS/core_cm0plus.h **** {
 963:../CMSIS/core_cm0plus.h ****     return 0U;           /* No FPU */
 964:../CMSIS/core_cm0plus.h **** }
 965:../CMSIS/core_cm0plus.h **** 
 966:../CMSIS/core_cm0plus.h **** 
 967:../CMSIS/core_cm0plus.h **** /*@} end of CMSIS_Core_FpuFunctions */
 968:../CMSIS/core_cm0plus.h **** 
 969:../CMSIS/core_cm0plus.h **** 
 970:../CMSIS/core_cm0plus.h **** 
 971:../CMSIS/core_cm0plus.h **** /* ##################################    SysTick function  ########################################
 972:../CMSIS/core_cm0plus.h **** /**
 973:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 974:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
 975:../CMSIS/core_cm0plus.h ****   \brief    Functions that configure the System.
 976:../CMSIS/core_cm0plus.h ****   @{
 977:../CMSIS/core_cm0plus.h ****  */
 978:../CMSIS/core_cm0plus.h **** 
 979:../CMSIS/core_cm0plus.h **** #if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
 980:../CMSIS/core_cm0plus.h **** 
 981:../CMSIS/core_cm0plus.h **** /**
 982:../CMSIS/core_cm0plus.h ****   \brief   System Tick Configuration
 983:../CMSIS/core_cm0plus.h ****   \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
 984:../CMSIS/core_cm0plus.h ****            Counter is in free running mode to generate periodic interrupts.
 985:../CMSIS/core_cm0plus.h ****   \param [in]  ticks  Number of ticks between two interrupts.
 986:../CMSIS/core_cm0plus.h ****   \return          0  Function succeeded.
 987:../CMSIS/core_cm0plus.h ****   \return          1  Function failed.
 988:../CMSIS/core_cm0plus.h ****   \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
 989:../CMSIS/core_cm0plus.h ****            function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.
 990:../CMSIS/core_cm0plus.h ****            must contain a vendor-specific implementation of this function.
 991:../CMSIS/core_cm0plus.h ****  */
 992:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
 993:../CMSIS/core_cm0plus.h **** {
 994:../CMSIS/core_cm0plus.h ****   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 522              		.loc 2 994 0
 523 0028 BB4B     		ldr	r3, .L71+12
 524 002a 0138     		subs	r0, r0, #1
 525 002c 9842     		cmp	r0, r3
 526 002e 0DD8     		bhi	.L31
 527              	.LBB79:
 528              	.LBB80:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 529              		.loc 2 847 0
 530 0030 C021     		movs	r1, #192
 531              	.LBE80:
 532              	.LBE79:
 995:../CMSIS/core_cm0plus.h ****   {
 996:../CMSIS/core_cm0plus.h ****     return (1UL);                                                   /* Reload value impossible */
 997:../CMSIS/core_cm0plus.h ****   }
 998:../CMSIS/core_cm0plus.h **** 
 999:../CMSIS/core_cm0plus.h ****   SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 533              		.loc 2 999 0
 534 0032 BA4A     		ldr	r2, .L71+16
 535              	.LBB83:
 536              	.LBB81:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 537              		.loc 2 847 0
 538 0034 0906     		lsls	r1, r1, #24
 539              	.LBE81:
 540              	.LBE83:
 541              		.loc 2 999 0
 542 0036 5060     		str	r0, [r2, #4]
 543              	.LVL50:
 544              	.LBB84:
 545              	.LBB82:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 546              		.loc 2 847 0
 547 0038 B948     		ldr	r0, .L71+20
 548 003a 036A     		ldr	r3, [r0, #32]
 549 003c 1B02     		lsls	r3, r3, #8
 550 003e 1B0A     		lsrs	r3, r3, #8
 551 0040 0B43     		orrs	r3, r1
 552 0042 0362     		str	r3, [r0, #32]
 553              	.LVL51:
 554              	.LBE82:
 555              	.LBE84:
1000:../CMSIS/core_cm0plus.h ****   NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Int
1001:../CMSIS/core_cm0plus.h ****   SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Val
 556              		.loc 2 1001 0
 557 0044 0023     		movs	r3, #0
 558 0046 9360     		str	r3, [r2, #8]
1002:../CMSIS/core_cm0plus.h ****   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 559              		.loc 2 1002 0
 560 0048 0733     		adds	r3, r3, #7
 561 004a 1360     		str	r3, [r2]
 562              	.L31:
 563              	.LBE78:
 564              	.LBE77:
 202:../source/main.c **** 
 203:../source/main.c **** 	//initI2C();
 204:../source/main.c **** 	//initAdc();
 205:../source/main.c **** 	initUART();
 565              		.loc 1 205 0
 566 004c FFF7FEFF 		bl	initUART
 567              	.LVL52:
 206:../source/main.c **** 	//configure_acc();
 207:../source/main.c **** 	//acc_init();
 208:../source/main.c **** 	//initTimer();
 209:../source/main.c **** 
 210:../source/main.c **** 	static const gpio_pin_config_t LED_configOutput = { kGPIO_DigitalOutput, /* use as output pin */
 211:../source/main.c **** 	1, /* initial value */
 212:../source/main.c **** 	};
 213:../source/main.c **** 
 214:../source/main.c **** 
 215:../source/main.c **** 	/*
 216:../source/main.c **** 	SMC_SetPowerModeProtection(SMC, kSMC_AllowPowerModeVlls);
 217:../source/main.c **** 	smc_power_mode_vlls_config.subMode = kSMC_StopSub1; //!< Stop submode 1, for VLLS1/LLS1.
 218:../source/main.c **** 
 219:../source/main.c **** 	LLWU->ME |= 0x01; 		// enable LLWU wakeup source from LPTMR module
 220:../source/main.c **** 	LLWU->PE3 |= 0x01; // enable LLWU wakeup source from accelerometer interrupt pin
 221:../source/main.c **** 					   // 0x20 for stock frdm pin enable,
 222:../source/main.c **** 	LLWU->FILT1 |= 0x28;	// set pin wakeup from rising edge, 0x2A for frdm
 223:../source/main.c **** 
 224:../source/main.c **** 	//EnableIRQ(PORTC_IRQn);
 225:../source/main.c **** 
 226:../source/main.c **** 	LPTMR_EnableInterrupts(LPTMR0, LPTMR_CSR_TIE_MASK);	//Sets Timer Interrupt Enable bit to 1
 227:../source/main.c **** 	LPTMR_StartTimer(LPTMR0);
 228:../source/main.c **** */
 229:../source/main.c **** 	GPIO_PinInit(GPIOA, 4u, &LED_configOutput);	//blue led as output
 568              		.loc 1 229 0
 569 0050 B44A     		ldr	r2, .L71+24
 570 0052 0421     		movs	r1, #4
 571 0054 B448     		ldr	r0, .L71+28
 572 0056 FFF7FEFF 		bl	GPIO_PinInit
 573              	.LVL53:
 230:../source/main.c **** /*
 231:../source/main.c **** 	while(true) {
 232:../source/main.c **** 		GPIO_PortToggle(GPIOA, 1 << 4u);
 233:../source/main.c **** 		delay_ms(10);
 234:../source/main.c **** 	}*/
 235:../source/main.c **** 
 236:../source/main.c **** 	//delay_ms(2000);
 237:../source/main.c **** 	/*
 238:../source/main.c **** 	 * set boost regulator enable pin as output. This pin will control the power to RF modules
 239:../source/main.c **** 	 */
 240:../source/main.c **** 	//GPIO_PinInit(GPIOA, 1u, &LED_configOutput);
 241:../source/main.c **** 
 242:../source/main.c **** 	//GPIO_SetPinsOutput(GPIOA, 1 << 1u); //Power on RF modules
 243:../source/main.c **** 
 244:../source/main.c **** 	//fletcher8(PMC_set, 14);
 245:../source/main.c **** 	//fletcher8(ubx_cfg_prt, 7);
 246:../source/main.c **** 	//ubx_send(ubx_cfg_prt);
 247:../source/main.c **** 
 248:../source/main.c **** 	PCprint(
 574              		.loc 1 248 0
 575 005a B448     		ldr	r0, .L71+32
 576 005c FFF7FEFF 		bl	PCprint
 577              	.LVL54:
 249:../source/main.c **** 			"Reindeer IoT has started\r\nCommand \"iot\" to start executing reindeer track cycle\r\n"
 250:../source/main.c **** 					"Command \"gpsinfo=1\" or \"gpsinfo=0\" to switch GPS data on/off\r\n");
 251:../source/main.c **** 	PCprint(
 578              		.loc 1 251 0
 579 0060 B348     		ldr	r0, .L71+36
 580 0062 FFF7FEFF 		bl	PCprint
 581              	.LVL55:
 252:../source/main.c **** 			"Or enter normal AT commands here for SARA-N2\r\nModules powered on and booting now!\r\n");
 253:../source/main.c **** 
 254:../source/main.c **** 	/*
 255:../source/main.c **** 	 * Copy all reindeer variables to struct before starting network operations
 256:../source/main.c **** 	 */
 257:../source/main.c **** 	char testLat[11] = ("6500.53");
 582              		.loc 1 257 0
 583 0066 B34D     		ldr	r5, .L71+40
 584 0068 0822     		movs	r2, #8
 585 006a 2900     		movs	r1, r5
 586 006c 6846     		mov	r0, sp
 587 006e FFF7FEFF 		bl	memcpy
 588              	.LVL56:
 589 0072 0322     		movs	r2, #3
 590 0074 0021     		movs	r1, #0
 591 0076 02A8     		add	r0, sp, #8
 592 0078 FFF7FEFF 		bl	memset
 593              	.LVL57:
 258:../source/main.c **** 	char testLon[11] = ("02534.554");
 594              		.loc 1 258 0
 595 007c 2900     		movs	r1, r5
 596 007e 0A22     		movs	r2, #10
 597 0080 0B31     		adds	r1, r1, #11
 598 0082 03A8     		add	r0, sp, #12
 599 0084 FFF7FEFF 		bl	memcpy
 600              	.LVL58:
 601 0088 1623     		movs	r3, #22
 602 008a 0022     		movs	r2, #0
 603 008c 6B44     		add	r3, r3, sp
 259:../source/main.c **** 	strcpy(reindeerData.serialNum, "11111");
 604              		.loc 1 259 0
 605 008e AA49     		ldr	r1, .L71+44
 606 0090 09A8     		add	r0, sp, #36
 258:../source/main.c **** 	char testLon[11] = ("02534.554");
 607              		.loc 1 258 0
 608 0092 1A70     		strb	r2, [r3]
 609              		.loc 1 259 0
 610 0094 FFF7FEFF 		bl	strcpy
 611              	.LVL59:
 260:../source/main.c **** 	strcpy(reindeerData.latitude, testLat);
 612              		.loc 1 260 0
 613 0098 2A23     		movs	r3, #42
 614 009a 6B44     		add	r3, r3, sp
 615 009c 6946     		mov	r1, sp
 616 009e 1800     		movs	r0, r3
 617 00a0 FFF7FEFF 		bl	strcpy
 618              	.LVL60:
 261:../source/main.c **** 	strcpy(reindeerData.longitude, testLon);
 619              		.loc 1 261 0
 620 00a4 3623     		movs	r3, #54
 621 00a6 6B44     		add	r3, r3, sp
 622 00a8 03A9     		add	r1, sp, #12
 623 00aa 1800     		movs	r0, r3
 624 00ac FFF7FEFF 		bl	strcpy
 625              	.LVL61:
 262:../source/main.c **** 	strcpy(reindeerData.dead, "false");
 626              		.loc 1 262 0
 627 00b0 4223     		movs	r3, #66
 628 00b2 6B44     		add	r3, r3, sp
 629 00b4 1800     		movs	r0, r3
 630 00b6 A149     		ldr	r1, .L71+48
 631 00b8 FFF7FEFF 		bl	strcpy
 632              	.LVL62:
 263:../source/main.c **** 	reindeerData.batteryLevel = 45;
 633              		.loc 1 263 0
 634 00bc 2923     		movs	r3, #41
 635 00be 2D22     		movs	r2, #45
 636 00c0 6B44     		add	r3, r3, sp
 637 00c2 DA77     		strb	r2, [r3, #31]
 264:../source/main.c **** 	/*
 265:../source/main.c **** 	 while (true) {
 266:../source/main.c **** 
 267:../source/main.c **** 	 int16_t acc_val_x = read_acc_axis(0);
 268:../source/main.c **** 	 int16_t acc_val_y = read_acc_axis(1);
 269:../source/main.c **** 	 int16_t acc_val_z = read_acc_axis(2);
 270:../source/main.c **** 	 printf("Akseloreometer x: %d y: %d z: %d\r\n", acc_val_x, acc_val_y, acc_val_z);
 271:../source/main.c **** 	 delay_ms(500);
 272:../source/main.c **** 	 }
 273:../source/main.c **** 	 */
 274:../source/main.c **** 	if (wake == 2) {
 638              		.loc 1 274 0
 639 00c4 9E4B     		ldr	r3, .L71+52
 640 00c6 1B78     		ldrb	r3, [r3]
 641 00c8 022B     		cmp	r3, #2
 642 00ca 08D1     		bne	.L33
 275:../source/main.c **** 		printf("Woken by ACCEL, reindeer is !!!ALIVE!!!\r\n");
 643              		.loc 1 275 0
 644 00cc 9D48     		ldr	r0, .L71+56
 645 00ce FFF7FEFF 		bl	puts
 646              	.LVL63:
 276:../source/main.c **** 		SMC_PreEnterStopModes();
 647              		.loc 1 276 0
 648 00d2 FFF7FEFF 		bl	SMC_PreEnterStopModes
 649              	.LVL64:
 277:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 650              		.loc 1 277 0
 651 00d6 9C49     		ldr	r1, .L71+60
 652 00d8 9C48     		ldr	r0, .L71+64
 653 00da FFF7FEFF 		bl	SMC_SetPowerModeVlls
 654              	.LVL65:
 655              	.L33:
 278:../source/main.c **** 	}
 279:../source/main.c **** 
 280:../source/main.c **** 	while (1) {
 281:../source/main.c **** 
 282:../source/main.c **** 		//int16_t acc_val = read_acc_axis(0);
 283:../source/main.c **** 		//printf("Accelereometer %d\r\n",acc_val);
 284:../source/main.c **** 		//break;
 285:../source/main.c **** 		/*
 286:../source/main.c **** 		 * Check if a string has arrived from PC (with CR line end)
 287:../source/main.c **** 		 */
 288:../source/main.c **** 
 289:../source/main.c **** 		if (wake == 1) {
 656              		.loc 1 289 0
 657 00de 984B     		ldr	r3, .L71+52
 658 00e0 1B78     		ldrb	r3, [r3]
 659 00e2 012B     		cmp	r3, #1
 660 00e4 4CD1     		bne	.L34
 290:../source/main.c **** 			strcpy(reindeerData.dead, "true");
 661              		.loc 1 290 0
 662 00e6 4133     		adds	r3, r3, #65
 663 00e8 6B44     		add	r3, r3, sp
 664 00ea 9949     		ldr	r1, .L71+68
 665 00ec 1800     		movs	r0, r3
 666 00ee FFF7FEFF 		bl	strcpy
 667              	.LVL66:
 291:../source/main.c **** 			printf("Woken by LPTMR, reindeer is !!!%s!!\r\n",
 668              		.loc 1 291 0
 669 00f2 4223     		movs	r3, #66
 670 00f4 6B44     		add	r3, r3, sp
 671 00f6 1900     		movs	r1, r3
 672 00f8 9648     		ldr	r0, .L71+72
 673 00fa FFF7FEFF 		bl	printf
 674              	.LVL67:
 292:../source/main.c **** 					reindeerData.dead);
 293:../source/main.c **** 
 294:../source/main.c **** 			while (true) {
 295:../source/main.c **** 				if (GPS_strReady) {
 675              		.loc 1 295 0
 676 00fe 964A     		ldr	r2, .L71+76
 677              	.L35:
 678 0100 1378     		ldrb	r3, [r2]
 679 0102 002B     		cmp	r3, #0
 680 0104 FCD0     		beq	.L35
 681              	.LBB85:
 296:../source/main.c **** 					printf(GPS_recBuf);
 682              		.loc 1 296 0
 683 0106 9548     		ldr	r0, .L71+80
 684 0108 FFF7FEFF 		bl	printf
 685              	.LVL68:
 297:../source/main.c **** 					printf("\r\n"); //First print out whole buffer
 686              		.loc 1 297 0
 687 010c 9448     		ldr	r0, .L71+84
 688 010e FFF7FEFF 		bl	puts
 689              	.LVL69:
 298:../source/main.c **** 
 299:../source/main.c **** 					char testLat[12] = ("6500.02359");
 690              		.loc 1 299 0
 691 0112 2900     		movs	r1, r5
 692 0114 0B22     		movs	r2, #11
 693 0116 1631     		adds	r1, r1, #22
 694 0118 06A8     		add	r0, sp, #24
 695 011a FFF7FEFF 		bl	memcpy
 696              	.LVL70:
 697 011e 2323     		movs	r3, #35
 698 0120 0022     		movs	r2, #0
 699 0122 6B44     		add	r3, r3, sp
 700 0124 1A70     		strb	r2, [r3]
 300:../source/main.c **** 					char testLon[12] = ("02530.56951");
 701              		.loc 1 300 0
 702 0126 8F49     		ldr	r1, .L71+88
 703 0128 0C32     		adds	r2, r2, #12
 704 012a 13A8     		add	r0, sp, #76
 705 012c FFF7FEFF 		bl	memcpy
 706              	.LVL71:
 301:../source/main.c **** 
 302:../source/main.c **** 					strcpy(reindeerData.latitude, testLat);
 707              		.loc 1 302 0
 708 0130 2A23     		movs	r3, #42
 709 0132 6B44     		add	r3, r3, sp
 710 0134 06A9     		add	r1, sp, #24
 711 0136 1800     		movs	r0, r3
 712 0138 FFF7FEFF 		bl	strcpy
 713              	.LVL72:
 303:../source/main.c **** 					strcpy(reindeerData.longitude, testLon);
 714              		.loc 1 303 0
 715 013c 3623     		movs	r3, #54
 716 013e 6B44     		add	r3, r3, sp
 717 0140 13A9     		add	r1, sp, #76
 718 0142 1800     		movs	r0, r3
 719 0144 FFF7FEFF 		bl	strcpy
 720              	.LVL73:
 721              	.LBE85:
 304:../source/main.c **** 					break;
 305:../source/main.c **** 
 306:../source/main.c **** 					if (getGPS()) {
 307:../source/main.c **** 						//char testLat[12] = ("6500.02359");
 308:../source/main.c **** 						//char testLon[12] = ("02530.56951");
 309:../source/main.c **** 
 310:../source/main.c **** 						//parseData(testLat,testLon);
 311:../source/main.c **** 
 312:../source/main.c **** 						strcpy(reindeerData.latitude, parsedLat);
 313:../source/main.c **** 						strcpy(reindeerData.longitude, parsedLon);
 314:../source/main.c **** 						break;
 315:../source/main.c **** 					}
 316:../source/main.c **** 					memset(GPS_recBuf, 0, 600);
 317:../source/main.c **** 					GPS_bufPtr = 0;
 318:../source/main.c **** 					GPS_strReady = 0;
 319:../source/main.c **** 				}
 320:../source/main.c **** 
 321:../source/main.c **** 			}
 322:../source/main.c **** 			printf("Parsed latitude: %s\r\n", reindeerData.latitude);
 722              		.loc 1 322 0
 723 0148 2A23     		movs	r3, #42
 724 014a 6B44     		add	r3, r3, sp
 725 014c 1900     		movs	r1, r3
 726 014e 8648     		ldr	r0, .L71+92
 727 0150 FFF7FEFF 		bl	printf
 728              	.LVL74:
 323:../source/main.c **** 			printf("Parsed longitude: %s\r\n", reindeerData.longitude);
 729              		.loc 1 323 0
 730 0154 3623     		movs	r3, #54
 731 0156 6B44     		add	r3, r3, sp
 732 0158 1900     		movs	r1, r3
 733 015a 8448     		ldr	r0, .L71+96
 734 015c FFF7FEFF 		bl	printf
 735              	.LVL75:
 736              	.L36:
 324:../source/main.c **** 			break;
 325:../source/main.c **** 		}
 326:../source/main.c **** 
 327:../source/main.c **** 		if (PC_strReady) {
 328:../source/main.c **** 
 329:../source/main.c **** 			if (strstr(PC_recBuf, "iot") != NULL) {
 330:../source/main.c **** 				printf("Starting Reindeer IoT cycle\r\n");
 331:../source/main.c **** 				break;
 332:../source/main.c **** 			} else if (strstr(PC_recBuf, "gpsinfo=1") != NULL) {
 333:../source/main.c **** 				streamGps = 1;
 334:../source/main.c **** 			} else if (strstr(PC_recBuf, "gpsinfo=0") != NULL) {
 335:../source/main.c **** 				streamGps = 0;
 336:../source/main.c **** 			} else if (strstr(PC_recBuf, "rfoff") != NULL) {
 337:../source/main.c **** 				GPIO_ClearPinsOutput(GPIOB, 1 << 11u); //Power on RF modules
 338:../source/main.c **** 			} else if (strstr(PC_recBuf, "rfon") != NULL) {
 339:../source/main.c **** 				GPIO_SetPinsOutput(GPIOB, 1 << 11u); //Power on RF modules
 340:../source/main.c **** 			} else if (strstr(PC_recBuf, "\xb5\x62") != NULL) //if input is UBX command!
 341:../source/main.c **** 			{
 342:../source/main.c **** 				printf("send to gps\r\n");
 343:../source/main.c **** 				uint8_t ubxMsgLen = calcUbxCrc(PC_recBuf + 2); //Calculate UBX checksum and add it to the messa
 344:../source/main.c **** 				GPS_send(PC_recBuf, ubxMsgLen); //Send UBX message to module
 345:../source/main.c **** 			} else {
 346:../source/main.c **** 
 347:../source/main.c **** 				NB_send(PC_recBuf);
 348:../source/main.c **** 
 349:../source/main.c **** 			}
 350:../source/main.c **** 			memset(PC_recBuf, 0, strlen(PC_recBuf));
 351:../source/main.c **** 			PC_strReady = 0;
 352:../source/main.c **** 			PC_bufPtr = 0;
 353:../source/main.c **** 		}
 354:../source/main.c **** 
 355:../source/main.c **** 		if (NB_strReady) {
 356:../source/main.c **** 			moduleResponseTimeout = millis() + RESPONSE_TIMEOUT_NORMAL_VALUE; //reset timeout to initial val
 357:../source/main.c **** 
 358:../source/main.c **** 			while (millis() < moduleResponseTimeout)
 359:../source/main.c **** 
 360:../source/main.c **** 			{
 361:../source/main.c **** 
 362:../source/main.c **** 				if (breakIfAtOk()) {
 363:../source/main.c **** 					break;
 364:../source/main.c **** 				}
 365:../source/main.c **** 
 366:../source/main.c **** 			}
 367:../source/main.c **** 
 368:../source/main.c **** 			//now the timeout has expired since last character had arrived, so we can process data
 369:../source/main.c **** 
 370:../source/main.c **** 			printf(NB_recBuf);
 371:../source/main.c **** 			printf("\r\n");
 372:../source/main.c **** 			memset(NB_recBuf, 0, 500);
 373:../source/main.c **** 			NB_bufPtr = 0;
 374:../source/main.c **** 			NB_strReady = 0;
 375:../source/main.c **** 		}
 376:../source/main.c **** 
 377:../source/main.c **** 		/*
 378:../source/main.c **** 		 * If GPS string is ready and GPS data streaming is enabled, enter here to process GPS data buffe
 379:../source/main.c **** 		 */
 380:../source/main.c **** 		if (GPS_strReady && streamGps) {
 381:../source/main.c **** 
 382:../source/main.c **** 			//printf(GPS_recBuf);
 383:../source/main.c **** 			//printf("\r\n"); //First print out whole buffer
 384:../source/main.c **** 
 385:../source/main.c **** 			if (getGPS()) {
 386:../source/main.c **** 				//char testLat[12] = ("6500.02359");
 387:../source/main.c **** 				//char testLon[12] = ("02530.56951");
 388:../source/main.c **** 
 389:../source/main.c **** 				//parseData(testLat,testLon);
 390:../source/main.c **** 
 391:../source/main.c **** 				strcpy(reindeerData.latitude, parsedLat);
 392:../source/main.c **** 				strcpy(reindeerData.longitude, parsedLon);
 393:../source/main.c **** 				break;
 394:../source/main.c **** 			}
 395:../source/main.c **** 
 396:../source/main.c **** 			printf("Parsed latitude: %s\r\n", reindeerData.latitude);
 397:../source/main.c **** 			printf("Parsed longitude: %s\r\n", reindeerData.longitude);
 398:../source/main.c **** 
 399:../source/main.c **** 			char* ubxResponseStartPtr = strstr(GPS_recBuf, "\xb5\x62"); //Find pointer to UBX header. If the
 400:../source/main.c **** 																		//will be NULL
 401:../source/main.c **** 
 402:../source/main.c **** 			if (ubxResponseStartPtr != NULL) //If pointer is not null, it means UBX response header is found
 403:../source/main.c **** 			{
 404:../source/main.c **** 				printf("Found UBX response\r\n");
 405:../source/main.c **** 
 406:../source/main.c **** 				uint8_t responseLength = *(ubxResponseStartPtr + 4); //Find out UBX response length, it is alwa
 407:../source/main.c **** 																	 //from beginning of the packet. * means dereferencing pointer
 408:../source/main.c **** 				//dereferencing means "accessing the value where pointer points"
 409:../source/main.c **** 
 410:../source/main.c **** 				printf("UBX response length: %02x\r\n", responseLength);
 411:../source/main.c **** 
 412:../source/main.c **** 				printUbxResponseHex(ubxResponseStartPtr,
 413:../source/main.c **** 						responseLength + 6 + 2); //Print UBX response message. Function wants to know
 414:../source/main.c **** 				//how many chars to print. We must add 6+2 to print header and crc too
 415:../source/main.c **** 			}
 416:../source/main.c **** 
 417:../source/main.c **** 			memset(GPS_recBuf, 0, 600);
 418:../source/main.c **** 			GPS_bufPtr = 0;
 419:../source/main.c **** 			GPS_strReady = 0;
 420:../source/main.c **** 		}
 421:../source/main.c **** 
 422:../source/main.c **** 	}
 423:../source/main.c **** 
 424:../source/main.c **** 	/*
 425:../source/main.c **** 	 * Assemble data to json format and then to POST message
 426:../source/main.c **** 	 */
 427:../source/main.c **** 
 428:../source/main.c **** 	uint8_t msgLen = assembleMqtt(&reindeerData, mqttMessage);
 737              		.loc 1 428 0
 738 0160 13A9     		add	r1, sp, #76
 739 0162 09A8     		add	r0, sp, #36
 740 0164 FFF7FEFF 		bl	assembleMqtt
 741              	.LVL76:
 742 0168 0100     		movs	r1, r0
 743              	.LVL77:
 429:../source/main.c **** 
 430:../source/main.c **** 	//NB_send_msg(mqttMessage, msgLen);
 431:../source/main.c **** 
 432:../source/main.c **** 	NB_create_pdp_send(mqttMessage, msgLen);
 744              		.loc 1 432 0
 745 016a 13A8     		add	r0, sp, #76
 746 016c FFF7FEFF 		bl	NB_create_pdp_send
 747              	.LVL78:
 433:../source/main.c **** 	printf("Roger\r\n");
 748              		.loc 1 433 0
 749 0170 7F48     		ldr	r0, .L71+100
 750 0172 FFF7FEFF 		bl	puts
 751              	.LVL79:
 434:../source/main.c **** 	//parseData(testLat, testLon);
 435:../source/main.c **** }
 752              		.loc 1 435 0
 753 0176 0020     		movs	r0, #0
 754 0178 8523     		movs	r3, #133
 755 017a 9B00     		lsls	r3, r3, #2
 756 017c 9D44     		add	sp, sp, r3
 757              		@ sp needed
 758 017e F0BD     		pop	{r4, r5, r6, r7, pc}
 759              	.L34:
 327:../source/main.c **** 
 760              		.loc 1 327 0
 761 0180 7C4E     		ldr	r6, .L71+104
 762 0182 3378     		ldrb	r3, [r6]
 763 0184 002B     		cmp	r3, #0
 764 0186 20D0     		beq	.L37
 329:../source/main.c **** 				printf("Starting Reindeer IoT cycle\r\n");
 765              		.loc 1 329 0
 766 0188 7B4C     		ldr	r4, .L71+108
 767 018a 7C49     		ldr	r1, .L71+112
 768 018c 2000     		movs	r0, r4
 769 018e FFF7FEFF 		bl	strstr
 770              	.LVL80:
 771 0192 0028     		cmp	r0, #0
 772 0194 03D0     		beq	.L38
 330:../source/main.c **** 				break;
 773              		.loc 1 330 0
 774 0196 7A48     		ldr	r0, .L71+116
 775 0198 FFF7FEFF 		bl	puts
 776              	.LVL81:
 331:../source/main.c **** 			} else if (strstr(PC_recBuf, "gpsinfo=1") != NULL) {
 777              		.loc 1 331 0
 778 019c E0E7     		b	.L36
 779              	.L38:
 332:../source/main.c **** 				streamGps = 1;
 780              		.loc 1 332 0
 781 019e 7949     		ldr	r1, .L71+120
 782 01a0 2000     		movs	r0, r4
 783 01a2 FFF7FEFF 		bl	strstr
 784              	.LVL82:
 785 01a6 071E     		subs	r7, r0, #0
 786 01a8 4FD0     		beq	.L39
 333:../source/main.c **** 			} else if (strstr(PC_recBuf, "gpsinfo=0") != NULL) {
 787              		.loc 1 333 0
 788 01aa 0122     		movs	r2, #1
 789 01ac 764B     		ldr	r3, .L71+124
 790 01ae 1A70     		strb	r2, [r3]
 791              	.L40:
 350:../source/main.c **** 			PC_strReady = 0;
 792              		.loc 1 350 0
 793 01b0 714C     		ldr	r4, .L71+108
 794 01b2 2000     		movs	r0, r4
 795 01b4 FFF7FEFF 		bl	strlen
 796              	.LVL83:
 797 01b8 0021     		movs	r1, #0
 798 01ba 0200     		movs	r2, r0
 799 01bc 2000     		movs	r0, r4
 800 01be FFF7FEFF 		bl	memset
 801              	.LVL84:
 351:../source/main.c **** 			PC_bufPtr = 0;
 802              		.loc 1 351 0
 803 01c2 0023     		movs	r3, #0
 352:../source/main.c **** 		}
 804              		.loc 1 352 0
 805 01c4 714A     		ldr	r2, .L71+128
 351:../source/main.c **** 			PC_bufPtr = 0;
 806              		.loc 1 351 0
 807 01c6 3370     		strb	r3, [r6]
 352:../source/main.c **** 		}
 808              		.loc 1 352 0
 809 01c8 1380     		strh	r3, [r2]
 810              	.L37:
 355:../source/main.c **** 			moduleResponseTimeout = millis() + RESPONSE_TIMEOUT_NORMAL_VALUE; //reset timeout to initial val
 811              		.loc 1 355 0
 812 01ca 714C     		ldr	r4, .L71+132
 813 01cc 2378     		ldrb	r3, [r4]
 814 01ce 002B     		cmp	r3, #0
 815 01d0 20D0     		beq	.L45
 356:../source/main.c **** 
 816              		.loc 1 356 0
 817 01d2 FFF7FEFF 		bl	millis
 818              	.LVL85:
 819 01d6 FA23     		movs	r3, #250
 820 01d8 6E4E     		ldr	r6, .L71+136
 821 01da DB00     		lsls	r3, r3, #3
 822 01dc C018     		adds	r0, r0, r3
 823 01de 3060     		str	r0, [r6]
 824              	.L46:
 358:../source/main.c **** 
 825              		.loc 1 358 0
 826 01e0 FFF7FEFF 		bl	millis
 827              	.LVL86:
 828 01e4 3368     		ldr	r3, [r6]
 829 01e6 9842     		cmp	r0, r3
 830 01e8 03D2     		bcs	.L48
 362:../source/main.c **** 					break;
 831              		.loc 1 362 0
 832 01ea FFF7FEFF 		bl	breakIfAtOk
 833              	.LVL87:
 834 01ee 0028     		cmp	r0, #0
 835 01f0 F6D0     		beq	.L46
 836              	.L48:
 370:../source/main.c **** 			printf("\r\n");
 837              		.loc 1 370 0
 838 01f2 694E     		ldr	r6, .L71+140
 839 01f4 3000     		movs	r0, r6
 840 01f6 FFF7FEFF 		bl	printf
 841              	.LVL88:
 371:../source/main.c **** 			memset(NB_recBuf, 0, 500);
 842              		.loc 1 371 0
 843 01fa 5948     		ldr	r0, .L71+84
 844 01fc FFF7FEFF 		bl	puts
 845              	.LVL89:
 372:../source/main.c **** 			NB_bufPtr = 0;
 846              		.loc 1 372 0
 847 0200 FA22     		movs	r2, #250
 848 0202 0021     		movs	r1, #0
 849 0204 5200     		lsls	r2, r2, #1
 850 0206 3000     		movs	r0, r6
 851 0208 FFF7FEFF 		bl	memset
 852              	.LVL90:
 373:../source/main.c **** 			NB_strReady = 0;
 853              		.loc 1 373 0
 854 020c 0023     		movs	r3, #0
 855 020e 634A     		ldr	r2, .L71+144
 856 0210 1380     		strh	r3, [r2]
 374:../source/main.c **** 		}
 857              		.loc 1 374 0
 858 0212 2370     		strb	r3, [r4]
 859              	.L45:
 380:../source/main.c **** 
 860              		.loc 1 380 0
 861 0214 504B     		ldr	r3, .L71+76
 862 0216 1B78     		ldrb	r3, [r3]
 863 0218 002B     		cmp	r3, #0
 864 021a 00D1     		bne	.LCB762
 865 021c 5FE7     		b	.L33	@long jump
 866              	.LCB762:
 380:../source/main.c **** 
 867              		.loc 1 380 0 is_stmt 0 discriminator 1
 868 021e 5A4B     		ldr	r3, .L71+124
 869 0220 1B78     		ldrb	r3, [r3]
 870 0222 002B     		cmp	r3, #0
 871 0224 00D1     		bne	.LCB766
 872 0226 5AE7     		b	.L33	@long jump
 873              	.LCB766:
 874              	.LBB86:
 385:../source/main.c **** 				//char testLat[12] = ("6500.02359");
 875              		.loc 1 385 0 is_stmt 1
 876 0228 FFF7FEFF 		bl	getGPS
 877              	.LVL91:
 878 022c 0028     		cmp	r0, #0
 879 022e 40D0     		beq	.L50
 391:../source/main.c **** 				strcpy(reindeerData.longitude, parsedLon);
 880              		.loc 1 391 0
 881 0230 2A23     		movs	r3, #42
 882 0232 6B44     		add	r3, r3, sp
 883 0234 5A49     		ldr	r1, .L71+148
 884 0236 1800     		movs	r0, r3
 885 0238 FFF7FEFF 		bl	strcpy
 886              	.LVL92:
 392:../source/main.c **** 				break;
 887              		.loc 1 392 0
 888 023c 3623     		movs	r3, #54
 889 023e 6B44     		add	r3, r3, sp
 890 0240 5849     		ldr	r1, .L71+152
 891 0242 1800     		movs	r0, r3
 892 0244 FFF7FEFF 		bl	strcpy
 893              	.LVL93:
 393:../source/main.c **** 			}
 894              		.loc 1 393 0
 895 0248 8AE7     		b	.L36
 896              	.L39:
 897              	.LBE86:
 334:../source/main.c **** 				streamGps = 0;
 898              		.loc 1 334 0
 899 024a 5749     		ldr	r1, .L71+156
 900 024c 2000     		movs	r0, r4
 901 024e FFF7FEFF 		bl	strstr
 902              	.LVL94:
 903 0252 0028     		cmp	r0, #0
 904 0254 02D0     		beq	.L41
 335:../source/main.c **** 			} else if (strstr(PC_recBuf, "rfoff") != NULL) {
 905              		.loc 1 335 0
 906 0256 4C4B     		ldr	r3, .L71+124
 907 0258 1F70     		strb	r7, [r3]
 908 025a A9E7     		b	.L40
 909              	.L41:
 336:../source/main.c **** 				GPIO_ClearPinsOutput(GPIOB, 1 << 11u); //Power on RF modules
 910              		.loc 1 336 0
 911 025c 5349     		ldr	r1, .L71+160
 912 025e 2000     		movs	r0, r4
 913 0260 FFF7FEFF 		bl	strstr
 914              	.LVL95:
 915 0264 0028     		cmp	r0, #0
 916 0266 04D0     		beq	.L42
 917              	.LVL96:
 918              	.LBB88:
 919              	.LBB89:
 920              	.LBB90:
 921              		.file 5 "../drivers/fsl_gpio.h"
   1:../drivers/fsl_gpio.h **** /*
   2:../drivers/fsl_gpio.h ****  * The Clear BSD License
   3:../drivers/fsl_gpio.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_gpio.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_gpio.h ****  * All rights reserved.
   6:../drivers/fsl_gpio.h ****  *
   7:../drivers/fsl_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_gpio.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_gpio.h ****  * that the following conditions are met:
  10:../drivers/fsl_gpio.h ****  *
  11:../drivers/fsl_gpio.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_gpio.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_gpio.h ****  *
  14:../drivers/fsl_gpio.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_gpio.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_gpio.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_gpio.h ****  *
  18:../drivers/fsl_gpio.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_gpio.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_gpio.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_gpio.h ****  *
  22:../drivers/fsl_gpio.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_gpio.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_gpio.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_gpio.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_gpio.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_gpio.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_gpio.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_gpio.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_gpio.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_gpio.h ****  */
  34:../drivers/fsl_gpio.h **** 
  35:../drivers/fsl_gpio.h **** #ifndef _FSL_GPIO_H_
  36:../drivers/fsl_gpio.h **** #define _FSL_GPIO_H_
  37:../drivers/fsl_gpio.h **** 
  38:../drivers/fsl_gpio.h **** #include "fsl_common.h"
  39:../drivers/fsl_gpio.h **** 
  40:../drivers/fsl_gpio.h **** /*!
  41:../drivers/fsl_gpio.h ****  * @addtogroup gpio
  42:../drivers/fsl_gpio.h ****  * @{
  43:../drivers/fsl_gpio.h ****  */
  44:../drivers/fsl_gpio.h **** 
  45:../drivers/fsl_gpio.h **** /*******************************************************************************
  46:../drivers/fsl_gpio.h ****  * Definitions
  47:../drivers/fsl_gpio.h ****  ******************************************************************************/
  48:../drivers/fsl_gpio.h **** 
  49:../drivers/fsl_gpio.h **** /*! @name Driver version */
  50:../drivers/fsl_gpio.h **** /*@{*/
  51:../drivers/fsl_gpio.h **** /*! @brief GPIO driver version 2.2.1. */
  52:../drivers/fsl_gpio.h **** #define FSL_GPIO_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  53:../drivers/fsl_gpio.h **** /*@}*/
  54:../drivers/fsl_gpio.h **** 
  55:../drivers/fsl_gpio.h **** /*! @brief GPIO direction definition */
  56:../drivers/fsl_gpio.h **** typedef enum _gpio_pin_direction
  57:../drivers/fsl_gpio.h **** {
  58:../drivers/fsl_gpio.h ****     kGPIO_DigitalInput = 0U,  /*!< Set current pin as digital input*/
  59:../drivers/fsl_gpio.h ****     kGPIO_DigitalOutput = 1U, /*!< Set current pin as digital output*/
  60:../drivers/fsl_gpio.h **** } gpio_pin_direction_t;
  61:../drivers/fsl_gpio.h **** 
  62:../drivers/fsl_gpio.h **** #if defined(FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER
  63:../drivers/fsl_gpio.h **** /*! @brief GPIO checker attribute */
  64:../drivers/fsl_gpio.h **** typedef enum _gpio_checker_attribute
  65:../drivers/fsl_gpio.h **** {
  66:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRWUsersecureRWPrivilegedsecureRW =
  67:../drivers/fsl_gpio.h ****         0x00U, /*!< User nonsecure:Read+Write; User Secure:Read+Write; Privileged Secure:Read+Write
  68:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRUsersecureRWPrivilegedsecureRW =
  69:../drivers/fsl_gpio.h ****         0x01U, /*!< User nonsecure:Read;       User Secure:Read+Write; Privileged Secure:Read+Write
  70:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureRWPrivilegedsecureRW =
  71:../drivers/fsl_gpio.h ****         0x02U, /*!< User nonsecure:None;       User Secure:Read+Write; Privileged Secure:Read+Write
  72:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRUsersecureRPrivilegedsecureRW =
  73:../drivers/fsl_gpio.h ****         0x03U, /*!< User nonsecure:Read;       User Secure:Read;       Privileged Secure:Read+Write
  74:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureRPrivilegedsecureRW =
  75:../drivers/fsl_gpio.h ****         0x04U, /*!< User nonsecure:None;       User Secure:Read;       Privileged Secure:Read+Write
  76:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureRW =
  77:../drivers/fsl_gpio.h ****         0x05U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:Read+Write
  78:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureR =
  79:../drivers/fsl_gpio.h ****         0x06U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:Read */
  80:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureN =
  81:../drivers/fsl_gpio.h ****         0x07U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:None */
  82:../drivers/fsl_gpio.h ****     kGPIO_IgnoreAttributeCheck = 0x80U, /*!< Ignores the attribute check */
  83:../drivers/fsl_gpio.h **** } gpio_checker_attribute_t;
  84:../drivers/fsl_gpio.h **** #endif
  85:../drivers/fsl_gpio.h **** 
  86:../drivers/fsl_gpio.h **** /*!
  87:../drivers/fsl_gpio.h ****  * @brief The GPIO pin configuration structure.
  88:../drivers/fsl_gpio.h ****  *
  89:../drivers/fsl_gpio.h ****  * Each pin can only be configured as either an output pin or an input pin at a time.
  90:../drivers/fsl_gpio.h ****  * If configured as an input pin, leave the outputConfig unused.
  91:../drivers/fsl_gpio.h ****  * Note that in some use cases, the corresponding port property should be configured in advance
  92:../drivers/fsl_gpio.h ****  *        with the PORT_SetPinConfig().
  93:../drivers/fsl_gpio.h ****  */
  94:../drivers/fsl_gpio.h **** typedef struct _gpio_pin_config
  95:../drivers/fsl_gpio.h **** {
  96:../drivers/fsl_gpio.h ****     gpio_pin_direction_t pinDirection; /*!< GPIO direction, input or output */
  97:../drivers/fsl_gpio.h ****     /* Output configurations; ignore if configured as an input pin */
  98:../drivers/fsl_gpio.h ****     uint8_t outputLogic; /*!< Set a default output logic, which has no use in input */
  99:../drivers/fsl_gpio.h **** } gpio_pin_config_t;
 100:../drivers/fsl_gpio.h **** 
 101:../drivers/fsl_gpio.h **** /*! @} */
 102:../drivers/fsl_gpio.h **** 
 103:../drivers/fsl_gpio.h **** /*******************************************************************************
 104:../drivers/fsl_gpio.h ****  * API
 105:../drivers/fsl_gpio.h ****  ******************************************************************************/
 106:../drivers/fsl_gpio.h **** 
 107:../drivers/fsl_gpio.h **** #if defined(__cplusplus)
 108:../drivers/fsl_gpio.h **** extern "C" {
 109:../drivers/fsl_gpio.h **** #endif
 110:../drivers/fsl_gpio.h **** 
 111:../drivers/fsl_gpio.h **** /*!
 112:../drivers/fsl_gpio.h ****  * @addtogroup gpio_driver
 113:../drivers/fsl_gpio.h ****  * @{
 114:../drivers/fsl_gpio.h ****  */
 115:../drivers/fsl_gpio.h **** 
 116:../drivers/fsl_gpio.h **** /*! @name GPIO Configuration */
 117:../drivers/fsl_gpio.h **** /*@{*/
 118:../drivers/fsl_gpio.h **** 
 119:../drivers/fsl_gpio.h **** /*!
 120:../drivers/fsl_gpio.h ****  * @brief Initializes a GPIO pin used by the board.
 121:../drivers/fsl_gpio.h ****  *
 122:../drivers/fsl_gpio.h ****  * To initialize the GPIO, define a pin configuration, as either input or output, in the user file.
 123:../drivers/fsl_gpio.h ****  * Then, call the GPIO_PinInit() function.
 124:../drivers/fsl_gpio.h ****  *
 125:../drivers/fsl_gpio.h ****  * This is an example to define an input pin or an output pin configuration.
 126:../drivers/fsl_gpio.h ****  * @code
 127:../drivers/fsl_gpio.h ****  * // Define a digital input pin configuration,
 128:../drivers/fsl_gpio.h ****  * gpio_pin_config_t config =
 129:../drivers/fsl_gpio.h ****  * {
 130:../drivers/fsl_gpio.h ****  *   kGPIO_DigitalInput,
 131:../drivers/fsl_gpio.h ****  *   0,
 132:../drivers/fsl_gpio.h ****  * }
 133:../drivers/fsl_gpio.h ****  * //Define a digital output pin configuration,
 134:../drivers/fsl_gpio.h ****  * gpio_pin_config_t config =
 135:../drivers/fsl_gpio.h ****  * {
 136:../drivers/fsl_gpio.h ****  *   kGPIO_DigitalOutput,
 137:../drivers/fsl_gpio.h ****  *   0,
 138:../drivers/fsl_gpio.h ****  * }
 139:../drivers/fsl_gpio.h ****  * @endcode
 140:../drivers/fsl_gpio.h ****  *
 141:../drivers/fsl_gpio.h ****  * @param base   GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 142:../drivers/fsl_gpio.h ****  * @param pin    GPIO port pin number
 143:../drivers/fsl_gpio.h ****  * @param config GPIO pin configuration pointer
 144:../drivers/fsl_gpio.h ****  */
 145:../drivers/fsl_gpio.h **** void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config);
 146:../drivers/fsl_gpio.h **** 
 147:../drivers/fsl_gpio.h **** /*@}*/
 148:../drivers/fsl_gpio.h **** 
 149:../drivers/fsl_gpio.h **** /*! @name GPIO Output Operations */
 150:../drivers/fsl_gpio.h **** /*@{*/
 151:../drivers/fsl_gpio.h **** 
 152:../drivers/fsl_gpio.h **** /*!
 153:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1 or 0.
 154:../drivers/fsl_gpio.h ****  *
 155:../drivers/fsl_gpio.h ****  * @param base    GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 156:../drivers/fsl_gpio.h ****  * @param pin     GPIO pin number
 157:../drivers/fsl_gpio.h ****  * @param output  GPIO pin output logic level.
 158:../drivers/fsl_gpio.h ****  *        - 0: corresponding pin output low-logic level.
 159:../drivers/fsl_gpio.h ****  *        - 1: corresponding pin output high-logic level.
 160:../drivers/fsl_gpio.h ****  */
 161:../drivers/fsl_gpio.h **** static inline void GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)
 162:../drivers/fsl_gpio.h **** {
 163:../drivers/fsl_gpio.h ****     if (output == 0U)
 164:../drivers/fsl_gpio.h ****     {
 165:../drivers/fsl_gpio.h ****         base->PCOR = 1U << pin;
 166:../drivers/fsl_gpio.h ****     }
 167:../drivers/fsl_gpio.h ****     else
 168:../drivers/fsl_gpio.h ****     {
 169:../drivers/fsl_gpio.h ****         base->PSOR = 1U << pin;
 170:../drivers/fsl_gpio.h ****     }
 171:../drivers/fsl_gpio.h **** }
 172:../drivers/fsl_gpio.h **** 
 173:../drivers/fsl_gpio.h **** /*!
 174:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1 or 0.
 175:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PinWrite.
 176:../drivers/fsl_gpio.h ****  */
 177:../drivers/fsl_gpio.h **** static inline void GPIO_WritePinOutput(GPIO_Type *base, uint32_t pin, uint8_t output)
 178:../drivers/fsl_gpio.h **** {
 179:../drivers/fsl_gpio.h ****     GPIO_PinWrite(base, pin, output);
 180:../drivers/fsl_gpio.h **** }
 181:../drivers/fsl_gpio.h **** 
 182:../drivers/fsl_gpio.h **** /*!
 183:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1.
 184:../drivers/fsl_gpio.h ****  *
 185:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 186:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 187:../drivers/fsl_gpio.h ****  */
 188:../drivers/fsl_gpio.h **** static inline void GPIO_PortSet(GPIO_Type *base, uint32_t mask)
 189:../drivers/fsl_gpio.h **** {
 190:../drivers/fsl_gpio.h ****     base->PSOR = mask;
 191:../drivers/fsl_gpio.h **** }
 192:../drivers/fsl_gpio.h **** 
 193:../drivers/fsl_gpio.h **** /*!
 194:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1.
 195:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PortSet.
 196:../drivers/fsl_gpio.h ****  */
 197:../drivers/fsl_gpio.h **** static inline void GPIO_SetPinsOutput(GPIO_Type *base, uint32_t mask)
 198:../drivers/fsl_gpio.h **** {
 199:../drivers/fsl_gpio.h ****     GPIO_PortSet(base, mask);
 200:../drivers/fsl_gpio.h **** }
 201:../drivers/fsl_gpio.h **** 
 202:../drivers/fsl_gpio.h **** /*!
 203:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 0.
 204:../drivers/fsl_gpio.h ****  *
 205:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 206:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 207:../drivers/fsl_gpio.h ****  */
 208:../drivers/fsl_gpio.h **** static inline void GPIO_PortClear(GPIO_Type *base, uint32_t mask)
 209:../drivers/fsl_gpio.h **** {
 210:../drivers/fsl_gpio.h ****     base->PCOR = mask;
 922              		.loc 5 210 0
 923 0268 8022     		movs	r2, #128
 924 026a 514B     		ldr	r3, .L71+164
 925 026c 1201     		lsls	r2, r2, #4
 926 026e 9A60     		str	r2, [r3, #8]
 927              	.LVL97:
 928 0270 9EE7     		b	.L40
 929              	.LVL98:
 930              	.L42:
 931              	.LBE90:
 932              	.LBE89:
 933              	.LBE88:
 338:../source/main.c **** 				GPIO_SetPinsOutput(GPIOB, 1 << 11u); //Power on RF modules
 934              		.loc 1 338 0
 935 0272 5049     		ldr	r1, .L71+168
 936 0274 2000     		movs	r0, r4
 937 0276 FFF7FEFF 		bl	strstr
 938              	.LVL99:
 939 027a 0028     		cmp	r0, #0
 940 027c 04D0     		beq	.L43
 941              	.LVL100:
 942              	.LBB91:
 943              	.LBB92:
 944              	.LBB93:
 190:../drivers/fsl_gpio.h **** }
 945              		.loc 5 190 0
 946 027e 8022     		movs	r2, #128
 947 0280 4B4B     		ldr	r3, .L71+164
 948 0282 1201     		lsls	r2, r2, #4
 949 0284 5A60     		str	r2, [r3, #4]
 950              	.LVL101:
 951 0286 93E7     		b	.L40
 952              	.LVL102:
 953              	.L43:
 954              	.LBE93:
 955              	.LBE92:
 956              	.LBE91:
 340:../source/main.c **** 			{
 957              		.loc 1 340 0
 958 0288 4B49     		ldr	r1, .L71+172
 959 028a 2000     		movs	r0, r4
 960 028c FFF7FEFF 		bl	strstr
 961              	.LVL103:
 962 0290 0028     		cmp	r0, #0
 963 0292 0AD0     		beq	.L44
 964              	.LBB94:
 342:../source/main.c **** 				uint8_t ubxMsgLen = calcUbxCrc(PC_recBuf + 2); //Calculate UBX checksum and add it to the messa
 965              		.loc 1 342 0
 966 0294 4948     		ldr	r0, .L71+176
 967 0296 FFF7FEFF 		bl	puts
 968              	.LVL104:
 343:../source/main.c **** 				GPS_send(PC_recBuf, ubxMsgLen); //Send UBX message to module
 969              		.loc 1 343 0
 970 029a 4948     		ldr	r0, .L71+180
 971 029c FFF7FEFF 		bl	calcUbxCrc
 972              	.LVL105:
 973 02a0 0100     		movs	r1, r0
 974              	.LVL106:
 344:../source/main.c **** 			} else {
 975              		.loc 1 344 0
 976 02a2 2000     		movs	r0, r4
 977 02a4 FFF7FEFF 		bl	GPS_send
 978              	.LVL107:
 979              	.LBE94:
 980 02a8 82E7     		b	.L40
 981              	.L44:
 347:../source/main.c **** 
 982              		.loc 1 347 0
 983 02aa 2000     		movs	r0, r4
 984 02ac FFF7FEFF 		bl	NB_send
 985              	.LVL108:
 986 02b0 7EE7     		b	.L40
 987              	.L50:
 988              	.LBB95:
 396:../source/main.c **** 			printf("Parsed longitude: %s\r\n", reindeerData.longitude);
 989              		.loc 1 396 0
 990 02b2 2A23     		movs	r3, #42
 991 02b4 6B44     		add	r3, r3, sp
 992 02b6 1900     		movs	r1, r3
 993 02b8 2B48     		ldr	r0, .L71+92
 994 02ba FFF7FEFF 		bl	printf
 995              	.LVL109:
 397:../source/main.c **** 
 996              		.loc 1 397 0
 997 02be 3623     		movs	r3, #54
 998 02c0 6B44     		add	r3, r3, sp
 999 02c2 1900     		movs	r1, r3
 1000 02c4 2948     		ldr	r0, .L71+96
 1001 02c6 FFF7FEFF 		bl	printf
 1002              	.LVL110:
 399:../source/main.c **** 																		//will be NULL
 1003              		.loc 1 399 0
 1004 02ca 244F     		ldr	r7, .L71+80
 1005 02cc 3A49     		ldr	r1, .L71+172
 1006 02ce 3800     		movs	r0, r7
 1007 02d0 FFF7FEFF 		bl	strstr
 1008              	.LVL111:
 1009 02d4 061E     		subs	r6, r0, #0
 1010              	.LVL112:
 402:../source/main.c **** 			{
 1011              		.loc 1 402 0
 1012 02d6 0DD0     		beq	.L51
 1013              	.LBB87:
 404:../source/main.c **** 
 1014              		.loc 1 404 0
 1015 02d8 3A48     		ldr	r0, .L71+184
 1016              	.LVL113:
 1017 02da FFF7FEFF 		bl	puts
 1018              	.LVL114:
 406:../source/main.c **** 																	 //from beginning of the packet. * means dereferencing pointer
 1019              		.loc 1 406 0
 1020 02de 3479     		ldrb	r4, [r6, #4]
 1021              	.LVL115:
 410:../source/main.c **** 
 1022              		.loc 1 410 0
 1023 02e0 3948     		ldr	r0, .L71+188
 1024 02e2 2100     		movs	r1, r4
 1025 02e4 FFF7FEFF 		bl	printf
 1026              	.LVL116:
 412:../source/main.c **** 						responseLength + 6 + 2); //Print UBX response message. Function wants to know
 1027              		.loc 1 412 0
 1028 02e8 2100     		movs	r1, r4
 1029 02ea 0831     		adds	r1, r1, #8
 1030 02ec C9B2     		uxtb	r1, r1
 1031 02ee 3000     		movs	r0, r6
 1032 02f0 FFF7FEFF 		bl	printUbxResponseHex
 1033              	.LVL117:
 1034              	.L51:
 1035              	.LBE87:
 417:../source/main.c **** 			GPS_bufPtr = 0;
 1036              		.loc 1 417 0
 1037 02f4 9622     		movs	r2, #150
 1038 02f6 0021     		movs	r1, #0
 1039 02f8 9200     		lsls	r2, r2, #2
 1040 02fa 3800     		movs	r0, r7
 1041 02fc FFF7FEFF 		bl	memset
 1042              	.LVL118:
 418:../source/main.c **** 			GPS_strReady = 0;
 1043              		.loc 1 418 0
 1044 0300 0023     		movs	r3, #0
 1045 0302 324A     		ldr	r2, .L71+192
 1046 0304 1380     		strh	r3, [r2]
 419:../source/main.c **** 		}
 1047              		.loc 1 419 0
 1048 0306 144A     		ldr	r2, .L71+76
 1049 0308 1370     		strb	r3, [r2]
 1050 030a E8E6     		b	.L33
 1051              	.L72:
 1052              		.align	2
 1053              	.L71:
 1054 030c ECFDFFFF 		.word	-532
 1055 0310 581B0000 		.word	7000
 1056 0314 00000000 		.word	ms_ticks
 1057 0318 FFFFFF00 		.word	16777215
 1058 031c 10E000E0 		.word	-536813552
 1059 0320 00ED00E0 		.word	-536810240
 1060 0324 00000000 		.word	.LANCHOR0
 1061 0328 00F00F40 		.word	1074786304
 1062 032c 00000000 		.word	.LC6
 1063 0330 90000000 		.word	.LC8
 1064 0334 00000000 		.word	.LANCHOR1
 1065 0338 E4000000 		.word	.LC13
 1066 033c EA000000 		.word	.LC15
 1067 0340 00000000 		.word	.LANCHOR2
 1068 0344 F0000000 		.word	.LC18
 1069 0348 00000000 		.word	smc_power_mode_vlls_config
 1070 034c 00E00740 		.word	1074257920
 1071 0350 19010000 		.word	.LC21
 1072 0354 1E010000 		.word	.LC23
 1073 0358 00000000 		.word	.LANCHOR3
 1074 035c 00000000 		.word	GPS_recBuf
 1075 0360 44010000 		.word	.LC27
 1076 0364 FA010000 		.word	.LC30
 1077 0368 46010000 		.word	.LC32
 1078 036c 5C010000 		.word	.LC34
 1079 0370 F3010000 		.word	.LC68
 1080 0374 00000000 		.word	.LANCHOR4
 1081 0378 00000000 		.word	PC_recBuf
 1082 037c 73010000 		.word	.LC37
 1083 0380 77010000 		.word	.LC40
 1084 0384 94010000 		.word	.LC42
 1085 0388 00000000 		.word	.LANCHOR5
 1086 038c 00000000 		.word	.LANCHOR6
 1087 0390 00000000 		.word	.LANCHOR7
 1088 0394 00000000 		.word	.LANCHOR8
 1089 0398 00000000 		.word	NB_recBuf
 1090 039c 00000000 		.word	.LANCHOR9
 1091 03a0 00000000 		.word	parsedLat
 1092 03a4 00000000 		.word	parsedLon
 1093 03a8 9E010000 		.word	.LC45
 1094 03ac A8010000 		.word	.LC47
 1095 03b0 40F00F40 		.word	1074786368
 1096 03b4 AE010000 		.word	.LC49
 1097 03b8 B3010000 		.word	.LC51
 1098 03bc B6010000 		.word	.LC53
 1099 03c0 02000000 		.word	PC_recBuf+2
 1100 03c4 C3010000 		.word	.LC63
 1101 03c8 D7010000 		.word	.LC65
 1102 03cc 00000000 		.word	.LANCHOR10
 1103              	.LBE95:
 1104              		.cfi_endproc
 1105              	.LFE130:
 1107              		.section	.text.LLWU_IRQHandler,"ax",%progbits
 1108              		.align	1
 1109              		.global	LLWU_IRQHandler
 1110              		.syntax unified
 1111              		.code	16
 1112              		.thumb_func
 1113              		.fpu softvfp
 1115              	LLWU_IRQHandler:
 1116              	.LFB131:
 436:../source/main.c **** /*
 437:../source/main.c ****  void PORTC_IRQHandler() {
 438:../source/main.c **** 
 439:../source/main.c ****  PORTC->PCR[6] |= 0x01000000;
 440:../source/main.c **** 
 441:../source/main.c ****  while ( PORTC->PCR[6] & 0x01000000) {
 442:../source/main.c **** 
 443:../source/main.c ****  }
 444:../source/main.c **** 
 445:../source/main.c ****  LPTMR_Deinit(LPTMR0);			// Deinitiate timer to reset timer counte
 446:../source/main.c ****  LPTMR_Init(LPTMR0, &lptmr_config);
 447:../source/main.c ****  LPTMR_SetTimerPeriod(LPTMR0, 2000);  // 3000 for 20hz data rat
 448:../source/main.c ****  LPTMR_EnableInterrupts(LPTMR0, LPTMR_CSR_TIE_MASK);	//Sets Timer Interrupt Enable bit to 1
 449:../source/main.c ****  LPTMR_StartTimer(LPTMR0);
 450:../source/main.c ****  GPIO_PortToggle(GPIOB, 1 << 22u);
 451:../source/main.c **** 
 452:../source/main.c ****  }
 453:../source/main.c ****  */
 454:../source/main.c **** void LLWU_IRQHandler() {
 1117              		.loc 1 454 0
 1118              		.cfi_startproc
 1119              		@ args = 0, pretend = 0, frame = 0
 1120              		@ frame_needed = 0, uses_anonymous_args = 0
 1121              		@ link register save eliminated.
 455:../source/main.c **** 
 456:../source/main.c **** 	if ( LLWU->F3 & 0x01) {	// 1 = LPTMR interrupt, 2 = Accel interrupt, 0 = No interrupts
 1122              		.loc 1 456 0
 1123 0000 0122     		movs	r2, #1
 1124 0002 0E4B     		ldr	r3, .L79
 1125 0004 D979     		ldrb	r1, [r3, #7]
 1126 0006 1142     		tst	r1, r2
 1127 0008 0DD0     		beq	.L74
 457:../source/main.c **** 		wake = 1;
 1128              		.loc 1 457 0
 1129 000a 0D49     		ldr	r1, .L79+4
 1130              	.LBB98:
 1131              	.LBB99:
 450:../drivers/fsl_clock.h **** }
 1132              		.loc 4 450 0
 1133 000c 0D48     		ldr	r0, .L79+8
 1134              	.LBE99:
 1135              	.LBE98:
 1136              		.loc 1 457 0
 1137 000e 0A70     		strb	r2, [r1]
 1138              	.LVL119:
 1139              	.LBB101:
 1140              	.LBB100:
 450:../drivers/fsl_clock.h **** }
 1141              		.loc 4 450 0
 1142 0010 0168     		ldr	r1, [r0]
 1143 0012 0A43     		orrs	r2, r1
 1144 0014 0260     		str	r2, [r0]
 1145              	.LVL120:
 1146              	.LBE100:
 1147              	.LBE101:
 458:../source/main.c **** 		CLOCK_EnableClock(kCLOCK_Lptmr0);
 459:../source/main.c **** 		LPTMR0->CSR |= LPTMR_CSR_TCF_MASK;
 1148              		.loc 1 459 0
 1149 0016 8022     		movs	r2, #128
 1150 0018 0B49     		ldr	r1, .L79+12
 1151 001a 0868     		ldr	r0, [r1]
 1152 001c 0243     		orrs	r2, r0
 1153 001e 0A60     		str	r2, [r1]
 1154              	.L75:
 460:../source/main.c **** 
 461:../source/main.c **** 	}
 462:../source/main.c **** 
 463:../source/main.c **** 	else if ( LLWU->F2 & 0x01) {// 0x04 for stock frdm acc wakeup reg, 0x01 for customized
 464:../source/main.c **** 		wake = 2;
 465:../source/main.c **** 		LLWU->F2 |= 0x01;
 466:../source/main.c **** 	}
 467:../source/main.c **** 
 468:../source/main.c **** 	LLWU->F2 = 0x01;
 1155              		.loc 1 468 0
 1156 0020 0122     		movs	r2, #1
 469:../source/main.c **** }
 1157              		.loc 1 469 0
 1158              		@ sp needed
 468:../source/main.c **** }
 1159              		.loc 1 468 0
 1160 0022 9A71     		strb	r2, [r3, #6]
 1161              		.loc 1 469 0
 1162 0024 7047     		bx	lr
 1163              	.L74:
 463:../source/main.c **** 		wake = 2;
 1164              		.loc 1 463 0
 1165 0026 9979     		ldrb	r1, [r3, #6]
 1166 0028 1142     		tst	r1, r2
 1167 002a F9D0     		beq	.L75
 464:../source/main.c **** 		LLWU->F2 |= 0x01;
 1168              		.loc 1 464 0
 1169 002c 0220     		movs	r0, #2
 1170 002e 0449     		ldr	r1, .L79+4
 1171 0030 0870     		strb	r0, [r1]
 465:../source/main.c **** 	}
 1172              		.loc 1 465 0
 1173 0032 9979     		ldrb	r1, [r3, #6]
 1174 0034 0A43     		orrs	r2, r1
 1175 0036 9A71     		strb	r2, [r3, #6]
 1176 0038 F2E7     		b	.L75
 1177              	.L80:
 1178 003a C046     		.align	2
 1179              	.L79:
 1180 003c 00C00740 		.word	1074249728
 1181 0040 00000000 		.word	.LANCHOR2
 1182 0044 38800440 		.word	1074036792
 1183 0048 00000440 		.word	1074003968
 1184              		.cfi_endproc
 1185              	.LFE131:
 1187              		.section	.text.LPTMR0_IRQHandler,"ax",%progbits
 1188              		.align	1
 1189              		.global	LPTMR0_IRQHandler
 1190              		.syntax unified
 1191              		.code	16
 1192              		.thumb_func
 1193              		.fpu softvfp
 1195              	LPTMR0_IRQHandler:
 1196              	.LFB132:
 470:../source/main.c **** 
 471:../source/main.c **** void LPTMR0_IRQHandler() {
 1197              		.loc 1 471 0
 1198              		.cfi_startproc
 1199              		@ args = 0, pretend = 0, frame = 0
 1200              		@ frame_needed = 0, uses_anonymous_args = 0
 1201              		@ link register save eliminated.
 472:../source/main.c **** 
 473:../source/main.c **** 	LPTMR0->CSR |= LPTMR_CSR_TCF_MASK;		// Clear the interrupt flag
 1202              		.loc 1 473 0
 1203 0000 8022     		movs	r2, #128
 1204 0002 084B     		ldr	r3, .L84
 1205 0004 1968     		ldr	r1, [r3]
 1206 0006 1143     		orrs	r1, r2
 1207 0008 1960     		str	r1, [r3]
 1208              	.L82:
 474:../source/main.c **** 	while ( LPTMR0->CSR & LPTMR_CSR_TCF_MASK) {
 1209              		.loc 1 474 0 discriminator 1
 1210 000a 1968     		ldr	r1, [r3]
 1211 000c 1142     		tst	r1, r2
 1212 000e FCD1     		bne	.L82
 475:../source/main.c **** 
 476:../source/main.c **** 	}
 477:../source/main.c **** 
 478:../source/main.c **** 	PMC->REGSC |= 0x08;
 1213              		.loc 1 478 0
 1214 0010 0823     		movs	r3, #8
 1215 0012 054A     		ldr	r2, .L84+4
 479:../source/main.c **** 
 480:../source/main.c **** 	GPIO_PortToggle(GPIOB, 1 << 21u); //light blue LED
 481:../source/main.c **** }
 1216              		.loc 1 481 0
 1217              		@ sp needed
 478:../source/main.c **** 
 1218              		.loc 1 478 0
 1219 0014 9178     		ldrb	r1, [r2, #2]
 1220 0016 0B43     		orrs	r3, r1
 1221 0018 9370     		strb	r3, [r2, #2]
 1222              	.LVL121:
 1223              	.LBB102:
 1224              	.LBB103:
 211:../drivers/fsl_gpio.h **** }
 212:../drivers/fsl_gpio.h **** 
 213:../drivers/fsl_gpio.h **** /*!
 214:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 0.
 215:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PortClear.
 216:../drivers/fsl_gpio.h ****  *
 217:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 218:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 219:../drivers/fsl_gpio.h ****  */
 220:../drivers/fsl_gpio.h **** static inline void GPIO_ClearPinsOutput(GPIO_Type *base, uint32_t mask)
 221:../drivers/fsl_gpio.h **** {
 222:../drivers/fsl_gpio.h ****     GPIO_PortClear(base, mask);
 223:../drivers/fsl_gpio.h **** }
 224:../drivers/fsl_gpio.h **** 
 225:../drivers/fsl_gpio.h **** /*!
 226:../drivers/fsl_gpio.h ****  * @brief Reverses the current output logic of the multiple GPIO pins.
 227:../drivers/fsl_gpio.h ****  *
 228:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 229:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 230:../drivers/fsl_gpio.h ****  */
 231:../drivers/fsl_gpio.h **** static inline void GPIO_PortToggle(GPIO_Type *base, uint32_t mask)
 232:../drivers/fsl_gpio.h **** {
 233:../drivers/fsl_gpio.h ****     base->PTOR = mask;
 1225              		.loc 5 233 0
 1226 001a 8022     		movs	r2, #128
 1227 001c 034B     		ldr	r3, .L84+8
 1228 001e 9203     		lsls	r2, r2, #14
 1229 0020 DA60     		str	r2, [r3, #12]
 1230              	.LVL122:
 1231              	.LBE103:
 1232              	.LBE102:
 1233              		.loc 1 481 0
 1234 0022 7047     		bx	lr
 1235              	.L85:
 1236              		.align	2
 1237              	.L84:
 1238 0024 00000440 		.word	1074003968
 1239 0028 00D00740 		.word	1074253824
 1240 002c 40F00F40 		.word	1074786368
 1241              		.cfi_endproc
 1242              	.LFE132:
 1244              		.section	.text.LPUART0_IRQHandler,"ax",%progbits
 1245              		.align	1
 1246              		.global	LPUART0_IRQHandler
 1247              		.syntax unified
 1248              		.code	16
 1249              		.thumb_func
 1250              		.fpu softvfp
 1252              	LPUART0_IRQHandler:
 1253              	.LFB133:
 482:../source/main.c **** 
 483:../source/main.c **** void LPUART0_IRQHandler () {
 1254              		.loc 1 483 0
 1255              		.cfi_startproc
 1256              		@ args = 0, pretend = 0, frame = 0
 1257              		@ frame_needed = 0, uses_anonymous_args = 0
 1258 0000 10B5     		push	{r4, lr}
 1259              		.cfi_def_cfa_offset 8
 1260              		.cfi_offset 4, -8
 1261              		.cfi_offset 14, -4
 484:../source/main.c **** 
 485:../source/main.c **** 	LPUART_ClearStatusFlags(LPUART0, kUART_RxDataRegFullFlag);
 1262              		.loc 1 485 0
 1263 0002 0D4C     		ldr	r4, .L90
 1264 0004 2021     		movs	r1, #32
 1265 0006 2000     		movs	r0, r4
 1266 0008 FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1267              	.LVL123:
 1268              	.LBB104:
 1269              	.LBB105:
 1270              		.loc 5 233 0
 1271 000c 8022     		movs	r2, #128
 1272 000e 0B4B     		ldr	r3, .L90+4
 1273 0010 D203     		lsls	r2, r2, #15
 1274 0012 DA60     		str	r2, [r3, #12]
 1275              	.LVL124:
 1276              	.LBE105:
 1277              	.LBE104:
 486:../source/main.c **** 	GPIO_PortToggle(GPIOB, 1 << 22u); //toggle RED led to indicate data arrived from NB Iiootee module
 487:../source/main.c **** 
 488:../source/main.c **** 	uint8_t uartData = LPUART0->DATA;
 1278              		.loc 1 488 0
 1279 0014 E368     		ldr	r3, [r4, #12]
 1280 0016 D9B2     		uxtb	r1, r3
 1281              	.LVL125:
 489:../source/main.c **** 	if (uartData != 0) {
 1282              		.loc 1 489 0
 1283 0018 0029     		cmp	r1, #0
 1284 001a 0CD0     		beq	.L86
 490:../source/main.c **** 
 491:../source/main.c **** 		NB_recBuf[NB_bufPtr] = uartData;
 1285              		.loc 1 491 0
 1286 001c 084A     		ldr	r2, .L90+8
 1287 001e 094C     		ldr	r4, .L90+12
 1288 0020 1088     		ldrh	r0, [r2]
 1289 0022 2354     		strb	r3, [r4, r0]
 492:../source/main.c **** 		NB_bufPtr++;
 1290              		.loc 1 492 0
 1291 0024 1388     		ldrh	r3, [r2]
 1292 0026 0133     		adds	r3, r3, #1
 1293 0028 9BB2     		uxth	r3, r3
 1294 002a 1380     		strh	r3, [r2]
 493:../source/main.c **** 
 494:../source/main.c **** 		if (uartData == 0x0d) {
 1295              		.loc 1 494 0
 1296 002c 0D29     		cmp	r1, #13
 1297 002e 02D1     		bne	.L86
 495:../source/main.c **** 			NB_strReady = 1;
 1298              		.loc 1 495 0
 1299 0030 0122     		movs	r2, #1
 1300 0032 054B     		ldr	r3, .L90+16
 1301 0034 1A70     		strb	r2, [r3]
 1302              	.L86:
 496:../source/main.c **** 			//NB_bufPtr = 0;
 497:../source/main.c **** 		}
 498:../source/main.c **** 
 499:../source/main.c **** 	}
 500:../source/main.c **** 
 501:../source/main.c **** }
 1303              		.loc 1 501 0
 1304              		@ sp needed
 1305 0036 10BD     		pop	{r4, pc}
 1306              	.L91:
 1307              		.align	2
 1308              	.L90:
 1309 0038 00400540 		.word	1074085888
 1310 003c 40F00F40 		.word	1074786368
 1311 0040 00000000 		.word	.LANCHOR9
 1312 0044 00000000 		.word	NB_recBuf
 1313 0048 00000000 		.word	.LANCHOR7
 1314              		.cfi_endproc
 1315              	.LFE133:
 1317              		.section	.text.UART2_FLEXIO_IRQHandler,"ax",%progbits
 1318              		.align	1
 1319              		.global	UART2_FLEXIO_IRQHandler
 1320              		.syntax unified
 1321              		.code	16
 1322              		.thumb_func
 1323              		.fpu softvfp
 1325              	UART2_FLEXIO_IRQHandler:
 1326              	.LFB134:
 502:../source/main.c **** 
 503:../source/main.c **** void UART2_FLEXIO_IRQHandler() {
 1327              		.loc 1 503 0
 1328              		.cfi_startproc
 1329              		@ args = 0, pretend = 0, frame = 0
 1330              		@ frame_needed = 0, uses_anonymous_args = 0
 1331 0000 10B5     		push	{r4, lr}
 1332              		.cfi_def_cfa_offset 8
 1333              		.cfi_offset 4, -8
 1334              		.cfi_offset 14, -4
 504:../source/main.c **** 
 505:../source/main.c **** 	UART_ClearStatusFlags(UART2, kUART_RxDataRegFullFlag);
 1335              		.loc 1 505 0
 1336 0002 104C     		ldr	r4, .L95
 1337 0004 2021     		movs	r1, #32
 1338 0006 2000     		movs	r0, r4
 1339 0008 FFF7FEFF 		bl	UART_ClearStatusFlags
 1340              	.LVL126:
 1341              	.LBB106:
 1342              	.LBB107:
 1343              		.loc 5 233 0
 1344 000c 8022     		movs	r2, #128
 1345 000e 0E4B     		ldr	r3, .L95+4
 1346 0010 D203     		lsls	r2, r2, #15
 1347              	.LBE107:
 1348              	.LBE106:
 506:../source/main.c **** 	GPIO_PortToggle(GPIOB, 1 << 22u); //toggle RED led to indicate data arrived from GPS module
 507:../source/main.c **** 
 508:../source/main.c **** 	uint8_t uartData = UART2->D;
 509:../source/main.c **** 
 510:../source/main.c **** 	/*
 511:../source/main.c **** 	 * Here we use different method for collecting GPS data. because there can be other data than char
 512:../source/main.c **** 	 * like 0x00 in UBX messages, normal string functions would fail (mistaken null terminator)
 513:../source/main.c **** 	 * so we must collect every byte from the gps module
 514:../source/main.c **** 	 * so fill buffer to almost full with GPS data, then put GPS_strReady high and stop filling.
 515:../source/main.c **** 	 * Start filling again when data has been read and GPS_strReady is low.
 516:../source/main.c **** 	 *
 517:../source/main.c **** 	 */
 518:../source/main.c **** 	if (GPS_strReady == 0) {
 1349              		.loc 1 518 0
 1350 0012 0E49     		ldr	r1, .L95+8
 1351              	.LBB109:
 1352              	.LBB108:
 1353              		.loc 5 233 0
 1354 0014 DA60     		str	r2, [r3, #12]
 1355              	.LVL127:
 1356              	.LBE108:
 1357              	.LBE109:
 508:../source/main.c **** 
 1358              		.loc 1 508 0
 1359 0016 E379     		ldrb	r3, [r4, #7]
 1360              		.loc 1 518 0
 1361 0018 0878     		ldrb	r0, [r1]
 508:../source/main.c **** 
 1362              		.loc 1 508 0
 1363 001a DBB2     		uxtb	r3, r3
 1364              	.LVL128:
 1365 001c 0C4A     		ldr	r2, .L95+12
 1366              		.loc 1 518 0
 1367 001e 0028     		cmp	r0, #0
 1368 0020 06D1     		bne	.L93
 519:../source/main.c **** 		GPS_recBuf[GPS_bufPtr] = uartData; //put new byte to buffer
 1369              		.loc 1 519 0
 1370 0022 1088     		ldrh	r0, [r2]
 1371 0024 0B4C     		ldr	r4, .L95+16
 1372 0026 2354     		strb	r3, [r4, r0]
 520:../source/main.c **** 		GPS_bufPtr++;
 1373              		.loc 1 520 0
 1374 0028 1388     		ldrh	r3, [r2]
 1375              	.LVL129:
 1376 002a 0133     		adds	r3, r3, #1
 1377 002c 9BB2     		uxth	r3, r3
 1378 002e 1380     		strh	r3, [r2]
 1379              	.LVL130:
 1380              	.L93:
 521:../source/main.c **** 	}
 522:../source/main.c **** 
 523:../source/main.c **** 	/*
 524:../source/main.c **** 	 * When buffer is almost full, put strReady high and stop filling it
 525:../source/main.c **** 	 */
 526:../source/main.c **** 	if (GPS_bufPtr > 499) {
 1381              		.loc 1 526 0
 1382 0030 F423     		movs	r3, #244
 1383 0032 1288     		ldrh	r2, [r2]
 1384 0034 FF33     		adds	r3, r3, #255
 1385 0036 9A42     		cmp	r2, r3
 1386 0038 02D9     		bls	.L92
 527:../source/main.c **** 		GPS_strReady = 1;
 1387              		.loc 1 527 0
 1388 003a F33B     		subs	r3, r3, #243
 1389 003c FF3B     		subs	r3, r3, #255
 1390 003e 0B70     		strb	r3, [r1]
 1391              	.L92:
 528:../source/main.c **** 	}
 529:../source/main.c **** 
 530:../source/main.c **** }
 1392              		.loc 1 530 0
 1393              		@ sp needed
 1394 0040 10BD     		pop	{r4, pc}
 1395              	.L96:
 1396 0042 C046     		.align	2
 1397              	.L95:
 1398 0044 00C00640 		.word	1074184192
 1399 0048 40F00F40 		.word	1074786368
 1400 004c 00000000 		.word	.LANCHOR3
 1401 0050 00000000 		.word	.LANCHOR10
 1402 0054 00000000 		.word	GPS_recBuf
 1403              		.cfi_endproc
 1404              	.LFE134:
 1406              		.section	.text.LPUART1_IRQHandler,"ax",%progbits
 1407              		.align	1
 1408              		.global	LPUART1_IRQHandler
 1409              		.syntax unified
 1410              		.code	16
 1411              		.thumb_func
 1412              		.fpu softvfp
 1414              	LPUART1_IRQHandler:
 1415              	.LFB135:
 531:../source/main.c **** 
 532:../source/main.c **** void LPUART1_IRQHandler() {
 1416              		.loc 1 532 0
 1417              		.cfi_startproc
 1418              		@ args = 0, pretend = 0, frame = 0
 1419              		@ frame_needed = 0, uses_anonymous_args = 0
 1420              		@ link register save eliminated.
 533:../source/main.c **** 
 534:../source/main.c **** 	uint8_t uartData = LPUART1->DATA;
 535:../source/main.c **** 	//GPIO_PortToggle(GPIOB, 1 << 21u); //toggle BLUE led to indicate data arrived from computer
 536:../source/main.c **** 
 537:../source/main.c **** 	PC_recBuf[PC_bufPtr] = uartData;
 1421              		.loc 1 537 0
 1422 0000 094A     		ldr	r2, .L99
 534:../source/main.c **** 	//GPIO_PortToggle(GPIOB, 1 << 21u); //toggle BLUE led to indicate data arrived from computer
 1423              		.loc 1 534 0
 1424 0002 0A4B     		ldr	r3, .L99+4
 1425              		.loc 1 537 0
 1426 0004 0A48     		ldr	r0, .L99+8
 534:../source/main.c **** 	//GPIO_PortToggle(GPIOB, 1 << 21u); //toggle BLUE led to indicate data arrived from computer
 1427              		.loc 1 534 0
 1428 0006 D968     		ldr	r1, [r3, #12]
 1429              	.LVL131:
 1430              		.loc 1 537 0
 1431 0008 1388     		ldrh	r3, [r2]
 1432 000a C154     		strb	r1, [r0, r3]
 538:../source/main.c **** 	PC_bufPtr++;
 1433              		.loc 1 538 0
 1434 000c 1388     		ldrh	r3, [r2]
 539:../source/main.c **** 
 540:../source/main.c **** 	if (uartData == 0x0a) {
 1435              		.loc 1 540 0
 1436 000e C9B2     		uxtb	r1, r1
 538:../source/main.c **** 	PC_bufPtr++;
 1437              		.loc 1 538 0
 1438 0010 0133     		adds	r3, r3, #1
 1439 0012 9BB2     		uxth	r3, r3
 1440 0014 1380     		strh	r3, [r2]
 1441              		.loc 1 540 0
 1442 0016 0A29     		cmp	r1, #10
 1443 0018 04D1     		bne	.L97
 541:../source/main.c **** 		PC_strReady = 1;
 1444              		.loc 1 541 0
 1445 001a 064B     		ldr	r3, .L99+12
 1446 001c 0939     		subs	r1, r1, #9
 1447              	.LVL132:
 1448 001e 1970     		strb	r1, [r3]
 542:../source/main.c **** 		PC_bufPtr = 0;
 1449              		.loc 1 542 0
 1450 0020 0023     		movs	r3, #0
 1451 0022 1380     		strh	r3, [r2]
 1452              	.LVL133:
 1453              	.L97:
 543:../source/main.c **** 
 544:../source/main.c **** 	}
 545:../source/main.c **** }
 1454              		.loc 1 545 0
 1455              		@ sp needed
 1456 0024 7047     		bx	lr
 1457              	.L100:
 1458 0026 C046     		.align	2
 1459              	.L99:
 1460 0028 00000000 		.word	.LANCHOR6
 1461 002c 00500540 		.word	1074089984
 1462 0030 00000000 		.word	PC_recBuf
 1463 0034 00000000 		.word	.LANCHOR4
 1464              		.cfi_endproc
 1465              	.LFE135:
 1467              		.comm	ms_ticks,4,4
 1468              		.global	moduleResponseTimeout
 1469              		.comm	parsedLon,15,1
 1470              		.comm	parsedLat,15,1
 1471              		.global	streamGps
 1472              		.global	GPS_strReady
 1473              		.global	GPS_bufPtr
 1474              		.comm	GPS_recBuf,600,1
 1475              		.global	PC_strReady
 1476              		.global	PC_bufPtr
 1477              		.comm	NB_recBuf,500,1
 1478              		.global	NB_bufPtr
 1479              		.global	NB_strReady
 1480              		.global	wake
 1481              		.comm	uart_config,8,4
 1482              		.comm	smc_power_mode_vlls_config,2,1
 1483              		.comm	lptmr_config,7,1
 1484              		.section	.rodata
 1485              		.set	.LANCHOR1,. + 0
 1486              	.LC10:
 1487 0000 36353030 		.ascii	"6500.53\000"
 1487      2E353300 
 1488 0008 000000   		.space	3
 1489              	.LC12:
 1490 000b 30323533 		.ascii	"02534.554\000"
 1490      342E3535 
 1490      3400
 1491 0015 00       		.space	1
 1492              	.LC29:
 1493 0016 36353030 		.ascii	"6500.02359\000"
 1493      2E303233 
 1493      353900
 1494 0021 00       		.space	1
 1495              		.section	.bss.GPS_bufPtr,"aw",%nobits
 1496              		.align	1
 1497              		.set	.LANCHOR10,. + 0
 1500              	GPS_bufPtr:
 1501 0000 0000     		.space	2
 1502              		.section	.bss.GPS_strReady,"aw",%nobits
 1503              		.set	.LANCHOR3,. + 0
 1506              	GPS_strReady:
 1507 0000 00       		.space	1
 1508              		.section	.bss.NB_bufPtr,"aw",%nobits
 1509              		.align	1
 1510              		.set	.LANCHOR9,. + 0
 1513              	NB_bufPtr:
 1514 0000 0000     		.space	2
 1515              		.section	.bss.NB_strReady,"aw",%nobits
 1516              		.set	.LANCHOR7,. + 0
 1519              	NB_strReady:
 1520 0000 00       		.space	1
 1521              		.section	.bss.PC_bufPtr,"aw",%nobits
 1522              		.align	1
 1523              		.set	.LANCHOR6,. + 0
 1526              	PC_bufPtr:
 1527 0000 0000     		.space	2
 1528              		.section	.bss.PC_recBuf,"aw",%nobits
 1531              	PC_recBuf:
 1532 0000 00000000 		.space	500
 1532      00000000 
 1532      00000000 
 1532      00000000 
 1532      00000000 
 1533              		.section	.bss.PC_strReady,"aw",%nobits
 1534              		.set	.LANCHOR4,. + 0
 1537              	PC_strReady:
 1538 0000 00       		.space	1
 1539              		.section	.bss.streamGps,"aw",%nobits
 1540              		.set	.LANCHOR5,. + 0
 1543              	streamGps:
 1544 0000 00       		.space	1
 1545              		.section	.data.moduleResponseTimeout,"aw",%progbits
 1546              		.align	2
 1547              		.set	.LANCHOR8,. + 0
 1550              	moduleResponseTimeout:
 1551 0000 D0070000 		.word	2000
 1552              		.section	.data.wake,"aw",%progbits
 1553              		.set	.LANCHOR2,. + 0
 1556              	wake:
 1557 0000 02       		.byte	2
 1558              		.section	.rodata.LED_configOutput.8110,"a",%progbits
 1559              		.set	.LANCHOR0,. + 0
 1562              	LED_configOutput.8110:
 1563 0000 01       		.byte	1
 1564 0001 01       		.byte	1
 1565              		.section	.rodata.main.str1.1,"aMS",%progbits,1
 1566              	.LC6:
 1567 0000 5265696E 		.ascii	"Reindeer IoT has started\015\012Command \"iot\" to "
 1567      64656572 
 1567      20496F54 
 1567      20686173 
 1567      20737461 
 1568 002b 73746172 		.ascii	"start executing reindeer track cycle\015\012Command"
 1568      74206578 
 1568      65637574 
 1568      696E6720 
 1568      7265696E 
 1569 0058 20226770 		.ascii	" \"gpsinfo=1\" or \"gpsinfo=0\" to switch GPS data "
 1569      73696E66 
 1569      6F3D3122 
 1569      206F7220 
 1569      22677073 
 1570 0087 6F6E2F6F 		.ascii	"on/off\015\012\000"
 1570      66660D0A 
 1570      00
 1571              	.LC8:
 1572 0090 4F722065 		.ascii	"Or enter normal AT commands here for SARA-N2\015\012"
 1572      6E746572 
 1572      206E6F72 
 1572      6D616C20 
 1572      41542063 
 1573 00be 4D6F6475 		.ascii	"Modules powered on and booting now!\015\012\000"
 1573      6C657320 
 1573      706F7765 
 1573      72656420 
 1573      6F6E2061 
 1574              	.LC13:
 1575 00e4 31313131 		.ascii	"11111\000"
 1575      3100
 1576              	.LC15:
 1577 00ea 66616C73 		.ascii	"false\000"
 1577      6500
 1578              	.LC18:
 1579 00f0 576F6B65 		.ascii	"Woken by ACCEL, reindeer is !!!ALIVE!!!\015\000"
 1579      6E206279 
 1579      20414343 
 1579      454C2C20 
 1579      7265696E 
 1580              	.LC21:
 1581 0119 74727565 		.ascii	"true\000"
 1581      00
 1582              	.LC23:
 1583 011e 576F6B65 		.ascii	"Woken by LPTMR, reindeer is !!!%s!!\015\012\000"
 1583      6E206279 
 1583      204C5054 
 1583      4D522C20 
 1583      7265696E 
 1584              	.LC27:
 1585 0144 0D00     		.ascii	"\015\000"
 1586              	.LC32:
 1587 0146 50617273 		.ascii	"Parsed latitude: %s\015\012\000"
 1587      6564206C 
 1587      61746974 
 1587      7564653A 
 1587      2025730D 
 1588              	.LC34:
 1589 015c 50617273 		.ascii	"Parsed longitude: %s\015\012\000"
 1589      6564206C 
 1589      6F6E6769 
 1589      74756465 
 1589      3A202573 
 1590              	.LC37:
 1591 0173 696F7400 		.ascii	"iot\000"
 1592              	.LC40:
 1593 0177 53746172 		.ascii	"Starting Reindeer IoT cycle\015\000"
 1593      74696E67 
 1593      20526569 
 1593      6E646565 
 1593      7220496F 
 1594              	.LC42:
 1595 0194 67707369 		.ascii	"gpsinfo=1\000"
 1595      6E666F3D 
 1595      3100
 1596              	.LC45:
 1597 019e 67707369 		.ascii	"gpsinfo=0\000"
 1597      6E666F3D 
 1597      3000
 1598              	.LC47:
 1599 01a8 72666F66 		.ascii	"rfoff\000"
 1599      6600
 1600              	.LC49:
 1601 01ae 72666F6E 		.ascii	"rfon\000"
 1601      00
 1602              	.LC51:
 1603 01b3 B56200   		.ascii	"\265b\000"
 1604              	.LC53:
 1605 01b6 73656E64 		.ascii	"send to gps\015\000"
 1605      20746F20 
 1605      6770730D 
 1605      00
 1606              	.LC63:
 1607 01c3 466F756E 		.ascii	"Found UBX response\015\000"
 1607      64205542 
 1607      58207265 
 1607      73706F6E 
 1607      73650D00 
 1608              	.LC65:
 1609 01d7 55425820 		.ascii	"UBX response length: %02x\015\012\000"
 1609      72657370 
 1609      6F6E7365 
 1609      206C656E 
 1609      6774683A 
 1610              	.LC68:
 1611 01f3 526F6765 		.ascii	"Roger\015\000"
 1611      720D00
 1612              	.LC30:
 1613 01fa 30323533 		.ascii	"02530.56951\000"
 1613      302E3536 
 1613      39353100 
 1614              		.text
 1615              	.Letext0:
 1616              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1617              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1618              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1619              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1620              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1621              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1622              		.file 12 "../CMSIS/MKL17Z4.h"
 1623              		.file 13 "../CMSIS/system_MKL17Z4.h"
 1624              		.file 14 "../drivers/fsl_common.h"
 1625              		.file 15 "../board/clock_config.h"
 1626              		.file 16 "../drivers/fsl_uart.h"
 1627              		.file 17 "../drivers/fsl_smc.h"
 1628              		.file 18 "../source/at_func.h"
 1629              		.file 19 "../drivers/fsl_lpuart.h"
 1630              		.file 20 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 1631              		.file 21 "../source/gps_func.h"
 1632              		.file 22 "../source/nbiot_func.h"
 1633              		.file 23 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdio.h"
 1634              		.file 24 "<built-in>"
 1635              		.file 25 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/string.h"
 1636              		.file 26 "../board/pin_mux.h"
 1637              		.file 27 "../source/timing.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccAbAM54.s:16     .text.initTimer:0000000000000000 $t
     /tmp/ccAbAM54.s:23     .text.initTimer:0000000000000000 initTimer
     /tmp/ccAbAM54.s:101    .text.initTimer:000000000000002c $d
                            *COM*:0000000000000007 lptmr_config
     /tmp/ccAbAM54.s:109    .text.initUART:0000000000000000 $t
     /tmp/ccAbAM54.s:116    .text.initUART:0000000000000000 initUART
     /tmp/ccAbAM54.s:270    .text.initUART:000000000000009c $d
                            *COM*:0000000000000008 uart_config
     /tmp/ccAbAM54.s:283    .text.NB_send:0000000000000000 $t
     /tmp/ccAbAM54.s:290    .text.NB_send:0000000000000000 NB_send
     /tmp/ccAbAM54.s:342    .text.NB_send:0000000000000024 $d
     /tmp/ccAbAM54.s:347    .text.GPS_send:0000000000000000 $t
     /tmp/ccAbAM54.s:354    .text.GPS_send:0000000000000000 GPS_send
     /tmp/ccAbAM54.s:410    .text.GPS_send:0000000000000028 $d
     /tmp/ccAbAM54.s:415    .text.PCprint:0000000000000000 $t
     /tmp/ccAbAM54.s:422    .text.PCprint:0000000000000000 PCprint
     /tmp/ccAbAM54.s:470    .text.PCprint:0000000000000024 $d
     /tmp/ccAbAM54.s:476    .text.startup.main:0000000000000000 $t
     /tmp/ccAbAM54.s:483    .text.startup.main:0000000000000000 main
     /tmp/ccAbAM54.s:1054   .text.startup.main:000000000000030c $d
                            *COM*:0000000000000004 ms_ticks
                            *COM*:0000000000000002 smc_power_mode_vlls_config
                            *COM*:0000000000000258 GPS_recBuf
     /tmp/ccAbAM54.s:1531   .bss.PC_recBuf:0000000000000000 PC_recBuf
                            *COM*:00000000000001f4 NB_recBuf
                            *COM*:000000000000000f parsedLat
                            *COM*:000000000000000f parsedLon
     /tmp/ccAbAM54.s:1108   .text.LLWU_IRQHandler:0000000000000000 $t
     /tmp/ccAbAM54.s:1115   .text.LLWU_IRQHandler:0000000000000000 LLWU_IRQHandler
     /tmp/ccAbAM54.s:1180   .text.LLWU_IRQHandler:000000000000003c $d
     /tmp/ccAbAM54.s:1188   .text.LPTMR0_IRQHandler:0000000000000000 $t
     /tmp/ccAbAM54.s:1195   .text.LPTMR0_IRQHandler:0000000000000000 LPTMR0_IRQHandler
     /tmp/ccAbAM54.s:1238   .text.LPTMR0_IRQHandler:0000000000000024 $d
     /tmp/ccAbAM54.s:1245   .text.LPUART0_IRQHandler:0000000000000000 $t
     /tmp/ccAbAM54.s:1252   .text.LPUART0_IRQHandler:0000000000000000 LPUART0_IRQHandler
     /tmp/ccAbAM54.s:1309   .text.LPUART0_IRQHandler:0000000000000038 $d
     /tmp/ccAbAM54.s:1318   .text.UART2_FLEXIO_IRQHandler:0000000000000000 $t
     /tmp/ccAbAM54.s:1325   .text.UART2_FLEXIO_IRQHandler:0000000000000000 UART2_FLEXIO_IRQHandler
     /tmp/ccAbAM54.s:1398   .text.UART2_FLEXIO_IRQHandler:0000000000000044 $d
     /tmp/ccAbAM54.s:1407   .text.LPUART1_IRQHandler:0000000000000000 $t
     /tmp/ccAbAM54.s:1414   .text.LPUART1_IRQHandler:0000000000000000 LPUART1_IRQHandler
     /tmp/ccAbAM54.s:1460   .text.LPUART1_IRQHandler:0000000000000028 $d
     /tmp/ccAbAM54.s:1550   .data.moduleResponseTimeout:0000000000000000 moduleResponseTimeout
     /tmp/ccAbAM54.s:1543   .bss.streamGps:0000000000000000 streamGps
     /tmp/ccAbAM54.s:1506   .bss.GPS_strReady:0000000000000000 GPS_strReady
     /tmp/ccAbAM54.s:1500   .bss.GPS_bufPtr:0000000000000000 GPS_bufPtr
     /tmp/ccAbAM54.s:1537   .bss.PC_strReady:0000000000000000 PC_strReady
     /tmp/ccAbAM54.s:1526   .bss.PC_bufPtr:0000000000000000 PC_bufPtr
     /tmp/ccAbAM54.s:1513   .bss.NB_bufPtr:0000000000000000 NB_bufPtr
     /tmp/ccAbAM54.s:1519   .bss.NB_strReady:0000000000000000 NB_strReady
     /tmp/ccAbAM54.s:1556   .data.wake:0000000000000000 wake
     /tmp/ccAbAM54.s:1488   .rodata:0000000000000008 $d
     /tmp/ccAbAM54.s:1496   .bss.GPS_bufPtr:0000000000000000 $d
     /tmp/ccAbAM54.s:1507   .bss.GPS_strReady:0000000000000000 $d
     /tmp/ccAbAM54.s:1509   .bss.NB_bufPtr:0000000000000000 $d
     /tmp/ccAbAM54.s:1520   .bss.NB_strReady:0000000000000000 $d
     /tmp/ccAbAM54.s:1522   .bss.PC_bufPtr:0000000000000000 $d
     /tmp/ccAbAM54.s:1532   .bss.PC_recBuf:0000000000000000 $d
     /tmp/ccAbAM54.s:1538   .bss.PC_strReady:0000000000000000 $d
     /tmp/ccAbAM54.s:1544   .bss.streamGps:0000000000000000 $d
     /tmp/ccAbAM54.s:1546   .data.moduleResponseTimeout:0000000000000000 $d
     /tmp/ccAbAM54.s:1562   .rodata.LED_configOutput.8110:0000000000000000 LED_configOutput.8110

UNDEFINED SYMBOLS
LPTMR_GetDefaultConfig
LPTMR_Init
LPUART_GetDefaultConfig
CLOCK_GetCoreSysClkFreq
UART_GetDefaultConfig
LPUART_Init
UART_Init
LPUART_EnableInterrupts
UART_EnableInterrupts
__aeabi_uidiv
BOARD_InitPins
BOARD_BootClockRUN
GPIO_PinInit
memcpy
memset
strcpy
puts
SMC_PreEnterStopModes
SMC_SetPowerModeVlls
printf
assembleMqtt
NB_create_pdp_send
strstr
strlen
millis
breakIfAtOk
getGPS
calcUbxCrc
printUbxResponseHex
LPUART_ClearStatusFlags
UART_ClearStatusFlags
