   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.initTimer,"ax",%progbits
  16              		.align	1
  17              		.global	initTimer
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	initTimer:
  24              	.LFB127:
  25              		.file 1 "../source/main.c"
   1:../source/main.c **** /**
   2:../source/main.c ****  * This is template for main module created by New Kinetis SDK 2.x Project Wizard. Enjoy!
   3:../source/main.c ****  **/
   4:../source/main.c **** 
   5:../source/main.c **** #include "board.h"
   6:../source/main.c **** #include "pin_mux.h"
   7:../source/main.c **** #include "clock_config.h"
   8:../source/main.c **** 
   9:../source/main.c **** #include "fsl_gpio.h"
  10:../source/main.c **** #include "fsl_uart.h"
  11:../source/main.c **** #include "fsl_port.h"
  12:../source/main.c **** #include "fsl_common.h"
  13:../source/main.c **** #include "fsl_i2c.h"
  14:../source/main.c **** #include "fsl_smc.h"
  15:../source/main.c **** #include "fsl_lptmr.h"
  16:../source/main.c **** #include "at_func.h"
  17:../source/main.c **** #include "fsl_lpuart.h"
  18:../source/main.c **** #include "fsl_llwu.h"
  19:../source/main.c **** #include "fsl_clock.h"
  20:../source/main.c **** 
  21:../source/main.c **** #include <stdio.h>
  22:../source/main.c **** #include <stdlib.h>
  23:../source/main.c **** 
  24:../source/main.c **** #include "acc_func.h"
  25:../source/main.c **** #include "i2c_func.h"
  26:../source/main.c **** #include "adc_func.h"
  27:../source/main.c **** #include "fsl_rtc.h"
  28:../source/main.c **** #include "gps_func.h"
  29:../source/main.c **** #include "ubx_func.h"
  30:../source/main.c **** #include "nbiot_func.h"
  31:../source/main.c **** #include "timing.h"
  32:../source/main.c **** 
  33:../source/main.c **** #define RESPONSE_TIMEOUT_NORMAL_VALUE 2000
  34:../source/main.c **** 
  35:../source/main.c **** lptmr_config_t lptmr_config;
  36:../source/main.c **** smc_power_mode_vlls_config_t smc_power_mode_vlls_config;
  37:../source/main.c **** uart_config_t uart_config;
  38:../source/main.c **** 
  39:../source/main.c **** volatile uint8_t wake = 3;
  40:../source/main.c **** volatile uint8_t NB_strReady = 0;
  41:../source/main.c **** volatile uint16_t NB_bufPtr = 0;
  42:../source/main.c **** 
  43:../source/main.c **** char NB_recBuf[500]; 	//buffer for receiving NB IoT module data
  44:../source/main.c **** 
  45:../source/main.c **** static char PC_recBuf[500];	//buffer for receiving from PC terminal
  46:../source/main.c **** volatile uint16_t PC_bufPtr = 0;
  47:../source/main.c **** volatile uint8_t PC_strReady = 0;
  48:../source/main.c **** 
  49:../source/main.c **** char GPS_recBuf[600];	//buffer for receiving from PC terminal
  50:../source/main.c **** volatile uint16_t GPS_bufPtr = 0;
  51:../source/main.c **** volatile uint8_t GPS_strReady = 0;
  52:../source/main.c **** uint8_t streamGps = 0;
  53:../source/main.c **** 
  54:../source/main.c **** char parsedLat[15];
  55:../source/main.c **** char parsedLon[15];
  56:../source/main.c **** 
  57:../source/main.c **** volatile uint32_t moduleResponseTimeout = RESPONSE_TIMEOUT_NORMAL_VALUE; //timeout variable for wai
  58:../source/main.c **** 
  59:../source/main.c **** uint32_t ms_ticks; //millisecond ticks value for the delay_ms function
  60:../source/main.c **** /*
  61:../source/main.c ****  void delay_ms(uint32_t del)
  62:../source/main.c ****  {
  63:../source/main.c ****  for (; del > 0; del--)
  64:../source/main.c ****  {
  65:../source/main.c ****  for(uint32_t t = 0; t<ms_ticks;t++)
  66:../source/main.c ****  {
  67:../source/main.c ****  __asm("nop");
  68:../source/main.c ****  }
  69:../source/main.c ****  }
  70:../source/main.c ****  }
  71:../source/main.c ****  */
  72:../source/main.c **** 
  73:../source/main.c **** void initTimer()
  74:../source/main.c **** {
  26              		.loc 1 74 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  32              		.cfi_def_cfa_offset 24
  33              		.cfi_offset 3, -24
  34              		.cfi_offset 4, -20
  35              		.cfi_offset 5, -16
  36              		.cfi_offset 6, -12
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39              	.LBB68:
  40              	.LBB69:
  41              		.file 2 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 736:../CMSIS/core_cm0plus.h ****   }
 737:../CMSIS/core_cm0plus.h **** }
 738:../CMSIS/core_cm0plus.h **** 
 739:../CMSIS/core_cm0plus.h **** 
 740:../CMSIS/core_cm0plus.h **** /**
 741:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Enable status
 742:../CMSIS/core_cm0plus.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 743:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 744:../CMSIS/core_cm0plus.h ****   \return             0  Interrupt is not enabled.
 745:../CMSIS/core_cm0plus.h ****   \return             1  Interrupt is enabled.
 746:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 747:../CMSIS/core_cm0plus.h ****  */
 748:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 749:../CMSIS/core_cm0plus.h **** {
 750:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 751:../CMSIS/core_cm0plus.h ****   {
 752:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 753:../CMSIS/core_cm0plus.h ****   }
 754:../CMSIS/core_cm0plus.h ****   else
 755:../CMSIS/core_cm0plus.h ****   {
 756:../CMSIS/core_cm0plus.h ****     return(0U);
 757:../CMSIS/core_cm0plus.h ****   }
 758:../CMSIS/core_cm0plus.h **** }
 759:../CMSIS/core_cm0plus.h **** 
 760:../CMSIS/core_cm0plus.h **** 
 761:../CMSIS/core_cm0plus.h **** /**
 762:../CMSIS/core_cm0plus.h ****   \brief   Disable Interrupt
 763:../CMSIS/core_cm0plus.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 764:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 765:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 766:../CMSIS/core_cm0plus.h ****  */
 767:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 768:../CMSIS/core_cm0plus.h **** {
 769:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 770:../CMSIS/core_cm0plus.h ****   {
 771:../CMSIS/core_cm0plus.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 772:../CMSIS/core_cm0plus.h ****     __DSB();
 773:../CMSIS/core_cm0plus.h ****     __ISB();
 774:../CMSIS/core_cm0plus.h ****   }
 775:../CMSIS/core_cm0plus.h **** }
 776:../CMSIS/core_cm0plus.h **** 
 777:../CMSIS/core_cm0plus.h **** 
 778:../CMSIS/core_cm0plus.h **** /**
 779:../CMSIS/core_cm0plus.h ****   \brief   Get Pending Interrupt
 780:../CMSIS/core_cm0plus.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 781:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 782:../CMSIS/core_cm0plus.h ****   \return             0  Interrupt status is not pending.
 783:../CMSIS/core_cm0plus.h ****   \return             1  Interrupt status is pending.
 784:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 785:../CMSIS/core_cm0plus.h ****  */
 786:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 787:../CMSIS/core_cm0plus.h **** {
 788:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 789:../CMSIS/core_cm0plus.h ****   {
 790:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 791:../CMSIS/core_cm0plus.h ****   }
 792:../CMSIS/core_cm0plus.h ****   else
 793:../CMSIS/core_cm0plus.h ****   {
 794:../CMSIS/core_cm0plus.h ****     return(0U);
 795:../CMSIS/core_cm0plus.h ****   }
 796:../CMSIS/core_cm0plus.h **** }
 797:../CMSIS/core_cm0plus.h **** 
 798:../CMSIS/core_cm0plus.h **** 
 799:../CMSIS/core_cm0plus.h **** /**
 800:../CMSIS/core_cm0plus.h ****   \brief   Set Pending Interrupt
 801:../CMSIS/core_cm0plus.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 802:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 803:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 804:../CMSIS/core_cm0plus.h ****  */
 805:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 806:../CMSIS/core_cm0plus.h **** {
 807:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 808:../CMSIS/core_cm0plus.h ****   {
 809:../CMSIS/core_cm0plus.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 810:../CMSIS/core_cm0plus.h ****   }
 811:../CMSIS/core_cm0plus.h **** }
 812:../CMSIS/core_cm0plus.h **** 
 813:../CMSIS/core_cm0plus.h **** 
 814:../CMSIS/core_cm0plus.h **** /**
 815:../CMSIS/core_cm0plus.h ****   \brief   Clear Pending Interrupt
 816:../CMSIS/core_cm0plus.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 817:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 818:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 819:../CMSIS/core_cm0plus.h ****  */
 820:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 821:../CMSIS/core_cm0plus.h **** {
 822:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 823:../CMSIS/core_cm0plus.h ****   {
 824:../CMSIS/core_cm0plus.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  42              		.loc 2 824 0
  43 0002 8026     		movs	r6, #128
  44 0004 C023     		movs	r3, #192
  45              	.LBE69:
  46              	.LBE68:
  75:../source/main.c **** 
  76:../source/main.c **** 	/*
  77:../source/main.c **** 	 * Init dead reindeer timer. LPTIMER interrupt will wake up MCU after a certain time, IF accelerom
  78:../source/main.c **** 	 * has not waked it earlier (and reset the timer)
  79:../source/main.c **** 	 */
  80:../source/main.c **** 	NVIC_ClearPendingIRQ(LPTMR0_IRQn);
  81:../source/main.c **** 	LPTMR_GetDefaultConfig(&lptmr_config);
  47              		.loc 1 81 0
  48 0006 0B4C     		ldr	r4, .L2
  49              	.LBB71:
  50              	.LBB70:
  51              		.loc 2 824 0
  52 0008 0B4D     		ldr	r5, .L2+4
  53 000a 7605     		lsls	r6, r6, #21
  54 000c 5B00     		lsls	r3, r3, #1
  55 000e EE50     		str	r6, [r5, r3]
  56              	.LVL1:
  57              	.LBE70:
  58              	.LBE71:
  59              		.loc 1 81 0
  60 0010 2000     		movs	r0, r4
  61 0012 FFF7FEFF 		bl	LPTMR_GetDefaultConfig
  62              	.LVL2:
  82:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  63              		.loc 1 82 0
  64 0016 0123     		movs	r3, #1
  83:../source/main.c **** 	lptmr_config.value = kLPTMR_Prescale_Glitch_0;
  65              		.loc 1 83 0
  66 0018 0022     		movs	r2, #0
  84:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  85:../source/main.c **** 	LPTMR_Init(LPTMR0, &lptmr_config);
  67              		.loc 1 85 0
  68 001a 084F     		ldr	r7, .L2+8
  69 001c 2100     		movs	r1, r4
  70 001e 3800     		movs	r0, r7
  82:../source/main.c **** 	lptmr_config.value = kLPTMR_Prescale_Glitch_0;
  71              		.loc 1 82 0
  72 0020 2371     		strb	r3, [r4, #4]
  84:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  73              		.loc 1 84 0
  74 0022 6371     		strb	r3, [r4, #5]
  83:../source/main.c **** 	lptmr_config.value = kLPTMR_Prescale_Glitch_0;
  75              		.loc 1 83 0
  76 0024 A271     		strb	r2, [r4, #6]
  77              		.loc 1 85 0
  78 0026 FFF7FEFF 		bl	LPTMR_Init
  79              	.LVL3:
  80              	.LBB72:
  81              	.LBB73:
  82              		.file 3 "../drivers/fsl_lptmr.h"
   1:../drivers/fsl_lptmr.h **** /*
   2:../drivers/fsl_lptmr.h ****  * The Clear BSD License
   3:../drivers/fsl_lptmr.h ****  * Copyright (c) 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_lptmr.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_lptmr.h ****  * All rights reserved.
   6:../drivers/fsl_lptmr.h ****  *
   7:../drivers/fsl_lptmr.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_lptmr.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_lptmr.h ****  * that the following conditions are met:
  10:../drivers/fsl_lptmr.h ****  *
  11:../drivers/fsl_lptmr.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_lptmr.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_lptmr.h ****  *
  14:../drivers/fsl_lptmr.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_lptmr.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_lptmr.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_lptmr.h ****  *
  18:../drivers/fsl_lptmr.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_lptmr.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_lptmr.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_lptmr.h ****  *
  22:../drivers/fsl_lptmr.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_lptmr.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_lptmr.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_lptmr.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_lptmr.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_lptmr.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_lptmr.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_lptmr.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_lptmr.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_lptmr.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_lptmr.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_lptmr.h ****  */
  34:../drivers/fsl_lptmr.h **** #ifndef _FSL_LPTMR_H_
  35:../drivers/fsl_lptmr.h **** #define _FSL_LPTMR_H_
  36:../drivers/fsl_lptmr.h **** 
  37:../drivers/fsl_lptmr.h **** #include "fsl_common.h"
  38:../drivers/fsl_lptmr.h **** 
  39:../drivers/fsl_lptmr.h **** /*!
  40:../drivers/fsl_lptmr.h ****  * @addtogroup lptmr
  41:../drivers/fsl_lptmr.h ****  * @{
  42:../drivers/fsl_lptmr.h ****  */
  43:../drivers/fsl_lptmr.h **** 
  44:../drivers/fsl_lptmr.h **** /*******************************************************************************
  45:../drivers/fsl_lptmr.h ****  * Definitions
  46:../drivers/fsl_lptmr.h ****  ******************************************************************************/
  47:../drivers/fsl_lptmr.h **** 
  48:../drivers/fsl_lptmr.h **** /*! @name Driver version */
  49:../drivers/fsl_lptmr.h **** /*@{*/
  50:../drivers/fsl_lptmr.h **** #define FSL_LPTMR_DRIVER_VERSION (MAKE_VERSION(2, 0, 1)) /*!< Version 2.0.1 */
  51:../drivers/fsl_lptmr.h **** /*@}*/
  52:../drivers/fsl_lptmr.h **** 
  53:../drivers/fsl_lptmr.h **** /*! @brief LPTMR pin selection used in pulse counter mode.*/
  54:../drivers/fsl_lptmr.h **** typedef enum _lptmr_pin_select
  55:../drivers/fsl_lptmr.h **** {
  56:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_0 = 0x0U, /*!< Pulse counter input 0 is selected */
  57:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_1 = 0x1U, /*!< Pulse counter input 1 is selected */
  58:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_2 = 0x2U, /*!< Pulse counter input 2 is selected */
  59:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_3 = 0x3U  /*!< Pulse counter input 3 is selected */
  60:../drivers/fsl_lptmr.h **** } lptmr_pin_select_t;
  61:../drivers/fsl_lptmr.h **** 
  62:../drivers/fsl_lptmr.h **** /*! @brief LPTMR pin polarity used in pulse counter mode.*/
  63:../drivers/fsl_lptmr.h **** typedef enum _lptmr_pin_polarity
  64:../drivers/fsl_lptmr.h **** {
  65:../drivers/fsl_lptmr.h ****     kLPTMR_PinPolarityActiveHigh = 0x0U, /*!< Pulse Counter input source is active-high */
  66:../drivers/fsl_lptmr.h ****     kLPTMR_PinPolarityActiveLow = 0x1U   /*!< Pulse Counter input source is active-low */
  67:../drivers/fsl_lptmr.h **** } lptmr_pin_polarity_t;
  68:../drivers/fsl_lptmr.h **** 
  69:../drivers/fsl_lptmr.h **** /*! @brief LPTMR timer mode selection.*/
  70:../drivers/fsl_lptmr.h **** typedef enum _lptmr_timer_mode
  71:../drivers/fsl_lptmr.h **** {
  72:../drivers/fsl_lptmr.h ****     kLPTMR_TimerModeTimeCounter = 0x0U, /*!< Time Counter mode */
  73:../drivers/fsl_lptmr.h ****     kLPTMR_TimerModePulseCounter = 0x1U /*!< Pulse Counter mode */
  74:../drivers/fsl_lptmr.h **** } lptmr_timer_mode_t;
  75:../drivers/fsl_lptmr.h **** 
  76:../drivers/fsl_lptmr.h **** /*! @brief LPTMR prescaler/glitch filter values*/
  77:../drivers/fsl_lptmr.h **** typedef enum _lptmr_prescaler_glitch_value
  78:../drivers/fsl_lptmr.h **** {
  79:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_0 = 0x0U,  /*!< Prescaler divide 2, glitch filter does not support this 
  80:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_1 = 0x1U,  /*!< Prescaler divide 4, glitch filter 2 */
  81:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_2 = 0x2U,  /*!< Prescaler divide 8, glitch filter 4 */
  82:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_3 = 0x3U,  /*!< Prescaler divide 16, glitch filter 8 */
  83:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_4 = 0x4U,  /*!< Prescaler divide 32, glitch filter 16 */
  84:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_5 = 0x5U,  /*!< Prescaler divide 64, glitch filter 32 */
  85:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_6 = 0x6U,  /*!< Prescaler divide 128, glitch filter 64 */
  86:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_7 = 0x7U,  /*!< Prescaler divide 256, glitch filter 128 */
  87:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_8 = 0x8U,  /*!< Prescaler divide 512, glitch filter 256 */
  88:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_9 = 0x9U,  /*!< Prescaler divide 1024, glitch filter 512*/
  89:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_10 = 0xAU, /*!< Prescaler divide 2048 glitch filter 1024 */
  90:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_11 = 0xBU, /*!< Prescaler divide 4096, glitch filter 2048 */
  91:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_12 = 0xCU, /*!< Prescaler divide 8192, glitch filter 4096 */
  92:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_13 = 0xDU, /*!< Prescaler divide 16384, glitch filter 8192 */
  93:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_14 = 0xEU, /*!< Prescaler divide 32768, glitch filter 16384 */
  94:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_15 = 0xFU  /*!< Prescaler divide 65536, glitch filter 32768 */
  95:../drivers/fsl_lptmr.h **** } lptmr_prescaler_glitch_value_t;
  96:../drivers/fsl_lptmr.h **** 
  97:../drivers/fsl_lptmr.h **** /*!
  98:../drivers/fsl_lptmr.h ****  * @brief LPTMR prescaler/glitch filter clock select.
  99:../drivers/fsl_lptmr.h ****  * @note Clock connections are SoC-specific
 100:../drivers/fsl_lptmr.h ****  */
 101:../drivers/fsl_lptmr.h **** typedef enum _lptmr_prescaler_clock_select
 102:../drivers/fsl_lptmr.h **** {
 103:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_0 = 0x0U, /*!< Prescaler/glitch filter clock 0 selected. */
 104:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_1 = 0x1U, /*!< Prescaler/glitch filter clock 1 selected. */
 105:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_2 = 0x2U, /*!< Prescaler/glitch filter clock 2 selected. */
 106:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_3 = 0x3U, /*!< Prescaler/glitch filter clock 3 selected. */
 107:../drivers/fsl_lptmr.h **** } lptmr_prescaler_clock_select_t;
 108:../drivers/fsl_lptmr.h **** 
 109:../drivers/fsl_lptmr.h **** /*! @brief List of the LPTMR interrupts */
 110:../drivers/fsl_lptmr.h **** typedef enum _lptmr_interrupt_enable
 111:../drivers/fsl_lptmr.h **** {
 112:../drivers/fsl_lptmr.h ****     kLPTMR_TimerInterruptEnable = LPTMR_CSR_TIE_MASK, /*!< Timer interrupt enable */
 113:../drivers/fsl_lptmr.h **** } lptmr_interrupt_enable_t;
 114:../drivers/fsl_lptmr.h **** 
 115:../drivers/fsl_lptmr.h **** /*! @brief List of the LPTMR status flags */
 116:../drivers/fsl_lptmr.h **** typedef enum _lptmr_status_flags
 117:../drivers/fsl_lptmr.h **** {
 118:../drivers/fsl_lptmr.h ****     kLPTMR_TimerCompareFlag = LPTMR_CSR_TCF_MASK, /*!< Timer compare flag */
 119:../drivers/fsl_lptmr.h **** } lptmr_status_flags_t;
 120:../drivers/fsl_lptmr.h **** 
 121:../drivers/fsl_lptmr.h **** /*!
 122:../drivers/fsl_lptmr.h ****  * @brief LPTMR config structure
 123:../drivers/fsl_lptmr.h ****  *
 124:../drivers/fsl_lptmr.h ****  * This structure holds the configuration settings for the LPTMR peripheral. To initialize this
 125:../drivers/fsl_lptmr.h ****  * structure to reasonable defaults, call the LPTMR_GetDefaultConfig() function and pass a
 126:../drivers/fsl_lptmr.h ****  * pointer to your configuration structure instance.
 127:../drivers/fsl_lptmr.h ****  *
 128:../drivers/fsl_lptmr.h ****  * The configuration struct can be made constant so it resides in flash.
 129:../drivers/fsl_lptmr.h ****  */
 130:../drivers/fsl_lptmr.h **** typedef struct _lptmr_config
 131:../drivers/fsl_lptmr.h **** {
 132:../drivers/fsl_lptmr.h ****     lptmr_timer_mode_t timerMode;     /*!< Time counter mode or pulse counter mode */
 133:../drivers/fsl_lptmr.h ****     lptmr_pin_select_t pinSelect;     /*!< LPTMR pulse input pin select; used only in pulse counter
 134:../drivers/fsl_lptmr.h ****     lptmr_pin_polarity_t pinPolarity; /*!< LPTMR pulse input pin polarity; used only in pulse count
 135:../drivers/fsl_lptmr.h ****     bool enableFreeRunning;           /*!< True: enable free running, counter is reset on overflow
 136:../drivers/fsl_lptmr.h ****                                            False: counter is reset when the compare flag is set */
 137:../drivers/fsl_lptmr.h ****     bool bypassPrescaler;             /*!< True: bypass prescaler; false: use clock from prescaler 
 138:../drivers/fsl_lptmr.h ****     lptmr_prescaler_clock_select_t prescalerClockSource; /*!< LPTMR clock source */
 139:../drivers/fsl_lptmr.h ****     lptmr_prescaler_glitch_value_t value;                /*!< Prescaler or glitch filter value */
 140:../drivers/fsl_lptmr.h **** } lptmr_config_t;
 141:../drivers/fsl_lptmr.h **** 
 142:../drivers/fsl_lptmr.h **** /*******************************************************************************
 143:../drivers/fsl_lptmr.h ****  * API
 144:../drivers/fsl_lptmr.h ****  ******************************************************************************/
 145:../drivers/fsl_lptmr.h **** 
 146:../drivers/fsl_lptmr.h **** #if defined(__cplusplus)
 147:../drivers/fsl_lptmr.h **** extern "C" {
 148:../drivers/fsl_lptmr.h **** #endif
 149:../drivers/fsl_lptmr.h **** 
 150:../drivers/fsl_lptmr.h **** /*!
 151:../drivers/fsl_lptmr.h ****  * @name Initialization and deinitialization
 152:../drivers/fsl_lptmr.h ****  * @{
 153:../drivers/fsl_lptmr.h ****  */
 154:../drivers/fsl_lptmr.h **** 
 155:../drivers/fsl_lptmr.h **** /*!
 156:../drivers/fsl_lptmr.h ****  * @brief Ungates the LPTMR clock and configures the peripheral for a basic operation.
 157:../drivers/fsl_lptmr.h ****  *
 158:../drivers/fsl_lptmr.h ****  * @note This API should be called at the beginning of the application using the LPTMR driver.
 159:../drivers/fsl_lptmr.h ****  *
 160:../drivers/fsl_lptmr.h ****  * @param base   LPTMR peripheral base address
 161:../drivers/fsl_lptmr.h ****  * @param config A pointer to the LPTMR configuration structure.
 162:../drivers/fsl_lptmr.h ****  */
 163:../drivers/fsl_lptmr.h **** void LPTMR_Init(LPTMR_Type *base, const lptmr_config_t *config);
 164:../drivers/fsl_lptmr.h **** 
 165:../drivers/fsl_lptmr.h **** /*!
 166:../drivers/fsl_lptmr.h ****  * @brief Gates the LPTMR clock.
 167:../drivers/fsl_lptmr.h ****  *
 168:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 169:../drivers/fsl_lptmr.h ****  */
 170:../drivers/fsl_lptmr.h **** void LPTMR_Deinit(LPTMR_Type *base);
 171:../drivers/fsl_lptmr.h **** 
 172:../drivers/fsl_lptmr.h **** /*!
 173:../drivers/fsl_lptmr.h ****  * @brief Fills in the LPTMR configuration structure with default settings.
 174:../drivers/fsl_lptmr.h ****  *
 175:../drivers/fsl_lptmr.h ****  * The default values are as follows.
 176:../drivers/fsl_lptmr.h ****  * @code
 177:../drivers/fsl_lptmr.h ****  *    config->timerMode = kLPTMR_TimerModeTimeCounter;
 178:../drivers/fsl_lptmr.h ****  *    config->pinSelect = kLPTMR_PinSelectInput_0;
 179:../drivers/fsl_lptmr.h ****  *    config->pinPolarity = kLPTMR_PinPolarityActiveHigh;
 180:../drivers/fsl_lptmr.h ****  *    config->enableFreeRunning = false;
 181:../drivers/fsl_lptmr.h ****  *    config->bypassPrescaler = true;
 182:../drivers/fsl_lptmr.h ****  *    config->prescalerClockSource = kLPTMR_PrescalerClock_1;
 183:../drivers/fsl_lptmr.h ****  *    config->value = kLPTMR_Prescale_Glitch_0;
 184:../drivers/fsl_lptmr.h ****  * @endcode
 185:../drivers/fsl_lptmr.h ****  * @param config A pointer to the LPTMR configuration structure.
 186:../drivers/fsl_lptmr.h ****  */
 187:../drivers/fsl_lptmr.h **** void LPTMR_GetDefaultConfig(lptmr_config_t *config);
 188:../drivers/fsl_lptmr.h **** 
 189:../drivers/fsl_lptmr.h **** /*! @}*/
 190:../drivers/fsl_lptmr.h **** 
 191:../drivers/fsl_lptmr.h **** /*!
 192:../drivers/fsl_lptmr.h ****  * @name Interrupt Interface
 193:../drivers/fsl_lptmr.h ****  * @{
 194:../drivers/fsl_lptmr.h ****  */
 195:../drivers/fsl_lptmr.h **** 
 196:../drivers/fsl_lptmr.h **** /*!
 197:../drivers/fsl_lptmr.h ****  * @brief Enables the selected LPTMR interrupts.
 198:../drivers/fsl_lptmr.h ****  *
 199:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 200:../drivers/fsl_lptmr.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 201:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_interrupt_enable_t
 202:../drivers/fsl_lptmr.h ****  */
 203:../drivers/fsl_lptmr.h **** static inline void LPTMR_EnableInterrupts(LPTMR_Type *base, uint32_t mask)
 204:../drivers/fsl_lptmr.h **** {
 205:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 206:../drivers/fsl_lptmr.h **** 
 207:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit so that we don't clear this w1c bit when writing back */
 208:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 209:../drivers/fsl_lptmr.h ****     reg |= mask;
 210:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 211:../drivers/fsl_lptmr.h **** }
 212:../drivers/fsl_lptmr.h **** 
 213:../drivers/fsl_lptmr.h **** /*!
 214:../drivers/fsl_lptmr.h ****  * @brief Disables the selected LPTMR interrupts.
 215:../drivers/fsl_lptmr.h ****  *
 216:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 217:../drivers/fsl_lptmr.h ****  * @param mask The interrupts to disable. This is a logical OR of members of the
 218:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_interrupt_enable_t.
 219:../drivers/fsl_lptmr.h ****  */
 220:../drivers/fsl_lptmr.h **** static inline void LPTMR_DisableInterrupts(LPTMR_Type *base, uint32_t mask)
 221:../drivers/fsl_lptmr.h **** {
 222:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 223:../drivers/fsl_lptmr.h **** 
 224:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit so that we don't clear this w1c bit when writing back */
 225:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 226:../drivers/fsl_lptmr.h ****     reg &= ~mask;
 227:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 228:../drivers/fsl_lptmr.h **** }
 229:../drivers/fsl_lptmr.h **** 
 230:../drivers/fsl_lptmr.h **** /*!
 231:../drivers/fsl_lptmr.h ****  * @brief Gets the enabled LPTMR interrupts.
 232:../drivers/fsl_lptmr.h ****  *
 233:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 234:../drivers/fsl_lptmr.h ****  *
 235:../drivers/fsl_lptmr.h ****  * @return The enabled interrupts. This is the logical OR of members of the
 236:../drivers/fsl_lptmr.h ****  *         enumeration ::lptmr_interrupt_enable_t
 237:../drivers/fsl_lptmr.h ****  */
 238:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetEnabledInterrupts(LPTMR_Type *base)
 239:../drivers/fsl_lptmr.h **** {
 240:../drivers/fsl_lptmr.h ****     return (base->CSR & LPTMR_CSR_TIE_MASK);
 241:../drivers/fsl_lptmr.h **** }
 242:../drivers/fsl_lptmr.h **** 
 243:../drivers/fsl_lptmr.h **** /*! @}*/
 244:../drivers/fsl_lptmr.h **** 
 245:../drivers/fsl_lptmr.h **** #if defined(FSL_FEATURE_LPTMR_HAS_CSR_TDRE) && (FSL_FEATURE_LPTMR_HAS_CSR_TDRE)
 246:../drivers/fsl_lptmr.h **** /*!
 247:../drivers/fsl_lptmr.h ****  * @brief Enable or disable timer DMA request
 248:../drivers/fsl_lptmr.h ****  *
 249:../drivers/fsl_lptmr.h ****  * @param base base LPTMR peripheral base address
 250:../drivers/fsl_lptmr.h ****  * @param enable Switcher of timer DMA feature. "true" means to enable, "false" means to disable.
 251:../drivers/fsl_lptmr.h ****  */
 252:../drivers/fsl_lptmr.h **** static inline void LPTMR_EnableTimerDMA(LPTMR_Type *base, bool enable)
 253:../drivers/fsl_lptmr.h **** {
 254:../drivers/fsl_lptmr.h ****     if(enable)
 255:../drivers/fsl_lptmr.h ****     {
 256:../drivers/fsl_lptmr.h ****         base->CSR |= LPTMR_CSR_TDRE_MASK;
 257:../drivers/fsl_lptmr.h ****     }
 258:../drivers/fsl_lptmr.h ****     else
 259:../drivers/fsl_lptmr.h ****     {
 260:../drivers/fsl_lptmr.h ****         base->CSR &= ~(LPTMR_CSR_TDRE_MASK);
 261:../drivers/fsl_lptmr.h ****     }
 262:../drivers/fsl_lptmr.h **** }
 263:../drivers/fsl_lptmr.h **** #endif /* FSL_FEATURE_LPTMR_HAS_CSR_TDRE */
 264:../drivers/fsl_lptmr.h **** 
 265:../drivers/fsl_lptmr.h **** /*!
 266:../drivers/fsl_lptmr.h ****  * @name Status Interface
 267:../drivers/fsl_lptmr.h ****  * @{
 268:../drivers/fsl_lptmr.h ****  */
 269:../drivers/fsl_lptmr.h **** 
 270:../drivers/fsl_lptmr.h **** /*!
 271:../drivers/fsl_lptmr.h ****  * @brief Gets the LPTMR status flags.
 272:../drivers/fsl_lptmr.h ****  *
 273:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 274:../drivers/fsl_lptmr.h ****  *
 275:../drivers/fsl_lptmr.h ****  * @return The status flags. This is the logical OR of members of the
 276:../drivers/fsl_lptmr.h ****  *         enumeration ::lptmr_status_flags_t
 277:../drivers/fsl_lptmr.h ****  */
 278:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetStatusFlags(LPTMR_Type *base)
 279:../drivers/fsl_lptmr.h **** {
 280:../drivers/fsl_lptmr.h ****     return (base->CSR & LPTMR_CSR_TCF_MASK);
 281:../drivers/fsl_lptmr.h **** }
 282:../drivers/fsl_lptmr.h **** 
 283:../drivers/fsl_lptmr.h **** /*!
 284:../drivers/fsl_lptmr.h ****  * @brief  Clears the LPTMR status flags.
 285:../drivers/fsl_lptmr.h ****  *
 286:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 287:../drivers/fsl_lptmr.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
 288:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_status_flags_t.
 289:../drivers/fsl_lptmr.h ****  */
 290:../drivers/fsl_lptmr.h **** static inline void LPTMR_ClearStatusFlags(LPTMR_Type *base, uint32_t mask)
 291:../drivers/fsl_lptmr.h **** {
 292:../drivers/fsl_lptmr.h ****     base->CSR |= mask;
 293:../drivers/fsl_lptmr.h **** }
 294:../drivers/fsl_lptmr.h **** 
 295:../drivers/fsl_lptmr.h **** /*! @}*/
 296:../drivers/fsl_lptmr.h **** 
 297:../drivers/fsl_lptmr.h **** /*!
 298:../drivers/fsl_lptmr.h ****  * @name Read and write the timer period
 299:../drivers/fsl_lptmr.h ****  * @{
 300:../drivers/fsl_lptmr.h ****  */
 301:../drivers/fsl_lptmr.h **** 
 302:../drivers/fsl_lptmr.h **** /*!
 303:../drivers/fsl_lptmr.h ****  * @brief Sets the timer period in units of count.
 304:../drivers/fsl_lptmr.h ****  *
 305:../drivers/fsl_lptmr.h ****  * Timers counts from 0 until it equals the count value set here. The count value is written to
 306:../drivers/fsl_lptmr.h ****  * the CMR register.
 307:../drivers/fsl_lptmr.h ****  *
 308:../drivers/fsl_lptmr.h ****  * @note
 309:../drivers/fsl_lptmr.h ****  * 1. The TCF flag is set with the CNR equals the count provided here and then increments.
 310:../drivers/fsl_lptmr.h ****  * 2. Call the utility macros provided in the fsl_common.h to convert to ticks.
 311:../drivers/fsl_lptmr.h ****  *
 312:../drivers/fsl_lptmr.h ****  * @param base  LPTMR peripheral base address
 313:../drivers/fsl_lptmr.h ****  * @param ticks A timer period in units of ticks, which should be equal or greater than 1.
 314:../drivers/fsl_lptmr.h ****  */
 315:../drivers/fsl_lptmr.h **** static inline void LPTMR_SetTimerPeriod(LPTMR_Type *base, uint32_t ticks)
 316:../drivers/fsl_lptmr.h **** {
 317:../drivers/fsl_lptmr.h ****     assert(ticks > 0);
 318:../drivers/fsl_lptmr.h ****     base->CMR = ticks - 1;
  83              		.loc 3 318 0
  84 002a 054B     		ldr	r3, .L2+12
  85              	.LBE73:
  86              	.LBE72:
  86:../source/main.c **** 	LPTMR_SetTimerPeriod(LPTMR0, 7000);  // 3000 for 20hz data rat
  87:../source/main.c **** 
  88:../source/main.c **** 	EnableIRQ(LPTMR0_IRQn);
  89:../source/main.c **** }
  87              		.loc 1 89 0
  88              		@ sp needed
  89              	.LBB75:
  90              	.LBB74:
  91              		.loc 3 318 0
  92 002c BB60     		str	r3, [r7, #8]
  93              	.LVL4:
  94              	.LBE74:
  95              	.LBE75:
  96              	.LBB76:
  97              	.LBB77:
  98              	.LBB78:
 735:../CMSIS/core_cm0plus.h ****   }
  99              		.loc 2 735 0
 100 002e 2E60     		str	r6, [r5]
 101              	.LVL5:
 102              	.LBE78:
 103              	.LBE77:
 104              	.LBE76:
 105              		.loc 1 89 0
 106 0030 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 107              	.L3:
 108 0032 C046     		.align	2
 109              	.L2:
 110 0034 00000000 		.word	lptmr_config
 111 0038 00E100E0 		.word	-536813312
 112 003c 00000440 		.word	1074003968
 113 0040 571B0000 		.word	6999
 114              		.cfi_endproc
 115              	.LFE127:
 117              		.section	.text.initUART,"ax",%progbits
 118              		.align	1
 119              		.global	initUART
 120              		.syntax unified
 121              		.code	16
 122              		.thumb_func
 123              		.fpu softvfp
 125              	initUART:
 126              	.LFB128:
  90:../source/main.c **** 
  91:../source/main.c **** /*
  92:../source/main.c ****  *
  93:../source/main.c ****  * Init all needed UART buses. LPUART0 for NB-IoT, UART0 for PC, UART2 for GPS
  94:../source/main.c ****  */
  95:../source/main.c **** 
  96:../source/main.c **** void initUART()
  97:../source/main.c **** {
 127              		.loc 1 97 0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 16
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 132              		.cfi_def_cfa_offset 20
 133              		.cfi_offset 4, -20
 134              		.cfi_offset 5, -16
 135              		.cfi_offset 6, -12
 136              		.cfi_offset 7, -8
 137              		.cfi_offset 14, -4
  98:../source/main.c **** 
  99:../source/main.c **** 	lpuart_config_t lpuart_config;
 100:../source/main.c **** 	uint32_t uartClkSrcFreq = CLOCK_GetFreq(kCLOCK_BusClk); //get MCU clock frequency for setting corr
 138              		.loc 1 100 0
 139 0002 0220     		movs	r0, #2
  97:../source/main.c **** 
 140              		.loc 1 97 0
 141 0004 85B0     		sub	sp, sp, #20
 142              		.cfi_def_cfa_offset 40
 143              		.loc 1 100 0
 144 0006 FFF7FEFF 		bl	CLOCK_GetFreq
 145              	.LVL6:
 101:../source/main.c **** 	uint32_t lpuartClkSrcFreq = CLOCK_GetFreq(BOARD_DEBUG_UART_CLKSRC);
 146              		.loc 1 101 0
 147 000a 0020     		movs	r0, #0
 148 000c FFF7FEFF 		bl	CLOCK_GetFreq
 149              	.LVL7:
 102:../source/main.c **** 
 103:../source/main.c **** 	UART_GetDefaultConfig(&uart_config);
 150              		.loc 1 103 0
 151 0010 204F     		ldr	r7, .L5
 104:../source/main.c **** 	LPUART_GetDefaultConfig(&lpuart_config);
 152              		.loc 1 104 0
 153 0012 01AC     		add	r4, sp, #4
 101:../source/main.c **** 	uint32_t lpuartClkSrcFreq = CLOCK_GetFreq(BOARD_DEBUG_UART_CLKSRC);
 154              		.loc 1 101 0
 155 0014 0600     		movs	r6, r0
 156              	.LVL8:
 103:../source/main.c **** 	LPUART_GetDefaultConfig(&lpuart_config);
 157              		.loc 1 103 0
 158 0016 3800     		movs	r0, r7
 159              	.LVL9:
 160 0018 FFF7FEFF 		bl	UART_GetDefaultConfig
 161              	.LVL10:
 162              		.loc 1 104 0
 163 001c 2000     		movs	r0, r4
 164 001e FFF7FEFF 		bl	LPUART_GetDefaultConfig
 165              	.LVL11:
 105:../source/main.c **** 	uart_config.baudRate_Bps = 9600;
 166              		.loc 1 105 0
 167 0022 9625     		movs	r5, #150
 106:../source/main.c **** 	uart_config.enableTx = true;
 168              		.loc 1 106 0
 169 0024 0123     		movs	r3, #1
 170              	.LBB95:
 171              	.LBB96:
 172              		.file 4 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 462:../drivers/fsl_clock.h **** }
 463:../drivers/fsl_clock.h **** 
 464:../drivers/fsl_clock.h **** /*!
 465:../drivers/fsl_clock.h ****  * @brief Set ERCLK32K source.
 466:../drivers/fsl_clock.h ****  *
 467:../drivers/fsl_clock.h ****  * @param src The value to set ERCLK32K clock source.
 468:../drivers/fsl_clock.h ****  */
 469:../drivers/fsl_clock.h **** static inline void CLOCK_SetEr32kClock(uint32_t src)
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
 472:../drivers/fsl_clock.h **** }
 473:../drivers/fsl_clock.h **** 
 474:../drivers/fsl_clock.h **** /*!
 475:../drivers/fsl_clock.h ****  * @brief Set LPUART0 clock source.
 476:../drivers/fsl_clock.h ****  *
 477:../drivers/fsl_clock.h ****  * @param src The value to set LPUART0 clock source.
 478:../drivers/fsl_clock.h ****  */
 479:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpuart0Clock(uint32_t src)
 480:../drivers/fsl_clock.h **** {
 481:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART0SRC_MASK) | SIM_SOPT2_LPUART0SRC(src));
 482:../drivers/fsl_clock.h **** }
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*!
 485:../drivers/fsl_clock.h ****  * @brief Set LPUART1 clock source.
 486:../drivers/fsl_clock.h ****  *
 487:../drivers/fsl_clock.h ****  * @param src The value to set LPUART1 clock source.
 488:../drivers/fsl_clock.h ****  */
 489:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpuart1Clock(uint32_t src)
 490:../drivers/fsl_clock.h **** {
 491:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART1SRC_MASK) | SIM_SOPT2_LPUART1SRC(src));
 173              		.loc 4 491 0
 174 0026 C020     		movs	r0, #192
 175              	.LBE96:
 176              	.LBE95:
 177              		.loc 1 106 0
 178 0028 BB71     		strb	r3, [r7, #6]
 107:../source/main.c **** 	uart_config.enableRx = true;
 179              		.loc 1 107 0
 180 002a FB71     		strb	r3, [r7, #7]
 108:../source/main.c **** 	lpuart_config.baudRate_Bps = 9600;
 109:../source/main.c **** 	lpuart_config.enableTx = true;
 181              		.loc 1 109 0
 182 002c A372     		strb	r3, [r4, #10]
 110:../source/main.c **** 	lpuart_config.enableRx = true;
 183              		.loc 1 110 0
 184 002e E372     		strb	r3, [r4, #11]
 185              	.LVL12:
 186              	.LBB100:
 187              	.LBB97:
 188              		.loc 4 491 0
 189 0030 194A     		ldr	r2, .L5+4
 190 0032 1A4B     		ldr	r3, .L5+8
 191              	.LBE97:
 192              	.LBE100:
 105:../source/main.c **** 	uart_config.enableTx = true;
 193              		.loc 1 105 0
 194 0034 AD01     		lsls	r5, r5, #6
 195 0036 3D60     		str	r5, [r7]
 108:../source/main.c **** 	lpuart_config.baudRate_Bps = 9600;
 196              		.loc 1 108 0
 197 0038 0195     		str	r5, [sp, #4]
 198              	.LBB101:
 199              	.LBB98:
 200              		.loc 4 491 0
 201 003a D158     		ldr	r1, [r2, r3]
 202 003c 8005     		lsls	r0, r0, #22
 203 003e 0143     		orrs	r1, r0
 204              	.LBE98:
 205              	.LBE101:
 206              	.LBB102:
 207              	.LBB103:
 481:../drivers/fsl_clock.h **** }
 208              		.loc 4 481 0
 209 0040 C020     		movs	r0, #192
 210              	.LBE103:
 211              	.LBE102:
 212              	.LBB106:
 213              	.LBB99:
 214              		.loc 4 491 0
 215 0042 D150     		str	r1, [r2, r3]
 216              	.LVL13:
 217              	.LBE99:
 218              	.LBE106:
 219              	.LBB107:
 220              	.LBB104:
 481:../drivers/fsl_clock.h **** }
 221              		.loc 4 481 0
 222 0044 D158     		ldr	r1, [r2, r3]
 223              	.LBE104:
 224              	.LBE107:
 111:../source/main.c **** 
 112:../source/main.c **** 	CLOCK_SetLpuart1Clock(0x3U);
 113:../source/main.c **** 	CLOCK_SetLpuart0Clock(0x3U);
 114:../source/main.c **** 
 115:../source/main.c **** 	LPUART_Init(LPUART0, &lpuart_config, lpuartClkSrcFreq); //Init LPUART0 for NBiot
 225              		.loc 1 115 0
 226 0046 164F     		ldr	r7, .L5+12
 227              	.LBB108:
 228              	.LBB105:
 481:../drivers/fsl_clock.h **** }
 229              		.loc 4 481 0
 230 0048 0005     		lsls	r0, r0, #20
 231 004a 0143     		orrs	r1, r0
 232 004c D150     		str	r1, [r2, r3]
 233              	.LVL14:
 234              	.LBE105:
 235              	.LBE108:
 236              		.loc 1 115 0
 237 004e 3800     		movs	r0, r7
 238 0050 3200     		movs	r2, r6
 239 0052 2100     		movs	r1, r4
 240 0054 FFF7FEFF 		bl	LPUART_Init
 241              	.LVL15:
 116:../source/main.c **** 
 117:../source/main.c **** 	//UART_Init(UART2, &uart_config, uartClkSrcFreq); //UART2 for GPS with same settings!
 118:../source/main.c **** 
 119:../source/main.c **** 	lpuart_config.baudRate_Bps = 9600;
 120:../source/main.c **** 
 121:../source/main.c **** 	LPUART_Init(LPUART1, &lpuart_config, lpuartClkSrcFreq); //Init LPUART1 for PCuart
 242              		.loc 1 121 0
 243 0058 3200     		movs	r2, r6
 122:../source/main.c **** 
 123:../source/main.c **** 	LPUART_EnableInterrupts(LPUART0, kLPUART_RxDataRegFullInterruptEnable); //enable LPUART0 receive i
 244              		.loc 1 123 0
 245 005a 8026     		movs	r6, #128
 246              	.LVL16:
 119:../source/main.c **** 
 247              		.loc 1 119 0
 248 005c 0195     		str	r5, [sp, #4]
 121:../source/main.c **** 
 249              		.loc 1 121 0
 250 005e 114D     		ldr	r5, .L5+16
 251 0060 2100     		movs	r1, r4
 252              		.loc 1 123 0
 253 0062 B603     		lsls	r6, r6, #14
 121:../source/main.c **** 
 254              		.loc 1 121 0
 255 0064 2800     		movs	r0, r5
 256 0066 FFF7FEFF 		bl	LPUART_Init
 257              	.LVL17:
 258              		.loc 1 123 0
 259 006a 3100     		movs	r1, r6
 260 006c 3800     		movs	r0, r7
 261 006e FFF7FEFF 		bl	LPUART_EnableInterrupts
 262              	.LVL18:
 263              	.LBB109:
 264              	.LBB110:
 265              	.LBB111:
 735:../CMSIS/core_cm0plus.h ****   }
 266              		.loc 2 735 0
 267 0072 8023     		movs	r3, #128
 268 0074 0C4C     		ldr	r4, .L5+20
 269 0076 5B01     		lsls	r3, r3, #5
 270 0078 2360     		str	r3, [r4]
 271              	.LVL19:
 272              	.LBE111:
 273              	.LBE110:
 274              	.LBE109:
 275              	.LBB112:
 276              	.LBB113:
 277              	.LBB114:
 278 007a 8023     		movs	r3, #128
 279 007c DB01     		lsls	r3, r3, #7
 280 007e 2360     		str	r3, [r4]
 281              	.LVL20:
 282              	.LBE114:
 283              	.LBE113:
 284              	.LBE112:
 124:../source/main.c **** 
 125:../source/main.c **** 	EnableIRQ(LPUART0_IRQn);
 126:../source/main.c **** 
 127:../source/main.c **** 	//UART_EnableInterrupts(UART2, kUART_RxDataRegFullInterruptEnable); //enable LPUART0 receive inter
 128:../source/main.c **** 	EnableIRQ(UART2_FLEXIO_IRQn);
 129:../source/main.c **** 
 130:../source/main.c **** 	LPUART_EnableInterrupts(LPUART1, kLPUART_RxDataRegFullInterruptEnable); //enable UART0 receive int
 285              		.loc 1 130 0
 286 0080 3100     		movs	r1, r6
 287 0082 2800     		movs	r0, r5
 288 0084 FFF7FEFF 		bl	LPUART_EnableInterrupts
 289              	.LVL21:
 290              	.LBB115:
 291              	.LBB116:
 292              	.LBB117:
 735:../CMSIS/core_cm0plus.h ****   }
 293              		.loc 2 735 0
 294 0088 8023     		movs	r3, #128
 295 008a 9B01     		lsls	r3, r3, #6
 296 008c 2360     		str	r3, [r4]
 297              	.LVL22:
 298              	.LBE117:
 299              	.LBE116:
 300              	.LBE115:
 131:../source/main.c **** 	EnableIRQ(LPUART1_IRQn);
 132:../source/main.c **** 
 133:../source/main.c **** }
 301              		.loc 1 133 0
 302 008e 05B0     		add	sp, sp, #20
 303              		@ sp needed
 304 0090 F0BD     		pop	{r4, r5, r6, r7, pc}
 305              	.L6:
 306 0092 C046     		.align	2
 307              	.L5:
 308 0094 00000000 		.word	uart_config
 309 0098 00700440 		.word	1074032640
 310 009c 04100000 		.word	4100
 311 00a0 00400540 		.word	1074085888
 312 00a4 00500540 		.word	1074089984
 313 00a8 00E100E0 		.word	-536813312
 314              		.cfi_endproc
 315              	.LFE128:
 317              		.section	.text.NB_send,"ax",%progbits
 318              		.align	1
 319              		.global	NB_send
 320              		.syntax unified
 321              		.code	16
 322              		.thumb_func
 323              		.fpu softvfp
 325              	NB_send:
 326              	.LFB129:
 134:../source/main.c **** 
 135:../source/main.c **** /*
 136:../source/main.c ****  * Send data to NBiot with LPUART0
 137:../source/main.c ****  * String to be sent is pointed by *data
 138:../source/main.c ****  *
 139:../source/main.c ****  */
 140:../source/main.c **** 
 141:../source/main.c **** void NB_send(char *data)
 142:../source/main.c **** {
 327              		.loc 1 142 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 0
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              	.LVL23:
 143:../source/main.c **** 
 144:../source/main.c **** 	char c = *data++; //assign c a character from the string and post-increment string pointer
 332              		.loc 1 144 0
 333 0000 0023     		movs	r3, #0
 145:../source/main.c **** 
 146:../source/main.c **** 	while (c)
 147:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 148:../source/main.c **** 
 149:../source/main.c **** 		while (!((LPUART0->STAT) & kLPUART_TxDataRegEmptyFlag))
 334              		.loc 1 149 0
 335 0002 8021     		movs	r1, #128
 142:../source/main.c **** 
 336              		.loc 1 142 0
 337 0004 10B5     		push	{r4, lr}
 338              		.cfi_def_cfa_offset 8
 339              		.cfi_offset 4, -8
 340              		.cfi_offset 14, -4
 341              		.loc 1 149 0
 342 0006 074A     		ldr	r2, .L13
 144:../source/main.c **** 
 343              		.loc 1 144 0
 344 0008 C356     		ldrsb	r3, [r0, r3]
 345              	.LVL24:
 346              		.loc 1 149 0
 347 000a 0904     		lsls	r1, r1, #16
 144:../source/main.c **** 
 348              		.loc 1 144 0
 349 000c 0130     		adds	r0, r0, #1
 350              	.LVL25:
 351              	.L8:
 146:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 352              		.loc 1 146 0
 353 000e 002B     		cmp	r3, #0
 354 0010 00D1     		bne	.L9
 150:../source/main.c **** 		{
 151:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 152:../source/main.c **** 		LPUART0->DATA = c; //write new character to transmit buffer
 153:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 154:../source/main.c **** 	}
 155:../source/main.c **** }
 355              		.loc 1 155 0
 356              		@ sp needed
 357 0012 10BD     		pop	{r4, pc}
 358              	.L9:
 149:../source/main.c **** 		{
 359              		.loc 1 149 0 discriminator 1
 360 0014 5468     		ldr	r4, [r2, #4]
 361 0016 0C42     		tst	r4, r1
 362 0018 FCD0     		beq	.L9
 152:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 363              		.loc 1 152 0
 364 001a D360     		str	r3, [r2, #12]
 365              	.LVL26:
 153:../source/main.c **** 	}
 366              		.loc 1 153 0
 367 001c 0023     		movs	r3, #0
 368              	.LVL27:
 369 001e C356     		ldrsb	r3, [r0, r3]
 370              	.LVL28:
 371 0020 0130     		adds	r0, r0, #1
 372              	.LVL29:
 373 0022 F4E7     		b	.L8
 374              	.L14:
 375              		.align	2
 376              	.L13:
 377 0024 00400540 		.word	1074085888
 378              		.cfi_endproc
 379              	.LFE129:
 381              		.section	.text.GPS_send,"ax",%progbits
 382              		.align	1
 383              		.global	GPS_send
 384              		.syntax unified
 385              		.code	16
 386              		.thumb_func
 387              		.fpu softvfp
 389              	GPS_send:
 390              	.LFB130:
 156:../source/main.c **** 
 157:../source/main.c **** void GPS_send(char *data, uint8_t len)
 158:../source/main.c **** {
 391              		.loc 1 158 0
 392              		.cfi_startproc
 393              		@ args = 0, pretend = 0, frame = 0
 394              		@ frame_needed = 0, uses_anonymous_args = 0
 395              	.LVL30:
 159:../source/main.c **** 
 160:../source/main.c **** 	char c = *data++; //assign c a character from the string and post-increment string pointer
 396              		.loc 1 160 0
 397 0000 0023     		movs	r3, #0
 158:../source/main.c **** 
 398              		.loc 1 158 0
 399 0002 10B5     		push	{r4, lr}
 400              		.cfi_def_cfa_offset 8
 401              		.cfi_offset 4, -8
 402              		.cfi_offset 14, -4
 161:../source/main.c **** 
 162:../source/main.c **** 	for (; len > 0; len--)
 163:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 164:../source/main.c **** 
 165:../source/main.c **** 		while (!((UART2->S1) & 0x80))
 403              		.loc 1 165 0
 404 0004 084C     		ldr	r4, .L20
 160:../source/main.c **** 
 405              		.loc 1 160 0
 406 0006 C356     		ldrsb	r3, [r0, r3]
 407              	.LVL31:
 408 0008 0130     		adds	r0, r0, #1
 409              	.LVL32:
 410              	.L16:
 162:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 411              		.loc 1 162 0 discriminator 1
 412 000a 0029     		cmp	r1, #0
 413 000c 00D1     		bne	.L17
 166:../source/main.c **** 		{
 167:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 168:../source/main.c **** 		UART2->D = c; //write new character to transmit buffer
 169:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 170:../source/main.c **** 	}
 171:../source/main.c **** }
 414              		.loc 1 171 0
 415              		@ sp needed
 416 000e 10BD     		pop	{r4, pc}
 417              	.L17:
 165:../source/main.c **** 		{
 418              		.loc 1 165 0 discriminator 1
 419 0010 2279     		ldrb	r2, [r4, #4]
 420 0012 52B2     		sxtb	r2, r2
 421 0014 002A     		cmp	r2, #0
 422 0016 FBDA     		bge	.L17
 168:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 423              		.loc 1 168 0
 424 0018 DBB2     		uxtb	r3, r3
 425 001a E371     		strb	r3, [r4, #7]
 426              	.LVL33:
 169:../source/main.c **** 	}
 427              		.loc 1 169 0
 428 001c 0023     		movs	r3, #0
 429              	.LVL34:
 162:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 430              		.loc 1 162 0
 431 001e 0139     		subs	r1, r1, #1
 432              	.LVL35:
 169:../source/main.c **** 	}
 433              		.loc 1 169 0
 434 0020 C356     		ldrsb	r3, [r0, r3]
 435              	.LVL36:
 162:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 436              		.loc 1 162 0
 437 0022 C9B2     		uxtb	r1, r1
 438              	.LVL37:
 439 0024 0130     		adds	r0, r0, #1
 440              	.LVL38:
 441 0026 F0E7     		b	.L16
 442              	.L21:
 443              		.align	2
 444              	.L20:
 445 0028 00C00640 		.word	1074184192
 446              		.cfi_endproc
 447              	.LFE130:
 449              		.section	.text.PCprint,"ax",%progbits
 450              		.align	1
 451              		.global	PCprint
 452              		.syntax unified
 453              		.code	16
 454              		.thumb_func
 455              		.fpu softvfp
 457              	PCprint:
 458              	.LFB131:
 172:../source/main.c **** 
 173:../source/main.c **** uint8_t PCprint(char *data)
 174:../source/main.c **** {
 459              		.loc 1 174 0
 460              		.cfi_startproc
 461              		@ args = 0, pretend = 0, frame = 0
 462              		@ frame_needed = 0, uses_anonymous_args = 0
 463              	.LVL39:
 464 0000 30B5     		push	{r4, r5, lr}
 465              		.cfi_def_cfa_offset 12
 466              		.cfi_offset 4, -12
 467              		.cfi_offset 5, -8
 468              		.cfi_offset 14, -4
 175:../source/main.c **** 	char c;
 176:../source/main.c **** 	uint8_t len = 0;
 177:../source/main.c **** 	while ((c = *data++))
 178:../source/main.c **** 	{
 179:../source/main.c **** 
 180:../source/main.c **** 		while (!(LPUART1->STAT & kLPUART_TxDataRegEmptyFlag))
 469              		.loc 1 180 0
 470 0002 8025     		movs	r5, #128
 174:../source/main.c **** 	char c;
 471              		.loc 1 174 0
 472 0004 0400     		movs	r4, r0
 177:../source/main.c **** 	{
 473              		.loc 1 177 0
 474 0006 0023     		movs	r3, #0
 475              		.loc 1 180 0
 476 0008 0649     		ldr	r1, .L28
 477 000a 2D04     		lsls	r5, r5, #16
 478              	.LVL40:
 479              	.L23:
 177:../source/main.c **** 	{
 480              		.loc 1 177 0
 481 000c E256     		ldrsb	r2, [r4, r3]
 482 000e D8B2     		uxtb	r0, r3
 483              	.LVL41:
 484 0010 002A     		cmp	r2, #0
 485 0012 00D1     		bne	.L24
 181:../source/main.c **** 		{
 182:../source/main.c **** 		}
 183:../source/main.c **** 
 184:../source/main.c **** 		LPUART1->DATA = c;
 185:../source/main.c **** 		len++;
 186:../source/main.c **** 
 187:../source/main.c **** 	}
 188:../source/main.c **** 
 189:../source/main.c **** 	return len;
 190:../source/main.c **** }
 486              		.loc 1 190 0
 487              		@ sp needed
 488              	.LVL42:
 489 0014 30BD     		pop	{r4, r5, pc}
 490              	.LVL43:
 491              	.L24:
 180:../source/main.c **** 		{
 492              		.loc 1 180 0 discriminator 1
 493 0016 4868     		ldr	r0, [r1, #4]
 494 0018 2842     		tst	r0, r5
 495 001a FCD0     		beq	.L24
 184:../source/main.c **** 		len++;
 496              		.loc 1 184 0
 497 001c CA60     		str	r2, [r1, #12]
 498              	.LVL44:
 499 001e 0133     		adds	r3, r3, #1
 500              	.LVL45:
 501 0020 F4E7     		b	.L23
 502              	.L29:
 503 0022 C046     		.align	2
 504              	.L28:
 505 0024 00500540 		.word	1074089984
 506              		.cfi_endproc
 507              	.LFE131:
 509              		.global	__aeabi_uidiv
 510              		.section	.text.startup.main,"ax",%progbits
 511              		.align	1
 512              		.global	main
 513              		.syntax unified
 514              		.code	16
 515              		.thumb_func
 516              		.fpu softvfp
 518              	main:
 519              	.LFB132:
 191:../source/main.c **** 
 192:../source/main.c **** int main(void)
 193:../source/main.c **** {
 520              		.loc 1 193 0
 521              		.cfi_startproc
 522              		@ args = 0, pretend = 0, frame = 560
 523              		@ frame_needed = 0, uses_anonymous_args = 0
 194:../source/main.c **** 
 195:../source/main.c **** 	PMC->REGSC |= 0x08;	//acknowledge wake up to voltage regulator module, this is needed with LLWU wa
 524              		.loc 1 195 0
 525 0000 0823     		movs	r3, #8
 193:../source/main.c **** 
 526              		.loc 1 193 0
 527 0002 F0B5     		push	{r4, r5, r6, r7, lr}
 528              		.cfi_def_cfa_offset 20
 529              		.cfi_offset 4, -20
 530              		.cfi_offset 5, -16
 531              		.cfi_offset 6, -12
 532              		.cfi_offset 7, -8
 533              		.cfi_offset 14, -4
 534              		.loc 1 195 0
 535 0004 CF4A     		ldr	r2, .L74
 193:../source/main.c **** 
 536              		.loc 1 193 0
 537 0006 D04C     		ldr	r4, .L74+4
 538              		.loc 1 195 0
 539 0008 9178     		ldrb	r1, [r2, #2]
 193:../source/main.c **** 
 540              		.loc 1 193 0
 541 000a A544     		add	sp, sp, r4
 542              		.cfi_def_cfa_offset 584
 543              		.loc 1 195 0
 544 000c 0B43     		orrs	r3, r1
 545 000e 9370     		strb	r3, [r2, #2]
 546              	.LVL46:
 547              	.LBB148:
 548              	.LBB149:
 735:../CMSIS/core_cm0plus.h ****   }
 549              		.loc 2 735 0
 550 0010 8022     		movs	r2, #128
 551 0012 CE4B     		ldr	r3, .L74+8
 552 0014 1A60     		str	r2, [r3]
 553              	.LVL47:
 554              	.LBE149:
 555              	.LBE148:
 196:../source/main.c **** 
 197:../source/main.c **** 	NVIC_EnableIRQ(LLWU_IRQn);//enable LLWU interrupts. if we wake up from VLLS mode, it means that ne
 198:../source/main.c **** 							  //will jump to the LLWU interrupt vector
 199:../source/main.c **** 	struct reindeerData_t reindeerData; //create struct for our reindeer data that will be sent
 200:../source/main.c **** 	char mqttMessage[450];
 201:../source/main.c **** 
 202:../source/main.c **** 	BOARD_InitPins();	//init all physical pins
 556              		.loc 1 202 0
 557 0016 FFF7FEFF 		bl	BOARD_InitPins
 558              	.LVL48:
 203:../source/main.c **** 	BOARD_BootClockVLPR(); //by uncommenting this we can use FRDM 50Mhz external clock, but will not w
 559              		.loc 1 203 0
 560 001a FFF7FEFF 		bl	BOARD_BootClockVLPR
 561              	.LVL49:
 204:../source/main.c **** 
 205:../source/main.c **** 	SysTick_Config(BOARD_DEBUG_UART_CLK_FREQ / 1000); //setup SysTick timer for 1ms interval for delay
 562              		.loc 1 205 0
 563 001e FFF7FEFF 		bl	CLOCK_GetCoreSysClkFreq
 564              	.LVL50:
 565 0022 FA21     		movs	r1, #250
 566 0024 8900     		lsls	r1, r1, #2
 567 0026 FFF7FEFF 		bl	__aeabi_uidiv
 568              	.LVL51:
 569              	.LBB150:
 570              	.LBB151:
 825:../CMSIS/core_cm0plus.h ****   }
 826:../CMSIS/core_cm0plus.h **** }
 827:../CMSIS/core_cm0plus.h **** 
 828:../CMSIS/core_cm0plus.h **** 
 829:../CMSIS/core_cm0plus.h **** /**
 830:../CMSIS/core_cm0plus.h ****   \brief   Set Interrupt Priority
 831:../CMSIS/core_cm0plus.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 832:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 833:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 834:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Interrupt number.
 835:../CMSIS/core_cm0plus.h ****   \param [in]  priority  Priority to set.
 836:../CMSIS/core_cm0plus.h ****   \note    The priority cannot be set for every processor exception.
 837:../CMSIS/core_cm0plus.h ****  */
 838:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 839:../CMSIS/core_cm0plus.h **** {
 840:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 841:../CMSIS/core_cm0plus.h ****   {
 842:../CMSIS/core_cm0plus.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 843:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 844:../CMSIS/core_cm0plus.h ****   }
 845:../CMSIS/core_cm0plus.h ****   else
 846:../CMSIS/core_cm0plus.h ****   {
 847:../CMSIS/core_cm0plus.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 848:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 849:../CMSIS/core_cm0plus.h ****   }
 850:../CMSIS/core_cm0plus.h **** }
 851:../CMSIS/core_cm0plus.h **** 
 852:../CMSIS/core_cm0plus.h **** 
 853:../CMSIS/core_cm0plus.h **** /**
 854:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Priority
 855:../CMSIS/core_cm0plus.h ****   \details Reads the priority of a device specific interrupt or a processor exception.
 856:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 857:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 858:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn  Interrupt number.
 859:../CMSIS/core_cm0plus.h ****   \return             Interrupt Priority.
 860:../CMSIS/core_cm0plus.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 861:../CMSIS/core_cm0plus.h ****  */
 862:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
 863:../CMSIS/core_cm0plus.h **** {
 864:../CMSIS/core_cm0plus.h **** 
 865:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 866:../CMSIS/core_cm0plus.h ****   {
 867:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 868:../CMSIS/core_cm0plus.h ****   }
 869:../CMSIS/core_cm0plus.h ****   else
 870:../CMSIS/core_cm0plus.h ****   {
 871:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 872:../CMSIS/core_cm0plus.h ****   }
 873:../CMSIS/core_cm0plus.h **** }
 874:../CMSIS/core_cm0plus.h **** 
 875:../CMSIS/core_cm0plus.h **** 
 876:../CMSIS/core_cm0plus.h **** /**
 877:../CMSIS/core_cm0plus.h ****   \brief   Set Interrupt Vector
 878:../CMSIS/core_cm0plus.h ****   \details Sets an interrupt vector in SRAM based interrupt vector table.
 879:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 880:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 881:../CMSIS/core_cm0plus.h ****            VTOR must been relocated to SRAM before.
 882:../CMSIS/core_cm0plus.h ****            If VTOR is not present address 0 must be mapped to SRAM.
 883:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn      Interrupt number
 884:../CMSIS/core_cm0plus.h ****   \param [in]   vector    Address of interrupt handler function
 885:../CMSIS/core_cm0plus.h ****  */
 886:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
 887:../CMSIS/core_cm0plus.h **** {
 888:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 889:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
 890:../CMSIS/core_cm0plus.h **** #else
 891:../CMSIS/core_cm0plus.h ****     uint32_t *vectors = (uint32_t *)0x0U;
 892:../CMSIS/core_cm0plus.h **** #endif
 893:../CMSIS/core_cm0plus.h ****   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
 894:../CMSIS/core_cm0plus.h **** }
 895:../CMSIS/core_cm0plus.h **** 
 896:../CMSIS/core_cm0plus.h **** 
 897:../CMSIS/core_cm0plus.h **** /**
 898:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Vector
 899:../CMSIS/core_cm0plus.h ****   \details Reads an interrupt vector from interrupt vector table.
 900:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 901:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 902:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn      Interrupt number.
 903:../CMSIS/core_cm0plus.h ****   \return                 Address of interrupt handler function
 904:../CMSIS/core_cm0plus.h ****  */
 905:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
 906:../CMSIS/core_cm0plus.h **** {
 907:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 908:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
 909:../CMSIS/core_cm0plus.h **** #else
 910:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)0x0U;
 911:../CMSIS/core_cm0plus.h **** #endif
 912:../CMSIS/core_cm0plus.h ****   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
 913:../CMSIS/core_cm0plus.h **** 
 914:../CMSIS/core_cm0plus.h **** }
 915:../CMSIS/core_cm0plus.h **** 
 916:../CMSIS/core_cm0plus.h **** 
 917:../CMSIS/core_cm0plus.h **** /**
 918:../CMSIS/core_cm0plus.h ****   \brief   System Reset
 919:../CMSIS/core_cm0plus.h ****   \details Initiates a system reset request to reset the MCU.
 920:../CMSIS/core_cm0plus.h ****  */
 921:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SystemReset(void)
 922:../CMSIS/core_cm0plus.h **** {
 923:../CMSIS/core_cm0plus.h ****   __DSB();                                                          /* Ensure all outstanding memor
 924:../CMSIS/core_cm0plus.h ****                                                                        buffered write are completed
 925:../CMSIS/core_cm0plus.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 926:../CMSIS/core_cm0plus.h ****                  SCB_AIRCR_SYSRESETREQ_Msk);
 927:../CMSIS/core_cm0plus.h ****   __DSB();                                                          /* Ensure completion of memory 
 928:../CMSIS/core_cm0plus.h **** 
 929:../CMSIS/core_cm0plus.h ****   for(;;)                                                           /* wait until reset */
 930:../CMSIS/core_cm0plus.h ****   {
 931:../CMSIS/core_cm0plus.h ****     __NOP();
 932:../CMSIS/core_cm0plus.h ****   }
 933:../CMSIS/core_cm0plus.h **** }
 934:../CMSIS/core_cm0plus.h **** 
 935:../CMSIS/core_cm0plus.h **** /*@} end of CMSIS_Core_NVICFunctions */
 936:../CMSIS/core_cm0plus.h **** 
 937:../CMSIS/core_cm0plus.h **** /* ##########################  MPU functions  #################################### */
 938:../CMSIS/core_cm0plus.h **** 
 939:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 940:../CMSIS/core_cm0plus.h **** 
 941:../CMSIS/core_cm0plus.h **** #include "mpu_armv7.h"
 942:../CMSIS/core_cm0plus.h **** 
 943:../CMSIS/core_cm0plus.h **** #endif
 944:../CMSIS/core_cm0plus.h **** 
 945:../CMSIS/core_cm0plus.h **** /* ##########################  FPU functions  #################################### */
 946:../CMSIS/core_cm0plus.h **** /**
 947:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 948:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FpuFunctions FPU Functions
 949:../CMSIS/core_cm0plus.h ****   \brief    Function that provides FPU type.
 950:../CMSIS/core_cm0plus.h ****   @{
 951:../CMSIS/core_cm0plus.h ****  */
 952:../CMSIS/core_cm0plus.h **** 
 953:../CMSIS/core_cm0plus.h **** /**
 954:../CMSIS/core_cm0plus.h ****   \brief   get FPU type
 955:../CMSIS/core_cm0plus.h ****   \details returns the FPU type
 956:../CMSIS/core_cm0plus.h ****   \returns
 957:../CMSIS/core_cm0plus.h ****    - \b  0: No FPU
 958:../CMSIS/core_cm0plus.h ****    - \b  1: Single precision FPU
 959:../CMSIS/core_cm0plus.h ****    - \b  2: Double + Single precision FPU
 960:../CMSIS/core_cm0plus.h ****  */
 961:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t SCB_GetFPUType(void)
 962:../CMSIS/core_cm0plus.h **** {
 963:../CMSIS/core_cm0plus.h ****     return 0U;           /* No FPU */
 964:../CMSIS/core_cm0plus.h **** }
 965:../CMSIS/core_cm0plus.h **** 
 966:../CMSIS/core_cm0plus.h **** 
 967:../CMSIS/core_cm0plus.h **** /*@} end of CMSIS_Core_FpuFunctions */
 968:../CMSIS/core_cm0plus.h **** 
 969:../CMSIS/core_cm0plus.h **** 
 970:../CMSIS/core_cm0plus.h **** 
 971:../CMSIS/core_cm0plus.h **** /* ##################################    SysTick function  ########################################
 972:../CMSIS/core_cm0plus.h **** /**
 973:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 974:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
 975:../CMSIS/core_cm0plus.h ****   \brief    Functions that configure the System.
 976:../CMSIS/core_cm0plus.h ****   @{
 977:../CMSIS/core_cm0plus.h ****  */
 978:../CMSIS/core_cm0plus.h **** 
 979:../CMSIS/core_cm0plus.h **** #if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
 980:../CMSIS/core_cm0plus.h **** 
 981:../CMSIS/core_cm0plus.h **** /**
 982:../CMSIS/core_cm0plus.h ****   \brief   System Tick Configuration
 983:../CMSIS/core_cm0plus.h ****   \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
 984:../CMSIS/core_cm0plus.h ****            Counter is in free running mode to generate periodic interrupts.
 985:../CMSIS/core_cm0plus.h ****   \param [in]  ticks  Number of ticks between two interrupts.
 986:../CMSIS/core_cm0plus.h ****   \return          0  Function succeeded.
 987:../CMSIS/core_cm0plus.h ****   \return          1  Function failed.
 988:../CMSIS/core_cm0plus.h ****   \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
 989:../CMSIS/core_cm0plus.h ****            function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.
 990:../CMSIS/core_cm0plus.h ****            must contain a vendor-specific implementation of this function.
 991:../CMSIS/core_cm0plus.h ****  */
 992:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
 993:../CMSIS/core_cm0plus.h **** {
 994:../CMSIS/core_cm0plus.h ****   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 571              		.loc 2 994 0
 572 002a C94B     		ldr	r3, .L74+12
 573 002c 0138     		subs	r0, r0, #1
 574 002e 9842     		cmp	r0, r3
 575 0030 0DD8     		bhi	.L31
 576              	.LBB152:
 577              	.LBB153:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 578              		.loc 2 847 0
 579 0032 C021     		movs	r1, #192
 580              	.LBE153:
 581              	.LBE152:
 995:../CMSIS/core_cm0plus.h ****   {
 996:../CMSIS/core_cm0plus.h ****     return (1UL);                                                   /* Reload value impossible */
 997:../CMSIS/core_cm0plus.h ****   }
 998:../CMSIS/core_cm0plus.h **** 
 999:../CMSIS/core_cm0plus.h ****   SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 582              		.loc 2 999 0
 583 0034 C74A     		ldr	r2, .L74+16
 584              	.LBB156:
 585              	.LBB154:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 586              		.loc 2 847 0
 587 0036 0906     		lsls	r1, r1, #24
 588              	.LBE154:
 589              	.LBE156:
 590              		.loc 2 999 0
 591 0038 5060     		str	r0, [r2, #4]
 592              	.LVL52:
 593              	.LBB157:
 594              	.LBB155:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 595              		.loc 2 847 0
 596 003a C748     		ldr	r0, .L74+20
 597 003c 036A     		ldr	r3, [r0, #32]
 598 003e 1B02     		lsls	r3, r3, #8
 599 0040 1B0A     		lsrs	r3, r3, #8
 600 0042 0B43     		orrs	r3, r1
 601 0044 0362     		str	r3, [r0, #32]
 602              	.LVL53:
 603              	.LBE155:
 604              	.LBE157:
1000:../CMSIS/core_cm0plus.h ****   NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Int
1001:../CMSIS/core_cm0plus.h ****   SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Val
 605              		.loc 2 1001 0
 606 0046 0023     		movs	r3, #0
 607 0048 9360     		str	r3, [r2, #8]
1002:../CMSIS/core_cm0plus.h ****   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 608              		.loc 2 1002 0
 609 004a 0733     		adds	r3, r3, #7
 610 004c 1360     		str	r3, [r2]
 611              	.L31:
 612              	.LBE151:
 613              	.LBE150:
 614              	.LBB158:
 615              	.LBB159:
 450:../drivers/fsl_clock.h **** }
 616              		.loc 4 450 0
 617 004e 0125     		movs	r5, #1
 618              	.LBE159:
 619              	.LBE158:
 206:../source/main.c **** 
 207:../source/main.c **** 	initI2C();
 620              		.loc 1 207 0
 621 0050 FFF7FEFF 		bl	initI2C
 622              	.LVL54:
 208:../source/main.c **** 	//initAdc();
 209:../source/main.c **** 	initUART();
 210:../source/main.c **** 
 211:../source/main.c **** 	static const gpio_pin_config_t LED_configOutput =
 212:../source/main.c **** 	{ kGPIO_DigitalOutput, /* use as output pin */
 213:../source/main.c **** 	1, /* initial value */
 214:../source/main.c **** 	};
 215:../source/main.c **** 	GPIO_PinInit(GPIOA, 4u, &LED_configOutput);	//blue led as output
 623              		.loc 1 215 0
 624 0054 C14C     		ldr	r4, .L74+24
 209:../source/main.c **** 
 625              		.loc 1 209 0
 626 0056 FFF7FEFF 		bl	initUART
 627              	.LVL55:
 628              		.loc 1 215 0
 629 005a C14F     		ldr	r7, .L74+28
 630 005c 0421     		movs	r1, #4
 631 005e 3A00     		movs	r2, r7
 632 0060 2000     		movs	r0, r4
 633 0062 FFF7FEFF 		bl	GPIO_PinInit
 634              	.LVL56:
 635              	.LBB163:
 636              	.LBB160:
 450:../drivers/fsl_clock.h **** }
 637              		.loc 4 450 0
 638 0066 BF4A     		ldr	r2, .L74+32
 639              	.LBE160:
 640              	.LBE163:
 216:../source/main.c **** 
 217:../source/main.c **** 	char buf[30];
 218:../source/main.c **** 
 219:../source/main.c **** 	CLOCK_EnableClock(kCLOCK_Lptmr0);
 220:../source/main.c **** 	sprintf(buf, "lptimer int flag: %lx\r\n", LPTMR0->CSR);
 641              		.loc 1 220 0
 642 0068 BF4E     		ldr	r6, .L74+36
 643              	.LBB164:
 644              	.LBB161:
 450:../drivers/fsl_clock.h **** }
 645              		.loc 4 450 0
 646 006a 1368     		ldr	r3, [r2]
 647              	.LBE161:
 648              	.LBE164:
 649              		.loc 1 220 0
 650 006c BF49     		ldr	r1, .L74+40
 651              	.LBB165:
 652              	.LBB162:
 450:../drivers/fsl_clock.h **** }
 653              		.loc 4 450 0
 654 006e 2B43     		orrs	r3, r5
 655 0070 1360     		str	r3, [r2]
 656              	.LVL57:
 657              	.LBE162:
 658              	.LBE165:
 659              		.loc 1 220 0
 660 0072 3268     		ldr	r2, [r6]
 661 0074 09A8     		add	r0, sp, #36
 662 0076 FFF7FEFF 		bl	sprintf
 663              	.LVL58:
 221:../source/main.c **** 	PCprint(buf);
 664              		.loc 1 221 0
 665 007a 09A8     		add	r0, sp, #36
 666 007c FFF7FEFF 		bl	PCprint
 667              	.LVL59:
 222:../source/main.c **** 	configure_acc();
 668              		.loc 1 222 0
 669 0080 FFF7FEFF 		bl	configure_acc
 670              	.LVL60:
 223:../source/main.c **** 	acc_init();
 671              		.loc 1 223 0
 672 0084 FFF7FEFF 		bl	acc_init
 673              	.LVL61:
 224:../source/main.c **** 	initTimer();
 674              		.loc 1 224 0
 675 0088 FFF7FEFF 		bl	initTimer
 676              	.LVL62:
 677              	.LBB166:
 678              	.LBB167:
 679              		.file 5 "../drivers/fsl_smc.h"
   1:../drivers/fsl_smc.h **** /*
   2:../drivers/fsl_smc.h ****  * The Clear BSD License
   3:../drivers/fsl_smc.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_smc.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_smc.h ****  * All rights reserved.
   6:../drivers/fsl_smc.h ****  *
   7:../drivers/fsl_smc.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_smc.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_smc.h ****  * that the following conditions are met:
  10:../drivers/fsl_smc.h ****  *
  11:../drivers/fsl_smc.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_smc.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_smc.h ****  *
  14:../drivers/fsl_smc.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_smc.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_smc.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_smc.h ****  *
  18:../drivers/fsl_smc.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_smc.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_smc.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_smc.h ****  *
  22:../drivers/fsl_smc.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_smc.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_smc.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_smc.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_smc.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_smc.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_smc.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_smc.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_smc.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_smc.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_smc.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_smc.h ****  */
  34:../drivers/fsl_smc.h **** 
  35:../drivers/fsl_smc.h **** #ifndef _FSL_SMC_H_
  36:../drivers/fsl_smc.h **** #define _FSL_SMC_H_
  37:../drivers/fsl_smc.h **** 
  38:../drivers/fsl_smc.h **** #include "fsl_common.h"
  39:../drivers/fsl_smc.h **** 
  40:../drivers/fsl_smc.h **** /*! @addtogroup smc */
  41:../drivers/fsl_smc.h **** /*! @{ */
  42:../drivers/fsl_smc.h **** 
  43:../drivers/fsl_smc.h **** /*******************************************************************************
  44:../drivers/fsl_smc.h ****  * Definitions
  45:../drivers/fsl_smc.h ****  ******************************************************************************/
  46:../drivers/fsl_smc.h **** 
  47:../drivers/fsl_smc.h **** /*! @name Driver version */
  48:../drivers/fsl_smc.h **** /*@{*/
  49:../drivers/fsl_smc.h **** /*! @brief SMC driver version 2.0.3. */
  50:../drivers/fsl_smc.h **** #define FSL_SMC_DRIVER_VERSION (MAKE_VERSION(2, 0, 3))
  51:../drivers/fsl_smc.h **** /*@}*/
  52:../drivers/fsl_smc.h **** 
  53:../drivers/fsl_smc.h **** /*!
  54:../drivers/fsl_smc.h ****  * @brief Power Modes Protection
  55:../drivers/fsl_smc.h ****  */
  56:../drivers/fsl_smc.h **** typedef enum _smc_power_mode_protection
  57:../drivers/fsl_smc.h **** {
  58:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
  59:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeVlls = SMC_PMPROT_AVLLS_MASK, /*!< Allow Very-low-leakage Stop Mode. */
  60:../drivers/fsl_smc.h **** #endif
  61:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
  62:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeLls = SMC_PMPROT_ALLS_MASK, /*!< Allow Low-leakage Stop Mode.      */
  63:../drivers/fsl_smc.h **** #endif                                             /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
  64:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeVlp = SMC_PMPROT_AVLP_MASK, /*!< Allow Very-Low-power Mode.        */
  65:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
  66:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeHsrun = SMC_PMPROT_AHSRUN_MASK, /*!< Allow High-speed Run mode.        */
  67:../drivers/fsl_smc.h **** #endif                                                 /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE *
  68:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeAll = (0U
  69:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
  70:../drivers/fsl_smc.h ****                               |
  71:../drivers/fsl_smc.h ****                               SMC_PMPROT_AVLLS_MASK
  72:../drivers/fsl_smc.h **** #endif
  73:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
  74:../drivers/fsl_smc.h ****                               |
  75:../drivers/fsl_smc.h ****                               SMC_PMPROT_ALLS_MASK
  76:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
  77:../drivers/fsl_smc.h ****                               |
  78:../drivers/fsl_smc.h ****                               SMC_PMPROT_AVLP_MASK
  79:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
  80:../drivers/fsl_smc.h ****                               |
  81:../drivers/fsl_smc.h ****                               kSMC_AllowPowerModeHsrun
  82:../drivers/fsl_smc.h **** #endif                          /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
  83:../drivers/fsl_smc.h ****                               ) /*!< Allow all power mode.              */
  84:../drivers/fsl_smc.h **** } smc_power_mode_protection_t;
  85:../drivers/fsl_smc.h **** 
  86:../drivers/fsl_smc.h **** /*!
  87:../drivers/fsl_smc.h ****  * @brief Power Modes in PMSTAT
  88:../drivers/fsl_smc.h ****  */
  89:../drivers/fsl_smc.h **** typedef enum _smc_power_state
  90:../drivers/fsl_smc.h **** {
  91:../drivers/fsl_smc.h ****     kSMC_PowerStateRun = 0x01U << 0U,  /*!< 0000_0001 - Current power mode is RUN   */
  92:../drivers/fsl_smc.h ****     kSMC_PowerStateStop = 0x01U << 1U, /*!< 0000_0010 - Current power mode is STOP  */
  93:../drivers/fsl_smc.h ****     kSMC_PowerStateVlpr = 0x01U << 2U, /*!< 0000_0100 - Current power mode is VLPR  */
  94:../drivers/fsl_smc.h ****     kSMC_PowerStateVlpw = 0x01U << 3U, /*!< 0000_1000 - Current power mode is VLPW  */
  95:../drivers/fsl_smc.h ****     kSMC_PowerStateVlps = 0x01U << 4U, /*!< 0001_0000 - Current power mode is VLPS  */
  96:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
  97:../drivers/fsl_smc.h ****     kSMC_PowerStateLls = 0x01U << 5U, /*!< 0010_0000 - Current power mode is LLS   */
  98:../drivers/fsl_smc.h **** #endif                                /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
  99:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 100:../drivers/fsl_smc.h ****     kSMC_PowerStateVlls = 0x01U << 6U, /*!< 0100_0000 - Current power mode is VLLS  */
 101:../drivers/fsl_smc.h **** #endif
 102:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
 103:../drivers/fsl_smc.h ****     kSMC_PowerStateHsrun = 0x01U << 7U /*!< 1000_0000 - Current power mode is HSRUN */
 104:../drivers/fsl_smc.h **** #endif                                 /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
 105:../drivers/fsl_smc.h **** } smc_power_state_t;
 106:../drivers/fsl_smc.h **** 
 107:../drivers/fsl_smc.h **** /*!
 108:../drivers/fsl_smc.h ****  * @brief Run mode definition
 109:../drivers/fsl_smc.h ****  */
 110:../drivers/fsl_smc.h **** typedef enum _smc_run_mode
 111:../drivers/fsl_smc.h **** {
 112:../drivers/fsl_smc.h ****     kSMC_RunNormal = 0U, /*!< Normal RUN mode.             */
 113:../drivers/fsl_smc.h ****     kSMC_RunVlpr = 2U,   /*!< Very-low-power RUN mode.     */
 114:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
 115:../drivers/fsl_smc.h ****     kSMC_Hsrun = 3U /*!< High-speed Run mode (HSRUN). */
 116:../drivers/fsl_smc.h **** #endif              /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
 117:../drivers/fsl_smc.h **** } smc_run_mode_t;
 118:../drivers/fsl_smc.h **** 
 119:../drivers/fsl_smc.h **** /*!
 120:../drivers/fsl_smc.h ****  * @brief Stop mode definition
 121:../drivers/fsl_smc.h ****  */
 122:../drivers/fsl_smc.h **** typedef enum _smc_stop_mode
 123:../drivers/fsl_smc.h **** {
 124:../drivers/fsl_smc.h ****     kSMC_StopNormal = 0U, /*!< Normal STOP mode.           */
 125:../drivers/fsl_smc.h ****     kSMC_StopVlps = 2U,   /*!< Very-low-power STOP mode.   */
 126:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
 127:../drivers/fsl_smc.h ****     kSMC_StopLls = 3U, /*!< Low-leakage Stop mode.      */
 128:../drivers/fsl_smc.h **** #endif                 /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
 129:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 130:../drivers/fsl_smc.h ****     kSMC_StopVlls = 4U /*!< Very-low-leakage Stop mode. */
 131:../drivers/fsl_smc.h **** #endif
 132:../drivers/fsl_smc.h **** } smc_stop_mode_t;
 133:../drivers/fsl_smc.h **** 
 134:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG) ||     \
 135:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) && FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) || \
 136:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 137:../drivers/fsl_smc.h **** /*!
 138:../drivers/fsl_smc.h ****  * @brief VLLS/LLS stop sub mode definition
 139:../drivers/fsl_smc.h ****  */
 140:../drivers/fsl_smc.h **** typedef enum _smc_stop_submode
 141:../drivers/fsl_smc.h **** {
 142:../drivers/fsl_smc.h ****     kSMC_StopSub0 = 0U, /*!< Stop submode 0, for VLLS0/LLS0. */
 143:../drivers/fsl_smc.h ****     kSMC_StopSub1 = 1U, /*!< Stop submode 1, for VLLS1/LLS1. */
 144:../drivers/fsl_smc.h ****     kSMC_StopSub2 = 2U, /*!< Stop submode 2, for VLLS2/LLS2. */
 145:../drivers/fsl_smc.h ****     kSMC_StopSub3 = 3U  /*!< Stop submode 3, for VLLS3/LLS3. */
 146:../drivers/fsl_smc.h **** } smc_stop_submode_t;
 147:../drivers/fsl_smc.h **** #endif
 148:../drivers/fsl_smc.h **** 
 149:../drivers/fsl_smc.h **** /*!
 150:../drivers/fsl_smc.h ****  * @brief Partial STOP option
 151:../drivers/fsl_smc.h ****  */
 152:../drivers/fsl_smc.h **** typedef enum _smc_partial_stop_mode
 153:../drivers/fsl_smc.h **** {
 154:../drivers/fsl_smc.h ****     kSMC_PartialStop = 0U,  /*!< STOP - Normal Stop mode*/
 155:../drivers/fsl_smc.h ****     kSMC_PartialStop1 = 1U, /*!< Partial Stop with both system and bus clocks disabled*/
 156:../drivers/fsl_smc.h ****     kSMC_PartialStop2 = 2U, /*!< Partial Stop with system clock disabled and bus clock enabled*/
 157:../drivers/fsl_smc.h **** } smc_partial_stop_option_t;
 158:../drivers/fsl_smc.h **** 
 159:../drivers/fsl_smc.h **** /*!
 160:../drivers/fsl_smc.h ****  * @brief SMC configuration status.
 161:../drivers/fsl_smc.h ****  */
 162:../drivers/fsl_smc.h **** enum _smc_status
 163:../drivers/fsl_smc.h **** {
 164:../drivers/fsl_smc.h ****     kStatus_SMC_StopAbort = MAKE_STATUS(kStatusGroup_POWER, 0) /*!< Entering Stop mode is abort*/
 165:../drivers/fsl_smc.h **** };
 166:../drivers/fsl_smc.h **** 
 167:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERID) && FSL_FEATURE_SMC_HAS_VERID)
 168:../drivers/fsl_smc.h **** /*!
 169:../drivers/fsl_smc.h ****  * @brief IP version ID definition.
 170:../drivers/fsl_smc.h ****  */
 171:../drivers/fsl_smc.h **** typedef struct _smc_version_id
 172:../drivers/fsl_smc.h **** {
 173:../drivers/fsl_smc.h ****     uint16_t feature; /*!< Feature Specification Number. */
 174:../drivers/fsl_smc.h ****     uint8_t minor;    /*!< Minor version number.         */
 175:../drivers/fsl_smc.h ****     uint8_t major;    /*!< Major version number.         */
 176:../drivers/fsl_smc.h **** } smc_version_id_t;
 177:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_VERID */
 178:../drivers/fsl_smc.h **** 
 179:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_PARAM) && FSL_FEATURE_SMC_HAS_PARAM)
 180:../drivers/fsl_smc.h **** /*!
 181:../drivers/fsl_smc.h ****  * @brief IP parameter definition.
 182:../drivers/fsl_smc.h ****  */
 183:../drivers/fsl_smc.h **** typedef struct _smc_param
 184:../drivers/fsl_smc.h **** {
 185:../drivers/fsl_smc.h ****     bool hsrunEnable; /*!< HSRUN mode enable. */
 186:../drivers/fsl_smc.h ****     bool llsEnable;   /*!< LLS mode enable.   */
 187:../drivers/fsl_smc.h ****     bool lls2Enable;  /*!< LLS2 mode enable.  */
 188:../drivers/fsl_smc.h ****     bool vlls0Enable; /*!< VLLS0 mode enable. */
 189:../drivers/fsl_smc.h **** } smc_param_t;
 190:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_PARAM */
 191:../drivers/fsl_smc.h **** 
 192:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE) || \
 193:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 194:../drivers/fsl_smc.h **** /*!
 195:../drivers/fsl_smc.h ****  * @brief SMC Low-Leakage Stop power mode configuration.
 196:../drivers/fsl_smc.h ****  */
 197:../drivers/fsl_smc.h **** typedef struct _smc_power_mode_lls_config
 198:../drivers/fsl_smc.h **** {
 199:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 200:../drivers/fsl_smc.h ****     smc_stop_submode_t subMode; /*!< Low-leakage Stop sub-mode */
 201:../drivers/fsl_smc.h **** #endif
 202:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 203:../drivers/fsl_smc.h ****     bool enableLpoClock; /*!< Enable LPO clock in LLS mode */
 204:../drivers/fsl_smc.h **** #endif
 205:../drivers/fsl_smc.h **** } smc_power_mode_lls_config_t;
 206:../drivers/fsl_smc.h **** #endif /* (FSL_FEATURE_SMC_HAS_LLS_SUBMODE || FSL_FEATURE_SMC_HAS_LPOPO) */
 207:../drivers/fsl_smc.h **** 
 208:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 209:../drivers/fsl_smc.h **** /*!
 210:../drivers/fsl_smc.h ****  * @brief SMC Very Low-Leakage Stop power mode configuration.
 211:../drivers/fsl_smc.h ****  */
 212:../drivers/fsl_smc.h **** typedef struct _smc_power_mode_vlls_config
 213:../drivers/fsl_smc.h **** {
 214:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG) ||     \
 215:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) && FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) || \
 216:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 217:../drivers/fsl_smc.h ****     smc_stop_submode_t subMode; /*!< Very Low-leakage Stop sub-mode */
 218:../drivers/fsl_smc.h **** #endif
 219:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_PORPO) && FSL_FEATURE_SMC_HAS_PORPO)
 220:../drivers/fsl_smc.h ****     bool enablePorDetectInVlls0; /*!< Enable Power on reset detect in VLLS mode */
 221:../drivers/fsl_smc.h **** #endif
 222:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION) && FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION)
 223:../drivers/fsl_smc.h ****     bool enableRam2InVlls2; /*!< Enable RAM2 power in VLLS2 */
 224:../drivers/fsl_smc.h **** #endif
 225:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 226:../drivers/fsl_smc.h ****     bool enableLpoClock; /*!< Enable LPO clock in VLLS mode */
 227:../drivers/fsl_smc.h **** #endif
 228:../drivers/fsl_smc.h **** } smc_power_mode_vlls_config_t;
 229:../drivers/fsl_smc.h **** #endif
 230:../drivers/fsl_smc.h **** 
 231:../drivers/fsl_smc.h **** /*******************************************************************************
 232:../drivers/fsl_smc.h ****  * API
 233:../drivers/fsl_smc.h ****  ******************************************************************************/
 234:../drivers/fsl_smc.h **** 
 235:../drivers/fsl_smc.h **** #if defined(__cplusplus)
 236:../drivers/fsl_smc.h **** extern "C" {
 237:../drivers/fsl_smc.h **** #endif /* __cplusplus */
 238:../drivers/fsl_smc.h **** 
 239:../drivers/fsl_smc.h **** /*! @name System mode controller APIs*/
 240:../drivers/fsl_smc.h **** /*@{*/
 241:../drivers/fsl_smc.h **** 
 242:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERID) && FSL_FEATURE_SMC_HAS_VERID)
 243:../drivers/fsl_smc.h **** /*!
 244:../drivers/fsl_smc.h ****  * @brief Gets the SMC version ID.
 245:../drivers/fsl_smc.h ****  *
 246:../drivers/fsl_smc.h ****  * This function gets the SMC version ID, including major version number,
 247:../drivers/fsl_smc.h ****  * minor version number, and feature specification number.
 248:../drivers/fsl_smc.h ****  *
 249:../drivers/fsl_smc.h ****  * @param base SMC peripheral base address.
 250:../drivers/fsl_smc.h ****  * @param versionId     Pointer to the version ID structure.
 251:../drivers/fsl_smc.h ****  */
 252:../drivers/fsl_smc.h **** static inline void SMC_GetVersionId(SMC_Type *base, smc_version_id_t *versionId)
 253:../drivers/fsl_smc.h **** {
 254:../drivers/fsl_smc.h ****     *((uint32_t *)versionId) = base->VERID;
 255:../drivers/fsl_smc.h **** }
 256:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_VERID */
 257:../drivers/fsl_smc.h **** 
 258:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_PARAM) && FSL_FEATURE_SMC_HAS_PARAM)
 259:../drivers/fsl_smc.h **** /*!
 260:../drivers/fsl_smc.h ****  * @brief Gets the SMC parameter.
 261:../drivers/fsl_smc.h ****  *
 262:../drivers/fsl_smc.h ****  * This function gets the SMC parameter including the enabled power mdoes.
 263:../drivers/fsl_smc.h ****  *
 264:../drivers/fsl_smc.h ****  * @param base SMC peripheral base address.
 265:../drivers/fsl_smc.h ****  * @param param         Pointer to the SMC param structure.
 266:../drivers/fsl_smc.h ****  */
 267:../drivers/fsl_smc.h **** void SMC_GetParam(SMC_Type *base, smc_param_t *param);
 268:../drivers/fsl_smc.h **** #endif
 269:../drivers/fsl_smc.h **** 
 270:../drivers/fsl_smc.h **** /*!
 271:../drivers/fsl_smc.h ****  * @brief Configures all power mode protection settings.
 272:../drivers/fsl_smc.h ****  *
 273:../drivers/fsl_smc.h ****  * This function  configures the power mode protection settings for
 274:../drivers/fsl_smc.h ****  * supported power modes in the specified chip family. The available power modes
 275:../drivers/fsl_smc.h ****  * are defined in the smc_power_mode_protection_t. This should be done at an early
 276:../drivers/fsl_smc.h ****  * system level initialization stage. See the reference manual for details.
 277:../drivers/fsl_smc.h ****  * This register can only write once after the power reset.
 278:../drivers/fsl_smc.h ****  *
 279:../drivers/fsl_smc.h ****  * The allowed modes are passed as bit map. For example, to allow LLS and VLLS,
 280:../drivers/fsl_smc.h ****  * use SMC_SetPowerModeProtection(kSMC_AllowPowerModeVlls | kSMC_AllowPowerModeVlps).
 281:../drivers/fsl_smc.h ****  * To allow all modes, use SMC_SetPowerModeProtection(kSMC_AllowPowerModeAll).
 282:../drivers/fsl_smc.h ****  *
 283:../drivers/fsl_smc.h ****  * @param base SMC peripheral base address.
 284:../drivers/fsl_smc.h ****  * @param allowedModes Bitmap of the allowed power modes.
 285:../drivers/fsl_smc.h ****  */
 286:../drivers/fsl_smc.h **** static inline void SMC_SetPowerModeProtection(SMC_Type *base, uint8_t allowedModes)
 287:../drivers/fsl_smc.h **** {
 288:../drivers/fsl_smc.h ****     base->PMPROT = allowedModes;
 680              		.loc 5 288 0
 681 008c 2A23     		movs	r3, #42
 682 008e B84A     		ldr	r2, .L74+44
 683              	.LBE167:
 684              	.LBE166:
 225:../source/main.c **** 
 226:../source/main.c **** 	SMC_SetPowerModeProtection(SMC, kSMC_AllowPowerModeAll);
 227:../source/main.c **** 	smc_power_mode_vlls_config.subMode = kSMC_StopSub1; //!< Stop submode 1, for VLLS1/LLS1.
 228:../source/main.c **** 
 229:../source/main.c **** 	LLWU->ME |= 0x01; 		// enable LLWU wakeup source from LPTMR module
 230:../source/main.c **** 	LLWU->PE2 |= 0x04; // enable LLWU wakeup source from accelerometer interrupt pin
 231:../source/main.c **** 	// 0x20 for stock frdm pin enable,
 232:../source/main.c **** 	LLWU->FILT1 |= 0x25;	// set pin wakeup from rising edge, 0x2A for frdm
 233:../source/main.c **** 
 234:../source/main.c **** 	//EnableIRQ(PORTC_IRQn);
 235:../source/main.c **** 
 236:../source/main.c **** 	LPTMR_EnableInterrupts(LPTMR0, kLPTMR_TimerInterruptEnable);//Sets Timer Interrupt Enable bit to 1
 237:../source/main.c **** 	LPTMR_StartTimer(LPTMR0);
 238:../source/main.c **** 
 239:../source/main.c **** 	GPIO_PinInit(GPIOA, 19u, &LED_configOutput);
 685              		.loc 1 239 0
 686 0090 2000     		movs	r0, r4
 687              	.LBB169:
 688              	.LBB168:
 689              		.loc 5 288 0
 690 0092 1370     		strb	r3, [r2]
 691              	.LVL63:
 692              	.LBE168:
 693              	.LBE169:
 227:../source/main.c **** 
 694              		.loc 1 227 0
 695 0094 B74B     		ldr	r3, .L74+48
 696 0096 1D70     		strb	r5, [r3]
 229:../source/main.c **** 	LLWU->PE2 |= 0x04; // enable LLWU wakeup source from accelerometer interrupt pin
 697              		.loc 1 229 0
 698 0098 B74B     		ldr	r3, .L74+52
 699 009a 1A79     		ldrb	r2, [r3, #4]
 700 009c 2A43     		orrs	r2, r5
 701 009e 1A71     		strb	r2, [r3, #4]
 230:../source/main.c **** 	// 0x20 for stock frdm pin enable,
 702              		.loc 1 230 0
 703 00a0 0422     		movs	r2, #4
 704 00a2 5978     		ldrb	r1, [r3, #1]
 705 00a4 0A43     		orrs	r2, r1
 706 00a6 5A70     		strb	r2, [r3, #1]
 232:../source/main.c **** 
 707              		.loc 1 232 0
 708 00a8 2522     		movs	r2, #37
 709 00aa 197A     		ldrb	r1, [r3, #8]
 710 00ac 0A43     		orrs	r2, r1
 711              	.LBB170:
 712              	.LBB171:
 208:../drivers/fsl_lptmr.h ****     reg |= mask;
 713              		.loc 3 208 0
 714 00ae 8021     		movs	r1, #128
 715              	.LBE171:
 716              	.LBE170:
 232:../source/main.c **** 
 717              		.loc 1 232 0
 718 00b0 1A72     		strb	r2, [r3, #8]
 719              	.LVL64:
 720              	.LBB173:
 721              	.LBB172:
 209:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 722              		.loc 3 209 0
 723 00b2 4023     		movs	r3, #64
 205:../drivers/fsl_lptmr.h **** 
 724              		.loc 3 205 0
 725 00b4 3268     		ldr	r2, [r6]
 726              	.LVL65:
 208:../drivers/fsl_lptmr.h ****     reg |= mask;
 727              		.loc 3 208 0
 728 00b6 8A43     		bics	r2, r1
 729              	.LVL66:
 209:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 730              		.loc 3 209 0
 731 00b8 1343     		orrs	r3, r2
 732              	.LVL67:
 210:../drivers/fsl_lptmr.h **** }
 733              		.loc 3 210 0
 734 00ba 3360     		str	r3, [r6]
 735              	.LVL68:
 736              	.LBE172:
 737              	.LBE173:
 738              	.LBB174:
 739              	.LBB175:
 319:../drivers/fsl_lptmr.h **** }
 320:../drivers/fsl_lptmr.h **** 
 321:../drivers/fsl_lptmr.h **** /*!
 322:../drivers/fsl_lptmr.h ****  * @brief Reads the current timer counting value.
 323:../drivers/fsl_lptmr.h ****  *
 324:../drivers/fsl_lptmr.h ****  * This function returns the real-time timer counting value in a range from 0 to a
 325:../drivers/fsl_lptmr.h ****  * timer period.
 326:../drivers/fsl_lptmr.h ****  *
 327:../drivers/fsl_lptmr.h ****  * @note Call the utility macros provided in the fsl_common.h to convert ticks to usec or msec.
 328:../drivers/fsl_lptmr.h ****  *
 329:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 330:../drivers/fsl_lptmr.h ****  *
 331:../drivers/fsl_lptmr.h ****  * @return The current counter value in ticks
 332:../drivers/fsl_lptmr.h ****  */
 333:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetCurrentTimerCount(LPTMR_Type *base)
 334:../drivers/fsl_lptmr.h **** {
 335:../drivers/fsl_lptmr.h ****     /* Must first write any value to the CNR. This synchronizes and registers the current value
 336:../drivers/fsl_lptmr.h ****      * of the CNR into a temporary register which can then be read
 337:../drivers/fsl_lptmr.h ****      */
 338:../drivers/fsl_lptmr.h ****     base->CNR = 0U;
 339:../drivers/fsl_lptmr.h ****     return (uint32_t)((base->CNR & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT);
 340:../drivers/fsl_lptmr.h **** }
 341:../drivers/fsl_lptmr.h **** 
 342:../drivers/fsl_lptmr.h **** /*! @}*/
 343:../drivers/fsl_lptmr.h **** 
 344:../drivers/fsl_lptmr.h **** /*!
 345:../drivers/fsl_lptmr.h ****  * @name Timer Start and Stop
 346:../drivers/fsl_lptmr.h ****  * @{
 347:../drivers/fsl_lptmr.h ****  */
 348:../drivers/fsl_lptmr.h **** 
 349:../drivers/fsl_lptmr.h **** /*!
 350:../drivers/fsl_lptmr.h ****  * @brief Starts the timer.
 351:../drivers/fsl_lptmr.h ****  *
 352:../drivers/fsl_lptmr.h ****  * After calling this function, the timer counts up to the CMR register value.
 353:../drivers/fsl_lptmr.h ****  * Each time the timer reaches the CMR value and then increments, it generates a
 354:../drivers/fsl_lptmr.h ****  * trigger pulse and sets the timeout interrupt flag. An interrupt is also
 355:../drivers/fsl_lptmr.h ****  * triggered if the timer interrupt is enabled.
 356:../drivers/fsl_lptmr.h ****  *
 357:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 358:../drivers/fsl_lptmr.h ****  */
 359:../drivers/fsl_lptmr.h **** static inline void LPTMR_StartTimer(LPTMR_Type *base)
 360:../drivers/fsl_lptmr.h **** {
 361:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 740              		.loc 3 361 0
 741 00bc 3368     		ldr	r3, [r6]
 742              	.LVL69:
 743              	.LBE175:
 744              	.LBE174:
 745              		.loc 1 239 0
 746 00be 3A00     		movs	r2, r7
 747              	.LBB177:
 748              	.LBB176:
 362:../drivers/fsl_lptmr.h **** 
 363:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit to avoid clearing the w1c bit when writing back. */
 364:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 749              		.loc 3 364 0
 750 00c0 8B43     		bics	r3, r1
 751              	.LVL70:
 365:../drivers/fsl_lptmr.h ****     reg |= LPTMR_CSR_TEN_MASK;
 752              		.loc 3 365 0
 753 00c2 2B43     		orrs	r3, r5
 754              	.LVL71:
 366:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 755              		.loc 3 366 0
 756 00c4 3360     		str	r3, [r6]
 757              	.LVL72:
 758              	.LBE176:
 759              	.LBE177:
 760              		.loc 1 239 0
 761 00c6 6D39     		subs	r1, r1, #109
 762 00c8 FFF7FEFF 		bl	GPIO_PinInit
 763              	.LVL73:
 764              	.LBB178:
 765              	.LBB179:
 766              	.LBB180:
 767              		.file 6 "../drivers/fsl_gpio.h"
   1:../drivers/fsl_gpio.h **** /*
   2:../drivers/fsl_gpio.h ****  * The Clear BSD License
   3:../drivers/fsl_gpio.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_gpio.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_gpio.h ****  * All rights reserved.
   6:../drivers/fsl_gpio.h ****  *
   7:../drivers/fsl_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_gpio.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_gpio.h ****  * that the following conditions are met:
  10:../drivers/fsl_gpio.h ****  *
  11:../drivers/fsl_gpio.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_gpio.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_gpio.h ****  *
  14:../drivers/fsl_gpio.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_gpio.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_gpio.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_gpio.h ****  *
  18:../drivers/fsl_gpio.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_gpio.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_gpio.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_gpio.h ****  *
  22:../drivers/fsl_gpio.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_gpio.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_gpio.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_gpio.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_gpio.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_gpio.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_gpio.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_gpio.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_gpio.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_gpio.h ****  */
  34:../drivers/fsl_gpio.h **** 
  35:../drivers/fsl_gpio.h **** #ifndef _FSL_GPIO_H_
  36:../drivers/fsl_gpio.h **** #define _FSL_GPIO_H_
  37:../drivers/fsl_gpio.h **** 
  38:../drivers/fsl_gpio.h **** #include "fsl_common.h"
  39:../drivers/fsl_gpio.h **** 
  40:../drivers/fsl_gpio.h **** /*!
  41:../drivers/fsl_gpio.h ****  * @addtogroup gpio
  42:../drivers/fsl_gpio.h ****  * @{
  43:../drivers/fsl_gpio.h ****  */
  44:../drivers/fsl_gpio.h **** 
  45:../drivers/fsl_gpio.h **** /*******************************************************************************
  46:../drivers/fsl_gpio.h ****  * Definitions
  47:../drivers/fsl_gpio.h ****  ******************************************************************************/
  48:../drivers/fsl_gpio.h **** 
  49:../drivers/fsl_gpio.h **** /*! @name Driver version */
  50:../drivers/fsl_gpio.h **** /*@{*/
  51:../drivers/fsl_gpio.h **** /*! @brief GPIO driver version 2.2.1. */
  52:../drivers/fsl_gpio.h **** #define FSL_GPIO_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  53:../drivers/fsl_gpio.h **** /*@}*/
  54:../drivers/fsl_gpio.h **** 
  55:../drivers/fsl_gpio.h **** /*! @brief GPIO direction definition */
  56:../drivers/fsl_gpio.h **** typedef enum _gpio_pin_direction
  57:../drivers/fsl_gpio.h **** {
  58:../drivers/fsl_gpio.h ****     kGPIO_DigitalInput = 0U,  /*!< Set current pin as digital input*/
  59:../drivers/fsl_gpio.h ****     kGPIO_DigitalOutput = 1U, /*!< Set current pin as digital output*/
  60:../drivers/fsl_gpio.h **** } gpio_pin_direction_t;
  61:../drivers/fsl_gpio.h **** 
  62:../drivers/fsl_gpio.h **** #if defined(FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER
  63:../drivers/fsl_gpio.h **** /*! @brief GPIO checker attribute */
  64:../drivers/fsl_gpio.h **** typedef enum _gpio_checker_attribute
  65:../drivers/fsl_gpio.h **** {
  66:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRWUsersecureRWPrivilegedsecureRW =
  67:../drivers/fsl_gpio.h ****         0x00U, /*!< User nonsecure:Read+Write; User Secure:Read+Write; Privileged Secure:Read+Write
  68:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRUsersecureRWPrivilegedsecureRW =
  69:../drivers/fsl_gpio.h ****         0x01U, /*!< User nonsecure:Read;       User Secure:Read+Write; Privileged Secure:Read+Write
  70:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureRWPrivilegedsecureRW =
  71:../drivers/fsl_gpio.h ****         0x02U, /*!< User nonsecure:None;       User Secure:Read+Write; Privileged Secure:Read+Write
  72:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRUsersecureRPrivilegedsecureRW =
  73:../drivers/fsl_gpio.h ****         0x03U, /*!< User nonsecure:Read;       User Secure:Read;       Privileged Secure:Read+Write
  74:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureRPrivilegedsecureRW =
  75:../drivers/fsl_gpio.h ****         0x04U, /*!< User nonsecure:None;       User Secure:Read;       Privileged Secure:Read+Write
  76:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureRW =
  77:../drivers/fsl_gpio.h ****         0x05U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:Read+Write
  78:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureR =
  79:../drivers/fsl_gpio.h ****         0x06U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:Read */
  80:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureN =
  81:../drivers/fsl_gpio.h ****         0x07U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:None */
  82:../drivers/fsl_gpio.h ****     kGPIO_IgnoreAttributeCheck = 0x80U, /*!< Ignores the attribute check */
  83:../drivers/fsl_gpio.h **** } gpio_checker_attribute_t;
  84:../drivers/fsl_gpio.h **** #endif
  85:../drivers/fsl_gpio.h **** 
  86:../drivers/fsl_gpio.h **** /*!
  87:../drivers/fsl_gpio.h ****  * @brief The GPIO pin configuration structure.
  88:../drivers/fsl_gpio.h ****  *
  89:../drivers/fsl_gpio.h ****  * Each pin can only be configured as either an output pin or an input pin at a time.
  90:../drivers/fsl_gpio.h ****  * If configured as an input pin, leave the outputConfig unused.
  91:../drivers/fsl_gpio.h ****  * Note that in some use cases, the corresponding port property should be configured in advance
  92:../drivers/fsl_gpio.h ****  *        with the PORT_SetPinConfig().
  93:../drivers/fsl_gpio.h ****  */
  94:../drivers/fsl_gpio.h **** typedef struct _gpio_pin_config
  95:../drivers/fsl_gpio.h **** {
  96:../drivers/fsl_gpio.h ****     gpio_pin_direction_t pinDirection; /*!< GPIO direction, input or output */
  97:../drivers/fsl_gpio.h ****     /* Output configurations; ignore if configured as an input pin */
  98:../drivers/fsl_gpio.h ****     uint8_t outputLogic; /*!< Set a default output logic, which has no use in input */
  99:../drivers/fsl_gpio.h **** } gpio_pin_config_t;
 100:../drivers/fsl_gpio.h **** 
 101:../drivers/fsl_gpio.h **** /*! @} */
 102:../drivers/fsl_gpio.h **** 
 103:../drivers/fsl_gpio.h **** /*******************************************************************************
 104:../drivers/fsl_gpio.h ****  * API
 105:../drivers/fsl_gpio.h ****  ******************************************************************************/
 106:../drivers/fsl_gpio.h **** 
 107:../drivers/fsl_gpio.h **** #if defined(__cplusplus)
 108:../drivers/fsl_gpio.h **** extern "C" {
 109:../drivers/fsl_gpio.h **** #endif
 110:../drivers/fsl_gpio.h **** 
 111:../drivers/fsl_gpio.h **** /*!
 112:../drivers/fsl_gpio.h ****  * @addtogroup gpio_driver
 113:../drivers/fsl_gpio.h ****  * @{
 114:../drivers/fsl_gpio.h ****  */
 115:../drivers/fsl_gpio.h **** 
 116:../drivers/fsl_gpio.h **** /*! @name GPIO Configuration */
 117:../drivers/fsl_gpio.h **** /*@{*/
 118:../drivers/fsl_gpio.h **** 
 119:../drivers/fsl_gpio.h **** /*!
 120:../drivers/fsl_gpio.h ****  * @brief Initializes a GPIO pin used by the board.
 121:../drivers/fsl_gpio.h ****  *
 122:../drivers/fsl_gpio.h ****  * To initialize the GPIO, define a pin configuration, as either input or output, in the user file.
 123:../drivers/fsl_gpio.h ****  * Then, call the GPIO_PinInit() function.
 124:../drivers/fsl_gpio.h ****  *
 125:../drivers/fsl_gpio.h ****  * This is an example to define an input pin or an output pin configuration.
 126:../drivers/fsl_gpio.h ****  * @code
 127:../drivers/fsl_gpio.h ****  * // Define a digital input pin configuration,
 128:../drivers/fsl_gpio.h ****  * gpio_pin_config_t config =
 129:../drivers/fsl_gpio.h ****  * {
 130:../drivers/fsl_gpio.h ****  *   kGPIO_DigitalInput,
 131:../drivers/fsl_gpio.h ****  *   0,
 132:../drivers/fsl_gpio.h ****  * }
 133:../drivers/fsl_gpio.h ****  * //Define a digital output pin configuration,
 134:../drivers/fsl_gpio.h ****  * gpio_pin_config_t config =
 135:../drivers/fsl_gpio.h ****  * {
 136:../drivers/fsl_gpio.h ****  *   kGPIO_DigitalOutput,
 137:../drivers/fsl_gpio.h ****  *   0,
 138:../drivers/fsl_gpio.h ****  * }
 139:../drivers/fsl_gpio.h ****  * @endcode
 140:../drivers/fsl_gpio.h ****  *
 141:../drivers/fsl_gpio.h ****  * @param base   GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 142:../drivers/fsl_gpio.h ****  * @param pin    GPIO port pin number
 143:../drivers/fsl_gpio.h ****  * @param config GPIO pin configuration pointer
 144:../drivers/fsl_gpio.h ****  */
 145:../drivers/fsl_gpio.h **** void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config);
 146:../drivers/fsl_gpio.h **** 
 147:../drivers/fsl_gpio.h **** /*@}*/
 148:../drivers/fsl_gpio.h **** 
 149:../drivers/fsl_gpio.h **** /*! @name GPIO Output Operations */
 150:../drivers/fsl_gpio.h **** /*@{*/
 151:../drivers/fsl_gpio.h **** 
 152:../drivers/fsl_gpio.h **** /*!
 153:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1 or 0.
 154:../drivers/fsl_gpio.h ****  *
 155:../drivers/fsl_gpio.h ****  * @param base    GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 156:../drivers/fsl_gpio.h ****  * @param pin     GPIO pin number
 157:../drivers/fsl_gpio.h ****  * @param output  GPIO pin output logic level.
 158:../drivers/fsl_gpio.h ****  *        - 0: corresponding pin output low-logic level.
 159:../drivers/fsl_gpio.h ****  *        - 1: corresponding pin output high-logic level.
 160:../drivers/fsl_gpio.h ****  */
 161:../drivers/fsl_gpio.h **** static inline void GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)
 162:../drivers/fsl_gpio.h **** {
 163:../drivers/fsl_gpio.h ****     if (output == 0U)
 164:../drivers/fsl_gpio.h ****     {
 165:../drivers/fsl_gpio.h ****         base->PCOR = 1U << pin;
 166:../drivers/fsl_gpio.h ****     }
 167:../drivers/fsl_gpio.h ****     else
 168:../drivers/fsl_gpio.h ****     {
 169:../drivers/fsl_gpio.h ****         base->PSOR = 1U << pin;
 170:../drivers/fsl_gpio.h ****     }
 171:../drivers/fsl_gpio.h **** }
 172:../drivers/fsl_gpio.h **** 
 173:../drivers/fsl_gpio.h **** /*!
 174:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1 or 0.
 175:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PinWrite.
 176:../drivers/fsl_gpio.h ****  */
 177:../drivers/fsl_gpio.h **** static inline void GPIO_WritePinOutput(GPIO_Type *base, uint32_t pin, uint8_t output)
 178:../drivers/fsl_gpio.h **** {
 179:../drivers/fsl_gpio.h ****     GPIO_PinWrite(base, pin, output);
 180:../drivers/fsl_gpio.h **** }
 181:../drivers/fsl_gpio.h **** 
 182:../drivers/fsl_gpio.h **** /*!
 183:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1.
 184:../drivers/fsl_gpio.h ****  *
 185:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 186:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 187:../drivers/fsl_gpio.h ****  */
 188:../drivers/fsl_gpio.h **** static inline void GPIO_PortSet(GPIO_Type *base, uint32_t mask)
 189:../drivers/fsl_gpio.h **** {
 190:../drivers/fsl_gpio.h ****     base->PSOR = mask;
 191:../drivers/fsl_gpio.h **** }
 192:../drivers/fsl_gpio.h **** 
 193:../drivers/fsl_gpio.h **** /*!
 194:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1.
 195:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PortSet.
 196:../drivers/fsl_gpio.h ****  */
 197:../drivers/fsl_gpio.h **** static inline void GPIO_SetPinsOutput(GPIO_Type *base, uint32_t mask)
 198:../drivers/fsl_gpio.h **** {
 199:../drivers/fsl_gpio.h ****     GPIO_PortSet(base, mask);
 200:../drivers/fsl_gpio.h **** }
 201:../drivers/fsl_gpio.h **** 
 202:../drivers/fsl_gpio.h **** /*!
 203:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 0.
 204:../drivers/fsl_gpio.h ****  *
 205:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 206:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 207:../drivers/fsl_gpio.h ****  */
 208:../drivers/fsl_gpio.h **** static inline void GPIO_PortClear(GPIO_Type *base, uint32_t mask)
 209:../drivers/fsl_gpio.h **** {
 210:../drivers/fsl_gpio.h ****     base->PCOR = mask;
 768              		.loc 6 210 0
 769 00cc 1023     		movs	r3, #16
 770              	.LBE180:
 771              	.LBE179:
 772              	.LBE178:
 240:../source/main.c **** 
 241:../source/main.c **** 	GPIO_ClearPinsOutput(GPIOA, 1 << 4u);
 242:../source/main.c **** 
 243:../source/main.c **** 	/*
 244:../source/main.c **** 	 * set boost regulator enable pin as output. This pin will control the power to RF modules
 245:../source/main.c **** 	 */
 246:../source/main.c **** 	GPIO_PinInit(GPIOA, 1u, &LED_configOutput);
 773              		.loc 1 246 0
 774 00ce 2900     		movs	r1, r5
 775 00d0 3A00     		movs	r2, r7
 776              	.LBB183:
 777              	.LBB182:
 778              	.LBB181:
 779              		.loc 6 210 0
 780 00d2 A360     		str	r3, [r4, #8]
 781              	.LVL74:
 782              	.LBE181:
 783              	.LBE182:
 784              	.LBE183:
 785              		.loc 1 246 0
 786 00d4 2000     		movs	r0, r4
 787 00d6 FFF7FEFF 		bl	GPIO_PinInit
 788              	.LVL75:
 789              	.LBB184:
 790              	.LBB185:
 791              	.LBB186:
 792              		.loc 6 210 0
 793 00da 0223     		movs	r3, #2
 794              	.LBE186:
 795              	.LBE185:
 796              	.LBE184:
 247:../source/main.c **** 
 248:../source/main.c **** 	GPIO_ClearPinsOutput(GPIOA, 1 << 1u); //Power on RF modules
 249:../source/main.c **** 
 250:../source/main.c **** 	PCprint(
 797              		.loc 1 250 0
 798 00dc A748     		ldr	r0, .L74+56
 799              	.LBB189:
 800              	.LBB188:
 801              	.LBB187:
 802              		.loc 6 210 0
 803 00de A360     		str	r3, [r4, #8]
 804              	.LVL76:
 805              	.LBE187:
 806              	.LBE188:
 807              	.LBE189:
 808              		.loc 1 250 0
 809 00e0 FFF7FEFF 		bl	PCprint
 810              	.LVL77:
 251:../source/main.c **** 			"Reindeer IoT has started\r\nCommand \"iot\" to start executing reindeer track cycle\r\n"
 252:../source/main.c **** 					"Command \"gpsinfo=1\" or \"gpsinfo=0\" to switch GPS data on/off\r\n");
 253:../source/main.c **** 	PCprint(
 811              		.loc 1 253 0
 812 00e4 A648     		ldr	r0, .L74+60
 813 00e6 FFF7FEFF 		bl	PCprint
 814              	.LVL78:
 254:../source/main.c **** 			"Or enter normal AT commands here for SARA-N2\r\nModules powered on and booting now!\r\n");
 255:../source/main.c **** 
 256:../source/main.c **** 
 257:../source/main.c **** 
 258:../source/main.c **** 	//GPIO_ClearPinsOutput(GPIOA, 1 << 19u);
 259:../source/main.c **** 	/*
 260:../source/main.c **** 	 while (true) {
 261:../source/main.c **** 
 262:../source/main.c **** 	 char acc_buf[150];
 263:../source/main.c **** 
 264:../source/main.c **** 	 int16_t acc_val_x = read_acc_axis(0);
 265:../source/main.c **** 	 int16_t acc_val_y = read_acc_axis(1);
 266:../source/main.c **** 	 int16_t acc_val_z = read_acc_axis(2);
 267:../source/main.c **** 	 sprintf(acc_buf, "Akselomeetteri X: %d Y: %d Z: %d\r\n", acc_val_x, acc_val_y, acc_val_z);
 268:../source/main.c **** 	 PCprint(acc_buf);
 269:../source/main.c **** 	 delay_ms(500);
 270:../source/main.c **** 	 }
 271:../source/main.c **** 	 */
 272:../source/main.c **** 	/*
 273:../source/main.c **** 	 * Copy all reindeer variables to struct before starting network operations
 274:../source/main.c **** 	 */
 275:../source/main.c **** 	char testLat[11] = ("6500.53");
 815              		.loc 1 275 0
 816 00ea 0822     		movs	r2, #8
 817 00ec A549     		ldr	r1, .L74+64
 818 00ee 6846     		mov	r0, sp
 819 00f0 FFF7FEFF 		bl	memcpy
 820              	.LVL79:
 821 00f4 0322     		movs	r2, #3
 822 00f6 0021     		movs	r1, #0
 823 00f8 02A8     		add	r0, sp, #8
 824 00fa FFF7FEFF 		bl	memset
 825              	.LVL80:
 276:../source/main.c **** 	char testLon[11] = ("02534.554");
 826              		.loc 1 276 0
 827 00fe A149     		ldr	r1, .L74+64
 828 0100 0A22     		movs	r2, #10
 829 0102 0B31     		adds	r1, r1, #11
 830 0104 03A8     		add	r0, sp, #12
 831 0106 FFF7FEFF 		bl	memcpy
 832              	.LVL81:
 833 010a 1623     		movs	r3, #22
 834 010c 0022     		movs	r2, #0
 835 010e 6B44     		add	r3, r3, sp
 277:../source/main.c **** 	strcpy(reindeerData.serialNum, "11111");
 836              		.loc 1 277 0
 837 0110 9D49     		ldr	r1, .L74+68
 838 0112 11A8     		add	r0, sp, #68
 276:../source/main.c **** 	char testLon[11] = ("02534.554");
 839              		.loc 1 276 0
 840 0114 1A70     		strb	r2, [r3]
 841              		.loc 1 277 0
 842 0116 FFF7FEFF 		bl	strcpy
 843              	.LVL82:
 278:../source/main.c **** 	strcpy(reindeerData.latitude, testLat);
 844              		.loc 1 278 0
 845 011a 4A23     		movs	r3, #74
 846 011c 6B44     		add	r3, r3, sp
 847 011e 6946     		mov	r1, sp
 848 0120 1800     		movs	r0, r3
 849 0122 FFF7FEFF 		bl	strcpy
 850              	.LVL83:
 279:../source/main.c **** 	strcpy(reindeerData.longitude, testLon);
 851              		.loc 1 279 0
 852 0126 5623     		movs	r3, #86
 853 0128 6B44     		add	r3, r3, sp
 854 012a 03A9     		add	r1, sp, #12
 855 012c 1800     		movs	r0, r3
 856 012e FFF7FEFF 		bl	strcpy
 857              	.LVL84:
 280:../source/main.c **** 	strcpy(reindeerData.dead, "false");
 858              		.loc 1 280 0
 859 0132 6223     		movs	r3, #98
 860 0134 6B44     		add	r3, r3, sp
 861 0136 1800     		movs	r0, r3
 862 0138 9449     		ldr	r1, .L74+72
 863 013a FFF7FEFF 		bl	strcpy
 864              	.LVL85:
 281:../source/main.c **** 	reindeerData.batteryLevel = 45;
 865              		.loc 1 281 0
 866 013e 4923     		movs	r3, #73
 867 0140 2D22     		movs	r2, #45
 282:../source/main.c **** 
 283:../source/main.c **** 	if (wake == 2)
 868              		.loc 1 283 0
 869 0142 934D     		ldr	r5, .L74+76
 281:../source/main.c **** 	reindeerData.batteryLevel = 45;
 870              		.loc 1 281 0
 871 0144 6B44     		add	r3, r3, sp
 872 0146 DA77     		strb	r2, [r3, #31]
 873              		.loc 1 283 0
 874 0148 2B78     		ldrb	r3, [r5]
 284:../source/main.c **** 	{
 285:../source/main.c **** 
 286:../source/main.c **** 		PCprint("Woken by ACCEL, reindeer is !!!ALIVE!!!\r\n");
 875              		.loc 1 286 0
 876 014a 9248     		ldr	r0, .L74+80
 283:../source/main.c **** 	{
 877              		.loc 1 283 0
 878 014c 022B     		cmp	r3, #2
 879 014e 03D0     		beq	.L72
 287:../source/main.c **** 		SMC_PreEnterStopModes();
 288:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 289:../source/main.c **** 	}
 290:../source/main.c **** 	else if (wake == 0)
 880              		.loc 1 290 0
 881 0150 2B78     		ldrb	r3, [r5]
 882 0152 002B     		cmp	r3, #0
 883 0154 08D1     		bne	.L33
 291:../source/main.c **** 	{
 292:../source/main.c **** 		PCprint("wake was 0 going to sleep\r\n");
 884              		.loc 1 292 0
 885 0156 9048     		ldr	r0, .L74+84
 886              	.L72:
 887 0158 FFF7FEFF 		bl	PCprint
 888              	.LVL86:
 293:../source/main.c **** 		SMC_PreEnterStopModes();
 889              		.loc 1 293 0
 890 015c FFF7FEFF 		bl	SMC_PreEnterStopModes
 891              	.LVL87:
 294:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 892              		.loc 1 294 0
 893 0160 8449     		ldr	r1, .L74+48
 894 0162 8348     		ldr	r0, .L74+44
 895 0164 FFF7FEFF 		bl	SMC_SetPowerModeVlls
 896              	.LVL88:
 897              	.L33:
 295:../source/main.c **** 	}
 296:../source/main.c **** 
 297:../source/main.c **** 	while (1)
 298:../source/main.c **** 	{
 299:../source/main.c **** 
 300:../source/main.c **** 		//int16_t acc_val = read_acc_axis(0);
 301:../source/main.c **** 		//PCprint("Accelereometer %d\r\n",acc_val);
 302:../source/main.c **** 		//break;
 303:../source/main.c **** 		/*
 304:../source/main.c **** 		 * Check if a string has arrived from PC (with CR line end)
 305:../source/main.c **** 		 */
 306:../source/main.c **** 
 307:../source/main.c **** 		if (wake == 1)
 898              		.loc 1 307 0
 899 0168 2B78     		ldrb	r3, [r5]
 900 016a 012B     		cmp	r3, #1
 901 016c 2BD1     		bne	.L35
 308:../source/main.c **** 		{
 309:../source/main.c **** 
 310:../source/main.c **** 			strcpy(reindeerData.dead, "true");
 902              		.loc 1 310 0
 903 016e 6133     		adds	r3, r3, #97
 904 0170 6B44     		add	r3, r3, sp
 905 0172 1800     		movs	r0, r3
 906 0174 8949     		ldr	r1, .L74+88
 907 0176 FFF7FEFF 		bl	strcpy
 908              	.LVL89:
 311:../source/main.c **** 			//PCprint("Woken by LPTMR, reindeer is !!!%s!!\r\n",
 312:../source/main.c **** 			//		reindeerData.dead);
 313:../source/main.c **** 
 314:../source/main.c **** 			while (true)
 315:../source/main.c **** 			{
 316:../source/main.c **** 				if (!GPS_strReady)
 909              		.loc 1 316 0
 910 017a 894B     		ldr	r3, .L74+92
 911              	.L36:
 912 017c 1C78     		ldrb	r4, [r3]
 913 017e E4B2     		uxtb	r4, r4
 914 0180 002C     		cmp	r4, #0
 915 0182 FBD1     		bne	.L36
 916              	.LBB190:
 317:../source/main.c **** 				{
 318:../source/main.c **** 					PCprint(GPS_recBuf);
 917              		.loc 1 318 0
 918 0184 8748     		ldr	r0, .L74+96
 919 0186 FFF7FEFF 		bl	PCprint
 920              	.LVL90:
 319:../source/main.c **** 					PCprint("\r\n"); //First print out whole buffer
 921              		.loc 1 319 0
 922 018a 8748     		ldr	r0, .L74+100
 923 018c FFF7FEFF 		bl	PCprint
 924              	.LVL91:
 320:../source/main.c **** 
 321:../source/main.c **** 					char testLat[12] = ("6500.02359");
 925              		.loc 1 321 0
 926 0190 7C49     		ldr	r1, .L74+64
 927 0192 0B22     		movs	r2, #11
 928 0194 1631     		adds	r1, r1, #22
 929 0196 06A8     		add	r0, sp, #24
 930 0198 FFF7FEFF 		bl	memcpy
 931              	.LVL92:
 932 019c 2323     		movs	r3, #35
 322:../source/main.c **** 					char testLon[12] = ("02530.56951");
 933              		.loc 1 322 0
 934 019e 0C22     		movs	r2, #12
 321:../source/main.c **** 					char testLon[12] = ("02530.56951");
 935              		.loc 1 321 0
 936 01a0 6B44     		add	r3, r3, sp
 937              		.loc 1 322 0
 938 01a2 8249     		ldr	r1, .L74+104
 939 01a4 1BA8     		add	r0, sp, #108
 321:../source/main.c **** 					char testLon[12] = ("02530.56951");
 940              		.loc 1 321 0
 941 01a6 1C70     		strb	r4, [r3]
 942              		.loc 1 322 0
 943 01a8 FFF7FEFF 		bl	memcpy
 944              	.LVL93:
 323:../source/main.c **** 
 324:../source/main.c **** 					strcpy(reindeerData.latitude, testLat);
 945              		.loc 1 324 0
 946 01ac 4A23     		movs	r3, #74
 947 01ae 6B44     		add	r3, r3, sp
 948 01b0 06A9     		add	r1, sp, #24
 949 01b2 1800     		movs	r0, r3
 950 01b4 FFF7FEFF 		bl	strcpy
 951              	.LVL94:
 325:../source/main.c **** 					strcpy(reindeerData.longitude, testLon);
 952              		.loc 1 325 0
 953 01b8 1BA9     		add	r1, sp, #108
 954              	.L73:
 955              	.LBE190:
 956              	.LBB191:
 326:../source/main.c **** 					break;
 327:../source/main.c **** 
 328:../source/main.c **** 					if (getGPS())
 329:../source/main.c **** 					{
 330:../source/main.c **** 						//char testLat[12] = ("6500.02359");
 331:../source/main.c **** 						//char testLon[12] = ("02530.56951");
 332:../source/main.c **** 
 333:../source/main.c **** 						//parseData(testLat,testLon);
 334:../source/main.c **** 
 335:../source/main.c **** 						strcpy(reindeerData.latitude, parsedLat);
 336:../source/main.c **** 						strcpy(reindeerData.longitude, parsedLon);
 337:../source/main.c **** 						break;
 338:../source/main.c **** 					}
 339:../source/main.c **** 					memset(GPS_recBuf, 0, 600);
 340:../source/main.c **** 					GPS_bufPtr = 0;
 341:../source/main.c **** 					GPS_strReady = 0;
 342:../source/main.c **** 				}
 343:../source/main.c **** 
 344:../source/main.c **** 			}
 345:../source/main.c **** 			//PCprint("Parsed latitude: %s\r\n", reindeerData.latitude);
 346:../source/main.c **** 			//PCprint("Parsed longitude: %s\r\n", reindeerData.longitude);
 347:../source/main.c **** 			break;
 348:../source/main.c **** 		}
 349:../source/main.c **** 
 350:../source/main.c **** 		if (PC_strReady)
 351:../source/main.c **** 		{
 352:../source/main.c **** 
 353:../source/main.c **** 			if (strstr(PC_recBuf, "iot") != NULL)
 354:../source/main.c **** 			{
 355:../source/main.c **** 				PCprint("Starting Reindeer IoT cycle\r\n");
 356:../source/main.c **** 				break;
 357:../source/main.c **** 			}
 358:../source/main.c **** 			else if (strstr(PC_recBuf, "gpsinfo=1") != NULL)
 359:../source/main.c **** 			{
 360:../source/main.c **** 				streamGps = 1;
 361:../source/main.c **** 			}
 362:../source/main.c **** 			else if (strstr(PC_recBuf, "gpsinfo=0") != NULL)
 363:../source/main.c **** 			{
 364:../source/main.c **** 				streamGps = 0;
 365:../source/main.c **** 			}
 366:../source/main.c **** 			else if (strstr(PC_recBuf, "rfoff") != NULL)
 367:../source/main.c **** 			{
 368:../source/main.c **** 				GPIO_ClearPinsOutput(GPIOA, 1 << 1u); //Power off RF modules
 369:../source/main.c **** 			}
 370:../source/main.c **** 			else if (strstr(PC_recBuf, "rfon") != NULL)
 371:../source/main.c **** 			{
 372:../source/main.c **** 				GPIO_SetPinsOutput(GPIOA, 1 << 1u); //Power on RF modules
 373:../source/main.c **** 			}
 374:../source/main.c **** 			else if (strstr(PC_recBuf, "\xb5\x62") != NULL) //if input is UBX command!
 375:../source/main.c **** 			{
 376:../source/main.c **** 				PCprint("send to gps\r\n");
 377:../source/main.c **** 				uint8_t ubxMsgLen = calcUbxCrc(PC_recBuf + 2); //Calculate UBX checksum and add it to the messa
 378:../source/main.c **** 				GPS_send(PC_recBuf, ubxMsgLen); //Send UBX message to module
 379:../source/main.c **** 			}
 380:../source/main.c **** 			else
 381:../source/main.c **** 			{
 382:../source/main.c **** 
 383:../source/main.c **** 				NB_send(PC_recBuf);
 384:../source/main.c **** 
 385:../source/main.c **** 			}
 386:../source/main.c **** 			memset(PC_recBuf, 0, strlen(PC_recBuf));
 387:../source/main.c **** 			PC_strReady = 0;
 388:../source/main.c **** 			PC_bufPtr = 0;
 389:../source/main.c **** 		}
 390:../source/main.c **** 
 391:../source/main.c **** 		if (NB_strReady)
 392:../source/main.c **** 		{
 393:../source/main.c **** 			moduleResponseTimeout = millis() + RESPONSE_TIMEOUT_NORMAL_VALUE; //reset timeout to initial val
 394:../source/main.c **** 
 395:../source/main.c **** 			while (millis() < moduleResponseTimeout)
 396:../source/main.c **** 
 397:../source/main.c **** 			{
 398:../source/main.c **** 
 399:../source/main.c **** 				if (breakIfAtOk())
 400:../source/main.c **** 				{
 401:../source/main.c **** 					break;
 402:../source/main.c **** 				}
 403:../source/main.c **** 
 404:../source/main.c **** 			}
 405:../source/main.c **** 
 406:../source/main.c **** 			//now the timeout has expired since last character had arrived, so we can process data
 407:../source/main.c **** 
 408:../source/main.c **** 			PCprint(NB_recBuf);
 409:../source/main.c **** 			PCprint("\r\n");
 410:../source/main.c **** 			memset(NB_recBuf, 0, 500);
 411:../source/main.c **** 			NB_bufPtr = 0;
 412:../source/main.c **** 			NB_strReady = 0;
 413:../source/main.c **** 		}
 414:../source/main.c **** 
 415:../source/main.c **** 		/*
 416:../source/main.c **** 		 * If GPS string is ready and GPS data streaming is enabled, enter here to process GPS data buffe
 417:../source/main.c **** 		 */
 418:../source/main.c **** 		if (GPS_strReady && streamGps)
 419:../source/main.c **** 		{
 420:../source/main.c **** 
 421:../source/main.c **** 			//PCprint(GPS_recBuf);
 422:../source/main.c **** 			//PCprint("\r\n"); //First print out whole buffer
 423:../source/main.c **** 
 424:../source/main.c **** 			if (getGPS())
 425:../source/main.c **** 			{
 426:../source/main.c **** 				//char testLat[12] = ("6500.02359");
 427:../source/main.c **** 				//char testLon[12] = ("02530.56951");
 428:../source/main.c **** 
 429:../source/main.c **** 				//parseData(testLat,testLon);
 430:../source/main.c **** 
 431:../source/main.c **** 				strcpy(reindeerData.latitude, parsedLat);
 432:../source/main.c **** 				strcpy(reindeerData.longitude, parsedLon);
 957              		.loc 1 432 0
 958 01ba 5623     		movs	r3, #86
 959 01bc 6B44     		add	r3, r3, sp
 960 01be 1800     		movs	r0, r3
 961 01c0 FFF7FEFF 		bl	strcpy
 962              	.LVL95:
 433:../source/main.c **** 				break;
 963              		.loc 1 433 0
 964 01c4 0DE0     		b	.L37
 965              	.L35:
 966              	.LBE191:
 350:../source/main.c **** 		{
 967              		.loc 1 350 0
 968 01c6 7A4B     		ldr	r3, .L74+108
 969 01c8 1B78     		ldrb	r3, [r3]
 970 01ca 002B     		cmp	r3, #0
 971 01cc 31D0     		beq	.L38
 353:../source/main.c **** 			{
 972              		.loc 1 353 0
 973 01ce 794E     		ldr	r6, .L74+112
 974 01d0 7949     		ldr	r1, .L74+116
 975 01d2 3000     		movs	r0, r6
 976 01d4 FFF7FEFF 		bl	strstr
 977              	.LVL96:
 978 01d8 0028     		cmp	r0, #0
 979 01da 13D0     		beq	.L39
 355:../source/main.c **** 				break;
 980              		.loc 1 355 0
 981 01dc 7748     		ldr	r0, .L74+120
 982 01de FFF7FEFF 		bl	PCprint
 983              	.LVL97:
 984              	.L37:
 434:../source/main.c **** 			}
 435:../source/main.c **** 
 436:../source/main.c **** 			//PCprint("Parsed latitude: %s\r\n", reindeerData.latitude);
 437:../source/main.c **** 			//PCprint("Parsed longitude: %s\r\n", reindeerData.longitude);
 438:../source/main.c **** 
 439:../source/main.c **** 			char* ubxResponseStartPtr = strstr(GPS_recBuf, "\xb5\x62"); //Find pointer to UBX header. If the
 440:../source/main.c **** 																		//will be NULL
 441:../source/main.c **** 
 442:../source/main.c **** 			if (ubxResponseStartPtr != NULL) //If pointer is not null, it means UBX response header is found
 443:../source/main.c **** 			{
 444:../source/main.c **** 				PCprint("Found UBX response\r\n");
 445:../source/main.c **** 
 446:../source/main.c **** 				uint8_t responseLength = *(ubxResponseStartPtr + 4); //Find out UBX response length, it is alwa
 447:../source/main.c **** 																	 //from beginning of the packet. * means dereferencing pointer
 448:../source/main.c **** 				//dereferencing means "accessing the value where pointer points"
 449:../source/main.c **** 
 450:../source/main.c **** 				//PCprint("UBX response length: %02x\r\n", responseLength);
 451:../source/main.c **** 
 452:../source/main.c **** 				printUbxResponseHex(ubxResponseStartPtr,
 453:../source/main.c **** 						responseLength + 6 + 2); //Print UBX response message. Function wants to know
 454:../source/main.c **** 				//how many chars to print. We must add 6+2 to print header and crc too
 455:../source/main.c **** 			}
 456:../source/main.c **** 
 457:../source/main.c **** 			memset(GPS_recBuf, 0, 600);
 458:../source/main.c **** 			GPS_bufPtr = 0;
 459:../source/main.c **** 			GPS_strReady = 0;
 460:../source/main.c **** 		}
 461:../source/main.c **** 
 462:../source/main.c **** 	}
 463:../source/main.c **** 
 464:../source/main.c **** 	/*
 465:../source/main.c **** 	 * Assemble data to json format and then to POST message
 466:../source/main.c **** 	 */
 467:../source/main.c **** 
 468:../source/main.c **** 	uint8_t msgLen = assembleMqtt(&reindeerData, mqttMessage);
 985              		.loc 1 468 0
 986 01e2 1BA9     		add	r1, sp, #108
 987 01e4 11A8     		add	r0, sp, #68
 988 01e6 FFF7FEFF 		bl	assembleMqtt
 989              	.LVL98:
 990 01ea 0100     		movs	r1, r0
 991              	.LVL99:
 469:../source/main.c **** 
 470:../source/main.c **** 	//NB_send_msg(mqttMessage, msgLen);
 471:../source/main.c **** 
 472:../source/main.c **** 	NB_create_pdp_send(mqttMessage, msgLen);
 992              		.loc 1 472 0
 993 01ec 1BA8     		add	r0, sp, #108
 994 01ee FFF7FEFF 		bl	NB_create_pdp_send
 995              	.LVL100:
 473:../source/main.c **** 	PCprint("Roger include main.c\r\n");
 996              		.loc 1 473 0
 997 01f2 7348     		ldr	r0, .L74+124
 998 01f4 FFF7FEFF 		bl	PCprint
 999              	.LVL101:
 474:../source/main.c **** 
 475:../source/main.c **** 	AT_send("CFUN=0", "", "OK");
 1000              		.loc 1 475 0
 1001 01f8 724A     		ldr	r2, .L74+128
 1002 01fa 7349     		ldr	r1, .L74+132
 1003 01fc 7348     		ldr	r0, .L74+136
 1004 01fe FFF7FEFF 		bl	AT_send
 1005              	.LVL102:
 1006              	.L53:
 1007 0202 FEE7     		b	.L53
 1008              	.L39:
 358:../source/main.c **** 			{
 1009              		.loc 1 358 0
 1010 0204 7249     		ldr	r1, .L74+140
 1011 0206 3000     		movs	r0, r6
 1012 0208 FFF7FEFF 		bl	strstr
 1013              	.LVL103:
 1014 020c 071E     		subs	r7, r0, #0
 1015 020e 4CD0     		beq	.L40
 360:../source/main.c **** 			}
 1016              		.loc 1 360 0
 1017 0210 0122     		movs	r2, #1
 1018 0212 704B     		ldr	r3, .L74+144
 1019 0214 1A70     		strb	r2, [r3]
 1020              	.L41:
 386:../source/main.c **** 			PC_strReady = 0;
 1021              		.loc 1 386 0
 1022 0216 674E     		ldr	r6, .L74+112
 1023 0218 3000     		movs	r0, r6
 1024 021a FFF7FEFF 		bl	strlen
 1025              	.LVL104:
 1026 021e 0021     		movs	r1, #0
 1027 0220 0200     		movs	r2, r0
 1028 0222 3000     		movs	r0, r6
 1029 0224 FFF7FEFF 		bl	memset
 1030              	.LVL105:
 387:../source/main.c **** 			PC_bufPtr = 0;
 1031              		.loc 1 387 0
 1032 0228 0023     		movs	r3, #0
 1033 022a 614A     		ldr	r2, .L74+108
 1034 022c 1370     		strb	r3, [r2]
 388:../source/main.c **** 		}
 1035              		.loc 1 388 0
 1036 022e 6A4A     		ldr	r2, .L74+148
 1037 0230 1380     		strh	r3, [r2]
 1038              	.L38:
 391:../source/main.c **** 		{
 1039              		.loc 1 391 0
 1040 0232 6A4B     		ldr	r3, .L74+152
 1041 0234 1B78     		ldrb	r3, [r3]
 1042 0236 002B     		cmp	r3, #0
 1043 0238 21D0     		beq	.L46
 393:../source/main.c **** 
 1044              		.loc 1 393 0
 1045 023a FFF7FEFF 		bl	millis
 1046              	.LVL106:
 1047 023e FA23     		movs	r3, #250
 1048 0240 674E     		ldr	r6, .L74+156
 1049 0242 DB00     		lsls	r3, r3, #3
 1050 0244 C018     		adds	r0, r0, r3
 1051 0246 3060     		str	r0, [r6]
 1052              	.L47:
 395:../source/main.c **** 
 1053              		.loc 1 395 0
 1054 0248 FFF7FEFF 		bl	millis
 1055              	.LVL107:
 1056 024c 3368     		ldr	r3, [r6]
 1057 024e 9842     		cmp	r0, r3
 1058 0250 03D2     		bcs	.L49
 399:../source/main.c **** 				{
 1059              		.loc 1 399 0
 1060 0252 FFF7FEFF 		bl	breakIfAtOk
 1061              	.LVL108:
 1062 0256 0028     		cmp	r0, #0
 1063 0258 F6D0     		beq	.L47
 1064              	.L49:
 408:../source/main.c **** 			PCprint("\r\n");
 1065              		.loc 1 408 0
 1066 025a 624E     		ldr	r6, .L74+160
 1067 025c 3000     		movs	r0, r6
 1068 025e FFF7FEFF 		bl	PCprint
 1069              	.LVL109:
 409:../source/main.c **** 			memset(NB_recBuf, 0, 500);
 1070              		.loc 1 409 0
 1071 0262 5148     		ldr	r0, .L74+100
 1072 0264 FFF7FEFF 		bl	PCprint
 1073              	.LVL110:
 410:../source/main.c **** 			NB_bufPtr = 0;
 1074              		.loc 1 410 0
 1075 0268 FA22     		movs	r2, #250
 1076 026a 0021     		movs	r1, #0
 1077 026c 5200     		lsls	r2, r2, #1
 1078 026e 3000     		movs	r0, r6
 1079 0270 FFF7FEFF 		bl	memset
 1080              	.LVL111:
 411:../source/main.c **** 			NB_strReady = 0;
 1081              		.loc 1 411 0
 1082 0274 0023     		movs	r3, #0
 1083 0276 5C4A     		ldr	r2, .L74+164
 1084 0278 1380     		strh	r3, [r2]
 412:../source/main.c **** 		}
 1085              		.loc 1 412 0
 1086 027a 584A     		ldr	r2, .L74+152
 1087 027c 1370     		strb	r3, [r2]
 1088              	.L46:
 418:../source/main.c **** 		{
 1089              		.loc 1 418 0
 1090 027e 484B     		ldr	r3, .L74+92
 1091 0280 1B78     		ldrb	r3, [r3]
 1092 0282 002B     		cmp	r3, #0
 1093 0284 00D1     		bne	.LCB975
 1094 0286 6FE7     		b	.L33	@long jump
 1095              	.LCB975:
 418:../source/main.c **** 		{
 1096              		.loc 1 418 0 is_stmt 0 discriminator 1
 1097 0288 524B     		ldr	r3, .L74+144
 1098 028a 1B78     		ldrb	r3, [r3]
 1099 028c 002B     		cmp	r3, #0
 1100 028e 00D1     		bne	.LCB979
 1101 0290 6AE7     		b	.L33	@long jump
 1102              	.LCB979:
 1103              	.LBB193:
 424:../source/main.c **** 			{
 1104              		.loc 1 424 0 is_stmt 1
 1105 0292 FFF7FEFF 		bl	getGPS
 1106              	.LVL112:
 1107 0296 0028     		cmp	r0, #0
 1108 0298 37D0     		beq	.L51
 431:../source/main.c **** 				strcpy(reindeerData.longitude, parsedLon);
 1109              		.loc 1 431 0
 1110 029a 4A23     		movs	r3, #74
 1111 029c 6B44     		add	r3, r3, sp
 1112 029e 5349     		ldr	r1, .L74+168
 1113 02a0 1800     		movs	r0, r3
 1114 02a2 FFF7FEFF 		bl	strcpy
 1115              	.LVL113:
 432:../source/main.c **** 				break;
 1116              		.loc 1 432 0
 1117 02a6 5249     		ldr	r1, .L74+172
 1118 02a8 87E7     		b	.L73
 1119              	.L40:
 1120              	.LBE193:
 362:../source/main.c **** 			{
 1121              		.loc 1 362 0
 1122 02aa 5249     		ldr	r1, .L74+176
 1123 02ac 3000     		movs	r0, r6
 1124 02ae FFF7FEFF 		bl	strstr
 1125              	.LVL114:
 1126 02b2 0028     		cmp	r0, #0
 1127 02b4 02D0     		beq	.L42
 364:../source/main.c **** 			}
 1128              		.loc 1 364 0
 1129 02b6 474B     		ldr	r3, .L74+144
 1130 02b8 1F70     		strb	r7, [r3]
 1131 02ba ACE7     		b	.L41
 1132              	.L42:
 366:../source/main.c **** 			{
 1133              		.loc 1 366 0
 1134 02bc 4E49     		ldr	r1, .L74+180
 1135 02be 3000     		movs	r0, r6
 1136 02c0 FFF7FEFF 		bl	strstr
 1137              	.LVL115:
 1138 02c4 0028     		cmp	r0, #0
 1139 02c6 02D0     		beq	.L43
 1140              	.LVL116:
 1141              	.LBB194:
 1142              	.LBB195:
 1143              	.LBB196:
 1144              		.loc 6 210 0
 1145 02c8 0223     		movs	r3, #2
 1146 02ca A360     		str	r3, [r4, #8]
 1147              	.LVL117:
 1148 02cc A3E7     		b	.L41
 1149              	.LVL118:
 1150              	.L43:
 1151              	.LBE196:
 1152              	.LBE195:
 1153              	.LBE194:
 370:../source/main.c **** 			{
 1154              		.loc 1 370 0
 1155 02ce 4B49     		ldr	r1, .L74+184
 1156 02d0 3000     		movs	r0, r6
 1157 02d2 FFF7FEFF 		bl	strstr
 1158              	.LVL119:
 1159 02d6 0028     		cmp	r0, #0
 1160 02d8 02D0     		beq	.L44
 1161              	.LVL120:
 1162              	.LBB197:
 1163              	.LBB198:
 1164              	.LBB199:
 190:../drivers/fsl_gpio.h **** }
 1165              		.loc 6 190 0
 1166 02da 0223     		movs	r3, #2
 1167 02dc 6360     		str	r3, [r4, #4]
 1168              	.LVL121:
 1169 02de 9AE7     		b	.L41
 1170              	.LVL122:
 1171              	.L44:
 1172              	.LBE199:
 1173              	.LBE198:
 1174              	.LBE197:
 374:../source/main.c **** 			{
 1175              		.loc 1 374 0
 1176 02e0 4749     		ldr	r1, .L74+188
 1177 02e2 3000     		movs	r0, r6
 1178 02e4 FFF7FEFF 		bl	strstr
 1179              	.LVL123:
 1180 02e8 0028     		cmp	r0, #0
 1181 02ea 0AD0     		beq	.L45
 1182              	.LBB200:
 376:../source/main.c **** 				uint8_t ubxMsgLen = calcUbxCrc(PC_recBuf + 2); //Calculate UBX checksum and add it to the messa
 1183              		.loc 1 376 0
 1184 02ec 4548     		ldr	r0, .L74+192
 1185 02ee FFF7FEFF 		bl	PCprint
 1186              	.LVL124:
 377:../source/main.c **** 				GPS_send(PC_recBuf, ubxMsgLen); //Send UBX message to module
 1187              		.loc 1 377 0
 1188 02f2 4548     		ldr	r0, .L74+196
 1189 02f4 FFF7FEFF 		bl	calcUbxCrc
 1190              	.LVL125:
 1191 02f8 0100     		movs	r1, r0
 1192              	.LVL126:
 378:../source/main.c **** 			}
 1193              		.loc 1 378 0
 1194 02fa 3000     		movs	r0, r6
 1195 02fc FFF7FEFF 		bl	GPS_send
 1196              	.LVL127:
 1197              	.LBE200:
 1198 0300 89E7     		b	.L41
 1199              	.L45:
 383:../source/main.c **** 
 1200              		.loc 1 383 0
 1201 0302 3000     		movs	r0, r6
 1202 0304 FFF7FEFF 		bl	NB_send
 1203              	.LVL128:
 1204 0308 85E7     		b	.L41
 1205              	.L51:
 1206              	.LBB201:
 439:../source/main.c **** 																		//will be NULL
 1207              		.loc 1 439 0
 1208 030a 264F     		ldr	r7, .L74+96
 1209 030c 3C49     		ldr	r1, .L74+188
 1210 030e 3800     		movs	r0, r7
 1211 0310 FFF7FEFF 		bl	strstr
 1212              	.LVL129:
 1213 0314 061E     		subs	r6, r0, #0
 1214              	.LVL130:
 442:../source/main.c **** 			{
 1215              		.loc 1 442 0
 1216 0316 08D0     		beq	.L52
 1217              	.LBB192:
 444:../source/main.c **** 
 1218              		.loc 1 444 0
 1219 0318 3C48     		ldr	r0, .L74+200
 1220              	.LVL131:
 1221 031a FFF7FEFF 		bl	PCprint
 1222              	.LVL132:
 452:../source/main.c **** 						responseLength + 6 + 2); //Print UBX response message. Function wants to know
 1223              		.loc 1 452 0
 1224 031e 3179     		ldrb	r1, [r6, #4]
 1225 0320 3000     		movs	r0, r6
 1226 0322 0831     		adds	r1, r1, #8
 1227 0324 C9B2     		uxtb	r1, r1
 1228 0326 FFF7FEFF 		bl	printUbxResponseHex
 1229              	.LVL133:
 1230              	.L52:
 1231              	.LBE192:
 457:../source/main.c **** 			GPS_bufPtr = 0;
 1232              		.loc 1 457 0
 1233 032a 9622     		movs	r2, #150
 1234 032c 0021     		movs	r1, #0
 1235 032e 9200     		lsls	r2, r2, #2
 1236 0330 3800     		movs	r0, r7
 1237 0332 FFF7FEFF 		bl	memset
 1238              	.LVL134:
 458:../source/main.c **** 			GPS_strReady = 0;
 1239              		.loc 1 458 0
 1240 0336 0023     		movs	r3, #0
 1241 0338 354A     		ldr	r2, .L74+204
 1242 033a 1380     		strh	r3, [r2]
 459:../source/main.c **** 		}
 1243              		.loc 1 459 0
 1244 033c 184A     		ldr	r2, .L74+92
 1245 033e 1370     		strb	r3, [r2]
 1246 0340 12E7     		b	.L33
 1247              	.L75:
 1248 0342 C046     		.align	2
 1249              	.L74:
 1250 0344 00D00740 		.word	1074253824
 1251 0348 CCFDFFFF 		.word	-564
 1252 034c 00E100E0 		.word	-536813312
 1253 0350 FFFFFF00 		.word	16777215
 1254 0354 10E000E0 		.word	-536813552
 1255 0358 00ED00E0 		.word	-536810240
 1256 035c 00F00F40 		.word	1074786304
 1257 0360 00000000 		.word	.LANCHOR0
 1258 0364 38800440 		.word	1074036792
 1259 0368 00000440 		.word	1074003968
 1260 036c 00000000 		.word	.LC5
 1261 0370 00E00740 		.word	1074257920
 1262 0374 00000000 		.word	smc_power_mode_vlls_config
 1263 0378 00C00740 		.word	1074249728
 1264 037c 18000000 		.word	.LC8
 1265 0380 A8000000 		.word	.LC10
 1266 0384 00000000 		.word	.LANCHOR1
 1267 0388 FC000000 		.word	.LC15
 1268 038c 02010000 		.word	.LC17
 1269 0390 00000000 		.word	.LANCHOR2
 1270 0394 08010000 		.word	.LC20
 1271 0398 32010000 		.word	.LC22
 1272 039c 4E010000 		.word	.LC24
 1273 03a0 00000000 		.word	.LANCHOR3
 1274 03a4 00000000 		.word	GPS_recBuf
 1275 03a8 53010000 		.word	.LC28
 1276 03ac DF010000 		.word	.LC31
 1277 03b0 00000000 		.word	.LANCHOR4
 1278 03b4 00000000 		.word	PC_recBuf
 1279 03b8 56010000 		.word	.LC34
 1280 03bc 5A010000 		.word	.LC37
 1281 03c0 BD010000 		.word	.LC63
 1282 03c4 D4010000 		.word	.LC65
 1283 03c8 D7010000 		.word	.LC67
 1284 03cc D8010000 		.word	.LC69
 1285 03d0 78010000 		.word	.LC39
 1286 03d4 00000000 		.word	.LANCHOR5
 1287 03d8 00000000 		.word	.LANCHOR6
 1288 03dc 00000000 		.word	.LANCHOR7
 1289 03e0 00000000 		.word	.LANCHOR8
 1290 03e4 00000000 		.word	NB_recBuf
 1291 03e8 00000000 		.word	.LANCHOR9
 1292 03ec 00000000 		.word	parsedLat
 1293 03f0 00000000 		.word	parsedLon
 1294 03f4 82010000 		.word	.LC42
 1295 03f8 8C010000 		.word	.LC44
 1296 03fc 92010000 		.word	.LC46
 1297 0400 97010000 		.word	.LC48
 1298 0404 9A010000 		.word	.LC50
 1299 0408 02000000 		.word	PC_recBuf+2
 1300 040c A8010000 		.word	.LC60
 1301 0410 00000000 		.word	.LANCHOR10
 1302              	.LBE201:
 1303              		.cfi_endproc
 1304              	.LFE132:
 1306              		.section	.text.LLWU_IRQHandler,"ax",%progbits
 1307              		.align	1
 1308              		.global	LLWU_IRQHandler
 1309              		.syntax unified
 1310              		.code	16
 1311              		.thumb_func
 1312              		.fpu softvfp
 1314              	LLWU_IRQHandler:
 1315              	.LFB133:
 476:../source/main.c **** 
 477:../source/main.c **** 	while (1)
 478:../source/main.c **** 	{
 479:../source/main.c **** 
 480:../source/main.c **** 	}
 481:../source/main.c **** 	//parseData(testLat, testLon);
 482:../source/main.c **** }
 483:../source/main.c **** /*
 484:../source/main.c ****  void PORTC_IRQHandler() {
 485:../source/main.c **** 
 486:../source/main.c ****  PORTC->PCR[6] |= 0x01000000;
 487:../source/main.c **** 
 488:../source/main.c ****  while ( PORTC->PCR[6] & 0x01000000) {
 489:../source/main.c **** 
 490:../source/main.c ****  }
 491:../source/main.c **** 
 492:../source/main.c ****  LPTMR_Deinit(LPTMR0);			// Deinitiate timer to reset timer counte
 493:../source/main.c ****  LPTMR_Init(LPTMR0, &lptmr_config);
 494:../source/main.c ****  LPTMR_SetTimerPeriod(LPTMR0, 2000);  // 3000 for 20hz data rat
 495:../source/main.c ****  LPTMR_EnableInterrupts(LPTMR0, LPTMR_CSR_TIE_MASK);	//Sets Timer Interrupt Enable bit to 1
 496:../source/main.c ****  LPTMR_StartTimer(LPTMR0);
 497:../source/main.c ****  GPIO_PortToggle(GPIOB, 1 << 22u);
 498:../source/main.c **** 
 499:../source/main.c ****  }
 500:../source/main.c ****  */
 501:../source/main.c **** void LLWU_IRQHandler()
 502:../source/main.c **** {
 1316              		.loc 1 502 0
 1317              		.cfi_startproc
 1318              		@ args = 0, pretend = 0, frame = 0
 1319              		@ frame_needed = 0, uses_anonymous_args = 0
 1320              	.LVL135:
 1321              	.LBB202:
 1322              	.LBB203:
 211:../drivers/fsl_gpio.h **** }
 212:../drivers/fsl_gpio.h **** 
 213:../drivers/fsl_gpio.h **** /*!
 214:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 0.
 215:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PortClear.
 216:../drivers/fsl_gpio.h ****  *
 217:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 218:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 219:../drivers/fsl_gpio.h ****  */
 220:../drivers/fsl_gpio.h **** static inline void GPIO_ClearPinsOutput(GPIO_Type *base, uint32_t mask)
 221:../drivers/fsl_gpio.h **** {
 222:../drivers/fsl_gpio.h ****     GPIO_PortClear(base, mask);
 223:../drivers/fsl_gpio.h **** }
 224:../drivers/fsl_gpio.h **** 
 225:../drivers/fsl_gpio.h **** /*!
 226:../drivers/fsl_gpio.h ****  * @brief Reverses the current output logic of the multiple GPIO pins.
 227:../drivers/fsl_gpio.h ****  *
 228:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 229:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 230:../drivers/fsl_gpio.h ****  */
 231:../drivers/fsl_gpio.h **** static inline void GPIO_PortToggle(GPIO_Type *base, uint32_t mask)
 232:../drivers/fsl_gpio.h **** {
 233:../drivers/fsl_gpio.h ****     base->PTOR = mask;
 1323              		.loc 6 233 0
 1324 0000 1022     		movs	r2, #16
 1325              	.LBE203:
 1326              	.LBE202:
 503:../source/main.c **** 
 504:../source/main.c **** 	GPIO_PortToggle(GPIOA, 1 << 4u);
 505:../source/main.c **** 	GPIO_PortToggle(GPIOA, 1 << 4u);
 506:../source/main.c **** 	wake = 1;
 1327              		.loc 1 506 0
 1328 0002 0120     		movs	r0, #1
 502:../source/main.c **** 
 1329              		.loc 1 502 0
 1330 0004 30B5     		push	{r4, r5, lr}
 1331              		.cfi_def_cfa_offset 12
 1332              		.cfi_offset 4, -12
 1333              		.cfi_offset 5, -8
 1334              		.cfi_offset 14, -4
 1335              	.LBB206:
 1336              	.LBB204:
 1337              		.loc 6 233 0
 1338 0006 124B     		ldr	r3, .L82
 1339              	.LBE204:
 1340              	.LBE206:
 1341              		.loc 1 506 0
 1342 0008 1249     		ldr	r1, .L82+4
 1343              	.LBB207:
 1344              	.LBB205:
 1345              		.loc 6 233 0
 1346 000a DA60     		str	r2, [r3, #12]
 1347              	.LVL136:
 1348              	.LBE205:
 1349              	.LBE207:
 1350              	.LBB208:
 1351              	.LBB209:
 1352 000c DA60     		str	r2, [r3, #12]
 1353              	.LVL137:
 1354              	.LBE209:
 1355              	.LBE208:
 1356              	.LBB210:
 1357              	.LBB211:
 1358              		.file 7 "../drivers/fsl_llwu.h"
   1:../drivers/fsl_llwu.h **** /*
   2:../drivers/fsl_llwu.h ****  * The Clear BSD License
   3:../drivers/fsl_llwu.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_llwu.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_llwu.h ****  * All rights reserved.
   6:../drivers/fsl_llwu.h ****  *
   7:../drivers/fsl_llwu.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_llwu.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_llwu.h ****  * that the following conditions are met:
  10:../drivers/fsl_llwu.h ****  *
  11:../drivers/fsl_llwu.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_llwu.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_llwu.h ****  *
  14:../drivers/fsl_llwu.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_llwu.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_llwu.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_llwu.h ****  *
  18:../drivers/fsl_llwu.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_llwu.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_llwu.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_llwu.h ****  *
  22:../drivers/fsl_llwu.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_llwu.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_llwu.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_llwu.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_llwu.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_llwu.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_llwu.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_llwu.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_llwu.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_llwu.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_llwu.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_llwu.h ****  */
  34:../drivers/fsl_llwu.h **** #ifndef _FSL_LLWU_H_
  35:../drivers/fsl_llwu.h **** #define _FSL_LLWU_H_
  36:../drivers/fsl_llwu.h **** 
  37:../drivers/fsl_llwu.h **** #include "fsl_common.h"
  38:../drivers/fsl_llwu.h **** 
  39:../drivers/fsl_llwu.h **** /*! @addtogroup llwu */
  40:../drivers/fsl_llwu.h **** /*! @{ */
  41:../drivers/fsl_llwu.h **** 
  42:../drivers/fsl_llwu.h **** /*******************************************************************************
  43:../drivers/fsl_llwu.h ****  * Definitions
  44:../drivers/fsl_llwu.h ****  ******************************************************************************/
  45:../drivers/fsl_llwu.h **** 
  46:../drivers/fsl_llwu.h **** /*! @name Driver version */
  47:../drivers/fsl_llwu.h **** /*@{*/
  48:../drivers/fsl_llwu.h **** /*! @brief LLWU driver version 2.0.1. */
  49:../drivers/fsl_llwu.h **** #define FSL_LLWU_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  50:../drivers/fsl_llwu.h **** /*@}*/
  51:../drivers/fsl_llwu.h **** 
  52:../drivers/fsl_llwu.h **** /*!
  53:../drivers/fsl_llwu.h ****  * @brief External input pin control modes
  54:../drivers/fsl_llwu.h ****  */
  55:../drivers/fsl_llwu.h **** typedef enum _llwu_external_pin_mode
  56:../drivers/fsl_llwu.h **** {
  57:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinDisable = 0U,     /*!< Pin disabled as a wakeup input.           */
  58:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinRisingEdge = 1U,  /*!< Pin enabled with the rising edge detection. */
  59:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinFallingEdge = 2U, /*!< Pin enabled with the falling edge detection.*/
  60:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinAnyEdge = 3U      /*!< Pin enabled with any change detection.  */
  61:../drivers/fsl_llwu.h **** } llwu_external_pin_mode_t;
  62:../drivers/fsl_llwu.h **** 
  63:../drivers/fsl_llwu.h **** /*!
  64:../drivers/fsl_llwu.h ****  * @brief Digital filter control modes
  65:../drivers/fsl_llwu.h ****  */
  66:../drivers/fsl_llwu.h **** typedef enum _llwu_pin_filter_mode
  67:../drivers/fsl_llwu.h **** {
  68:../drivers/fsl_llwu.h ****     kLLWU_PinFilterDisable = 0U,     /*!< Filter disabled.               */
  69:../drivers/fsl_llwu.h ****     kLLWU_PinFilterRisingEdge = 1U,  /*!< Filter positive edge detection.*/
  70:../drivers/fsl_llwu.h ****     kLLWU_PinFilterFallingEdge = 2U, /*!< Filter negative edge detection.*/
  71:../drivers/fsl_llwu.h ****     kLLWU_PinFilterAnyEdge = 3U      /*!< Filter any edge detection.     */
  72:../drivers/fsl_llwu.h **** } llwu_pin_filter_mode_t;
  73:../drivers/fsl_llwu.h **** 
  74:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_VERID) && FSL_FEATURE_LLWU_HAS_VERID)
  75:../drivers/fsl_llwu.h **** /*!
  76:../drivers/fsl_llwu.h ****  * @brief IP version ID definition.
  77:../drivers/fsl_llwu.h ****  */
  78:../drivers/fsl_llwu.h **** typedef struct _llwu_version_id
  79:../drivers/fsl_llwu.h **** {
  80:../drivers/fsl_llwu.h ****     uint16_t feature; /*!< A feature specification number. */
  81:../drivers/fsl_llwu.h ****     uint8_t minor;    /*!< The minor version number.         */
  82:../drivers/fsl_llwu.h ****     uint8_t major;    /*!< The major version number.         */
  83:../drivers/fsl_llwu.h **** } llwu_version_id_t;
  84:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_VERID */
  85:../drivers/fsl_llwu.h **** 
  86:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_PARAM) && FSL_FEATURE_LLWU_HAS_PARAM)
  87:../drivers/fsl_llwu.h **** /*!
  88:../drivers/fsl_llwu.h ****  * @brief IP parameter definition.
  89:../drivers/fsl_llwu.h ****  */
  90:../drivers/fsl_llwu.h **** typedef struct _llwu_param
  91:../drivers/fsl_llwu.h **** {
  92:../drivers/fsl_llwu.h ****     uint8_t filters; /*!< A number of the pin filter.      */
  93:../drivers/fsl_llwu.h ****     uint8_t dmas;    /*!< A number of the wakeup DMA.      */
  94:../drivers/fsl_llwu.h ****     uint8_t modules; /*!< A number of the wakeup module.   */
  95:../drivers/fsl_llwu.h ****     uint8_t pins;    /*!< A number of the wake up pin.     */
  96:../drivers/fsl_llwu.h **** } llwu_param_t;
  97:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_PARAM */
  98:../drivers/fsl_llwu.h **** 
  99:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_PIN_FILTER) && FSL_FEATURE_LLWU_HAS_PIN_FILTER)
 100:../drivers/fsl_llwu.h **** /*!
 101:../drivers/fsl_llwu.h ****  * @brief An external input pin filter control structure
 102:../drivers/fsl_llwu.h ****  */
 103:../drivers/fsl_llwu.h **** typedef struct _llwu_external_pin_filter_mode
 104:../drivers/fsl_llwu.h **** {
 105:../drivers/fsl_llwu.h ****     uint32_t pinIndex;                 /*!< A pin number  */
 106:../drivers/fsl_llwu.h ****     llwu_pin_filter_mode_t filterMode; /*!< Filter mode */
 107:../drivers/fsl_llwu.h **** } llwu_external_pin_filter_mode_t;
 108:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_PIN_FILTER */
 109:../drivers/fsl_llwu.h **** 
 110:../drivers/fsl_llwu.h **** /*******************************************************************************
 111:../drivers/fsl_llwu.h ****  * API
 112:../drivers/fsl_llwu.h ****  ******************************************************************************/
 113:../drivers/fsl_llwu.h **** 
 114:../drivers/fsl_llwu.h **** #if defined(__cplusplus)
 115:../drivers/fsl_llwu.h **** extern "C" {
 116:../drivers/fsl_llwu.h **** #endif
 117:../drivers/fsl_llwu.h **** 
 118:../drivers/fsl_llwu.h **** /*!
 119:../drivers/fsl_llwu.h ****  * @name Low-Leakage Wakeup Unit Control APIs
 120:../drivers/fsl_llwu.h ****  * @{
 121:../drivers/fsl_llwu.h ****  */
 122:../drivers/fsl_llwu.h **** 
 123:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_VERID) && FSL_FEATURE_LLWU_HAS_VERID)
 124:../drivers/fsl_llwu.h **** /*!
 125:../drivers/fsl_llwu.h ****  * @brief Gets the LLWU version ID.
 126:../drivers/fsl_llwu.h ****  *
 127:../drivers/fsl_llwu.h ****  * This function gets the LLWU version ID, including the major version number,
 128:../drivers/fsl_llwu.h ****  * the minor version number, and the feature specification number.
 129:../drivers/fsl_llwu.h ****  *
 130:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 131:../drivers/fsl_llwu.h ****  * @param versionId     A pointer to the version ID structure.
 132:../drivers/fsl_llwu.h ****  */
 133:../drivers/fsl_llwu.h **** static inline void LLWU_GetVersionId(LLWU_Type *base, llwu_version_id_t *versionId)
 134:../drivers/fsl_llwu.h **** {
 135:../drivers/fsl_llwu.h ****     *((uint32_t *)versionId) = base->VERID;
 136:../drivers/fsl_llwu.h **** }
 137:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_VERID */
 138:../drivers/fsl_llwu.h **** 
 139:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_PARAM) && FSL_FEATURE_LLWU_HAS_PARAM)
 140:../drivers/fsl_llwu.h **** /*!
 141:../drivers/fsl_llwu.h ****  * @brief Gets the LLWU parameter.
 142:../drivers/fsl_llwu.h ****  *
 143:../drivers/fsl_llwu.h ****  * This function gets the LLWU parameter, including a wakeup pin number, a module
 144:../drivers/fsl_llwu.h ****  * number, a DMA number, and a pin filter number.
 145:../drivers/fsl_llwu.h ****  *
 146:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 147:../drivers/fsl_llwu.h ****  * @param param         A pointer to the LLWU parameter structure.
 148:../drivers/fsl_llwu.h ****  */
 149:../drivers/fsl_llwu.h **** static inline void LLWU_GetParam(LLWU_Type *base, llwu_param_t *param)
 150:../drivers/fsl_llwu.h **** {
 151:../drivers/fsl_llwu.h ****     *((uint32_t *)param) = base->PARAM;
 152:../drivers/fsl_llwu.h **** }
 153:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_PARAM */
 154:../drivers/fsl_llwu.h **** 
 155:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN) && FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN)
 156:../drivers/fsl_llwu.h **** /*!
 157:../drivers/fsl_llwu.h ****  * @brief Sets the external input pin source mode.
 158:../drivers/fsl_llwu.h ****  *
 159:../drivers/fsl_llwu.h ****  * This function sets the external input pin source mode that is used
 160:../drivers/fsl_llwu.h ****  * as a wake up source.
 161:../drivers/fsl_llwu.h ****  *
 162:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 163:../drivers/fsl_llwu.h ****  * @param pinIndex A pin index to be enabled as an external wakeup source starting from 1.
 164:../drivers/fsl_llwu.h ****  * @param pinMode A pin configuration mode defined in the llwu_external_pin_modes_t.
 165:../drivers/fsl_llwu.h ****  */
 166:../drivers/fsl_llwu.h **** void LLWU_SetExternalWakeupPinMode(LLWU_Type *base, uint32_t pinIndex, llwu_external_pin_mode_t pin
 167:../drivers/fsl_llwu.h **** 
 168:../drivers/fsl_llwu.h **** /*!
 169:../drivers/fsl_llwu.h ****  * @brief Gets the external wakeup source flag.
 170:../drivers/fsl_llwu.h ****  *
 171:../drivers/fsl_llwu.h ****  * This function checks the external pin flag to detect whether the MCU is
 172:../drivers/fsl_llwu.h ****  * woken up by the specific pin.
 173:../drivers/fsl_llwu.h ****  *
 174:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 175:../drivers/fsl_llwu.h ****  * @param pinIndex     A pin index, which starts from 1.
 176:../drivers/fsl_llwu.h ****  * @return True if the specific pin is a wakeup source.
 177:../drivers/fsl_llwu.h ****  */
 178:../drivers/fsl_llwu.h **** bool LLWU_GetExternalWakeupPinFlag(LLWU_Type *base, uint32_t pinIndex);
 179:../drivers/fsl_llwu.h **** 
 180:../drivers/fsl_llwu.h **** /*!
 181:../drivers/fsl_llwu.h ****  * @brief Clears the external wakeup source flag.
 182:../drivers/fsl_llwu.h ****  *
 183:../drivers/fsl_llwu.h ****  * This function clears the external wakeup source flag for a specific pin.
 184:../drivers/fsl_llwu.h ****  *
 185:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 186:../drivers/fsl_llwu.h ****  * @param pinIndex A pin index, which starts from 1.
 187:../drivers/fsl_llwu.h ****  */
 188:../drivers/fsl_llwu.h **** void LLWU_ClearExternalWakeupPinFlag(LLWU_Type *base, uint32_t pinIndex);
 189:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN */
 190:../drivers/fsl_llwu.h **** 
 191:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE) && FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE)
 192:../drivers/fsl_llwu.h **** /*!
 193:../drivers/fsl_llwu.h ****  * @brief Enables/disables the internal module source.
 194:../drivers/fsl_llwu.h ****  *
 195:../drivers/fsl_llwu.h ****  * This function enables/disables the internal module source mode that is used
 196:../drivers/fsl_llwu.h ****  * as a wake up source.
 197:../drivers/fsl_llwu.h ****  *
 198:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 199:../drivers/fsl_llwu.h ****  * @param moduleIndex   A module index to be enabled as an internal wakeup source starting from 1.
 200:../drivers/fsl_llwu.h ****  * @param enable        An enable or a disable setting
 201:../drivers/fsl_llwu.h ****  */
 202:../drivers/fsl_llwu.h **** static inline void LLWU_EnableInternalModuleInterruptWakup(LLWU_Type *base, uint32_t moduleIndex, b
 203:../drivers/fsl_llwu.h **** {
 204:../drivers/fsl_llwu.h ****     if (enable)
 205:../drivers/fsl_llwu.h ****     {
 206:../drivers/fsl_llwu.h ****         base->ME |= 1U << moduleIndex;
 207:../drivers/fsl_llwu.h ****     }
 208:../drivers/fsl_llwu.h ****     else
 209:../drivers/fsl_llwu.h ****     {
 210:../drivers/fsl_llwu.h ****         base->ME &= ~(1U << moduleIndex);
 211:../drivers/fsl_llwu.h ****     }
 212:../drivers/fsl_llwu.h **** }
 213:../drivers/fsl_llwu.h **** 
 214:../drivers/fsl_llwu.h **** #if (!(defined(FSL_FEATURE_LLWU_HAS_NO_INTERNAL_MODULE_WAKEUP_FLAG_REG) && \
 215:../drivers/fsl_llwu.h ****        FSL_FEATURE_LLWU_HAS_NO_INTERNAL_MODULE_WAKEUP_FLAG_REG))
 216:../drivers/fsl_llwu.h **** /* Re-define the register which includes the internal wakeup module flag. */
 217:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_REG_BITWIDTH) && (FSL_FEATURE_LLWU_REG_BITWIDTH == 32)) /* 32-bit LLW
 218:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_MF) && FSL_FEATURE_LLWU_HAS_MF)
 219:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG MF
 220:../drivers/fsl_llwu.h **** #else
 221:../drivers/fsl_llwu.h **** #error "Unsupported internal module flag register."
 222:../drivers/fsl_llwu.h **** #endif
 223:../drivers/fsl_llwu.h **** #else /* 8-bit LLUW. */
 224:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_MF) && FSL_FEATURE_LLWU_HAS_MF)
 225:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG MF5
 226:../drivers/fsl_llwu.h **** #elif(defined(FSL_FEATURE_LLWU_HAS_PF) && FSL_FEATURE_LLWU_HAS_PF)
 227:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG PF3
 228:../drivers/fsl_llwu.h **** #elif(!(defined(FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN) && (FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN > 16)))
 229:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG F3
 230:../drivers/fsl_llwu.h **** #else
 231:../drivers/fsl_llwu.h **** #error "Unsupported internal module flag register."
 232:../drivers/fsl_llwu.h **** #endif
 233:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_REG_BITWIDTH */
 234:../drivers/fsl_llwu.h **** 
 235:../drivers/fsl_llwu.h **** /*!
 236:../drivers/fsl_llwu.h ****  * @brief Gets the external wakeup source flag.
 237:../drivers/fsl_llwu.h ****  *
 238:../drivers/fsl_llwu.h ****  * This function checks the external pin flag to detect whether the system is
 239:../drivers/fsl_llwu.h ****  * woken up by the specific pin.
 240:../drivers/fsl_llwu.h ****  *
 241:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 242:../drivers/fsl_llwu.h ****  * @param moduleIndex  A module index, which starts from 1.
 243:../drivers/fsl_llwu.h ****  * @return True if the specific pin is a wake up source.
 244:../drivers/fsl_llwu.h ****  */
 245:../drivers/fsl_llwu.h **** static inline bool LLWU_GetInternalWakeupModuleFlag(LLWU_Type *base, uint32_t moduleIndex)
 246:../drivers/fsl_llwu.h **** {
 247:../drivers/fsl_llwu.h ****     return ((1U << moduleIndex) == (base->INTERNAL_WAKEUP_MODULE_FLAG_REG & (1U << moduleIndex)));
 1359              		.loc 7 247 0
 1360 000e 124B     		ldr	r3, .L82+8
 1361              	.LBE211:
 1362              	.LBE210:
 1363              		.loc 1 506 0
 1364 0010 0870     		strb	r0, [r1]
 1365              	.LVL138:
 1366              	.LBB213:
 1367              	.LBB212:
 1368              		.loc 7 247 0
 1369 0012 DA79     		ldrb	r2, [r3, #7]
 1370              	.LBE212:
 1371              	.LBE213:
 507:../source/main.c **** 
 508:../source/main.c **** 	/* If wakeup by LPTMR. */
 509:../source/main.c **** 	if (LLWU_GetInternalWakeupModuleFlag(LLWU, 0U))
 1372              		.loc 1 509 0
 1373 0014 0242     		tst	r2, r0
 1374 0016 10D0     		beq	.L77
 1375              	.LVL139:
 1376              	.LBB214:
 1377              	.LBB215:
 226:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 1378              		.loc 3 226 0
 1379 0018 C025     		movs	r5, #192
 222:../drivers/fsl_lptmr.h **** 
 1380              		.loc 3 222 0
 1381 001a 104A     		ldr	r2, .L82+12
 1382 001c 1468     		ldr	r4, [r2]
 1383              	.LVL140:
 226:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 1384              		.loc 3 226 0
 1385 001e AC43     		bics	r4, r5
 1386              	.LVL141:
 227:../drivers/fsl_lptmr.h **** }
 1387              		.loc 3 227 0
 1388 0020 1460     		str	r4, [r2]
 1389              	.LVL142:
 1390              	.LBE215:
 1391              	.LBE214:
 1392              	.LBB216:
 1393              	.LBB217:
 292:../drivers/fsl_lptmr.h **** }
 1394              		.loc 3 292 0
 1395 0022 8024     		movs	r4, #128
 1396 0024 1568     		ldr	r5, [r2]
 1397 0026 2C43     		orrs	r4, r5
 1398              	.LBE217:
 1399              	.LBE216:
 1400              	.LBB219:
 1401              	.LBB220:
 367:../drivers/fsl_lptmr.h **** }
 368:../drivers/fsl_lptmr.h **** 
 369:../drivers/fsl_lptmr.h **** /*!
 370:../drivers/fsl_lptmr.h ****  * @brief Stops the timer.
 371:../drivers/fsl_lptmr.h ****  *
 372:../drivers/fsl_lptmr.h ****  * This function stops the timer and resets the timer's counter register.
 373:../drivers/fsl_lptmr.h ****  *
 374:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 375:../drivers/fsl_lptmr.h ****  */
 376:../drivers/fsl_lptmr.h **** static inline void LPTMR_StopTimer(LPTMR_Type *base)
 377:../drivers/fsl_lptmr.h **** {
 378:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 379:../drivers/fsl_lptmr.h **** 
 380:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit to avoid clearing the w1c bit when writing back. */
 381:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 382:../drivers/fsl_lptmr.h ****     reg &= ~LPTMR_CSR_TEN_MASK;
 1402              		.loc 3 382 0
 1403 0028 8125     		movs	r5, #129
 1404              	.LBE220:
 1405              	.LBE219:
 1406              	.LBB222:
 1407              	.LBB218:
 292:../drivers/fsl_lptmr.h **** }
 1408              		.loc 3 292 0
 1409 002a 1460     		str	r4, [r2]
 1410              	.LVL143:
 1411              	.LBE218:
 1412              	.LBE222:
 1413              	.LBB223:
 1414              	.LBB221:
 378:../drivers/fsl_lptmr.h **** 
 1415              		.loc 3 378 0
 1416 002c 1468     		ldr	r4, [r2]
 1417              	.LVL144:
 1418              		.loc 3 382 0
 1419 002e AC43     		bics	r4, r5
 1420              	.LVL145:
 383:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 1421              		.loc 3 383 0
 1422 0030 1460     		str	r4, [r2]
 1423              	.LVL146:
 1424              	.LBE221:
 1425              	.LBE223:
 510:../source/main.c **** 	{
 511:../source/main.c **** 		LPTMR_DisableInterrupts(LPTMR0, kLPTMR_TimerInterruptEnable);
 512:../source/main.c **** 		LPTMR_ClearStatusFlags(LPTMR0, kLPTMR_TimerCompareFlag);
 513:../source/main.c **** 		LPTMR_StopTimer(LPTMR0);
 514:../source/main.c **** 		wake = 1;
 1426              		.loc 1 514 0
 1427 0032 0870     		strb	r0, [r1]
 1428              	.L78:
 515:../source/main.c **** 	}
 516:../source/main.c **** 
 517:../source/main.c **** 	else if ( LLWU->F2 & 0x20)
 518:../source/main.c **** 	{	// 0x04 for stock frdm acc wakeup reg, 0x01 for customized
 519:../source/main.c **** 		wake = 2;
 520:../source/main.c **** 		LLWU->F2 |= 0x20;
 521:../source/main.c **** 	}
 522:../source/main.c **** 
 523:../source/main.c **** 	LLWU->F2 = 0x20;
 1429              		.loc 1 523 0
 1430 0034 2022     		movs	r2, #32
 524:../source/main.c **** }
 1431              		.loc 1 524 0
 1432              		@ sp needed
 523:../source/main.c **** }
 1433              		.loc 1 523 0
 1434 0036 9A71     		strb	r2, [r3, #6]
 1435              		.loc 1 524 0
 1436 0038 30BD     		pop	{r4, r5, pc}
 1437              	.L77:
 517:../source/main.c **** 	{	// 0x04 for stock frdm acc wakeup reg, 0x01 for customized
 1438              		.loc 1 517 0
 1439 003a 2022     		movs	r2, #32
 1440 003c 9879     		ldrb	r0, [r3, #6]
 1441 003e 1042     		tst	r0, r2
 1442 0040 F8D0     		beq	.L78
 519:../source/main.c **** 		LLWU->F2 |= 0x20;
 1443              		.loc 1 519 0
 1444 0042 0220     		movs	r0, #2
 1445 0044 0870     		strb	r0, [r1]
 520:../source/main.c **** 	}
 1446              		.loc 1 520 0
 1447 0046 9979     		ldrb	r1, [r3, #6]
 1448 0048 0A43     		orrs	r2, r1
 1449 004a 9A71     		strb	r2, [r3, #6]
 1450 004c F2E7     		b	.L78
 1451              	.L83:
 1452 004e C046     		.align	2
 1453              	.L82:
 1454 0050 00F00F40 		.word	1074786304
 1455 0054 00000000 		.word	.LANCHOR2
 1456 0058 00C00740 		.word	1074249728
 1457 005c 00000440 		.word	1074003968
 1458              		.cfi_endproc
 1459              	.LFE133:
 1461              		.section	.text.LPTMR0_IRQHandler,"ax",%progbits
 1462              		.align	1
 1463              		.global	LPTMR0_IRQHandler
 1464              		.syntax unified
 1465              		.code	16
 1466              		.thumb_func
 1467              		.fpu softvfp
 1469              	LPTMR0_IRQHandler:
 1470              	.LFB134:
 525:../source/main.c **** 
 526:../source/main.c **** void LPTMR0_IRQHandler()
 527:../source/main.c **** {
 1471              		.loc 1 527 0
 1472              		.cfi_startproc
 1473              		@ args = 0, pretend = 0, frame = 0
 1474              		@ frame_needed = 0, uses_anonymous_args = 0
 1475              		@ link register save eliminated.
 528:../source/main.c **** 
 529:../source/main.c **** 	LPTMR0->CSR |= LPTMR_CSR_TCF_MASK;		// Clear the interrupt flag
 1476              		.loc 1 529 0
 1477 0000 8022     		movs	r2, #128
 1478 0002 044B     		ldr	r3, .L87
 1479 0004 1968     		ldr	r1, [r3]
 1480 0006 1143     		orrs	r1, r2
 1481 0008 1960     		str	r1, [r3]
 1482              	.L85:
 530:../source/main.c **** 	while ( LPTMR0->CSR & LPTMR_CSR_TCF_MASK)
 1483              		.loc 1 530 0 discriminator 1
 1484 000a 1968     		ldr	r1, [r3]
 1485 000c 1142     		tst	r1, r2
 1486 000e FCD1     		bne	.L85
 531:../source/main.c **** 	{
 532:../source/main.c **** 
 533:../source/main.c **** 	}
 534:../source/main.c **** 
 535:../source/main.c **** 	//wake=1;
 536:../source/main.c **** 
 537:../source/main.c **** 	//PMC->REGSC |= 0x08;
 538:../source/main.c **** 
 539:../source/main.c **** 	//GPIO_PortToggle(GPIOB, 1 << 21u); //light blue LED
 540:../source/main.c **** }
 1487              		.loc 1 540 0
 1488              		@ sp needed
 1489 0010 7047     		bx	lr
 1490              	.L88:
 1491 0012 C046     		.align	2
 1492              	.L87:
 1493 0014 00000440 		.word	1074003968
 1494              		.cfi_endproc
 1495              	.LFE134:
 1497              		.section	.text.LPUART0_IRQHandler,"ax",%progbits
 1498              		.align	1
 1499              		.global	LPUART0_IRQHandler
 1500              		.syntax unified
 1501              		.code	16
 1502              		.thumb_func
 1503              		.fpu softvfp
 1505              	LPUART0_IRQHandler:
 1506              	.LFB135:
 541:../source/main.c **** 
 542:../source/main.c **** void LPUART0_IRQHandler()
 543:../source/main.c **** {
 1507              		.loc 1 543 0
 1508              		.cfi_startproc
 1509              		@ args = 0, pretend = 0, frame = 0
 1510              		@ frame_needed = 0, uses_anonymous_args = 0
 1511 0000 10B5     		push	{r4, lr}
 1512              		.cfi_def_cfa_offset 8
 1513              		.cfi_offset 4, -8
 1514              		.cfi_offset 14, -4
 544:../source/main.c **** 
 545:../source/main.c **** 	LPUART_ClearStatusFlags(LPUART0, kUART_RxDataRegFullFlag);
 1515              		.loc 1 545 0
 1516 0002 0D4C     		ldr	r4, .L93
 1517 0004 2021     		movs	r1, #32
 1518 0006 2000     		movs	r0, r4
 1519 0008 FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1520              	.LVL147:
 1521              	.LBB224:
 1522              	.LBB225:
 1523              		.loc 6 233 0
 1524 000c 8022     		movs	r2, #128
 1525 000e 0B4B     		ldr	r3, .L93+4
 1526 0010 D203     		lsls	r2, r2, #15
 1527 0012 DA60     		str	r2, [r3, #12]
 1528              	.LVL148:
 1529              	.LBE225:
 1530              	.LBE224:
 546:../source/main.c **** 	GPIO_PortToggle(GPIOB, 1 << 22u); //toggle RED led to indicate data arrived from NB Iiootee module
 547:../source/main.c **** 
 548:../source/main.c **** 	uint8_t uartData = LPUART0->DATA;
 1531              		.loc 1 548 0
 1532 0014 E368     		ldr	r3, [r4, #12]
 1533 0016 D9B2     		uxtb	r1, r3
 1534              	.LVL149:
 549:../source/main.c **** 	if (uartData != 0)
 1535              		.loc 1 549 0
 1536 0018 0029     		cmp	r1, #0
 1537 001a 0CD0     		beq	.L89
 550:../source/main.c **** 	{
 551:../source/main.c **** 
 552:../source/main.c **** 		NB_recBuf[NB_bufPtr] = uartData;
 1538              		.loc 1 552 0
 1539 001c 084A     		ldr	r2, .L93+8
 1540 001e 094C     		ldr	r4, .L93+12
 1541 0020 1088     		ldrh	r0, [r2]
 1542 0022 2354     		strb	r3, [r4, r0]
 553:../source/main.c **** 		NB_bufPtr++;
 1543              		.loc 1 553 0
 1544 0024 1388     		ldrh	r3, [r2]
 1545 0026 0133     		adds	r3, r3, #1
 1546 0028 9BB2     		uxth	r3, r3
 1547 002a 1380     		strh	r3, [r2]
 554:../source/main.c **** 
 555:../source/main.c **** 		if (uartData == 0x0d)
 1548              		.loc 1 555 0
 1549 002c 0D29     		cmp	r1, #13
 1550 002e 02D1     		bne	.L89
 556:../source/main.c **** 		{
 557:../source/main.c **** 			NB_strReady = 1;
 1551              		.loc 1 557 0
 1552 0030 0122     		movs	r2, #1
 1553 0032 054B     		ldr	r3, .L93+16
 1554 0034 1A70     		strb	r2, [r3]
 1555              	.L89:
 558:../source/main.c **** 			//NB_bufPtr = 0;
 559:../source/main.c **** 		}
 560:../source/main.c **** 
 561:../source/main.c **** 	}
 562:../source/main.c **** 
 563:../source/main.c **** }
 1556              		.loc 1 563 0
 1557              		@ sp needed
 1558 0036 10BD     		pop	{r4, pc}
 1559              	.L94:
 1560              		.align	2
 1561              	.L93:
 1562 0038 00400540 		.word	1074085888
 1563 003c 40F00F40 		.word	1074786368
 1564 0040 00000000 		.word	.LANCHOR9
 1565 0044 00000000 		.word	NB_recBuf
 1566 0048 00000000 		.word	.LANCHOR7
 1567              		.cfi_endproc
 1568              	.LFE135:
 1570              		.section	.text.UART2_FLEXIO_IRQHandler,"ax",%progbits
 1571              		.align	1
 1572              		.global	UART2_FLEXIO_IRQHandler
 1573              		.syntax unified
 1574              		.code	16
 1575              		.thumb_func
 1576              		.fpu softvfp
 1578              	UART2_FLEXIO_IRQHandler:
 1579              	.LFB136:
 564:../source/main.c **** 
 565:../source/main.c **** void UART2_FLEXIO_IRQHandler()
 566:../source/main.c **** {
 1580              		.loc 1 566 0
 1581              		.cfi_startproc
 1582              		@ args = 0, pretend = 0, frame = 0
 1583              		@ frame_needed = 0, uses_anonymous_args = 0
 1584 0000 10B5     		push	{r4, lr}
 1585              		.cfi_def_cfa_offset 8
 1586              		.cfi_offset 4, -8
 1587              		.cfi_offset 14, -4
 567:../source/main.c **** 
 568:../source/main.c **** 	UART_ClearStatusFlags(UART2, kUART_RxDataRegFullFlag);
 1588              		.loc 1 568 0
 1589 0002 0E4C     		ldr	r4, .L98
 1590 0004 2021     		movs	r1, #32
 1591 0006 2000     		movs	r0, r4
 1592 0008 FFF7FEFF 		bl	UART_ClearStatusFlags
 1593              	.LVL150:
 569:../source/main.c **** 
 570:../source/main.c **** 	uint8_t uartData = UART2->D;
 571:../source/main.c **** 
 572:../source/main.c **** 	/*
 573:../source/main.c **** 	 * Here we use different method for collecting GPS data. because there can be other data than char
 574:../source/main.c **** 	 * like 0x00 in UBX messages, normal string functions would fail (mistaken null terminator)
 575:../source/main.c **** 	 * so we must collect every byte from the gps module
 576:../source/main.c **** 	 * so fill buffer to almost full with GPS data, then put GPS_strReady high and stop filling.
 577:../source/main.c **** 	 * Start filling again when data has been read and GPS_strReady is low.
 578:../source/main.c **** 	 *
 579:../source/main.c **** 	 */
 580:../source/main.c **** 	if (GPS_strReady == 0)
 1594              		.loc 1 580 0
 1595 000c 0C49     		ldr	r1, .L98+4
 570:../source/main.c **** 
 1596              		.loc 1 570 0
 1597 000e E379     		ldrb	r3, [r4, #7]
 1598              		.loc 1 580 0
 1599 0010 0878     		ldrb	r0, [r1]
 570:../source/main.c **** 
 1600              		.loc 1 570 0
 1601 0012 DBB2     		uxtb	r3, r3
 1602              	.LVL151:
 1603 0014 0B4A     		ldr	r2, .L98+8
 1604              		.loc 1 580 0
 1605 0016 0028     		cmp	r0, #0
 1606 0018 06D1     		bne	.L96
 581:../source/main.c **** 	{
 582:../source/main.c **** 		GPS_recBuf[GPS_bufPtr] = uartData; //put new byte to buffer
 1607              		.loc 1 582 0
 1608 001a 1088     		ldrh	r0, [r2]
 1609 001c 0A4C     		ldr	r4, .L98+12
 1610 001e 2354     		strb	r3, [r4, r0]
 583:../source/main.c **** 		GPS_bufPtr++;
 1611              		.loc 1 583 0
 1612 0020 1388     		ldrh	r3, [r2]
 1613              	.LVL152:
 1614 0022 0133     		adds	r3, r3, #1
 1615 0024 9BB2     		uxth	r3, r3
 1616 0026 1380     		strh	r3, [r2]
 1617              	.LVL153:
 1618              	.L96:
 584:../source/main.c **** 	}
 585:../source/main.c **** 
 586:../source/main.c **** 	/*
 587:../source/main.c **** 	 * When buffer is almost full, put strReady high and stop filling it
 588:../source/main.c **** 	 */
 589:../source/main.c **** 	if (GPS_bufPtr > 499)
 1619              		.loc 1 589 0
 1620 0028 F423     		movs	r3, #244
 1621 002a 1288     		ldrh	r2, [r2]
 1622 002c FF33     		adds	r3, r3, #255
 1623 002e 9A42     		cmp	r2, r3
 1624 0030 02D9     		bls	.L95
 590:../source/main.c **** 	{
 591:../source/main.c **** 		GPS_strReady = 1;
 1625              		.loc 1 591 0
 1626 0032 F33B     		subs	r3, r3, #243
 1627 0034 FF3B     		subs	r3, r3, #255
 1628 0036 0B70     		strb	r3, [r1]
 1629              	.L95:
 592:../source/main.c **** 	}
 593:../source/main.c **** 
 594:../source/main.c **** }
 1630              		.loc 1 594 0
 1631              		@ sp needed
 1632 0038 10BD     		pop	{r4, pc}
 1633              	.L99:
 1634 003a C046     		.align	2
 1635              	.L98:
 1636 003c 00C00640 		.word	1074184192
 1637 0040 00000000 		.word	.LANCHOR3
 1638 0044 00000000 		.word	.LANCHOR10
 1639 0048 00000000 		.word	GPS_recBuf
 1640              		.cfi_endproc
 1641              	.LFE136:
 1643              		.section	.text.LPUART1_IRQHandler,"ax",%progbits
 1644              		.align	1
 1645              		.global	LPUART1_IRQHandler
 1646              		.syntax unified
 1647              		.code	16
 1648              		.thumb_func
 1649              		.fpu softvfp
 1651              	LPUART1_IRQHandler:
 1652              	.LFB137:
 595:../source/main.c **** 
 596:../source/main.c **** void LPUART1_IRQHandler()
 597:../source/main.c **** {
 1653              		.loc 1 597 0
 1654              		.cfi_startproc
 1655              		@ args = 0, pretend = 0, frame = 0
 1656              		@ frame_needed = 0, uses_anonymous_args = 0
 1657              		@ link register save eliminated.
 1658              	.LBB226:
 1659              	.LBB227:
 1660              		.loc 6 233 0
 1661 0000 1022     		movs	r2, #16
 1662              	.LBE227:
 1663              	.LBE226:
 598:../source/main.c **** 
 599:../source/main.c **** 	uint8_t uartData = LPUART1->DATA;
 1664              		.loc 1 599 0
 1665 0002 0A4B     		ldr	r3, .L102
 600:../source/main.c **** 	GPIO_PortToggle(GPIOA, 1 << 4u);
 601:../source/main.c **** 
 602:../source/main.c **** 	PC_recBuf[PC_bufPtr] = uartData;
 1666              		.loc 1 602 0
 1667 0004 0A48     		ldr	r0, .L102+4
 599:../source/main.c **** 	GPIO_PortToggle(GPIOA, 1 << 4u);
 1668              		.loc 1 599 0
 1669 0006 D968     		ldr	r1, [r3, #12]
 1670              	.LVL154:
 1671              	.LBB229:
 1672              	.LBB228:
 1673              		.loc 6 233 0
 1674 0008 0A4B     		ldr	r3, .L102+8
 1675 000a DA60     		str	r2, [r3, #12]
 1676              	.LVL155:
 1677              	.LBE228:
 1678              	.LBE229:
 1679              		.loc 1 602 0
 1680 000c 0A4A     		ldr	r2, .L102+12
 1681 000e 1388     		ldrh	r3, [r2]
 1682 0010 C154     		strb	r1, [r0, r3]
 603:../source/main.c **** 	PC_bufPtr++;
 1683              		.loc 1 603 0
 1684 0012 1388     		ldrh	r3, [r2]
 604:../source/main.c **** 
 605:../source/main.c **** 	if (uartData == 0x0a)
 1685              		.loc 1 605 0
 1686 0014 C9B2     		uxtb	r1, r1
 603:../source/main.c **** 	PC_bufPtr++;
 1687              		.loc 1 603 0
 1688 0016 0133     		adds	r3, r3, #1
 1689 0018 9BB2     		uxth	r3, r3
 1690 001a 1380     		strh	r3, [r2]
 1691              		.loc 1 605 0
 1692 001c 0A29     		cmp	r1, #10
 1693 001e 04D1     		bne	.L100
 606:../source/main.c **** 	{
 607:../source/main.c **** 		PC_strReady = 1;
 1694              		.loc 1 607 0
 1695 0020 064B     		ldr	r3, .L102+16
 1696 0022 0939     		subs	r1, r1, #9
 1697              	.LVL156:
 1698 0024 1970     		strb	r1, [r3]
 608:../source/main.c **** 		PC_bufPtr = 0;
 1699              		.loc 1 608 0
 1700 0026 0023     		movs	r3, #0
 1701 0028 1380     		strh	r3, [r2]
 1702              	.LVL157:
 1703              	.L100:
 609:../source/main.c **** 
 610:../source/main.c **** 	}
 611:../source/main.c **** }
 1704              		.loc 1 611 0
 1705              		@ sp needed
 1706 002a 7047     		bx	lr
 1707              	.L103:
 1708              		.align	2
 1709              	.L102:
 1710 002c 00500540 		.word	1074089984
 1711 0030 00000000 		.word	PC_recBuf
 1712 0034 00F00F40 		.word	1074786304
 1713 0038 00000000 		.word	.LANCHOR6
 1714 003c 00000000 		.word	.LANCHOR4
 1715              		.cfi_endproc
 1716              	.LFE137:
 1718              		.comm	ms_ticks,4,4
 1719              		.global	moduleResponseTimeout
 1720              		.comm	parsedLon,15,1
 1721              		.comm	parsedLat,15,1
 1722              		.global	streamGps
 1723              		.global	GPS_strReady
 1724              		.global	GPS_bufPtr
 1725              		.comm	GPS_recBuf,600,1
 1726              		.global	PC_strReady
 1727              		.global	PC_bufPtr
 1728              		.comm	NB_recBuf,500,1
 1729              		.global	NB_bufPtr
 1730              		.global	NB_strReady
 1731              		.global	wake
 1732              		.comm	uart_config,8,4
 1733              		.comm	smc_power_mode_vlls_config,2,1
 1734              		.comm	lptmr_config,7,1
 1735              		.section	.rodata
 1736              		.set	.LANCHOR1,. + 0
 1737              	.LC12:
 1738 0000 36353030 		.ascii	"6500.53\000"
 1738      2E353300 
 1739 0008 000000   		.space	3
 1740              	.LC14:
 1741 000b 30323533 		.ascii	"02534.554\000"
 1741      342E3535 
 1741      3400
 1742 0015 00       		.space	1
 1743              	.LC30:
 1744 0016 36353030 		.ascii	"6500.02359\000"
 1744      2E303233 
 1744      353900
 1745 0021 00       		.space	1
 1746              		.section	.bss.GPS_bufPtr,"aw",%nobits
 1747              		.align	1
 1748              		.set	.LANCHOR10,. + 0
 1751              	GPS_bufPtr:
 1752 0000 0000     		.space	2
 1753              		.section	.bss.GPS_strReady,"aw",%nobits
 1754              		.set	.LANCHOR3,. + 0
 1757              	GPS_strReady:
 1758 0000 00       		.space	1
 1759              		.section	.bss.NB_bufPtr,"aw",%nobits
 1760              		.align	1
 1761              		.set	.LANCHOR9,. + 0
 1764              	NB_bufPtr:
 1765 0000 0000     		.space	2
 1766              		.section	.bss.NB_strReady,"aw",%nobits
 1767              		.set	.LANCHOR7,. + 0
 1770              	NB_strReady:
 1771 0000 00       		.space	1
 1772              		.section	.bss.PC_bufPtr,"aw",%nobits
 1773              		.align	1
 1774              		.set	.LANCHOR6,. + 0
 1777              	PC_bufPtr:
 1778 0000 0000     		.space	2
 1779              		.section	.bss.PC_recBuf,"aw",%nobits
 1782              	PC_recBuf:
 1783 0000 00000000 		.space	500
 1783      00000000 
 1783      00000000 
 1783      00000000 
 1783      00000000 
 1784              		.section	.bss.PC_strReady,"aw",%nobits
 1785              		.set	.LANCHOR4,. + 0
 1788              	PC_strReady:
 1789 0000 00       		.space	1
 1790              		.section	.bss.streamGps,"aw",%nobits
 1791              		.set	.LANCHOR5,. + 0
 1794              	streamGps:
 1795 0000 00       		.space	1
 1796              		.section	.data.moduleResponseTimeout,"aw",%progbits
 1797              		.align	2
 1798              		.set	.LANCHOR8,. + 0
 1801              	moduleResponseTimeout:
 1802 0000 D0070000 		.word	2000
 1803              		.section	.data.wake,"aw",%progbits
 1804              		.set	.LANCHOR2,. + 0
 1807              	wake:
 1808 0000 03       		.byte	3
 1809              		.section	.rodata.LED_configOutput.8156,"a",%progbits
 1810              		.set	.LANCHOR0,. + 0
 1813              	LED_configOutput.8156:
 1814 0000 01       		.byte	1
 1815 0001 01       		.byte	1
 1816              		.section	.rodata.main.str1.1,"aMS",%progbits,1
 1817              	.LC5:
 1818 0000 6C707469 		.ascii	"lptimer int flag: %lx\015\012\000"
 1818      6D657220 
 1818      696E7420 
 1818      666C6167 
 1818      3A20256C 
 1819              	.LC8:
 1820 0018 5265696E 		.ascii	"Reindeer IoT has started\015\012Command \"iot\" to "
 1820      64656572 
 1820      20496F54 
 1820      20686173 
 1820      20737461 
 1821 0043 73746172 		.ascii	"start executing reindeer track cycle\015\012Command"
 1821      74206578 
 1821      65637574 
 1821      696E6720 
 1821      7265696E 
 1822 0070 20226770 		.ascii	" \"gpsinfo=1\" or \"gpsinfo=0\" to switch GPS data "
 1822      73696E66 
 1822      6F3D3122 
 1822      206F7220 
 1822      22677073 
 1823 009f 6F6E2F6F 		.ascii	"on/off\015\012\000"
 1823      66660D0A 
 1823      00
 1824              	.LC10:
 1825 00a8 4F722065 		.ascii	"Or enter normal AT commands here for SARA-N2\015\012"
 1825      6E746572 
 1825      206E6F72 
 1825      6D616C20 
 1825      41542063 
 1826 00d6 4D6F6475 		.ascii	"Modules powered on and booting now!\015\012\000"
 1826      6C657320 
 1826      706F7765 
 1826      72656420 
 1826      6F6E2061 
 1827              	.LC15:
 1828 00fc 31313131 		.ascii	"11111\000"
 1828      3100
 1829              	.LC17:
 1830 0102 66616C73 		.ascii	"false\000"
 1830      6500
 1831              	.LC20:
 1832 0108 576F6B65 		.ascii	"Woken by ACCEL, reindeer is !!!ALIVE!!!\015\012\000"
 1832      6E206279 
 1832      20414343 
 1832      454C2C20 
 1832      7265696E 
 1833              	.LC22:
 1834 0132 77616B65 		.ascii	"wake was 0 going to sleep\015\012\000"
 1834      20776173 
 1834      20302067 
 1834      6F696E67 
 1834      20746F20 
 1835              	.LC24:
 1836 014e 74727565 		.ascii	"true\000"
 1836      00
 1837              	.LC28:
 1838 0153 0D0A00   		.ascii	"\015\012\000"
 1839              	.LC34:
 1840 0156 696F7400 		.ascii	"iot\000"
 1841              	.LC37:
 1842 015a 53746172 		.ascii	"Starting Reindeer IoT cycle\015\012\000"
 1842      74696E67 
 1842      20526569 
 1842      6E646565 
 1842      7220496F 
 1843              	.LC39:
 1844 0178 67707369 		.ascii	"gpsinfo=1\000"
 1844      6E666F3D 
 1844      3100
 1845              	.LC42:
 1846 0182 67707369 		.ascii	"gpsinfo=0\000"
 1846      6E666F3D 
 1846      3000
 1847              	.LC44:
 1848 018c 72666F66 		.ascii	"rfoff\000"
 1848      6600
 1849              	.LC46:
 1850 0192 72666F6E 		.ascii	"rfon\000"
 1850      00
 1851              	.LC48:
 1852 0197 B56200   		.ascii	"\265b\000"
 1853              	.LC50:
 1854 019a 73656E64 		.ascii	"send to gps\015\012\000"
 1854      20746F20 
 1854      6770730D 
 1854      0A00
 1855              	.LC60:
 1856 01a8 466F756E 		.ascii	"Found UBX response\015\012\000"
 1856      64205542 
 1856      58207265 
 1856      73706F6E 
 1856      73650D0A 
 1857              	.LC63:
 1858 01bd 526F6765 		.ascii	"Roger include main.c\015\012\000"
 1858      7220696E 
 1858      636C7564 
 1858      65206D61 
 1858      696E2E63 
 1859              	.LC65:
 1860 01d4 4F4B00   		.ascii	"OK\000"
 1861              	.LC67:
 1862 01d7 00       		.ascii	"\000"
 1863              	.LC69:
 1864 01d8 4346554E 		.ascii	"CFUN=0\000"
 1864      3D3000
 1865              	.LC31:
 1866 01df 30323533 		.ascii	"02530.56951\000"
 1866      302E3536 
 1866      39353100 
 1867              		.text
 1868              	.Letext0:
 1869              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1870              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1871              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1872              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1873              		.file 12 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1874              		.file 13 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1875              		.file 14 "../CMSIS/MKL17Z4.h"
 1876              		.file 15 "../CMSIS/system_MKL17Z4.h"
 1877              		.file 16 "../drivers/fsl_common.h"
 1878              		.file 17 "../board/clock_config.h"
 1879              		.file 18 "../drivers/fsl_uart.h"
 1880              		.file 19 "../source/at_func.h"
 1881              		.file 20 "../drivers/fsl_lpuart.h"
 1882              		.file 21 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 1883              		.file 22 "../source/gps_func.h"
 1884              		.file 23 "../source/nbiot_func.h"
 1885              		.file 24 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/string.h"
 1886              		.file 25 "<built-in>"
 1887              		.file 26 "../board/pin_mux.h"
 1888              		.file 27 "../source/i2c_func.h"
 1889              		.file 28 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdio.h"
 1890              		.file 29 "../source/acc_func.h"
 1891              		.file 30 "../source/timing.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc9RGw8F.s:16     .text.initTimer:0000000000000000 $t
     /tmp/cc9RGw8F.s:23     .text.initTimer:0000000000000000 initTimer
     /tmp/cc9RGw8F.s:110    .text.initTimer:0000000000000034 $d
                            *COM*:0000000000000007 lptmr_config
     /tmp/cc9RGw8F.s:118    .text.initUART:0000000000000000 $t
     /tmp/cc9RGw8F.s:125    .text.initUART:0000000000000000 initUART
     /tmp/cc9RGw8F.s:308    .text.initUART:0000000000000094 $d
                            *COM*:0000000000000008 uart_config
     /tmp/cc9RGw8F.s:318    .text.NB_send:0000000000000000 $t
     /tmp/cc9RGw8F.s:325    .text.NB_send:0000000000000000 NB_send
     /tmp/cc9RGw8F.s:377    .text.NB_send:0000000000000024 $d
     /tmp/cc9RGw8F.s:382    .text.GPS_send:0000000000000000 $t
     /tmp/cc9RGw8F.s:389    .text.GPS_send:0000000000000000 GPS_send
     /tmp/cc9RGw8F.s:445    .text.GPS_send:0000000000000028 $d
     /tmp/cc9RGw8F.s:450    .text.PCprint:0000000000000000 $t
     /tmp/cc9RGw8F.s:457    .text.PCprint:0000000000000000 PCprint
     /tmp/cc9RGw8F.s:505    .text.PCprint:0000000000000024 $d
     /tmp/cc9RGw8F.s:511    .text.startup.main:0000000000000000 $t
     /tmp/cc9RGw8F.s:518    .text.startup.main:0000000000000000 main
     /tmp/cc9RGw8F.s:1250   .text.startup.main:0000000000000344 $d
                            *COM*:0000000000000002 smc_power_mode_vlls_config
                            *COM*:0000000000000258 GPS_recBuf
     /tmp/cc9RGw8F.s:1782   .bss.PC_recBuf:0000000000000000 PC_recBuf
                            *COM*:00000000000001f4 NB_recBuf
                            *COM*:000000000000000f parsedLat
                            *COM*:000000000000000f parsedLon
     /tmp/cc9RGw8F.s:1307   .text.LLWU_IRQHandler:0000000000000000 $t
     /tmp/cc9RGw8F.s:1314   .text.LLWU_IRQHandler:0000000000000000 LLWU_IRQHandler
     /tmp/cc9RGw8F.s:1454   .text.LLWU_IRQHandler:0000000000000050 $d
     /tmp/cc9RGw8F.s:1462   .text.LPTMR0_IRQHandler:0000000000000000 $t
     /tmp/cc9RGw8F.s:1469   .text.LPTMR0_IRQHandler:0000000000000000 LPTMR0_IRQHandler
     /tmp/cc9RGw8F.s:1493   .text.LPTMR0_IRQHandler:0000000000000014 $d
     /tmp/cc9RGw8F.s:1498   .text.LPUART0_IRQHandler:0000000000000000 $t
     /tmp/cc9RGw8F.s:1505   .text.LPUART0_IRQHandler:0000000000000000 LPUART0_IRQHandler
     /tmp/cc9RGw8F.s:1562   .text.LPUART0_IRQHandler:0000000000000038 $d
     /tmp/cc9RGw8F.s:1571   .text.UART2_FLEXIO_IRQHandler:0000000000000000 $t
     /tmp/cc9RGw8F.s:1578   .text.UART2_FLEXIO_IRQHandler:0000000000000000 UART2_FLEXIO_IRQHandler
     /tmp/cc9RGw8F.s:1636   .text.UART2_FLEXIO_IRQHandler:000000000000003c $d
     /tmp/cc9RGw8F.s:1644   .text.LPUART1_IRQHandler:0000000000000000 $t
     /tmp/cc9RGw8F.s:1651   .text.LPUART1_IRQHandler:0000000000000000 LPUART1_IRQHandler
     /tmp/cc9RGw8F.s:1710   .text.LPUART1_IRQHandler:000000000000002c $d
                            *COM*:0000000000000004 ms_ticks
     /tmp/cc9RGw8F.s:1801   .data.moduleResponseTimeout:0000000000000000 moduleResponseTimeout
     /tmp/cc9RGw8F.s:1794   .bss.streamGps:0000000000000000 streamGps
     /tmp/cc9RGw8F.s:1757   .bss.GPS_strReady:0000000000000000 GPS_strReady
     /tmp/cc9RGw8F.s:1751   .bss.GPS_bufPtr:0000000000000000 GPS_bufPtr
     /tmp/cc9RGw8F.s:1788   .bss.PC_strReady:0000000000000000 PC_strReady
     /tmp/cc9RGw8F.s:1777   .bss.PC_bufPtr:0000000000000000 PC_bufPtr
     /tmp/cc9RGw8F.s:1764   .bss.NB_bufPtr:0000000000000000 NB_bufPtr
     /tmp/cc9RGw8F.s:1770   .bss.NB_strReady:0000000000000000 NB_strReady
     /tmp/cc9RGw8F.s:1807   .data.wake:0000000000000000 wake
     /tmp/cc9RGw8F.s:1739   .rodata:0000000000000008 $d
     /tmp/cc9RGw8F.s:1747   .bss.GPS_bufPtr:0000000000000000 $d
     /tmp/cc9RGw8F.s:1758   .bss.GPS_strReady:0000000000000000 $d
     /tmp/cc9RGw8F.s:1760   .bss.NB_bufPtr:0000000000000000 $d
     /tmp/cc9RGw8F.s:1771   .bss.NB_strReady:0000000000000000 $d
     /tmp/cc9RGw8F.s:1773   .bss.PC_bufPtr:0000000000000000 $d
     /tmp/cc9RGw8F.s:1783   .bss.PC_recBuf:0000000000000000 $d
     /tmp/cc9RGw8F.s:1789   .bss.PC_strReady:0000000000000000 $d
     /tmp/cc9RGw8F.s:1795   .bss.streamGps:0000000000000000 $d
     /tmp/cc9RGw8F.s:1797   .data.moduleResponseTimeout:0000000000000000 $d
     /tmp/cc9RGw8F.s:1813   .rodata.LED_configOutput.8156:0000000000000000 LED_configOutput.8156

UNDEFINED SYMBOLS
LPTMR_GetDefaultConfig
LPTMR_Init
CLOCK_GetFreq
UART_GetDefaultConfig
LPUART_GetDefaultConfig
LPUART_Init
LPUART_EnableInterrupts
__aeabi_uidiv
BOARD_InitPins
BOARD_BootClockVLPR
CLOCK_GetCoreSysClkFreq
initI2C
GPIO_PinInit
sprintf
configure_acc
acc_init
memcpy
memset
strcpy
SMC_PreEnterStopModes
SMC_SetPowerModeVlls
strstr
assembleMqtt
NB_create_pdp_send
AT_send
strlen
millis
breakIfAtOk
getGPS
calcUbxCrc
printUbxResponseHex
LPUART_ClearStatusFlags
UART_ClearStatusFlags
