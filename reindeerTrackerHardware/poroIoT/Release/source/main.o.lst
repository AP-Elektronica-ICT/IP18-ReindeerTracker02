   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.initTimer,"ax",%progbits
  16              		.align	1
  17              		.global	initTimer
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	initTimer:
  24              	.LFB127:
  25              		.file 1 "../source/main.c"
   1:../source/main.c **** /**
   2:../source/main.c ****  * This is template for main module created by New Kinetis SDK 2.x Project Wizard. Enjoy!
   3:../source/main.c ****  **/
   4:../source/main.c **** 
   5:../source/main.c **** #include "board.h"
   6:../source/main.c **** #include "pin_mux.h"
   7:../source/main.c **** #include "clock_config.h"
   8:../source/main.c **** 
   9:../source/main.c **** #include "fsl_gpio.h"
  10:../source/main.c **** #include "fsl_uart.h"
  11:../source/main.c **** #include "fsl_port.h"
  12:../source/main.c **** #include "fsl_common.h"
  13:../source/main.c **** #include "fsl_i2c.h"
  14:../source/main.c **** #include "fsl_smc.h"
  15:../source/main.c **** #include "fsl_lptmr.h"
  16:../source/main.c **** #include "at_func.h"
  17:../source/main.c **** #include "fsl_lpuart.h"
  18:../source/main.c **** #include "fsl_llwu.h"
  19:../source/main.c **** #include "fsl_clock.h"
  20:../source/main.c **** 
  21:../source/main.c **** #include <stdio.h>
  22:../source/main.c **** #include <stdlib.h>
  23:../source/main.c **** 
  24:../source/main.c **** #include "acc_func.h"
  25:../source/main.c **** #include "i2c_func.h"
  26:../source/main.c **** #include "adc_func.h"
  27:../source/main.c **** #include "fsl_rtc.h"
  28:../source/main.c **** #include "gps_func.h"
  29:../source/main.c **** #include "ubx_func.h"
  30:../source/main.c **** #include "nbiot_func.h"
  31:../source/main.c **** #include "timing.h"
  32:../source/main.c **** 
  33:../source/main.c **** #define RESPONSE_TIMEOUT_NORMAL_VALUE 2000
  34:../source/main.c **** 
  35:../source/main.c **** lptmr_config_t lptmr_config;
  36:../source/main.c **** smc_power_mode_vlls_config_t smc_power_mode_vlls_config;
  37:../source/main.c **** uart_config_t uart_config;
  38:../source/main.c **** 
  39:../source/main.c **** volatile uint8_t wake = 0;
  40:../source/main.c **** volatile uint8_t NB_strReady = 0;
  41:../source/main.c **** volatile uint16_t NB_bufPtr = 0;
  42:../source/main.c **** 
  43:../source/main.c **** char NB_recBuf[500]; 	//buffer for receiving NB IoT module data
  44:../source/main.c **** 
  45:../source/main.c **** static char PC_recBuf[500];	//buffer for receiving from PC terminal
  46:../source/main.c **** volatile uint16_t PC_bufPtr = 0;
  47:../source/main.c **** volatile uint8_t PC_strReady = 0;
  48:../source/main.c **** 
  49:../source/main.c **** char GPS_recBuf[600];	//buffer for receiving from PC terminal
  50:../source/main.c **** volatile uint16_t GPS_bufPtr = 0;
  51:../source/main.c **** volatile uint8_t GPS_strReady = 0;
  52:../source/main.c **** uint8_t streamGps = 0;
  53:../source/main.c **** 
  54:../source/main.c **** char parsedLat[15];
  55:../source/main.c **** char parsedLon[15];
  56:../source/main.c **** 
  57:../source/main.c **** volatile uint32_t moduleResponseTimeout = RESPONSE_TIMEOUT_NORMAL_VALUE; //timeout variable for wai
  58:../source/main.c **** 
  59:../source/main.c **** uint32_t ms_ticks; //millisecond ticks value for the delay_ms function
  60:../source/main.c **** /*
  61:../source/main.c ****  void delay_ms(uint32_t del)
  62:../source/main.c ****  {
  63:../source/main.c ****  for (; del > 0; del--)
  64:../source/main.c ****  {
  65:../source/main.c ****  for(uint32_t t = 0; t<ms_ticks;t++)
  66:../source/main.c ****  {
  67:../source/main.c ****  __asm("nop");
  68:../source/main.c ****  }
  69:../source/main.c ****  }
  70:../source/main.c ****  }
  71:../source/main.c ****  */
  72:../source/main.c **** 
  73:../source/main.c **** void initTimer()
  74:../source/main.c **** {
  26              		.loc 1 74 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 70B5     		push	{r4, r5, r6, lr}
  31              		.cfi_def_cfa_offset 16
  32              		.cfi_offset 4, -16
  33              		.cfi_offset 5, -12
  34              		.cfi_offset 6, -8
  35              		.cfi_offset 14, -4
  75:../source/main.c **** 
  76:../source/main.c **** 	/*
  77:../source/main.c **** 	 * Init dead reindeer timer. LPTIMER interrupt will wake up MCU after a certain time, IF accelerom
  78:../source/main.c **** 	 * has not waked it earlier (and reset the timer)
  79:../source/main.c **** 	 */
  80:../source/main.c **** 	LPTMR_GetDefaultConfig(&lptmr_config);
  36              		.loc 1 80 0
  37 0002 084C     		ldr	r4, .L2
  81:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  82:../source/main.c **** 	lptmr_config.value = kLPTMR_Prescale_Glitch_0;
  83:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  84:../source/main.c **** 	LPTMR_Init(LPTMR0, &lptmr_config);
  38              		.loc 1 84 0
  39 0004 084D     		ldr	r5, .L2+4
  80:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  40              		.loc 1 80 0
  41 0006 2000     		movs	r0, r4
  42 0008 FFF7FEFF 		bl	LPTMR_GetDefaultConfig
  43              	.LVL0:
  81:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  44              		.loc 1 81 0
  45 000c 0123     		movs	r3, #1
  82:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  46              		.loc 1 82 0
  47 000e 0022     		movs	r2, #0
  48              		.loc 1 84 0
  49 0010 2800     		movs	r0, r5
  50 0012 2100     		movs	r1, r4
  81:../source/main.c **** 	lptmr_config.bypassPrescaler = true;
  51              		.loc 1 81 0
  52 0014 2371     		strb	r3, [r4, #4]
  83:../source/main.c **** 	LPTMR_Init(LPTMR0, &lptmr_config);
  53              		.loc 1 83 0
  54 0016 6371     		strb	r3, [r4, #5]
  82:../source/main.c **** 	lptmr_config.prescalerClockSource = kLPTMR_PrescalerClock_1;
  55              		.loc 1 82 0
  56 0018 A271     		strb	r2, [r4, #6]
  57              		.loc 1 84 0
  58 001a FFF7FEFF 		bl	LPTMR_Init
  59              	.LVL1:
  60              	.LBB58:
  61              	.LBB59:
  62              		.file 2 "../drivers/fsl_lptmr.h"
   1:../drivers/fsl_lptmr.h **** /*
   2:../drivers/fsl_lptmr.h ****  * The Clear BSD License
   3:../drivers/fsl_lptmr.h ****  * Copyright (c) 2016, Freescale Semiconductor, Inc.
   4:../drivers/fsl_lptmr.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_lptmr.h ****  * All rights reserved.
   6:../drivers/fsl_lptmr.h ****  *
   7:../drivers/fsl_lptmr.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_lptmr.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_lptmr.h ****  * that the following conditions are met:
  10:../drivers/fsl_lptmr.h ****  *
  11:../drivers/fsl_lptmr.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_lptmr.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_lptmr.h ****  *
  14:../drivers/fsl_lptmr.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_lptmr.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_lptmr.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_lptmr.h ****  *
  18:../drivers/fsl_lptmr.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_lptmr.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_lptmr.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_lptmr.h ****  *
  22:../drivers/fsl_lptmr.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_lptmr.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_lptmr.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_lptmr.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_lptmr.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_lptmr.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_lptmr.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_lptmr.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_lptmr.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_lptmr.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_lptmr.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_lptmr.h ****  */
  34:../drivers/fsl_lptmr.h **** #ifndef _FSL_LPTMR_H_
  35:../drivers/fsl_lptmr.h **** #define _FSL_LPTMR_H_
  36:../drivers/fsl_lptmr.h **** 
  37:../drivers/fsl_lptmr.h **** #include "fsl_common.h"
  38:../drivers/fsl_lptmr.h **** 
  39:../drivers/fsl_lptmr.h **** /*!
  40:../drivers/fsl_lptmr.h ****  * @addtogroup lptmr
  41:../drivers/fsl_lptmr.h ****  * @{
  42:../drivers/fsl_lptmr.h ****  */
  43:../drivers/fsl_lptmr.h **** 
  44:../drivers/fsl_lptmr.h **** /*******************************************************************************
  45:../drivers/fsl_lptmr.h ****  * Definitions
  46:../drivers/fsl_lptmr.h ****  ******************************************************************************/
  47:../drivers/fsl_lptmr.h **** 
  48:../drivers/fsl_lptmr.h **** /*! @name Driver version */
  49:../drivers/fsl_lptmr.h **** /*@{*/
  50:../drivers/fsl_lptmr.h **** #define FSL_LPTMR_DRIVER_VERSION (MAKE_VERSION(2, 0, 1)) /*!< Version 2.0.1 */
  51:../drivers/fsl_lptmr.h **** /*@}*/
  52:../drivers/fsl_lptmr.h **** 
  53:../drivers/fsl_lptmr.h **** /*! @brief LPTMR pin selection used in pulse counter mode.*/
  54:../drivers/fsl_lptmr.h **** typedef enum _lptmr_pin_select
  55:../drivers/fsl_lptmr.h **** {
  56:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_0 = 0x0U, /*!< Pulse counter input 0 is selected */
  57:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_1 = 0x1U, /*!< Pulse counter input 1 is selected */
  58:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_2 = 0x2U, /*!< Pulse counter input 2 is selected */
  59:../drivers/fsl_lptmr.h ****     kLPTMR_PinSelectInput_3 = 0x3U  /*!< Pulse counter input 3 is selected */
  60:../drivers/fsl_lptmr.h **** } lptmr_pin_select_t;
  61:../drivers/fsl_lptmr.h **** 
  62:../drivers/fsl_lptmr.h **** /*! @brief LPTMR pin polarity used in pulse counter mode.*/
  63:../drivers/fsl_lptmr.h **** typedef enum _lptmr_pin_polarity
  64:../drivers/fsl_lptmr.h **** {
  65:../drivers/fsl_lptmr.h ****     kLPTMR_PinPolarityActiveHigh = 0x0U, /*!< Pulse Counter input source is active-high */
  66:../drivers/fsl_lptmr.h ****     kLPTMR_PinPolarityActiveLow = 0x1U   /*!< Pulse Counter input source is active-low */
  67:../drivers/fsl_lptmr.h **** } lptmr_pin_polarity_t;
  68:../drivers/fsl_lptmr.h **** 
  69:../drivers/fsl_lptmr.h **** /*! @brief LPTMR timer mode selection.*/
  70:../drivers/fsl_lptmr.h **** typedef enum _lptmr_timer_mode
  71:../drivers/fsl_lptmr.h **** {
  72:../drivers/fsl_lptmr.h ****     kLPTMR_TimerModeTimeCounter = 0x0U, /*!< Time Counter mode */
  73:../drivers/fsl_lptmr.h ****     kLPTMR_TimerModePulseCounter = 0x1U /*!< Pulse Counter mode */
  74:../drivers/fsl_lptmr.h **** } lptmr_timer_mode_t;
  75:../drivers/fsl_lptmr.h **** 
  76:../drivers/fsl_lptmr.h **** /*! @brief LPTMR prescaler/glitch filter values*/
  77:../drivers/fsl_lptmr.h **** typedef enum _lptmr_prescaler_glitch_value
  78:../drivers/fsl_lptmr.h **** {
  79:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_0 = 0x0U,  /*!< Prescaler divide 2, glitch filter does not support this 
  80:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_1 = 0x1U,  /*!< Prescaler divide 4, glitch filter 2 */
  81:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_2 = 0x2U,  /*!< Prescaler divide 8, glitch filter 4 */
  82:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_3 = 0x3U,  /*!< Prescaler divide 16, glitch filter 8 */
  83:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_4 = 0x4U,  /*!< Prescaler divide 32, glitch filter 16 */
  84:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_5 = 0x5U,  /*!< Prescaler divide 64, glitch filter 32 */
  85:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_6 = 0x6U,  /*!< Prescaler divide 128, glitch filter 64 */
  86:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_7 = 0x7U,  /*!< Prescaler divide 256, glitch filter 128 */
  87:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_8 = 0x8U,  /*!< Prescaler divide 512, glitch filter 256 */
  88:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_9 = 0x9U,  /*!< Prescaler divide 1024, glitch filter 512*/
  89:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_10 = 0xAU, /*!< Prescaler divide 2048 glitch filter 1024 */
  90:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_11 = 0xBU, /*!< Prescaler divide 4096, glitch filter 2048 */
  91:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_12 = 0xCU, /*!< Prescaler divide 8192, glitch filter 4096 */
  92:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_13 = 0xDU, /*!< Prescaler divide 16384, glitch filter 8192 */
  93:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_14 = 0xEU, /*!< Prescaler divide 32768, glitch filter 16384 */
  94:../drivers/fsl_lptmr.h ****     kLPTMR_Prescale_Glitch_15 = 0xFU  /*!< Prescaler divide 65536, glitch filter 32768 */
  95:../drivers/fsl_lptmr.h **** } lptmr_prescaler_glitch_value_t;
  96:../drivers/fsl_lptmr.h **** 
  97:../drivers/fsl_lptmr.h **** /*!
  98:../drivers/fsl_lptmr.h ****  * @brief LPTMR prescaler/glitch filter clock select.
  99:../drivers/fsl_lptmr.h ****  * @note Clock connections are SoC-specific
 100:../drivers/fsl_lptmr.h ****  */
 101:../drivers/fsl_lptmr.h **** typedef enum _lptmr_prescaler_clock_select
 102:../drivers/fsl_lptmr.h **** {
 103:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_0 = 0x0U, /*!< Prescaler/glitch filter clock 0 selected. */
 104:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_1 = 0x1U, /*!< Prescaler/glitch filter clock 1 selected. */
 105:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_2 = 0x2U, /*!< Prescaler/glitch filter clock 2 selected. */
 106:../drivers/fsl_lptmr.h ****     kLPTMR_PrescalerClock_3 = 0x3U, /*!< Prescaler/glitch filter clock 3 selected. */
 107:../drivers/fsl_lptmr.h **** } lptmr_prescaler_clock_select_t;
 108:../drivers/fsl_lptmr.h **** 
 109:../drivers/fsl_lptmr.h **** /*! @brief List of the LPTMR interrupts */
 110:../drivers/fsl_lptmr.h **** typedef enum _lptmr_interrupt_enable
 111:../drivers/fsl_lptmr.h **** {
 112:../drivers/fsl_lptmr.h ****     kLPTMR_TimerInterruptEnable = LPTMR_CSR_TIE_MASK, /*!< Timer interrupt enable */
 113:../drivers/fsl_lptmr.h **** } lptmr_interrupt_enable_t;
 114:../drivers/fsl_lptmr.h **** 
 115:../drivers/fsl_lptmr.h **** /*! @brief List of the LPTMR status flags */
 116:../drivers/fsl_lptmr.h **** typedef enum _lptmr_status_flags
 117:../drivers/fsl_lptmr.h **** {
 118:../drivers/fsl_lptmr.h ****     kLPTMR_TimerCompareFlag = LPTMR_CSR_TCF_MASK, /*!< Timer compare flag */
 119:../drivers/fsl_lptmr.h **** } lptmr_status_flags_t;
 120:../drivers/fsl_lptmr.h **** 
 121:../drivers/fsl_lptmr.h **** /*!
 122:../drivers/fsl_lptmr.h ****  * @brief LPTMR config structure
 123:../drivers/fsl_lptmr.h ****  *
 124:../drivers/fsl_lptmr.h ****  * This structure holds the configuration settings for the LPTMR peripheral. To initialize this
 125:../drivers/fsl_lptmr.h ****  * structure to reasonable defaults, call the LPTMR_GetDefaultConfig() function and pass a
 126:../drivers/fsl_lptmr.h ****  * pointer to your configuration structure instance.
 127:../drivers/fsl_lptmr.h ****  *
 128:../drivers/fsl_lptmr.h ****  * The configuration struct can be made constant so it resides in flash.
 129:../drivers/fsl_lptmr.h ****  */
 130:../drivers/fsl_lptmr.h **** typedef struct _lptmr_config
 131:../drivers/fsl_lptmr.h **** {
 132:../drivers/fsl_lptmr.h ****     lptmr_timer_mode_t timerMode;     /*!< Time counter mode or pulse counter mode */
 133:../drivers/fsl_lptmr.h ****     lptmr_pin_select_t pinSelect;     /*!< LPTMR pulse input pin select; used only in pulse counter
 134:../drivers/fsl_lptmr.h ****     lptmr_pin_polarity_t pinPolarity; /*!< LPTMR pulse input pin polarity; used only in pulse count
 135:../drivers/fsl_lptmr.h ****     bool enableFreeRunning;           /*!< True: enable free running, counter is reset on overflow
 136:../drivers/fsl_lptmr.h ****                                            False: counter is reset when the compare flag is set */
 137:../drivers/fsl_lptmr.h ****     bool bypassPrescaler;             /*!< True: bypass prescaler; false: use clock from prescaler 
 138:../drivers/fsl_lptmr.h ****     lptmr_prescaler_clock_select_t prescalerClockSource; /*!< LPTMR clock source */
 139:../drivers/fsl_lptmr.h ****     lptmr_prescaler_glitch_value_t value;                /*!< Prescaler or glitch filter value */
 140:../drivers/fsl_lptmr.h **** } lptmr_config_t;
 141:../drivers/fsl_lptmr.h **** 
 142:../drivers/fsl_lptmr.h **** /*******************************************************************************
 143:../drivers/fsl_lptmr.h ****  * API
 144:../drivers/fsl_lptmr.h ****  ******************************************************************************/
 145:../drivers/fsl_lptmr.h **** 
 146:../drivers/fsl_lptmr.h **** #if defined(__cplusplus)
 147:../drivers/fsl_lptmr.h **** extern "C" {
 148:../drivers/fsl_lptmr.h **** #endif
 149:../drivers/fsl_lptmr.h **** 
 150:../drivers/fsl_lptmr.h **** /*!
 151:../drivers/fsl_lptmr.h ****  * @name Initialization and deinitialization
 152:../drivers/fsl_lptmr.h ****  * @{
 153:../drivers/fsl_lptmr.h ****  */
 154:../drivers/fsl_lptmr.h **** 
 155:../drivers/fsl_lptmr.h **** /*!
 156:../drivers/fsl_lptmr.h ****  * @brief Ungates the LPTMR clock and configures the peripheral for a basic operation.
 157:../drivers/fsl_lptmr.h ****  *
 158:../drivers/fsl_lptmr.h ****  * @note This API should be called at the beginning of the application using the LPTMR driver.
 159:../drivers/fsl_lptmr.h ****  *
 160:../drivers/fsl_lptmr.h ****  * @param base   LPTMR peripheral base address
 161:../drivers/fsl_lptmr.h ****  * @param config A pointer to the LPTMR configuration structure.
 162:../drivers/fsl_lptmr.h ****  */
 163:../drivers/fsl_lptmr.h **** void LPTMR_Init(LPTMR_Type *base, const lptmr_config_t *config);
 164:../drivers/fsl_lptmr.h **** 
 165:../drivers/fsl_lptmr.h **** /*!
 166:../drivers/fsl_lptmr.h ****  * @brief Gates the LPTMR clock.
 167:../drivers/fsl_lptmr.h ****  *
 168:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 169:../drivers/fsl_lptmr.h ****  */
 170:../drivers/fsl_lptmr.h **** void LPTMR_Deinit(LPTMR_Type *base);
 171:../drivers/fsl_lptmr.h **** 
 172:../drivers/fsl_lptmr.h **** /*!
 173:../drivers/fsl_lptmr.h ****  * @brief Fills in the LPTMR configuration structure with default settings.
 174:../drivers/fsl_lptmr.h ****  *
 175:../drivers/fsl_lptmr.h ****  * The default values are as follows.
 176:../drivers/fsl_lptmr.h ****  * @code
 177:../drivers/fsl_lptmr.h ****  *    config->timerMode = kLPTMR_TimerModeTimeCounter;
 178:../drivers/fsl_lptmr.h ****  *    config->pinSelect = kLPTMR_PinSelectInput_0;
 179:../drivers/fsl_lptmr.h ****  *    config->pinPolarity = kLPTMR_PinPolarityActiveHigh;
 180:../drivers/fsl_lptmr.h ****  *    config->enableFreeRunning = false;
 181:../drivers/fsl_lptmr.h ****  *    config->bypassPrescaler = true;
 182:../drivers/fsl_lptmr.h ****  *    config->prescalerClockSource = kLPTMR_PrescalerClock_1;
 183:../drivers/fsl_lptmr.h ****  *    config->value = kLPTMR_Prescale_Glitch_0;
 184:../drivers/fsl_lptmr.h ****  * @endcode
 185:../drivers/fsl_lptmr.h ****  * @param config A pointer to the LPTMR configuration structure.
 186:../drivers/fsl_lptmr.h ****  */
 187:../drivers/fsl_lptmr.h **** void LPTMR_GetDefaultConfig(lptmr_config_t *config);
 188:../drivers/fsl_lptmr.h **** 
 189:../drivers/fsl_lptmr.h **** /*! @}*/
 190:../drivers/fsl_lptmr.h **** 
 191:../drivers/fsl_lptmr.h **** /*!
 192:../drivers/fsl_lptmr.h ****  * @name Interrupt Interface
 193:../drivers/fsl_lptmr.h ****  * @{
 194:../drivers/fsl_lptmr.h ****  */
 195:../drivers/fsl_lptmr.h **** 
 196:../drivers/fsl_lptmr.h **** /*!
 197:../drivers/fsl_lptmr.h ****  * @brief Enables the selected LPTMR interrupts.
 198:../drivers/fsl_lptmr.h ****  *
 199:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 200:../drivers/fsl_lptmr.h ****  * @param mask The interrupts to enable. This is a logical OR of members of the
 201:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_interrupt_enable_t
 202:../drivers/fsl_lptmr.h ****  */
 203:../drivers/fsl_lptmr.h **** static inline void LPTMR_EnableInterrupts(LPTMR_Type *base, uint32_t mask)
 204:../drivers/fsl_lptmr.h **** {
 205:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 206:../drivers/fsl_lptmr.h **** 
 207:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit so that we don't clear this w1c bit when writing back */
 208:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 209:../drivers/fsl_lptmr.h ****     reg |= mask;
 210:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 211:../drivers/fsl_lptmr.h **** }
 212:../drivers/fsl_lptmr.h **** 
 213:../drivers/fsl_lptmr.h **** /*!
 214:../drivers/fsl_lptmr.h ****  * @brief Disables the selected LPTMR interrupts.
 215:../drivers/fsl_lptmr.h ****  *
 216:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 217:../drivers/fsl_lptmr.h ****  * @param mask The interrupts to disable. This is a logical OR of members of the
 218:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_interrupt_enable_t.
 219:../drivers/fsl_lptmr.h ****  */
 220:../drivers/fsl_lptmr.h **** static inline void LPTMR_DisableInterrupts(LPTMR_Type *base, uint32_t mask)
 221:../drivers/fsl_lptmr.h **** {
 222:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 223:../drivers/fsl_lptmr.h **** 
 224:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit so that we don't clear this w1c bit when writing back */
 225:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 226:../drivers/fsl_lptmr.h ****     reg &= ~mask;
 227:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 228:../drivers/fsl_lptmr.h **** }
 229:../drivers/fsl_lptmr.h **** 
 230:../drivers/fsl_lptmr.h **** /*!
 231:../drivers/fsl_lptmr.h ****  * @brief Gets the enabled LPTMR interrupts.
 232:../drivers/fsl_lptmr.h ****  *
 233:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 234:../drivers/fsl_lptmr.h ****  *
 235:../drivers/fsl_lptmr.h ****  * @return The enabled interrupts. This is the logical OR of members of the
 236:../drivers/fsl_lptmr.h ****  *         enumeration ::lptmr_interrupt_enable_t
 237:../drivers/fsl_lptmr.h ****  */
 238:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetEnabledInterrupts(LPTMR_Type *base)
 239:../drivers/fsl_lptmr.h **** {
 240:../drivers/fsl_lptmr.h ****     return (base->CSR & LPTMR_CSR_TIE_MASK);
 241:../drivers/fsl_lptmr.h **** }
 242:../drivers/fsl_lptmr.h **** 
 243:../drivers/fsl_lptmr.h **** /*! @}*/
 244:../drivers/fsl_lptmr.h **** 
 245:../drivers/fsl_lptmr.h **** #if defined(FSL_FEATURE_LPTMR_HAS_CSR_TDRE) && (FSL_FEATURE_LPTMR_HAS_CSR_TDRE)
 246:../drivers/fsl_lptmr.h **** /*!
 247:../drivers/fsl_lptmr.h ****  * @brief Enable or disable timer DMA request
 248:../drivers/fsl_lptmr.h ****  *
 249:../drivers/fsl_lptmr.h ****  * @param base base LPTMR peripheral base address
 250:../drivers/fsl_lptmr.h ****  * @param enable Switcher of timer DMA feature. "true" means to enable, "false" means to disable.
 251:../drivers/fsl_lptmr.h ****  */
 252:../drivers/fsl_lptmr.h **** static inline void LPTMR_EnableTimerDMA(LPTMR_Type *base, bool enable)
 253:../drivers/fsl_lptmr.h **** {
 254:../drivers/fsl_lptmr.h ****     if(enable)
 255:../drivers/fsl_lptmr.h ****     {
 256:../drivers/fsl_lptmr.h ****         base->CSR |= LPTMR_CSR_TDRE_MASK;
 257:../drivers/fsl_lptmr.h ****     }
 258:../drivers/fsl_lptmr.h ****     else
 259:../drivers/fsl_lptmr.h ****     {
 260:../drivers/fsl_lptmr.h ****         base->CSR &= ~(LPTMR_CSR_TDRE_MASK);
 261:../drivers/fsl_lptmr.h ****     }
 262:../drivers/fsl_lptmr.h **** }
 263:../drivers/fsl_lptmr.h **** #endif /* FSL_FEATURE_LPTMR_HAS_CSR_TDRE */
 264:../drivers/fsl_lptmr.h **** 
 265:../drivers/fsl_lptmr.h **** /*!
 266:../drivers/fsl_lptmr.h ****  * @name Status Interface
 267:../drivers/fsl_lptmr.h ****  * @{
 268:../drivers/fsl_lptmr.h ****  */
 269:../drivers/fsl_lptmr.h **** 
 270:../drivers/fsl_lptmr.h **** /*!
 271:../drivers/fsl_lptmr.h ****  * @brief Gets the LPTMR status flags.
 272:../drivers/fsl_lptmr.h ****  *
 273:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 274:../drivers/fsl_lptmr.h ****  *
 275:../drivers/fsl_lptmr.h ****  * @return The status flags. This is the logical OR of members of the
 276:../drivers/fsl_lptmr.h ****  *         enumeration ::lptmr_status_flags_t
 277:../drivers/fsl_lptmr.h ****  */
 278:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetStatusFlags(LPTMR_Type *base)
 279:../drivers/fsl_lptmr.h **** {
 280:../drivers/fsl_lptmr.h ****     return (base->CSR & LPTMR_CSR_TCF_MASK);
 281:../drivers/fsl_lptmr.h **** }
 282:../drivers/fsl_lptmr.h **** 
 283:../drivers/fsl_lptmr.h **** /*!
 284:../drivers/fsl_lptmr.h ****  * @brief  Clears the LPTMR status flags.
 285:../drivers/fsl_lptmr.h ****  *
 286:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 287:../drivers/fsl_lptmr.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
 288:../drivers/fsl_lptmr.h ****  *             enumeration ::lptmr_status_flags_t.
 289:../drivers/fsl_lptmr.h ****  */
 290:../drivers/fsl_lptmr.h **** static inline void LPTMR_ClearStatusFlags(LPTMR_Type *base, uint32_t mask)
 291:../drivers/fsl_lptmr.h **** {
 292:../drivers/fsl_lptmr.h ****     base->CSR |= mask;
 293:../drivers/fsl_lptmr.h **** }
 294:../drivers/fsl_lptmr.h **** 
 295:../drivers/fsl_lptmr.h **** /*! @}*/
 296:../drivers/fsl_lptmr.h **** 
 297:../drivers/fsl_lptmr.h **** /*!
 298:../drivers/fsl_lptmr.h ****  * @name Read and write the timer period
 299:../drivers/fsl_lptmr.h ****  * @{
 300:../drivers/fsl_lptmr.h ****  */
 301:../drivers/fsl_lptmr.h **** 
 302:../drivers/fsl_lptmr.h **** /*!
 303:../drivers/fsl_lptmr.h ****  * @brief Sets the timer period in units of count.
 304:../drivers/fsl_lptmr.h ****  *
 305:../drivers/fsl_lptmr.h ****  * Timers counts from 0 until it equals the count value set here. The count value is written to
 306:../drivers/fsl_lptmr.h ****  * the CMR register.
 307:../drivers/fsl_lptmr.h ****  *
 308:../drivers/fsl_lptmr.h ****  * @note
 309:../drivers/fsl_lptmr.h ****  * 1. The TCF flag is set with the CNR equals the count provided here and then increments.
 310:../drivers/fsl_lptmr.h ****  * 2. Call the utility macros provided in the fsl_common.h to convert to ticks.
 311:../drivers/fsl_lptmr.h ****  *
 312:../drivers/fsl_lptmr.h ****  * @param base  LPTMR peripheral base address
 313:../drivers/fsl_lptmr.h ****  * @param ticks A timer period in units of ticks, which should be equal or greater than 1.
 314:../drivers/fsl_lptmr.h ****  */
 315:../drivers/fsl_lptmr.h **** static inline void LPTMR_SetTimerPeriod(LPTMR_Type *base, uint32_t ticks)
 316:../drivers/fsl_lptmr.h **** {
 317:../drivers/fsl_lptmr.h ****     assert(ticks > 0);
 318:../drivers/fsl_lptmr.h ****     base->CMR = ticks - 1;
  63              		.loc 2 318 0
  64 001e 034B     		ldr	r3, .L2+8
  65              	.LBE59:
  66              	.LBE58:
  85:../source/main.c **** 	LPTMR_SetTimerPeriod(LPTMR0, 5000);  // 3000 for 20hz data rat
  86:../source/main.c **** 
  87:../source/main.c **** }
  67              		.loc 1 87 0
  68              		@ sp needed
  69              	.LBB61:
  70              	.LBB60:
  71              		.loc 2 318 0
  72 0020 AB60     		str	r3, [r5, #8]
  73              	.LVL2:
  74              	.LBE60:
  75              	.LBE61:
  76              		.loc 1 87 0
  77 0022 70BD     		pop	{r4, r5, r6, pc}
  78              	.L3:
  79              		.align	2
  80              	.L2:
  81 0024 00000000 		.word	lptmr_config
  82 0028 00000440 		.word	1074003968
  83 002c 87130000 		.word	4999
  84              		.cfi_endproc
  85              	.LFE127:
  87              		.section	.text.initUART,"ax",%progbits
  88              		.align	1
  89              		.global	initUART
  90              		.syntax unified
  91              		.code	16
  92              		.thumb_func
  93              		.fpu softvfp
  95              	initUART:
  96              	.LFB128:
  88:../source/main.c **** 
  89:../source/main.c **** /*
  90:../source/main.c ****  *
  91:../source/main.c ****  * Init all needed UART buses. LPUART0 for NB-IoT, UART0 for PC, UART2 for GPS
  92:../source/main.c ****  */
  93:../source/main.c **** 
  94:../source/main.c **** void initUART()
  95:../source/main.c **** {
  97              		.loc 1 95 0
  98              		.cfi_startproc
  99              		@ args = 0, pretend = 0, frame = 24
 100              		@ frame_needed = 0, uses_anonymous_args = 0
 101 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 102              		.cfi_def_cfa_offset 20
 103              		.cfi_offset 4, -20
 104              		.cfi_offset 5, -16
 105              		.cfi_offset 6, -12
 106              		.cfi_offset 7, -8
 107              		.cfi_offset 14, -4
 108 0002 87B0     		sub	sp, sp, #28
 109              		.cfi_def_cfa_offset 48
  96:../source/main.c **** 
  97:../source/main.c **** 	lpuart_config_t lpuart_config;
  98:../source/main.c **** 
  99:../source/main.c **** 	SystemCoreClockUpdate();
 110              		.loc 1 99 0
 111 0004 FFF7FEFF 		bl	SystemCoreClockUpdate
 112              	.LVL3:
 100:../source/main.c **** 	uint32_t uartClkSrcFreq = CLOCK_GetFreq(kCLOCK_BusClk); //get MCU clock frequency for setting corr
 113              		.loc 1 100 0
 114 0008 0220     		movs	r0, #2
 115 000a FFF7FEFF 		bl	CLOCK_GetFreq
 116              	.LVL4:
 117 000e 0190     		str	r0, [sp, #4]
 118              	.LVL5:
 101:../source/main.c **** 	uint32_t lpuartClkSrcFreq = CLOCK_GetFreq(BOARD_DEBUG_UART_CLKSRC);
 119              		.loc 1 101 0
 120 0010 0020     		movs	r0, #0
 121              	.LVL6:
 122 0012 FFF7FEFF 		bl	CLOCK_GetFreq
 123              	.LVL7:
 102:../source/main.c **** 
 103:../source/main.c **** 	UART_GetDefaultConfig(&uart_config);
 124              		.loc 1 103 0
 125 0016 254D     		ldr	r5, .L5
 104:../source/main.c **** 	LPUART_GetDefaultConfig(&lpuart_config);
 126              		.loc 1 104 0
 127 0018 03AC     		add	r4, sp, #12
 101:../source/main.c **** 	uint32_t lpuartClkSrcFreq = CLOCK_GetFreq(BOARD_DEBUG_UART_CLKSRC);
 128              		.loc 1 101 0
 129 001a 0090     		str	r0, [sp]
 130              	.LVL8:
 103:../source/main.c **** 	LPUART_GetDefaultConfig(&lpuart_config);
 131              		.loc 1 103 0
 132 001c 2800     		movs	r0, r5
 133              	.LVL9:
 134 001e FFF7FEFF 		bl	UART_GetDefaultConfig
 135              	.LVL10:
 136              		.loc 1 104 0
 137 0022 2000     		movs	r0, r4
 138 0024 FFF7FEFF 		bl	LPUART_GetDefaultConfig
 139              	.LVL11:
 105:../source/main.c **** 	uart_config.baudRate_Bps = 9600;
 140              		.loc 1 105 0
 141 0028 9626     		movs	r6, #150
 106:../source/main.c **** 	uart_config.enableTx = true;
 142              		.loc 1 106 0
 143 002a 0123     		movs	r3, #1
 144              	.LBB78:
 145              	.LBB79:
 146              		.file 3 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * The Clear BSD License
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   5:../drivers/fsl_clock.h ****  * All rights reserved.
   6:../drivers/fsl_clock.h ****  *
   7:../drivers/fsl_clock.h ****  *
   8:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   9:../drivers/fsl_clock.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
  10:../drivers/fsl_clock.h ****  * that the following conditions are met:
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  13:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  14:../drivers/fsl_clock.h ****  *
  15:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  16:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  17:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  18:../drivers/fsl_clock.h ****  *
  19:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  20:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  21:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  22:../drivers/fsl_clock.h ****  *
  23:../drivers/fsl_clock.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  24:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  25:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  26:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  27:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  28:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  29:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  31:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  32:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  33:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../drivers/fsl_clock.h ****  */
  35:../drivers/fsl_clock.h **** 
  36:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  37:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  38:../drivers/fsl_clock.h **** 
  39:../drivers/fsl_clock.h **** #include "fsl_common.h"
  40:../drivers/fsl_clock.h **** 
  41:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  42:../drivers/fsl_clock.h **** /*! @{ */
  43:../drivers/fsl_clock.h **** 
  44:../drivers/fsl_clock.h **** /*! @file */
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*******************************************************************************
  47:../drivers/fsl_clock.h ****  * Configurations
  48:../drivers/fsl_clock.h ****  ******************************************************************************/
  49:../drivers/fsl_clock.h **** 
  50:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  51:../drivers/fsl_clock.h ****  *
  52:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  53:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  54:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  55:../drivers/fsl_clock.h ****  * the driver.
  56:../drivers/fsl_clock.h ****  *
  57:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  58:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  61:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*******************************************************************************
  65:../drivers/fsl_clock.h ****  * Definitions
  66:../drivers/fsl_clock.h ****  ******************************************************************************/
  67:../drivers/fsl_clock.h **** 
  68:../drivers/fsl_clock.h **** /*! @name Driver version */
  69:../drivers/fsl_clock.h **** /*@{*/
  70:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.1.1. */
  71:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
  72:../drivers/fsl_clock.h **** /*@}*/
  73:../drivers/fsl_clock.h **** 
  74:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  75:../drivers/fsl_clock.h ****  *
  76:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  77:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  78:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  79:../drivers/fsl_clock.h ****  * @code
  80:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  81:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
  82:../drivers/fsl_clock.h ****  * @endcode
  83:../drivers/fsl_clock.h ****  *
  84:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up the
  85:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
  86:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  87:../drivers/fsl_clock.h ****  */
  88:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
  89:../drivers/fsl_clock.h **** 
  90:../drivers/fsl_clock.h **** /*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
  91:../drivers/fsl_clock.h ****  *
  92:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
  93:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
  94:../drivers/fsl_clock.h ****  *
  95:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where one core needs to set up
  96:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
  97:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
  98:../drivers/fsl_clock.h ****  */
  99:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 100:../drivers/fsl_clock.h **** 
 101:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 102:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 103:../drivers/fsl_clock.h ****     {                  \
 104:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 105:../drivers/fsl_clock.h ****     }
 106:../drivers/fsl_clock.h **** 
 107:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 108:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 109:../drivers/fsl_clock.h ****     {               \
 110:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 111:../drivers/fsl_clock.h ****     }
 112:../drivers/fsl_clock.h **** 
 113:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SAI. */
 114:../drivers/fsl_clock.h **** #define SAI_CLOCKS  \
 115:../drivers/fsl_clock.h ****     {               \
 116:../drivers/fsl_clock.h ****         kCLOCK_Sai0 \
 117:../drivers/fsl_clock.h ****     }
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 120:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 121:../drivers/fsl_clock.h ****     {                            \
 122:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 126:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 132:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 133:../drivers/fsl_clock.h ****     {                                                                        \
 134:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPUART. */
 138:../drivers/fsl_clock.h **** #define LPUART_CLOCKS                  \
 139:../drivers/fsl_clock.h ****     {                                  \
 140:../drivers/fsl_clock.h ****         kCLOCK_Lpuart0, kCLOCK_Lpuart1 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 144:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 145:../drivers/fsl_clock.h ****     {               \
 146:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 150:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {                 \
 152:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 156:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 157:../drivers/fsl_clock.h ****     {                \
 158:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FLEXIO. */
 162:../drivers/fsl_clock.h **** #define FLEXIO_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                  \
 164:../drivers/fsl_clock.h ****         kCLOCK_Flexio0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for VREF. */
 168:../drivers/fsl_clock.h **** #define VREF_CLOCKS  \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Vref0 \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 180:../drivers/fsl_clock.h **** #define UART_CLOCKS                                      \
 181:../drivers/fsl_clock.h ****     {                                                    \
 182:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_IpInvalid, kCLOCK_Uart2 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 186:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 187:../drivers/fsl_clock.h ****     {                                         \
 188:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 192:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 193:../drivers/fsl_clock.h ****     {                            \
 194:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 198:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 199:../drivers/fsl_clock.h ****     {               \
 200:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 204:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*!
 210:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 211:../drivers/fsl_clock.h ****  */
 212:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 213:../drivers/fsl_clock.h **** 
 214:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 215:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 216:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 217:../drivers/fsl_clock.h **** 
 218:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC SYS_CLK
 219:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC SYS_CLK
 220:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 221:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 222:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 225:../drivers/fsl_clock.h **** typedef enum _clock_name
 226:../drivers/fsl_clock.h **** {
 227:../drivers/fsl_clock.h **** 
 228:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 229:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,    /*!< Core/system clock                                         */
 230:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,       /*!< Platform clock                                            */
 231:../drivers/fsl_clock.h ****     kCLOCK_BusClk,        /*!< Bus clock                                                 */
 232:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,    /*!< FlexBus clock                                             */
 233:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,      /*!< Flash clock                                               */
 234:../drivers/fsl_clock.h ****     kCLOCK_FastPeriphClk, /*!< Fast peripheral clock                                     */
 235:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk,  /*!< The clock after SIM[PLLFLLSEL].                           */
 236:../drivers/fsl_clock.h **** 
 237:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 238:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,       /*!< External reference 32K clock (ERCLK32K)                   */
 239:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk,      /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 240:../drivers/fsl_clock.h ****     kCLOCK_Osc1ErClk,      /*!< OSC1 external reference clock (OSC1ERCLK)                 */
 241:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClkUndiv, /*!< OSC0 external reference undivided clock(OSC0ERCLK_UNDIV). */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 245:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 246:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 247:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 248:../drivers/fsl_clock.h ****     kCLOCK_McgPll1Clk,        /*!< MCGPLL1CLK                                                */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
 252:../drivers/fsl_clock.h **** 
 253:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 254:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 255:../drivers/fsl_clock.h **** 
 256:../drivers/fsl_clock.h **** } clock_name_t;
 257:../drivers/fsl_clock.h **** 
 258:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 259:../drivers/fsl_clock.h **** 
 260:../drivers/fsl_clock.h ****  clock_gate_t definition:
 261:../drivers/fsl_clock.h **** 
 262:../drivers/fsl_clock.h ****  31                              16                              0
 263:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 264:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 265:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 266:../drivers/fsl_clock.h **** 
 267:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 268:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 271:../drivers/fsl_clock.h **** 
 272:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 273:../drivers/fsl_clock.h **** 
 274:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 275:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 276:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 277:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 278:../drivers/fsl_clock.h **** 
 279:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 280:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 281:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 282:../drivers/fsl_clock.h **** 
 283:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 284:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 285:../drivers/fsl_clock.h **** 
 286:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 287:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 288:../drivers/fsl_clock.h **** {
 289:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 290:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 291:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 292:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 293:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 294:../drivers/fsl_clock.h ****     kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
 295:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 296:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 297:../drivers/fsl_clock.h **** 
 298:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 299:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 300:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Lpuart1 = CLK_GATE_DEFINE(0x1038U, 21U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Flexio0 = CLK_GATE_DEFINE(0x1038U, 31U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 310:../drivers/fsl_clock.h ****     kCLOCK_Sai0 = CLK_GATE_DEFINE(0x103CU, 15U),
 311:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 312:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 313:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 314:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 315:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 316:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 318:../drivers/fsl_clock.h **** 
 319:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 320:../drivers/fsl_clock.h **** } clock_ip_name_t;
 321:../drivers/fsl_clock.h **** 
 322:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 323:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 324:../drivers/fsl_clock.h **** {
 325:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 326:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 327:../drivers/fsl_clock.h **** } sim_clock_config_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 330:../drivers/fsl_clock.h **** enum _osc_cap_load
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 333:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 334:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 335:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 336:../drivers/fsl_clock.h **** };
 337:../drivers/fsl_clock.h **** 
 338:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 339:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 340:../drivers/fsl_clock.h **** {
 341:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 342:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 343:../drivers/fsl_clock.h **** };
 344:../drivers/fsl_clock.h **** 
 345:../drivers/fsl_clock.h **** /*! @brief The OSC configuration for OSCERCLK. */
 346:../drivers/fsl_clock.h **** typedef struct _oscer_config
 347:../drivers/fsl_clock.h **** {
 348:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
 349:../drivers/fsl_clock.h **** 
 350:../drivers/fsl_clock.h **** } oscer_config_t;
 351:../drivers/fsl_clock.h **** 
 352:../drivers/fsl_clock.h **** /*! @brief The OSC work mode. */
 353:../drivers/fsl_clock.h **** typedef enum _osc_mode
 354:../drivers/fsl_clock.h **** {
 355:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U,                                            /*!< Use external clock.   */
 356:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK,                    /*!< Oscillator low power. */
 357:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 358:../drivers/fsl_clock.h **** } osc_mode_t;
 359:../drivers/fsl_clock.h **** 
 360:../drivers/fsl_clock.h **** /*!
 361:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 362:../drivers/fsl_clock.h ****  *
 363:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 364:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 365:../drivers/fsl_clock.h ****  * according to the board settings:
 366:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 367:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 368:../drivers/fsl_clock.h ****  */
 369:../drivers/fsl_clock.h **** typedef struct _osc_config
 370:../drivers/fsl_clock.h **** {
 371:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 372:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 373:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 374:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 375:../drivers/fsl_clock.h **** } osc_config_t;
 376:../drivers/fsl_clock.h **** 
 377:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock source selection. */
 378:../drivers/fsl_clock.h **** typedef enum _mcglite_clkout_src
 379:../drivers/fsl_clock.h **** {
 380:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
 381:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
 382:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
 383:../drivers/fsl_clock.h ****     kMCGLITE_ClkSrcReserved
 384:../drivers/fsl_clock.h **** } mcglite_clkout_src_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*! @brief MCG_Lite LIRC select. */
 387:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_mode
 388:../drivers/fsl_clock.h **** {
 389:../drivers/fsl_clock.h ****     kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
 390:../drivers/fsl_clock.h ****     kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
 391:../drivers/fsl_clock.h **** } mcglite_lirc_mode_t;
 392:../drivers/fsl_clock.h **** 
 393:../drivers/fsl_clock.h **** /*! @brief MCG_Lite divider factor selection for clock source*/
 394:../drivers/fsl_clock.h **** typedef enum _mcglite_lirc_div
 395:../drivers/fsl_clock.h **** {
 396:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
 397:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
 398:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
 399:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
 400:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
 401:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
 402:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
 403:../drivers/fsl_clock.h ****     kMCGLITE_LircDivBy128     /*!< Divider is 128  */
 404:../drivers/fsl_clock.h **** } mcglite_lirc_div_t;
 405:../drivers/fsl_clock.h **** 
 406:../drivers/fsl_clock.h **** /*! @brief MCG_Lite clock mode definitions */
 407:../drivers/fsl_clock.h **** typedef enum _mcglite_mode
 408:../drivers/fsl_clock.h **** {
 409:../drivers/fsl_clock.h ****     kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
 410:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
 411:../drivers/fsl_clock.h ****     kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
 412:../drivers/fsl_clock.h ****     kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
 413:../drivers/fsl_clock.h ****     kMCGLITE_ModeError    /*!< Unknown mode            */
 414:../drivers/fsl_clock.h **** } mcglite_mode_t;
 415:../drivers/fsl_clock.h **** 
 416:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 417:../drivers/fsl_clock.h **** enum _mcglite_irclk_enable_mode
 418:../drivers/fsl_clock.h **** {
 419:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 420:../drivers/fsl_clock.h ****     kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 421:../drivers/fsl_clock.h **** };
 422:../drivers/fsl_clock.h **** 
 423:../drivers/fsl_clock.h **** /*! @brief MCG_Lite configure structure for mode change. */
 424:../drivers/fsl_clock.h **** typedef struct _mcglite_config
 425:../drivers/fsl_clock.h **** {
 426:../drivers/fsl_clock.h ****     mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
 427:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_m
 428:../drivers/fsl_clock.h ****     mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
 429:../drivers/fsl_clock.h ****     mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
 430:../drivers/fsl_clock.h ****     mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
 431:../drivers/fsl_clock.h ****     bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
 432:../drivers/fsl_clock.h **** } mcglite_config_t;
 433:../drivers/fsl_clock.h **** 
 434:../drivers/fsl_clock.h **** /*******************************************************************************
 435:../drivers/fsl_clock.h ****  * API
 436:../drivers/fsl_clock.h ****  ******************************************************************************/
 437:../drivers/fsl_clock.h **** 
 438:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 439:../drivers/fsl_clock.h **** extern "C" {
 440:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 441:../drivers/fsl_clock.h **** 
 442:../drivers/fsl_clock.h **** /*!
 443:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 444:../drivers/fsl_clock.h ****  *
 445:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 446:../drivers/fsl_clock.h ****  */
 447:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 448:../drivers/fsl_clock.h **** {
 449:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 450:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 451:../drivers/fsl_clock.h **** }
 452:../drivers/fsl_clock.h **** 
 453:../drivers/fsl_clock.h **** /*!
 454:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 455:../drivers/fsl_clock.h ****  *
 456:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 457:../drivers/fsl_clock.h ****  */
 458:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 459:../drivers/fsl_clock.h **** {
 460:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 461:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 462:../drivers/fsl_clock.h **** }
 463:../drivers/fsl_clock.h **** 
 464:../drivers/fsl_clock.h **** /*!
 465:../drivers/fsl_clock.h ****  * @brief Set ERCLK32K source.
 466:../drivers/fsl_clock.h ****  *
 467:../drivers/fsl_clock.h ****  * @param src The value to set ERCLK32K clock source.
 468:../drivers/fsl_clock.h ****  */
 469:../drivers/fsl_clock.h **** static inline void CLOCK_SetEr32kClock(uint32_t src)
 470:../drivers/fsl_clock.h **** {
 471:../drivers/fsl_clock.h ****     SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
 472:../drivers/fsl_clock.h **** }
 473:../drivers/fsl_clock.h **** 
 474:../drivers/fsl_clock.h **** /*!
 475:../drivers/fsl_clock.h ****  * @brief Set LPUART0 clock source.
 476:../drivers/fsl_clock.h ****  *
 477:../drivers/fsl_clock.h ****  * @param src The value to set LPUART0 clock source.
 478:../drivers/fsl_clock.h ****  */
 479:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpuart0Clock(uint32_t src)
 480:../drivers/fsl_clock.h **** {
 481:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART0SRC_MASK) | SIM_SOPT2_LPUART0SRC(src));
 482:../drivers/fsl_clock.h **** }
 483:../drivers/fsl_clock.h **** 
 484:../drivers/fsl_clock.h **** /*!
 485:../drivers/fsl_clock.h ****  * @brief Set LPUART1 clock source.
 486:../drivers/fsl_clock.h ****  *
 487:../drivers/fsl_clock.h ****  * @param src The value to set LPUART1 clock source.
 488:../drivers/fsl_clock.h ****  */
 489:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpuart1Clock(uint32_t src)
 490:../drivers/fsl_clock.h **** {
 491:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART1SRC_MASK) | SIM_SOPT2_LPUART1SRC(src));
 147              		.loc 3 491 0
 148 002c C020     		movs	r0, #192
 149              	.LBE79:
 150              	.LBE78:
 151              		.loc 1 106 0
 152 002e AB71     		strb	r3, [r5, #6]
 107:../source/main.c **** 	uart_config.enableRx = true;
 153              		.loc 1 107 0
 154 0030 EB71     		strb	r3, [r5, #7]
 108:../source/main.c **** 	lpuart_config.baudRate_Bps = 9600;
 109:../source/main.c **** 	lpuart_config.enableTx = true;
 155              		.loc 1 109 0
 156 0032 A372     		strb	r3, [r4, #10]
 110:../source/main.c **** 	lpuart_config.enableRx = true;
 157              		.loc 1 110 0
 158 0034 E372     		strb	r3, [r4, #11]
 159              	.LVL12:
 160              	.LBB83:
 161              	.LBB80:
 162              		.loc 3 491 0
 163 0036 1E4A     		ldr	r2, .L5+4
 164 0038 1E4B     		ldr	r3, .L5+8
 165              	.LBE80:
 166              	.LBE83:
 105:../source/main.c **** 	uart_config.enableTx = true;
 167              		.loc 1 105 0
 168 003a B601     		lsls	r6, r6, #6
 169 003c 2E60     		str	r6, [r5]
 108:../source/main.c **** 	lpuart_config.baudRate_Bps = 9600;
 170              		.loc 1 108 0
 171 003e 0396     		str	r6, [sp, #12]
 172              	.LBB84:
 173              	.LBB81:
 174              		.loc 3 491 0
 175 0040 D158     		ldr	r1, [r2, r3]
 176 0042 8005     		lsls	r0, r0, #22
 177 0044 0143     		orrs	r1, r0
 178              	.LBE81:
 179              	.LBE84:
 180              	.LBB85:
 181              	.LBB86:
 481:../drivers/fsl_clock.h **** }
 182              		.loc 3 481 0
 183 0046 C020     		movs	r0, #192
 184              	.LBE86:
 185              	.LBE85:
 186              	.LBB89:
 187              	.LBB82:
 188              		.loc 3 491 0
 189 0048 D150     		str	r1, [r2, r3]
 190              	.LVL13:
 191              	.LBE82:
 192              	.LBE89:
 193              	.LBB90:
 194              	.LBB87:
 481:../drivers/fsl_clock.h **** }
 195              		.loc 3 481 0
 196 004a D158     		ldr	r1, [r2, r3]
 197 004c 0005     		lsls	r0, r0, #20
 198 004e 0143     		orrs	r1, r0
 199              	.LBE87:
 200              	.LBE90:
 111:../source/main.c **** 
 112:../source/main.c **** 	CLOCK_SetLpuart1Clock(0x3U);
 113:../source/main.c **** 	CLOCK_SetLpuart0Clock(0x3U);
 114:../source/main.c **** 
 115:../source/main.c **** 	LPUART_Init(LPUART0, &lpuart_config, lpuartClkSrcFreq); //Init LPUART0 for NBiot
 116:../source/main.c **** 
 117:../source/main.c **** 	UART_Init(UART2, &uart_config, uartClkSrcFreq); //UART2 for GPS with same settings!
 201              		.loc 1 117 0
 202 0050 194F     		ldr	r7, .L5+12
 203              	.LBB91:
 204              	.LBB88:
 481:../drivers/fsl_clock.h **** }
 205              		.loc 3 481 0
 206 0052 D150     		str	r1, [r2, r3]
 207              	.LVL14:
 208              	.LBE88:
 209              	.LBE91:
 115:../source/main.c **** 
 210              		.loc 1 115 0
 211 0054 1948     		ldr	r0, .L5+16
 212 0056 009A     		ldr	r2, [sp]
 213 0058 2100     		movs	r1, r4
 214 005a FFF7FEFF 		bl	LPUART_Init
 215              	.LVL15:
 216              		.loc 1 117 0
 217 005e 019A     		ldr	r2, [sp, #4]
 218 0060 2900     		movs	r1, r5
 219 0062 3800     		movs	r0, r7
 220 0064 FFF7FEFF 		bl	UART_Init
 221              	.LVL16:
 118:../source/main.c **** 
 119:../source/main.c **** 	lpuart_config.baudRate_Bps = 9600;
 222              		.loc 1 119 0
 223 0068 0396     		str	r6, [sp, #12]
 120:../source/main.c **** 
 121:../source/main.c **** 	LPUART_Init(LPUART1, &lpuart_config, lpuartClkSrcFreq); //Init LPUART1 for PCuart
 122:../source/main.c **** 
 123:../source/main.c **** 	LPUART_EnableInterrupts(LPUART0, kLPUART_RxDataRegFullInterruptEnable); //enable LPUART0 receive i
 224              		.loc 1 123 0
 225 006a 8026     		movs	r6, #128
 121:../source/main.c **** 
 226              		.loc 1 121 0
 227 006c 144D     		ldr	r5, .L5+20
 228 006e 009A     		ldr	r2, [sp]
 229 0070 2100     		movs	r1, r4
 230              		.loc 1 123 0
 231 0072 B603     		lsls	r6, r6, #14
 121:../source/main.c **** 
 232              		.loc 1 121 0
 233 0074 2800     		movs	r0, r5
 234 0076 FFF7FEFF 		bl	LPUART_Init
 235              	.LVL17:
 236              		.loc 1 123 0
 237 007a 3100     		movs	r1, r6
 238 007c 0F48     		ldr	r0, .L5+16
 239 007e FFF7FEFF 		bl	LPUART_EnableInterrupts
 240              	.LVL18:
 241              	.LBB92:
 242              	.LBB93:
 243              	.LBB94:
 244              		.file 4 "../CMSIS/core_cm0plus.h"
   1:../CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:../CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../CMSIS/core_cm0plus.h ****  * @version  V5.0.2
   5:../CMSIS/core_cm0plus.h ****  * @date     19. April 2017
   6:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:../CMSIS/core_cm0plus.h **** /*
   8:../CMSIS/core_cm0plus.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:../CMSIS/core_cm0plus.h ****  *
  10:../CMSIS/core_cm0plus.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../CMSIS/core_cm0plus.h ****  *
  12:../CMSIS/core_cm0plus.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../CMSIS/core_cm0plus.h ****  * not use this file except in compliance with the License.
  14:../CMSIS/core_cm0plus.h ****  * You may obtain a copy of the License at
  15:../CMSIS/core_cm0plus.h ****  *
  16:../CMSIS/core_cm0plus.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../CMSIS/core_cm0plus.h ****  *
  18:../CMSIS/core_cm0plus.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../CMSIS/core_cm0plus.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../CMSIS/core_cm0plus.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../CMSIS/core_cm0plus.h ****  * See the License for the specific language governing permissions and
  22:../CMSIS/core_cm0plus.h ****  * limitations under the License.
  23:../CMSIS/core_cm0plus.h ****  */
  24:../CMSIS/core_cm0plus.h **** 
  25:../CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  26:../CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  27:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  28:../CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  29:../CMSIS/core_cm0plus.h **** #endif
  30:../CMSIS/core_cm0plus.h **** 
  31:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  32:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  33:../CMSIS/core_cm0plus.h **** 
  34:../CMSIS/core_cm0plus.h **** #include <stdint.h>
  35:../CMSIS/core_cm0plus.h **** 
  36:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  37:../CMSIS/core_cm0plus.h ****  extern "C" {
  38:../CMSIS/core_cm0plus.h **** #endif
  39:../CMSIS/core_cm0plus.h **** 
  40:../CMSIS/core_cm0plus.h **** /**
  41:../CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:../CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:../CMSIS/core_cm0plus.h **** 
  44:../CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:../CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  46:../CMSIS/core_cm0plus.h **** 
  47:../CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:../CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  49:../CMSIS/core_cm0plus.h **** 
  50:../CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:../CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  52:../CMSIS/core_cm0plus.h ****  */
  53:../CMSIS/core_cm0plus.h **** 
  54:../CMSIS/core_cm0plus.h **** 
  55:../CMSIS/core_cm0plus.h **** /*******************************************************************************
  56:../CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  57:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
  58:../CMSIS/core_cm0plus.h **** /**
  59:../CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  60:../CMSIS/core_cm0plus.h ****   @{
  61:../CMSIS/core_cm0plus.h ****  */
  62:../CMSIS/core_cm0plus.h **** 
  63:../CMSIS/core_cm0plus.h **** #include "cmsis_version.h"
  64:../CMSIS/core_cm0plus.h ****  
  65:../CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  66:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [3
  67:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [1
  68:../CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  69:../CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CM
  70:../CMSIS/core_cm0plus.h **** 
  71:../CMSIS/core_cm0plus.h **** #define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core 
  72:../CMSIS/core_cm0plus.h **** 
  73:../CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:../CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
  75:../CMSIS/core_cm0plus.h **** */
  76:../CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
  77:../CMSIS/core_cm0plus.h **** 
  78:../CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
  79:../CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
  80:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:../CMSIS/core_cm0plus.h ****   #endif
  82:../CMSIS/core_cm0plus.h **** 
  83:../CMSIS/core_cm0plus.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:../CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
  85:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:../CMSIS/core_cm0plus.h ****   #endif
  87:../CMSIS/core_cm0plus.h **** 
  88:../CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  89:../CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:../CMSIS/core_cm0plus.h ****   #endif
  92:../CMSIS/core_cm0plus.h **** 
  93:../CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  94:../CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
  95:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:../CMSIS/core_cm0plus.h ****   #endif
  97:../CMSIS/core_cm0plus.h **** 
  98:../CMSIS/core_cm0plus.h **** #elif defined ( __TI_ARM__ )
  99:../CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 100:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:../CMSIS/core_cm0plus.h ****   #endif
 102:../CMSIS/core_cm0plus.h **** 
 103:../CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 104:../CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 105:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:../CMSIS/core_cm0plus.h ****   #endif
 107:../CMSIS/core_cm0plus.h **** 
 108:../CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 109:../CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 110:../CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:../CMSIS/core_cm0plus.h ****   #endif
 112:../CMSIS/core_cm0plus.h **** 
 113:../CMSIS/core_cm0plus.h **** #endif
 114:../CMSIS/core_cm0plus.h **** 
 115:../CMSIS/core_cm0plus.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:../CMSIS/core_cm0plus.h **** 
 117:../CMSIS/core_cm0plus.h **** 
 118:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 119:../CMSIS/core_cm0plus.h **** }
 120:../CMSIS/core_cm0plus.h **** #endif
 121:../CMSIS/core_cm0plus.h **** 
 122:../CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 123:../CMSIS/core_cm0plus.h **** 
 124:../CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 125:../CMSIS/core_cm0plus.h **** 
 126:../CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 127:../CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 128:../CMSIS/core_cm0plus.h **** 
 129:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 130:../CMSIS/core_cm0plus.h ****  extern "C" {
 131:../CMSIS/core_cm0plus.h **** #endif
 132:../CMSIS/core_cm0plus.h **** 
 133:../CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 134:../CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 135:../CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 136:../CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 137:../CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 138:../CMSIS/core_cm0plus.h ****   #endif
 139:../CMSIS/core_cm0plus.h **** 
 140:../CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 141:../CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 142:../CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 143:../CMSIS/core_cm0plus.h ****   #endif
 144:../CMSIS/core_cm0plus.h **** 
 145:../CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 146:../CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 147:../CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 148:../CMSIS/core_cm0plus.h ****   #endif
 149:../CMSIS/core_cm0plus.h **** 
 150:../CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 151:../CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 152:../CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 153:../CMSIS/core_cm0plus.h ****   #endif
 154:../CMSIS/core_cm0plus.h **** 
 155:../CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 156:../CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 157:../CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 158:../CMSIS/core_cm0plus.h ****   #endif
 159:../CMSIS/core_cm0plus.h **** #endif
 160:../CMSIS/core_cm0plus.h **** 
 161:../CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 162:../CMSIS/core_cm0plus.h **** /**
 163:../CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 164:../CMSIS/core_cm0plus.h **** 
 165:../CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 166:../CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 167:../CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 168:../CMSIS/core_cm0plus.h **** */
 169:../CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 170:../CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 171:../CMSIS/core_cm0plus.h **** #else
 172:../CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 173:../CMSIS/core_cm0plus.h **** #endif
 174:../CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 175:../CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 176:../CMSIS/core_cm0plus.h **** 
 177:../CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 178:../CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 179:../CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 180:../CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 181:../CMSIS/core_cm0plus.h **** 
 182:../CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 183:../CMSIS/core_cm0plus.h **** 
 184:../CMSIS/core_cm0plus.h **** 
 185:../CMSIS/core_cm0plus.h **** 
 186:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 187:../CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 188:../CMSIS/core_cm0plus.h ****   Core Register contain:
 189:../CMSIS/core_cm0plus.h ****   - Core Register
 190:../CMSIS/core_cm0plus.h ****   - Core NVIC Register
 191:../CMSIS/core_cm0plus.h ****   - Core SCB Register
 192:../CMSIS/core_cm0plus.h ****   - Core SysTick Register
 193:../CMSIS/core_cm0plus.h ****   - Core MPU Register
 194:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 195:../CMSIS/core_cm0plus.h **** /**
 196:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 197:../CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 198:../CMSIS/core_cm0plus.h **** */
 199:../CMSIS/core_cm0plus.h **** 
 200:../CMSIS/core_cm0plus.h **** /**
 201:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 202:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 203:../CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 204:../CMSIS/core_cm0plus.h ****   @{
 205:../CMSIS/core_cm0plus.h ****  */
 206:../CMSIS/core_cm0plus.h **** 
 207:../CMSIS/core_cm0plus.h **** /**
 208:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 209:../CMSIS/core_cm0plus.h ****  */
 210:../CMSIS/core_cm0plus.h **** typedef union
 211:../CMSIS/core_cm0plus.h **** {
 212:../CMSIS/core_cm0plus.h ****   struct
 213:../CMSIS/core_cm0plus.h ****   {
 214:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 215:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 216:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 217:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 218:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 219:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 220:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 221:../CMSIS/core_cm0plus.h **** } APSR_Type;
 222:../CMSIS/core_cm0plus.h **** 
 223:../CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 224:../CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 225:../CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 226:../CMSIS/core_cm0plus.h **** 
 227:../CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 228:../CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 229:../CMSIS/core_cm0plus.h **** 
 230:../CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 231:../CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 232:../CMSIS/core_cm0plus.h **** 
 233:../CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 234:../CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 235:../CMSIS/core_cm0plus.h **** 
 236:../CMSIS/core_cm0plus.h **** 
 237:../CMSIS/core_cm0plus.h **** /**
 238:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 239:../CMSIS/core_cm0plus.h ****  */
 240:../CMSIS/core_cm0plus.h **** typedef union
 241:../CMSIS/core_cm0plus.h **** {
 242:../CMSIS/core_cm0plus.h ****   struct
 243:../CMSIS/core_cm0plus.h ****   {
 244:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 245:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 246:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 247:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 248:../CMSIS/core_cm0plus.h **** } IPSR_Type;
 249:../CMSIS/core_cm0plus.h **** 
 250:../CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 251:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 252:../CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 253:../CMSIS/core_cm0plus.h **** 
 254:../CMSIS/core_cm0plus.h **** 
 255:../CMSIS/core_cm0plus.h **** /**
 256:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 257:../CMSIS/core_cm0plus.h ****  */
 258:../CMSIS/core_cm0plus.h **** typedef union
 259:../CMSIS/core_cm0plus.h **** {
 260:../CMSIS/core_cm0plus.h ****   struct
 261:../CMSIS/core_cm0plus.h ****   {
 262:../CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 263:../CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 264:../CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 265:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 266:../CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 267:../CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 268:../CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 269:../CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 270:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 271:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 272:../CMSIS/core_cm0plus.h **** } xPSR_Type;
 273:../CMSIS/core_cm0plus.h **** 
 274:../CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 275:../CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 276:../CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 277:../CMSIS/core_cm0plus.h **** 
 278:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 279:../CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 280:../CMSIS/core_cm0plus.h **** 
 281:../CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 282:../CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 283:../CMSIS/core_cm0plus.h **** 
 284:../CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 285:../CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 286:../CMSIS/core_cm0plus.h **** 
 287:../CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 288:../CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 289:../CMSIS/core_cm0plus.h **** 
 290:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 291:../CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 292:../CMSIS/core_cm0plus.h **** 
 293:../CMSIS/core_cm0plus.h **** 
 294:../CMSIS/core_cm0plus.h **** /**
 295:../CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 296:../CMSIS/core_cm0plus.h ****  */
 297:../CMSIS/core_cm0plus.h **** typedef union
 298:../CMSIS/core_cm0plus.h **** {
 299:../CMSIS/core_cm0plus.h ****   struct
 300:../CMSIS/core_cm0plus.h ****   {
 301:../CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 302:../CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 303:../CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 304:../CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 305:../CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:../CMSIS/core_cm0plus.h **** } CONTROL_Type;
 307:../CMSIS/core_cm0plus.h **** 
 308:../CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 309:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 310:../CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 311:../CMSIS/core_cm0plus.h **** 
 312:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 313:../CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 314:../CMSIS/core_cm0plus.h **** 
 315:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 316:../CMSIS/core_cm0plus.h **** 
 317:../CMSIS/core_cm0plus.h **** 
 318:../CMSIS/core_cm0plus.h **** /**
 319:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 320:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 321:../CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 322:../CMSIS/core_cm0plus.h ****   @{
 323:../CMSIS/core_cm0plus.h ****  */
 324:../CMSIS/core_cm0plus.h **** 
 325:../CMSIS/core_cm0plus.h **** /**
 326:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 327:../CMSIS/core_cm0plus.h ****  */
 328:../CMSIS/core_cm0plus.h **** typedef struct
 329:../CMSIS/core_cm0plus.h **** {
 330:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 331:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 332:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 333:../CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 334:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 335:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 336:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 337:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 338:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 339:../CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 340:../CMSIS/core_cm0plus.h **** }  NVIC_Type;
 341:../CMSIS/core_cm0plus.h **** 
 342:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 343:../CMSIS/core_cm0plus.h **** 
 344:../CMSIS/core_cm0plus.h **** 
 345:../CMSIS/core_cm0plus.h **** /**
 346:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 347:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 348:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 349:../CMSIS/core_cm0plus.h ****   @{
 350:../CMSIS/core_cm0plus.h ****  */
 351:../CMSIS/core_cm0plus.h **** 
 352:../CMSIS/core_cm0plus.h **** /**
 353:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 354:../CMSIS/core_cm0plus.h ****  */
 355:../CMSIS/core_cm0plus.h **** typedef struct
 356:../CMSIS/core_cm0plus.h **** {
 357:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 358:../CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 359:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 360:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 361:../CMSIS/core_cm0plus.h **** #else
 362:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 363:../CMSIS/core_cm0plus.h **** #endif
 364:../CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 365:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 366:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 367:../CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 368:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 369:../CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 370:../CMSIS/core_cm0plus.h **** } SCB_Type;
 371:../CMSIS/core_cm0plus.h **** 
 372:../CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 373:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 374:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 375:../CMSIS/core_cm0plus.h **** 
 376:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 377:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 378:../CMSIS/core_cm0plus.h **** 
 379:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 380:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 381:../CMSIS/core_cm0plus.h **** 
 382:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 383:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 384:../CMSIS/core_cm0plus.h **** 
 385:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 386:../CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 387:../CMSIS/core_cm0plus.h **** 
 388:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 389:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 390:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 391:../CMSIS/core_cm0plus.h **** 
 392:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 393:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 394:../CMSIS/core_cm0plus.h **** 
 395:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 396:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 397:../CMSIS/core_cm0plus.h **** 
 398:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 399:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 400:../CMSIS/core_cm0plus.h **** 
 401:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 402:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 403:../CMSIS/core_cm0plus.h **** 
 404:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 405:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 406:../CMSIS/core_cm0plus.h **** 
 407:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 408:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 409:../CMSIS/core_cm0plus.h **** 
 410:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 411:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 412:../CMSIS/core_cm0plus.h **** 
 413:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 414:../CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 415:../CMSIS/core_cm0plus.h **** 
 416:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 417:../CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 418:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 419:../CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 420:../CMSIS/core_cm0plus.h **** #endif
 421:../CMSIS/core_cm0plus.h **** 
 422:../CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 423:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 424:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 425:../CMSIS/core_cm0plus.h **** 
 426:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 427:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 428:../CMSIS/core_cm0plus.h **** 
 429:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 430:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 431:../CMSIS/core_cm0plus.h **** 
 432:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 433:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 434:../CMSIS/core_cm0plus.h **** 
 435:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 436:../CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 437:../CMSIS/core_cm0plus.h **** 
 438:../CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 439:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 440:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 441:../CMSIS/core_cm0plus.h **** 
 442:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 443:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 444:../CMSIS/core_cm0plus.h **** 
 445:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 446:../CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 447:../CMSIS/core_cm0plus.h **** 
 448:../CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 449:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 450:../CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 451:../CMSIS/core_cm0plus.h **** 
 452:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 453:../CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 454:../CMSIS/core_cm0plus.h **** 
 455:../CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 456:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 457:../CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 458:../CMSIS/core_cm0plus.h **** 
 459:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 460:../CMSIS/core_cm0plus.h **** 
 461:../CMSIS/core_cm0plus.h **** 
 462:../CMSIS/core_cm0plus.h **** /**
 463:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 464:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 465:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 466:../CMSIS/core_cm0plus.h ****   @{
 467:../CMSIS/core_cm0plus.h ****  */
 468:../CMSIS/core_cm0plus.h **** 
 469:../CMSIS/core_cm0plus.h **** /**
 470:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 471:../CMSIS/core_cm0plus.h ****  */
 472:../CMSIS/core_cm0plus.h **** typedef struct
 473:../CMSIS/core_cm0plus.h **** {
 474:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 475:../CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 476:../CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 477:../CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 478:../CMSIS/core_cm0plus.h **** } SysTick_Type;
 479:../CMSIS/core_cm0plus.h **** 
 480:../CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 481:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 482:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 483:../CMSIS/core_cm0plus.h **** 
 484:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 485:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 486:../CMSIS/core_cm0plus.h **** 
 487:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 488:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 489:../CMSIS/core_cm0plus.h **** 
 490:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 491:../CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 492:../CMSIS/core_cm0plus.h **** 
 493:../CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 494:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 495:../CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 496:../CMSIS/core_cm0plus.h **** 
 497:../CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 498:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 499:../CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 500:../CMSIS/core_cm0plus.h **** 
 501:../CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 502:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 503:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 504:../CMSIS/core_cm0plus.h **** 
 505:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 506:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 507:../CMSIS/core_cm0plus.h **** 
 508:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 509:../CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 510:../CMSIS/core_cm0plus.h **** 
 511:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 512:../CMSIS/core_cm0plus.h **** 
 513:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 514:../CMSIS/core_cm0plus.h **** /**
 515:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 516:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 517:../CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 518:../CMSIS/core_cm0plus.h ****   @{
 519:../CMSIS/core_cm0plus.h ****  */
 520:../CMSIS/core_cm0plus.h **** 
 521:../CMSIS/core_cm0plus.h **** /**
 522:../CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 523:../CMSIS/core_cm0plus.h ****  */
 524:../CMSIS/core_cm0plus.h **** typedef struct
 525:../CMSIS/core_cm0plus.h **** {
 526:../CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 527:../CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 528:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 529:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 530:../CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 531:../CMSIS/core_cm0plus.h **** } MPU_Type;
 532:../CMSIS/core_cm0plus.h **** 
 533:../CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 534:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 535:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 536:../CMSIS/core_cm0plus.h **** 
 537:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 538:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 539:../CMSIS/core_cm0plus.h **** 
 540:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 541:../CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 542:../CMSIS/core_cm0plus.h **** 
 543:../CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 544:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 545:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 546:../CMSIS/core_cm0plus.h **** 
 547:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 548:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 549:../CMSIS/core_cm0plus.h **** 
 550:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 551:../CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 552:../CMSIS/core_cm0plus.h **** 
 553:../CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 554:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 555:../CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 556:../CMSIS/core_cm0plus.h **** 
 557:../CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 558:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 559:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 560:../CMSIS/core_cm0plus.h **** 
 561:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 562:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 563:../CMSIS/core_cm0plus.h **** 
 564:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 565:../CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 566:../CMSIS/core_cm0plus.h **** 
 567:../CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 568:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 569:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 570:../CMSIS/core_cm0plus.h **** 
 571:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 572:../CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 573:../CMSIS/core_cm0plus.h **** 
 574:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 575:../CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 576:../CMSIS/core_cm0plus.h **** 
 577:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 578:../CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 579:../CMSIS/core_cm0plus.h **** 
 580:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 581:../CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 582:../CMSIS/core_cm0plus.h **** 
 583:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 584:../CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 585:../CMSIS/core_cm0plus.h **** 
 586:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 587:../CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 588:../CMSIS/core_cm0plus.h **** 
 589:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 590:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 591:../CMSIS/core_cm0plus.h **** 
 592:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 593:../CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 594:../CMSIS/core_cm0plus.h **** 
 595:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 596:../CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 597:../CMSIS/core_cm0plus.h **** 
 598:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 599:../CMSIS/core_cm0plus.h **** #endif
 600:../CMSIS/core_cm0plus.h **** 
 601:../CMSIS/core_cm0plus.h **** 
 602:../CMSIS/core_cm0plus.h **** /**
 603:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 604:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 605:../CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 606:../CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 607:../CMSIS/core_cm0plus.h ****   @{
 608:../CMSIS/core_cm0plus.h ****  */
 609:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 610:../CMSIS/core_cm0plus.h **** 
 611:../CMSIS/core_cm0plus.h **** 
 612:../CMSIS/core_cm0plus.h **** /**
 613:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 614:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 615:../CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 616:../CMSIS/core_cm0plus.h ****   @{
 617:../CMSIS/core_cm0plus.h ****  */
 618:../CMSIS/core_cm0plus.h **** 
 619:../CMSIS/core_cm0plus.h **** /**
 620:../CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 621:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 622:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 623:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 624:../CMSIS/core_cm0plus.h **** */
 625:../CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 626:../CMSIS/core_cm0plus.h **** 
 627:../CMSIS/core_cm0plus.h **** /**
 628:../CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 629:../CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 630:../CMSIS/core_cm0plus.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 631:../CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 632:../CMSIS/core_cm0plus.h **** */
 633:../CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 634:../CMSIS/core_cm0plus.h **** 
 635:../CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 636:../CMSIS/core_cm0plus.h **** 
 637:../CMSIS/core_cm0plus.h **** 
 638:../CMSIS/core_cm0plus.h **** /**
 639:../CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 640:../CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 641:../CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 642:../CMSIS/core_cm0plus.h ****   @{
 643:../CMSIS/core_cm0plus.h ****  */
 644:../CMSIS/core_cm0plus.h **** 
 645:../CMSIS/core_cm0plus.h **** /* Memory mapping of Core Hardware */
 646:../CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 647:../CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 648:../CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 649:../CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 650:../CMSIS/core_cm0plus.h **** 
 651:../CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 652:../CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 653:../CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 654:../CMSIS/core_cm0plus.h **** 
 655:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 656:../CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 657:../CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 658:../CMSIS/core_cm0plus.h **** #endif
 659:../CMSIS/core_cm0plus.h **** 
 660:../CMSIS/core_cm0plus.h **** /*@} */
 661:../CMSIS/core_cm0plus.h **** 
 662:../CMSIS/core_cm0plus.h **** 
 663:../CMSIS/core_cm0plus.h **** 
 664:../CMSIS/core_cm0plus.h **** /*******************************************************************************
 665:../CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 666:../CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 667:../CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 668:../CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 669:../CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 670:../CMSIS/core_cm0plus.h ****  ******************************************************************************/
 671:../CMSIS/core_cm0plus.h **** /**
 672:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 673:../CMSIS/core_cm0plus.h **** */
 674:../CMSIS/core_cm0plus.h **** 
 675:../CMSIS/core_cm0plus.h **** 
 676:../CMSIS/core_cm0plus.h **** 
 677:../CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 678:../CMSIS/core_cm0plus.h **** /**
 679:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 680:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 681:../CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 682:../CMSIS/core_cm0plus.h ****   @{
 683:../CMSIS/core_cm0plus.h ****  */
 684:../CMSIS/core_cm0plus.h **** 
 685:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_NVIC_VIRTUAL
 686:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 687:../CMSIS/core_cm0plus.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 688:../CMSIS/core_cm0plus.h ****   #endif
 689:../CMSIS/core_cm0plus.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 690:../CMSIS/core_cm0plus.h **** #else
 691:../CMSIS/core_cm0plus.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
 692:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
 693:../CMSIS/core_cm0plus.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 694:../CMSIS/core_cm0plus.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 695:../CMSIS/core_cm0plus.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 696:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 697:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 698:../CMSIS/core_cm0plus.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 699:../CMSIS/core_cm0plus.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
 700:../CMSIS/core_cm0plus.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 701:../CMSIS/core_cm0plus.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 702:../CMSIS/core_cm0plus.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 703:../CMSIS/core_cm0plus.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 704:../CMSIS/core_cm0plus.h **** 
 705:../CMSIS/core_cm0plus.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 706:../CMSIS/core_cm0plus.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 707:../CMSIS/core_cm0plus.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 708:../CMSIS/core_cm0plus.h ****   #endif
 709:../CMSIS/core_cm0plus.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 710:../CMSIS/core_cm0plus.h **** #else
 711:../CMSIS/core_cm0plus.h ****   #define NVIC_SetVector              __NVIC_SetVector
 712:../CMSIS/core_cm0plus.h ****   #define NVIC_GetVector              __NVIC_GetVector
 713:../CMSIS/core_cm0plus.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 714:../CMSIS/core_cm0plus.h **** 
 715:../CMSIS/core_cm0plus.h **** #define NVIC_USER_IRQ_OFFSET          16
 716:../CMSIS/core_cm0plus.h **** 
 717:../CMSIS/core_cm0plus.h **** 
 718:../CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 719:../CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 720:../CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 721:../CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 722:../CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 723:../CMSIS/core_cm0plus.h **** 
 724:../CMSIS/core_cm0plus.h **** 
 725:../CMSIS/core_cm0plus.h **** /**
 726:../CMSIS/core_cm0plus.h ****   \brief   Enable Interrupt
 727:../CMSIS/core_cm0plus.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 728:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 729:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 730:../CMSIS/core_cm0plus.h ****  */
 731:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 732:../CMSIS/core_cm0plus.h **** {
 733:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 734:../CMSIS/core_cm0plus.h ****   {
 735:../CMSIS/core_cm0plus.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 245              		.loc 4 735 0
 246 0082 8023     		movs	r3, #128
 247              	.LBE94:
 248              	.LBE93:
 249              	.LBE92:
 124:../source/main.c **** 
 125:../source/main.c **** 	EnableIRQ(LPUART0_IRQn);
 126:../source/main.c **** 
 127:../source/main.c **** 	UART_EnableInterrupts(UART2, kUART_RxDataRegFullInterruptEnable); //enable LPUART0 receive interru
 250              		.loc 1 127 0
 251 0084 8021     		movs	r1, #128
 252              	.LBB97:
 253              	.LBB96:
 254              	.LBB95:
 255              		.loc 4 735 0
 256 0086 0F4C     		ldr	r4, .L5+24
 257 0088 5B01     		lsls	r3, r3, #5
 258 008a 2360     		str	r3, [r4]
 259              	.LVL19:
 260              	.LBE95:
 261              	.LBE96:
 262              	.LBE97:
 263              		.loc 1 127 0
 264 008c 3800     		movs	r0, r7
 265 008e 8901     		lsls	r1, r1, #6
 266 0090 FFF7FEFF 		bl	UART_EnableInterrupts
 267              	.LVL20:
 268              	.LBB98:
 269              	.LBB99:
 270              	.LBB100:
 271              		.loc 4 735 0
 272 0094 8023     		movs	r3, #128
 273 0096 DB01     		lsls	r3, r3, #7
 274 0098 2360     		str	r3, [r4]
 275              	.LVL21:
 276              	.LBE100:
 277              	.LBE99:
 278              	.LBE98:
 128:../source/main.c **** 	EnableIRQ(UART2_FLEXIO_IRQn);
 129:../source/main.c **** 
 130:../source/main.c **** 	LPUART_EnableInterrupts(LPUART1, kLPUART_RxDataRegFullInterruptEnable); //enable UART0 receive int
 279              		.loc 1 130 0
 280 009a 3100     		movs	r1, r6
 281 009c 2800     		movs	r0, r5
 282 009e FFF7FEFF 		bl	LPUART_EnableInterrupts
 283              	.LVL22:
 284              	.LBB101:
 285              	.LBB102:
 286              	.LBB103:
 287              		.loc 4 735 0
 288 00a2 8023     		movs	r3, #128
 289 00a4 9B01     		lsls	r3, r3, #6
 290 00a6 2360     		str	r3, [r4]
 291              	.LVL23:
 292              	.LBE103:
 293              	.LBE102:
 294              	.LBE101:
 131:../source/main.c **** 	EnableIRQ(LPUART1_IRQn);
 132:../source/main.c **** 
 133:../source/main.c **** }
 295              		.loc 1 133 0
 296 00a8 07B0     		add	sp, sp, #28
 297              	.LVL24:
 298              		@ sp needed
 299 00aa F0BD     		pop	{r4, r5, r6, r7, pc}
 300              	.L6:
 301              		.align	2
 302              	.L5:
 303 00ac 00000000 		.word	uart_config
 304 00b0 00700440 		.word	1074032640
 305 00b4 04100000 		.word	4100
 306 00b8 00C00640 		.word	1074184192
 307 00bc 00400540 		.word	1074085888
 308 00c0 00500540 		.word	1074089984
 309 00c4 00E100E0 		.word	-536813312
 310              		.cfi_endproc
 311              	.LFE128:
 313              		.section	.text.NB_send,"ax",%progbits
 314              		.align	1
 315              		.global	NB_send
 316              		.syntax unified
 317              		.code	16
 318              		.thumb_func
 319              		.fpu softvfp
 321              	NB_send:
 322              	.LFB129:
 134:../source/main.c **** 
 135:../source/main.c **** /*
 136:../source/main.c ****  * Send data to NBiot with LPUART0
 137:../source/main.c ****  * String to be sent is pointed by *data
 138:../source/main.c ****  *
 139:../source/main.c ****  */
 140:../source/main.c **** 
 141:../source/main.c **** void NB_send(char *data)
 142:../source/main.c **** {
 323              		.loc 1 142 0
 324              		.cfi_startproc
 325              		@ args = 0, pretend = 0, frame = 0
 326              		@ frame_needed = 0, uses_anonymous_args = 0
 327              	.LVL25:
 143:../source/main.c **** 
 144:../source/main.c **** 	char c = *data++; //assign c a character from the string and post-increment string pointer
 328              		.loc 1 144 0
 329 0000 0023     		movs	r3, #0
 145:../source/main.c **** 
 146:../source/main.c **** 	while (c)
 147:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 148:../source/main.c **** 
 149:../source/main.c **** 		while (!((LPUART0->STAT) & kLPUART_TxDataRegEmptyFlag))
 330              		.loc 1 149 0
 331 0002 8021     		movs	r1, #128
 142:../source/main.c **** 
 332              		.loc 1 142 0
 333 0004 10B5     		push	{r4, lr}
 334              		.cfi_def_cfa_offset 8
 335              		.cfi_offset 4, -8
 336              		.cfi_offset 14, -4
 337              		.loc 1 149 0
 338 0006 074A     		ldr	r2, .L13
 144:../source/main.c **** 
 339              		.loc 1 144 0
 340 0008 C356     		ldrsb	r3, [r0, r3]
 341              	.LVL26:
 342              		.loc 1 149 0
 343 000a 0904     		lsls	r1, r1, #16
 144:../source/main.c **** 
 344              		.loc 1 144 0
 345 000c 0130     		adds	r0, r0, #1
 346              	.LVL27:
 347              	.L8:
 146:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 348              		.loc 1 146 0
 349 000e 002B     		cmp	r3, #0
 350 0010 00D1     		bne	.L9
 150:../source/main.c **** 		{
 151:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 152:../source/main.c **** 		LPUART0->DATA = c; //write new character to transmit buffer
 153:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 154:../source/main.c **** 	}
 155:../source/main.c **** }
 351              		.loc 1 155 0
 352              		@ sp needed
 353 0012 10BD     		pop	{r4, pc}
 354              	.L9:
 149:../source/main.c **** 		{
 355              		.loc 1 149 0 discriminator 1
 356 0014 5468     		ldr	r4, [r2, #4]
 357 0016 0C42     		tst	r4, r1
 358 0018 FCD0     		beq	.L9
 152:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 359              		.loc 1 152 0
 360 001a D360     		str	r3, [r2, #12]
 361              	.LVL28:
 153:../source/main.c **** 	}
 362              		.loc 1 153 0
 363 001c 0023     		movs	r3, #0
 364              	.LVL29:
 365 001e C356     		ldrsb	r3, [r0, r3]
 366              	.LVL30:
 367 0020 0130     		adds	r0, r0, #1
 368              	.LVL31:
 369 0022 F4E7     		b	.L8
 370              	.L14:
 371              		.align	2
 372              	.L13:
 373 0024 00400540 		.word	1074085888
 374              		.cfi_endproc
 375              	.LFE129:
 377              		.section	.text.GPS_send,"ax",%progbits
 378              		.align	1
 379              		.global	GPS_send
 380              		.syntax unified
 381              		.code	16
 382              		.thumb_func
 383              		.fpu softvfp
 385              	GPS_send:
 386              	.LFB130:
 156:../source/main.c **** 
 157:../source/main.c **** void GPS_send(char *data, uint8_t len)
 158:../source/main.c **** {
 387              		.loc 1 158 0
 388              		.cfi_startproc
 389              		@ args = 0, pretend = 0, frame = 0
 390              		@ frame_needed = 0, uses_anonymous_args = 0
 391              	.LVL32:
 159:../source/main.c **** 
 160:../source/main.c **** 	char c = *data++; //assign c a character from the string and post-increment string pointer
 392              		.loc 1 160 0
 393 0000 0023     		movs	r3, #0
 158:../source/main.c **** 
 394              		.loc 1 158 0
 395 0002 10B5     		push	{r4, lr}
 396              		.cfi_def_cfa_offset 8
 397              		.cfi_offset 4, -8
 398              		.cfi_offset 14, -4
 161:../source/main.c **** 
 162:../source/main.c **** 	for (; len > 0; len--)
 163:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 164:../source/main.c **** 
 165:../source/main.c **** 		while (!((UART2->S1) & 0x80))
 399              		.loc 1 165 0
 400 0004 084C     		ldr	r4, .L20
 160:../source/main.c **** 
 401              		.loc 1 160 0
 402 0006 C356     		ldrsb	r3, [r0, r3]
 403              	.LVL33:
 404 0008 0130     		adds	r0, r0, #1
 405              	.LVL34:
 406              	.L16:
 162:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 407              		.loc 1 162 0 discriminator 1
 408 000a 0029     		cmp	r1, #0
 409 000c 00D1     		bne	.L17
 166:../source/main.c **** 		{
 167:../source/main.c **** 		} //wait until LPUART0 Transmission Complete flag rises, so we can send new char
 168:../source/main.c **** 		UART2->D = c; //write new character to transmit buffer
 169:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 170:../source/main.c **** 	}
 171:../source/main.c **** }
 410              		.loc 1 171 0
 411              		@ sp needed
 412 000e 10BD     		pop	{r4, pc}
 413              	.L17:
 165:../source/main.c **** 		{
 414              		.loc 1 165 0 discriminator 1
 415 0010 2279     		ldrb	r2, [r4, #4]
 416 0012 52B2     		sxtb	r2, r2
 417 0014 002A     		cmp	r2, #0
 418 0016 FBDA     		bge	.L17
 168:../source/main.c **** 		c = *data++; //assign next character to c and post-increment string pointer
 419              		.loc 1 168 0
 420 0018 DBB2     		uxtb	r3, r3
 421 001a E371     		strb	r3, [r4, #7]
 422              	.LVL35:
 169:../source/main.c **** 	}
 423              		.loc 1 169 0
 424 001c 0023     		movs	r3, #0
 425              	.LVL36:
 162:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 426              		.loc 1 162 0
 427 001e 0139     		subs	r1, r1, #1
 428              	.LVL37:
 169:../source/main.c **** 	}
 429              		.loc 1 169 0
 430 0020 C356     		ldrsb	r3, [r0, r3]
 431              	.LVL38:
 162:../source/main.c **** 	{ //loop until c is zero which means string has ended and no more chars has to be sent
 432              		.loc 1 162 0
 433 0022 C9B2     		uxtb	r1, r1
 434              	.LVL39:
 435 0024 0130     		adds	r0, r0, #1
 436              	.LVL40:
 437 0026 F0E7     		b	.L16
 438              	.L21:
 439              		.align	2
 440              	.L20:
 441 0028 00C00640 		.word	1074184192
 442              		.cfi_endproc
 443              	.LFE130:
 445              		.section	.text.PCprint,"ax",%progbits
 446              		.align	1
 447              		.global	PCprint
 448              		.syntax unified
 449              		.code	16
 450              		.thumb_func
 451              		.fpu softvfp
 453              	PCprint:
 454              	.LFB131:
 172:../source/main.c **** 
 173:../source/main.c **** uint8_t PCprint(char *data)
 174:../source/main.c **** {
 455              		.loc 1 174 0
 456              		.cfi_startproc
 457              		@ args = 0, pretend = 0, frame = 0
 458              		@ frame_needed = 0, uses_anonymous_args = 0
 459              	.LVL41:
 460 0000 30B5     		push	{r4, r5, lr}
 461              		.cfi_def_cfa_offset 12
 462              		.cfi_offset 4, -12
 463              		.cfi_offset 5, -8
 464              		.cfi_offset 14, -4
 175:../source/main.c **** 	char c;
 176:../source/main.c **** 	uint8_t len = 0;
 177:../source/main.c **** 	while ((c = *data++))
 178:../source/main.c **** 	{
 179:../source/main.c **** 
 180:../source/main.c **** 		while (!(LPUART1->STAT & kLPUART_TxDataRegEmptyFlag))
 465              		.loc 1 180 0
 466 0002 8025     		movs	r5, #128
 174:../source/main.c **** 	char c;
 467              		.loc 1 174 0
 468 0004 0400     		movs	r4, r0
 177:../source/main.c **** 	{
 469              		.loc 1 177 0
 470 0006 0023     		movs	r3, #0
 471              		.loc 1 180 0
 472 0008 0649     		ldr	r1, .L28
 473 000a 2D04     		lsls	r5, r5, #16
 474              	.LVL42:
 475              	.L23:
 177:../source/main.c **** 	{
 476              		.loc 1 177 0
 477 000c E256     		ldrsb	r2, [r4, r3]
 478 000e D8B2     		uxtb	r0, r3
 479              	.LVL43:
 480 0010 002A     		cmp	r2, #0
 481 0012 00D1     		bne	.L24
 181:../source/main.c **** 		{
 182:../source/main.c **** 		}
 183:../source/main.c **** 
 184:../source/main.c **** 		LPUART1->DATA = c;
 185:../source/main.c **** 		len++;
 186:../source/main.c **** 
 187:../source/main.c **** 	}
 188:../source/main.c **** 
 189:../source/main.c **** 	return len;
 190:../source/main.c **** }
 482              		.loc 1 190 0
 483              		@ sp needed
 484              	.LVL44:
 485 0014 30BD     		pop	{r4, r5, pc}
 486              	.LVL45:
 487              	.L24:
 180:../source/main.c **** 		{
 488              		.loc 1 180 0 discriminator 1
 489 0016 4868     		ldr	r0, [r1, #4]
 490 0018 2842     		tst	r0, r5
 491 001a FCD0     		beq	.L24
 184:../source/main.c **** 		len++;
 492              		.loc 1 184 0
 493 001c CA60     		str	r2, [r1, #12]
 494              	.LVL46:
 495 001e 0133     		adds	r3, r3, #1
 496              	.LVL47:
 497 0020 F4E7     		b	.L23
 498              	.L29:
 499 0022 C046     		.align	2
 500              	.L28:
 501 0024 00500540 		.word	1074089984
 502              		.cfi_endproc
 503              	.LFE131:
 505              		.global	__aeabi_uidiv
 506              		.section	.text.startup.main,"ax",%progbits
 507              		.align	1
 508              		.global	main
 509              		.syntax unified
 510              		.code	16
 511              		.thumb_func
 512              		.fpu softvfp
 514              	main:
 515              	.LFB132:
 191:../source/main.c **** 
 192:../source/main.c **** int main(void)
 193:../source/main.c **** {
 516              		.loc 1 193 0
 517              		.cfi_startproc
 518              		@ args = 0, pretend = 0, frame = 560
 519              		@ frame_needed = 0, uses_anonymous_args = 0
 194:../source/main.c **** 
 195:../source/main.c **** 	PMC->REGSC |= 0x08;	//acknowledge wake up to voltage regulator module, this is needed with LLWU wa
 520              		.loc 1 195 0
 521 0000 0823     		movs	r3, #8
 193:../source/main.c **** 
 522              		.loc 1 193 0
 523 0002 F0B5     		push	{r4, r5, r6, r7, lr}
 524              		.cfi_def_cfa_offset 20
 525              		.cfi_offset 4, -20
 526              		.cfi_offset 5, -16
 527              		.cfi_offset 6, -12
 528              		.cfi_offset 7, -8
 529              		.cfi_offset 14, -4
 530              		.loc 1 195 0
 531 0004 D54A     		ldr	r2, .L77
 193:../source/main.c **** 
 532              		.loc 1 193 0
 533 0006 D64C     		ldr	r4, .L77+4
 534              		.loc 1 195 0
 535 0008 9178     		ldrb	r1, [r2, #2]
 193:../source/main.c **** 
 536              		.loc 1 193 0
 537 000a A544     		add	sp, sp, r4
 538              		.cfi_def_cfa_offset 584
 539              		.loc 1 195 0
 540 000c 0B43     		orrs	r3, r1
 541 000e 9370     		strb	r3, [r2, #2]
 542              	.LVL48:
 543              	.LBB138:
 544              	.LBB139:
 545              		.loc 4 735 0
 546 0010 8022     		movs	r2, #128
 547 0012 D44B     		ldr	r3, .L77+8
 548 0014 1A60     		str	r2, [r3]
 549              	.LVL49:
 550              	.LBE139:
 551              	.LBE138:
 196:../source/main.c **** 
 197:../source/main.c **** 	NVIC_EnableIRQ(LLWU_IRQn);//enable LLWU interrupts. if we wake up from VLLS mode, it means that ne
 198:../source/main.c **** 							  //will jump to the LLWU interrupt vector
 199:../source/main.c **** 	struct reindeerData_t reindeerData; //create struct for our reindeer data that will be sent
 200:../source/main.c **** 	char mqttMessage[450];
 201:../source/main.c **** 
 202:../source/main.c **** 	BOARD_InitPins();	//init all physical pins
 552              		.loc 1 202 0
 553 0016 FFF7FEFF 		bl	BOARD_InitPins
 554              	.LVL50:
 203:../source/main.c **** 	BOARD_BootClockVLPR(); //by uncommenting this we can use FRDM 50Mhz external clock, but will not w
 555              		.loc 1 203 0
 556 001a FFF7FEFF 		bl	BOARD_BootClockVLPR
 557              	.LVL51:
 204:../source/main.c **** 
 205:../source/main.c **** 	SysTick_Config(BOARD_DEBUG_UART_CLK_FREQ / 1000); //setup SysTick timer for 1ms interval for delay
 558              		.loc 1 205 0
 559 001e FFF7FEFF 		bl	CLOCK_GetCoreSysClkFreq
 560              	.LVL52:
 561 0022 FA21     		movs	r1, #250
 562 0024 8900     		lsls	r1, r1, #2
 563 0026 FFF7FEFF 		bl	__aeabi_uidiv
 564              	.LVL53:
 565              	.LBB140:
 566              	.LBB141:
 736:../CMSIS/core_cm0plus.h ****   }
 737:../CMSIS/core_cm0plus.h **** }
 738:../CMSIS/core_cm0plus.h **** 
 739:../CMSIS/core_cm0plus.h **** 
 740:../CMSIS/core_cm0plus.h **** /**
 741:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Enable status
 742:../CMSIS/core_cm0plus.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 743:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 744:../CMSIS/core_cm0plus.h ****   \return             0  Interrupt is not enabled.
 745:../CMSIS/core_cm0plus.h ****   \return             1  Interrupt is enabled.
 746:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 747:../CMSIS/core_cm0plus.h ****  */
 748:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 749:../CMSIS/core_cm0plus.h **** {
 750:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 751:../CMSIS/core_cm0plus.h ****   {
 752:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 753:../CMSIS/core_cm0plus.h ****   }
 754:../CMSIS/core_cm0plus.h ****   else
 755:../CMSIS/core_cm0plus.h ****   {
 756:../CMSIS/core_cm0plus.h ****     return(0U);
 757:../CMSIS/core_cm0plus.h ****   }
 758:../CMSIS/core_cm0plus.h **** }
 759:../CMSIS/core_cm0plus.h **** 
 760:../CMSIS/core_cm0plus.h **** 
 761:../CMSIS/core_cm0plus.h **** /**
 762:../CMSIS/core_cm0plus.h ****   \brief   Disable Interrupt
 763:../CMSIS/core_cm0plus.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 764:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 765:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 766:../CMSIS/core_cm0plus.h ****  */
 767:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 768:../CMSIS/core_cm0plus.h **** {
 769:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 770:../CMSIS/core_cm0plus.h ****   {
 771:../CMSIS/core_cm0plus.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 772:../CMSIS/core_cm0plus.h ****     __DSB();
 773:../CMSIS/core_cm0plus.h ****     __ISB();
 774:../CMSIS/core_cm0plus.h ****   }
 775:../CMSIS/core_cm0plus.h **** }
 776:../CMSIS/core_cm0plus.h **** 
 777:../CMSIS/core_cm0plus.h **** 
 778:../CMSIS/core_cm0plus.h **** /**
 779:../CMSIS/core_cm0plus.h ****   \brief   Get Pending Interrupt
 780:../CMSIS/core_cm0plus.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 781:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 782:../CMSIS/core_cm0plus.h ****   \return             0  Interrupt status is not pending.
 783:../CMSIS/core_cm0plus.h ****   \return             1  Interrupt status is pending.
 784:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 785:../CMSIS/core_cm0plus.h ****  */
 786:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 787:../CMSIS/core_cm0plus.h **** {
 788:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 789:../CMSIS/core_cm0plus.h ****   {
 790:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 791:../CMSIS/core_cm0plus.h ****   }
 792:../CMSIS/core_cm0plus.h ****   else
 793:../CMSIS/core_cm0plus.h ****   {
 794:../CMSIS/core_cm0plus.h ****     return(0U);
 795:../CMSIS/core_cm0plus.h ****   }
 796:../CMSIS/core_cm0plus.h **** }
 797:../CMSIS/core_cm0plus.h **** 
 798:../CMSIS/core_cm0plus.h **** 
 799:../CMSIS/core_cm0plus.h **** /**
 800:../CMSIS/core_cm0plus.h ****   \brief   Set Pending Interrupt
 801:../CMSIS/core_cm0plus.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 802:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 803:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 804:../CMSIS/core_cm0plus.h ****  */
 805:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 806:../CMSIS/core_cm0plus.h **** {
 807:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 808:../CMSIS/core_cm0plus.h ****   {
 809:../CMSIS/core_cm0plus.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 810:../CMSIS/core_cm0plus.h ****   }
 811:../CMSIS/core_cm0plus.h **** }
 812:../CMSIS/core_cm0plus.h **** 
 813:../CMSIS/core_cm0plus.h **** 
 814:../CMSIS/core_cm0plus.h **** /**
 815:../CMSIS/core_cm0plus.h ****   \brief   Clear Pending Interrupt
 816:../CMSIS/core_cm0plus.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 817:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Device specific interrupt number.
 818:../CMSIS/core_cm0plus.h ****   \note    IRQn must not be negative.
 819:../CMSIS/core_cm0plus.h ****  */
 820:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 821:../CMSIS/core_cm0plus.h **** {
 822:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 823:../CMSIS/core_cm0plus.h ****   {
 824:../CMSIS/core_cm0plus.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 825:../CMSIS/core_cm0plus.h ****   }
 826:../CMSIS/core_cm0plus.h **** }
 827:../CMSIS/core_cm0plus.h **** 
 828:../CMSIS/core_cm0plus.h **** 
 829:../CMSIS/core_cm0plus.h **** /**
 830:../CMSIS/core_cm0plus.h ****   \brief   Set Interrupt Priority
 831:../CMSIS/core_cm0plus.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 832:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 833:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 834:../CMSIS/core_cm0plus.h ****   \param [in]      IRQn  Interrupt number.
 835:../CMSIS/core_cm0plus.h ****   \param [in]  priority  Priority to set.
 836:../CMSIS/core_cm0plus.h ****   \note    The priority cannot be set for every processor exception.
 837:../CMSIS/core_cm0plus.h ****  */
 838:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 839:../CMSIS/core_cm0plus.h **** {
 840:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 841:../CMSIS/core_cm0plus.h ****   {
 842:../CMSIS/core_cm0plus.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 843:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 844:../CMSIS/core_cm0plus.h ****   }
 845:../CMSIS/core_cm0plus.h ****   else
 846:../CMSIS/core_cm0plus.h ****   {
 847:../CMSIS/core_cm0plus.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 848:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 849:../CMSIS/core_cm0plus.h ****   }
 850:../CMSIS/core_cm0plus.h **** }
 851:../CMSIS/core_cm0plus.h **** 
 852:../CMSIS/core_cm0plus.h **** 
 853:../CMSIS/core_cm0plus.h **** /**
 854:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Priority
 855:../CMSIS/core_cm0plus.h ****   \details Reads the priority of a device specific interrupt or a processor exception.
 856:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 857:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 858:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn  Interrupt number.
 859:../CMSIS/core_cm0plus.h ****   \return             Interrupt Priority.
 860:../CMSIS/core_cm0plus.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 861:../CMSIS/core_cm0plus.h ****  */
 862:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
 863:../CMSIS/core_cm0plus.h **** {
 864:../CMSIS/core_cm0plus.h **** 
 865:../CMSIS/core_cm0plus.h ****   if ((int32_t)(IRQn) >= 0)
 866:../CMSIS/core_cm0plus.h ****   {
 867:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 868:../CMSIS/core_cm0plus.h ****   }
 869:../CMSIS/core_cm0plus.h ****   else
 870:../CMSIS/core_cm0plus.h ****   {
 871:../CMSIS/core_cm0plus.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 872:../CMSIS/core_cm0plus.h ****   }
 873:../CMSIS/core_cm0plus.h **** }
 874:../CMSIS/core_cm0plus.h **** 
 875:../CMSIS/core_cm0plus.h **** 
 876:../CMSIS/core_cm0plus.h **** /**
 877:../CMSIS/core_cm0plus.h ****   \brief   Set Interrupt Vector
 878:../CMSIS/core_cm0plus.h ****   \details Sets an interrupt vector in SRAM based interrupt vector table.
 879:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 880:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 881:../CMSIS/core_cm0plus.h ****            VTOR must been relocated to SRAM before.
 882:../CMSIS/core_cm0plus.h ****            If VTOR is not present address 0 must be mapped to SRAM.
 883:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn      Interrupt number
 884:../CMSIS/core_cm0plus.h ****   \param [in]   vector    Address of interrupt handler function
 885:../CMSIS/core_cm0plus.h ****  */
 886:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
 887:../CMSIS/core_cm0plus.h **** {
 888:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 889:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
 890:../CMSIS/core_cm0plus.h **** #else
 891:../CMSIS/core_cm0plus.h ****     uint32_t *vectors = (uint32_t *)0x0U;
 892:../CMSIS/core_cm0plus.h **** #endif
 893:../CMSIS/core_cm0plus.h ****   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
 894:../CMSIS/core_cm0plus.h **** }
 895:../CMSIS/core_cm0plus.h **** 
 896:../CMSIS/core_cm0plus.h **** 
 897:../CMSIS/core_cm0plus.h **** /**
 898:../CMSIS/core_cm0plus.h ****   \brief   Get Interrupt Vector
 899:../CMSIS/core_cm0plus.h ****   \details Reads an interrupt vector from interrupt vector table.
 900:../CMSIS/core_cm0plus.h ****            The interrupt number can be positive to specify a device specific interrupt,
 901:../CMSIS/core_cm0plus.h ****            or negative to specify a processor exception.
 902:../CMSIS/core_cm0plus.h ****   \param [in]   IRQn      Interrupt number.
 903:../CMSIS/core_cm0plus.h ****   \return                 Address of interrupt handler function
 904:../CMSIS/core_cm0plus.h ****  */
 905:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
 906:../CMSIS/core_cm0plus.h **** {
 907:../CMSIS/core_cm0plus.h **** #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
 908:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
 909:../CMSIS/core_cm0plus.h **** #else
 910:../CMSIS/core_cm0plus.h ****   uint32_t *vectors = (uint32_t *)0x0U;
 911:../CMSIS/core_cm0plus.h **** #endif
 912:../CMSIS/core_cm0plus.h ****   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
 913:../CMSIS/core_cm0plus.h **** 
 914:../CMSIS/core_cm0plus.h **** }
 915:../CMSIS/core_cm0plus.h **** 
 916:../CMSIS/core_cm0plus.h **** 
 917:../CMSIS/core_cm0plus.h **** /**
 918:../CMSIS/core_cm0plus.h ****   \brief   System Reset
 919:../CMSIS/core_cm0plus.h ****   \details Initiates a system reset request to reset the MCU.
 920:../CMSIS/core_cm0plus.h ****  */
 921:../CMSIS/core_cm0plus.h **** __STATIC_INLINE void __NVIC_SystemReset(void)
 922:../CMSIS/core_cm0plus.h **** {
 923:../CMSIS/core_cm0plus.h ****   __DSB();                                                          /* Ensure all outstanding memor
 924:../CMSIS/core_cm0plus.h ****                                                                        buffered write are completed
 925:../CMSIS/core_cm0plus.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 926:../CMSIS/core_cm0plus.h ****                  SCB_AIRCR_SYSRESETREQ_Msk);
 927:../CMSIS/core_cm0plus.h ****   __DSB();                                                          /* Ensure completion of memory 
 928:../CMSIS/core_cm0plus.h **** 
 929:../CMSIS/core_cm0plus.h ****   for(;;)                                                           /* wait until reset */
 930:../CMSIS/core_cm0plus.h ****   {
 931:../CMSIS/core_cm0plus.h ****     __NOP();
 932:../CMSIS/core_cm0plus.h ****   }
 933:../CMSIS/core_cm0plus.h **** }
 934:../CMSIS/core_cm0plus.h **** 
 935:../CMSIS/core_cm0plus.h **** /*@} end of CMSIS_Core_NVICFunctions */
 936:../CMSIS/core_cm0plus.h **** 
 937:../CMSIS/core_cm0plus.h **** /* ##########################  MPU functions  #################################### */
 938:../CMSIS/core_cm0plus.h **** 
 939:../CMSIS/core_cm0plus.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
 940:../CMSIS/core_cm0plus.h **** 
 941:../CMSIS/core_cm0plus.h **** #include "mpu_armv7.h"
 942:../CMSIS/core_cm0plus.h **** 
 943:../CMSIS/core_cm0plus.h **** #endif
 944:../CMSIS/core_cm0plus.h **** 
 945:../CMSIS/core_cm0plus.h **** /* ##########################  FPU functions  #################################### */
 946:../CMSIS/core_cm0plus.h **** /**
 947:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 948:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FpuFunctions FPU Functions
 949:../CMSIS/core_cm0plus.h ****   \brief    Function that provides FPU type.
 950:../CMSIS/core_cm0plus.h ****   @{
 951:../CMSIS/core_cm0plus.h ****  */
 952:../CMSIS/core_cm0plus.h **** 
 953:../CMSIS/core_cm0plus.h **** /**
 954:../CMSIS/core_cm0plus.h ****   \brief   get FPU type
 955:../CMSIS/core_cm0plus.h ****   \details returns the FPU type
 956:../CMSIS/core_cm0plus.h ****   \returns
 957:../CMSIS/core_cm0plus.h ****    - \b  0: No FPU
 958:../CMSIS/core_cm0plus.h ****    - \b  1: Single precision FPU
 959:../CMSIS/core_cm0plus.h ****    - \b  2: Double + Single precision FPU
 960:../CMSIS/core_cm0plus.h ****  */
 961:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t SCB_GetFPUType(void)
 962:../CMSIS/core_cm0plus.h **** {
 963:../CMSIS/core_cm0plus.h ****     return 0U;           /* No FPU */
 964:../CMSIS/core_cm0plus.h **** }
 965:../CMSIS/core_cm0plus.h **** 
 966:../CMSIS/core_cm0plus.h **** 
 967:../CMSIS/core_cm0plus.h **** /*@} end of CMSIS_Core_FpuFunctions */
 968:../CMSIS/core_cm0plus.h **** 
 969:../CMSIS/core_cm0plus.h **** 
 970:../CMSIS/core_cm0plus.h **** 
 971:../CMSIS/core_cm0plus.h **** /* ##################################    SysTick function  ########################################
 972:../CMSIS/core_cm0plus.h **** /**
 973:../CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 974:../CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
 975:../CMSIS/core_cm0plus.h ****   \brief    Functions that configure the System.
 976:../CMSIS/core_cm0plus.h ****   @{
 977:../CMSIS/core_cm0plus.h ****  */
 978:../CMSIS/core_cm0plus.h **** 
 979:../CMSIS/core_cm0plus.h **** #if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
 980:../CMSIS/core_cm0plus.h **** 
 981:../CMSIS/core_cm0plus.h **** /**
 982:../CMSIS/core_cm0plus.h ****   \brief   System Tick Configuration
 983:../CMSIS/core_cm0plus.h ****   \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
 984:../CMSIS/core_cm0plus.h ****            Counter is in free running mode to generate periodic interrupts.
 985:../CMSIS/core_cm0plus.h ****   \param [in]  ticks  Number of ticks between two interrupts.
 986:../CMSIS/core_cm0plus.h ****   \return          0  Function succeeded.
 987:../CMSIS/core_cm0plus.h ****   \return          1  Function failed.
 988:../CMSIS/core_cm0plus.h ****   \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
 989:../CMSIS/core_cm0plus.h ****            function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.
 990:../CMSIS/core_cm0plus.h ****            must contain a vendor-specific implementation of this function.
 991:../CMSIS/core_cm0plus.h ****  */
 992:../CMSIS/core_cm0plus.h **** __STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
 993:../CMSIS/core_cm0plus.h **** {
 994:../CMSIS/core_cm0plus.h ****   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 567              		.loc 4 994 0
 568 002a CF4B     		ldr	r3, .L77+12
 569 002c 0138     		subs	r0, r0, #1
 570 002e 9842     		cmp	r0, r3
 571 0030 0DD8     		bhi	.L31
 572              	.LBB142:
 573              	.LBB143:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 574              		.loc 4 847 0
 575 0032 C021     		movs	r1, #192
 576              	.LBE143:
 577              	.LBE142:
 995:../CMSIS/core_cm0plus.h ****   {
 996:../CMSIS/core_cm0plus.h ****     return (1UL);                                                   /* Reload value impossible */
 997:../CMSIS/core_cm0plus.h ****   }
 998:../CMSIS/core_cm0plus.h **** 
 999:../CMSIS/core_cm0plus.h ****   SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 578              		.loc 4 999 0
 579 0034 CD4A     		ldr	r2, .L77+16
 580              	.LBB146:
 581              	.LBB144:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 582              		.loc 4 847 0
 583 0036 0906     		lsls	r1, r1, #24
 584              	.LBE144:
 585              	.LBE146:
 586              		.loc 4 999 0
 587 0038 5060     		str	r0, [r2, #4]
 588              	.LVL54:
 589              	.LBB147:
 590              	.LBB145:
 847:../CMSIS/core_cm0plus.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 591              		.loc 4 847 0
 592 003a CD48     		ldr	r0, .L77+20
 593 003c 036A     		ldr	r3, [r0, #32]
 594 003e 1B02     		lsls	r3, r3, #8
 595 0040 1B0A     		lsrs	r3, r3, #8
 596 0042 0B43     		orrs	r3, r1
 597 0044 0362     		str	r3, [r0, #32]
 598              	.LVL55:
 599              	.LBE145:
 600              	.LBE147:
1000:../CMSIS/core_cm0plus.h ****   NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Int
1001:../CMSIS/core_cm0plus.h ****   SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Val
 601              		.loc 4 1001 0
 602 0046 0023     		movs	r3, #0
 603 0048 9360     		str	r3, [r2, #8]
1002:../CMSIS/core_cm0plus.h ****   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 604              		.loc 4 1002 0
 605 004a 0733     		adds	r3, r3, #7
 606 004c 1360     		str	r3, [r2]
 607              	.L31:
 608              	.LBE141:
 609              	.LBE140:
 206:../source/main.c **** 
 207:../source/main.c **** 	initI2C();
 610              		.loc 1 207 0
 611 004e FFF7FEFF 		bl	initI2C
 612              	.LVL56:
 208:../source/main.c **** 	configure_acc();
 209:../source/main.c **** 	acc_init();
 210:../source/main.c **** 	//initAdc();
 211:../source/main.c **** 	initUART();
 212:../source/main.c **** 
 213:../source/main.c **** 	static const gpio_pin_config_t LED_configOutput =
 214:../source/main.c **** 	{ kGPIO_DigitalOutput, /* use as output pin */
 215:../source/main.c **** 	1, /* initial value */
 216:../source/main.c **** 	};
 217:../source/main.c **** 	GPIO_PinInit(GPIOA, 4u, &LED_configOutput);	//blue led as output
 613              		.loc 1 217 0
 614 0052 C84C     		ldr	r4, .L77+24
 208:../source/main.c **** 	configure_acc();
 615              		.loc 1 208 0
 616 0054 FFF7FEFF 		bl	configure_acc
 617              	.LVL57:
 209:../source/main.c **** 	//initAdc();
 618              		.loc 1 209 0
 619 0058 FFF7FEFF 		bl	acc_init
 620              	.LVL58:
 211:../source/main.c **** 
 621              		.loc 1 211 0
 622 005c FFF7FEFF 		bl	initUART
 623              	.LVL59:
 624              		.loc 1 217 0
 625 0060 C54F     		ldr	r7, .L77+28
 626 0062 0421     		movs	r1, #4
 627 0064 3A00     		movs	r2, r7
 628 0066 2000     		movs	r0, r4
 629 0068 FFF7FEFF 		bl	GPIO_PinInit
 630              	.LVL60:
 218:../source/main.c **** 
 219:../source/main.c **** 	char buf[30];
 220:../source/main.c **** 
 221:../source/main.c **** 	//CLOCK_EnableClock(kCLOCK_Lptmr0);
 222:../source/main.c **** 	//sprintf(buf, "lptimer int flag: %lx\r\n", LPTMR0->CSR);
 223:../source/main.c **** 	PCprint(buf);
 631              		.loc 1 223 0
 632 006c 09A8     		add	r0, sp, #36
 633 006e FFF7FEFF 		bl	PCprint
 634              	.LVL61:
 224:../source/main.c **** 
 225:../source/main.c **** 	initTimer();
 635              		.loc 1 225 0
 636 0072 FFF7FEFF 		bl	initTimer
 637              	.LVL62:
 638              	.LBB148:
 639              	.LBB149:
 640              		.file 5 "../drivers/fsl_smc.h"
   1:../drivers/fsl_smc.h **** /*
   2:../drivers/fsl_smc.h ****  * The Clear BSD License
   3:../drivers/fsl_smc.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_smc.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_smc.h ****  * All rights reserved.
   6:../drivers/fsl_smc.h ****  *
   7:../drivers/fsl_smc.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_smc.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_smc.h ****  * that the following conditions are met:
  10:../drivers/fsl_smc.h ****  *
  11:../drivers/fsl_smc.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_smc.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_smc.h ****  *
  14:../drivers/fsl_smc.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_smc.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_smc.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_smc.h ****  *
  18:../drivers/fsl_smc.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_smc.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_smc.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_smc.h ****  *
  22:../drivers/fsl_smc.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_smc.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_smc.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_smc.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_smc.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_smc.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_smc.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_smc.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_smc.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_smc.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_smc.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_smc.h ****  */
  34:../drivers/fsl_smc.h **** 
  35:../drivers/fsl_smc.h **** #ifndef _FSL_SMC_H_
  36:../drivers/fsl_smc.h **** #define _FSL_SMC_H_
  37:../drivers/fsl_smc.h **** 
  38:../drivers/fsl_smc.h **** #include "fsl_common.h"
  39:../drivers/fsl_smc.h **** 
  40:../drivers/fsl_smc.h **** /*! @addtogroup smc */
  41:../drivers/fsl_smc.h **** /*! @{ */
  42:../drivers/fsl_smc.h **** 
  43:../drivers/fsl_smc.h **** /*******************************************************************************
  44:../drivers/fsl_smc.h ****  * Definitions
  45:../drivers/fsl_smc.h ****  ******************************************************************************/
  46:../drivers/fsl_smc.h **** 
  47:../drivers/fsl_smc.h **** /*! @name Driver version */
  48:../drivers/fsl_smc.h **** /*@{*/
  49:../drivers/fsl_smc.h **** /*! @brief SMC driver version 2.0.3. */
  50:../drivers/fsl_smc.h **** #define FSL_SMC_DRIVER_VERSION (MAKE_VERSION(2, 0, 3))
  51:../drivers/fsl_smc.h **** /*@}*/
  52:../drivers/fsl_smc.h **** 
  53:../drivers/fsl_smc.h **** /*!
  54:../drivers/fsl_smc.h ****  * @brief Power Modes Protection
  55:../drivers/fsl_smc.h ****  */
  56:../drivers/fsl_smc.h **** typedef enum _smc_power_mode_protection
  57:../drivers/fsl_smc.h **** {
  58:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
  59:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeVlls = SMC_PMPROT_AVLLS_MASK, /*!< Allow Very-low-leakage Stop Mode. */
  60:../drivers/fsl_smc.h **** #endif
  61:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
  62:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeLls = SMC_PMPROT_ALLS_MASK, /*!< Allow Low-leakage Stop Mode.      */
  63:../drivers/fsl_smc.h **** #endif                                             /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
  64:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeVlp = SMC_PMPROT_AVLP_MASK, /*!< Allow Very-Low-power Mode.        */
  65:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
  66:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeHsrun = SMC_PMPROT_AHSRUN_MASK, /*!< Allow High-speed Run mode.        */
  67:../drivers/fsl_smc.h **** #endif                                                 /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE *
  68:../drivers/fsl_smc.h ****     kSMC_AllowPowerModeAll = (0U
  69:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
  70:../drivers/fsl_smc.h ****                               |
  71:../drivers/fsl_smc.h ****                               SMC_PMPROT_AVLLS_MASK
  72:../drivers/fsl_smc.h **** #endif
  73:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
  74:../drivers/fsl_smc.h ****                               |
  75:../drivers/fsl_smc.h ****                               SMC_PMPROT_ALLS_MASK
  76:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
  77:../drivers/fsl_smc.h ****                               |
  78:../drivers/fsl_smc.h ****                               SMC_PMPROT_AVLP_MASK
  79:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
  80:../drivers/fsl_smc.h ****                               |
  81:../drivers/fsl_smc.h ****                               kSMC_AllowPowerModeHsrun
  82:../drivers/fsl_smc.h **** #endif                          /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
  83:../drivers/fsl_smc.h ****                               ) /*!< Allow all power mode.              */
  84:../drivers/fsl_smc.h **** } smc_power_mode_protection_t;
  85:../drivers/fsl_smc.h **** 
  86:../drivers/fsl_smc.h **** /*!
  87:../drivers/fsl_smc.h ****  * @brief Power Modes in PMSTAT
  88:../drivers/fsl_smc.h ****  */
  89:../drivers/fsl_smc.h **** typedef enum _smc_power_state
  90:../drivers/fsl_smc.h **** {
  91:../drivers/fsl_smc.h ****     kSMC_PowerStateRun = 0x01U << 0U,  /*!< 0000_0001 - Current power mode is RUN   */
  92:../drivers/fsl_smc.h ****     kSMC_PowerStateStop = 0x01U << 1U, /*!< 0000_0010 - Current power mode is STOP  */
  93:../drivers/fsl_smc.h ****     kSMC_PowerStateVlpr = 0x01U << 2U, /*!< 0000_0100 - Current power mode is VLPR  */
  94:../drivers/fsl_smc.h ****     kSMC_PowerStateVlpw = 0x01U << 3U, /*!< 0000_1000 - Current power mode is VLPW  */
  95:../drivers/fsl_smc.h ****     kSMC_PowerStateVlps = 0x01U << 4U, /*!< 0001_0000 - Current power mode is VLPS  */
  96:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
  97:../drivers/fsl_smc.h ****     kSMC_PowerStateLls = 0x01U << 5U, /*!< 0010_0000 - Current power mode is LLS   */
  98:../drivers/fsl_smc.h **** #endif                                /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
  99:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 100:../drivers/fsl_smc.h ****     kSMC_PowerStateVlls = 0x01U << 6U, /*!< 0100_0000 - Current power mode is VLLS  */
 101:../drivers/fsl_smc.h **** #endif
 102:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
 103:../drivers/fsl_smc.h ****     kSMC_PowerStateHsrun = 0x01U << 7U /*!< 1000_0000 - Current power mode is HSRUN */
 104:../drivers/fsl_smc.h **** #endif                                 /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
 105:../drivers/fsl_smc.h **** } smc_power_state_t;
 106:../drivers/fsl_smc.h **** 
 107:../drivers/fsl_smc.h **** /*!
 108:../drivers/fsl_smc.h ****  * @brief Run mode definition
 109:../drivers/fsl_smc.h ****  */
 110:../drivers/fsl_smc.h **** typedef enum _smc_run_mode
 111:../drivers/fsl_smc.h **** {
 112:../drivers/fsl_smc.h ****     kSMC_RunNormal = 0U, /*!< Normal RUN mode.             */
 113:../drivers/fsl_smc.h ****     kSMC_RunVlpr = 2U,   /*!< Very-low-power RUN mode.     */
 114:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
 115:../drivers/fsl_smc.h ****     kSMC_Hsrun = 3U /*!< High-speed Run mode (HSRUN). */
 116:../drivers/fsl_smc.h **** #endif              /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */
 117:../drivers/fsl_smc.h **** } smc_run_mode_t;
 118:../drivers/fsl_smc.h **** 
 119:../drivers/fsl_smc.h **** /*!
 120:../drivers/fsl_smc.h ****  * @brief Stop mode definition
 121:../drivers/fsl_smc.h ****  */
 122:../drivers/fsl_smc.h **** typedef enum _smc_stop_mode
 123:../drivers/fsl_smc.h **** {
 124:../drivers/fsl_smc.h ****     kSMC_StopNormal = 0U, /*!< Normal STOP mode.           */
 125:../drivers/fsl_smc.h ****     kSMC_StopVlps = 2U,   /*!< Very-low-power STOP mode.   */
 126:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MOD
 127:../drivers/fsl_smc.h ****     kSMC_StopLls = 3U, /*!< Low-leakage Stop mode.      */
 128:../drivers/fsl_smc.h **** #endif                 /* FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE */
 129:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 130:../drivers/fsl_smc.h ****     kSMC_StopVlls = 4U /*!< Very-low-leakage Stop mode. */
 131:../drivers/fsl_smc.h **** #endif
 132:../drivers/fsl_smc.h **** } smc_stop_mode_t;
 133:../drivers/fsl_smc.h **** 
 134:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG) ||     \
 135:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) && FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) || \
 136:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 137:../drivers/fsl_smc.h **** /*!
 138:../drivers/fsl_smc.h ****  * @brief VLLS/LLS stop sub mode definition
 139:../drivers/fsl_smc.h ****  */
 140:../drivers/fsl_smc.h **** typedef enum _smc_stop_submode
 141:../drivers/fsl_smc.h **** {
 142:../drivers/fsl_smc.h ****     kSMC_StopSub0 = 0U, /*!< Stop submode 0, for VLLS0/LLS0. */
 143:../drivers/fsl_smc.h ****     kSMC_StopSub1 = 1U, /*!< Stop submode 1, for VLLS1/LLS1. */
 144:../drivers/fsl_smc.h ****     kSMC_StopSub2 = 2U, /*!< Stop submode 2, for VLLS2/LLS2. */
 145:../drivers/fsl_smc.h ****     kSMC_StopSub3 = 3U  /*!< Stop submode 3, for VLLS3/LLS3. */
 146:../drivers/fsl_smc.h **** } smc_stop_submode_t;
 147:../drivers/fsl_smc.h **** #endif
 148:../drivers/fsl_smc.h **** 
 149:../drivers/fsl_smc.h **** /*!
 150:../drivers/fsl_smc.h ****  * @brief Partial STOP option
 151:../drivers/fsl_smc.h ****  */
 152:../drivers/fsl_smc.h **** typedef enum _smc_partial_stop_mode
 153:../drivers/fsl_smc.h **** {
 154:../drivers/fsl_smc.h ****     kSMC_PartialStop = 0U,  /*!< STOP - Normal Stop mode*/
 155:../drivers/fsl_smc.h ****     kSMC_PartialStop1 = 1U, /*!< Partial Stop with both system and bus clocks disabled*/
 156:../drivers/fsl_smc.h ****     kSMC_PartialStop2 = 2U, /*!< Partial Stop with system clock disabled and bus clock enabled*/
 157:../drivers/fsl_smc.h **** } smc_partial_stop_option_t;
 158:../drivers/fsl_smc.h **** 
 159:../drivers/fsl_smc.h **** /*!
 160:../drivers/fsl_smc.h ****  * @brief SMC configuration status.
 161:../drivers/fsl_smc.h ****  */
 162:../drivers/fsl_smc.h **** enum _smc_status
 163:../drivers/fsl_smc.h **** {
 164:../drivers/fsl_smc.h ****     kStatus_SMC_StopAbort = MAKE_STATUS(kStatusGroup_POWER, 0) /*!< Entering Stop mode is abort*/
 165:../drivers/fsl_smc.h **** };
 166:../drivers/fsl_smc.h **** 
 167:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERID) && FSL_FEATURE_SMC_HAS_VERID)
 168:../drivers/fsl_smc.h **** /*!
 169:../drivers/fsl_smc.h ****  * @brief IP version ID definition.
 170:../drivers/fsl_smc.h ****  */
 171:../drivers/fsl_smc.h **** typedef struct _smc_version_id
 172:../drivers/fsl_smc.h **** {
 173:../drivers/fsl_smc.h ****     uint16_t feature; /*!< Feature Specification Number. */
 174:../drivers/fsl_smc.h ****     uint8_t minor;    /*!< Minor version number.         */
 175:../drivers/fsl_smc.h ****     uint8_t major;    /*!< Major version number.         */
 176:../drivers/fsl_smc.h **** } smc_version_id_t;
 177:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_VERID */
 178:../drivers/fsl_smc.h **** 
 179:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_PARAM) && FSL_FEATURE_SMC_HAS_PARAM)
 180:../drivers/fsl_smc.h **** /*!
 181:../drivers/fsl_smc.h ****  * @brief IP parameter definition.
 182:../drivers/fsl_smc.h ****  */
 183:../drivers/fsl_smc.h **** typedef struct _smc_param
 184:../drivers/fsl_smc.h **** {
 185:../drivers/fsl_smc.h ****     bool hsrunEnable; /*!< HSRUN mode enable. */
 186:../drivers/fsl_smc.h ****     bool llsEnable;   /*!< LLS mode enable.   */
 187:../drivers/fsl_smc.h ****     bool lls2Enable;  /*!< LLS2 mode enable.  */
 188:../drivers/fsl_smc.h ****     bool vlls0Enable; /*!< VLLS0 mode enable. */
 189:../drivers/fsl_smc.h **** } smc_param_t;
 190:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_PARAM */
 191:../drivers/fsl_smc.h **** 
 192:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE) || \
 193:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 194:../drivers/fsl_smc.h **** /*!
 195:../drivers/fsl_smc.h ****  * @brief SMC Low-Leakage Stop power mode configuration.
 196:../drivers/fsl_smc.h ****  */
 197:../drivers/fsl_smc.h **** typedef struct _smc_power_mode_lls_config
 198:../drivers/fsl_smc.h **** {
 199:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 200:../drivers/fsl_smc.h ****     smc_stop_submode_t subMode; /*!< Low-leakage Stop sub-mode */
 201:../drivers/fsl_smc.h **** #endif
 202:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 203:../drivers/fsl_smc.h ****     bool enableLpoClock; /*!< Enable LPO clock in LLS mode */
 204:../drivers/fsl_smc.h **** #endif
 205:../drivers/fsl_smc.h **** } smc_power_mode_lls_config_t;
 206:../drivers/fsl_smc.h **** #endif /* (FSL_FEATURE_SMC_HAS_LLS_SUBMODE || FSL_FEATURE_SMC_HAS_LPOPO) */
 207:../drivers/fsl_smc.h **** 
 208:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE) && FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAG
 209:../drivers/fsl_smc.h **** /*!
 210:../drivers/fsl_smc.h ****  * @brief SMC Very Low-Leakage Stop power mode configuration.
 211:../drivers/fsl_smc.h ****  */
 212:../drivers/fsl_smc.h **** typedef struct _smc_power_mode_vlls_config
 213:../drivers/fsl_smc.h **** {
 214:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_USE_VLLSCTRL_REG) && FSL_FEATURE_SMC_USE_VLLSCTRL_REG) ||     \
 215:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) && FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM) || \
 216:../drivers/fsl_smc.h ****     (defined(FSL_FEATURE_SMC_HAS_LLS_SUBMODE) && FSL_FEATURE_SMC_HAS_LLS_SUBMODE)
 217:../drivers/fsl_smc.h ****     smc_stop_submode_t subMode; /*!< Very Low-leakage Stop sub-mode */
 218:../drivers/fsl_smc.h **** #endif
 219:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_PORPO) && FSL_FEATURE_SMC_HAS_PORPO)
 220:../drivers/fsl_smc.h ****     bool enablePorDetectInVlls0; /*!< Enable Power on reset detect in VLLS mode */
 221:../drivers/fsl_smc.h **** #endif
 222:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION) && FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION)
 223:../drivers/fsl_smc.h ****     bool enableRam2InVlls2; /*!< Enable RAM2 power in VLLS2 */
 224:../drivers/fsl_smc.h **** #endif
 225:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_LPOPO) && FSL_FEATURE_SMC_HAS_LPOPO)
 226:../drivers/fsl_smc.h ****     bool enableLpoClock; /*!< Enable LPO clock in VLLS mode */
 227:../drivers/fsl_smc.h **** #endif
 228:../drivers/fsl_smc.h **** } smc_power_mode_vlls_config_t;
 229:../drivers/fsl_smc.h **** #endif
 230:../drivers/fsl_smc.h **** 
 231:../drivers/fsl_smc.h **** /*******************************************************************************
 232:../drivers/fsl_smc.h ****  * API
 233:../drivers/fsl_smc.h ****  ******************************************************************************/
 234:../drivers/fsl_smc.h **** 
 235:../drivers/fsl_smc.h **** #if defined(__cplusplus)
 236:../drivers/fsl_smc.h **** extern "C" {
 237:../drivers/fsl_smc.h **** #endif /* __cplusplus */
 238:../drivers/fsl_smc.h **** 
 239:../drivers/fsl_smc.h **** /*! @name System mode controller APIs*/
 240:../drivers/fsl_smc.h **** /*@{*/
 241:../drivers/fsl_smc.h **** 
 242:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_VERID) && FSL_FEATURE_SMC_HAS_VERID)
 243:../drivers/fsl_smc.h **** /*!
 244:../drivers/fsl_smc.h ****  * @brief Gets the SMC version ID.
 245:../drivers/fsl_smc.h ****  *
 246:../drivers/fsl_smc.h ****  * This function gets the SMC version ID, including major version number,
 247:../drivers/fsl_smc.h ****  * minor version number, and feature specification number.
 248:../drivers/fsl_smc.h ****  *
 249:../drivers/fsl_smc.h ****  * @param base SMC peripheral base address.
 250:../drivers/fsl_smc.h ****  * @param versionId     Pointer to the version ID structure.
 251:../drivers/fsl_smc.h ****  */
 252:../drivers/fsl_smc.h **** static inline void SMC_GetVersionId(SMC_Type *base, smc_version_id_t *versionId)
 253:../drivers/fsl_smc.h **** {
 254:../drivers/fsl_smc.h ****     *((uint32_t *)versionId) = base->VERID;
 255:../drivers/fsl_smc.h **** }
 256:../drivers/fsl_smc.h **** #endif /* FSL_FEATURE_SMC_HAS_VERID */
 257:../drivers/fsl_smc.h **** 
 258:../drivers/fsl_smc.h **** #if (defined(FSL_FEATURE_SMC_HAS_PARAM) && FSL_FEATURE_SMC_HAS_PARAM)
 259:../drivers/fsl_smc.h **** /*!
 260:../drivers/fsl_smc.h ****  * @brief Gets the SMC parameter.
 261:../drivers/fsl_smc.h ****  *
 262:../drivers/fsl_smc.h ****  * This function gets the SMC parameter including the enabled power mdoes.
 263:../drivers/fsl_smc.h ****  *
 264:../drivers/fsl_smc.h ****  * @param base SMC peripheral base address.
 265:../drivers/fsl_smc.h ****  * @param param         Pointer to the SMC param structure.
 266:../drivers/fsl_smc.h ****  */
 267:../drivers/fsl_smc.h **** void SMC_GetParam(SMC_Type *base, smc_param_t *param);
 268:../drivers/fsl_smc.h **** #endif
 269:../drivers/fsl_smc.h **** 
 270:../drivers/fsl_smc.h **** /*!
 271:../drivers/fsl_smc.h ****  * @brief Configures all power mode protection settings.
 272:../drivers/fsl_smc.h ****  *
 273:../drivers/fsl_smc.h ****  * This function  configures the power mode protection settings for
 274:../drivers/fsl_smc.h ****  * supported power modes in the specified chip family. The available power modes
 275:../drivers/fsl_smc.h ****  * are defined in the smc_power_mode_protection_t. This should be done at an early
 276:../drivers/fsl_smc.h ****  * system level initialization stage. See the reference manual for details.
 277:../drivers/fsl_smc.h ****  * This register can only write once after the power reset.
 278:../drivers/fsl_smc.h ****  *
 279:../drivers/fsl_smc.h ****  * The allowed modes are passed as bit map. For example, to allow LLS and VLLS,
 280:../drivers/fsl_smc.h ****  * use SMC_SetPowerModeProtection(kSMC_AllowPowerModeVlls | kSMC_AllowPowerModeVlps).
 281:../drivers/fsl_smc.h ****  * To allow all modes, use SMC_SetPowerModeProtection(kSMC_AllowPowerModeAll).
 282:../drivers/fsl_smc.h ****  *
 283:../drivers/fsl_smc.h ****  * @param base SMC peripheral base address.
 284:../drivers/fsl_smc.h ****  * @param allowedModes Bitmap of the allowed power modes.
 285:../drivers/fsl_smc.h ****  */
 286:../drivers/fsl_smc.h **** static inline void SMC_SetPowerModeProtection(SMC_Type *base, uint8_t allowedModes)
 287:../drivers/fsl_smc.h **** {
 288:../drivers/fsl_smc.h ****     base->PMPROT = allowedModes;
 641              		.loc 5 288 0
 642 0076 2A23     		movs	r3, #42
 643              	.LBE149:
 644              	.LBE148:
 226:../source/main.c **** 
 227:../source/main.c **** 	SMC_SetPowerModeProtection(SMC, kSMC_AllowPowerModeAll);
 228:../source/main.c **** 	smc_power_mode_vlls_config.subMode = kSMC_StopSub1; //!< Stop submode 1, for VLLS1/LLS1.
 645              		.loc 1 228 0
 646 0078 0126     		movs	r6, #1
 647              	.LBB151:
 648              	.LBB150:
 649              		.loc 5 288 0
 650 007a C04D     		ldr	r5, .L77+32
 651 007c 2B70     		strb	r3, [r5]
 652              	.LVL63:
 653              	.LBE150:
 654              	.LBE151:
 655              		.loc 1 228 0
 656 007e C04B     		ldr	r3, .L77+36
 657 0080 1E70     		strb	r6, [r3]
 229:../source/main.c **** 
 230:../source/main.c **** 	LLWU->ME |= 0x01; 		// enable LLWU wakeup source from LPTMR module
 658              		.loc 1 230 0
 659 0082 C04B     		ldr	r3, .L77+40
 660 0084 1A79     		ldrb	r2, [r3, #4]
 661 0086 3243     		orrs	r2, r6
 662 0088 1A71     		strb	r2, [r3, #4]
 231:../source/main.c **** 	LLWU->PE2 |= 0x04; // enable LLWU wakeup source from accelerometer interrupt pin
 663              		.loc 1 231 0
 664 008a 0422     		movs	r2, #4
 665 008c 5978     		ldrb	r1, [r3, #1]
 666 008e 0A43     		orrs	r2, r1
 667 0090 5A70     		strb	r2, [r3, #1]
 232:../source/main.c **** 	// 0x20 for stock frdm pin enable,
 233:../source/main.c **** 	LLWU->FILT1 |= 0x25;	// set pin wakeup from rising edge, 0x2A for frdm
 668              		.loc 1 233 0
 669 0092 2522     		movs	r2, #37
 670 0094 197A     		ldrb	r1, [r3, #8]
 671 0096 0A43     		orrs	r2, r1
 672              	.LBB152:
 673              	.LBB153:
 208:../drivers/fsl_lptmr.h ****     reg |= mask;
 674              		.loc 2 208 0
 675 0098 8021     		movs	r1, #128
 676              	.LBE153:
 677              	.LBE152:
 678              		.loc 1 233 0
 679 009a 1A72     		strb	r2, [r3, #8]
 680              	.LVL64:
 681              	.LBB155:
 682              	.LBB154:
 209:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 683              		.loc 2 209 0
 684 009c 4023     		movs	r3, #64
 205:../drivers/fsl_lptmr.h **** 
 685              		.loc 2 205 0
 686 009e BA4A     		ldr	r2, .L77+44
 687 00a0 1068     		ldr	r0, [r2]
 688              	.LVL65:
 208:../drivers/fsl_lptmr.h ****     reg |= mask;
 689              		.loc 2 208 0
 690 00a2 8843     		bics	r0, r1
 691              	.LVL66:
 209:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 692              		.loc 2 209 0
 693 00a4 0343     		orrs	r3, r0
 694              	.LVL67:
 210:../drivers/fsl_lptmr.h **** }
 695              		.loc 2 210 0
 696 00a6 1360     		str	r3, [r2]
 697              	.LVL68:
 698              	.LBE154:
 699              	.LBE155:
 700              	.LBB156:
 701              	.LBB157:
 319:../drivers/fsl_lptmr.h **** }
 320:../drivers/fsl_lptmr.h **** 
 321:../drivers/fsl_lptmr.h **** /*!
 322:../drivers/fsl_lptmr.h ****  * @brief Reads the current timer counting value.
 323:../drivers/fsl_lptmr.h ****  *
 324:../drivers/fsl_lptmr.h ****  * This function returns the real-time timer counting value in a range from 0 to a
 325:../drivers/fsl_lptmr.h ****  * timer period.
 326:../drivers/fsl_lptmr.h ****  *
 327:../drivers/fsl_lptmr.h ****  * @note Call the utility macros provided in the fsl_common.h to convert ticks to usec or msec.
 328:../drivers/fsl_lptmr.h ****  *
 329:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 330:../drivers/fsl_lptmr.h ****  *
 331:../drivers/fsl_lptmr.h ****  * @return The current counter value in ticks
 332:../drivers/fsl_lptmr.h ****  */
 333:../drivers/fsl_lptmr.h **** static inline uint32_t LPTMR_GetCurrentTimerCount(LPTMR_Type *base)
 334:../drivers/fsl_lptmr.h **** {
 335:../drivers/fsl_lptmr.h ****     /* Must first write any value to the CNR. This synchronizes and registers the current value
 336:../drivers/fsl_lptmr.h ****      * of the CNR into a temporary register which can then be read
 337:../drivers/fsl_lptmr.h ****      */
 338:../drivers/fsl_lptmr.h ****     base->CNR = 0U;
 339:../drivers/fsl_lptmr.h ****     return (uint32_t)((base->CNR & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT);
 340:../drivers/fsl_lptmr.h **** }
 341:../drivers/fsl_lptmr.h **** 
 342:../drivers/fsl_lptmr.h **** /*! @}*/
 343:../drivers/fsl_lptmr.h **** 
 344:../drivers/fsl_lptmr.h **** /*!
 345:../drivers/fsl_lptmr.h ****  * @name Timer Start and Stop
 346:../drivers/fsl_lptmr.h ****  * @{
 347:../drivers/fsl_lptmr.h ****  */
 348:../drivers/fsl_lptmr.h **** 
 349:../drivers/fsl_lptmr.h **** /*!
 350:../drivers/fsl_lptmr.h ****  * @brief Starts the timer.
 351:../drivers/fsl_lptmr.h ****  *
 352:../drivers/fsl_lptmr.h ****  * After calling this function, the timer counts up to the CMR register value.
 353:../drivers/fsl_lptmr.h ****  * Each time the timer reaches the CMR value and then increments, it generates a
 354:../drivers/fsl_lptmr.h ****  * trigger pulse and sets the timeout interrupt flag. An interrupt is also
 355:../drivers/fsl_lptmr.h ****  * triggered if the timer interrupt is enabled.
 356:../drivers/fsl_lptmr.h ****  *
 357:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 358:../drivers/fsl_lptmr.h ****  */
 359:../drivers/fsl_lptmr.h **** static inline void LPTMR_StartTimer(LPTMR_Type *base)
 360:../drivers/fsl_lptmr.h **** {
 361:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 702              		.loc 2 361 0
 703 00a8 1368     		ldr	r3, [r2]
 704              	.LVL69:
 705              	.LBE157:
 706              	.LBE156:
 234:../source/main.c **** 
 235:../source/main.c **** 	//EnableIRQ(PORTC_IRQn);
 236:../source/main.c **** 
 237:../source/main.c **** 	LPTMR_EnableInterrupts(LPTMR0, kLPTMR_TimerInterruptEnable);//Sets Timer Interrupt Enable bit to 1
 238:../source/main.c **** 	LPTMR_StartTimer(LPTMR0);
 239:../source/main.c **** 
 240:../source/main.c **** 	GPIO_PinInit(GPIOA, 19u, &LED_configOutput);
 707              		.loc 1 240 0
 708 00aa 2000     		movs	r0, r4
 709              	.LBB159:
 710              	.LBB158:
 362:../drivers/fsl_lptmr.h **** 
 363:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit to avoid clearing the w1c bit when writing back. */
 364:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 711              		.loc 2 364 0
 712 00ac 8B43     		bics	r3, r1
 713              	.LVL70:
 365:../drivers/fsl_lptmr.h ****     reg |= LPTMR_CSR_TEN_MASK;
 714              		.loc 2 365 0
 715 00ae 3343     		orrs	r3, r6
 716              	.LVL71:
 366:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 717              		.loc 2 366 0
 718 00b0 1360     		str	r3, [r2]
 719              	.LVL72:
 720              	.LBE158:
 721              	.LBE159:
 722              		.loc 1 240 0
 723 00b2 6D39     		subs	r1, r1, #109
 724 00b4 3A00     		movs	r2, r7
 725 00b6 FFF7FEFF 		bl	GPIO_PinInit
 726              	.LVL73:
 241:../source/main.c **** 
 242:../source/main.c **** 	//GPIO_ClearPinsOutput(GPIOA, 1 << 4u);
 243:../source/main.c **** 
 244:../source/main.c **** 	/*
 245:../source/main.c **** 	 * set boost regulator enable pin as output. This pin will control the power to RF modules
 246:../source/main.c **** 	 */
 247:../source/main.c **** 	GPIO_PinInit(GPIOA, 1u, &LED_configOutput);
 727              		.loc 1 247 0
 728 00ba 3A00     		movs	r2, r7
 729 00bc 3100     		movs	r1, r6
 730 00be 2000     		movs	r0, r4
 731 00c0 FFF7FEFF 		bl	GPIO_PinInit
 732              	.LVL74:
 733              	.LBB160:
 734              	.LBB161:
 735              	.LBB162:
 736              		.file 6 "../drivers/fsl_gpio.h"
   1:../drivers/fsl_gpio.h **** /*
   2:../drivers/fsl_gpio.h ****  * The Clear BSD License
   3:../drivers/fsl_gpio.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_gpio.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_gpio.h ****  * All rights reserved.
   6:../drivers/fsl_gpio.h ****  *
   7:../drivers/fsl_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_gpio.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_gpio.h ****  * that the following conditions are met:
  10:../drivers/fsl_gpio.h ****  *
  11:../drivers/fsl_gpio.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_gpio.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_gpio.h ****  *
  14:../drivers/fsl_gpio.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_gpio.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_gpio.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_gpio.h ****  *
  18:../drivers/fsl_gpio.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_gpio.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_gpio.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_gpio.h ****  *
  22:../drivers/fsl_gpio.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_gpio.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_gpio.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_gpio.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_gpio.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_gpio.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_gpio.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_gpio.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_gpio.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_gpio.h ****  */
  34:../drivers/fsl_gpio.h **** 
  35:../drivers/fsl_gpio.h **** #ifndef _FSL_GPIO_H_
  36:../drivers/fsl_gpio.h **** #define _FSL_GPIO_H_
  37:../drivers/fsl_gpio.h **** 
  38:../drivers/fsl_gpio.h **** #include "fsl_common.h"
  39:../drivers/fsl_gpio.h **** 
  40:../drivers/fsl_gpio.h **** /*!
  41:../drivers/fsl_gpio.h ****  * @addtogroup gpio
  42:../drivers/fsl_gpio.h ****  * @{
  43:../drivers/fsl_gpio.h ****  */
  44:../drivers/fsl_gpio.h **** 
  45:../drivers/fsl_gpio.h **** /*******************************************************************************
  46:../drivers/fsl_gpio.h ****  * Definitions
  47:../drivers/fsl_gpio.h ****  ******************************************************************************/
  48:../drivers/fsl_gpio.h **** 
  49:../drivers/fsl_gpio.h **** /*! @name Driver version */
  50:../drivers/fsl_gpio.h **** /*@{*/
  51:../drivers/fsl_gpio.h **** /*! @brief GPIO driver version 2.2.1. */
  52:../drivers/fsl_gpio.h **** #define FSL_GPIO_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  53:../drivers/fsl_gpio.h **** /*@}*/
  54:../drivers/fsl_gpio.h **** 
  55:../drivers/fsl_gpio.h **** /*! @brief GPIO direction definition */
  56:../drivers/fsl_gpio.h **** typedef enum _gpio_pin_direction
  57:../drivers/fsl_gpio.h **** {
  58:../drivers/fsl_gpio.h ****     kGPIO_DigitalInput = 0U,  /*!< Set current pin as digital input*/
  59:../drivers/fsl_gpio.h ****     kGPIO_DigitalOutput = 1U, /*!< Set current pin as digital output*/
  60:../drivers/fsl_gpio.h **** } gpio_pin_direction_t;
  61:../drivers/fsl_gpio.h **** 
  62:../drivers/fsl_gpio.h **** #if defined(FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER
  63:../drivers/fsl_gpio.h **** /*! @brief GPIO checker attribute */
  64:../drivers/fsl_gpio.h **** typedef enum _gpio_checker_attribute
  65:../drivers/fsl_gpio.h **** {
  66:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRWUsersecureRWPrivilegedsecureRW =
  67:../drivers/fsl_gpio.h ****         0x00U, /*!< User nonsecure:Read+Write; User Secure:Read+Write; Privileged Secure:Read+Write
  68:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRUsersecureRWPrivilegedsecureRW =
  69:../drivers/fsl_gpio.h ****         0x01U, /*!< User nonsecure:Read;       User Secure:Read+Write; Privileged Secure:Read+Write
  70:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureRWPrivilegedsecureRW =
  71:../drivers/fsl_gpio.h ****         0x02U, /*!< User nonsecure:None;       User Secure:Read+Write; Privileged Secure:Read+Write
  72:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureRUsersecureRPrivilegedsecureRW =
  73:../drivers/fsl_gpio.h ****         0x03U, /*!< User nonsecure:Read;       User Secure:Read;       Privileged Secure:Read+Write
  74:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureRPrivilegedsecureRW =
  75:../drivers/fsl_gpio.h ****         0x04U, /*!< User nonsecure:None;       User Secure:Read;       Privileged Secure:Read+Write
  76:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureRW =
  77:../drivers/fsl_gpio.h ****         0x05U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:Read+Write
  78:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureR =
  79:../drivers/fsl_gpio.h ****         0x06U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:Read */
  80:../drivers/fsl_gpio.h ****     kGPIO_UsernonsecureNUsersecureNPrivilegedsecureN =
  81:../drivers/fsl_gpio.h ****         0x07U, /*!< User nonsecure:None;       User Secure:None;       Privileged Secure:None */
  82:../drivers/fsl_gpio.h ****     kGPIO_IgnoreAttributeCheck = 0x80U, /*!< Ignores the attribute check */
  83:../drivers/fsl_gpio.h **** } gpio_checker_attribute_t;
  84:../drivers/fsl_gpio.h **** #endif
  85:../drivers/fsl_gpio.h **** 
  86:../drivers/fsl_gpio.h **** /*!
  87:../drivers/fsl_gpio.h ****  * @brief The GPIO pin configuration structure.
  88:../drivers/fsl_gpio.h ****  *
  89:../drivers/fsl_gpio.h ****  * Each pin can only be configured as either an output pin or an input pin at a time.
  90:../drivers/fsl_gpio.h ****  * If configured as an input pin, leave the outputConfig unused.
  91:../drivers/fsl_gpio.h ****  * Note that in some use cases, the corresponding port property should be configured in advance
  92:../drivers/fsl_gpio.h ****  *        with the PORT_SetPinConfig().
  93:../drivers/fsl_gpio.h ****  */
  94:../drivers/fsl_gpio.h **** typedef struct _gpio_pin_config
  95:../drivers/fsl_gpio.h **** {
  96:../drivers/fsl_gpio.h ****     gpio_pin_direction_t pinDirection; /*!< GPIO direction, input or output */
  97:../drivers/fsl_gpio.h ****     /* Output configurations; ignore if configured as an input pin */
  98:../drivers/fsl_gpio.h ****     uint8_t outputLogic; /*!< Set a default output logic, which has no use in input */
  99:../drivers/fsl_gpio.h **** } gpio_pin_config_t;
 100:../drivers/fsl_gpio.h **** 
 101:../drivers/fsl_gpio.h **** /*! @} */
 102:../drivers/fsl_gpio.h **** 
 103:../drivers/fsl_gpio.h **** /*******************************************************************************
 104:../drivers/fsl_gpio.h ****  * API
 105:../drivers/fsl_gpio.h ****  ******************************************************************************/
 106:../drivers/fsl_gpio.h **** 
 107:../drivers/fsl_gpio.h **** #if defined(__cplusplus)
 108:../drivers/fsl_gpio.h **** extern "C" {
 109:../drivers/fsl_gpio.h **** #endif
 110:../drivers/fsl_gpio.h **** 
 111:../drivers/fsl_gpio.h **** /*!
 112:../drivers/fsl_gpio.h ****  * @addtogroup gpio_driver
 113:../drivers/fsl_gpio.h ****  * @{
 114:../drivers/fsl_gpio.h ****  */
 115:../drivers/fsl_gpio.h **** 
 116:../drivers/fsl_gpio.h **** /*! @name GPIO Configuration */
 117:../drivers/fsl_gpio.h **** /*@{*/
 118:../drivers/fsl_gpio.h **** 
 119:../drivers/fsl_gpio.h **** /*!
 120:../drivers/fsl_gpio.h ****  * @brief Initializes a GPIO pin used by the board.
 121:../drivers/fsl_gpio.h ****  *
 122:../drivers/fsl_gpio.h ****  * To initialize the GPIO, define a pin configuration, as either input or output, in the user file.
 123:../drivers/fsl_gpio.h ****  * Then, call the GPIO_PinInit() function.
 124:../drivers/fsl_gpio.h ****  *
 125:../drivers/fsl_gpio.h ****  * This is an example to define an input pin or an output pin configuration.
 126:../drivers/fsl_gpio.h ****  * @code
 127:../drivers/fsl_gpio.h ****  * // Define a digital input pin configuration,
 128:../drivers/fsl_gpio.h ****  * gpio_pin_config_t config =
 129:../drivers/fsl_gpio.h ****  * {
 130:../drivers/fsl_gpio.h ****  *   kGPIO_DigitalInput,
 131:../drivers/fsl_gpio.h ****  *   0,
 132:../drivers/fsl_gpio.h ****  * }
 133:../drivers/fsl_gpio.h ****  * //Define a digital output pin configuration,
 134:../drivers/fsl_gpio.h ****  * gpio_pin_config_t config =
 135:../drivers/fsl_gpio.h ****  * {
 136:../drivers/fsl_gpio.h ****  *   kGPIO_DigitalOutput,
 137:../drivers/fsl_gpio.h ****  *   0,
 138:../drivers/fsl_gpio.h ****  * }
 139:../drivers/fsl_gpio.h ****  * @endcode
 140:../drivers/fsl_gpio.h ****  *
 141:../drivers/fsl_gpio.h ****  * @param base   GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 142:../drivers/fsl_gpio.h ****  * @param pin    GPIO port pin number
 143:../drivers/fsl_gpio.h ****  * @param config GPIO pin configuration pointer
 144:../drivers/fsl_gpio.h ****  */
 145:../drivers/fsl_gpio.h **** void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config);
 146:../drivers/fsl_gpio.h **** 
 147:../drivers/fsl_gpio.h **** /*@}*/
 148:../drivers/fsl_gpio.h **** 
 149:../drivers/fsl_gpio.h **** /*! @name GPIO Output Operations */
 150:../drivers/fsl_gpio.h **** /*@{*/
 151:../drivers/fsl_gpio.h **** 
 152:../drivers/fsl_gpio.h **** /*!
 153:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1 or 0.
 154:../drivers/fsl_gpio.h ****  *
 155:../drivers/fsl_gpio.h ****  * @param base    GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 156:../drivers/fsl_gpio.h ****  * @param pin     GPIO pin number
 157:../drivers/fsl_gpio.h ****  * @param output  GPIO pin output logic level.
 158:../drivers/fsl_gpio.h ****  *        - 0: corresponding pin output low-logic level.
 159:../drivers/fsl_gpio.h ****  *        - 1: corresponding pin output high-logic level.
 160:../drivers/fsl_gpio.h ****  */
 161:../drivers/fsl_gpio.h **** static inline void GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)
 162:../drivers/fsl_gpio.h **** {
 163:../drivers/fsl_gpio.h ****     if (output == 0U)
 164:../drivers/fsl_gpio.h ****     {
 165:../drivers/fsl_gpio.h ****         base->PCOR = 1U << pin;
 166:../drivers/fsl_gpio.h ****     }
 167:../drivers/fsl_gpio.h ****     else
 168:../drivers/fsl_gpio.h ****     {
 169:../drivers/fsl_gpio.h ****         base->PSOR = 1U << pin;
 170:../drivers/fsl_gpio.h ****     }
 171:../drivers/fsl_gpio.h **** }
 172:../drivers/fsl_gpio.h **** 
 173:../drivers/fsl_gpio.h **** /*!
 174:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1 or 0.
 175:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PinWrite.
 176:../drivers/fsl_gpio.h ****  */
 177:../drivers/fsl_gpio.h **** static inline void GPIO_WritePinOutput(GPIO_Type *base, uint32_t pin, uint8_t output)
 178:../drivers/fsl_gpio.h **** {
 179:../drivers/fsl_gpio.h ****     GPIO_PinWrite(base, pin, output);
 180:../drivers/fsl_gpio.h **** }
 181:../drivers/fsl_gpio.h **** 
 182:../drivers/fsl_gpio.h **** /*!
 183:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1.
 184:../drivers/fsl_gpio.h ****  *
 185:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 186:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 187:../drivers/fsl_gpio.h ****  */
 188:../drivers/fsl_gpio.h **** static inline void GPIO_PortSet(GPIO_Type *base, uint32_t mask)
 189:../drivers/fsl_gpio.h **** {
 190:../drivers/fsl_gpio.h ****     base->PSOR = mask;
 191:../drivers/fsl_gpio.h **** }
 192:../drivers/fsl_gpio.h **** 
 193:../drivers/fsl_gpio.h **** /*!
 194:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 1.
 195:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PortSet.
 196:../drivers/fsl_gpio.h ****  */
 197:../drivers/fsl_gpio.h **** static inline void GPIO_SetPinsOutput(GPIO_Type *base, uint32_t mask)
 198:../drivers/fsl_gpio.h **** {
 199:../drivers/fsl_gpio.h ****     GPIO_PortSet(base, mask);
 200:../drivers/fsl_gpio.h **** }
 201:../drivers/fsl_gpio.h **** 
 202:../drivers/fsl_gpio.h **** /*!
 203:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 0.
 204:../drivers/fsl_gpio.h ****  *
 205:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 206:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 207:../drivers/fsl_gpio.h ****  */
 208:../drivers/fsl_gpio.h **** static inline void GPIO_PortClear(GPIO_Type *base, uint32_t mask)
 209:../drivers/fsl_gpio.h **** {
 210:../drivers/fsl_gpio.h ****     base->PCOR = mask;
 737              		.loc 6 210 0
 738 00c4 0223     		movs	r3, #2
 739              	.LBE162:
 740              	.LBE161:
 741              	.LBE160:
 248:../source/main.c **** 
 249:../source/main.c **** 	GPIO_ClearPinsOutput(GPIOA, 1 << 1u); //Power on RF modules
 250:../source/main.c **** 
 251:../source/main.c **** 	PCprint(
 742              		.loc 1 251 0
 743 00c6 B148     		ldr	r0, .L77+48
 744              	.LBB165:
 745              	.LBB164:
 746              	.LBB163:
 747              		.loc 6 210 0
 748 00c8 A360     		str	r3, [r4, #8]
 749              	.LVL75:
 750              	.LBE163:
 751              	.LBE164:
 752              	.LBE165:
 753              		.loc 1 251 0
 754 00ca FFF7FEFF 		bl	PCprint
 755              	.LVL76:
 252:../source/main.c **** 			"Reindeer IoT has started\r\nCommand \"iot\" to start executing reindeer track cycle\r\n"
 253:../source/main.c **** 					"Command \"gpsinfo=1\" or \"gpsinfo=0\" to switch GPS data on/off\r\n");
 254:../source/main.c **** 	PCprint(
 756              		.loc 1 254 0
 757 00ce B048     		ldr	r0, .L77+52
 758 00d0 FFF7FEFF 		bl	PCprint
 759              	.LVL77:
 255:../source/main.c **** 			"Or enter normal AT commands here for SARA-N2\r\nModules powered on and booting now!\r\n");
 256:../source/main.c **** 
 257:../source/main.c **** 
 258:../source/main.c **** 
 259:../source/main.c **** 	//GPIO_ClearPinsOutput(GPIOA, 1 << 19u);
 260:../source/main.c **** 	/*
 261:../source/main.c **** 	 while (true) {
 262:../source/main.c **** 
 263:../source/main.c **** 	 char acc_buf[150];
 264:../source/main.c **** 
 265:../source/main.c **** 	 int16_t acc_val_x = read_acc_axis(0);
 266:../source/main.c **** 	 int16_t acc_val_y = read_acc_axis(1);
 267:../source/main.c **** 	 int16_t acc_val_z = read_acc_axis(2);
 268:../source/main.c **** 	 sprintf(acc_buf, "Akselomeetteri X: %d Y: %d Z: %d\r\n", acc_val_x, acc_val_y, acc_val_z);
 269:../source/main.c **** 	 PCprint(acc_buf);
 270:../source/main.c **** 	 delay_ms(500);
 271:../source/main.c **** 	 }
 272:../source/main.c **** 	 */
 273:../source/main.c **** 	/*
 274:../source/main.c **** 	 * Copy all reindeer variables to struct before starting network operations
 275:../source/main.c **** 	 */
 276:../source/main.c **** 	char testLat[11] = ("6500.53");
 760              		.loc 1 276 0
 761 00d4 AF4F     		ldr	r7, .L77+56
 762 00d6 0822     		movs	r2, #8
 763 00d8 3900     		movs	r1, r7
 764 00da 6846     		mov	r0, sp
 765 00dc FFF7FEFF 		bl	memcpy
 766              	.LVL78:
 767 00e0 0322     		movs	r2, #3
 768 00e2 0021     		movs	r1, #0
 769 00e4 02A8     		add	r0, sp, #8
 770 00e6 FFF7FEFF 		bl	memset
 771              	.LVL79:
 277:../source/main.c **** 	char testLon[11] = ("02534.554");
 772              		.loc 1 277 0
 773 00ea 3900     		movs	r1, r7
 774 00ec 0A22     		movs	r2, #10
 775 00ee 0B31     		adds	r1, r1, #11
 776 00f0 03A8     		add	r0, sp, #12
 777 00f2 FFF7FEFF 		bl	memcpy
 778              	.LVL80:
 779 00f6 1623     		movs	r3, #22
 780 00f8 0022     		movs	r2, #0
 781 00fa 6B44     		add	r3, r3, sp
 278:../source/main.c **** 	strcpy(reindeerData.serialNum, "11111");
 782              		.loc 1 278 0
 783 00fc A649     		ldr	r1, .L77+60
 784 00fe 11A8     		add	r0, sp, #68
 277:../source/main.c **** 	char testLon[11] = ("02534.554");
 785              		.loc 1 277 0
 786 0100 1A70     		strb	r2, [r3]
 787              		.loc 1 278 0
 788 0102 FFF7FEFF 		bl	strcpy
 789              	.LVL81:
 279:../source/main.c **** 	strcpy(reindeerData.latitude, testLat);
 790              		.loc 1 279 0
 791 0106 4A23     		movs	r3, #74
 792 0108 6B44     		add	r3, r3, sp
 793 010a 6946     		mov	r1, sp
 794 010c 1800     		movs	r0, r3
 795 010e FFF7FEFF 		bl	strcpy
 796              	.LVL82:
 280:../source/main.c **** 	strcpy(reindeerData.longitude, testLon);
 797              		.loc 1 280 0
 798 0112 5623     		movs	r3, #86
 799 0114 6B44     		add	r3, r3, sp
 800 0116 03A9     		add	r1, sp, #12
 801 0118 1800     		movs	r0, r3
 802 011a FFF7FEFF 		bl	strcpy
 803              	.LVL83:
 281:../source/main.c **** 	strcpy(reindeerData.dead, "false");
 804              		.loc 1 281 0
 805 011e 6223     		movs	r3, #98
 806 0120 6B44     		add	r3, r3, sp
 807 0122 1800     		movs	r0, r3
 808 0124 9D49     		ldr	r1, .L77+64
 809 0126 FFF7FEFF 		bl	strcpy
 810              	.LVL84:
 282:../source/main.c **** 	reindeerData.batteryLevel = 45;
 811              		.loc 1 282 0
 812 012a 4923     		movs	r3, #73
 813 012c 2D22     		movs	r2, #45
 814 012e 6B44     		add	r3, r3, sp
 815 0130 DA77     		strb	r2, [r3, #31]
 283:../source/main.c **** 
 284:../source/main.c **** 	if (wake == 2)
 816              		.loc 1 284 0
 817 0132 9B4B     		ldr	r3, .L77+68
 285:../source/main.c **** 	{
 286:../source/main.c **** 
 287:../source/main.c **** 		PCprint("Woken by ACCEL, reindeer is !!!ALIVE!!!\r\n");
 818              		.loc 1 287 0
 819 0134 9B48     		ldr	r0, .L77+72
 284:../source/main.c **** 	{
 820              		.loc 1 284 0
 821 0136 1A78     		ldrb	r2, [r3]
 822 0138 022A     		cmp	r2, #2
 823 013a 07D0     		beq	.L73
 288:../source/main.c **** 		SMC_PreEnterStopModes();
 289:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 290:../source/main.c **** 	}
 291:../source/main.c **** 	else if (wake == 0)
 824              		.loc 1 291 0
 825 013c 1A78     		ldrb	r2, [r3]
 292:../source/main.c **** 	{
 293:../source/main.c **** 		PCprint("wake was 0 going to sleep\r\n");
 826              		.loc 1 293 0
 827 013e 9A48     		ldr	r0, .L77+76
 291:../source/main.c **** 	{
 828              		.loc 1 291 0
 829 0140 002A     		cmp	r2, #0
 830 0142 03D0     		beq	.L73
 294:../source/main.c **** 		SMC_PreEnterStopModes();
 295:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 296:../source/main.c **** 	}
 297:../source/main.c **** 	else if (wake == 1)
 831              		.loc 1 297 0
 832 0144 1B78     		ldrb	r3, [r3]
 833 0146 012B     		cmp	r3, #1
 834 0148 08D1     		bne	.L33
 298:../source/main.c **** 	{
 299:../source/main.c **** 		PCprint("wake on 1 jeesus tulee\r\n");
 835              		.loc 1 299 0
 836 014a 9848     		ldr	r0, .L77+80
 837              	.L73:
 838 014c FFF7FEFF 		bl	PCprint
 839              	.LVL85:
 300:../source/main.c **** 		SMC_PreEnterStopModes();
 840              		.loc 1 300 0
 841 0150 FFF7FEFF 		bl	SMC_PreEnterStopModes
 842              	.LVL86:
 301:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 843              		.loc 1 301 0
 844 0154 8A49     		ldr	r1, .L77+36
 845 0156 2800     		movs	r0, r5
 846 0158 FFF7FEFF 		bl	SMC_SetPowerModeVlls
 847              	.LVL87:
 848              	.L33:
 302:../source/main.c **** 	}
 303:../source/main.c **** 
 304:../source/main.c **** 	while (1)
 305:../source/main.c **** 	{
 306:../source/main.c **** 
 307:../source/main.c **** 		//int16_t acc_val = read_acc_axis(0);
 308:../source/main.c **** 		//PCprint("Accelereometer %d\r\n",acc_val);
 309:../source/main.c **** 		//break;
 310:../source/main.c **** 		/*
 311:../source/main.c **** 		 * Check if a string has arrived from PC (with CR line end)
 312:../source/main.c **** 		 */
 313:../source/main.c **** 
 314:../source/main.c **** 		if (wake == 1)
 849              		.loc 1 314 0
 850 015c 904B     		ldr	r3, .L77+68
 851 015e 1B78     		ldrb	r3, [r3]
 852 0160 012B     		cmp	r3, #1
 853 0162 2BD1     		bne	.L36
 315:../source/main.c **** 		{
 316:../source/main.c **** 
 317:../source/main.c **** 			strcpy(reindeerData.dead, "true");
 854              		.loc 1 317 0
 855 0164 6133     		adds	r3, r3, #97
 856 0166 6B44     		add	r3, r3, sp
 857 0168 1800     		movs	r0, r3
 858 016a 9149     		ldr	r1, .L77+84
 859 016c FFF7FEFF 		bl	strcpy
 860              	.LVL88:
 318:../source/main.c **** 			//PCprint("Woken by LPTMR, reindeer is !!!%s!!\r\n",
 319:../source/main.c **** 			//		reindeerData.dead);
 320:../source/main.c **** 
 321:../source/main.c **** 			while (true)
 322:../source/main.c **** 			{
 323:../source/main.c **** 				if (!GPS_strReady)
 861              		.loc 1 323 0
 862 0170 904B     		ldr	r3, .L77+88
 863              	.L37:
 864 0172 1D78     		ldrb	r5, [r3]
 865 0174 EDB2     		uxtb	r5, r5
 866 0176 002D     		cmp	r5, #0
 867 0178 FBD1     		bne	.L37
 868              	.LBB166:
 324:../source/main.c **** 				{
 325:../source/main.c **** 					PCprint(GPS_recBuf);
 869              		.loc 1 325 0
 870 017a 8F48     		ldr	r0, .L77+92
 871 017c FFF7FEFF 		bl	PCprint
 872              	.LVL89:
 326:../source/main.c **** 					PCprint("\r\n"); //First print out whole buffer
 873              		.loc 1 326 0
 874 0180 8E48     		ldr	r0, .L77+96
 875 0182 FFF7FEFF 		bl	PCprint
 876              	.LVL90:
 327:../source/main.c **** 
 328:../source/main.c **** 					char testLat[12] = ("6500.02359");
 877              		.loc 1 328 0
 878 0186 3900     		movs	r1, r7
 879 0188 0B22     		movs	r2, #11
 880 018a 1631     		adds	r1, r1, #22
 881 018c 06A8     		add	r0, sp, #24
 882 018e FFF7FEFF 		bl	memcpy
 883              	.LVL91:
 884 0192 2323     		movs	r3, #35
 329:../source/main.c **** 					char testLon[12] = ("02530.56951");
 885              		.loc 1 329 0
 886 0194 0C22     		movs	r2, #12
 328:../source/main.c **** 					char testLon[12] = ("02530.56951");
 887              		.loc 1 328 0
 888 0196 6B44     		add	r3, r3, sp
 889              		.loc 1 329 0
 890 0198 8949     		ldr	r1, .L77+100
 891 019a 1BA8     		add	r0, sp, #108
 328:../source/main.c **** 					char testLon[12] = ("02530.56951");
 892              		.loc 1 328 0
 893 019c 1D70     		strb	r5, [r3]
 894              		.loc 1 329 0
 895 019e FFF7FEFF 		bl	memcpy
 896              	.LVL92:
 330:../source/main.c **** 
 331:../source/main.c **** 					strcpy(reindeerData.latitude, testLat);
 897              		.loc 1 331 0
 898 01a2 4A23     		movs	r3, #74
 899 01a4 6B44     		add	r3, r3, sp
 900 01a6 06A9     		add	r1, sp, #24
 901 01a8 1800     		movs	r0, r3
 902 01aa FFF7FEFF 		bl	strcpy
 903              	.LVL93:
 332:../source/main.c **** 					strcpy(reindeerData.longitude, testLon);
 904              		.loc 1 332 0
 905 01ae 1BA9     		add	r1, sp, #108
 906              	.L76:
 907              	.LBE166:
 908              	.LBB167:
 333:../source/main.c **** 					break;
 334:../source/main.c **** 
 335:../source/main.c **** 					if (getGPS())
 336:../source/main.c **** 					{
 337:../source/main.c **** 						//char testLat[12] = ("6500.02359");
 338:../source/main.c **** 						//char testLon[12] = ("02530.56951");
 339:../source/main.c **** 
 340:../source/main.c **** 						//parseData(testLat,testLon);
 341:../source/main.c **** 
 342:../source/main.c **** 						strcpy(reindeerData.latitude, parsedLat);
 343:../source/main.c **** 						strcpy(reindeerData.longitude, parsedLon);
 344:../source/main.c **** 						break;
 345:../source/main.c **** 					}
 346:../source/main.c **** 					memset(GPS_recBuf, 0, 600);
 347:../source/main.c **** 					GPS_bufPtr = 0;
 348:../source/main.c **** 					GPS_strReady = 0;
 349:../source/main.c **** 				}
 350:../source/main.c **** 
 351:../source/main.c **** 			}
 352:../source/main.c **** 			//PCprint("Parsed latitude: %s\r\n", reindeerData.latitude);
 353:../source/main.c **** 			//PCprint("Parsed longitude: %s\r\n", reindeerData.longitude);
 354:../source/main.c **** 			break;
 355:../source/main.c **** 		}
 356:../source/main.c **** 
 357:../source/main.c **** 		if (PC_strReady)
 358:../source/main.c **** 		{
 359:../source/main.c **** 
 360:../source/main.c **** 			if (strstr(PC_recBuf, "iot") != NULL)
 361:../source/main.c **** 			{
 362:../source/main.c **** 				PCprint("Starting Reindeer IoT cycle\r\n");
 363:../source/main.c **** 				break;
 364:../source/main.c **** 			}
 365:../source/main.c **** 			else if (strstr(PC_recBuf, "gpsinfo=1") != NULL)
 366:../source/main.c **** 			{
 367:../source/main.c **** 				streamGps = 1;
 368:../source/main.c **** 				GPIO_ClearPinsOutput(GPIOA, 1 << 19u);
 369:../source/main.c **** 			}
 370:../source/main.c **** 			else if (strstr(PC_recBuf, "gpsinfo=0") != NULL)
 371:../source/main.c **** 			{
 372:../source/main.c **** 				streamGps = 0;
 373:../source/main.c **** 				GPIO_SetPinsOutput(GPIOA, 1 << 19u);
 374:../source/main.c **** 			}
 375:../source/main.c **** 			else if (strstr(PC_recBuf, "rfoff") != NULL)
 376:../source/main.c **** 			{
 377:../source/main.c **** 				GPIO_ClearPinsOutput(GPIOA, 1 << 1u); //Power off RF modules
 378:../source/main.c **** 			}
 379:../source/main.c **** 			else if (strstr(PC_recBuf, "rfon") != NULL)
 380:../source/main.c **** 			{
 381:../source/main.c **** 				GPIO_SetPinsOutput(GPIOA, 1 << 1u); //Power on RF modules
 382:../source/main.c **** 			}
 383:../source/main.c **** 			else if (strstr(PC_recBuf, "\xb5\x62") != NULL) //if input is UBX command!
 384:../source/main.c **** 			{
 385:../source/main.c **** 				PCprint("send to gps\r\n");
 386:../source/main.c **** 				uint8_t ubxMsgLen = calcUbxCrc(PC_recBuf + 2); //Calculate UBX checksum and add it to the messa
 387:../source/main.c **** 				GPS_send(PC_recBuf, ubxMsgLen); //Send UBX message to module
 388:../source/main.c **** 			}
 389:../source/main.c **** 			else
 390:../source/main.c **** 			{
 391:../source/main.c **** 
 392:../source/main.c **** 				NB_send(PC_recBuf);
 393:../source/main.c **** 
 394:../source/main.c **** 			}
 395:../source/main.c **** 			memset(PC_recBuf, 0, strlen(PC_recBuf));
 396:../source/main.c **** 			PC_strReady = 0;
 397:../source/main.c **** 			PC_bufPtr = 0;
 398:../source/main.c **** 		}
 399:../source/main.c **** 
 400:../source/main.c **** 		if (NB_strReady)
 401:../source/main.c **** 		{
 402:../source/main.c **** 			moduleResponseTimeout = millis() + RESPONSE_TIMEOUT_NORMAL_VALUE; //reset timeout to initial val
 403:../source/main.c **** 
 404:../source/main.c **** 			while (millis() < moduleResponseTimeout)
 405:../source/main.c **** 
 406:../source/main.c **** 			{
 407:../source/main.c **** 
 408:../source/main.c **** 				if (breakIfAtOk())
 409:../source/main.c **** 				{
 410:../source/main.c **** 					break;
 411:../source/main.c **** 				}
 412:../source/main.c **** 
 413:../source/main.c **** 			}
 414:../source/main.c **** 
 415:../source/main.c **** 			//now the timeout has expired since last character had arrived, so we can process data
 416:../source/main.c **** 
 417:../source/main.c **** 			PCprint(NB_recBuf);
 418:../source/main.c **** 			PCprint("\r\n");
 419:../source/main.c **** 			memset(NB_recBuf, 0, 500);
 420:../source/main.c **** 			NB_bufPtr = 0;
 421:../source/main.c **** 			NB_strReady = 0;
 422:../source/main.c **** 		}
 423:../source/main.c **** 
 424:../source/main.c **** 		/*
 425:../source/main.c **** 		 * If GPS string is ready and GPS data streaming is enabled, enter here to process GPS data buffe
 426:../source/main.c **** 		 */
 427:../source/main.c **** 		if (GPS_strReady && streamGps)
 428:../source/main.c **** 		{
 429:../source/main.c **** 
 430:../source/main.c **** 			PCprint(GPS_recBuf);
 431:../source/main.c **** 			PCprint("\r\n"); //First print out whole buffer
 432:../source/main.c **** 
 433:../source/main.c **** 			if (getGPS())
 434:../source/main.c **** 			{
 435:../source/main.c **** 				//char testLat[12] = ("6500.02359");
 436:../source/main.c **** 				//char testLon[12] = ("02530.56951");
 437:../source/main.c **** 
 438:../source/main.c **** 				//parseData(testLat,testLon);
 439:../source/main.c **** 
 440:../source/main.c **** 				strcpy(reindeerData.latitude, parsedLat);
 441:../source/main.c **** 				strcpy(reindeerData.longitude, parsedLon);
 909              		.loc 1 441 0
 910 01b0 5623     		movs	r3, #86
 911 01b2 6B44     		add	r3, r3, sp
 912 01b4 1800     		movs	r0, r3
 913 01b6 FFF7FEFF 		bl	strcpy
 914              	.LVL94:
 442:../source/main.c **** 				break;
 915              		.loc 1 442 0
 916 01ba 0DE0     		b	.L38
 917              	.L36:
 918              	.LBE167:
 357:../source/main.c **** 		{
 919              		.loc 1 357 0
 920 01bc 814B     		ldr	r3, .L77+104
 921 01be 1B78     		ldrb	r3, [r3]
 922 01c0 002B     		cmp	r3, #0
 923 01c2 3CD0     		beq	.L39
 360:../source/main.c **** 			{
 924              		.loc 1 360 0
 925 01c4 804D     		ldr	r5, .L77+108
 926 01c6 8149     		ldr	r1, .L77+112
 927 01c8 2800     		movs	r0, r5
 928 01ca FFF7FEFF 		bl	strstr
 929              	.LVL95:
 930 01ce 0028     		cmp	r0, #0
 931 01d0 1BD0     		beq	.L40
 362:../source/main.c **** 				break;
 932              		.loc 1 362 0
 933 01d2 7F48     		ldr	r0, .L77+116
 934 01d4 FFF7FEFF 		bl	PCprint
 935              	.LVL96:
 936              	.L38:
 443:../source/main.c **** 			}
 444:../source/main.c **** 
 445:../source/main.c **** 			//PCprint("Parsed latitude: %s\r\n", reindeerData.latitude);
 446:../source/main.c **** 			//PCprint("Parsed longitude: %s\r\n", reindeerData.longitude);
 447:../source/main.c **** 
 448:../source/main.c **** 			char* ubxResponseStartPtr = strstr(GPS_recBuf, "\xb5\x62"); //Find pointer to UBX header. If the
 449:../source/main.c **** 																		//will be NULL
 450:../source/main.c **** 
 451:../source/main.c **** 			if (ubxResponseStartPtr != NULL) //If pointer is not null, it means UBX response header is found
 452:../source/main.c **** 			{
 453:../source/main.c **** 				PCprint("Found UBX response\r\n");
 454:../source/main.c **** 
 455:../source/main.c **** 				uint8_t responseLength = *(ubxResponseStartPtr + 4); //Find out UBX response length, it is alwa
 456:../source/main.c **** 																	 //from beginning of the packet. * means dereferencing pointer
 457:../source/main.c **** 				//dereferencing means "accessing the value where pointer points"
 458:../source/main.c **** 
 459:../source/main.c **** 				//PCprint("UBX response length: %02x\r\n", responseLength);
 460:../source/main.c **** 
 461:../source/main.c **** 				printUbxResponseHex(ubxResponseStartPtr,
 462:../source/main.c **** 						responseLength + 6 + 2); //Print UBX response message. Function wants to know
 463:../source/main.c **** 				//how many chars to print. We must add 6+2 to print header and crc too
 464:../source/main.c **** 			}
 465:../source/main.c **** 
 466:../source/main.c **** 			memset(GPS_recBuf, 0, 600);
 467:../source/main.c **** 			GPS_bufPtr = 0;
 468:../source/main.c **** 			GPS_strReady = 0;
 469:../source/main.c **** 		}
 470:../source/main.c **** 
 471:../source/main.c **** 	}
 472:../source/main.c **** 
 473:../source/main.c **** 	/*
 474:../source/main.c **** 	 * Assemble data to json format and then to POST message
 475:../source/main.c **** 	 */
 476:../source/main.c **** 
 477:../source/main.c **** 	uint8_t msgLen = assembleMqtt(&reindeerData, mqttMessage);
 937              		.loc 1 477 0
 938 01d8 1BA9     		add	r1, sp, #108
 939 01da 11A8     		add	r0, sp, #68
 940 01dc FFF7FEFF 		bl	assembleMqtt
 941              	.LVL97:
 942 01e0 0100     		movs	r1, r0
 943              	.LVL98:
 478:../source/main.c **** 
 479:../source/main.c **** 	//NB_send_msg(mqttMessage, msgLen);
 480:../source/main.c **** 
 481:../source/main.c **** 	NB_create_pdp_send(mqttMessage, msgLen);
 944              		.loc 1 481 0
 945 01e2 1BA8     		add	r0, sp, #108
 946 01e4 FFF7FEFF 		bl	NB_create_pdp_send
 947              	.LVL99:
 482:../source/main.c **** 	PCprint("Roger include main.c\r\n");
 948              		.loc 1 482 0
 949 01e8 7A48     		ldr	r0, .L77+120
 950 01ea FFF7FEFF 		bl	PCprint
 951              	.LVL100:
 483:../source/main.c **** 
 484:../source/main.c **** 	AT_send("CFUN=0", "", "OK");
 952              		.loc 1 484 0
 953 01ee 7A49     		ldr	r1, .L77+124
 954 01f0 7A4A     		ldr	r2, .L77+128
 955 01f2 7B48     		ldr	r0, .L77+132
 956 01f4 FFF7FEFF 		bl	AT_send
 957              	.LVL101:
 958              	.LBB169:
 959              	.LBB170:
 960              	.LBB171:
 961              		.loc 6 210 0
 962 01f8 0223     		movs	r3, #2
 963 01fa A360     		str	r3, [r4, #8]
 964              	.LVL102:
 965              	.LBE171:
 966              	.LBE170:
 967              	.LBE169:
 485:../source/main.c **** 
 486:../source/main.c **** 	GPIO_ClearPinsOutput(GPIOA, 1 << 1u); //Power on RF modules
 487:../source/main.c **** 
 488:../source/main.c **** 	SMC_PreEnterStopModes();
 968              		.loc 1 488 0
 969 01fc FFF7FEFF 		bl	SMC_PreEnterStopModes
 970              	.LVL103:
 489:../source/main.c **** 		SMC_SetPowerModeVlls(SMC, &smc_power_mode_vlls_config);
 971              		.loc 1 489 0
 972 0200 5F49     		ldr	r1, .L77+36
 973 0202 5E48     		ldr	r0, .L77+32
 974 0204 FFF7FEFF 		bl	SMC_SetPowerModeVlls
 975              	.LVL104:
 976              	.L54:
 977 0208 FEE7     		b	.L54
 978              	.L40:
 365:../source/main.c **** 			{
 979              		.loc 1 365 0
 980 020a 7649     		ldr	r1, .L77+136
 981 020c 2800     		movs	r0, r5
 982 020e FFF7FEFF 		bl	strstr
 983              	.LVL105:
 984 0212 061E     		subs	r6, r0, #0
 985 0214 56D0     		beq	.L41
 367:../source/main.c **** 				GPIO_ClearPinsOutput(GPIOA, 1 << 19u);
 986              		.loc 1 367 0
 987 0216 0122     		movs	r2, #1
 988 0218 734B     		ldr	r3, .L77+140
 989 021a 1A70     		strb	r2, [r3]
 990              	.LVL106:
 991              	.LBB172:
 992              	.LBB173:
 993              	.LBB174:
 994              		.loc 6 210 0
 995 021c 8023     		movs	r3, #128
 996 021e 1B03     		lsls	r3, r3, #12
 997              	.LVL107:
 998              	.L74:
 999              	.LBE174:
 1000              	.LBE173:
 1001              	.LBE172:
 1002              	.LBB175:
 1003              	.LBB176:
 1004              	.LBB177:
 1005 0220 A360     		str	r3, [r4, #8]
 1006              	.L42:
 1007              	.LBE177:
 1008              	.LBE176:
 1009              	.LBE175:
 395:../source/main.c **** 			PC_strReady = 0;
 1010              		.loc 1 395 0
 1011 0222 694D     		ldr	r5, .L77+108
 1012 0224 2800     		movs	r0, r5
 1013 0226 FFF7FEFF 		bl	strlen
 1014              	.LVL108:
 1015 022a 0021     		movs	r1, #0
 1016 022c 0200     		movs	r2, r0
 1017 022e 2800     		movs	r0, r5
 1018 0230 FFF7FEFF 		bl	memset
 1019              	.LVL109:
 396:../source/main.c **** 			PC_bufPtr = 0;
 1020              		.loc 1 396 0
 1021 0234 0023     		movs	r3, #0
 1022 0236 634A     		ldr	r2, .L77+104
 1023 0238 1370     		strb	r3, [r2]
 397:../source/main.c **** 		}
 1024              		.loc 1 397 0
 1025 023a 6C4A     		ldr	r2, .L77+144
 1026 023c 1380     		strh	r3, [r2]
 1027              	.L39:
 400:../source/main.c **** 		{
 1028              		.loc 1 400 0
 1029 023e 6C4B     		ldr	r3, .L77+148
 1030 0240 1B78     		ldrb	r3, [r3]
 1031 0242 002B     		cmp	r3, #0
 1032 0244 21D0     		beq	.L47
 402:../source/main.c **** 
 1033              		.loc 1 402 0
 1034 0246 FFF7FEFF 		bl	millis
 1035              	.LVL110:
 1036 024a FA23     		movs	r3, #250
 1037 024c 694D     		ldr	r5, .L77+152
 1038 024e DB00     		lsls	r3, r3, #3
 1039 0250 C018     		adds	r0, r0, r3
 1040 0252 2860     		str	r0, [r5]
 1041              	.L48:
 404:../source/main.c **** 
 1042              		.loc 1 404 0
 1043 0254 FFF7FEFF 		bl	millis
 1044              	.LVL111:
 1045 0258 2B68     		ldr	r3, [r5]
 1046 025a 9842     		cmp	r0, r3
 1047 025c 03D2     		bcs	.L50
 408:../source/main.c **** 				{
 1048              		.loc 1 408 0
 1049 025e FFF7FEFF 		bl	breakIfAtOk
 1050              	.LVL112:
 1051 0262 0028     		cmp	r0, #0
 1052 0264 F6D0     		beq	.L48
 1053              	.L50:
 417:../source/main.c **** 			PCprint("\r\n");
 1054              		.loc 1 417 0
 1055 0266 644D     		ldr	r5, .L77+156
 1056 0268 2800     		movs	r0, r5
 1057 026a FFF7FEFF 		bl	PCprint
 1058              	.LVL113:
 418:../source/main.c **** 			memset(NB_recBuf, 0, 500);
 1059              		.loc 1 418 0
 1060 026e 5348     		ldr	r0, .L77+96
 1061 0270 FFF7FEFF 		bl	PCprint
 1062              	.LVL114:
 419:../source/main.c **** 			NB_bufPtr = 0;
 1063              		.loc 1 419 0
 1064 0274 FA22     		movs	r2, #250
 1065 0276 0021     		movs	r1, #0
 1066 0278 5200     		lsls	r2, r2, #1
 1067 027a 2800     		movs	r0, r5
 1068 027c FFF7FEFF 		bl	memset
 1069              	.LVL115:
 420:../source/main.c **** 			NB_strReady = 0;
 1070              		.loc 1 420 0
 1071 0280 0023     		movs	r3, #0
 1072 0282 5E4A     		ldr	r2, .L77+160
 1073 0284 1380     		strh	r3, [r2]
 421:../source/main.c **** 		}
 1074              		.loc 1 421 0
 1075 0286 5A4A     		ldr	r2, .L77+148
 1076 0288 1370     		strb	r3, [r2]
 1077              	.L47:
 427:../source/main.c **** 		{
 1078              		.loc 1 427 0
 1079 028a 4A4B     		ldr	r3, .L77+88
 1080 028c 1B78     		ldrb	r3, [r3]
 1081 028e 002B     		cmp	r3, #0
 1082 0290 00D1     		bne	.LCB966
 1083 0292 63E7     		b	.L33	@long jump
 1084              	.LCB966:
 427:../source/main.c **** 		{
 1085              		.loc 1 427 0 is_stmt 0 discriminator 1
 1086 0294 544B     		ldr	r3, .L77+140
 1087 0296 1B78     		ldrb	r3, [r3]
 1088 0298 002B     		cmp	r3, #0
 1089 029a 00D1     		bne	.LCB970
 1090 029c 5EE7     		b	.L33	@long jump
 1091              	.LCB970:
 1092              	.LBB180:
 430:../source/main.c **** 			PCprint("\r\n"); //First print out whole buffer
 1093              		.loc 1 430 0 is_stmt 1
 1094 029e 464D     		ldr	r5, .L77+92
 1095 02a0 2800     		movs	r0, r5
 1096 02a2 FFF7FEFF 		bl	PCprint
 1097              	.LVL116:
 431:../source/main.c **** 
 1098              		.loc 1 431 0
 1099 02a6 4548     		ldr	r0, .L77+96
 1100 02a8 FFF7FEFF 		bl	PCprint
 1101              	.LVL117:
 433:../source/main.c **** 			{
 1102              		.loc 1 433 0
 1103 02ac FFF7FEFF 		bl	getGPS
 1104              	.LVL118:
 1105 02b0 0028     		cmp	r0, #0
 1106 02b2 38D0     		beq	.L52
 440:../source/main.c **** 				strcpy(reindeerData.longitude, parsedLon);
 1107              		.loc 1 440 0
 1108 02b4 4A23     		movs	r3, #74
 1109 02b6 6B44     		add	r3, r3, sp
 1110 02b8 5149     		ldr	r1, .L77+164
 1111 02ba 1800     		movs	r0, r3
 1112 02bc FFF7FEFF 		bl	strcpy
 1113              	.LVL119:
 441:../source/main.c **** 				break;
 1114              		.loc 1 441 0
 1115 02c0 5049     		ldr	r1, .L77+168
 1116 02c2 75E7     		b	.L76
 1117              	.L41:
 1118              	.LBE180:
 370:../source/main.c **** 			{
 1119              		.loc 1 370 0
 1120 02c4 5049     		ldr	r1, .L77+172
 1121 02c6 2800     		movs	r0, r5
 1122 02c8 FFF7FEFF 		bl	strstr
 1123              	.LVL120:
 1124 02cc 0028     		cmp	r0, #0
 1125 02ce 05D0     		beq	.L43
 372:../source/main.c **** 				GPIO_SetPinsOutput(GPIOA, 1 << 19u);
 1126              		.loc 1 372 0
 1127 02d0 454B     		ldr	r3, .L77+140
 1128 02d2 1E70     		strb	r6, [r3]
 1129              	.LVL121:
 1130              	.LBB181:
 1131              	.LBB182:
 1132              	.LBB183:
 190:../drivers/fsl_gpio.h **** }
 1133              		.loc 6 190 0
 1134 02d4 8023     		movs	r3, #128
 1135 02d6 1B03     		lsls	r3, r3, #12
 1136              	.LVL122:
 1137              	.L75:
 1138              	.LBE183:
 1139              	.LBE182:
 1140              	.LBE181:
 1141              	.LBB184:
 1142              	.LBB185:
 1143              	.LBB186:
 1144 02d8 6360     		str	r3, [r4, #4]
 1145 02da A2E7     		b	.L42
 1146              	.L43:
 1147              	.LBE186:
 1148              	.LBE185:
 1149              	.LBE184:
 375:../source/main.c **** 			{
 1150              		.loc 1 375 0
 1151 02dc 4B49     		ldr	r1, .L77+176
 1152 02de 2800     		movs	r0, r5
 1153 02e0 FFF7FEFF 		bl	strstr
 1154              	.LVL123:
 1155 02e4 0028     		cmp	r0, #0
 1156 02e6 01D0     		beq	.L44
 1157              	.LVL124:
 1158              	.LBB189:
 1159              	.LBB179:
 1160              	.LBB178:
 1161              		.loc 6 210 0
 1162 02e8 0223     		movs	r3, #2
 1163 02ea 99E7     		b	.L74
 1164              	.LVL125:
 1165              	.L44:
 1166              	.LBE178:
 1167              	.LBE179:
 1168              	.LBE189:
 379:../source/main.c **** 			{
 1169              		.loc 1 379 0
 1170 02ec 4849     		ldr	r1, .L77+180
 1171 02ee 2800     		movs	r0, r5
 1172 02f0 FFF7FEFF 		bl	strstr
 1173              	.LVL126:
 1174 02f4 0028     		cmp	r0, #0
 1175 02f6 01D0     		beq	.L45
 1176              	.LVL127:
 1177              	.LBB190:
 1178              	.LBB188:
 1179              	.LBB187:
 190:../drivers/fsl_gpio.h **** }
 1180              		.loc 6 190 0
 1181 02f8 0223     		movs	r3, #2
 1182 02fa EDE7     		b	.L75
 1183              	.LVL128:
 1184              	.L45:
 1185              	.LBE187:
 1186              	.LBE188:
 1187              	.LBE190:
 383:../source/main.c **** 			{
 1188              		.loc 1 383 0
 1189 02fc 4549     		ldr	r1, .L77+184
 1190 02fe 2800     		movs	r0, r5
 1191 0300 FFF7FEFF 		bl	strstr
 1192              	.LVL129:
 1193 0304 0028     		cmp	r0, #0
 1194 0306 0AD0     		beq	.L46
 1195              	.LBB191:
 385:../source/main.c **** 				uint8_t ubxMsgLen = calcUbxCrc(PC_recBuf + 2); //Calculate UBX checksum and add it to the messa
 1196              		.loc 1 385 0
 1197 0308 4348     		ldr	r0, .L77+188
 1198 030a FFF7FEFF 		bl	PCprint
 1199              	.LVL130:
 386:../source/main.c **** 				GPS_send(PC_recBuf, ubxMsgLen); //Send UBX message to module
 1200              		.loc 1 386 0
 1201 030e 4348     		ldr	r0, .L77+192
 1202 0310 FFF7FEFF 		bl	calcUbxCrc
 1203              	.LVL131:
 1204 0314 0100     		movs	r1, r0
 1205              	.LVL132:
 387:../source/main.c **** 			}
 1206              		.loc 1 387 0
 1207 0316 2800     		movs	r0, r5
 1208 0318 FFF7FEFF 		bl	GPS_send
 1209              	.LVL133:
 1210              	.LBE191:
 1211 031c 81E7     		b	.L42
 1212              	.L46:
 392:../source/main.c **** 
 1213              		.loc 1 392 0
 1214 031e 2800     		movs	r0, r5
 1215 0320 FFF7FEFF 		bl	NB_send
 1216              	.LVL134:
 1217 0324 7DE7     		b	.L42
 1218              	.L52:
 1219              	.LBB192:
 448:../source/main.c **** 																		//will be NULL
 1220              		.loc 1 448 0
 1221 0326 3B49     		ldr	r1, .L77+184
 1222 0328 2800     		movs	r0, r5
 1223 032a FFF7FEFF 		bl	strstr
 1224              	.LVL135:
 1225 032e 061E     		subs	r6, r0, #0
 1226              	.LVL136:
 451:../source/main.c **** 			{
 1227              		.loc 1 451 0
 1228 0330 08D0     		beq	.L53
 1229              	.LBB168:
 453:../source/main.c **** 
 1230              		.loc 1 453 0
 1231 0332 3B48     		ldr	r0, .L77+196
 1232              	.LVL137:
 1233 0334 FFF7FEFF 		bl	PCprint
 1234              	.LVL138:
 461:../source/main.c **** 						responseLength + 6 + 2); //Print UBX response message. Function wants to know
 1235              		.loc 1 461 0
 1236 0338 3179     		ldrb	r1, [r6, #4]
 1237 033a 3000     		movs	r0, r6
 1238 033c 0831     		adds	r1, r1, #8
 1239 033e C9B2     		uxtb	r1, r1
 1240 0340 FFF7FEFF 		bl	printUbxResponseHex
 1241              	.LVL139:
 1242              	.L53:
 1243              	.LBE168:
 466:../source/main.c **** 			GPS_bufPtr = 0;
 1244              		.loc 1 466 0
 1245 0344 9622     		movs	r2, #150
 1246 0346 0021     		movs	r1, #0
 1247 0348 9200     		lsls	r2, r2, #2
 1248 034a 2800     		movs	r0, r5
 1249 034c FFF7FEFF 		bl	memset
 1250              	.LVL140:
 467:../source/main.c **** 			GPS_strReady = 0;
 1251              		.loc 1 467 0
 1252 0350 0023     		movs	r3, #0
 1253 0352 344A     		ldr	r2, .L77+200
 1254 0354 1380     		strh	r3, [r2]
 468:../source/main.c **** 		}
 1255              		.loc 1 468 0
 1256 0356 174A     		ldr	r2, .L77+88
 1257 0358 1370     		strb	r3, [r2]
 1258 035a FFE6     		b	.L33
 1259              	.L78:
 1260              		.align	2
 1261              	.L77:
 1262 035c 00D00740 		.word	1074253824
 1263 0360 CCFDFFFF 		.word	-564
 1264 0364 00E100E0 		.word	-536813312
 1265 0368 FFFFFF00 		.word	16777215
 1266 036c 10E000E0 		.word	-536813552
 1267 0370 00ED00E0 		.word	-536810240
 1268 0374 00F00F40 		.word	1074786304
 1269 0378 00000000 		.word	.LANCHOR0
 1270 037c 00E00740 		.word	1074257920
 1271 0380 00000000 		.word	smc_power_mode_vlls_config
 1272 0384 00C00740 		.word	1074249728
 1273 0388 00000440 		.word	1074003968
 1274 038c 00000000 		.word	.LC6
 1275 0390 90000000 		.word	.LC8
 1276 0394 00000000 		.word	.LANCHOR1
 1277 0398 E4000000 		.word	.LC13
 1278 039c EA000000 		.word	.LC15
 1279 03a0 00000000 		.word	.LANCHOR2
 1280 03a4 F0000000 		.word	.LC18
 1281 03a8 1A010000 		.word	.LC20
 1282 03ac 36010000 		.word	.LC22
 1283 03b0 4F010000 		.word	.LC24
 1284 03b4 00000000 		.word	.LANCHOR3
 1285 03b8 00000000 		.word	GPS_recBuf
 1286 03bc 54010000 		.word	.LC28
 1287 03c0 E0010000 		.word	.LC31
 1288 03c4 00000000 		.word	.LANCHOR4
 1289 03c8 00000000 		.word	PC_recBuf
 1290 03cc 57010000 		.word	.LC34
 1291 03d0 5B010000 		.word	.LC37
 1292 03d4 BE010000 		.word	.LC63
 1293 03d8 D8010000 		.word	.LC67
 1294 03dc D5010000 		.word	.LC65
 1295 03e0 D9010000 		.word	.LC69
 1296 03e4 79010000 		.word	.LC39
 1297 03e8 00000000 		.word	.LANCHOR5
 1298 03ec 00000000 		.word	.LANCHOR6
 1299 03f0 00000000 		.word	.LANCHOR7
 1300 03f4 00000000 		.word	.LANCHOR8
 1301 03f8 00000000 		.word	NB_recBuf
 1302 03fc 00000000 		.word	.LANCHOR9
 1303 0400 00000000 		.word	parsedLat
 1304 0404 00000000 		.word	parsedLon
 1305 0408 83010000 		.word	.LC42
 1306 040c 8D010000 		.word	.LC44
 1307 0410 93010000 		.word	.LC46
 1308 0414 98010000 		.word	.LC48
 1309 0418 9B010000 		.word	.LC50
 1310 041c 02000000 		.word	PC_recBuf+2
 1311 0420 A9010000 		.word	.LC60
 1312 0424 00000000 		.word	.LANCHOR10
 1313              	.LBE192:
 1314              		.cfi_endproc
 1315              	.LFE132:
 1317              		.section	.text.LLWU_IRQHandler,"ax",%progbits
 1318              		.align	1
 1319              		.global	LLWU_IRQHandler
 1320              		.syntax unified
 1321              		.code	16
 1322              		.thumb_func
 1323              		.fpu softvfp
 1325              	LLWU_IRQHandler:
 1326              	.LFB133:
 490:../source/main.c **** 
 491:../source/main.c **** 	while (1)
 492:../source/main.c **** 	{
 493:../source/main.c **** 
 494:../source/main.c **** 	}
 495:../source/main.c **** 	//parseData(testLat, testLon);
 496:../source/main.c **** }
 497:../source/main.c **** /*
 498:../source/main.c ****  void PORTC_IRQHandler() {
 499:../source/main.c **** 
 500:../source/main.c ****  PORTC->PCR[6] |= 0x01000000;
 501:../source/main.c **** 
 502:../source/main.c ****  while ( PORTC->PCR[6] & 0x01000000) {
 503:../source/main.c **** 
 504:../source/main.c ****  }
 505:../source/main.c **** 
 506:../source/main.c ****  LPTMR_Deinit(LPTMR0);			// Deinitiate timer to reset timer counte
 507:../source/main.c ****  LPTMR_Init(LPTMR0, &lptmr_config);
 508:../source/main.c ****  LPTMR_SetTimerPeriod(LPTMR0, 2000);  // 3000 for 20hz data rat
 509:../source/main.c ****  LPTMR_EnableInterrupts(LPTMR0, LPTMR_CSR_TIE_MASK);	//Sets Timer Interrupt Enable bit to 1
 510:../source/main.c ****  LPTMR_StartTimer(LPTMR0);
 511:../source/main.c ****  GPIO_PortToggle(GPIOB, 1 << 22u);
 512:../source/main.c **** 
 513:../source/main.c ****  }
 514:../source/main.c ****  */
 515:../source/main.c **** void LLWU_IRQHandler()
 516:../source/main.c **** {
 1327              		.loc 1 516 0
 1328              		.cfi_startproc
 1329              		@ args = 0, pretend = 0, frame = 0
 1330              		@ frame_needed = 0, uses_anonymous_args = 0
 1331              	.LVL141:
 517:../source/main.c **** 
 518:../source/main.c **** 	/* If wakeup by LPTMR. */
 519:../source/main.c **** 	if (LLWU_GetInternalWakeupModuleFlag(LLWU, 0U))
 1332              		.loc 1 519 0
 1333 0000 0120     		movs	r0, #1
 516:../source/main.c **** 
 1334              		.loc 1 516 0
 1335 0002 10B5     		push	{r4, lr}
 1336              		.cfi_def_cfa_offset 8
 1337              		.cfi_offset 4, -8
 1338              		.cfi_offset 14, -4
 1339              	.LBB193:
 1340              	.LBB194:
 1341              		.file 7 "../drivers/fsl_llwu.h"
   1:../drivers/fsl_llwu.h **** /*
   2:../drivers/fsl_llwu.h ****  * The Clear BSD License
   3:../drivers/fsl_llwu.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   4:../drivers/fsl_llwu.h ****  * Copyright 2016-2017 NXP
   5:../drivers/fsl_llwu.h ****  * All rights reserved.
   6:../drivers/fsl_llwu.h ****  *
   7:../drivers/fsl_llwu.h ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../drivers/fsl_llwu.h ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../drivers/fsl_llwu.h ****  * that the following conditions are met:
  10:../drivers/fsl_llwu.h ****  *
  11:../drivers/fsl_llwu.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../drivers/fsl_llwu.h ****  *   of conditions and the following disclaimer.
  13:../drivers/fsl_llwu.h ****  *
  14:../drivers/fsl_llwu.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../drivers/fsl_llwu.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../drivers/fsl_llwu.h ****  *   other materials provided with the distribution.
  17:../drivers/fsl_llwu.h ****  *
  18:../drivers/fsl_llwu.h ****  * o Neither the name of the copyright holder nor the names of its
  19:../drivers/fsl_llwu.h ****  *   contributors may be used to endorse or promote products derived from this
  20:../drivers/fsl_llwu.h ****  *   software without specific prior written permission.
  21:../drivers/fsl_llwu.h ****  *
  22:../drivers/fsl_llwu.h ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../drivers/fsl_llwu.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../drivers/fsl_llwu.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../drivers/fsl_llwu.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../drivers/fsl_llwu.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../drivers/fsl_llwu.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../drivers/fsl_llwu.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../drivers/fsl_llwu.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../drivers/fsl_llwu.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../drivers/fsl_llwu.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../drivers/fsl_llwu.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../drivers/fsl_llwu.h ****  */
  34:../drivers/fsl_llwu.h **** #ifndef _FSL_LLWU_H_
  35:../drivers/fsl_llwu.h **** #define _FSL_LLWU_H_
  36:../drivers/fsl_llwu.h **** 
  37:../drivers/fsl_llwu.h **** #include "fsl_common.h"
  38:../drivers/fsl_llwu.h **** 
  39:../drivers/fsl_llwu.h **** /*! @addtogroup llwu */
  40:../drivers/fsl_llwu.h **** /*! @{ */
  41:../drivers/fsl_llwu.h **** 
  42:../drivers/fsl_llwu.h **** /*******************************************************************************
  43:../drivers/fsl_llwu.h ****  * Definitions
  44:../drivers/fsl_llwu.h ****  ******************************************************************************/
  45:../drivers/fsl_llwu.h **** 
  46:../drivers/fsl_llwu.h **** /*! @name Driver version */
  47:../drivers/fsl_llwu.h **** /*@{*/
  48:../drivers/fsl_llwu.h **** /*! @brief LLWU driver version 2.0.1. */
  49:../drivers/fsl_llwu.h **** #define FSL_LLWU_DRIVER_VERSION (MAKE_VERSION(2, 0, 1))
  50:../drivers/fsl_llwu.h **** /*@}*/
  51:../drivers/fsl_llwu.h **** 
  52:../drivers/fsl_llwu.h **** /*!
  53:../drivers/fsl_llwu.h ****  * @brief External input pin control modes
  54:../drivers/fsl_llwu.h ****  */
  55:../drivers/fsl_llwu.h **** typedef enum _llwu_external_pin_mode
  56:../drivers/fsl_llwu.h **** {
  57:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinDisable = 0U,     /*!< Pin disabled as a wakeup input.           */
  58:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinRisingEdge = 1U,  /*!< Pin enabled with the rising edge detection. */
  59:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinFallingEdge = 2U, /*!< Pin enabled with the falling edge detection.*/
  60:../drivers/fsl_llwu.h ****     kLLWU_ExternalPinAnyEdge = 3U      /*!< Pin enabled with any change detection.  */
  61:../drivers/fsl_llwu.h **** } llwu_external_pin_mode_t;
  62:../drivers/fsl_llwu.h **** 
  63:../drivers/fsl_llwu.h **** /*!
  64:../drivers/fsl_llwu.h ****  * @brief Digital filter control modes
  65:../drivers/fsl_llwu.h ****  */
  66:../drivers/fsl_llwu.h **** typedef enum _llwu_pin_filter_mode
  67:../drivers/fsl_llwu.h **** {
  68:../drivers/fsl_llwu.h ****     kLLWU_PinFilterDisable = 0U,     /*!< Filter disabled.               */
  69:../drivers/fsl_llwu.h ****     kLLWU_PinFilterRisingEdge = 1U,  /*!< Filter positive edge detection.*/
  70:../drivers/fsl_llwu.h ****     kLLWU_PinFilterFallingEdge = 2U, /*!< Filter negative edge detection.*/
  71:../drivers/fsl_llwu.h ****     kLLWU_PinFilterAnyEdge = 3U      /*!< Filter any edge detection.     */
  72:../drivers/fsl_llwu.h **** } llwu_pin_filter_mode_t;
  73:../drivers/fsl_llwu.h **** 
  74:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_VERID) && FSL_FEATURE_LLWU_HAS_VERID)
  75:../drivers/fsl_llwu.h **** /*!
  76:../drivers/fsl_llwu.h ****  * @brief IP version ID definition.
  77:../drivers/fsl_llwu.h ****  */
  78:../drivers/fsl_llwu.h **** typedef struct _llwu_version_id
  79:../drivers/fsl_llwu.h **** {
  80:../drivers/fsl_llwu.h ****     uint16_t feature; /*!< A feature specification number. */
  81:../drivers/fsl_llwu.h ****     uint8_t minor;    /*!< The minor version number.         */
  82:../drivers/fsl_llwu.h ****     uint8_t major;    /*!< The major version number.         */
  83:../drivers/fsl_llwu.h **** } llwu_version_id_t;
  84:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_VERID */
  85:../drivers/fsl_llwu.h **** 
  86:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_PARAM) && FSL_FEATURE_LLWU_HAS_PARAM)
  87:../drivers/fsl_llwu.h **** /*!
  88:../drivers/fsl_llwu.h ****  * @brief IP parameter definition.
  89:../drivers/fsl_llwu.h ****  */
  90:../drivers/fsl_llwu.h **** typedef struct _llwu_param
  91:../drivers/fsl_llwu.h **** {
  92:../drivers/fsl_llwu.h ****     uint8_t filters; /*!< A number of the pin filter.      */
  93:../drivers/fsl_llwu.h ****     uint8_t dmas;    /*!< A number of the wakeup DMA.      */
  94:../drivers/fsl_llwu.h ****     uint8_t modules; /*!< A number of the wakeup module.   */
  95:../drivers/fsl_llwu.h ****     uint8_t pins;    /*!< A number of the wake up pin.     */
  96:../drivers/fsl_llwu.h **** } llwu_param_t;
  97:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_PARAM */
  98:../drivers/fsl_llwu.h **** 
  99:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_PIN_FILTER) && FSL_FEATURE_LLWU_HAS_PIN_FILTER)
 100:../drivers/fsl_llwu.h **** /*!
 101:../drivers/fsl_llwu.h ****  * @brief An external input pin filter control structure
 102:../drivers/fsl_llwu.h ****  */
 103:../drivers/fsl_llwu.h **** typedef struct _llwu_external_pin_filter_mode
 104:../drivers/fsl_llwu.h **** {
 105:../drivers/fsl_llwu.h ****     uint32_t pinIndex;                 /*!< A pin number  */
 106:../drivers/fsl_llwu.h ****     llwu_pin_filter_mode_t filterMode; /*!< Filter mode */
 107:../drivers/fsl_llwu.h **** } llwu_external_pin_filter_mode_t;
 108:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_PIN_FILTER */
 109:../drivers/fsl_llwu.h **** 
 110:../drivers/fsl_llwu.h **** /*******************************************************************************
 111:../drivers/fsl_llwu.h ****  * API
 112:../drivers/fsl_llwu.h ****  ******************************************************************************/
 113:../drivers/fsl_llwu.h **** 
 114:../drivers/fsl_llwu.h **** #if defined(__cplusplus)
 115:../drivers/fsl_llwu.h **** extern "C" {
 116:../drivers/fsl_llwu.h **** #endif
 117:../drivers/fsl_llwu.h **** 
 118:../drivers/fsl_llwu.h **** /*!
 119:../drivers/fsl_llwu.h ****  * @name Low-Leakage Wakeup Unit Control APIs
 120:../drivers/fsl_llwu.h ****  * @{
 121:../drivers/fsl_llwu.h ****  */
 122:../drivers/fsl_llwu.h **** 
 123:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_VERID) && FSL_FEATURE_LLWU_HAS_VERID)
 124:../drivers/fsl_llwu.h **** /*!
 125:../drivers/fsl_llwu.h ****  * @brief Gets the LLWU version ID.
 126:../drivers/fsl_llwu.h ****  *
 127:../drivers/fsl_llwu.h ****  * This function gets the LLWU version ID, including the major version number,
 128:../drivers/fsl_llwu.h ****  * the minor version number, and the feature specification number.
 129:../drivers/fsl_llwu.h ****  *
 130:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 131:../drivers/fsl_llwu.h ****  * @param versionId     A pointer to the version ID structure.
 132:../drivers/fsl_llwu.h ****  */
 133:../drivers/fsl_llwu.h **** static inline void LLWU_GetVersionId(LLWU_Type *base, llwu_version_id_t *versionId)
 134:../drivers/fsl_llwu.h **** {
 135:../drivers/fsl_llwu.h ****     *((uint32_t *)versionId) = base->VERID;
 136:../drivers/fsl_llwu.h **** }
 137:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_VERID */
 138:../drivers/fsl_llwu.h **** 
 139:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_PARAM) && FSL_FEATURE_LLWU_HAS_PARAM)
 140:../drivers/fsl_llwu.h **** /*!
 141:../drivers/fsl_llwu.h ****  * @brief Gets the LLWU parameter.
 142:../drivers/fsl_llwu.h ****  *
 143:../drivers/fsl_llwu.h ****  * This function gets the LLWU parameter, including a wakeup pin number, a module
 144:../drivers/fsl_llwu.h ****  * number, a DMA number, and a pin filter number.
 145:../drivers/fsl_llwu.h ****  *
 146:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 147:../drivers/fsl_llwu.h ****  * @param param         A pointer to the LLWU parameter structure.
 148:../drivers/fsl_llwu.h ****  */
 149:../drivers/fsl_llwu.h **** static inline void LLWU_GetParam(LLWU_Type *base, llwu_param_t *param)
 150:../drivers/fsl_llwu.h **** {
 151:../drivers/fsl_llwu.h ****     *((uint32_t *)param) = base->PARAM;
 152:../drivers/fsl_llwu.h **** }
 153:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_PARAM */
 154:../drivers/fsl_llwu.h **** 
 155:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN) && FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN)
 156:../drivers/fsl_llwu.h **** /*!
 157:../drivers/fsl_llwu.h ****  * @brief Sets the external input pin source mode.
 158:../drivers/fsl_llwu.h ****  *
 159:../drivers/fsl_llwu.h ****  * This function sets the external input pin source mode that is used
 160:../drivers/fsl_llwu.h ****  * as a wake up source.
 161:../drivers/fsl_llwu.h ****  *
 162:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 163:../drivers/fsl_llwu.h ****  * @param pinIndex A pin index to be enabled as an external wakeup source starting from 1.
 164:../drivers/fsl_llwu.h ****  * @param pinMode A pin configuration mode defined in the llwu_external_pin_modes_t.
 165:../drivers/fsl_llwu.h ****  */
 166:../drivers/fsl_llwu.h **** void LLWU_SetExternalWakeupPinMode(LLWU_Type *base, uint32_t pinIndex, llwu_external_pin_mode_t pin
 167:../drivers/fsl_llwu.h **** 
 168:../drivers/fsl_llwu.h **** /*!
 169:../drivers/fsl_llwu.h ****  * @brief Gets the external wakeup source flag.
 170:../drivers/fsl_llwu.h ****  *
 171:../drivers/fsl_llwu.h ****  * This function checks the external pin flag to detect whether the MCU is
 172:../drivers/fsl_llwu.h ****  * woken up by the specific pin.
 173:../drivers/fsl_llwu.h ****  *
 174:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 175:../drivers/fsl_llwu.h ****  * @param pinIndex     A pin index, which starts from 1.
 176:../drivers/fsl_llwu.h ****  * @return True if the specific pin is a wakeup source.
 177:../drivers/fsl_llwu.h ****  */
 178:../drivers/fsl_llwu.h **** bool LLWU_GetExternalWakeupPinFlag(LLWU_Type *base, uint32_t pinIndex);
 179:../drivers/fsl_llwu.h **** 
 180:../drivers/fsl_llwu.h **** /*!
 181:../drivers/fsl_llwu.h ****  * @brief Clears the external wakeup source flag.
 182:../drivers/fsl_llwu.h ****  *
 183:../drivers/fsl_llwu.h ****  * This function clears the external wakeup source flag for a specific pin.
 184:../drivers/fsl_llwu.h ****  *
 185:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 186:../drivers/fsl_llwu.h ****  * @param pinIndex A pin index, which starts from 1.
 187:../drivers/fsl_llwu.h ****  */
 188:../drivers/fsl_llwu.h **** void LLWU_ClearExternalWakeupPinFlag(LLWU_Type *base, uint32_t pinIndex);
 189:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN */
 190:../drivers/fsl_llwu.h **** 
 191:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE) && FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE)
 192:../drivers/fsl_llwu.h **** /*!
 193:../drivers/fsl_llwu.h ****  * @brief Enables/disables the internal module source.
 194:../drivers/fsl_llwu.h ****  *
 195:../drivers/fsl_llwu.h ****  * This function enables/disables the internal module source mode that is used
 196:../drivers/fsl_llwu.h ****  * as a wake up source.
 197:../drivers/fsl_llwu.h ****  *
 198:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 199:../drivers/fsl_llwu.h ****  * @param moduleIndex   A module index to be enabled as an internal wakeup source starting from 1.
 200:../drivers/fsl_llwu.h ****  * @param enable        An enable or a disable setting
 201:../drivers/fsl_llwu.h ****  */
 202:../drivers/fsl_llwu.h **** static inline void LLWU_EnableInternalModuleInterruptWakup(LLWU_Type *base, uint32_t moduleIndex, b
 203:../drivers/fsl_llwu.h **** {
 204:../drivers/fsl_llwu.h ****     if (enable)
 205:../drivers/fsl_llwu.h ****     {
 206:../drivers/fsl_llwu.h ****         base->ME |= 1U << moduleIndex;
 207:../drivers/fsl_llwu.h ****     }
 208:../drivers/fsl_llwu.h ****     else
 209:../drivers/fsl_llwu.h ****     {
 210:../drivers/fsl_llwu.h ****         base->ME &= ~(1U << moduleIndex);
 211:../drivers/fsl_llwu.h ****     }
 212:../drivers/fsl_llwu.h **** }
 213:../drivers/fsl_llwu.h **** 
 214:../drivers/fsl_llwu.h **** #if (!(defined(FSL_FEATURE_LLWU_HAS_NO_INTERNAL_MODULE_WAKEUP_FLAG_REG) && \
 215:../drivers/fsl_llwu.h ****        FSL_FEATURE_LLWU_HAS_NO_INTERNAL_MODULE_WAKEUP_FLAG_REG))
 216:../drivers/fsl_llwu.h **** /* Re-define the register which includes the internal wakeup module flag. */
 217:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_REG_BITWIDTH) && (FSL_FEATURE_LLWU_REG_BITWIDTH == 32)) /* 32-bit LLW
 218:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_MF) && FSL_FEATURE_LLWU_HAS_MF)
 219:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG MF
 220:../drivers/fsl_llwu.h **** #else
 221:../drivers/fsl_llwu.h **** #error "Unsupported internal module flag register."
 222:../drivers/fsl_llwu.h **** #endif
 223:../drivers/fsl_llwu.h **** #else /* 8-bit LLUW. */
 224:../drivers/fsl_llwu.h **** #if (defined(FSL_FEATURE_LLWU_HAS_MF) && FSL_FEATURE_LLWU_HAS_MF)
 225:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG MF5
 226:../drivers/fsl_llwu.h **** #elif(defined(FSL_FEATURE_LLWU_HAS_PF) && FSL_FEATURE_LLWU_HAS_PF)
 227:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG PF3
 228:../drivers/fsl_llwu.h **** #elif(!(defined(FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN) && (FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN > 16)))
 229:../drivers/fsl_llwu.h **** #define INTERNAL_WAKEUP_MODULE_FLAG_REG F3
 230:../drivers/fsl_llwu.h **** #else
 231:../drivers/fsl_llwu.h **** #error "Unsupported internal module flag register."
 232:../drivers/fsl_llwu.h **** #endif
 233:../drivers/fsl_llwu.h **** #endif /* FSL_FEATURE_LLWU_REG_BITWIDTH */
 234:../drivers/fsl_llwu.h **** 
 235:../drivers/fsl_llwu.h **** /*!
 236:../drivers/fsl_llwu.h ****  * @brief Gets the external wakeup source flag.
 237:../drivers/fsl_llwu.h ****  *
 238:../drivers/fsl_llwu.h ****  * This function checks the external pin flag to detect whether the system is
 239:../drivers/fsl_llwu.h ****  * woken up by the specific pin.
 240:../drivers/fsl_llwu.h ****  *
 241:../drivers/fsl_llwu.h ****  * @param base LLWU peripheral base address.
 242:../drivers/fsl_llwu.h ****  * @param moduleIndex  A module index, which starts from 1.
 243:../drivers/fsl_llwu.h ****  * @return True if the specific pin is a wake up source.
 244:../drivers/fsl_llwu.h ****  */
 245:../drivers/fsl_llwu.h **** static inline bool LLWU_GetInternalWakeupModuleFlag(LLWU_Type *base, uint32_t moduleIndex)
 246:../drivers/fsl_llwu.h **** {
 247:../drivers/fsl_llwu.h ****     return ((1U << moduleIndex) == (base->INTERNAL_WAKEUP_MODULE_FLAG_REG & (1U << moduleIndex)));
 1342              		.loc 7 247 0
 1343 0004 104B     		ldr	r3, .L85
 1344 0006 DA79     		ldrb	r2, [r3, #7]
 1345              	.LBE194:
 1346              	.LBE193:
 1347              		.loc 1 519 0
 1348 0008 0242     		tst	r2, r0
 1349 000a 11D0     		beq	.L80
 1350              	.LVL142:
 1351              	.LBB195:
 1352              	.LBB196:
 226:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 1353              		.loc 2 226 0
 1354 000c C024     		movs	r4, #192
 222:../drivers/fsl_lptmr.h **** 
 1355              		.loc 2 222 0
 1356 000e 0F4A     		ldr	r2, .L85+4
 1357 0010 1168     		ldr	r1, [r2]
 1358              	.LVL143:
 226:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 1359              		.loc 2 226 0
 1360 0012 A143     		bics	r1, r4
 1361              	.LVL144:
 227:../drivers/fsl_lptmr.h **** }
 1362              		.loc 2 227 0
 1363 0014 1160     		str	r1, [r2]
 1364              	.LVL145:
 1365              	.LBE196:
 1366              	.LBE195:
 1367              	.LBB197:
 1368              	.LBB198:
 292:../drivers/fsl_lptmr.h **** }
 1369              		.loc 2 292 0
 1370 0016 8021     		movs	r1, #128
 1371 0018 1468     		ldr	r4, [r2]
 1372 001a 2143     		orrs	r1, r4
 1373              	.LBE198:
 1374              	.LBE197:
 1375              	.LBB200:
 1376              	.LBB201:
 367:../drivers/fsl_lptmr.h **** }
 368:../drivers/fsl_lptmr.h **** 
 369:../drivers/fsl_lptmr.h **** /*!
 370:../drivers/fsl_lptmr.h ****  * @brief Stops the timer.
 371:../drivers/fsl_lptmr.h ****  *
 372:../drivers/fsl_lptmr.h ****  * This function stops the timer and resets the timer's counter register.
 373:../drivers/fsl_lptmr.h ****  *
 374:../drivers/fsl_lptmr.h ****  * @param base LPTMR peripheral base address
 375:../drivers/fsl_lptmr.h ****  */
 376:../drivers/fsl_lptmr.h **** static inline void LPTMR_StopTimer(LPTMR_Type *base)
 377:../drivers/fsl_lptmr.h **** {
 378:../drivers/fsl_lptmr.h ****     uint32_t reg = base->CSR;
 379:../drivers/fsl_lptmr.h **** 
 380:../drivers/fsl_lptmr.h ****     /* Clear the TCF bit to avoid clearing the w1c bit when writing back. */
 381:../drivers/fsl_lptmr.h ****     reg &= ~(LPTMR_CSR_TCF_MASK);
 382:../drivers/fsl_lptmr.h ****     reg &= ~LPTMR_CSR_TEN_MASK;
 1377              		.loc 2 382 0
 1378 001c 8124     		movs	r4, #129
 1379              	.LBE201:
 1380              	.LBE200:
 1381              	.LBB203:
 1382              	.LBB199:
 292:../drivers/fsl_lptmr.h **** }
 1383              		.loc 2 292 0
 1384 001e 1160     		str	r1, [r2]
 1385              	.LVL146:
 1386              	.LBE199:
 1387              	.LBE203:
 1388              	.LBB204:
 1389              	.LBB202:
 378:../drivers/fsl_lptmr.h **** 
 1390              		.loc 2 378 0
 1391 0020 1168     		ldr	r1, [r2]
 1392              	.LVL147:
 1393              		.loc 2 382 0
 1394 0022 A143     		bics	r1, r4
 1395              	.LVL148:
 383:../drivers/fsl_lptmr.h ****     base->CSR = reg;
 1396              		.loc 2 383 0
 1397 0024 1160     		str	r1, [r2]
 1398              	.LVL149:
 1399              	.LBE202:
 1400              	.LBE204:
 520:../source/main.c **** 	{
 521:../source/main.c **** 		LPTMR_DisableInterrupts(LPTMR0, kLPTMR_TimerInterruptEnable);
 522:../source/main.c **** 		LPTMR_ClearStatusFlags(LPTMR0, kLPTMR_TimerCompareFlag);
 523:../source/main.c **** 		LPTMR_StopTimer(LPTMR0);
 524:../source/main.c **** 		wake = 1;
 1401              		.loc 1 524 0
 1402 0026 0A4A     		ldr	r2, .L85+8
 1403 0028 1070     		strb	r0, [r2]
 1404              	.L81:
 525:../source/main.c **** 	}
 526:../source/main.c **** 
 527:../source/main.c **** 	else if ( LLWU->F1 & 0x20)
 528:../source/main.c **** 	{	// 0x04 for stock frdm acc wakeup reg, 0x01 for customized
 529:../source/main.c **** 		wake = 2;
 530:../source/main.c **** 		LLWU->F1 |= 0x20;
 531:../source/main.c **** 	}
 532:../source/main.c **** 
 533:../source/main.c **** 	LLWU->F1 = 0x20;
 1405              		.loc 1 533 0
 1406 002a 2022     		movs	r2, #32
 534:../source/main.c **** }
 1407              		.loc 1 534 0
 1408              		@ sp needed
 533:../source/main.c **** }
 1409              		.loc 1 533 0
 1410 002c 5A71     		strb	r2, [r3, #5]
 1411              		.loc 1 534 0
 1412 002e 10BD     		pop	{r4, pc}
 1413              	.L80:
 527:../source/main.c **** 	{	// 0x04 for stock frdm acc wakeup reg, 0x01 for customized
 1414              		.loc 1 527 0
 1415 0030 2022     		movs	r2, #32
 1416 0032 5979     		ldrb	r1, [r3, #5]
 1417 0034 1142     		tst	r1, r2
 1418 0036 F8D0     		beq	.L81
 529:../source/main.c **** 		LLWU->F1 |= 0x20;
 1419              		.loc 1 529 0
 1420 0038 0220     		movs	r0, #2
 1421 003a 0549     		ldr	r1, .L85+8
 1422 003c 0870     		strb	r0, [r1]
 530:../source/main.c **** 	}
 1423              		.loc 1 530 0
 1424 003e 5979     		ldrb	r1, [r3, #5]
 1425 0040 0A43     		orrs	r2, r1
 1426 0042 5A71     		strb	r2, [r3, #5]
 1427 0044 F1E7     		b	.L81
 1428              	.L86:
 1429 0046 C046     		.align	2
 1430              	.L85:
 1431 0048 00C00740 		.word	1074249728
 1432 004c 00000440 		.word	1074003968
 1433 0050 00000000 		.word	.LANCHOR2
 1434              		.cfi_endproc
 1435              	.LFE133:
 1437              		.section	.text.LPTMR0_IRQHandler,"ax",%progbits
 1438              		.align	1
 1439              		.global	LPTMR0_IRQHandler
 1440              		.syntax unified
 1441              		.code	16
 1442              		.thumb_func
 1443              		.fpu softvfp
 1445              	LPTMR0_IRQHandler:
 1446              	.LFB134:
 535:../source/main.c **** 
 536:../source/main.c **** void LPTMR0_IRQHandler()
 537:../source/main.c **** {
 1447              		.loc 1 537 0
 1448              		.cfi_startproc
 1449              		@ args = 0, pretend = 0, frame = 0
 1450              		@ frame_needed = 0, uses_anonymous_args = 0
 1451              		@ link register save eliminated.
 538:../source/main.c **** 
 539:../source/main.c **** 	LPTMR0->CSR |= LPTMR_CSR_TCF_MASK;		// Clear the interrupt flag
 1452              		.loc 1 539 0
 1453 0000 8022     		movs	r2, #128
 1454 0002 044B     		ldr	r3, .L90
 1455 0004 1968     		ldr	r1, [r3]
 1456 0006 1143     		orrs	r1, r2
 1457 0008 1960     		str	r1, [r3]
 1458              	.L88:
 540:../source/main.c **** 	while ( LPTMR0->CSR & LPTMR_CSR_TCF_MASK)
 1459              		.loc 1 540 0 discriminator 1
 1460 000a 1968     		ldr	r1, [r3]
 1461 000c 1142     		tst	r1, r2
 1462 000e FCD1     		bne	.L88
 541:../source/main.c **** 	{
 542:../source/main.c **** 
 543:../source/main.c **** 	}
 544:../source/main.c **** 
 545:../source/main.c **** 	//wake=1;
 546:../source/main.c **** 
 547:../source/main.c **** 	//PMC->REGSC |= 0x08;
 548:../source/main.c **** 
 549:../source/main.c **** 	//GPIO_PortToggle(GPIOB, 1 << 21u); //light blue LED
 550:../source/main.c **** }
 1463              		.loc 1 550 0
 1464              		@ sp needed
 1465 0010 7047     		bx	lr
 1466              	.L91:
 1467 0012 C046     		.align	2
 1468              	.L90:
 1469 0014 00000440 		.word	1074003968
 1470              		.cfi_endproc
 1471              	.LFE134:
 1473              		.section	.text.LPUART0_IRQHandler,"ax",%progbits
 1474              		.align	1
 1475              		.global	LPUART0_IRQHandler
 1476              		.syntax unified
 1477              		.code	16
 1478              		.thumb_func
 1479              		.fpu softvfp
 1481              	LPUART0_IRQHandler:
 1482              	.LFB135:
 551:../source/main.c **** 
 552:../source/main.c **** void LPUART0_IRQHandler()
 553:../source/main.c **** {
 1483              		.loc 1 553 0
 1484              		.cfi_startproc
 1485              		@ args = 0, pretend = 0, frame = 0
 1486              		@ frame_needed = 0, uses_anonymous_args = 0
 1487 0000 10B5     		push	{r4, lr}
 1488              		.cfi_def_cfa_offset 8
 1489              		.cfi_offset 4, -8
 1490              		.cfi_offset 14, -4
 554:../source/main.c **** 
 555:../source/main.c **** 	LPUART_ClearStatusFlags(LPUART0, kUART_RxDataRegFullFlag);
 1491              		.loc 1 555 0
 1492 0002 0D4C     		ldr	r4, .L96
 1493 0004 2021     		movs	r1, #32
 1494 0006 2000     		movs	r0, r4
 1495 0008 FFF7FEFF 		bl	LPUART_ClearStatusFlags
 1496              	.LVL150:
 1497              	.LBB205:
 1498              	.LBB206:
 211:../drivers/fsl_gpio.h **** }
 212:../drivers/fsl_gpio.h **** 
 213:../drivers/fsl_gpio.h **** /*!
 214:../drivers/fsl_gpio.h ****  * @brief Sets the output level of the multiple GPIO pins to the logic 0.
 215:../drivers/fsl_gpio.h ****  * @deprecated Do not use this function.  It has been superceded by @ref GPIO_PortClear.
 216:../drivers/fsl_gpio.h ****  *
 217:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 218:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 219:../drivers/fsl_gpio.h ****  */
 220:../drivers/fsl_gpio.h **** static inline void GPIO_ClearPinsOutput(GPIO_Type *base, uint32_t mask)
 221:../drivers/fsl_gpio.h **** {
 222:../drivers/fsl_gpio.h ****     GPIO_PortClear(base, mask);
 223:../drivers/fsl_gpio.h **** }
 224:../drivers/fsl_gpio.h **** 
 225:../drivers/fsl_gpio.h **** /*!
 226:../drivers/fsl_gpio.h ****  * @brief Reverses the current output logic of the multiple GPIO pins.
 227:../drivers/fsl_gpio.h ****  *
 228:../drivers/fsl_gpio.h ****  * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 229:../drivers/fsl_gpio.h ****  * @param mask GPIO pin number macro
 230:../drivers/fsl_gpio.h ****  */
 231:../drivers/fsl_gpio.h **** static inline void GPIO_PortToggle(GPIO_Type *base, uint32_t mask)
 232:../drivers/fsl_gpio.h **** {
 233:../drivers/fsl_gpio.h ****     base->PTOR = mask;
 1499              		.loc 6 233 0
 1500 000c 8022     		movs	r2, #128
 1501 000e 0B4B     		ldr	r3, .L96+4
 1502 0010 D203     		lsls	r2, r2, #15
 1503 0012 DA60     		str	r2, [r3, #12]
 1504              	.LVL151:
 1505              	.LBE206:
 1506              	.LBE205:
 556:../source/main.c **** 	GPIO_PortToggle(GPIOB, 1 << 22u); //toggle RED led to indicate data arrived from NB Iiootee module
 557:../source/main.c **** 
 558:../source/main.c **** 	uint8_t uartData = LPUART0->DATA;
 1507              		.loc 1 558 0
 1508 0014 E368     		ldr	r3, [r4, #12]
 1509 0016 D9B2     		uxtb	r1, r3
 1510              	.LVL152:
 559:../source/main.c **** 	if (uartData != 0)
 1511              		.loc 1 559 0
 1512 0018 0029     		cmp	r1, #0
 1513 001a 0CD0     		beq	.L92
 560:../source/main.c **** 	{
 561:../source/main.c **** 
 562:../source/main.c **** 		NB_recBuf[NB_bufPtr] = uartData;
 1514              		.loc 1 562 0
 1515 001c 084A     		ldr	r2, .L96+8
 1516 001e 094C     		ldr	r4, .L96+12
 1517 0020 1088     		ldrh	r0, [r2]
 1518 0022 2354     		strb	r3, [r4, r0]
 563:../source/main.c **** 		NB_bufPtr++;
 1519              		.loc 1 563 0
 1520 0024 1388     		ldrh	r3, [r2]
 1521 0026 0133     		adds	r3, r3, #1
 1522 0028 9BB2     		uxth	r3, r3
 1523 002a 1380     		strh	r3, [r2]
 564:../source/main.c **** 
 565:../source/main.c **** 		if (uartData == 0x0d)
 1524              		.loc 1 565 0
 1525 002c 0D29     		cmp	r1, #13
 1526 002e 02D1     		bne	.L92
 566:../source/main.c **** 		{
 567:../source/main.c **** 			NB_strReady = 1;
 1527              		.loc 1 567 0
 1528 0030 0122     		movs	r2, #1
 1529 0032 054B     		ldr	r3, .L96+16
 1530 0034 1A70     		strb	r2, [r3]
 1531              	.L92:
 568:../source/main.c **** 			//NB_bufPtr = 0;
 569:../source/main.c **** 		}
 570:../source/main.c **** 
 571:../source/main.c **** 	}
 572:../source/main.c **** 
 573:../source/main.c **** }
 1532              		.loc 1 573 0
 1533              		@ sp needed
 1534 0036 10BD     		pop	{r4, pc}
 1535              	.L97:
 1536              		.align	2
 1537              	.L96:
 1538 0038 00400540 		.word	1074085888
 1539 003c 40F00F40 		.word	1074786368
 1540 0040 00000000 		.word	.LANCHOR9
 1541 0044 00000000 		.word	NB_recBuf
 1542 0048 00000000 		.word	.LANCHOR7
 1543              		.cfi_endproc
 1544              	.LFE135:
 1546              		.section	.text.UART2_FLEXIO_IRQHandler,"ax",%progbits
 1547              		.align	1
 1548              		.global	UART2_FLEXIO_IRQHandler
 1549              		.syntax unified
 1550              		.code	16
 1551              		.thumb_func
 1552              		.fpu softvfp
 1554              	UART2_FLEXIO_IRQHandler:
 1555              	.LFB136:
 574:../source/main.c **** 
 575:../source/main.c **** void UART2_FLEXIO_IRQHandler()
 576:../source/main.c **** {
 1556              		.loc 1 576 0
 1557              		.cfi_startproc
 1558              		@ args = 0, pretend = 0, frame = 0
 1559              		@ frame_needed = 0, uses_anonymous_args = 0
 1560 0000 10B5     		push	{r4, lr}
 1561              		.cfi_def_cfa_offset 8
 1562              		.cfi_offset 4, -8
 1563              		.cfi_offset 14, -4
 577:../source/main.c **** 
 578:../source/main.c **** 	UART_ClearStatusFlags(UART2, kUART_RxDataRegFullFlag);
 1564              		.loc 1 578 0
 1565 0002 0E4C     		ldr	r4, .L101
 1566 0004 2021     		movs	r1, #32
 1567 0006 2000     		movs	r0, r4
 1568 0008 FFF7FEFF 		bl	UART_ClearStatusFlags
 1569              	.LVL153:
 579:../source/main.c **** 
 580:../source/main.c **** 	uint8_t uartData = UART2->D;
 581:../source/main.c **** 
 582:../source/main.c **** 	/*
 583:../source/main.c **** 	 * Here we use different method for collecting GPS data. because there can be other data than char
 584:../source/main.c **** 	 * like 0x00 in UBX messages, normal string functions would fail (mistaken null terminator)
 585:../source/main.c **** 	 * so we must collect every byte from the gps module
 586:../source/main.c **** 	 * so fill buffer to almost full with GPS data, then put GPS_strReady high and stop filling.
 587:../source/main.c **** 	 * Start filling again when data has been read and GPS_strReady is low.
 588:../source/main.c **** 	 *
 589:../source/main.c **** 	 */
 590:../source/main.c **** 	if (GPS_strReady == 0)
 1570              		.loc 1 590 0
 1571 000c 0C49     		ldr	r1, .L101+4
 580:../source/main.c **** 
 1572              		.loc 1 580 0
 1573 000e E379     		ldrb	r3, [r4, #7]
 1574              		.loc 1 590 0
 1575 0010 0878     		ldrb	r0, [r1]
 580:../source/main.c **** 
 1576              		.loc 1 580 0
 1577 0012 DBB2     		uxtb	r3, r3
 1578              	.LVL154:
 1579 0014 0B4A     		ldr	r2, .L101+8
 1580              		.loc 1 590 0
 1581 0016 0028     		cmp	r0, #0
 1582 0018 06D1     		bne	.L99
 591:../source/main.c **** 	{
 592:../source/main.c **** 		GPS_recBuf[GPS_bufPtr] = uartData; //put new byte to buffer
 1583              		.loc 1 592 0
 1584 001a 1088     		ldrh	r0, [r2]
 1585 001c 0A4C     		ldr	r4, .L101+12
 1586 001e 2354     		strb	r3, [r4, r0]
 593:../source/main.c **** 		GPS_bufPtr++;
 1587              		.loc 1 593 0
 1588 0020 1388     		ldrh	r3, [r2]
 1589              	.LVL155:
 1590 0022 0133     		adds	r3, r3, #1
 1591 0024 9BB2     		uxth	r3, r3
 1592 0026 1380     		strh	r3, [r2]
 1593              	.LVL156:
 1594              	.L99:
 594:../source/main.c **** 	}
 595:../source/main.c **** 
 596:../source/main.c **** 	/*
 597:../source/main.c **** 	 * When buffer is almost full, put strReady high and stop filling it
 598:../source/main.c **** 	 */
 599:../source/main.c **** 	if (GPS_bufPtr > 499)
 1595              		.loc 1 599 0
 1596 0028 F423     		movs	r3, #244
 1597 002a 1288     		ldrh	r2, [r2]
 1598 002c FF33     		adds	r3, r3, #255
 1599 002e 9A42     		cmp	r2, r3
 1600 0030 02D9     		bls	.L98
 600:../source/main.c **** 	{
 601:../source/main.c **** 		GPS_strReady = 1;
 1601              		.loc 1 601 0
 1602 0032 F33B     		subs	r3, r3, #243
 1603 0034 FF3B     		subs	r3, r3, #255
 1604 0036 0B70     		strb	r3, [r1]
 1605              	.L98:
 602:../source/main.c **** 	}
 603:../source/main.c **** 
 604:../source/main.c **** }
 1606              		.loc 1 604 0
 1607              		@ sp needed
 1608 0038 10BD     		pop	{r4, pc}
 1609              	.L102:
 1610 003a C046     		.align	2
 1611              	.L101:
 1612 003c 00C00640 		.word	1074184192
 1613 0040 00000000 		.word	.LANCHOR3
 1614 0044 00000000 		.word	.LANCHOR10
 1615 0048 00000000 		.word	GPS_recBuf
 1616              		.cfi_endproc
 1617              	.LFE136:
 1619              		.section	.text.LPUART1_IRQHandler,"ax",%progbits
 1620              		.align	1
 1621              		.global	LPUART1_IRQHandler
 1622              		.syntax unified
 1623              		.code	16
 1624              		.thumb_func
 1625              		.fpu softvfp
 1627              	LPUART1_IRQHandler:
 1628              	.LFB137:
 605:../source/main.c **** 
 606:../source/main.c **** void LPUART1_IRQHandler()
 607:../source/main.c **** {
 1629              		.loc 1 607 0
 1630              		.cfi_startproc
 1631              		@ args = 0, pretend = 0, frame = 0
 1632              		@ frame_needed = 0, uses_anonymous_args = 0
 1633              		@ link register save eliminated.
 608:../source/main.c **** 
 609:../source/main.c **** 	uint8_t uartData = LPUART1->DATA;
 610:../source/main.c **** 	//GPIO_PortToggle(GPIOA, 1 << 4u);
 611:../source/main.c **** 
 612:../source/main.c **** 	PC_recBuf[PC_bufPtr] = uartData;
 1634              		.loc 1 612 0
 1635 0000 094A     		ldr	r2, .L105
 609:../source/main.c **** 	//GPIO_PortToggle(GPIOA, 1 << 4u);
 1636              		.loc 1 609 0
 1637 0002 0A4B     		ldr	r3, .L105+4
 1638              		.loc 1 612 0
 1639 0004 0A48     		ldr	r0, .L105+8
 609:../source/main.c **** 	//GPIO_PortToggle(GPIOA, 1 << 4u);
 1640              		.loc 1 609 0
 1641 0006 D968     		ldr	r1, [r3, #12]
 1642              	.LVL157:
 1643              		.loc 1 612 0
 1644 0008 1388     		ldrh	r3, [r2]
 1645 000a C154     		strb	r1, [r0, r3]
 613:../source/main.c **** 	PC_bufPtr++;
 1646              		.loc 1 613 0
 1647 000c 1388     		ldrh	r3, [r2]
 614:../source/main.c **** 
 615:../source/main.c **** 	if (uartData == 0x0d)
 1648              		.loc 1 615 0
 1649 000e C9B2     		uxtb	r1, r1
 613:../source/main.c **** 	PC_bufPtr++;
 1650              		.loc 1 613 0
 1651 0010 0133     		adds	r3, r3, #1
 1652 0012 9BB2     		uxth	r3, r3
 1653 0014 1380     		strh	r3, [r2]
 1654              		.loc 1 615 0
 1655 0016 0D29     		cmp	r1, #13
 1656 0018 04D1     		bne	.L103
 616:../source/main.c **** 	{
 617:../source/main.c **** 		PC_strReady = 1;
 1657              		.loc 1 617 0
 1658 001a 064B     		ldr	r3, .L105+12
 1659 001c 0C39     		subs	r1, r1, #12
 1660              	.LVL158:
 1661 001e 1970     		strb	r1, [r3]
 618:../source/main.c **** 		PC_bufPtr = 0;
 1662              		.loc 1 618 0
 1663 0020 0023     		movs	r3, #0
 1664 0022 1380     		strh	r3, [r2]
 1665              	.LVL159:
 1666              	.L103:
 619:../source/main.c **** 
 620:../source/main.c **** 	}
 621:../source/main.c **** }
 1667              		.loc 1 621 0
 1668              		@ sp needed
 1669 0024 7047     		bx	lr
 1670              	.L106:
 1671 0026 C046     		.align	2
 1672              	.L105:
 1673 0028 00000000 		.word	.LANCHOR6
 1674 002c 00500540 		.word	1074089984
 1675 0030 00000000 		.word	PC_recBuf
 1676 0034 00000000 		.word	.LANCHOR4
 1677              		.cfi_endproc
 1678              	.LFE137:
 1680              		.comm	ms_ticks,4,4
 1681              		.global	moduleResponseTimeout
 1682              		.comm	parsedLon,15,1
 1683              		.comm	parsedLat,15,1
 1684              		.global	streamGps
 1685              		.global	GPS_strReady
 1686              		.global	GPS_bufPtr
 1687              		.comm	GPS_recBuf,600,1
 1688              		.global	PC_strReady
 1689              		.global	PC_bufPtr
 1690              		.comm	NB_recBuf,500,1
 1691              		.global	NB_bufPtr
 1692              		.global	NB_strReady
 1693              		.global	wake
 1694              		.comm	uart_config,8,4
 1695              		.comm	smc_power_mode_vlls_config,2,1
 1696              		.comm	lptmr_config,7,1
 1697              		.section	.rodata
 1698              		.set	.LANCHOR1,. + 0
 1699              	.LC10:
 1700 0000 36353030 		.ascii	"6500.53\000"
 1700      2E353300 
 1701 0008 000000   		.space	3
 1702              	.LC12:
 1703 000b 30323533 		.ascii	"02534.554\000"
 1703      342E3535 
 1703      3400
 1704 0015 00       		.space	1
 1705              	.LC30:
 1706 0016 36353030 		.ascii	"6500.02359\000"
 1706      2E303233 
 1706      353900
 1707 0021 00       		.space	1
 1708              		.section	.bss.GPS_bufPtr,"aw",%nobits
 1709              		.align	1
 1710              		.set	.LANCHOR10,. + 0
 1713              	GPS_bufPtr:
 1714 0000 0000     		.space	2
 1715              		.section	.bss.GPS_strReady,"aw",%nobits
 1716              		.set	.LANCHOR3,. + 0
 1719              	GPS_strReady:
 1720 0000 00       		.space	1
 1721              		.section	.bss.NB_bufPtr,"aw",%nobits
 1722              		.align	1
 1723              		.set	.LANCHOR9,. + 0
 1726              	NB_bufPtr:
 1727 0000 0000     		.space	2
 1728              		.section	.bss.NB_strReady,"aw",%nobits
 1729              		.set	.LANCHOR7,. + 0
 1732              	NB_strReady:
 1733 0000 00       		.space	1
 1734              		.section	.bss.PC_bufPtr,"aw",%nobits
 1735              		.align	1
 1736              		.set	.LANCHOR6,. + 0
 1739              	PC_bufPtr:
 1740 0000 0000     		.space	2
 1741              		.section	.bss.PC_recBuf,"aw",%nobits
 1744              	PC_recBuf:
 1745 0000 00000000 		.space	500
 1745      00000000 
 1745      00000000 
 1745      00000000 
 1745      00000000 
 1746              		.section	.bss.PC_strReady,"aw",%nobits
 1747              		.set	.LANCHOR4,. + 0
 1750              	PC_strReady:
 1751 0000 00       		.space	1
 1752              		.section	.bss.streamGps,"aw",%nobits
 1753              		.set	.LANCHOR5,. + 0
 1756              	streamGps:
 1757 0000 00       		.space	1
 1758              		.section	.bss.wake,"aw",%nobits
 1759              		.set	.LANCHOR2,. + 0
 1762              	wake:
 1763 0000 00       		.space	1
 1764              		.section	.data.moduleResponseTimeout,"aw",%progbits
 1765              		.align	2
 1766              		.set	.LANCHOR8,. + 0
 1769              	moduleResponseTimeout:
 1770 0000 D0070000 		.word	2000
 1771              		.section	.rodata.LED_configOutput.8156,"a",%progbits
 1772              		.set	.LANCHOR0,. + 0
 1775              	LED_configOutput.8156:
 1776 0000 01       		.byte	1
 1777 0001 01       		.byte	1
 1778              		.section	.rodata.main.str1.1,"aMS",%progbits,1
 1779              	.LC6:
 1780 0000 5265696E 		.ascii	"Reindeer IoT has started\015\012Command \"iot\" to "
 1780      64656572 
 1780      20496F54 
 1780      20686173 
 1780      20737461 
 1781 002b 73746172 		.ascii	"start executing reindeer track cycle\015\012Command"
 1781      74206578 
 1781      65637574 
 1781      696E6720 
 1781      7265696E 
 1782 0058 20226770 		.ascii	" \"gpsinfo=1\" or \"gpsinfo=0\" to switch GPS data "
 1782      73696E66 
 1782      6F3D3122 
 1782      206F7220 
 1782      22677073 
 1783 0087 6F6E2F6F 		.ascii	"on/off\015\012\000"
 1783      66660D0A 
 1783      00
 1784              	.LC8:
 1785 0090 4F722065 		.ascii	"Or enter normal AT commands here for SARA-N2\015\012"
 1785      6E746572 
 1785      206E6F72 
 1785      6D616C20 
 1785      41542063 
 1786 00be 4D6F6475 		.ascii	"Modules powered on and booting now!\015\012\000"
 1786      6C657320 
 1786      706F7765 
 1786      72656420 
 1786      6F6E2061 
 1787              	.LC13:
 1788 00e4 31313131 		.ascii	"11111\000"
 1788      3100
 1789              	.LC15:
 1790 00ea 66616C73 		.ascii	"false\000"
 1790      6500
 1791              	.LC18:
 1792 00f0 576F6B65 		.ascii	"Woken by ACCEL, reindeer is !!!ALIVE!!!\015\012\000"
 1792      6E206279 
 1792      20414343 
 1792      454C2C20 
 1792      7265696E 
 1793              	.LC20:
 1794 011a 77616B65 		.ascii	"wake was 0 going to sleep\015\012\000"
 1794      20776173 
 1794      20302067 
 1794      6F696E67 
 1794      20746F20 
 1795              	.LC22:
 1796 0136 77616B65 		.ascii	"wake on 1 jeesus tulee\015\012\000"
 1796      206F6E20 
 1796      31206A65 
 1796      65737573 
 1796      2074756C 
 1797              	.LC24:
 1798 014f 74727565 		.ascii	"true\000"
 1798      00
 1799              	.LC28:
 1800 0154 0D0A00   		.ascii	"\015\012\000"
 1801              	.LC34:
 1802 0157 696F7400 		.ascii	"iot\000"
 1803              	.LC37:
 1804 015b 53746172 		.ascii	"Starting Reindeer IoT cycle\015\012\000"
 1804      74696E67 
 1804      20526569 
 1804      6E646565 
 1804      7220496F 
 1805              	.LC39:
 1806 0179 67707369 		.ascii	"gpsinfo=1\000"
 1806      6E666F3D 
 1806      3100
 1807              	.LC42:
 1808 0183 67707369 		.ascii	"gpsinfo=0\000"
 1808      6E666F3D 
 1808      3000
 1809              	.LC44:
 1810 018d 72666F66 		.ascii	"rfoff\000"
 1810      6600
 1811              	.LC46:
 1812 0193 72666F6E 		.ascii	"rfon\000"
 1812      00
 1813              	.LC48:
 1814 0198 B56200   		.ascii	"\265b\000"
 1815              	.LC50:
 1816 019b 73656E64 		.ascii	"send to gps\015\012\000"
 1816      20746F20 
 1816      6770730D 
 1816      0A00
 1817              	.LC60:
 1818 01a9 466F756E 		.ascii	"Found UBX response\015\012\000"
 1818      64205542 
 1818      58207265 
 1818      73706F6E 
 1818      73650D0A 
 1819              	.LC63:
 1820 01be 526F6765 		.ascii	"Roger include main.c\015\012\000"
 1820      7220696E 
 1820      636C7564 
 1820      65206D61 
 1820      696E2E63 
 1821              	.LC65:
 1822 01d5 4F4B00   		.ascii	"OK\000"
 1823              	.LC67:
 1824 01d8 00       		.ascii	"\000"
 1825              	.LC69:
 1826 01d9 4346554E 		.ascii	"CFUN=0\000"
 1826      3D3000
 1827              	.LC31:
 1828 01e0 30323533 		.ascii	"02530.56951\000"
 1828      302E3536 
 1828      39353100 
 1829              		.text
 1830              	.Letext0:
 1831              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 1832              		.file 9 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1833              		.file 10 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1834              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1835              		.file 12 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 1836              		.file 13 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1837              		.file 14 "../CMSIS/MKL17Z4.h"
 1838              		.file 15 "../CMSIS/system_MKL17Z4.h"
 1839              		.file 16 "../drivers/fsl_common.h"
 1840              		.file 17 "../board/clock_config.h"
 1841              		.file 18 "../drivers/fsl_uart.h"
 1842              		.file 19 "../source/at_func.h"
 1843              		.file 20 "../drivers/fsl_lpuart.h"
 1844              		.file 21 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 1845              		.file 22 "../source/gps_func.h"
 1846              		.file 23 "../source/nbiot_func.h"
 1847              		.file 24 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/string.h"
 1848              		.file 25 "<built-in>"
 1849              		.file 26 "../board/pin_mux.h"
 1850              		.file 27 "../source/i2c_func.h"
 1851              		.file 28 "../source/acc_func.h"
 1852              		.file 29 "../source/timing.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccNwvFpX.s:16     .text.initTimer:0000000000000000 $t
     /tmp/ccNwvFpX.s:23     .text.initTimer:0000000000000000 initTimer
     /tmp/ccNwvFpX.s:81     .text.initTimer:0000000000000024 $d
                            *COM*:0000000000000007 lptmr_config
     /tmp/ccNwvFpX.s:88     .text.initUART:0000000000000000 $t
     /tmp/ccNwvFpX.s:95     .text.initUART:0000000000000000 initUART
     /tmp/ccNwvFpX.s:303    .text.initUART:00000000000000ac $d
                            *COM*:0000000000000008 uart_config
     /tmp/ccNwvFpX.s:314    .text.NB_send:0000000000000000 $t
     /tmp/ccNwvFpX.s:321    .text.NB_send:0000000000000000 NB_send
     /tmp/ccNwvFpX.s:373    .text.NB_send:0000000000000024 $d
     /tmp/ccNwvFpX.s:378    .text.GPS_send:0000000000000000 $t
     /tmp/ccNwvFpX.s:385    .text.GPS_send:0000000000000000 GPS_send
     /tmp/ccNwvFpX.s:441    .text.GPS_send:0000000000000028 $d
     /tmp/ccNwvFpX.s:446    .text.PCprint:0000000000000000 $t
     /tmp/ccNwvFpX.s:453    .text.PCprint:0000000000000000 PCprint
     /tmp/ccNwvFpX.s:501    .text.PCprint:0000000000000024 $d
     /tmp/ccNwvFpX.s:507    .text.startup.main:0000000000000000 $t
     /tmp/ccNwvFpX.s:514    .text.startup.main:0000000000000000 main
     /tmp/ccNwvFpX.s:1262   .text.startup.main:000000000000035c $d
                            *COM*:0000000000000002 smc_power_mode_vlls_config
                            *COM*:0000000000000258 GPS_recBuf
     /tmp/ccNwvFpX.s:1744   .bss.PC_recBuf:0000000000000000 PC_recBuf
                            *COM*:00000000000001f4 NB_recBuf
                            *COM*:000000000000000f parsedLat
                            *COM*:000000000000000f parsedLon
     /tmp/ccNwvFpX.s:1318   .text.LLWU_IRQHandler:0000000000000000 $t
     /tmp/ccNwvFpX.s:1325   .text.LLWU_IRQHandler:0000000000000000 LLWU_IRQHandler
     /tmp/ccNwvFpX.s:1431   .text.LLWU_IRQHandler:0000000000000048 $d
     /tmp/ccNwvFpX.s:1438   .text.LPTMR0_IRQHandler:0000000000000000 $t
     /tmp/ccNwvFpX.s:1445   .text.LPTMR0_IRQHandler:0000000000000000 LPTMR0_IRQHandler
     /tmp/ccNwvFpX.s:1469   .text.LPTMR0_IRQHandler:0000000000000014 $d
     /tmp/ccNwvFpX.s:1474   .text.LPUART0_IRQHandler:0000000000000000 $t
     /tmp/ccNwvFpX.s:1481   .text.LPUART0_IRQHandler:0000000000000000 LPUART0_IRQHandler
     /tmp/ccNwvFpX.s:1538   .text.LPUART0_IRQHandler:0000000000000038 $d
     /tmp/ccNwvFpX.s:1547   .text.UART2_FLEXIO_IRQHandler:0000000000000000 $t
     /tmp/ccNwvFpX.s:1554   .text.UART2_FLEXIO_IRQHandler:0000000000000000 UART2_FLEXIO_IRQHandler
     /tmp/ccNwvFpX.s:1612   .text.UART2_FLEXIO_IRQHandler:000000000000003c $d
     /tmp/ccNwvFpX.s:1620   .text.LPUART1_IRQHandler:0000000000000000 $t
     /tmp/ccNwvFpX.s:1627   .text.LPUART1_IRQHandler:0000000000000000 LPUART1_IRQHandler
     /tmp/ccNwvFpX.s:1673   .text.LPUART1_IRQHandler:0000000000000028 $d
                            *COM*:0000000000000004 ms_ticks
     /tmp/ccNwvFpX.s:1769   .data.moduleResponseTimeout:0000000000000000 moduleResponseTimeout
     /tmp/ccNwvFpX.s:1756   .bss.streamGps:0000000000000000 streamGps
     /tmp/ccNwvFpX.s:1719   .bss.GPS_strReady:0000000000000000 GPS_strReady
     /tmp/ccNwvFpX.s:1713   .bss.GPS_bufPtr:0000000000000000 GPS_bufPtr
     /tmp/ccNwvFpX.s:1750   .bss.PC_strReady:0000000000000000 PC_strReady
     /tmp/ccNwvFpX.s:1739   .bss.PC_bufPtr:0000000000000000 PC_bufPtr
     /tmp/ccNwvFpX.s:1726   .bss.NB_bufPtr:0000000000000000 NB_bufPtr
     /tmp/ccNwvFpX.s:1732   .bss.NB_strReady:0000000000000000 NB_strReady
     /tmp/ccNwvFpX.s:1762   .bss.wake:0000000000000000 wake
     /tmp/ccNwvFpX.s:1701   .rodata:0000000000000008 $d
     /tmp/ccNwvFpX.s:1709   .bss.GPS_bufPtr:0000000000000000 $d
     /tmp/ccNwvFpX.s:1720   .bss.GPS_strReady:0000000000000000 $d
     /tmp/ccNwvFpX.s:1722   .bss.NB_bufPtr:0000000000000000 $d
     /tmp/ccNwvFpX.s:1733   .bss.NB_strReady:0000000000000000 $d
     /tmp/ccNwvFpX.s:1735   .bss.PC_bufPtr:0000000000000000 $d
     /tmp/ccNwvFpX.s:1745   .bss.PC_recBuf:0000000000000000 $d
     /tmp/ccNwvFpX.s:1751   .bss.PC_strReady:0000000000000000 $d
     /tmp/ccNwvFpX.s:1757   .bss.streamGps:0000000000000000 $d
     /tmp/ccNwvFpX.s:1763   .bss.wake:0000000000000000 $d
     /tmp/ccNwvFpX.s:1765   .data.moduleResponseTimeout:0000000000000000 $d
     /tmp/ccNwvFpX.s:1775   .rodata.LED_configOutput.8156:0000000000000000 LED_configOutput.8156

UNDEFINED SYMBOLS
LPTMR_GetDefaultConfig
LPTMR_Init
SystemCoreClockUpdate
CLOCK_GetFreq
UART_GetDefaultConfig
LPUART_GetDefaultConfig
LPUART_Init
UART_Init
LPUART_EnableInterrupts
UART_EnableInterrupts
__aeabi_uidiv
BOARD_InitPins
BOARD_BootClockVLPR
CLOCK_GetCoreSysClkFreq
initI2C
configure_acc
acc_init
GPIO_PinInit
memcpy
memset
strcpy
SMC_PreEnterStopModes
SMC_SetPowerModeVlls
strstr
assembleMqtt
NB_create_pdp_send
AT_send
strlen
millis
breakIfAtOk
getGPS
calcUbxCrc
printUbxResponseHex
LPUART_ClearStatusFlags
UART_ClearStatusFlags
