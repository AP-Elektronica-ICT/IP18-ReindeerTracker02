   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"gps_func.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.printUbxResponseHex,"ax",%progbits
  16              		.align	1
  17              		.global	printUbxResponseHex
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	printUbxResponseHex:
  24              	.LFB3:
  25              		.file 1 "../source/gps_func.c"
   1:../source/gps_func.c **** /*
   2:../source/gps_func.c ****  * gps_func.c
   3:../source/gps_func.c ****  *
   4:../source/gps_func.c ****  *  Created on: Mar 15, 2018
   5:../source/gps_func.c ****  *      Author: nks
   6:../source/gps_func.c ****  */
   7:../source/gps_func.c **** 
   8:../source/gps_func.c **** #include <string.h>
   9:../source/gps_func.c **** #include <stdio.h>
  10:../source/gps_func.c **** #include <stdlib.h>
  11:../source/gps_func.c **** 
  12:../source/gps_func.c **** #include "gps_func.h"
  13:../source/gps_func.c **** #include "at_func.h"
  14:../source/gps_func.c **** extern uint8_t PCprint(char *data);
  15:../source/gps_func.c **** 
  16:../source/gps_func.c **** 
  17:../source/gps_func.c **** 
  18:../source/gps_func.c **** /*
  19:../source/gps_func.c ****  *
  20:../source/gps_func.c ****  * Print UBX response message as hex numbers
  21:../source/gps_func.c ****  * cannot print it normally by PCprint because it contains 0x00 as data
  22:../source/gps_func.c ****  */
  23:../source/gps_func.c **** 
  24:../source/gps_func.c **** void printUbxResponseHex(char* data, uint8_t dataLength)
  25:../source/gps_func.c **** {
  26              		.loc 1 25 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
  32              		.cfi_def_cfa_offset 24
  33              		.cfi_offset 0, -24
  34              		.cfi_offset 1, -20
  35              		.cfi_offset 2, -16
  36              		.cfi_offset 4, -12
  37              		.cfi_offset 5, -8
  38              		.cfi_offset 14, -4
  39 0002 0400     		movs	r4, r0
  40 0004 4518     		adds	r5, r0, r1
  41              	.LVL1:
  42              	.L2:
  43              	.LBB2:
  26:../source/gps_func.c **** 	char buffer[5];
  27:../source/gps_func.c **** 	for (uint8_t n = 0; n < dataLength; n++)
  44              		.loc 1 27 0 discriminator 1
  45 0006 AC42     		cmp	r4, r5
  46 0008 00D1     		bne	.L3
  47              	.LBE2:
  28:../source/gps_func.c **** 	{
  29:../source/gps_func.c **** 		sprintf(buffer,"%02x", (uint8_t) (*(data + n)));
  30:../source/gps_func.c **** 		PCprint(buffer);
  31:../source/gps_func.c **** 	}
  32:../source/gps_func.c **** }
  48              		.loc 1 32 0
  49              		@ sp needed
  50              	.LVL2:
  51 000a 37BD     		pop	{r0, r1, r2, r4, r5, pc}
  52              	.LVL3:
  53              	.L3:
  54              	.LBB3:
  29:../source/gps_func.c **** 		PCprint(buffer);
  55              		.loc 1 29 0 discriminator 3
  56 000c 2278     		ldrb	r2, [r4]
  57 000e 0449     		ldr	r1, .L4
  58 0010 6846     		mov	r0, sp
  59 0012 FFF7FEFF 		bl	sprintf
  60              	.LVL4:
  30:../source/gps_func.c **** 	}
  61              		.loc 1 30 0 discriminator 3
  62 0016 6846     		mov	r0, sp
  63 0018 FFF7FEFF 		bl	PCprint
  64              	.LVL5:
  65 001c 0134     		adds	r4, r4, #1
  66              	.LVL6:
  67 001e F2E7     		b	.L2
  68              	.L5:
  69              		.align	2
  70              	.L4:
  71 0020 00000000 		.word	.LC2
  72              	.LBE3:
  73              		.cfi_endproc
  74              	.LFE3:
  76              		.section	.text.calcUbxCrc,"ax",%progbits
  77              		.align	1
  78              		.global	calcUbxCrc
  79              		.syntax unified
  80              		.code	16
  81              		.thumb_func
  82              		.fpu softvfp
  84              	calcUbxCrc:
  85              	.LFB4:
  33:../source/gps_func.c **** 
  34:../source/gps_func.c **** uint8_t calcUbxCrc(char *data)
  35:../source/gps_func.c **** {
  86              		.loc 1 35 0
  87              		.cfi_startproc
  88              		@ args = 0, pretend = 0, frame = 0
  89              		@ frame_needed = 0, uses_anonymous_args = 0
  90              	.LVL7:
  36:../source/gps_func.c **** 
  37:../source/gps_func.c **** 	uint8_t ck_a = 0, ck_b = 0, n = 0;
  91              		.loc 1 37 0
  92 0000 0023     		movs	r3, #0
  35:../source/gps_func.c **** 
  93              		.loc 1 35 0
  94 0002 30B5     		push	{r4, r5, lr}
  95              		.cfi_def_cfa_offset 12
  96              		.cfi_offset 4, -12
  97              		.cfi_offset 5, -8
  98              		.cfi_offset 14, -4
  99              	.LVL8:
 100              	.L7:
  38:../source/gps_func.c **** 
  39:../source/gps_func.c **** 	while (data[n] != 0x0d) //figure out length of input message by finding CR line end char
 101              		.loc 1 39 0
 102 0004 0022     		movs	r2, #0
 103 0006 C418     		adds	r4, r0, r3
 104 0008 A256     		ldrsb	r2, [r4, r2]
 105 000a 0D2A     		cmp	r2, #13
 106 000c 0DD1     		bne	.L8
  37:../source/gps_func.c **** 
 107              		.loc 1 37 0
 108 000e 0022     		movs	r2, #0
 109 0010 1100     		movs	r1, r2
 110              	.LVL9:
 111              	.L9:
  40:../source/gps_func.c **** 	{
  41:../source/gps_func.c **** 		n++;
  42:../source/gps_func.c **** 	}
  43:../source/gps_func.c **** 
  44:../source/gps_func.c **** 	uint8_t dataLength = n;
  45:../source/gps_func.c **** 
  46:../source/gps_func.c **** 	for (n = 0; n < dataLength; n++)//calculate checksum for dataLength bytes
 112              		.loc 1 46 0 discriminator 1
 113 0012 8442     		cmp	r4, r0
 114 0014 0CD1     		bne	.L10
  47:../source/gps_func.c **** 	{
  48:../source/gps_func.c **** 		ck_a = ck_a + data[n];
  49:../source/gps_func.c **** 		ck_b = ck_b + ck_a;
  50:../source/gps_func.c **** 	}
  51:../source/gps_func.c **** 
  52:../source/gps_func.c **** 	data[n] = ck_a; //add checksum to end of data string
  53:../source/gps_func.c **** 	data[n + 1] = ck_b;
 115              		.loc 1 53 0
 116 0016 6270     		strb	r2, [r4, #1]
  54:../source/gps_func.c **** 	data[n + 2] = 0;	//add a zero to terminate string
 117              		.loc 1 54 0
 118 0018 0022     		movs	r2, #0
 119              	.LVL10:
  52:../source/gps_func.c **** 	data[n + 1] = ck_b;
 120              		.loc 1 52 0
 121 001a 2170     		strb	r1, [r4]
 122              		.loc 1 54 0
 123 001c A270     		strb	r2, [r4, #2]
 124              	.LVL11:
  55:../source/gps_func.c **** 
  56:../source/gps_func.c **** 	for (n = 0; n < (dataLength + 2); n++) //debug print our complete message
 125              		.loc 1 56 0
 126 001e 591C     		adds	r1, r3, #1
 127              	.LVL12:
 128              	.L11:
 129              		.loc 1 56 0 is_stmt 0 discriminator 1
 130 0020 9142     		cmp	r1, r2
 131 0022 0CDA     		bge	.L12
  57:../source/gps_func.c **** 	{
  58:../source/gps_func.c **** 		//PCprint("%02x ", (uint8_t) data[n]);
  59:../source/gps_func.c **** 	}
  60:../source/gps_func.c **** 
  61:../source/gps_func.c **** 	return dataLength + 4;
 132              		.loc 1 61 0 is_stmt 1
 133 0024 181D     		adds	r0, r3, #4
 134 0026 C0B2     		uxtb	r0, r0
  62:../source/gps_func.c **** }
 135              		.loc 1 62 0
 136              		@ sp needed
 137              	.LVL13:
 138 0028 30BD     		pop	{r4, r5, pc}
 139              	.LVL14:
 140              	.L8:
  41:../source/gps_func.c **** 	}
 141              		.loc 1 41 0
 142 002a 0133     		adds	r3, r3, #1
 143              	.LVL15:
 144 002c DBB2     		uxtb	r3, r3
 145              	.LVL16:
 146 002e E9E7     		b	.L7
 147              	.LVL17:
 148              	.L10:
  48:../source/gps_func.c **** 		ck_b = ck_b + ck_a;
 149              		.loc 1 48 0 discriminator 3
 150 0030 0578     		ldrb	r5, [r0]
 151 0032 0130     		adds	r0, r0, #1
 152              	.LVL18:
 153 0034 4919     		adds	r1, r1, r5
 154              	.LVL19:
 155 0036 C9B2     		uxtb	r1, r1
 156              	.LVL20:
  49:../source/gps_func.c **** 	}
 157              		.loc 1 49 0 discriminator 3
 158 0038 5218     		adds	r2, r2, r1
 159              	.LVL21:
 160 003a D2B2     		uxtb	r2, r2
 161              	.LVL22:
 162 003c E9E7     		b	.L9
 163              	.LVL23:
 164              	.L12:
  56:../source/gps_func.c **** 	{
 165              		.loc 1 56 0 discriminator 3
 166 003e 0132     		adds	r2, r2, #1
 167              	.LVL24:
 168 0040 D2B2     		uxtb	r2, r2
 169              	.LVL25:
 170 0042 EDE7     		b	.L11
 171              		.cfi_endproc
 172              	.LFE4:
 174              		.global	__aeabi_uidiv
 175              		.section	.text.parseData,"ax",%progbits
 176              		.align	1
 177              		.global	parseData
 178              		.syntax unified
 179              		.code	16
 180              		.thumb_func
 181              		.fpu softvfp
 183              	parseData:
 184              	.LFB6:
  63:../source/gps_func.c **** 
  64:../source/gps_func.c **** uint8_t getGPS()
  65:../source/gps_func.c **** {
  66:../source/gps_func.c **** 
  67:../source/gps_func.c **** 	uint8_t counter = 0;
  68:../source/gps_func.c **** 
  69:../source/gps_func.c **** 	char GLL_ID[10];	// GLL Message ID $GPGLL
  70:../source/gps_func.c **** 	char latitude[15];
  71:../source/gps_func.c **** 	char northSouth[2];	// Indicates North / South, N = north, S = south
  72:../source/gps_func.c **** 	char longitude[15];
  73:../source/gps_func.c **** 	char eastWest[2];	// Indicates East / West, E = east, W = west
  74:../source/gps_func.c **** 	char time[10];		// UTC Time
  75:../source/gps_func.c **** 	char status[2];	// Status indicates data validity V = Data invalid or receiver warning, A = data v
  76:../source/gps_func.c **** 	char posMode[2];	// Positioning mode according to NMEA protocol
  77:../source/gps_func.c **** 	char checkSum[10];
  78:../source/gps_func.c **** 
  79:../source/gps_func.c **** 	char* GPS_dataPtrs[9] =
  80:../source/gps_func.c **** 	{ GLL_ID, latitude, northSouth, longitude, eastWest, time, status, posMode,
  81:../source/gps_func.c **** 			checkSum };
  82:../source/gps_func.c **** 
  83:../source/gps_func.c **** 	char* gllStart = strstr(GPS_recBuf, "NGLL"); //get starting pointer of GLL string
  84:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
  85:../source/gps_func.c **** 
  86:../source/gps_func.c **** 	if (gllStart != NULL) //check if GLL string is found
  87:../source/gps_func.c **** 	{
  88:../source/gps_func.c **** 
  89:../source/gps_func.c **** 		char* gllEnd = strstr(gllStart, "\r\n"); //get end of GLL string
  90:../source/gps_func.c **** 
  91:../source/gps_func.c **** 		if (gllEnd != NULL)
  92:../source/gps_func.c **** 
  93:../source/gps_func.c **** 		{
  94:../source/gps_func.c **** 			*(gllEnd + 2) = 0; //write 0 to end of GLL string so string functions will stop correctly
  95:../source/gps_func.c **** 			//PCprint("GLL string %s\r\n", gllStart);
  96:../source/gps_func.c **** 		}
  97:../source/gps_func.c **** 
  98:../source/gps_func.c **** 		uint8_t gllLength = strlen(gllStart);
  99:../source/gps_func.c **** 		char* gllStringPtr = gllStart;
 100:../source/gps_func.c **** 
 101:../source/gps_func.c **** 		/*
 102:../source/gps_func.c **** 		 * Here own function is used instead of strtok to splice the string
 103:../source/gps_func.c **** 		 *
 104:../source/gps_func.c **** 		 */
 105:../source/gps_func.c **** 		while (*gllStringPtr)
 106:../source/gps_func.c **** 		{
 107:../source/gps_func.c **** 
 108:../source/gps_func.c **** 			if (*gllStringPtr == ',') //if comma is found
 109:../source/gps_func.c **** 			{
 110:../source/gps_func.c **** 				*gllStringPtr = 0; //put 0 to comma's place
 111:../source/gps_func.c **** 				GPS_dataPtrs[counter] = gllStart; //save this string token to variable
 112:../source/gps_func.c **** 				counter++;
 113:../source/gps_func.c **** 				gllStart = gllStringPtr + 1; //move gllStart so it points to the next char after the comma
 114:../source/gps_func.c **** 
 115:../source/gps_func.c **** 			}
 116:../source/gps_func.c **** 
 117:../source/gps_func.c **** 			gllStringPtr++;
 118:../source/gps_func.c **** 
 119:../source/gps_func.c **** 		}
 120:../source/gps_func.c **** 
 121:../source/gps_func.c **** 		if (strstr(GPS_dataPtrs[6], "A") != NULL)
 122:../source/gps_func.c **** 		{
 123:../source/gps_func.c **** 			PCprint("Got GPS\r\n");
 124:../source/gps_func.c **** 			parseData(GPS_dataPtrs[1], GPS_dataPtrs[3]);
 125:../source/gps_func.c **** 			return 1;
 126:../source/gps_func.c **** 		}
 127:../source/gps_func.c **** 
 128:../source/gps_func.c **** 		else if (strstr(GPS_dataPtrs[6], "V") != NULL)
 129:../source/gps_func.c **** 		{
 130:../source/gps_func.c **** 			PCprint("Data invalid, waiting for valid data\r\n");
 131:../source/gps_func.c **** 		}
 132:../source/gps_func.c **** 
 133:../source/gps_func.c **** 		for (uint8_t cnr = 0; cnr < 7; cnr++)
 134:../source/gps_func.c **** 		{
 135:../source/gps_func.c **** 			//PCprint("%s\r\n", GPS_dataPtrs[cnr]);
 136:../source/gps_func.c **** 		}
 137:../source/gps_func.c **** 
 138:../source/gps_func.c **** 	}
 139:../source/gps_func.c **** 
 140:../source/gps_func.c **** 	if (gsvStart != NULL) //if GSV string is found, print it
 141:../source/gps_func.c **** 	{
 142:../source/gps_func.c **** 		char* gsvEnd = strstr(gsvStart, "\r\n");
 143:../source/gps_func.c **** 
 144:../source/gps_func.c **** 		if (gsvEnd != NULL)
 145:../source/gps_func.c **** 		{
 146:../source/gps_func.c **** 
 147:../source/gps_func.c **** 			*(gsvEnd + 2) = 0;
 148:../source/gps_func.c **** 			//PCprint("GSV string %s\r\n", gsvStart);
 149:../source/gps_func.c **** 
 150:../source/gps_func.c **** 		}
 151:../source/gps_func.c **** 	}
 152:../source/gps_func.c **** 
 153:../source/gps_func.c **** 	return 0;
 154:../source/gps_func.c **** 	//}
 155:../source/gps_func.c **** }
 156:../source/gps_func.c **** 
 157:../source/gps_func.c **** void parseData(char* latStr, char* lonStr)
 158:../source/gps_func.c **** {
 185              		.loc 1 158 0
 186              		.cfi_startproc
 187              		@ args = 0, pretend = 0, frame = 0
 188              		@ frame_needed = 0, uses_anonymous_args = 0
 189              	.LVL26:
 190 0000 70B5     		push	{r4, r5, r6, lr}
 191              		.cfi_def_cfa_offset 16
 192              		.cfi_offset 4, -16
 193              		.cfi_offset 5, -12
 194              		.cfi_offset 6, -8
 195              		.cfi_offset 14, -4
 159:../source/gps_func.c **** 
 160:../source/gps_func.c **** 	uint8_t d_ptr = 0;
 161:../source/gps_func.c **** 
 162:../source/gps_func.c **** 	const char s = '.';
 163:../source/gps_func.c **** 
 164:../source/gps_func.c **** 	char* delPtr;
 165:../source/gps_func.c **** 
 166:../source/gps_func.c **** 	/*
 167:../source/gps_func.c **** 	 * swap comma from ddmm.mmm to dd.mmmmm
 168:../source/gps_func.c **** 	 */
 169:../source/gps_func.c **** 
 170:../source/gps_func.c **** 	latStr[4] = latStr[3];
 196              		.loc 1 170 0
 197 0002 C378     		ldrb	r3, [r0, #3]
 158:../source/gps_func.c **** 
 198              		.loc 1 158 0
 199 0004 0D00     		movs	r5, r1
 200              		.loc 1 170 0
 201 0006 0371     		strb	r3, [r0, #4]
 171:../source/gps_func.c **** 	latStr[3] = latStr[2];
 202              		.loc 1 171 0
 203 0008 8378     		ldrb	r3, [r0, #2]
 204 000a C370     		strb	r3, [r0, #3]
 172:../source/gps_func.c **** 	latStr[2] = '.';
 205              		.loc 1 172 0
 206 000c 2E23     		movs	r3, #46
 207 000e 8370     		strb	r3, [r0, #2]
 173:../source/gps_func.c **** 
 174:../source/gps_func.c **** 	lonStr[5] = lonStr[4];
 208              		.loc 1 174 0
 209 0010 0A79     		ldrb	r2, [r1, #4]
 210 0012 4A71     		strb	r2, [r1, #5]
 175:../source/gps_func.c **** 	lonStr[4] = lonStr[3];
 211              		.loc 1 175 0
 212 0014 CA78     		ldrb	r2, [r1, #3]
 176:../source/gps_func.c **** 	lonStr[3] = '.';
 213              		.loc 1 176 0
 214 0016 CB70     		strb	r3, [r1, #3]
 160:../source/gps_func.c **** 
 215              		.loc 1 160 0
 216 0018 0023     		movs	r3, #0
 175:../source/gps_func.c **** 	lonStr[4] = lonStr[3];
 217              		.loc 1 175 0
 218 001a 0A71     		strb	r2, [r1, #4]
 219              	.LVL27:
 220              	.L14:
 177:../source/gps_func.c **** 
 178:../source/gps_func.c **** 	//PCprint("latstr %s lonstr %s\r\n",latStr,lonStr);
 179:../source/gps_func.c **** 
 180:../source/gps_func.c **** 	while (latStr[d_ptr] == '0')
 221              		.loc 1 180 0
 222 001c 0022     		movs	r2, #0
 223 001e C118     		adds	r1, r0, r3
 224 0020 8A56     		ldrsb	r2, [r1, r2]
 225 0022 302A     		cmp	r2, #48
 226 0024 37D0     		beq	.L15
 181:../source/gps_func.c **** 	{		// Skip all zeroes from beginning of string
 182:../source/gps_func.c **** 		d_ptr++;
 183:../source/gps_func.c **** 	}
 184:../source/gps_func.c **** 
 185:../source/gps_func.c **** 	strcpy(parsedLat, latStr + d_ptr);// Copy string without zeroes to new string
 227              		.loc 1 185 0
 228 0026 214C     		ldr	r4, .L22
 229 0028 2000     		movs	r0, r4
 230              	.LVL28:
 231 002a FFF7FEFF 		bl	strcpy
 232              	.LVL29:
 186:../source/gps_func.c **** 
 187:../source/gps_func.c **** 	d_ptr = 0;
 188:../source/gps_func.c **** 
 189:../source/gps_func.c **** 	delPtr = strchr(parsedLat, s);
 233              		.loc 1 189 0
 234 002e 2000     		movs	r0, r4
 235 0030 2E21     		movs	r1, #46
 236 0032 FFF7FEFF 		bl	strchr
 237              	.LVL30:
 190:../source/gps_func.c **** 	delPtr++;
 238              		.loc 1 190 0
 239 0036 441C     		adds	r4, r0, #1
 240              	.LVL31:
 241              	.L16:
 191:../source/gps_func.c **** 	while(*delPtr == '0'){	delPtr++;} //LOOP2: If there is zeroes in minutes part, skip them
 242              		.loc 1 191 0 discriminator 1
 243 0038 0023     		movs	r3, #0
 244 003a E356     		ldrsb	r3, [r4, r3]
 245 003c 302B     		cmp	r3, #48
 246 003e 2DD0     		beq	.L17
 192:../source/gps_func.c **** 
 193:../source/gps_func.c **** 	uint32_t latMinutes = atol(delPtr);
 247              		.loc 1 193 0
 248 0040 2000     		movs	r0, r4
 249 0042 FFF7FEFF 		bl	atol
 250              	.LVL32:
 194:../source/gps_func.c **** 	latMinutes = latMinutes / 6; //Convert minutes to decimal degrees
 251              		.loc 1 194 0
 252 0046 0621     		movs	r1, #6
 253 0048 FFF7FEFF 		bl	__aeabi_uidiv
 254              	.LVL33:
 195:../source/gps_func.c **** 
 196:../source/gps_func.c **** 	sprintf(delPtr, "%ld\r\n", latMinutes); //here because of LOOP2 delPtr points after the original z
 255              		.loc 1 196 0
 256 004c 184E     		ldr	r6, .L22+4
 194:../source/gps_func.c **** 	latMinutes = latMinutes / 6; //Convert minutes to decimal degrees
 257              		.loc 1 194 0
 258 004e 0200     		movs	r2, r0
 259              		.loc 1 196 0
 260 0050 3100     		movs	r1, r6
 261 0052 2000     		movs	r0, r4
 262 0054 FFF7FEFF 		bl	sprintf
 263              	.LVL34:
 187:../source/gps_func.c **** 
 264              		.loc 1 187 0
 265 0058 0023     		movs	r3, #0
 266              	.LVL35:
 267              	.L18:
 197:../source/gps_func.c **** 											//and decimal problem is fixed
 198:../source/gps_func.c **** 
 199:../source/gps_func.c **** 	//PCprint("latmin: %ld\r\n",latMinutes);
 200:../source/gps_func.c **** 
 201:../source/gps_func.c **** 	while (lonStr[d_ptr] == '0')
 268              		.loc 1 201 0
 269 005a 0022     		movs	r2, #0
 270 005c E918     		adds	r1, r5, r3
 271 005e 8A56     		ldrsb	r2, [r1, r2]
 272 0060 302A     		cmp	r2, #48
 273 0062 1DD0     		beq	.L19
 202:../source/gps_func.c **** 	{
 203:../source/gps_func.c **** 		d_ptr++;
 204:../source/gps_func.c **** 	}
 205:../source/gps_func.c **** 
 206:../source/gps_func.c **** 	strcpy(parsedLon, lonStr + d_ptr);
 274              		.loc 1 206 0
 275 0064 134C     		ldr	r4, .L22+8
 276              	.LVL36:
 277 0066 2000     		movs	r0, r4
 278 0068 FFF7FEFF 		bl	strcpy
 279              	.LVL37:
 207:../source/gps_func.c **** 
 208:../source/gps_func.c **** 	delPtr = strchr(parsedLon, s);
 280              		.loc 1 208 0
 281 006c 2000     		movs	r0, r4
 282 006e 2E21     		movs	r1, #46
 283 0070 FFF7FEFF 		bl	strchr
 284              	.LVL38:
 209:../source/gps_func.c **** 	delPtr++;
 285              		.loc 1 209 0
 286 0074 441C     		adds	r4, r0, #1
 287              	.LVL39:
 288              	.L20:
 210:../source/gps_func.c **** 	while(*delPtr == '0'){	delPtr++;} //LOOP3: If there is zeroes in minutes part, skip them
 289              		.loc 1 210 0 discriminator 1
 290 0076 0023     		movs	r3, #0
 291 0078 E356     		ldrsb	r3, [r4, r3]
 292 007a 302B     		cmp	r3, #48
 293 007c 13D0     		beq	.L21
 211:../source/gps_func.c **** 
 212:../source/gps_func.c **** 	uint32_t lonMinutes = atol(delPtr);
 294              		.loc 1 212 0
 295 007e 2000     		movs	r0, r4
 296 0080 FFF7FEFF 		bl	atol
 297              	.LVL40:
 213:../source/gps_func.c **** 	lonMinutes = lonMinutes / 6;
 298              		.loc 1 213 0
 299 0084 0621     		movs	r1, #6
 300 0086 FFF7FEFF 		bl	__aeabi_uidiv
 301              	.LVL41:
 214:../source/gps_func.c **** 
 215:../source/gps_func.c **** 	sprintf(delPtr, "%ld\r\n", lonMinutes);//here because of LOOP3 delPtr points after the original ze
 302              		.loc 1 215 0
 303 008a 3100     		movs	r1, r6
 213:../source/gps_func.c **** 	lonMinutes = lonMinutes / 6;
 304              		.loc 1 213 0
 305 008c 0200     		movs	r2, r0
 306              		.loc 1 215 0
 307 008e 2000     		movs	r0, r4
 308 0090 FFF7FEFF 		bl	sprintf
 309              	.LVL42:
 216:../source/gps_func.c **** 											//and decimal problem is fixed
 217:../source/gps_func.c **** 
 218:../source/gps_func.c **** 	//PCprint("Parsed latitude: %s", parsedLon);
 219:../source/gps_func.c **** 	//PCprint("Parsed longitude: %s", parsedLat);
 220:../source/gps_func.c **** }
 310              		.loc 1 220 0
 311              		@ sp needed
 312              	.LVL43:
 313              	.LVL44:
 314 0094 70BD     		pop	{r4, r5, r6, pc}
 315              	.LVL45:
 316              	.L15:
 182:../source/gps_func.c **** 	}
 317              		.loc 1 182 0
 318 0096 0133     		adds	r3, r3, #1
 319              	.LVL46:
 320 0098 DBB2     		uxtb	r3, r3
 321              	.LVL47:
 322 009a BFE7     		b	.L14
 323              	.LVL48:
 324              	.L17:
 191:../source/gps_func.c **** 
 325              		.loc 1 191 0 discriminator 2
 326 009c 0134     		adds	r4, r4, #1
 327              	.LVL49:
 328 009e CBE7     		b	.L16
 329              	.LVL50:
 330              	.L19:
 203:../source/gps_func.c **** 	}
 331              		.loc 1 203 0
 332 00a0 0133     		adds	r3, r3, #1
 333              	.LVL51:
 334 00a2 DBB2     		uxtb	r3, r3
 335              	.LVL52:
 336 00a4 D9E7     		b	.L18
 337              	.LVL53:
 338              	.L21:
 210:../source/gps_func.c **** 
 339              		.loc 1 210 0 discriminator 2
 340 00a6 0134     		adds	r4, r4, #1
 341              	.LVL54:
 342 00a8 E5E7     		b	.L20
 343              	.L23:
 344 00aa C046     		.align	2
 345              	.L22:
 346 00ac 00000000 		.word	parsedLat
 347 00b0 00000000 		.word	.LC5
 348 00b4 00000000 		.word	parsedLon
 349              		.cfi_endproc
 350              	.LFE6:
 352              		.section	.text.getGPS,"ax",%progbits
 353              		.align	1
 354              		.global	getGPS
 355              		.syntax unified
 356              		.code	16
 357              		.thumb_func
 358              		.fpu softvfp
 360              	getGPS:
 361              	.LFB5:
  65:../source/gps_func.c **** 
 362              		.loc 1 65 0
 363              		.cfi_startproc
 364              		@ args = 0, pretend = 0, frame = 72
 365              		@ frame_needed = 0, uses_anonymous_args = 0
 366              	.LVL55:
 367 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 368              		.cfi_def_cfa_offset 20
 369              		.cfi_offset 4, -20
 370              		.cfi_offset 5, -16
 371              		.cfi_offset 6, -12
 372              		.cfi_offset 7, -8
 373              		.cfi_offset 14, -4
 374 0002 93B0     		sub	sp, sp, #76
 375              		.cfi_def_cfa_offset 96
  79:../source/gps_func.c **** 	{ GLL_ID, latitude, northSouth, longitude, eastWest, time, status, posMode,
 376              		.loc 1 79 0
 377 0004 09AC     		add	r4, sp, #36
 378 0006 01AB     		add	r3, sp, #4
 379 0008 6360     		str	r3, [r4, #4]
 380 000a 05AB     		add	r3, sp, #20
 381 000c E360     		str	r3, [r4, #12]
 382 000e 6B46     		mov	r3, sp
  83:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
 383              		.loc 1 83 0
 384 0010 274E     		ldr	r6, .L42
 385 0012 2849     		ldr	r1, .L42+4
 386 0014 3000     		movs	r0, r6
  79:../source/gps_func.c **** 	{ GLL_ID, latitude, northSouth, longitude, eastWest, time, status, posMode,
 387              		.loc 1 79 0
 388 0016 A361     		str	r3, [r4, #24]
  83:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
 389              		.loc 1 83 0
 390 0018 FFF7FEFF 		bl	strstr
 391              	.LVL56:
  84:../source/gps_func.c **** 
 392              		.loc 1 84 0
 393 001c 2649     		ldr	r1, .L42+8
  83:../source/gps_func.c **** 	char* gsvStart = strstr(GPS_recBuf, "PGSV"); //get start of GSV string(sats in view)
 394              		.loc 1 83 0
 395 001e 0500     		movs	r5, r0
 396              	.LVL57:
  84:../source/gps_func.c **** 
 397              		.loc 1 84 0
 398 0020 3000     		movs	r0, r6
 399              	.LVL58:
 400 0022 FFF7FEFF 		bl	strstr
 401              	.LVL59:
 402 0026 0600     		movs	r6, r0
 403              	.LVL60:
  86:../source/gps_func.c **** 	{
 404              		.loc 1 86 0
 405 0028 002D     		cmp	r5, #0
 406 002a 34D0     		beq	.L26
 407              	.LBB4:
  89:../source/gps_func.c **** 
 408              		.loc 1 89 0
 409 002c 2349     		ldr	r1, .L42+12
 410 002e 2800     		movs	r0, r5
 411              	.LVL61:
 412 0030 FFF7FEFF 		bl	strstr
 413              	.LVL62:
  91:../source/gps_func.c **** 
 414              		.loc 1 91 0
 415 0034 0028     		cmp	r0, #0
 416 0036 01D0     		beq	.L27
  94:../source/gps_func.c **** 			//PCprint("GLL string %s\r\n", gllStart);
 417              		.loc 1 94 0
 418 0038 0023     		movs	r3, #0
 419 003a 8370     		strb	r3, [r0, #2]
 420              	.L27:
 113:../source/gps_func.c **** 
 421              		.loc 1 113 0
 422 003c 0023     		movs	r3, #0
 423 003e 2900     		movs	r1, r5
 110:../source/gps_func.c **** 				GPS_dataPtrs[counter] = gllStart; //save this string token to variable
 424              		.loc 1 110 0
 425 0040 1F00     		movs	r7, r3
 426              	.LVL63:
 427              	.L28:
 105:../source/gps_func.c **** 		{
 428              		.loc 1 105 0
 429 0042 0022     		movs	r2, #0
 430 0044 AA56     		ldrsb	r2, [r5, r2]
 431 0046 002A     		cmp	r2, #0
 432 0048 11D1     		bne	.L30
 121:../source/gps_func.c **** 		{
 433              		.loc 1 121 0
 434 004a A569     		ldr	r5, [r4, #24]
 435              	.LVL64:
 436 004c 4121     		movs	r1, #65
 437              	.LVL65:
 438 004e 2800     		movs	r0, r5
 439 0050 FFF7FEFF 		bl	strchr
 440              	.LVL66:
 441 0054 0028     		cmp	r0, #0
 442 0056 15D0     		beq	.L31
 123:../source/gps_func.c **** 			parseData(GPS_dataPtrs[1], GPS_dataPtrs[3]);
 443              		.loc 1 123 0
 444 0058 1948     		ldr	r0, .L42+16
 445 005a FFF7FEFF 		bl	PCprint
 446              	.LVL67:
 124:../source/gps_func.c **** 			return 1;
 447              		.loc 1 124 0
 448 005e E168     		ldr	r1, [r4, #12]
 449 0060 6068     		ldr	r0, [r4, #4]
 450 0062 FFF7FEFF 		bl	parseData
 451              	.LVL68:
 125:../source/gps_func.c **** 		}
 452              		.loc 1 125 0
 453 0066 0123     		movs	r3, #1
 454              	.L32:
 455              	.LBE4:
 155:../source/gps_func.c **** 
 456              		.loc 1 155 0
 457 0068 1800     		movs	r0, r3
 458 006a 13B0     		add	sp, sp, #76
 459              		@ sp needed
 460              	.LVL69:
 461 006c F0BD     		pop	{r4, r5, r6, r7, pc}
 462              	.LVL70:
 463              	.L30:
 464 006e 681C     		adds	r0, r5, #1
 465              	.LBB5:
 108:../source/gps_func.c **** 			{
 466              		.loc 1 108 0
 467 0070 2C2A     		cmp	r2, #44
 468 0072 05D1     		bne	.L29
 111:../source/gps_func.c **** 				counter++;
 469              		.loc 1 111 0
 470 0074 9A00     		lsls	r2, r3, #2
 471 0076 A150     		str	r1, [r4, r2]
 113:../source/gps_func.c **** 
 472              		.loc 1 113 0
 473 0078 0100     		movs	r1, r0
 474              	.LVL71:
 112:../source/gps_func.c **** 				gllStart = gllStringPtr + 1; //move gllStart so it points to the next char after the comma
 475              		.loc 1 112 0
 476 007a 0133     		adds	r3, r3, #1
 477              	.LVL72:
 110:../source/gps_func.c **** 				GPS_dataPtrs[counter] = gllStart; //save this string token to variable
 478              		.loc 1 110 0
 479 007c 2F70     		strb	r7, [r5]
 112:../source/gps_func.c **** 				gllStart = gllStringPtr + 1; //move gllStart so it points to the next char after the comma
 480              		.loc 1 112 0
 481 007e DBB2     		uxtb	r3, r3
 482              	.LVL73:
 483              	.L29:
 117:../source/gps_func.c **** 
 484              		.loc 1 117 0
 485 0080 0500     		movs	r5, r0
 486 0082 DEE7     		b	.L28
 487              	.LVL74:
 488              	.L31:
 128:../source/gps_func.c **** 		{
 489              		.loc 1 128 0
 490 0084 5621     		movs	r1, #86
 491 0086 2800     		movs	r0, r5
 492 0088 FFF7FEFF 		bl	strchr
 493              	.LVL75:
 494 008c 0028     		cmp	r0, #0
 495 008e 02D0     		beq	.L26
 130:../source/gps_func.c **** 		}
 496              		.loc 1 130 0
 497 0090 0C48     		ldr	r0, .L42+20
 498 0092 FFF7FEFF 		bl	PCprint
 499              	.LVL76:
 500              	.L26:
 501              	.LBE5:
 153:../source/gps_func.c **** 	//}
 502              		.loc 1 153 0
 503 0096 331E     		subs	r3, r6, #0
 140:../source/gps_func.c **** 	{
 504              		.loc 1 140 0
 505 0098 E6D0     		beq	.L32
 506              	.LVL77:
 507              	.LBB6:
 142:../source/gps_func.c **** 
 508              		.loc 1 142 0
 509 009a 0849     		ldr	r1, .L42+12
 510 009c 3000     		movs	r0, r6
 511 009e FFF7FEFF 		bl	strstr
 512              	.LVL78:
 513 00a2 0022     		movs	r2, #0
 514              	.LBE6:
 153:../source/gps_func.c **** 	//}
 515              		.loc 1 153 0
 516 00a4 0300     		movs	r3, r0
 517              	.LBB7:
 144:../source/gps_func.c **** 		{
 518              		.loc 1 144 0
 519 00a6 9042     		cmp	r0, r2
 520 00a8 DED0     		beq	.L32
 147:../source/gps_func.c **** 			//PCprint("GSV string %s\r\n", gsvStart);
 521              		.loc 1 147 0
 522 00aa 8270     		strb	r2, [r0, #2]
 523              	.LBE7:
 153:../source/gps_func.c **** 	//}
 524              		.loc 1 153 0
 525 00ac 1300     		movs	r3, r2
 526 00ae DBE7     		b	.L32
 527              	.L43:
 528              		.align	2
 529              	.L42:
 530 00b0 00000000 		.word	GPS_recBuf
 531 00b4 00000000 		.word	.LC8
 532 00b8 05000000 		.word	.LC11
 533 00bc 0A000000 		.word	.LC13
 534 00c0 0D000000 		.word	.LC15
 535 00c4 17000000 		.word	.LC17
 536              		.cfi_endproc
 537              	.LFE5:
 539              		.section	.rodata.getGPS.str1.1,"aMS",%progbits,1
 540              	.LC8:
 541 0000 4E474C4C 		.ascii	"NGLL\000"
 541      00
 542              	.LC11:
 543 0005 50475356 		.ascii	"PGSV\000"
 543      00
 544              	.LC13:
 545 000a 0D0A00   		.ascii	"\015\012\000"
 546              	.LC15:
 547 000d 476F7420 		.ascii	"Got GPS\015\012\000"
 547      4750530D 
 547      0A00
 548              	.LC17:
 549 0017 44617461 		.ascii	"Data invalid, waiting for valid data\015\012\000"
 549      20696E76 
 549      616C6964 
 549      2C207761 
 549      6974696E 
 550              		.section	.rodata.parseData.str1.1,"aMS",%progbits,1
 551              	.LC5:
 552 0000 256C640D 		.ascii	"%ld\015\012\000"
 552      0A00
 553              		.section	.rodata.printUbxResponseHex.str1.1,"aMS",%progbits,1
 554              	.LC2:
 555 0000 25303278 		.ascii	"%02x\000"
 555      00
 556              		.text
 557              	.Letext0:
 558              		.file 2 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 559              		.file 3 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 560              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 561              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 562              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 563              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 564              		.file 8 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 565              		.file 9 "../source/gps_func.h"
 566              		.file 10 "../source/at_func.h"
 567              		.file 11 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/string.h"
 568              		.file 12 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdio.h"
 569              		.file 13 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 gps_func.c
     /tmp/cc6dDLrX.s:16     .text.printUbxResponseHex:0000000000000000 $t
     /tmp/cc6dDLrX.s:23     .text.printUbxResponseHex:0000000000000000 printUbxResponseHex
     /tmp/cc6dDLrX.s:71     .text.printUbxResponseHex:0000000000000020 $d
     /tmp/cc6dDLrX.s:77     .text.calcUbxCrc:0000000000000000 $t
     /tmp/cc6dDLrX.s:84     .text.calcUbxCrc:0000000000000000 calcUbxCrc
     /tmp/cc6dDLrX.s:176    .text.parseData:0000000000000000 $t
     /tmp/cc6dDLrX.s:183    .text.parseData:0000000000000000 parseData
     /tmp/cc6dDLrX.s:346    .text.parseData:00000000000000ac $d
     /tmp/cc6dDLrX.s:353    .text.getGPS:0000000000000000 $t
     /tmp/cc6dDLrX.s:360    .text.getGPS:0000000000000000 getGPS
     /tmp/cc6dDLrX.s:530    .text.getGPS:00000000000000b0 $d

UNDEFINED SYMBOLS
sprintf
PCprint
__aeabi_uidiv
strcpy
strchr
atol
parsedLat
parsedLon
strstr
GPS_recBuf
