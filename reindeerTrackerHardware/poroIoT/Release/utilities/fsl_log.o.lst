   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_log.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.LOG_ReadOneCharacter,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	LOG_ReadOneCharacter:
  23              	.LFB60:
  24              		.file 1 "../utilities/fsl_log.c"
   1:../utilities/fsl_log.c **** /*
   2:../utilities/fsl_log.c ****  * The Clear BSD License
   3:../utilities/fsl_log.c ****  * Copyright 2017 NXP
   4:../utilities/fsl_log.c ****  * All rights reserved.
   5:../utilities/fsl_log.c ****  *
   6:../utilities/fsl_log.c ****  *
   7:../utilities/fsl_log.c ****  * Redistribution and use in source and binary forms, with or without modification,
   8:../utilities/fsl_log.c ****  * are permitted (subject to the limitations in the disclaimer below) provided
   9:../utilities/fsl_log.c ****  * that the following conditions are met:
  10:../utilities/fsl_log.c ****  *
  11:../utilities/fsl_log.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  12:../utilities/fsl_log.c ****  *   of conditions and the following disclaimer.
  13:../utilities/fsl_log.c ****  *
  14:../utilities/fsl_log.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  15:../utilities/fsl_log.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  16:../utilities/fsl_log.c ****  *   other materials provided with the distribution.
  17:../utilities/fsl_log.c ****  *
  18:../utilities/fsl_log.c ****  * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  19:../utilities/fsl_log.c ****  *   contributors may be used to endorse or promote products derived from this
  20:../utilities/fsl_log.c ****  *   software without specific prior written permission.
  21:../utilities/fsl_log.c ****  *
  22:../utilities/fsl_log.c ****  * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
  23:../utilities/fsl_log.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:../utilities/fsl_log.c ****  * ANY EPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:../utilities/fsl_log.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:../utilities/fsl_log.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  27:../utilities/fsl_log.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:../utilities/fsl_log.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:../utilities/fsl_log.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  30:../utilities/fsl_log.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:../utilities/fsl_log.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:../utilities/fsl_log.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:../utilities/fsl_log.c ****  *
  34:../utilities/fsl_log.c ****  */
  35:../utilities/fsl_log.c **** #include "fsl_log.h"
  36:../utilities/fsl_log.c **** #include "fsl_debug_console_conf.h"
  37:../utilities/fsl_log.c **** #include "fsl_io.h"
  38:../utilities/fsl_log.c **** #ifdef FSL_RTOS_FREE_RTOS
  39:../utilities/fsl_log.c **** #include "FreeRTOS.h"
  40:../utilities/fsl_log.c **** #include "task.h"
  41:../utilities/fsl_log.c **** #include "semphr.h"
  42:../utilities/fsl_log.c **** #endif
  43:../utilities/fsl_log.c **** /*******************************************************************************
  44:../utilities/fsl_log.c ****  * Definitions
  45:../utilities/fsl_log.c ****  ******************************************************************************/
  46:../utilities/fsl_log.c **** #ifndef BACKSPACE
  47:../utilities/fsl_log.c **** /*! @brief character backspace ASCII value */
  48:../utilities/fsl_log.c **** #define BACKSPACE 127
  49:../utilities/fsl_log.c **** #endif
  50:../utilities/fsl_log.c **** 
  51:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
  52:../utilities/fsl_log.c **** /*! @brief increase pop member */
  53:../utilities/fsl_log.c **** #define LOG_CHECK_BUFFER_INDEX_OVERFLOW(index)          \
  54:../utilities/fsl_log.c ****     {                                                   \
  55:../utilities/fsl_log.c ****         if (index >= DEBUG_CONSOLE_TRANSMIT_BUFFER_LEN) \
  56:../utilities/fsl_log.c ****         {                                               \
  57:../utilities/fsl_log.c ****             index -= DEBUG_CONSOLE_TRANSMIT_BUFFER_LEN; \
  58:../utilities/fsl_log.c ****         }                                               \
  59:../utilities/fsl_log.c ****     \
  60:../utilities/fsl_log.c **** \
  61:../utilities/fsl_log.c **** }
  62:../utilities/fsl_log.c **** 
  63:../utilities/fsl_log.c **** /*! @brief get current runing environment is ISR or not */
  64:../utilities/fsl_log.c **** #ifdef __CA7_REV
  65:../utilities/fsl_log.c **** #define IS_RUNNING_IN_ISR() SystemGetIRQNestingLevel()
  66:../utilities/fsl_log.c **** #else
  67:../utilities/fsl_log.c **** #define IS_RUNNING_IN_ISR() __get_IPSR()
  68:../utilities/fsl_log.c **** #endif /* __CA7_REV */
  69:../utilities/fsl_log.c **** 
  70:../utilities/fsl_log.c **** #else
  71:../utilities/fsl_log.c **** #define IS_RUNNING_IN_ISR() (0U)
  72:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
  73:../utilities/fsl_log.c **** 
  74:../utilities/fsl_log.c **** /* define for rtos */
  75:../utilities/fsl_log.c **** #if (DEBUG_CONSOLE_SYNCHRONIZATION_MODE == DEBUG_CONSOLE_SYNCHRONIZATION_FREERTOS)
  76:../utilities/fsl_log.c **** /* metex semaphore */
  77:../utilities/fsl_log.c **** #define LOG_CREATE_MUTEX_SEMAPHORE(mutex) (mutex = xSemaphoreCreateMutex())
  78:../utilities/fsl_log.c **** 
  79:../utilities/fsl_log.c **** #define LOG_GIVE_MUTEX_SEMAPHORE(mutex) \
  80:../utilities/fsl_log.c ****     \
  81:../utilities/fsl_log.c **** {                                \
  82:../utilities/fsl_log.c ****         if (IS_RUNNING_IN_ISR() == 0U)  \
  83:../utilities/fsl_log.c ****         {                               \
  84:../utilities/fsl_log.c ****             xSemaphoreGive(mutex);      \
  85:../utilities/fsl_log.c ****         }                               \
  86:../utilities/fsl_log.c ****     \
  87:../utilities/fsl_log.c **** }
  88:../utilities/fsl_log.c **** 
  89:../utilities/fsl_log.c **** #define LOG_TAKE_MUTEX_SEMAPHORE_BLOCKING(mutex)  \
  90:../utilities/fsl_log.c ****     \
  91:../utilities/fsl_log.c **** {                                          \
  92:../utilities/fsl_log.c ****         if (IS_RUNNING_IN_ISR() == 0U)            \
  93:../utilities/fsl_log.c ****         {                                         \
  94:../utilities/fsl_log.c ****             xSemaphoreTake(mutex, portMAX_DELAY); \
  95:../utilities/fsl_log.c ****         }                                         \
  96:../utilities/fsl_log.c ****     \
  97:../utilities/fsl_log.c **** }
  98:../utilities/fsl_log.c **** 
  99:../utilities/fsl_log.c **** #define LOG_TAKE_MUTEX_SEMAPHORE_NONBLOCKING(mutex, result) \
 100:../utilities/fsl_log.c ****     \
 101:../utilities/fsl_log.c **** {                                                    \
 102:../utilities/fsl_log.c ****         if (IS_RUNNING_IN_ISR() == 0U)                      \
 103:../utilities/fsl_log.c ****         {                                                   \
 104:../utilities/fsl_log.c ****             result = xSemaphoreTake(mutex, 0U);             \
 105:../utilities/fsl_log.c ****         }                                                   \
 106:../utilities/fsl_log.c ****         else                                                \
 107:../utilities/fsl_log.c ****         {                                                   \
 108:../utilities/fsl_log.c ****             result = 1U;                                    \
 109:../utilities/fsl_log.c ****         }                                                   \
 110:../utilities/fsl_log.c ****     \
 111:../utilities/fsl_log.c **** }
 112:../utilities/fsl_log.c **** 
 113:../utilities/fsl_log.c **** /* Binary semaphore */
 114:../utilities/fsl_log.c **** #define LOG_CREATE_BINARY_SEMAPHORE(binary) (binary = xSemaphoreCreateBinary())
 115:../utilities/fsl_log.c **** #define LOG_TAKE_BINARY_SEMAPHORE_BLOCKING(binary) (xSemaphoreTake(binary, portMAX_DELAY))
 116:../utilities/fsl_log.c **** #define LOG_GIVE_BINARY_SEMAPHORE_FROM_ISR(binary) (xSemaphoreGiveFromISR(binary, NULL))
 117:../utilities/fsl_log.c **** 
 118:../utilities/fsl_log.c **** #elif(DEBUG_CONSOLE_SYNCHRONIZATION_MODE == DEBUG_CONSOLE_SYNCHRONIZATION_BM)
 119:../utilities/fsl_log.c **** 
 120:../utilities/fsl_log.c **** #define LOG_CREATE_MUTEX_SEMAPHORE(mutex)
 121:../utilities/fsl_log.c **** #define LOG_TAKE_MUTEX_SEMAPHORE_BLOCKING(mutex)
 122:../utilities/fsl_log.c **** #define LOG_GIVE_MUTEX_SEMAPHORE(mutex)
 123:../utilities/fsl_log.c **** #define LOG_CREATE_BINARY_SEMAPHORE(binary)
 124:../utilities/fsl_log.c **** #define LOG_TAKE_MUTEX_SEMAPHORE_NONBLOCKING(mutex, result) (result = 1U)
 125:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 126:../utilities/fsl_log.c **** #define LOG_TAKE_BINARY_SEMAPHORE_BLOCKING(binary) \
 127:../utilities/fsl_log.c ****     \
 128:../utilities/fsl_log.c **** {                                           \
 129:../utilities/fsl_log.c ****         while (!binary)                            \
 130:../utilities/fsl_log.c ****             ;                                      \
 131:../utilities/fsl_log.c ****         binary = false;                            \
 132:../utilities/fsl_log.c ****     \
 133:../utilities/fsl_log.c **** \
 134:../utilities/fsl_log.c **** }
 135:../utilities/fsl_log.c **** #define LOG_GIVE_BINARY_SEMAPHORE_FROM_ISR(binary) (binary = true)
 136:../utilities/fsl_log.c **** #else
 137:../utilities/fsl_log.c **** #define LOG_TAKE_BINARY_SEMAPHORE_BLOCKING(binary)
 138:../utilities/fsl_log.c **** #define LOG_GIVE_BINARY_SEMAPHORE_FROM_ISR(binary)
 139:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 140:../utilities/fsl_log.c **** 
 141:../utilities/fsl_log.c **** /* add other implementation here
 142:../utilities/fsl_log.c **** *such as :
 143:../utilities/fsl_log.c **** * #elif(DEBUG_CONSOLE_SYNCHRONIZATION_MODE == DEBUG_CONSOLE_SYNCHRONIZATION_xxx)
 144:../utilities/fsl_log.c **** */
 145:../utilities/fsl_log.c **** 
 146:../utilities/fsl_log.c **** #else
 147:../utilities/fsl_log.c **** 
 148:../utilities/fsl_log.c **** #define LOG_CREATE_MUTEX_SEMAPHORE(mutex)
 149:../utilities/fsl_log.c **** #define LOG_TAKE_MUTEX_SEMAPHORE_BLOCKING(mutex)
 150:../utilities/fsl_log.c **** #define LOG_TAKE_MUTEX_SEMAPHORE_NONBLOCKING(mutex, result) (result = 1U)
 151:../utilities/fsl_log.c **** #define LOG_GIVE_MUTEX_SEMAPHORE(mutex)
 152:../utilities/fsl_log.c **** #define LOG_CREATE_BINARY_SEMAPHORE(binary)
 153:../utilities/fsl_log.c **** #define LOG_TAKE_BINARY_SEMAPHORE_BLOCKING(binary)
 154:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_SYNCHRONIZATION_MODE == DEBUG_CONSOLE_SYNCHRONIZATION_FREERTOS */
 155:../utilities/fsl_log.c **** 
 156:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 157:../utilities/fsl_log.c **** /*! @brief Define the buffer
 158:../utilities/fsl_log.c **** * The total buffer size should be calucate as (BUFFER_SUPPORT_LOG_LENGTH + 1) * BUFFER_SUPPORT_LOG_
 159:../utilities/fsl_log.c **** */
 160:../utilities/fsl_log.c **** typedef struct _log_buffer
 161:../utilities/fsl_log.c **** {
 162:../utilities/fsl_log.c ****     volatile uint16_t totalIndex;                     /*!< indicate the total usage of the buffer *
 163:../utilities/fsl_log.c ****     volatile uint16_t pushIndex;                      /*!< indicate the next push index */
 164:../utilities/fsl_log.c ****     volatile uint16_t popIndex;                       /*!< indicate the pop index */
 165:../utilities/fsl_log.c ****     uint8_t txBuf[DEBUG_CONSOLE_TRANSMIT_BUFFER_LEN]; /*!< buffer to store printf log */
 166:../utilities/fsl_log.c **** 
 167:../utilities/fsl_log.c ****     uint8_t rxBuf[DEBUG_CONSOLE_RECEIVE_BUFFER_LEN]; /*!< buffer to store scanf log */
 168:../utilities/fsl_log.c **** } log_buffer_t;
 169:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 170:../utilities/fsl_log.c **** 
 171:../utilities/fsl_log.c **** /*******************************************************************************
 172:../utilities/fsl_log.c ****  * Variables
 173:../utilities/fsl_log.c ****  ******************************************************************************/
 174:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 175:../utilities/fsl_log.c **** /* A global log buffer */
 176:../utilities/fsl_log.c **** static log_buffer_t s_log_buffer;
 177:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 178:../utilities/fsl_log.c **** 
 179:../utilities/fsl_log.c **** /* lock definition */
 180:../utilities/fsl_log.c **** #if (DEBUG_CONSOLE_SYNCHRONIZATION_MODE == DEBUG_CONSOLE_SYNCHRONIZATION_FREERTOS)
 181:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 182:../utilities/fsl_log.c **** static SemaphoreHandle_t s_logPushSemaphore = NULL;
 183:../utilities/fsl_log.c **** static SemaphoreHandle_t s_logReadSemaphore = NULL;
 184:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 185:../utilities/fsl_log.c **** static SemaphoreHandle_t s_logPopSemaphore = NULL;
 186:../utilities/fsl_log.c **** static SemaphoreHandle_t s_logReadWaitSemaphore = NULL;
 187:../utilities/fsl_log.c **** 
 188:../utilities/fsl_log.c **** #elif(DEBUG_CONSOLE_SYNCHRONIZATION_MODE == DEBUG_CONSOLE_SYNCHRONIZATION_BM)
 189:../utilities/fsl_log.c **** 
 190:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 191:../utilities/fsl_log.c **** 
 192:../utilities/fsl_log.c **** static volatile bool s_logReadWaitSemaphore = false; /* transferred event from ISR for bare-metal +
 193:../utilities/fsl_log.c **** 
 194:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 195:../utilities/fsl_log.c **** 
 196:../utilities/fsl_log.c **** #else
 197:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 198:../utilities/fsl_log.c **** 
 199:../utilities/fsl_log.c **** /*******************************************************************************
 200:../utilities/fsl_log.c **** * Prototypes
 201:../utilities/fsl_log.c **** ******************************************************************************/
 202:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 203:../utilities/fsl_log.c **** /*!
 204:../utilities/fsl_log.c ****  * @brief callback function for IO layer to notify LOG
 205:../utilities/fsl_log.c ****  *
 206:../utilities/fsl_log.c ****  * @param size last transfer data size
 207:../utilities/fsl_log.c ****  * @param receive indicate a RX transfer
 208:../utilities/fsl_log.c ****  * @param transmit indicate a TX transfer
 209:../utilities/fsl_log.c ****  *
 210:../utilities/fsl_log.c ****  */
 211:../utilities/fsl_log.c **** static void LOG_Transferred(size_t *size, bool receive, bool transmit);
 212:../utilities/fsl_log.c **** 
 213:../utilities/fsl_log.c **** /*!
 214:../utilities/fsl_log.c ****  * @brief log push function
 215:../utilities/fsl_log.c ****  *
 216:../utilities/fsl_log.c ****  * @param buf target buffer
 217:../utilities/fsl_log.c ****  * @param size log size
 218:../utilities/fsl_log.c ****  *
 219:../utilities/fsl_log.c ****  */
 220:../utilities/fsl_log.c **** static int LOG_BufPush(uint8_t *buf, size_t size);
 221:../utilities/fsl_log.c **** 
 222:../utilities/fsl_log.c **** /*!
 223:../utilities/fsl_log.c ****  * @brief Get next avaliable log
 224:../utilities/fsl_log.c ****  *
 225:../utilities/fsl_log.c ****  * @param next avaliable size
 226:../utilities/fsl_log.c ****  * @return next avaliable address
 227:../utilities/fsl_log.c ****  */
 228:../utilities/fsl_log.c **** static uint8_t *LOG_BufGetNextAvaliableLog(size_t *size);
 229:../utilities/fsl_log.c **** 
 230:../utilities/fsl_log.c **** /*!
 231:../utilities/fsl_log.c ****  * @brief buf pop
 232:../utilities/fsl_log.c ****  *
 233:../utilities/fsl_log.c ****  * @param size log size popped and next available log size
 234:../utilities/fsl_log.c ****  * @return next avaliable address
 235:../utilities/fsl_log.c ****  */
 236:../utilities/fsl_log.c **** static uint8_t *LOG_BufPop(size_t *size);
 237:../utilities/fsl_log.c **** 
 238:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 239:../utilities/fsl_log.c **** 
 240:../utilities/fsl_log.c **** /*!
 241:../utilities/fsl_log.c ****  * @brief read one character
 242:../utilities/fsl_log.c ****  *
 243:../utilities/fsl_log.c ****  * @param ch character address
 244:../utilities/fsl_log.c ****  * @return indicate the read status
 245:../utilities/fsl_log.c ****  *
 246:../utilities/fsl_log.c ****  */
 247:../utilities/fsl_log.c **** static status_t LOG_ReadOneCharacter(uint8_t *ch);
 248:../utilities/fsl_log.c **** 
 249:../utilities/fsl_log.c **** #if DEBUG_CONSOLE_ENABLE_ECHO_FUNCTION
 250:../utilities/fsl_log.c **** /*!
 251:../utilities/fsl_log.c ****  * @brief echo one character
 252:../utilities/fsl_log.c ****  *
 253:../utilities/fsl_log.c ****  * @param ch character address
 254:../utilities/fsl_log.c ****  * @param isGetchar flag to distinguish getchar from scanf
 255:../utilities/fsl_log.c ****  * @param index special for scanf to support backspace
 256:../utilities/fsl_log.c ****  * @return indicate the read status
 257:../utilities/fsl_log.c ****  *
 258:../utilities/fsl_log.c ****  */
 259:../utilities/fsl_log.c **** static status_t LOG_EchoCharacter(uint8_t *ch, bool isGetChar, int *index);
 260:../utilities/fsl_log.c **** #endif
 261:../utilities/fsl_log.c **** 
 262:../utilities/fsl_log.c **** /*******************************************************************************
 263:../utilities/fsl_log.c ****  * Code
 264:../utilities/fsl_log.c ****  ******************************************************************************/
 265:../utilities/fsl_log.c **** status_t LOG_Init(uint32_t baseAddr, uint8_t device, uint32_t baudRate, uint32_t clkSrcFreq)
 266:../utilities/fsl_log.c **** {
 267:../utilities/fsl_log.c ****     io_state_t io;
 268:../utilities/fsl_log.c ****     /* init io */
 269:../utilities/fsl_log.c ****     io.ioBase = (void *)baseAddr;
 270:../utilities/fsl_log.c ****     io.ioType = device;
 271:../utilities/fsl_log.c **** 
 272:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 273:../utilities/fsl_log.c ****     /* memset the global queue */
 274:../utilities/fsl_log.c ****     memset(&s_log_buffer, 0U, sizeof(s_log_buffer));
 275:../utilities/fsl_log.c ****     /* init callback for NON-BLOCKING */
 276:../utilities/fsl_log.c ****     io.callBack = LOG_Transferred;
 277:../utilities/fsl_log.c ****     /* io init function */
 278:../utilities/fsl_log.c ****     IO_Init(&io, baudRate, clkSrcFreq, s_log_buffer.rxBuf);
 279:../utilities/fsl_log.c ****     /* Debug console buffer push lock create */
 280:../utilities/fsl_log.c ****     LOG_CREATE_MUTEX_SEMAPHORE(s_logPushSemaphore);
 281:../utilities/fsl_log.c ****     /* Debug console get/scanf mutex lock create */
 282:../utilities/fsl_log.c ****     LOG_CREATE_MUTEX_SEMAPHORE(s_logReadSemaphore);
 283:../utilities/fsl_log.c **** #else
 284:../utilities/fsl_log.c ****     IO_Init(&io, baudRate, clkSrcFreq, NULL);
 285:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 286:../utilities/fsl_log.c **** 
 287:../utilities/fsl_log.c ****     /* Debug console lock create */
 288:../utilities/fsl_log.c ****     LOG_CREATE_MUTEX_SEMAPHORE(s_logPopSemaphore);
 289:../utilities/fsl_log.c ****     LOG_CREATE_BINARY_SEMAPHORE(s_logReadWaitSemaphore);
 290:../utilities/fsl_log.c **** 
 291:../utilities/fsl_log.c ****     return kStatus_Success;
 292:../utilities/fsl_log.c **** }
 293:../utilities/fsl_log.c **** 
 294:../utilities/fsl_log.c **** void LOG_Deinit(void)
 295:../utilities/fsl_log.c **** {
 296:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 297:../utilities/fsl_log.c ****     /* memset the global queue */
 298:../utilities/fsl_log.c ****     memset(&s_log_buffer, 0U, sizeof(s_log_buffer));
 299:../utilities/fsl_log.c **** #endif /*DEBUG_CONSOLE_TRANSFER_NON_BLOCKING*/
 300:../utilities/fsl_log.c ****     /* Deinit IO */
 301:../utilities/fsl_log.c ****     IO_Deinit();
 302:../utilities/fsl_log.c **** }
 303:../utilities/fsl_log.c **** 
 304:../utilities/fsl_log.c **** status_t LOG_WaitIdle(void)
 305:../utilities/fsl_log.c **** {
 306:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 307:../utilities/fsl_log.c ****     /* wait buffer empty */
 308:../utilities/fsl_log.c ****     while (!(s_log_buffer.totalIndex == 0U))
 309:../utilities/fsl_log.c ****         ;
 310:../utilities/fsl_log.c **** #endif /*DEBUG_CONSOLE_TRANSFER_NON_BLOCKING*/
 311:../utilities/fsl_log.c ****     /* wait IO idle */
 312:../utilities/fsl_log.c ****     IO_WaitIdle();
 313:../utilities/fsl_log.c **** 
 314:../utilities/fsl_log.c ****     return kStatus_Success;
 315:../utilities/fsl_log.c **** }
 316:../utilities/fsl_log.c **** 
 317:../utilities/fsl_log.c **** int LOG_Push(uint8_t *buf, size_t size)
 318:../utilities/fsl_log.c **** {
 319:../utilities/fsl_log.c ****     assert(buf != NULL);
 320:../utilities/fsl_log.c **** 
 321:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 322:../utilities/fsl_log.c ****     /* push to buffer */
 323:../utilities/fsl_log.c ****     LOG_BufPush(buf, size);
 324:../utilities/fsl_log.c ****     buf = LOG_BufGetNextAvaliableLog(&size);
 325:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
 326:../utilities/fsl_log.c ****     /* pop log */
 327:../utilities/fsl_log.c ****     return LOG_Pop(buf, size);
 328:../utilities/fsl_log.c **** }
 329:../utilities/fsl_log.c **** 
 330:../utilities/fsl_log.c **** int LOG_Pop(uint8_t *buf, size_t size)
 331:../utilities/fsl_log.c **** {
 332:../utilities/fsl_log.c ****     uint8_t getLock = 0U;
 333:../utilities/fsl_log.c **** 
 334:../utilities/fsl_log.c ****     if ((0 != size) && (NULL != buf))
 335:../utilities/fsl_log.c ****     {
 336:../utilities/fsl_log.c ****         /* take POP lock, should be non-blocking */
 337:../utilities/fsl_log.c ****         LOG_TAKE_MUTEX_SEMAPHORE_NONBLOCKING(s_logPopSemaphore, getLock);
 338:../utilities/fsl_log.c **** 
 339:../utilities/fsl_log.c ****         if (getLock)
 340:../utilities/fsl_log.c ****         {
 341:../utilities/fsl_log.c ****             /* call IO transfer function */
 342:../utilities/fsl_log.c ****             if (IO_Transfer(buf, size, true) != kStatus_Success)
 343:../utilities/fsl_log.c ****             {
 344:../utilities/fsl_log.c ****                 size = 0U;
 345:../utilities/fsl_log.c ****             }
 346:../utilities/fsl_log.c ****             /* release POP lock */
 347:../utilities/fsl_log.c ****             LOG_GIVE_MUTEX_SEMAPHORE(s_logPopSemaphore);
 348:../utilities/fsl_log.c ****         }
 349:../utilities/fsl_log.c ****     }
 350:../utilities/fsl_log.c **** 
 351:../utilities/fsl_log.c ****     return size;
 352:../utilities/fsl_log.c **** }
 353:../utilities/fsl_log.c **** 
 354:../utilities/fsl_log.c **** int LOG_ReadLine(uint8_t *buf, size_t size)
 355:../utilities/fsl_log.c **** {
 356:../utilities/fsl_log.c ****     assert(buf != NULL);
 357:../utilities/fsl_log.c **** 
 358:../utilities/fsl_log.c ****     int i = 0;
 359:../utilities/fsl_log.c **** 
 360:../utilities/fsl_log.c ****     /* take mutex lock function */
 361:../utilities/fsl_log.c ****     LOG_TAKE_MUTEX_SEMAPHORE_BLOCKING(s_logReadSemaphore);
 362:../utilities/fsl_log.c **** 
 363:../utilities/fsl_log.c ****     for (i = 0; i < size; i++)
 364:../utilities/fsl_log.c ****     {
 365:../utilities/fsl_log.c ****         /* recieve one char every time */
 366:../utilities/fsl_log.c ****         if (LOG_ReadOneCharacter(&buf[i]) != kStatus_Success)
 367:../utilities/fsl_log.c ****         {
 368:../utilities/fsl_log.c ****             return -1;
 369:../utilities/fsl_log.c ****         }
 370:../utilities/fsl_log.c **** #if DEBUG_CONSOLE_ENABLE_ECHO_FUNCTION
 371:../utilities/fsl_log.c ****         LOG_EchoCharacter(&buf[i], false, &i);
 372:../utilities/fsl_log.c **** #endif
 373:../utilities/fsl_log.c ****         /* analysis data */
 374:../utilities/fsl_log.c ****         if ((buf[i] == '\r') || (buf[i] == '\n'))
 375:../utilities/fsl_log.c ****         {
 376:../utilities/fsl_log.c ****             /* End of Line. */
 377:../utilities/fsl_log.c ****             if (i == 0)
 378:../utilities/fsl_log.c ****             {
 379:../utilities/fsl_log.c ****                 buf[i] = '\0';
 380:../utilities/fsl_log.c ****                 i = -1;
 381:../utilities/fsl_log.c ****             }
 382:../utilities/fsl_log.c ****             else
 383:../utilities/fsl_log.c ****             {
 384:../utilities/fsl_log.c ****                 break;
 385:../utilities/fsl_log.c ****             }
 386:../utilities/fsl_log.c ****         }
 387:../utilities/fsl_log.c ****     }
 388:../utilities/fsl_log.c ****     /* get char should not add '\0'*/
 389:../utilities/fsl_log.c ****     if (i == size)
 390:../utilities/fsl_log.c ****     {
 391:../utilities/fsl_log.c ****         buf[i] = '\0';
 392:../utilities/fsl_log.c ****     }
 393:../utilities/fsl_log.c ****     else
 394:../utilities/fsl_log.c ****     {
 395:../utilities/fsl_log.c ****         buf[i + 1] = '\0';
 396:../utilities/fsl_log.c ****     }
 397:../utilities/fsl_log.c **** 
 398:../utilities/fsl_log.c ****     /* release mutex lock function */
 399:../utilities/fsl_log.c ****     LOG_GIVE_MUTEX_SEMAPHORE(s_logReadSemaphore);
 400:../utilities/fsl_log.c **** 
 401:../utilities/fsl_log.c ****     return i;
 402:../utilities/fsl_log.c **** }
 403:../utilities/fsl_log.c **** 
 404:../utilities/fsl_log.c **** int LOG_ReadCharacter(uint8_t *ch)
 405:../utilities/fsl_log.c **** {
 406:../utilities/fsl_log.c ****     assert(ch != NULL);
 407:../utilities/fsl_log.c ****     int ret = 0;
 408:../utilities/fsl_log.c **** 
 409:../utilities/fsl_log.c ****     /* take mutex lock function */
 410:../utilities/fsl_log.c ****     LOG_TAKE_MUTEX_SEMAPHORE_BLOCKING(s_logReadSemaphore);
 411:../utilities/fsl_log.c ****     /* read one character */
 412:../utilities/fsl_log.c ****     if (LOG_ReadOneCharacter(ch) == kStatus_Success)
 413:../utilities/fsl_log.c ****     {
 414:../utilities/fsl_log.c ****         ret = 1;
 415:../utilities/fsl_log.c **** #if DEBUG_CONSOLE_ENABLE_ECHO_FUNCTION
 416:../utilities/fsl_log.c ****         LOG_EchoCharacter(ch, true, NULL);
 417:../utilities/fsl_log.c **** #endif
 418:../utilities/fsl_log.c ****     }
 419:../utilities/fsl_log.c ****     else
 420:../utilities/fsl_log.c ****     {
 421:../utilities/fsl_log.c ****         ret = -1;
 422:../utilities/fsl_log.c ****     }
 423:../utilities/fsl_log.c **** 
 424:../utilities/fsl_log.c ****     /* release mutex lock function */
 425:../utilities/fsl_log.c ****     LOG_GIVE_MUTEX_SEMAPHORE(s_logReadSemaphore);
 426:../utilities/fsl_log.c **** 
 427:../utilities/fsl_log.c ****     return ret;
 428:../utilities/fsl_log.c **** }
 429:../utilities/fsl_log.c **** 
 430:../utilities/fsl_log.c **** static status_t LOG_ReadOneCharacter(uint8_t *ch)
 431:../utilities/fsl_log.c **** {
  25              		.loc 1 431 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 10B5     		push	{r4, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
 432:../utilities/fsl_log.c ****     /* recieve one char every time */
 433:../utilities/fsl_log.c ****     if (IO_Transfer(ch, 1U, false) != kStatus_Success)
  34              		.loc 1 433 0
  35 0002 0022     		movs	r2, #0
  36 0004 0121     		movs	r1, #1
  37 0006 FFF7FEFF 		bl	IO_Transfer
  38              	.LVL1:
  39 000a 0028     		cmp	r0, #0
  40 000c 00D1     		bne	.L3
  41              	.L1:
 434:../utilities/fsl_log.c ****     {
 435:../utilities/fsl_log.c ****         return kStatus_Fail;
 436:../utilities/fsl_log.c ****     }
 437:../utilities/fsl_log.c **** 
 438:../utilities/fsl_log.c ****     /* wait release from ISR */
 439:../utilities/fsl_log.c ****     LOG_TAKE_BINARY_SEMAPHORE_BLOCKING(s_logReadWaitSemaphore);
 440:../utilities/fsl_log.c **** 
 441:../utilities/fsl_log.c ****     return kStatus_Success;
 442:../utilities/fsl_log.c **** }
  42              		.loc 1 442 0
  43              		@ sp needed
  44 000e 10BD     		pop	{r4, pc}
  45              	.L3:
 435:../utilities/fsl_log.c ****     }
  46              		.loc 1 435 0
  47 0010 0120     		movs	r0, #1
  48 0012 FCE7     		b	.L1
  49              		.cfi_endproc
  50              	.LFE60:
  52              		.section	.text.LOG_Init,"ax",%progbits
  53              		.align	1
  54              		.global	LOG_Init
  55              		.syntax unified
  56              		.code	16
  57              		.thumb_func
  58              		.fpu softvfp
  60              	LOG_Init:
  61              	.LFB53:
 266:../utilities/fsl_log.c ****     io_state_t io;
  62              		.loc 1 266 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              	.LVL2:
  67 0000 10B5     		push	{r4, lr}
  68              		.cfi_def_cfa_offset 8
  69              		.cfi_offset 4, -8
  70              		.cfi_offset 14, -4
  71 0002 82B0     		sub	sp, sp, #8
  72              		.cfi_def_cfa_offset 16
  73 0004 1400     		movs	r4, r2
  74 0006 1A00     		movs	r2, r3
  75              	.LVL3:
 269:../utilities/fsl_log.c ****     io.ioType = device;
  76              		.loc 1 269 0
  77 0008 0090     		str	r0, [sp]
 270:../utilities/fsl_log.c **** 
  78              		.loc 1 270 0
  79 000a 6B46     		mov	r3, sp
  80              	.LVL4:
  81 000c 1971     		strb	r1, [r3, #4]
 284:../utilities/fsl_log.c **** #endif /* DEBUG_CONSOLE_TRANSFER_NON_BLOCKING */
  82              		.loc 1 284 0
  83 000e 0023     		movs	r3, #0
  84 0010 2100     		movs	r1, r4
  85              	.LVL5:
  86 0012 6846     		mov	r0, sp
  87              	.LVL6:
  88 0014 FFF7FEFF 		bl	IO_Init
  89              	.LVL7:
 292:../utilities/fsl_log.c **** 
  90              		.loc 1 292 0
  91 0018 0020     		movs	r0, #0
  92 001a 02B0     		add	sp, sp, #8
  93              		@ sp needed
  94              	.LVL8:
  95 001c 10BD     		pop	{r4, pc}
  96              		.cfi_endproc
  97              	.LFE53:
  99              		.section	.text.LOG_Deinit,"ax",%progbits
 100              		.align	1
 101              		.global	LOG_Deinit
 102              		.syntax unified
 103              		.code	16
 104              		.thumb_func
 105              		.fpu softvfp
 107              	LOG_Deinit:
 108              	.LFB54:
 295:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 109              		.loc 1 295 0
 110              		.cfi_startproc
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
 113 0000 10B5     		push	{r4, lr}
 114              		.cfi_def_cfa_offset 8
 115              		.cfi_offset 4, -8
 116              		.cfi_offset 14, -4
 301:../utilities/fsl_log.c **** }
 117              		.loc 1 301 0
 118 0002 FFF7FEFF 		bl	IO_Deinit
 119              	.LVL9:
 302:../utilities/fsl_log.c **** 
 120              		.loc 1 302 0
 121              		@ sp needed
 122 0006 10BD     		pop	{r4, pc}
 123              		.cfi_endproc
 124              	.LFE54:
 126              		.section	.text.LOG_WaitIdle,"ax",%progbits
 127              		.align	1
 128              		.global	LOG_WaitIdle
 129              		.syntax unified
 130              		.code	16
 131              		.thumb_func
 132              		.fpu softvfp
 134              	LOG_WaitIdle:
 135              	.LFB55:
 305:../utilities/fsl_log.c **** #ifdef DEBUG_CONSOLE_TRANSFER_NON_BLOCKING
 136              		.loc 1 305 0
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 0
 139              		@ frame_needed = 0, uses_anonymous_args = 0
 140 0000 10B5     		push	{r4, lr}
 141              		.cfi_def_cfa_offset 8
 142              		.cfi_offset 4, -8
 143              		.cfi_offset 14, -4
 312:../utilities/fsl_log.c **** 
 144              		.loc 1 312 0
 145 0002 FFF7FEFF 		bl	IO_WaitIdle
 146              	.LVL10:
 315:../utilities/fsl_log.c **** 
 147              		.loc 1 315 0
 148 0006 0020     		movs	r0, #0
 149              		@ sp needed
 150 0008 10BD     		pop	{r4, pc}
 151              		.cfi_endproc
 152              	.LFE55:
 154              		.section	.text.LOG_Pop,"ax",%progbits
 155              		.align	1
 156              		.global	LOG_Pop
 157              		.syntax unified
 158              		.code	16
 159              		.thumb_func
 160              		.fpu softvfp
 162              	LOG_Pop:
 163              	.LFB57:
 331:../utilities/fsl_log.c ****     uint8_t getLock = 0U;
 164              		.loc 1 331 0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 0, uses_anonymous_args = 0
 168              	.LVL11:
 169 0000 10B5     		push	{r4, lr}
 170              		.cfi_def_cfa_offset 8
 171              		.cfi_offset 4, -8
 172              		.cfi_offset 14, -4
 173 0002 0C1E     		subs	r4, r1, #0
 174              	.LVL12:
 334:../utilities/fsl_log.c ****     {
 175              		.loc 1 334 0
 176 0004 07D0     		beq	.L8
 334:../utilities/fsl_log.c ****     {
 177              		.loc 1 334 0 is_stmt 0 discriminator 1
 178 0006 0028     		cmp	r0, #0
 179 0008 05D0     		beq	.L8
 180              	.LVL13:
 342:../utilities/fsl_log.c ****             {
 181              		.loc 1 342 0 is_stmt 1
 182 000a 0122     		movs	r2, #1
 183 000c FFF7FEFF 		bl	IO_Transfer
 184              	.LVL14:
 185 0010 0028     		cmp	r0, #0
 186 0012 00D0     		beq	.L8
 344:../utilities/fsl_log.c ****             }
 187              		.loc 1 344 0
 188 0014 0024     		movs	r4, #0
 189              	.LVL15:
 190              	.L8:
 352:../utilities/fsl_log.c **** 
 191              		.loc 1 352 0
 192 0016 2000     		movs	r0, r4
 193              		@ sp needed
 194              	.LVL16:
 195 0018 10BD     		pop	{r4, pc}
 196              		.cfi_endproc
 197              	.LFE57:
 199              		.section	.text.LOG_Push,"ax",%progbits
 200              		.align	1
 201              		.global	LOG_Push
 202              		.syntax unified
 203              		.code	16
 204              		.thumb_func
 205              		.fpu softvfp
 207              	LOG_Push:
 208              	.LFB56:
 318:../utilities/fsl_log.c ****     assert(buf != NULL);
 209              		.loc 1 318 0
 210              		.cfi_startproc
 211              		@ args = 0, pretend = 0, frame = 0
 212              		@ frame_needed = 0, uses_anonymous_args = 0
 213              	.LVL17:
 214 0000 10B5     		push	{r4, lr}
 215              		.cfi_def_cfa_offset 8
 216              		.cfi_offset 4, -8
 217              		.cfi_offset 14, -4
 327:../utilities/fsl_log.c **** }
 218              		.loc 1 327 0
 219 0002 FFF7FEFF 		bl	LOG_Pop
 220              	.LVL18:
 328:../utilities/fsl_log.c **** 
 221              		.loc 1 328 0
 222              		@ sp needed
 223 0006 10BD     		pop	{r4, pc}
 224              		.cfi_endproc
 225              	.LFE56:
 227              		.section	.text.LOG_ReadLine,"ax",%progbits
 228              		.align	1
 229              		.global	LOG_ReadLine
 230              		.syntax unified
 231              		.code	16
 232              		.thumb_func
 233              		.fpu softvfp
 235              	LOG_ReadLine:
 236              	.LFB58:
 355:../utilities/fsl_log.c ****     assert(buf != NULL);
 237              		.loc 1 355 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 8
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              	.LVL19:
 242 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 243              		.cfi_def_cfa_offset 20
 244              		.cfi_offset 4, -20
 245              		.cfi_offset 5, -16
 246              		.cfi_offset 6, -12
 247              		.cfi_offset 7, -8
 248              		.cfi_offset 14, -4
 249 0002 83B0     		sub	sp, sp, #12
 250              		.cfi_def_cfa_offset 32
 251 0004 0700     		movs	r7, r0
 252 0006 0E00     		movs	r6, r1
 253              	.LVL20:
 363:../utilities/fsl_log.c ****     {
 254              		.loc 1 363 0
 255 0008 0024     		movs	r4, #0
 256 000a 05E0     		b	.L12
 257              	.LVL21:
 258              	.L14:
 377:../utilities/fsl_log.c ****             {
 259              		.loc 1 377 0
 260 000c 002C     		cmp	r4, #0
 261 000e 12D1     		bne	.L16
 379:../utilities/fsl_log.c ****                 i = -1;
 262              		.loc 1 379 0
 263 0010 0023     		movs	r3, #0
 264 0012 2B70     		strb	r3, [r5]
 265              	.LVL22:
 380:../utilities/fsl_log.c ****             }
 266              		.loc 1 380 0
 267 0014 013C     		subs	r4, r4, #1
 268              	.LVL23:
 269              	.L15:
 363:../utilities/fsl_log.c ****     {
 270              		.loc 1 363 0 discriminator 2
 271 0016 0134     		adds	r4, r4, #1
 272              	.LVL24:
 273              	.L12:
 363:../utilities/fsl_log.c ****     {
 274              		.loc 1 363 0 is_stmt 0 discriminator 1
 275 0018 0194     		str	r4, [sp, #4]
 276 001a B442     		cmp	r4, r6
 277 001c 0BD2     		bcs	.L16
 366:../utilities/fsl_log.c ****         {
 278              		.loc 1 366 0 is_stmt 1
 279 001e 3D19     		adds	r5, r7, r4
 280 0020 2800     		movs	r0, r5
 281 0022 FFF7FEFF 		bl	LOG_ReadOneCharacter
 282              	.LVL25:
 283 0026 0028     		cmp	r0, #0
 284 0028 14D1     		bne	.L19
 374:../utilities/fsl_log.c ****         {
 285              		.loc 1 374 0
 286 002a 2B78     		ldrb	r3, [r5]
 287 002c 0D2B     		cmp	r3, #13
 288 002e EDD0     		beq	.L14
 374:../utilities/fsl_log.c ****         {
 289              		.loc 1 374 0 is_stmt 0 discriminator 1
 290 0030 0A2B     		cmp	r3, #10
 291 0032 F0D1     		bne	.L15
 292 0034 EAE7     		b	.L14
 293              	.L16:
 389:../utilities/fsl_log.c ****     {
 294              		.loc 1 389 0 is_stmt 1
 295 0036 019B     		ldr	r3, [sp, #4]
 296 0038 B342     		cmp	r3, r6
 297 003a 07D0     		beq	.L20
 395:../utilities/fsl_log.c ****     }
 298              		.loc 1 395 0
 299 003c 019E     		ldr	r6, [sp, #4]
 300              	.LVL26:
 301 003e 0136     		adds	r6, r6, #1
 302 0040 BE19     		adds	r6, r7, r6
 303 0042 0023     		movs	r3, #0
 304 0044 3370     		strb	r3, [r6]
 305              	.LVL27:
 306              	.L11:
 402:../utilities/fsl_log.c **** 
 307              		.loc 1 402 0
 308 0046 2000     		movs	r0, r4
 309 0048 03B0     		add	sp, sp, #12
 310              		@ sp needed
 311              	.LVL28:
 312 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 313              	.LVL29:
 314              	.L20:
 391:../utilities/fsl_log.c ****     }
 315              		.loc 1 391 0
 316 004c FE18     		adds	r6, r7, r3
 317              	.LVL30:
 318 004e 0023     		movs	r3, #0
 319 0050 3370     		strb	r3, [r6]
 320 0052 F8E7     		b	.L11
 321              	.LVL31:
 322              	.L19:
 368:../utilities/fsl_log.c ****         }
 323              		.loc 1 368 0
 324 0054 0124     		movs	r4, #1
 325              	.LVL32:
 326 0056 6442     		rsbs	r4, r4, #0
 327 0058 F5E7     		b	.L11
 328              		.cfi_endproc
 329              	.LFE58:
 331              		.section	.text.LOG_ReadCharacter,"ax",%progbits
 332              		.align	1
 333              		.global	LOG_ReadCharacter
 334              		.syntax unified
 335              		.code	16
 336              		.thumb_func
 337              		.fpu softvfp
 339              	LOG_ReadCharacter:
 340              	.LFB59:
 405:../utilities/fsl_log.c ****     assert(ch != NULL);
 341              		.loc 1 405 0
 342              		.cfi_startproc
 343              		@ args = 0, pretend = 0, frame = 0
 344              		@ frame_needed = 0, uses_anonymous_args = 0
 345              	.LVL33:
 346 0000 10B5     		push	{r4, lr}
 347              		.cfi_def_cfa_offset 8
 348              		.cfi_offset 4, -8
 349              		.cfi_offset 14, -4
 350              	.LVL34:
 412:../utilities/fsl_log.c ****     {
 351              		.loc 1 412 0
 352 0002 FFF7FEFF 		bl	LOG_ReadOneCharacter
 353              	.LVL35:
 354 0006 0028     		cmp	r0, #0
 355 0008 01D1     		bne	.L23
 414:../utilities/fsl_log.c **** #if DEBUG_CONSOLE_ENABLE_ECHO_FUNCTION
 356              		.loc 1 414 0
 357 000a 0130     		adds	r0, r0, #1
 358              	.LVL36:
 359              	.L21:
 428:../utilities/fsl_log.c **** 
 360              		.loc 1 428 0
 361              		@ sp needed
 362 000c 10BD     		pop	{r4, pc}
 363              	.LVL37:
 364              	.L23:
 421:../utilities/fsl_log.c ****     }
 365              		.loc 1 421 0
 366 000e 0120     		movs	r0, #1
 367 0010 4042     		rsbs	r0, r0, #0
 368              	.LVL38:
 427:../utilities/fsl_log.c **** }
 369              		.loc 1 427 0
 370 0012 FBE7     		b	.L21
 371              		.cfi_endproc
 372              	.LFE59:
 374              		.text
 375              	.Letext0:
 376              		.file 2 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h"
 377              		.file 3 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 378              		.file 4 "/opt/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 379              		.file 5 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 380              		.file 6 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 381              		.file 7 "/opt/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 382              		.file 8 "../CMSIS/system_MKL17Z4.h"
 383              		.file 9 "../drivers/fsl_common.h"
 384              		.file 10 "../drivers/fsl_clock.h"
 385              		.file 11 "../utilities/fsl_io.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_log.c
     /tmp/ccvmcRZL.s:16     .text.LOG_ReadOneCharacter:0000000000000000 $t
     /tmp/ccvmcRZL.s:22     .text.LOG_ReadOneCharacter:0000000000000000 LOG_ReadOneCharacter
     /tmp/ccvmcRZL.s:53     .text.LOG_Init:0000000000000000 $t
     /tmp/ccvmcRZL.s:60     .text.LOG_Init:0000000000000000 LOG_Init
     /tmp/ccvmcRZL.s:100    .text.LOG_Deinit:0000000000000000 $t
     /tmp/ccvmcRZL.s:107    .text.LOG_Deinit:0000000000000000 LOG_Deinit
     /tmp/ccvmcRZL.s:127    .text.LOG_WaitIdle:0000000000000000 $t
     /tmp/ccvmcRZL.s:134    .text.LOG_WaitIdle:0000000000000000 LOG_WaitIdle
     /tmp/ccvmcRZL.s:155    .text.LOG_Pop:0000000000000000 $t
     /tmp/ccvmcRZL.s:162    .text.LOG_Pop:0000000000000000 LOG_Pop
     /tmp/ccvmcRZL.s:200    .text.LOG_Push:0000000000000000 $t
     /tmp/ccvmcRZL.s:207    .text.LOG_Push:0000000000000000 LOG_Push
     /tmp/ccvmcRZL.s:228    .text.LOG_ReadLine:0000000000000000 $t
     /tmp/ccvmcRZL.s:235    .text.LOG_ReadLine:0000000000000000 LOG_ReadLine
     /tmp/ccvmcRZL.s:332    .text.LOG_ReadCharacter:0000000000000000 $t
     /tmp/ccvmcRZL.s:339    .text.LOG_ReadCharacter:0000000000000000 LOG_ReadCharacter

UNDEFINED SYMBOLS
IO_Transfer
IO_Init
IO_Deinit
IO_WaitIdle
